record_number,buggy_code,fixed_code
13001,"public static void preRegister(final Context context,final String programName,final PrintWriter errWriter,final PrintWriter warnWriter,final PrintWriter noticeWriter){
  context.put(logKey,new Context.Factory<Log>(){
    public Log make(){
      return new Messager(context,programName,errWriter,warnWriter,noticeWriter);
    }
  }
);
}","public static void preRegister(Context context,final String programName,final PrintWriter errWriter,final PrintWriter warnWriter,final PrintWriter noticeWriter){
  context.put(logKey,new Context.Factory<Log>(){
    public Log make(    Context c){
      return new Messager(c,programName,errWriter,warnWriter,noticeWriter);
    }
  }
);
}"
13002,"public JavacMessages make(){
  return new ArgTypeMessages(c){
    @Override public String getLocalizedString(    Locale l,    String key,    Object... args){
      return getKeyArgsString(key,args);
    }
  }
;
}","public JavacMessages make(Context c){
  return new ArgTypeMessages(c){
    @Override public String getLocalizedString(    Locale l,    String key,    Object... args){
      return getKeyArgsString(key,args);
    }
  }
;
}"
13003,"static void preRegister(final Context c){
  c.put(JavacMessages.messagesKey,new Context.Factory<JavacMessages>(){
    public JavacMessages make(){
      return new ArgTypeMessages(c){
        @Override public String getLocalizedString(        Locale l,        String key,        Object... args){
          return getKeyArgsString(key,args);
        }
      }
;
    }
  }
);
}","static void preRegister(Context context){
  context.put(JavacMessages.messagesKey,new Context.Factory<JavacMessages>(){
    public JavacMessages make(    Context c){
      return new ArgTypeMessages(c){
        @Override public String getLocalizedString(        Locale l,        String key,        Object... args){
          return getKeyArgsString(key,args);
        }
      }
;
    }
  }
);
}"
13004,"public JavacMessages make(){
  return new MessageTracker(c){
    @Override public String getLocalizedString(    Locale l,    String key,    Object... args){
      keys.add(key);
      return super.getLocalizedString(l,key,args);
    }
  }
;
}","public JavacMessages make(Context c){
  return new MessageTracker(c){
    @Override public String getLocalizedString(    Locale l,    String key,    Object... args){
      keys.add(key);
      return super.getLocalizedString(l,key,args);
    }
  }
;
}"
13005,"static void preRegister(final Context c,final Set<String> keys){
  if (keys != null) {
    c.put(JavacMessages.messagesKey,new Context.Factory<JavacMessages>(){
      public JavacMessages make(){
        return new MessageTracker(c){
          @Override public String getLocalizedString(          Locale l,          String key,          Object... args){
            keys.add(key);
            return super.getLocalizedString(l,key,args);
          }
        }
;
      }
    }
);
  }
}","static void preRegister(Context c,final Set<String> keys){
  if (keys != null) {
    c.put(JavacMessages.messagesKey,new Context.Factory<JavacMessages>(){
      public JavacMessages make(      Context c){
        return new MessageTracker(c){
          @Override public String getLocalizedString(          Locale l,          String key,          Object... args){
            keys.add(key);
            return super.getLocalizedString(l,key,args);
          }
        }
;
      }
    }
);
  }
}"
13006,"protected Scope(Symbol owner,ScopeCounter scopeCounter){
  this(null,owner,new Entry[INITIAL_SIZE],scopeCounter);
}","protected Scope(Symbol owner,ScopeCounter scopeCounter){
  this(null,owner,new Entry[INITIAL_SIZE],scopeCounter);
  for (int i=0; i < INITIAL_SIZE; i++)   table[i]=sentinel;
}"
13007,"public Entry next(){
  Entry e=super.shadowed;
  while (e.scope != null && (e.sym.name != sym.name || e.sym.owner != e.scope.owner))   e=e.shadowed;
  return e;
}","public Entry next(){
  Entry e=super.shadowed;
  while (isBogus())   e=e.shadowed;
  return e;
}"
13008,"protected Scope(Symbol owner,ScopeCounter scopeCounter){
  this(null,owner,new Entry[INITIAL_SIZE],scopeCounter);
  for (int i=0; i < INITIAL_SIZE; i++)   table[i]=sentinel;
}","protected Scope(Symbol owner,ScopeCounter scopeCounter){
  this(null,owner,new Entry[INITIAL_SIZE],scopeCounter);
}"
13009,"@Override public void write(int b) throws IOException {
  size++;
}","@Override public void write(int b){
  size++;
}"
13010,"public int byteLength(){
class SizeOutputStream extends OutputStream {
    @Override public void write(    int b) throws IOException {
      size++;
    }
    int size;
  }
  SizeOutputStream sizeOut=new SizeOutputStream();
  DataOutputStream out=new DataOutputStream(sizeOut);
  try {
    out.writeUTF(value);
  }
 catch (  IOException ignore) {
  }
  return 1 + sizeOut.size;
}","public int byteLength(){
class SizeOutputStream extends OutputStream {
    @Override public void write(    int b){
      size++;
    }
    int size;
  }
  SizeOutputStream sizeOut=new SizeOutputStream();
  DataOutputStream out=new DataOutputStream(sizeOut);
  try {
    out.writeUTF(value);
  }
 catch (  IOException ignore) {
  }
  return 1 + sizeOut.size;
}"
13011,"/** 
 * Constructor
 * @param context      Context for this javadoc instance.
 */
private DocEnv(Context context){
  context.put(docEnvKey,this);
  messager=Messager.instance0(context);
  syms=Symtab.instance(context);
  reader=JavadocClassReader.instance0(context);
  enter=JavadocEnter.instance0(context);
  attr=Attr.instance(context);
  names=Names.instance(context);
  externalizableSym=reader.enterClass(names.fromString(""String_Node_Str""));
  chk=Check.instance(context);
  types=Types.instance(context);
  fileManager=context.get(JavaFileManager.class);
  this.doclocale=new DocLocale(this,""String_Node_Str"",breakiterator);
}","/** 
 * Constructor
 * @param context      Context for this javadoc instance.
 */
private DocEnv(Context context){
  context.put(docEnvKey,this);
  messager=Messager.instance0(context);
  syms=Symtab.instance(context);
  reader=JavadocClassReader.instance0(context);
  enter=JavadocEnter.instance0(context);
  names=Names.instance(context);
  externalizableSym=reader.enterClass(names.fromString(""String_Node_Str""));
  chk=Check.instance(context);
  types=Types.instance(context);
  fileManager=context.get(JavaFileManager.class);
  this.doclocale=new DocLocale(this,""String_Node_Str"",breakiterator);
}"
13012,"/** 
 * Default class enter visitor method: do nothing.
 */
public void visitTree(JCTree tree){
  result=null;
}","/** 
 * Default class enter visitor method: do nothing.
 */
@Override public void visitTree(JCTree tree){
  result=null;
}"
13013,"public void visitClassDef(JCClassDecl tree){
  Symbol owner=env.info.scope.owner;
  Scope enclScope=enterScope(env);
  ClassSymbol c;
  if (owner.kind == PCK) {
    PackageSymbol packge=(PackageSymbol)owner;
    for (Symbol q=packge; q != null && q.kind == PCK; q=q.owner)     q.flags_field|=EXISTS;
    c=reader.enterClass(tree.name,packge);
    packge.members().enterIfAbsent(c);
    if ((tree.mods.flags & PUBLIC) != 0 && !classNameMatchesFileName(c,env)) {
      log.error(tree.pos(),""String_Node_Str"",tree.name);
    }
  }
 else {
    if (!tree.name.isEmpty() && !chk.checkUniqueClassName(tree.pos(),tree.name,enclScope)) {
      result=null;
      return;
    }
    if (owner.kind == TYP) {
      c=reader.enterClass(tree.name,(TypeSymbol)owner);
      if ((owner.flags_field & INTERFACE) != 0) {
        tree.mods.flags|=PUBLIC | STATIC;
      }
    }
 else {
      c=reader.defineClass(tree.name,owner);
      c.flatname=chk.localClassName(c);
      if (!c.name.isEmpty())       chk.checkTransparentClass(tree.pos(),c,env.info.scope);
    }
  }
  tree.sym=c;
  if (chk.compiled.get(c.flatname) != null) {
    duplicateClass(tree.pos(),c);
    result=types.createErrorType(tree.name,(TypeSymbol)owner,Type.noType);
    tree.sym=(ClassSymbol)result.tsym;
    return;
  }
  chk.compiled.put(c.flatname,c);
  enclScope.enter(c);
  Env<AttrContext> localEnv=classEnv(tree,env);
  typeEnvs.put(c,localEnv);
  c.completer=memberEnter;
  c.flags_field=chk.checkFlags(tree.pos(),tree.mods.flags,c,tree);
  c.sourcefile=env.toplevel.sourcefile;
  c.members_field=new Scope(c);
  ClassType ct=(ClassType)c.type;
  if (owner.kind != PCK && (c.flags_field & STATIC) == 0) {
    Symbol owner1=owner;
    while ((owner1.kind & (VAR | MTH)) != 0 && (owner1.flags_field & STATIC) == 0) {
      owner1=owner1.owner;
    }
    if (owner1.kind == TYP) {
      ct.setEnclosingType(owner1.type);
    }
  }
  ct.typarams_field=classEnter(tree.typarams,localEnv);
  if (!c.isLocal() && uncompleted != null)   uncompleted.append(c);
  classEnter(tree.defs,localEnv);
  result=c.type;
}","@Override public void visitClassDef(JCClassDecl tree){
  Symbol owner=env.info.scope.owner;
  Scope enclScope=enterScope(env);
  ClassSymbol c;
  if (owner.kind == PCK) {
    PackageSymbol packge=(PackageSymbol)owner;
    for (Symbol q=packge; q != null && q.kind == PCK; q=q.owner)     q.flags_field|=EXISTS;
    c=reader.enterClass(tree.name,packge);
    packge.members().enterIfAbsent(c);
    if ((tree.mods.flags & PUBLIC) != 0 && !classNameMatchesFileName(c,env)) {
      log.error(tree.pos(),""String_Node_Str"",tree.name);
    }
  }
 else {
    if (!tree.name.isEmpty() && !chk.checkUniqueClassName(tree.pos(),tree.name,enclScope)) {
      result=null;
      return;
    }
    if (owner.kind == TYP) {
      c=reader.enterClass(tree.name,(TypeSymbol)owner);
      if ((owner.flags_field & INTERFACE) != 0) {
        tree.mods.flags|=PUBLIC | STATIC;
      }
    }
 else {
      c=reader.defineClass(tree.name,owner);
      c.flatname=chk.localClassName(c);
      if (!c.name.isEmpty())       chk.checkTransparentClass(tree.pos(),c,env.info.scope);
    }
  }
  tree.sym=c;
  if (chk.compiled.get(c.flatname) != null) {
    duplicateClass(tree.pos(),c);
    result=types.createErrorType(tree.name,(TypeSymbol)owner,Type.noType);
    tree.sym=(ClassSymbol)result.tsym;
    return;
  }
  chk.compiled.put(c.flatname,c);
  enclScope.enter(c);
  Env<AttrContext> localEnv=classEnv(tree,env);
  typeEnvs.put(c,localEnv);
  c.completer=memberEnter;
  c.flags_field=chk.checkFlags(tree.pos(),tree.mods.flags,c,tree);
  c.sourcefile=env.toplevel.sourcefile;
  c.members_field=new Scope(c);
  ClassType ct=(ClassType)c.type;
  if (owner.kind != PCK && (c.flags_field & STATIC) == 0) {
    Symbol owner1=owner;
    while ((owner1.kind & (VAR | MTH)) != 0 && (owner1.flags_field & STATIC) == 0) {
      owner1=owner1.owner;
    }
    if (owner1.kind == TYP) {
      ct.setEnclosingType(owner1.type);
    }
  }
  ct.typarams_field=classEnter(tree.typarams,localEnv);
  if (!c.isLocal() && uncompleted != null)   uncompleted.append(c);
  classEnter(tree.defs,localEnv);
  result=c.type;
}"
13014,"public void visitTopLevel(JCCompilationUnit tree){
  JavaFileObject prev=log.useSource(tree.sourcefile);
  boolean addEnv=false;
  boolean isPkgInfo=tree.sourcefile.isNameCompatible(""String_Node_Str"",JavaFileObject.Kind.SOURCE);
  if (tree.pid != null) {
    tree.packge=reader.enterPackage(TreeInfo.fullName(tree.pid));
    if (tree.packageAnnotations.nonEmpty()) {
      if (isPkgInfo) {
        addEnv=true;
      }
 else {
        log.error(tree.packageAnnotations.head.pos(),""String_Node_Str"");
      }
    }
  }
 else {
    tree.packge=syms.unnamedPackage;
  }
  tree.packge.complete();
  Env<AttrContext> env=topLevelEnv(tree);
  if (isPkgInfo) {
    Env<AttrContext> env0=typeEnvs.get(tree.packge);
    if (env0 == null) {
      typeEnvs.put(tree.packge,env);
    }
 else {
      JCCompilationUnit tree0=env0.toplevel;
      if (!fileManager.isSameFile(tree.sourcefile,tree0.sourcefile)) {
        log.warning(tree.pid != null ? tree.pid.pos() : null,""String_Node_Str"",tree.packge);
        if (addEnv || (tree0.packageAnnotations.isEmpty() && tree.docComments != null && tree.docComments.get(tree) != null)) {
          typeEnvs.put(tree.packge,env);
        }
      }
    }
    for (Symbol q=tree.packge; q != null && q.kind == PCK; q=q.owner)     q.flags_field|=EXISTS;
    Name name=names.package_info;
    ClassSymbol c=reader.enterClass(name,tree.packge);
    c.flatname=names.fromString(tree.packge + ""String_Node_Str"" + name);
    c.sourcefile=tree.sourcefile;
    c.completer=null;
    c.members_field=new Scope(c);
    tree.packge.package_info=c;
  }
  classEnter(tree.defs,env);
  if (addEnv) {
    todo.append(env);
  }
  log.useSource(prev);
  result=null;
}","@Override public void visitTopLevel(JCCompilationUnit tree){
  JavaFileObject prev=log.useSource(tree.sourcefile);
  boolean addEnv=false;
  boolean isPkgInfo=tree.sourcefile.isNameCompatible(""String_Node_Str"",JavaFileObject.Kind.SOURCE);
  if (tree.pid != null) {
    tree.packge=reader.enterPackage(TreeInfo.fullName(tree.pid));
    if (tree.packageAnnotations.nonEmpty()) {
      if (isPkgInfo) {
        addEnv=true;
      }
 else {
        log.error(tree.packageAnnotations.head.pos(),""String_Node_Str"");
      }
    }
  }
 else {
    tree.packge=syms.unnamedPackage;
  }
  tree.packge.complete();
  Env<AttrContext> topEnv=topLevelEnv(tree);
  if (isPkgInfo) {
    Env<AttrContext> env0=typeEnvs.get(tree.packge);
    if (env0 == null) {
      typeEnvs.put(tree.packge,topEnv);
    }
 else {
      JCCompilationUnit tree0=env0.toplevel;
      if (!fileManager.isSameFile(tree.sourcefile,tree0.sourcefile)) {
        log.warning(tree.pid != null ? tree.pid.pos() : null,""String_Node_Str"",tree.packge);
        if (addEnv || (tree0.packageAnnotations.isEmpty() && tree.docComments != null && tree.docComments.get(tree) != null)) {
          typeEnvs.put(tree.packge,topEnv);
        }
      }
    }
    for (Symbol q=tree.packge; q != null && q.kind == PCK; q=q.owner)     q.flags_field|=EXISTS;
    Name name=names.package_info;
    ClassSymbol c=reader.enterClass(name,tree.packge);
    c.flatname=names.fromString(tree.packge + ""String_Node_Str"" + name);
    c.sourcefile=tree.sourcefile;
    c.completer=null;
    c.members_field=new Scope(c);
    tree.packge.package_info=c;
  }
  classEnter(tree.defs,topEnv);
  if (addEnv) {
    todo.append(topEnv);
  }
  log.useSource(prev);
  result=null;
}"
13015,"/** 
 * Class enter visitor method for type parameters. Enter a symbol for type parameter in local scope, after checking that it is unique.
 */
public void visitTypeParameter(JCTypeParameter tree){
  TypeVar a=(tree.type != null) ? (TypeVar)tree.type : new TypeVar(tree.name,env.info.scope.owner,syms.botType);
  tree.type=a;
  if (chk.checkUnique(tree.pos(),a.tsym,env.info.scope)) {
    env.info.scope.enter(a.tsym);
  }
  result=a;
}","/** 
 * Class enter visitor method for type parameters. Enter a symbol for type parameter in local scope, after checking that it is unique.
 */
@Override public void visitTypeParameter(JCTypeParameter tree){
  TypeVar a=(tree.type != null) ? (TypeVar)tree.type : new TypeVar(tree.name,env.info.scope.owner,syms.botType);
  tree.type=a;
  if (chk.checkUnique(tree.pos(),a.tsym,env.info.scope)) {
    env.info.scope.enter(a.tsym);
  }
  result=a;
}"
13016,"/** 
 * Main method: enter one class from a list of toplevel trees and place the rest on uncompleted for later processing.
 * @param trees      The list of trees to be processed.
 * @param c          The class symbol to be processed.
 */
public void complete(List<JCCompilationUnit> trees,ClassSymbol c){
  annotate.enterStart();
  ListBuffer<ClassSymbol> prevUncompleted=uncompleted;
  if (memberEnter.completionEnabled)   uncompleted=new ListBuffer<ClassSymbol>();
  try {
    classEnter(trees,null);
    if (memberEnter.completionEnabled) {
      while (uncompleted.nonEmpty()) {
        ClassSymbol clazz=uncompleted.next();
        if (c == null || c == clazz || prevUncompleted == null)         clazz.complete();
 else         prevUncompleted.append(clazz);
      }
      for (      JCCompilationUnit tree : trees) {
        if (tree.starImportScope.elems == null) {
          JavaFileObject prev=log.useSource(tree.sourcefile);
          Env<AttrContext> env=typeEnvs.get(tree);
          if (env == null)           env=topLevelEnv(tree);
          memberEnter.memberEnter(tree,env);
          log.useSource(prev);
        }
      }
    }
  }
  finally {
    uncompleted=prevUncompleted;
    annotate.enterDone();
  }
}","/** 
 * Main method: enter one class from a list of toplevel trees and place the rest on uncompleted for later processing.
 * @param trees      The list of trees to be processed.
 * @param c          The class symbol to be processed.
 */
public void complete(List<JCCompilationUnit> trees,ClassSymbol c){
  annotate.enterStart();
  ListBuffer<ClassSymbol> prevUncompleted=uncompleted;
  if (memberEnter.completionEnabled)   uncompleted=new ListBuffer<ClassSymbol>();
  try {
    classEnter(trees,null);
    if (memberEnter.completionEnabled) {
      while (uncompleted.nonEmpty()) {
        ClassSymbol clazz=uncompleted.next();
        if (c == null || c == clazz || prevUncompleted == null)         clazz.complete();
 else         prevUncompleted.append(clazz);
      }
      for (      JCCompilationUnit tree : trees) {
        if (tree.starImportScope.elems == null) {
          JavaFileObject prev=log.useSource(tree.sourcefile);
          Env<AttrContext> topEnv=topLevelEnv(tree);
          memberEnter.memberEnter(tree,topEnv);
          log.useSource(prev);
        }
      }
    }
  }
  finally {
    uncompleted=prevUncompleted;
    annotate.enterDone();
  }
}"
13017,"public void visitNewArray(JCNewArray tree){
  tree.elemtype=translate(tree.elemtype,null);
  translate(tree.dims,syms.intType);
  tree.elems=translate(tree.elems,(tree.type == null) ? null : erasure(types.elemtype(tree.type)));
  tree.type=erasure(tree.type);
  result=tree;
}","public void visitNewArray(JCNewArray tree){
  tree.elemtype=translate(tree.elemtype,null);
  translate(tree.dims,syms.intType);
  if (tree.type != null) {
    tree.elems=translate(tree.elems,erasure(types.elemtype(tree.type)));
    tree.type=erasure(tree.type);
  }
 else {
    tree.elems=translate(tree.elems,null);
  }
  result=tree;
}"
13018,"/** 
 * A KindName representing a given symbol
 */
public static KindName kindName(Symbol sym){
switch (sym.getKind()) {
case PACKAGE:
    return KindName.PACKAGE;
case ENUM:
case ANNOTATION_TYPE:
case INTERFACE:
case CLASS:
  return KindName.CLASS;
case TYPE_PARAMETER:
return KindName.TYPEVAR;
case ENUM_CONSTANT:
case FIELD:
case PARAMETER:
case LOCAL_VARIABLE:
case EXCEPTION_PARAMETER:
return KindName.VAR;
case METHOD:
case CONSTRUCTOR:
case STATIC_INIT:
case INSTANCE_INIT:
return KindName.METHOD;
default :
if (sym.kind == VAL) return KindName.VAL;
 else throw new AssertionError(""String_Node_Str"" + sym.getKind());
}
}","/** 
 * A KindName representing a given symbol
 */
public static KindName kindName(Symbol sym){
switch (sym.getKind()) {
case PACKAGE:
    return KindName.PACKAGE;
case ENUM:
  return KindName.ENUM;
case ANNOTATION_TYPE:
case CLASS:
return KindName.CLASS;
case INTERFACE:
return KindName.INTERFACE;
case TYPE_PARAMETER:
return KindName.TYPEVAR;
case ENUM_CONSTANT:
case FIELD:
case PARAMETER:
case LOCAL_VARIABLE:
case EXCEPTION_PARAMETER:
return KindName.VAR;
case CONSTRUCTOR:
return KindName.CONSTRUCTOR;
case METHOD:
case STATIC_INIT:
case INSTANCE_INIT:
return KindName.METHOD;
default :
if (sym.kind == VAL) return KindName.VAL;
 else throw new AssertionError(""String_Node_Str"" + sym.getKind());
}
}"
13019,"/** 
 * The number of errors reported so far.
 */
public int errorCount(){
  if (delegateCompiler != null && delegateCompiler != this)   return delegateCompiler.errorCount();
 else   return log.nerrors;
}","/** 
 * The number of errors reported so far.
 */
public int errorCount(){
  if (delegateCompiler != null && delegateCompiler != this)   return delegateCompiler.errorCount();
 else {
    if (werror && log.nerrors == 0 && log.nwarnings > 0) {
      log.error(""String_Node_Str"");
    }
  }
  return log.nerrors;
}"
13020,"/** 
 * Construct a new compiler using a shared context.
 */
public JavaCompiler(final Context context){
  this.context=context;
  context.put(compilerKey,this);
  if (context.get(JavaFileManager.class) == null)   JavacFileManager.preRegister(context);
  names=Names.instance(context);
  log=Log.instance(context);
  diagFactory=JCDiagnostic.Factory.instance(context);
  reader=ClassReader.instance(context);
  make=TreeMaker.instance(context);
  writer=ClassWriter.instance(context);
  enter=Enter.instance(context);
  todo=Todo.instance(context);
  fileManager=context.get(JavaFileManager.class);
  parserFactory=ParserFactory.instance(context);
  try {
    syms=Symtab.instance(context);
  }
 catch (  CompletionFailure ex) {
    log.error(""String_Node_Str"",ex.sym,ex.getDetailValue());
    if (ex instanceof ClassReader.BadClassFile)     throw new Abort();
  }
  source=Source.instance(context);
  attr=Attr.instance(context);
  chk=Check.instance(context);
  gen=Gen.instance(context);
  flow=Flow.instance(context);
  transTypes=TransTypes.instance(context);
  lower=Lower.instance(context);
  annotate=Annotate.instance(context);
  types=Types.instance(context);
  taskListener=context.get(TaskListener.class);
  reader.sourceCompleter=this;
  Options options=Options.instance(context);
  verbose=options.get(""String_Node_Str"") != null;
  sourceOutput=options.get(""String_Node_Str"") != null;
  stubOutput=options.get(""String_Node_Str"") != null;
  relax=options.get(""String_Node_Str"") != null;
  printFlat=options.get(""String_Node_Str"") != null;
  attrParseOnly=options.get(""String_Node_Str"") != null;
  encoding=options.get(""String_Node_Str"");
  lineDebugInfo=options.get(""String_Node_Str"") == null || options.get(""String_Node_Str"") != null;
  genEndPos=options.get(""String_Node_Str"") != null || context.get(DiagnosticListener.class) != null;
  devVerbose=options.get(""String_Node_Str"") != null;
  processPcks=options.get(""String_Node_Str"") != null;
  verboseCompilePolicy=options.get(""String_Node_Str"") != null;
  if (attrParseOnly)   compilePolicy=CompilePolicy.ATTR_ONLY;
 else   compilePolicy=CompilePolicy.decode(options.get(""String_Node_Str""));
  implicitSourcePolicy=ImplicitSourcePolicy.decode(options.get(""String_Node_Str""));
  completionFailureName=(options.get(""String_Node_Str"") != null) ? names.fromString(options.get(""String_Node_Str"")) : null;
}","/** 
 * Construct a new compiler using a shared context.
 */
public JavaCompiler(final Context context){
  this.context=context;
  context.put(compilerKey,this);
  if (context.get(JavaFileManager.class) == null)   JavacFileManager.preRegister(context);
  names=Names.instance(context);
  log=Log.instance(context);
  diagFactory=JCDiagnostic.Factory.instance(context);
  reader=ClassReader.instance(context);
  make=TreeMaker.instance(context);
  writer=ClassWriter.instance(context);
  enter=Enter.instance(context);
  todo=Todo.instance(context);
  fileManager=context.get(JavaFileManager.class);
  parserFactory=ParserFactory.instance(context);
  try {
    syms=Symtab.instance(context);
  }
 catch (  CompletionFailure ex) {
    log.error(""String_Node_Str"",ex.sym,ex.getDetailValue());
    if (ex instanceof ClassReader.BadClassFile)     throw new Abort();
  }
  source=Source.instance(context);
  attr=Attr.instance(context);
  chk=Check.instance(context);
  gen=Gen.instance(context);
  flow=Flow.instance(context);
  transTypes=TransTypes.instance(context);
  lower=Lower.instance(context);
  annotate=Annotate.instance(context);
  types=Types.instance(context);
  taskListener=context.get(TaskListener.class);
  reader.sourceCompleter=this;
  Options options=Options.instance(context);
  verbose=options.get(""String_Node_Str"") != null;
  sourceOutput=options.get(""String_Node_Str"") != null;
  stubOutput=options.get(""String_Node_Str"") != null;
  relax=options.get(""String_Node_Str"") != null;
  printFlat=options.get(""String_Node_Str"") != null;
  attrParseOnly=options.get(""String_Node_Str"") != null;
  encoding=options.get(""String_Node_Str"");
  lineDebugInfo=options.get(""String_Node_Str"") == null || options.get(""String_Node_Str"") != null;
  genEndPos=options.get(""String_Node_Str"") != null || context.get(DiagnosticListener.class) != null;
  devVerbose=options.get(""String_Node_Str"") != null;
  processPcks=options.get(""String_Node_Str"") != null;
  werror=options.get(""String_Node_Str"") != null;
  verboseCompilePolicy=options.get(""String_Node_Str"") != null;
  if (attrParseOnly)   compilePolicy=CompilePolicy.ATTR_ONLY;
 else   compilePolicy=CompilePolicy.decode(options.get(""String_Node_Str""));
  implicitSourcePolicy=ImplicitSourcePolicy.decode(options.get(""String_Node_Str""));
  completionFailureName=(options.get(""String_Node_Str"") != null) ? names.fromString(options.get(""String_Node_Str"")) : null;
}"
13021,"/** 
 * Programmatic interface for main function.
 * @param args    The command line parameters.
 */
public int compile(String[] args,Context context,List<JavaFileObject> fileObjects,Iterable<? extends Processor> processors){
  if (options == null)   options=Options.instance(context);
  filenames=new ListBuffer<File>();
  classnames=new ListBuffer<String>();
  JavaCompiler comp=null;
  try {
    if (args.length == 0 && fileObjects.isEmpty()) {
      help();
      return EXIT_CMDERR;
    }
    List<File> files;
    try {
      files=processArgs(CommandLine.parse(args));
      if (files == null) {
        return EXIT_CMDERR;
      }
 else       if (files.isEmpty() && fileObjects.isEmpty() && classnames.isEmpty()) {
        if (options.get(""String_Node_Str"") != null || options.get(""String_Node_Str"") != null || options.get(""String_Node_Str"") != null || options.get(""String_Node_Str"") != null)         return EXIT_OK;
        error(""String_Node_Str"");
        return EXIT_CMDERR;
      }
    }
 catch (    java.io.FileNotFoundException e) {
      Log.printLines(out,ownName + ""String_Node_Str"" + getLocalizedString(""String_Node_Str"",e.getMessage()));
      return EXIT_SYSERR;
    }
    boolean forceStdOut=options.get(""String_Node_Str"") != null;
    if (forceStdOut) {
      out.flush();
      out=new PrintWriter(System.out,true);
    }
    context.put(Log.outKey,out);
    boolean batchMode=(options.get(""String_Node_Str"") == null && System.getProperty(""String_Node_Str"") == null);
    if (batchMode)     CacheFSInfo.preRegister(context);
    fileManager=context.get(JavaFileManager.class);
    comp=JavaCompiler.instance(context);
    if (comp == null)     return EXIT_SYSERR;
    Log log=Log.instance(context);
    if (!files.isEmpty()) {
      comp=JavaCompiler.instance(context);
      List<JavaFileObject> otherFiles=List.nil();
      JavacFileManager dfm=(JavacFileManager)fileManager;
      for (      JavaFileObject fo : dfm.getJavaFileObjectsFromFiles(files))       otherFiles=otherFiles.prepend(fo);
      for (      JavaFileObject fo : otherFiles)       fileObjects=fileObjects.prepend(fo);
    }
    comp.compile(fileObjects,classnames.toList(),processors);
    if (log.expectDiagKeys != null) {
      if (log.expectDiagKeys.size() == 0) {
        Log.printLines(log.noticeWriter,""String_Node_Str"");
        return EXIT_OK;
      }
 else {
        Log.printLines(log.noticeWriter,""String_Node_Str"" + log.expectDiagKeys);
        return EXIT_ERROR;
      }
    }
    if (comp.errorCount() != 0 || options.get(""String_Node_Str"") != null && comp.warningCount() != 0)     return EXIT_ERROR;
  }
 catch (  IOException ex) {
    ioMessage(ex);
    return EXIT_SYSERR;
  }
catch (  OutOfMemoryError ex) {
    resourceMessage(ex);
    return EXIT_SYSERR;
  }
catch (  StackOverflowError ex) {
    resourceMessage(ex);
    return EXIT_SYSERR;
  }
catch (  FatalError ex) {
    feMessage(ex);
    return EXIT_SYSERR;
  }
catch (  AnnotationProcessingError ex) {
    apMessage(ex);
    return EXIT_SYSERR;
  }
catch (  ClientCodeException ex) {
    throw new RuntimeException(ex.getCause());
  }
catch (  PropagatedException ex) {
    throw ex.getCause();
  }
catch (  Throwable ex) {
    if (comp == null || comp.errorCount() == 0 || options == null || options.get(""String_Node_Str"") != null)     bugMessage(ex);
    return EXIT_ABNORMAL;
  }
 finally {
    if (comp != null)     comp.close();
    filenames=null;
    options=null;
  }
  return EXIT_OK;
}","/** 
 * Programmatic interface for main function.
 * @param args    The command line parameters.
 */
public int compile(String[] args,Context context,List<JavaFileObject> fileObjects,Iterable<? extends Processor> processors){
  if (options == null)   options=Options.instance(context);
  filenames=new ListBuffer<File>();
  classnames=new ListBuffer<String>();
  JavaCompiler comp=null;
  try {
    if (args.length == 0 && fileObjects.isEmpty()) {
      help();
      return EXIT_CMDERR;
    }
    List<File> files;
    try {
      files=processArgs(CommandLine.parse(args));
      if (files == null) {
        return EXIT_CMDERR;
      }
 else       if (files.isEmpty() && fileObjects.isEmpty() && classnames.isEmpty()) {
        if (options.get(""String_Node_Str"") != null || options.get(""String_Node_Str"") != null || options.get(""String_Node_Str"") != null || options.get(""String_Node_Str"") != null)         return EXIT_OK;
        error(""String_Node_Str"");
        return EXIT_CMDERR;
      }
    }
 catch (    java.io.FileNotFoundException e) {
      Log.printLines(out,ownName + ""String_Node_Str"" + getLocalizedString(""String_Node_Str"",e.getMessage()));
      return EXIT_SYSERR;
    }
    boolean forceStdOut=options.get(""String_Node_Str"") != null;
    if (forceStdOut) {
      out.flush();
      out=new PrintWriter(System.out,true);
    }
    context.put(Log.outKey,out);
    boolean batchMode=(options.get(""String_Node_Str"") == null && System.getProperty(""String_Node_Str"") == null);
    if (batchMode)     CacheFSInfo.preRegister(context);
    fileManager=context.get(JavaFileManager.class);
    comp=JavaCompiler.instance(context);
    if (comp == null)     return EXIT_SYSERR;
    Log log=Log.instance(context);
    if (!files.isEmpty()) {
      comp=JavaCompiler.instance(context);
      List<JavaFileObject> otherFiles=List.nil();
      JavacFileManager dfm=(JavacFileManager)fileManager;
      for (      JavaFileObject fo : dfm.getJavaFileObjectsFromFiles(files))       otherFiles=otherFiles.prepend(fo);
      for (      JavaFileObject fo : otherFiles)       fileObjects=fileObjects.prepend(fo);
    }
    comp.compile(fileObjects,classnames.toList(),processors);
    if (log.expectDiagKeys != null) {
      if (log.expectDiagKeys.size() == 0) {
        Log.printLines(log.noticeWriter,""String_Node_Str"");
        return EXIT_OK;
      }
 else {
        Log.printLines(log.noticeWriter,""String_Node_Str"" + log.expectDiagKeys);
        return EXIT_ERROR;
      }
    }
    if (comp.errorCount() != 0)     return EXIT_ERROR;
  }
 catch (  IOException ex) {
    ioMessage(ex);
    return EXIT_SYSERR;
  }
catch (  OutOfMemoryError ex) {
    resourceMessage(ex);
    return EXIT_SYSERR;
  }
catch (  StackOverflowError ex) {
    resourceMessage(ex);
    return EXIT_SYSERR;
  }
catch (  FatalError ex) {
    feMessage(ex);
    return EXIT_SYSERR;
  }
catch (  AnnotationProcessingError ex) {
    apMessage(ex);
    return EXIT_SYSERR;
  }
catch (  ClientCodeException ex) {
    throw new RuntimeException(ex.getCause());
  }
catch (  PropagatedException ex) {
    throw ex.getCause();
  }
catch (  Throwable ex) {
    if (comp == null || comp.errorCount() == 0 || options == null || options.get(""String_Node_Str"") != null)     bugMessage(ex);
    return EXIT_ABNORMAL;
  }
 finally {
    if (comp != null)     comp.close();
    filenames=null;
    options=null;
  }
  return EXIT_OK;
}"
13022,"/** 
 * Get all the recognized options.
 * @param helper an {@code OptionHelper} to help when processing options
 * @return an array of options
 */
public static Option[] getAll(final OptionHelper helper){
  return new Option[]{new Option(G,""String_Node_Str""),new Option(G_NONE,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",""String_Node_Str"");
      return false;
    }
  }
,new Option(G_CUSTOM,""String_Node_Str"",Option.ChoiceKind.ANYOF,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new XOption(XLINT,""String_Node_Str""),new XOption(XLINT_CUSTOM,""String_Node_Str"",Option.ChoiceKind.ANYOF,getXLintChoices()),new Option(NOWARN,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",option);
      return false;
    }
  }
,new Option(VERBOSE,""String_Node_Str""),new Option(DEPRECATION,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",option);
      return false;
    }
  }
,new Option(CLASSPATH,""String_Node_Str"",""String_Node_Str""),new Option(CP,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(SOURCEPATH,""String_Node_Str"",""String_Node_Str""),new Option(BOOTCLASSPATH,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      options.remove(""String_Node_Str"");
      options.remove(""String_Node_Str"");
      return super.process(options,option,arg);
    }
  }
,new XOption(XBOOTCLASSPATH_PREPEND,""String_Node_Str"",""String_Node_Str""),new XOption(XBOOTCLASSPATH_APPEND,""String_Node_Str"",""String_Node_Str""),new XOption(XBOOTCLASSPATH,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      options.remove(""String_Node_Str"");
      options.remove(""String_Node_Str"");
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(EXTDIRS,""String_Node_Str"",""String_Node_Str""),new XOption(DJAVA_EXT_DIRS,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(ENDORSEDDIRS,""String_Node_Str"",""String_Node_Str""),new XOption(DJAVA_ENDORSED_DIRS,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(PROC,""String_Node_Str"",Option.ChoiceKind.ONEOF,""String_Node_Str"",""String_Node_Str""),new Option(PROCESSOR,""String_Node_Str"",""String_Node_Str""),new Option(PROCESSORPATH,""String_Node_Str"",""String_Node_Str""),new Option(D,""String_Node_Str"",""String_Node_Str""),new Option(S,""String_Node_Str"",""String_Node_Str""),new Option(IMPLICIT,""String_Node_Str"",Option.ChoiceKind.ONEOF,""String_Node_Str"",""String_Node_Str""),new Option(ENCODING,""String_Node_Str"",""String_Node_Str""),new Option(SOURCE,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String operand){
      Source source=Source.lookup(operand);
      if (source == null) {
        helper.error(""String_Node_Str"",operand);
        return true;
      }
      return super.process(options,option,operand);
    }
  }
,new Option(TARGET,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String operand){
      Target target=Target.lookup(operand);
      if (target == null) {
        helper.error(""String_Node_Str"",operand);
        return true;
      }
      return super.process(options,option,operand);
    }
  }
,new Option(VERSION,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      helper.printVersion();
      return super.process(options,option);
    }
  }
,new HiddenOption(FULLVERSION){
    @Override public boolean process(    Options options,    String option){
      helper.printFullVersion();
      return super.process(options,option);
    }
  }
,new Option(HELP,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      helper.printHelp();
      return super.process(options,option);
    }
  }
,new Option(A,""String_Node_Str"",""String_Node_Str""){
    @Override String helpSynopsis(){
      hasSuffix=true;
      return super.helpSynopsis();
    }
    @Override public boolean matches(    String arg){
      return arg.startsWith(""String_Node_Str"");
    }
    @Override public boolean hasArg(){
      return false;
    }
    @Override public boolean process(    Options options,    String option){
      int argLength=option.length();
      if (argLength == 2) {
        helper.error(""String_Node_Str"");
        return true;
      }
      int sepIndex=option.indexOf('=');
      String key=option.substring(2,(sepIndex != -1 ? sepIndex : argLength));
      if (!JavacProcessingEnvironment.isValidOptionName(key)) {
        helper.error(""String_Node_Str"",option);
        return true;
      }
      return process(options,option,option);
    }
  }
,new Option(X,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      helper.printXhelp();
      return super.process(options,option);
    }
  }
,new Option(J,""String_Node_Str"",""String_Node_Str""){
    @Override String helpSynopsis(){
      hasSuffix=true;
      return super.helpSynopsis();
    }
    @Override public boolean process(    Options options,    String option){
      throw new AssertionError(""String_Node_Str"");
    }
  }
,new HiddenOption(MOREINFO){
    @Override public boolean process(    Options options,    String option){
      Type.moreInfo=true;
      return super.process(options,option);
    }
  }
,new HiddenOption(WERROR),new HiddenOption(COMPLEXINFERENCE),new HiddenOption(PROMPT),new HiddenOption(DOE),new HiddenOption(PRINTSOURCE),new HiddenOption(WARNUNCHECKED){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",option);
      return false;
    }
  }
,new XOption(XMAXERRS,""String_Node_Str"",""String_Node_Str""),new XOption(XMAXWARNS,""String_Node_Str"",""String_Node_Str""),new XOption(XSTDOUT,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      try {
        helper.setOut(new PrintWriter(new FileWriter(arg),true));
      }
 catch (      java.io.IOException e) {
        helper.error(""String_Node_Str"",arg,e);
        return true;
      }
      return super.process(options,option,arg);
    }
  }
,new XOption(XPRINT,""String_Node_Str""),new XOption(XPRINTROUNDS,""String_Node_Str""),new XOption(XPRINTPROCESSORINFO,""String_Node_Str""),new XOption(XPREFER,""String_Node_Str"",Option.ChoiceKind.ONEOF,""String_Node_Str"",""String_Node_Str""),new HiddenOption(O),new HiddenOption(XJCOV),new HiddenOption(XD){
    String s;
    @Override public boolean matches(    String s){
      this.s=s;
      return s.startsWith(name.optionName);
    }
    @Override public boolean process(    Options options,    String option){
      s=s.substring(name.optionName.length());
      int eq=s.indexOf('=');
      String key=(eq < 0) ? s : s.substring(0,eq);
      String value=(eq < 0) ? s : s.substring(eq + 1);
      options.put(key,value);
      return false;
    }
  }
,new HiddenOption(SOURCEFILE){
    String s;
    @Override public boolean matches(    String s){
      this.s=s;
      return s.endsWith(""String_Node_Str"") || SourceVersion.isName(s);
    }
    @Override public boolean process(    Options options,    String option){
      if (s.endsWith(""String_Node_Str"")) {
        File f=new File(s);
        if (!f.exists()) {
          helper.error(""String_Node_Str"",f);
          return true;
        }
        if (!f.isFile()) {
          helper.error(""String_Node_Str"",f);
          return true;
        }
        helper.addFile(f);
      }
 else       helper.addClassName(s);
      return false;
    }
  }
};
}","/** 
 * Get all the recognized options.
 * @param helper an {@code OptionHelper} to help when processing options
 * @return an array of options
 */
public static Option[] getAll(final OptionHelper helper){
  return new Option[]{new Option(G,""String_Node_Str""),new Option(G_NONE,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",""String_Node_Str"");
      return false;
    }
  }
,new Option(G_CUSTOM,""String_Node_Str"",Option.ChoiceKind.ANYOF,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new XOption(XLINT,""String_Node_Str""),new XOption(XLINT_CUSTOM,""String_Node_Str"",Option.ChoiceKind.ANYOF,getXLintChoices()),new Option(NOWARN,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",option);
      return false;
    }
  }
,new Option(VERBOSE,""String_Node_Str""),new Option(DEPRECATION,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",option);
      return false;
    }
  }
,new Option(CLASSPATH,""String_Node_Str"",""String_Node_Str""),new Option(CP,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(SOURCEPATH,""String_Node_Str"",""String_Node_Str""),new Option(BOOTCLASSPATH,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      options.remove(""String_Node_Str"");
      options.remove(""String_Node_Str"");
      return super.process(options,option,arg);
    }
  }
,new XOption(XBOOTCLASSPATH_PREPEND,""String_Node_Str"",""String_Node_Str""),new XOption(XBOOTCLASSPATH_APPEND,""String_Node_Str"",""String_Node_Str""),new XOption(XBOOTCLASSPATH,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      options.remove(""String_Node_Str"");
      options.remove(""String_Node_Str"");
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(EXTDIRS,""String_Node_Str"",""String_Node_Str""),new XOption(DJAVA_EXT_DIRS,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(ENDORSEDDIRS,""String_Node_Str"",""String_Node_Str""),new XOption(DJAVA_ENDORSED_DIRS,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(PROC,""String_Node_Str"",Option.ChoiceKind.ONEOF,""String_Node_Str"",""String_Node_Str""),new Option(PROCESSOR,""String_Node_Str"",""String_Node_Str""),new Option(PROCESSORPATH,""String_Node_Str"",""String_Node_Str""),new Option(D,""String_Node_Str"",""String_Node_Str""),new Option(S,""String_Node_Str"",""String_Node_Str""),new Option(IMPLICIT,""String_Node_Str"",Option.ChoiceKind.ONEOF,""String_Node_Str"",""String_Node_Str""),new Option(ENCODING,""String_Node_Str"",""String_Node_Str""),new Option(SOURCE,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String operand){
      Source source=Source.lookup(operand);
      if (source == null) {
        helper.error(""String_Node_Str"",operand);
        return true;
      }
      return super.process(options,option,operand);
    }
  }
,new Option(TARGET,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String operand){
      Target target=Target.lookup(operand);
      if (target == null) {
        helper.error(""String_Node_Str"",operand);
        return true;
      }
      return super.process(options,option,operand);
    }
  }
,new Option(VERSION,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      helper.printVersion();
      return super.process(options,option);
    }
  }
,new HiddenOption(FULLVERSION){
    @Override public boolean process(    Options options,    String option){
      helper.printFullVersion();
      return super.process(options,option);
    }
  }
,new Option(HELP,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      helper.printHelp();
      return super.process(options,option);
    }
  }
,new Option(A,""String_Node_Str"",""String_Node_Str""){
    @Override String helpSynopsis(){
      hasSuffix=true;
      return super.helpSynopsis();
    }
    @Override public boolean matches(    String arg){
      return arg.startsWith(""String_Node_Str"");
    }
    @Override public boolean hasArg(){
      return false;
    }
    @Override public boolean process(    Options options,    String option){
      int argLength=option.length();
      if (argLength == 2) {
        helper.error(""String_Node_Str"");
        return true;
      }
      int sepIndex=option.indexOf('=');
      String key=option.substring(2,(sepIndex != -1 ? sepIndex : argLength));
      if (!JavacProcessingEnvironment.isValidOptionName(key)) {
        helper.error(""String_Node_Str"",option);
        return true;
      }
      return process(options,option,option);
    }
  }
,new Option(X,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      helper.printXhelp();
      return super.process(options,option);
    }
  }
,new Option(J,""String_Node_Str"",""String_Node_Str""){
    @Override String helpSynopsis(){
      hasSuffix=true;
      return super.helpSynopsis();
    }
    @Override public boolean process(    Options options,    String option){
      throw new AssertionError(""String_Node_Str"");
    }
  }
,new HiddenOption(MOREINFO){
    @Override public boolean process(    Options options,    String option){
      Type.moreInfo=true;
      return super.process(options,option);
    }
  }
,new Option(WERROR,""String_Node_Str""),new HiddenOption(COMPLEXINFERENCE),new HiddenOption(PROMPT),new HiddenOption(DOE),new HiddenOption(PRINTSOURCE),new HiddenOption(WARNUNCHECKED){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",option);
      return false;
    }
  }
,new XOption(XMAXERRS,""String_Node_Str"",""String_Node_Str""),new XOption(XMAXWARNS,""String_Node_Str"",""String_Node_Str""),new XOption(XSTDOUT,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      try {
        helper.setOut(new PrintWriter(new FileWriter(arg),true));
      }
 catch (      java.io.IOException e) {
        helper.error(""String_Node_Str"",arg,e);
        return true;
      }
      return super.process(options,option,arg);
    }
  }
,new XOption(XPRINT,""String_Node_Str""),new XOption(XPRINTROUNDS,""String_Node_Str""),new XOption(XPRINTPROCESSORINFO,""String_Node_Str""),new XOption(XPREFER,""String_Node_Str"",Option.ChoiceKind.ONEOF,""String_Node_Str"",""String_Node_Str""),new HiddenOption(O),new HiddenOption(XJCOV),new HiddenOption(XD){
    String s;
    @Override public boolean matches(    String s){
      this.s=s;
      return s.startsWith(name.optionName);
    }
    @Override public boolean process(    Options options,    String option){
      s=s.substring(name.optionName.length());
      int eq=s.indexOf('=');
      String key=(eq < 0) ? s : s.substring(0,eq);
      String value=(eq < 0) ? s : s.substring(eq + 1);
      options.put(key,value);
      return false;
    }
  }
,new HiddenOption(SOURCEFILE){
    String s;
    @Override public boolean matches(    String s){
      this.s=s;
      return s.endsWith(""String_Node_Str"") || SourceVersion.isName(s);
    }
    @Override public boolean process(    Options options,    String option){
      if (s.endsWith(""String_Node_Str"")) {
        File f=new File(s);
        if (!f.exists()) {
          helper.error(""String_Node_Str"",f);
          return true;
        }
        if (!f.isFile()) {
          helper.error(""String_Node_Str"",f);
          return true;
        }
        helper.addFile(f);
      }
 else       helper.addClassName(s);
      return false;
    }
  }
};
}"
13023,"private boolean onStartDiscovery(){
  String label=labelTextField.getText().trim();
  if (autoLabelCheckBox.isSelected()) {
    label=createAutoLabel();
    labelTextField.setText(label);
  }
 else {
    if (!isValidLabel(label))     return false;
  }
  GenericXmlApplicationContext ctx=new GenericXmlApplicationContext();
  ctx.load(""String_Node_Str"");
  ctx.load(""String_Node_Str"");
  ctx.refresh();
  Map<String,String> props=new HashMap<>();
  props.put(""String_Node_Str"",projectDir.getAbsolutePath());
  VersionManagerFactory versionManagerFactory=ctx.getBean(""String_Node_Str"",VersionManagerFactory.class);
  VersionManager versionManager=versionManagerFactory.createVersionManager(""String_Node_Str"",props);
  String version=versionManager.createVersion();
  props.put(""String_Node_Str"",version);
  networkDiscovererFactory=ctx.getBean(""String_Node_Str"",NetworkDiscovererFactory.class);
  ConnectionDetailsManagerFactory connectionManagerFacotry=ctx.getBean(""String_Node_Str"",ConnectionDetailsManagerFactory.class);
  ConnectionDetailsManager connectionDetails=connectionManagerFacotry.createConnectionDetailsManager(""String_Node_Str"",props);
  LinkedHashMap<String,ConnectionDetails> connectionList=null;
  if (connectionDetails != null) {
    connectionList=(LinkedHashMap<String,ConnectionDetails>)connectionDetails.getConnections();
  }
  props.put(""String_Node_Str"",version);
  NetworkDiscoverer nodeDiscovererImpl=this.networkDiscovererFactory.createNetworkDiscoverer(""String_Node_Str"",props);
  int depth=(Integer)depthComboBox.getSelectedItem();
  NodeDiscoveryListener nodeListener=new NodeDiscoveryListener(){
    @Override public void nodeDiscovered(    NodeDiscoveryResult discoveryResult){
      discoveredDevices++;
      loggerConsole.setText(discoveryResult.getNodeId() + ""String_Node_Str"" + ""String_Node_Str""+ DISCOVERED_DEVICES+ ""String_Node_Str""+ discoveredDevices);
      loggerConsole.repaint();
    }
  }
;
  NetworkDiscoveryListener networkListener=new NetworkDiscoveryListener(){
    @Override public void networkDiscovered(    NetworkDiscoveryResult result){
      loggerConsole.setText(""String_Node_Str"");
      loggerConsole.repaint();
    }
  }
;
  nodeDiscovererImpl.addNetworkDiscoveryListeners(networkListener);
  nodeDiscovererImpl.startDiscovery(new HashSet<>(connectionList.values()));
  return true;
}","private boolean onStartDiscovery(){
  String label=labelTextField.getText().trim();
  if (autoLabelCheckBox.isSelected()) {
    label=createAutoLabel();
    labelTextField.setText(label);
  }
 else {
    if (!isValidLabel(label))     return false;
  }
  GenericXmlApplicationContext ctx=new GenericXmlApplicationContext();
  ctx.load(""String_Node_Str"");
  ctx.load(""String_Node_Str"");
  ctx.refresh();
  Map<String,String> props=new HashMap<>();
  props.put(""String_Node_Str"",projectDir.getAbsolutePath());
  VersionManagerFactory versionManagerFactory=ctx.getBean(""String_Node_Str"",VersionManagerFactory.class);
  VersionManager versionManager=versionManagerFactory.createVersionManager(""String_Node_Str"",props);
  String version=versionManager.createVersion();
  props.put(""String_Node_Str"",version);
  networkDiscovererFactory=ctx.getBean(""String_Node_Str"",NetworkDiscovererFactory.class);
  ConnectionDetailsManagerFactory connectionManagerFacotry=ctx.getBean(""String_Node_Str"",ConnectionDetailsManagerFactory.class);
  ConnectionDetailsManager connectionDetails=connectionManagerFacotry.createConnectionDetailsManager(""String_Node_Str"",props);
  LinkedHashMap<String,ConnectionDetails> connectionList=null;
  if (connectionDetails != null) {
    connectionList=(LinkedHashMap<String,ConnectionDetails>)connectionDetails.getConnections();
  }
  props.put(""String_Node_Str"",version);
  NetworkDiscoverer nodeDiscovererImpl=this.networkDiscovererFactory.createNetworkDiscoverer(""String_Node_Str"",props);
  int depth=(Integer)depthComboBox.getSelectedItem();
  NodeDiscoveryListener nodeListener=new NodeDiscoveryListener(){
    @Override public void nodeDiscovered(    NodeDiscoveryResult discoveryResult){
      discoveredDevices++;
      loggerConsole.setText(discoveryResult.getNodeId() + ""String_Node_Str"" + ""String_Node_Str""+ DISCOVERED_DEVICES+ ""String_Node_Str""+ discoveredDevices);
      loggerConsole.repaint();
    }
  }
;
  NetworkDiscoveryListener networkListener=new NetworkDiscoveryListener(){
    @Override public void networkDiscovered(    NetworkDiscoveryResult result){
      loggerConsole.setText(""String_Node_Str"");
      loggerConsole.repaint();
    }
  }
;
  nodeDiscovererImpl.addNetworkDiscoveryListeners(networkListener);
  nodeDiscovererImpl.startDiscovery();
  return true;
}"
13024,"public static void main(String[] args) throws MalformedURLException {
  logger.debug(""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  Options options=new Options();
  Option projectPathOption=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  projectPathOption.setRequired(true);
  options.addOption(projectPathOption);
  Option newProjectOption=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  newProjectOption.setRequired(false);
  options.addOption(newProjectOption);
  Option deleteProject=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  newProjectOption.setRequired(false);
  options.addOption(deleteProject);
  CommandLineParser parser=new DefaultParser();
  HelpFormatter formatter=new HelpFormatter();
  CommandLine cmd;
  try {
    cmd=parser.parse(options,args);
  }
 catch (  ParseException e) {
    System.out.println(e.getMessage());
    String usage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    ;
    formatter.printHelp(200,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",options,usage);
    System.exit(1);
    return;
  }
  String newProjectFlag=cmd.getOptionValue(""String_Node_Str"");
  String projectPath=cmd.getOptionValue(""String_Node_Str"");
  String deleteProject1=cmd.getOptionValue(""String_Node_Str"");
  GenericXmlApplicationContext ctx=new GenericXmlApplicationContext();
  ctx.load(""String_Node_Str"");
  ctx.refresh();
  ctx.load(""String_Node_Str"");
  FileBasedProjectManagerFactory fileBasedProjectManagerFactory=ctx.getBean(""String_Node_Str"",FileBasedProjectManagerFactory.class);
  FileBasedProjectManager projectManager=fileBasedProjectManagerFactory.createProjectManager();
  if (newProjectFlag != null) {
    if (projectPath == null) {
      System.out.println(""String_Node_Str"");
      return;
    }
    File project=new File(projectPath);
    if (project.exists()) {
      System.out.println(""String_Node_Str"");
      return;
    }
 else {
      logger.info(""String_Node_Str"" + projectPath + ""String_Node_Str"");
      project.mkdir();
    }
    projectManager.createProject(""String_Node_Str"",new File(projectPath).getAbsolutePath());
  }
  if (deleteProject1 != null) {
    if (projectPath == null) {
      System.out.println(""String_Node_Str"");
      return;
    }
    projectManager.deleteProject(new File(projectPath).getAbsolutePath());
    return;
  }
  if (projectPath == null) {
    File cwd=new File(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + cwd.getAbsolutePath());
    projectPath=cwd.getAbsolutePath();
  }
  System.setProperty(""String_Node_Str"",new File(projectPath).getAbsolutePath());
  System.out.println(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
  NetworkDiscovererFactory discovererFactory=ctx.getBean(""String_Node_Str"",NetworkDiscovererFactory.class);
  VersionManagerFactory versionManagerFactory=ctx.getBean(""String_Node_Str"",VersionManagerFactory.class);
  Map<String,String> props=new HashMap<>();
  props.put(""String_Node_Str"",projectPath);
  VersionManager versionManager=versionManagerFactory.createVersionManager(""String_Node_Str"",props);
  String version=versionManager.createVersion();
  props.put(""String_Node_Str"",version);
  NetworkDiscoverer networkDiscoverer=discovererFactory.createNetworkDiscoverer(""String_Node_Str"",props);
  networkDiscoverer.addNetworkDiscoveryListeners(result -> {
    Map<String,Node> nodes=result.getNodes();
    for (    String node : nodes.keySet()) {
      System.out.println(""String_Node_Str"" + node);
    }
  }
);
  ConnectionDetailsManagerFactory factory=ctx.getBean(""String_Node_Str"",ConnectionDetailsManagerFactory.class);
  ConnectionDetailsManager connectionDetailsManager=factory.createConnectionDetailsManager(""String_Node_Str"",props);
  Map<String,ConnectionDetails> connectionDetails=connectionDetailsManager.getConnections();
  networkDiscoverer.startDiscovery(new HashSet<>(connectionDetails.values()));
}","public static void main(String[] args) throws MalformedURLException {
  logger.debug(""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  Options options=new Options();
  Option projectPathOption=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  projectPathOption.setRequired(true);
  options.addOption(projectPathOption);
  Option newProjectOption=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  newProjectOption.setRequired(false);
  options.addOption(newProjectOption);
  Option deleteProject=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  newProjectOption.setRequired(false);
  options.addOption(deleteProject);
  CommandLineParser parser=new DefaultParser();
  HelpFormatter formatter=new HelpFormatter();
  CommandLine cmd;
  try {
    cmd=parser.parse(options,args);
  }
 catch (  ParseException e) {
    System.out.println(e.getMessage());
    String usage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    ;
    formatter.printHelp(200,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",options,usage);
    System.exit(1);
    return;
  }
  String newProjectFlag=cmd.getOptionValue(""String_Node_Str"");
  String projectPath=cmd.getOptionValue(""String_Node_Str"");
  String deleteProject1=cmd.getOptionValue(""String_Node_Str"");
  GenericXmlApplicationContext ctx=new GenericXmlApplicationContext();
  ctx.load(""String_Node_Str"");
  ctx.refresh();
  ctx.load(""String_Node_Str"");
  FileBasedProjectManagerFactory fileBasedProjectManagerFactory=ctx.getBean(""String_Node_Str"",FileBasedProjectManagerFactory.class);
  String baseDir=System.getProperty(""String_Node_Str"");
  if (baseDir == null) {
    baseDir=""String_Node_Str"";
    System.setProperty(""String_Node_Str"",baseDir);
  }
  Map<String,String> parameters=new HashMap<>();
  parameters.put(""String_Node_Str"",baseDir);
  FileBasedProjectManager projectManager=fileBasedProjectManagerFactory.createProjectManager(parameters);
  if (newProjectFlag != null) {
    if (projectPath == null) {
      System.out.println(""String_Node_Str"");
      return;
    }
    File project=new File(projectPath);
    if (project.exists()) {
      System.out.println(""String_Node_Str"");
      return;
    }
 else {
      logger.info(""String_Node_Str"" + projectPath + ""String_Node_Str"");
      project.mkdir();
    }
    projectManager.createProject(""String_Node_Str"",new File(projectPath).getAbsolutePath());
  }
  if (deleteProject1 != null) {
    if (projectPath == null) {
      System.out.println(""String_Node_Str"");
      return;
    }
    projectManager.deleteProject(new File(projectPath).getAbsolutePath());
    return;
  }
  if (projectPath == null) {
    File cwd=new File(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + cwd.getAbsolutePath());
    projectPath=cwd.getAbsolutePath();
  }
  System.setProperty(""String_Node_Str"",new File(projectPath).getAbsolutePath());
  System.out.println(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
  NetworkDiscovererFactory discovererFactory=ctx.getBean(""String_Node_Str"",NetworkDiscovererFactory.class);
  VersionManagerFactory versionManagerFactory=ctx.getBean(""String_Node_Str"",VersionManagerFactory.class);
  Map<String,String> props=new HashMap<>();
  props.put(""String_Node_Str"",projectPath);
  VersionManager versionManager=versionManagerFactory.createVersionManager(""String_Node_Str"",props);
  String version=versionManager.createVersion();
  props.put(""String_Node_Str"",version);
  NetworkDiscoverer networkDiscoverer=discovererFactory.createNetworkDiscoverer(""String_Node_Str"",props);
  networkDiscoverer.addNetworkDiscoveryListeners(result -> {
    Map<String,Node> nodes=result.getNodes();
    for (    String node : nodes.keySet()) {
      System.out.println(""String_Node_Str"" + node);
    }
  }
);
  ConnectionDetailsManagerFactory factory=ctx.getBean(""String_Node_Str"",ConnectionDetailsManagerFactory.class);
  ConnectionDetailsManager connectionDetailsManager=factory.createConnectionDetailsManager(""String_Node_Str"",props);
  Map<String,ConnectionDetails> connectionDetails=connectionDetailsManager.getConnections();
  networkDiscoverer.startDiscovery(new HashSet<>(connectionDetails.values()));
}"
13025,"@Override public void actionPerformed(ActionEvent e){
  NewProjectDialog dialog=new NewProjectDialog(frame);
  dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
  dialog.setVisible(true);
  File file=null;
  String projectType=dialog.getProjectType();
  logger.info(""String_Node_Str"" + projectType);
  if (!dialog.isOkPressed()) {
    return;
  }
  frame.setTitle(ProjectConstants.getProjectName(projectType));
  FileBasedProjectManager fileBasedProjectManager=new FileBasedProjectManager();
  try {
    fileBasedProjectManager.createProject(""String_Node_Str"",dialog.getProjectDir().getAbsolutePath());
  }
 catch (  ProjectManagerException e1) {
    JOptionPane.showMessageDialog(frame,""String_Node_Str"" + dialog.getProjectDir());
  }
  frame.setPath(dialog.getProjectDir());
switch (projectType) {
case ProjectConstants.mrtBgpDiscovererProjectType:
    file=new File(""String_Node_Str"");
  frame.setProjectType(ProjectConstants.mrtBgpDiscovererProjectType);
frame.setViewerConfig(""String_Node_Str"");
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(0).setEnabled(false);
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(1).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(7).getMenuComponent(4).setEnabled(true);
break;
case ProjectConstants.freeGraphProjectType:
file=new File(""String_Node_Str"");
frame.setProjectType(ProjectConstants.freeGraphProjectType);
frame.setViewerConfig(""String_Node_Str"");
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(0).setEnabled(false);
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(1).setEnabled(false);
frame.getRootPane().getJMenuBar().getMenu(7).getMenuComponent(5).setEnabled(true);
break;
case ProjectConstants.snmpProjectType:
file=new File(""String_Node_Str"");
frame.setProjectType(ProjectConstants.snmpProjectType);
frame.setViewerConfig(""String_Node_Str"");
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(0).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(1).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(7).getMenuComponent(3).setEnabled(true);
break;
case ProjectConstants.snmpBgpDiscovererProjectType:
file=new File(""String_Node_Str"");
frame.setProjectType(ProjectConstants.snmpBgpDiscovererProjectType);
frame.setViewerConfig(""String_Node_Str"");
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(0).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(1).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(7).getMenuComponent(3).setEnabled(true);
break;
default :
JOptionPane.showMessageDialog(frame,""String_Node_Str"");
}
frame.setPath(dialog.getProjectDir());
frame.getRootPane().getJMenuBar().getMenu(1).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(2).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(3).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(4).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(5).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(6).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(7).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(0).getMenuComponent(4).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(0).getMenuComponent(5).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(0).getMenuComponent(6).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(0).getMenuComponent(7).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(0).getMenuComponent(8).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(0).getMenuComponent(9).setEnabled(true);
}","@Override public void actionPerformed(ActionEvent e){
  NewProjectDialog dialog=new NewProjectDialog(frame);
  dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
  dialog.setVisible(true);
  File file=null;
  String projectType=dialog.getProjectType();
  logger.info(""String_Node_Str"" + projectType);
  if (!dialog.isOkPressed()) {
    return;
  }
  frame.setTitle(ProjectConstants.getProjectName(projectType));
  FileBasedProjectManager fileBasedProjectManager=new FileBasedProjectManager(dialog.getProjectDir().getParentFile());
  try {
    fileBasedProjectManager.createProject(""String_Node_Str"",dialog.getProjectDir().getAbsolutePath());
  }
 catch (  ProjectManagerException e1) {
    JOptionPane.showMessageDialog(frame,""String_Node_Str"" + dialog.getProjectDir());
  }
  frame.setPath(dialog.getProjectDir());
switch (projectType) {
case ProjectConstants.mrtBgpDiscovererProjectType:
    file=new File(""String_Node_Str"");
  frame.setProjectType(ProjectConstants.mrtBgpDiscovererProjectType);
frame.setViewerConfig(""String_Node_Str"");
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(0).setEnabled(false);
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(1).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(7).getMenuComponent(4).setEnabled(true);
break;
case ProjectConstants.freeGraphProjectType:
file=new File(""String_Node_Str"");
frame.setProjectType(ProjectConstants.freeGraphProjectType);
frame.setViewerConfig(""String_Node_Str"");
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(0).setEnabled(false);
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(1).setEnabled(false);
frame.getRootPane().getJMenuBar().getMenu(7).getMenuComponent(5).setEnabled(true);
break;
case ProjectConstants.snmpProjectType:
file=new File(""String_Node_Str"");
frame.setProjectType(ProjectConstants.snmpProjectType);
frame.setViewerConfig(""String_Node_Str"");
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(0).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(1).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(7).getMenuComponent(3).setEnabled(true);
break;
case ProjectConstants.snmpBgpDiscovererProjectType:
file=new File(""String_Node_Str"");
frame.setProjectType(ProjectConstants.snmpBgpDiscovererProjectType);
frame.setViewerConfig(""String_Node_Str"");
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(0).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(1).getMenuComponent(1).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(7).getMenuComponent(3).setEnabled(true);
break;
default :
JOptionPane.showMessageDialog(frame,""String_Node_Str"");
}
frame.setPath(dialog.getProjectDir());
frame.getRootPane().getJMenuBar().getMenu(1).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(2).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(3).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(4).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(5).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(6).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(7).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(0).getMenuComponent(4).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(0).getMenuComponent(5).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(0).getMenuComponent(6).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(0).getMenuComponent(7).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(0).getMenuComponent(8).setEnabled(true);
frame.getRootPane().getJMenuBar().getMenu(0).getMenuComponent(9).setEnabled(true);
}"
13026,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public void createSelectionParam(@PathVariable String resourceName,@PathVariable String paramName,@RequestBody String paramValue){
  getResourceManager().createSelectionParam(resourceName,paramName,paramValue);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public void createSelectionParam(@PathVariable String resourceName,@RequestParam String paramName,@RequestParam String paramValue){
  getResourceManager().createSelectionParam(resourceName,paramName,paramValue);
}"
13027,"public Map<String,List<Icon>> getIconsMap(Map<String,GraphmlNode> vertexMap){
  Map<String,DataMatcher> matcherMap=this.dataMatcherMap.getMatcherMap();
  Map<String,List<Icon>> iconMap=new HashMap<>();
  List<IconType> iconTypeList=viewerConfig.getIcon();
  List<IconType.Data> datas;
  for (  GraphmlNode vertice : vertexMap.values()) {
    System.out.println(vertice);
    for (    IconType iconType : iconTypeList) {
      boolean match=true;
      datas=iconType.getData();
      boolean isDefaultIcon=datas.isEmpty();
      for (      IconType.Data data : datas) {
        final String value=vertice.getGraphmlNodeData().get(data.getKey());
        String matcher=data.getMatcher();
        if (matcher == null) {
          matcher=""String_Node_Str"";
        }
        if (value == null) {
          match=false;
          break;
        }
        DataMatcher matcherInstance=matcherMap.get(matcher);
        boolean matchResult=matcherInstance.compareData(value,data.getValue());
        if (!matchResult) {
          match=false;
          break;
        }
      }
      boolean iconExists=iconMap.containsKey(vertice.getId());
      if ((!isDefaultIcon && match) || (isDefaultIcon && !iconExists)) {
        final String name=iconType.getName();
        String[] iconNames=name.split(""String_Node_Str"");
        iconMap.putIfAbsent(vertice.getId(),new ArrayList<>());
        for (int i=1; i < iconNames.length; i++) {
          List<Icon> iconList=iconMap.get(vertice.getId());
          iconList.add(new Icon(iconNames[i].trim()));
        }
        break;
      }
    }
  }
  return iconMap;
}","public Map<String,List<Icon>> getIconsMap(Map<String,GraphmlNode> vertexMap){
  Map<String,DataMatcher> matcherMap=this.dataMatcherMap.getMatcherMap();
  Map<String,List<Icon>> iconMap=new HashMap<>();
  List<IconType> iconTypeList=viewerConfig.getIcon();
  List<IconType.Data> datas;
  for (  GraphmlNode vertice : vertexMap.values()) {
    System.out.println(vertice);
    for (    IconType iconType : iconTypeList) {
      boolean match=true;
      datas=iconType.getData();
      boolean isDefaultIcon=datas.isEmpty();
      for (      IconType.Data data : datas) {
        final String value=vertice.getGraphmlNodeData().get(data.getKey());
        String matcher=data.getMatcher();
        if (matcher == null) {
          matcher=""String_Node_Str"";
        }
        if (value == null) {
          match=false;
          break;
        }
        DataMatcher matcherInstance=matcherMap.get(matcher);
        boolean matchResult=matcherInstance.compareData(value,data.getValue());
        if (!matchResult) {
          match=false;
          break;
        }
      }
      boolean iconExists=iconMap.containsKey(vertice.getId());
      if ((!isDefaultIcon && match) || (isDefaultIcon && !iconExists)) {
        final String name=iconType.getName();
        String[] iconNames=name.split(""String_Node_Str"");
        iconMap.putIfAbsent(vertice.getId(),new ArrayList<>());
        for (int i=0; i < iconNames.length; i++) {
          List<Icon> iconList=iconMap.get(vertice.getId());
          iconList.add(new Icon(iconNames[i].trim()));
        }
        break;
      }
    }
  }
  return iconMap;
}"
13028,"@Override public void deleteConnectionParam(String name,String paramName){
  ConnectionDetails connectionDetails=connectionDetailsMap.get(name);
  if (connectionDetails != null)   connectionDetails.getParams().remove(paramName);
}","@Override public void deleteConnectionParam(String name,String paramName){
  ConnectionDetails connectionDetails=connectionDetailsMap.get(name);
  connectionDetails.removeParam(paramName);
}"
13029,"@Override public void createConnectionParam(String name,String paramName,String paramValue){
  ConnectionDetails connectionDetails=connectionDetailsMap.get(name);
  if (connectionDetails != null)   connectionDetails.put(paramName,paramValue);
}","@Override public void createConnectionParam(String name,String paramName,String paramValue){
  ConnectionDetails connectionDetails=connectionDetailsMap.get(name);
  connectionDetails.put(paramName,paramValue);
}"
13030,"@Override public void updateConnectionParam(String name,String paramName,String paramValue){
  ConnectionDetails connectionDetails=connectionDetailsMap.get(name);
  if (connectionDetails.getParam(paramName) != null) {
    connectionDetails.put(paramName,paramValue);
  }
 else {
  }
}","@Override public void updateConnectionParam(String name,String paramName,String paramValue){
  ConnectionDetails connectionDetails=connectionDetailsMap.get(name);
  connectionDetails.put(paramName,paramValue);
}"
13031,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public void createConnection(@RequestBody String name){
  getConnectionDetailsManager().createConnection(name,null);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public void createConnection(@RequestBody String name){
  getConnectionDetailsManager().createConnection(name,new ConnectionDetails());
}"
13032,"@Override public void handleNodeNeighboursDiscovered(Node node,NodeDiscoveryResult nodeDiscoveryResult){
  File baseDir=new File(projectPath,labelDirName);
  File graphmlDir=new File(baseDir,graphmlDirName);
  if (!graphmlDir.exists())   graphmlDir.mkdir();
  String nodeFileName=node.getId();
  String discoveredIPv4Address=(String)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
  DiscoveredDevice discoveredDevice=(DiscoveredDevice)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
  Map<String,String> subnetDetails=(Map<String,String>)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
  String icmpStatus=(String)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
  String dnsFQDN=(String)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
  String dnsPQDN=(String)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
  HashMap<String,Object> params=new HashMap<>();
  ArrayList<GraphmlNode> graphmlNodes=new ArrayList<>();
  List<GraphmlEdge> graphmlEdges=new ArrayList<>();
  GraphmlNode mainNode=new GraphmlNode(node.getId(),node.getId());
  List<GraphmlNodeData> mainNodeGraphmlDatas=new ArrayList<>();
  if (icmpStatus != null) {
    GraphmlNodeData icmpNodeData=new GraphmlNodeData(""String_Node_Str"",icmpStatus);
    mainNodeGraphmlDatas.add(icmpNodeData);
    GraphmlNodeData discoveredIPv4AddressNodeData=new GraphmlNodeData(""String_Node_Str"",discoveredIPv4Address);
    mainNodeGraphmlDatas.add(discoveredIPv4AddressNodeData);
  }
  if (discoveredDevice != null) {
    GraphmlNodeData snmpStatus=new GraphmlNodeData(""String_Node_Str"",""String_Node_Str"");
    GraphmlNodeData discoveredIPv4AddressNodeData=new GraphmlNodeData(""String_Node_Str"",discoveredIPv4Address);
    mainNodeGraphmlDatas.add(discoveredIPv4AddressNodeData);
    mainNodeGraphmlDatas.add(snmpStatus);
    List<GraphmlNodeData> snmpNodeData=getSnmpMainNode(discoveredDevice);
    mainNodeGraphmlDatas.addAll(snmpNodeData);
    DeviceToGraphml deviceToGraphml=new DeviceToGraphml(node,discoveredDevice);
    graphmlNodes.addAll(deviceToGraphml.getSubnetNodes());
    graphmlNodes.addAll(deviceToGraphml.getNonSubnetNeighbours());
    graphmlEdges=deviceToGraphml.getSubnetEdgesToMainNode();
    graphmlEdges.addAll(deviceToGraphml.getEdgesToNeighbours());
  }
  if (subnetDetails != null) {
    List<GraphmlNodeData> subnetNodeData=getSubnetMainNode(subnetDetails);
    String bogonSubnetMarker=(String)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
    String privateSubnetMarker=(String)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
    if (bogonSubnetMarker != null && bogonSubnetMarker.equals(""String_Node_Str""))     subnetNodeData.add(new GraphmlNodeData(""String_Node_Str"",""String_Node_Str""));
 else     subnetNodeData.add(new GraphmlNodeData(""String_Node_Str"",""String_Node_Str""));
    if (privateSubnetMarker != null && privateSubnetMarker.equals(""String_Node_Str""))     subnetNodeData.add(new GraphmlNodeData(""String_Node_Str"",""String_Node_Str""));
 else     subnetNodeData.add(new GraphmlNodeData(""String_Node_Str"",""String_Node_Str""));
    mainNodeGraphmlDatas.addAll(subnetNodeData);
    String subnetIpAddress=subnetDetails.get(""String_Node_Str"");
    String subnetPrefixMask=subnetDetails.get(""String_Node_Str"");
    nodeFileName=subnetIpAddress + ""String_Node_Str"" + subnetPrefixMask;
  }
  if (dnsFQDN != null) {
    GraphmlNodeData fqdn=new GraphmlNodeData(""String_Node_Str"",dnsFQDN);
    mainNodeGraphmlDatas.add(fqdn);
    GraphmlNodeData pqdn=new GraphmlNodeData(""String_Node_Str"",dnsPQDN);
    mainNodeGraphmlDatas.add(pqdn);
  }
  if (icmpStatus == null && dnsFQDN == null && discoveredDevice == null && subnetDetails == null)   return;
  mainNode.setGraphmlNodeDataList(mainNodeGraphmlDatas);
  graphmlNodes.add(mainNode);
  params.put(""String_Node_Str"",graphmlNodes);
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",graphmlEdges);
  try {
    String projectName=new File(projectPath).getName();
    if (projectName.equals(""String_Node_Str""))     projectName=new File(new File(projectPath).getParent()).getName();
    params.put(""String_Node_Str"",projectName);
    params.put(""String_Node_Str"",baseDir.getCanonicalFile().getName());
  }
 catch (  IOException e) {
    logger.error(e);
  }
  String graphml=null;
  try {
    logger.info(""String_Node_Str"" + node.getId());
    graphml=graphmlRenderer.render(velocityTemplate,params);
    logger.info(""String_Node_Str"" + node.getId());
  }
 catch (  Exception e) {
    logger.trace(e.getMessage());
  }
  logger.trace(graphml);
  final String fileName=""String_Node_Str"" + nodeFileName + ""String_Node_Str"";
  final File nodeFile=new File(graphmlDir,fileName);
  try {
    FileUtils.writeStringToFile(nodeFile,graphml);
    File undirectedGraphmls=new File(graphmlDir.getParent(),""String_Node_Str"" + ""String_Node_Str"");
    if (!undirectedGraphmls.exists()) {
      undirectedGraphmls.createNewFile();
    }
    FileWriter writer=new FileWriter(undirectedGraphmls,true);
    writer.append(String.valueOf(fileName)).append(""String_Node_Str"");
    writer.close();
  }
 catch (  IOException e) {
    logger.error(e.getMessage());
  }
}","@Override public void handleNodeNeighboursDiscovered(Node node,NodeDiscoveryResult nodeDiscoveryResult){
  File baseDir=new File(projectPath,labelDirName);
  File graphmlDir=new File(baseDir,graphmlDirName);
  if (!graphmlDir.exists())   graphmlDir.mkdir();
  String nodeFileName=node.getId();
  String discoveredIPv4Address=(String)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
  DiscoveredDevice discoveredDevice=(DiscoveredDevice)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
  Map<String,String> subnetDetails=(Map<String,String>)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
  String icmpStatus=(String)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
  String dnsFQDN=(String)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
  String dnsPQDN=(String)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
  HashMap<String,Object> params=new HashMap<>();
  ArrayList<GraphmlNode> graphmlNodes=new ArrayList<>();
  List<GraphmlEdge> graphmlEdges=new ArrayList<>();
  GraphmlNode mainNode=new GraphmlNode(node.getId(),node.getId());
  List<GraphmlNodeData> mainNodeGraphmlDatas=new ArrayList<>();
  if (icmpStatus != null) {
    GraphmlNodeData icmpNodeData=new GraphmlNodeData(""String_Node_Str"",icmpStatus);
    mainNodeGraphmlDatas.add(icmpNodeData);
    GraphmlNodeData discoveredIPv4AddressNodeData=new GraphmlNodeData(""String_Node_Str"",discoveredIPv4Address);
    mainNodeGraphmlDatas.add(discoveredIPv4AddressNodeData);
  }
  if (discoveredDevice != null) {
    GraphmlNodeData snmpStatus=new GraphmlNodeData(""String_Node_Str"",""String_Node_Str"");
    GraphmlNodeData discoveredIPv4AddressNodeData=new GraphmlNodeData(""String_Node_Str"",discoveredIPv4Address);
    mainNodeGraphmlDatas.add(discoveredIPv4AddressNodeData);
    mainNodeGraphmlDatas.add(snmpStatus);
    List<GraphmlNodeData> snmpNodeData=getSnmpMainNode(discoveredDevice);
    mainNodeGraphmlDatas.addAll(snmpNodeData);
    DeviceToGraphml deviceToGraphml=new DeviceToGraphml(node,discoveredDevice);
    graphmlNodes.addAll(deviceToGraphml.getSubnetNodes());
    graphmlNodes.addAll(deviceToGraphml.getNonSubnetNeighbours());
    graphmlEdges=deviceToGraphml.getSubnetEdgesToMainNode();
    graphmlEdges.addAll(deviceToGraphml.getEdgesToNeighbours());
  }
  if (subnetDetails != null) {
    List<GraphmlNodeData> subnetNodeData=getSubnetMainNode(subnetDetails);
    String bogonSubnetMarker=(String)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
    String privateSubnetMarker=(String)nodeDiscoveryResult.getDiscoveredData().get(""String_Node_Str"");
    if (bogonSubnetMarker != null && bogonSubnetMarker.equals(""String_Node_Str""))     subnetNodeData.add(new GraphmlNodeData(""String_Node_Str"",""String_Node_Str""));
 else     subnetNodeData.add(new GraphmlNodeData(""String_Node_Str"",""String_Node_Str""));
    if (privateSubnetMarker != null && privateSubnetMarker.equals(""String_Node_Str""))     subnetNodeData.add(new GraphmlNodeData(""String_Node_Str"",""String_Node_Str""));
 else     subnetNodeData.add(new GraphmlNodeData(""String_Node_Str"",""String_Node_Str""));
    mainNodeGraphmlDatas.addAll(subnetNodeData);
    List<GraphmlNode> subnetNeighbourNodes=new ArrayList<>();
    List<GraphmlEdge> subnetNeighbourEdges=new ArrayList<>();
    for (    Node subnetNeighbour : node.getNeighbours()) {
      AliasResolver aliasResolver=new AliasResolver(node,subnetNeighbour.getId(),null,null);
      String neighbourId=aliasResolver.getNeighbourIdFromAliases();
      GraphmlNode subnetNeighbourNode;
      if (neighbourId == null)       neighbourId=subnetNeighbour.getId();
      subnetNeighbourNode=new GraphmlNode(neighbourId,neighbourId);
      subnetNeighbourNodes.add(subnetNeighbourNode);
      EdgeIdGenerator edgeIdGenerator=new EdgeIdGenerator(neighbourId,node.getId(),neighbourId,node.getId());
      GraphmlEdge subnetNeighbourEdge=edgeIdGenerator.createEdge();
      subnetNeighbourEdges.add(subnetNeighbourEdge);
    }
    graphmlNodes.addAll(subnetNeighbourNodes);
    graphmlEdges.addAll(subnetNeighbourEdges);
    String subnetIpAddress=subnetDetails.get(""String_Node_Str"");
    String subnetPrefixMask=subnetDetails.get(""String_Node_Str"");
    nodeFileName=subnetIpAddress + ""String_Node_Str"" + subnetPrefixMask;
  }
  if (dnsFQDN != null) {
    GraphmlNodeData fqdn=new GraphmlNodeData(""String_Node_Str"",dnsFQDN);
    mainNodeGraphmlDatas.add(fqdn);
    GraphmlNodeData pqdn=new GraphmlNodeData(""String_Node_Str"",dnsPQDN);
    mainNodeGraphmlDatas.add(pqdn);
  }
  if (icmpStatus == null && dnsFQDN == null && discoveredDevice == null && subnetDetails == null)   return;
  mainNode.setGraphmlNodeDataList(mainNodeGraphmlDatas);
  graphmlNodes.add(mainNode);
  params.put(""String_Node_Str"",graphmlNodes);
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",graphmlEdges);
  try {
    String projectName=new File(projectPath).getName();
    if (projectName.equals(""String_Node_Str""))     projectName=new File(new File(projectPath).getParent()).getName();
    params.put(""String_Node_Str"",projectName);
    params.put(""String_Node_Str"",baseDir.getCanonicalFile().getName());
  }
 catch (  IOException e) {
    logger.error(e);
  }
  String graphml=null;
  try {
    logger.info(""String_Node_Str"" + node.getId());
    graphml=graphmlRenderer.render(velocityTemplate,params);
    logger.info(""String_Node_Str"" + node.getId());
  }
 catch (  Exception e) {
    logger.trace(e.getMessage());
  }
  logger.trace(graphml);
  final String fileName=""String_Node_Str"" + nodeFileName + ""String_Node_Str"";
  final File nodeFile=new File(graphmlDir,fileName);
  try {
    FileUtils.writeStringToFile(nodeFile,graphml);
    File undirectedGraphmls=new File(graphmlDir.getParent(),""String_Node_Str"" + ""String_Node_Str"");
    if (!undirectedGraphmls.exists()) {
      undirectedGraphmls.createNewFile();
    }
    FileWriter writer=new FileWriter(undirectedGraphmls,true);
    writer.append(String.valueOf(fileName)).append(""String_Node_Str"");
    writer.close();
  }
 catch (  IOException e) {
    logger.error(e.getMessage());
  }
}"
13033,"public List<GraphmlNode> getNonSubnetNeighbours(){
  List<GraphmlNode> neighbourNodes=new ArrayList<>();
  List<DeviceNeighbour> deviceNeighbours=device.getDeviceNeighbours();
  for (  DeviceNeighbour deviceNeighbour : deviceNeighbours) {
    String neighbourIpAddress=deviceNeighbour.getIpAddress();
    String neighbourHostName=deviceNeighbour.getNeighbourHostName();
    String neighbourMac=deviceNeighbour.getNeighbourMac();
    String neighbourId=getNeighbourIdFromAliases(neighbourHostName,neighbourIpAddress,neighbourMac);
    if (neighbourId == null) {
      logger.info(""String_Node_Str"" + deviceNeighbour);
      continue;
    }
    GraphmlNode graphmlNode=new GraphmlNode(neighbourId,neighbourId);
    neighbourNodes.add(graphmlNode);
  }
  return neighbourNodes;
}","public List<GraphmlNode> getNonSubnetNeighbours(){
  List<GraphmlNode> neighbourNodes=new ArrayList<>();
  List<DeviceNeighbour> deviceNeighbours=device.getDeviceNeighbours();
  for (  DeviceNeighbour deviceNeighbour : deviceNeighbours) {
    String neighbourIpAddress=deviceNeighbour.getIpAddress();
    String neighbourHostName=deviceNeighbour.getNeighbourHostName();
    String neighbourMac=deviceNeighbour.getNeighbourMac();
    AliasResolver aliasResolver=new AliasResolver(node,neighbourHostName,neighbourIpAddress,neighbourMac);
    String neighbourId=aliasResolver.getNeighbourIdFromAliases();
    if (neighbourId == null) {
      logger.info(""String_Node_Str"" + deviceNeighbour);
      continue;
    }
    GraphmlNode graphmlNode=new GraphmlNode(neighbourId,neighbourId);
    neighbourNodes.add(graphmlNode);
  }
  return neighbourNodes;
}"
13034,"public List<GraphmlEdge> getEdgesToNeighbours(){
  List<GraphmlEdge> graphmlEdges=new ArrayList<>();
  Set<Subnet> subnetSet=device.getDeviceSubnetsFromActiveInterfaces();
  for (  DiscoveredInterface devInterface : device.getInterfaceList()) {
    String localMac=devInterface.getParams().get(""String_Node_Str"");
    for (    DeviceNeighbour deviceNeighbour : devInterface.getNeighbours()) {
      String neighbourIpAddress=deviceNeighbour.getNeighbourIpAddress();
      String neighbourHostName=deviceNeighbour.getNeighbourHostName();
      String neighbourMac=deviceNeighbour.getNeighbourMac();
      String neighbourId=getNeighbourIdFromAliases(neighbourHostName,neighbourIpAddress,neighbourMac);
      if (neighbourId == null)       continue;
      boolean neighbourInSubnet=false;
      if (neighbourIpAddress != null && !neighbourIpAddress.isEmpty()) {
        for (        Subnet subnet : subnetSet) {
          if (subnet.contains(neighbourIpAddress)) {
            EdgeIdGenerator edgeIdGenerator=new EdgeIdGenerator(neighbourId,subnet.getName(),neighbourIpAddress,subnet.getIpAddress());
            GraphmlEdge graphmlEdge=edgeIdGenerator.createEdge();
            graphmlEdge.setGraphmlEdgeDataList(getGraphmlDirectNeighbourEdgeMetaData(deviceNeighbour));
            boolean edgeAlreadyDefined=false;
            for (            GraphmlEdge edge : graphmlEdges) {
              if (edge.getId().equals(graphmlEdge.getId())) {
                edgeAlreadyDefined=true;
                int index=graphmlEdges.indexOf(edge);
                logger.info(graphmlEdge + ""String_Node_Str"");
                List<GraphmlEdgeData> existingGraphmlEdgeDatas=edge.getGraphmlEdgeDataList();
                List<GraphmlEdgeData> newGraphmlEdgeDatas=graphmlEdge.getGraphmlEdgeDataList();
                edge.setGraphmlEdgeDataList(new ArrayList<>(combineEdgeMetaDatas(existingGraphmlEdgeDatas,newGraphmlEdgeDatas)));
                graphmlEdges.set(index,edge);
              }
            }
            if (!edgeAlreadyDefined) {
              graphmlEdges.add(graphmlEdge);
            }
            neighbourInSubnet=true;
            break;
          }
        }
      }
      if (!neighbourInSubnet) {
        EdgeIdGenerator edgeIdGenerator=new EdgeIdGenerator(neighbourId,node.getId(),neighbourId,node.getId(),localMac,neighbourMac);
        GraphmlEdge graphmlEdge=edgeIdGenerator.createEdge();
        graphmlEdge.setGraphmlEdgeDataList(getGraphmlDirectNeighbourEdgeMetaData(deviceNeighbour));
        boolean edgeAlreadyDefined=false;
        for (        GraphmlEdge edge : graphmlEdges) {
          if (edge.getId().equals(graphmlEdge.getId())) {
            edgeAlreadyDefined=true;
            int index=graphmlEdges.indexOf(edge);
            logger.info(graphmlEdge + ""String_Node_Str"");
            List<GraphmlEdgeData> existingGraphmlEdgeDatas=edge.getGraphmlEdgeDataList();
            List<GraphmlEdgeData> newGraphmlEdgeDatas=graphmlEdge.getGraphmlEdgeDataList();
            edge.setGraphmlEdgeDataList(new ArrayList<>(combineEdgeMetaDatas(existingGraphmlEdgeDatas,newGraphmlEdgeDatas)));
            graphmlEdges.set(index,edge);
          }
        }
        if (!edgeAlreadyDefined) {
          graphmlEdges.add(graphmlEdge);
        }
      }
    }
  }
  for (  DeviceNeighbour deviceNeighbour : device.getLogicalDeviceData().getDeviceNeighbourList()) {
    String neighbourIpAddress=deviceNeighbour.getNeighbourIpAddress();
    String neighbourHostName=deviceNeighbour.getNeighbourHostName();
    String neighbourMac=deviceNeighbour.getNeighbourMac();
    String neighbourId=getNeighbourIdFromAliases(neighbourHostName,neighbourIpAddress,neighbourMac);
    if (neighbourId == null)     continue;
    boolean neighbourInSubnet=false;
    if (neighbourIpAddress != null && !neighbourIpAddress.isEmpty()) {
      for (      Subnet subnet : subnetSet) {
        if (subnet.contains(neighbourIpAddress)) {
          EdgeIdGenerator edgeIdGenerator=new EdgeIdGenerator(neighbourId,subnet.getName(),neighbourIpAddress,subnet.getIpAddress());
          GraphmlEdge graphmlEdge=edgeIdGenerator.createEdge();
          graphmlEdge.setGraphmlEdgeDataList(getGraphmlDirectNeighbourEdgeMetaData(deviceNeighbour));
          boolean edgeAlreadyDefined=false;
          for (          GraphmlEdge edge : graphmlEdges) {
            if (edge.getId().equals(graphmlEdge.getId())) {
              edgeAlreadyDefined=true;
              int index=graphmlEdges.indexOf(edge);
              logger.info(graphmlEdge + ""String_Node_Str"");
              List<GraphmlEdgeData> existingGraphmlEdgeDatas=edge.getGraphmlEdgeDataList();
              List<GraphmlEdgeData> newGraphmlEdgeDatas=graphmlEdge.getGraphmlEdgeDataList();
              edge.setGraphmlEdgeDataList(new ArrayList<>(combineEdgeMetaDatas(existingGraphmlEdgeDatas,newGraphmlEdgeDatas)));
              graphmlEdges.set(index,edge);
            }
          }
          if (!edgeAlreadyDefined) {
            graphmlEdges.add(graphmlEdge);
          }
          neighbourInSubnet=true;
          break;
        }
      }
    }
    if (!neighbourInSubnet) {
      EdgeIdGenerator edgeIdGenerator=new EdgeIdGenerator(neighbourId,node.getId(),neighbourId,node.getId());
      GraphmlEdge graphmlEdge=edgeIdGenerator.createEdge();
      graphmlEdge.setGraphmlEdgeDataList(getGraphmlDirectNeighbourEdgeMetaData(deviceNeighbour));
      boolean edgeAlreadyDefined=false;
      for (      GraphmlEdge edge : graphmlEdges) {
        if (edge.getId().equals(graphmlEdge.getId())) {
          edgeAlreadyDefined=true;
          int index=graphmlEdges.indexOf(edge);
          logger.info(graphmlEdge + ""String_Node_Str"");
          edge.setGraphmlEdgeDataList(new ArrayList<>(combineEdgeMetaDatas(edge.getGraphmlEdgeDataList(),graphmlEdge.getGraphmlEdgeDataList())));
          graphmlEdges.set(index,edge);
        }
      }
      if (!edgeAlreadyDefined) {
        graphmlEdges.add(graphmlEdge);
      }
    }
  }
  return graphmlEdges;
}","public List<GraphmlEdge> getEdgesToNeighbours(){
  List<GraphmlEdge> graphmlEdges=new ArrayList<>();
  Set<Subnet> subnetSet=device.getDeviceSubnetsFromActiveInterfaces();
  for (  DiscoveredInterface devInterface : device.getInterfaceList()) {
    String localMac=devInterface.getParams().get(""String_Node_Str"");
    for (    DeviceNeighbour deviceNeighbour : devInterface.getNeighbours()) {
      String neighbourIpAddress=deviceNeighbour.getNeighbourIpAddress();
      String neighbourHostName=deviceNeighbour.getNeighbourHostName();
      String neighbourMac=deviceNeighbour.getNeighbourMac();
      AliasResolver aliasResolver=new AliasResolver(node,neighbourHostName,neighbourIpAddress,neighbourMac);
      String neighbourId=aliasResolver.getNeighbourIdFromAliases();
      if (neighbourId == null)       continue;
      boolean neighbourInSubnet=false;
      if (neighbourIpAddress != null && !neighbourIpAddress.isEmpty()) {
        for (        Subnet subnet : subnetSet) {
          if (subnet.contains(neighbourIpAddress)) {
            EdgeIdGenerator edgeIdGenerator=new EdgeIdGenerator(neighbourId,subnet.getName(),neighbourIpAddress,subnet.getIpAddress());
            GraphmlEdge graphmlEdge=edgeIdGenerator.createEdge();
            graphmlEdge.setGraphmlEdgeDataList(getGraphmlDirectNeighbourEdgeMetaData(deviceNeighbour));
            boolean edgeAlreadyDefined=false;
            for (            GraphmlEdge edge : graphmlEdges) {
              if (edge.getId().equals(graphmlEdge.getId())) {
                edgeAlreadyDefined=true;
                int index=graphmlEdges.indexOf(edge);
                logger.info(graphmlEdge + ""String_Node_Str"");
                List<GraphmlEdgeData> existingGraphmlEdgeDatas=edge.getGraphmlEdgeDataList();
                List<GraphmlEdgeData> newGraphmlEdgeDatas=graphmlEdge.getGraphmlEdgeDataList();
                edge.setGraphmlEdgeDataList(new ArrayList<>(combineEdgeMetaDatas(existingGraphmlEdgeDatas,newGraphmlEdgeDatas)));
                graphmlEdges.set(index,edge);
              }
            }
            if (!edgeAlreadyDefined) {
              graphmlEdges.add(graphmlEdge);
            }
            neighbourInSubnet=true;
            break;
          }
        }
      }
      if (!neighbourInSubnet) {
        EdgeIdGenerator edgeIdGenerator=new EdgeIdGenerator(neighbourId,node.getId(),neighbourId,node.getId(),localMac,neighbourMac);
        GraphmlEdge graphmlEdge=edgeIdGenerator.createEdge();
        graphmlEdge.setGraphmlEdgeDataList(getGraphmlDirectNeighbourEdgeMetaData(deviceNeighbour));
        boolean edgeAlreadyDefined=false;
        for (        GraphmlEdge edge : graphmlEdges) {
          if (edge.getId().equals(graphmlEdge.getId())) {
            edgeAlreadyDefined=true;
            int index=graphmlEdges.indexOf(edge);
            logger.info(graphmlEdge + ""String_Node_Str"");
            List<GraphmlEdgeData> existingGraphmlEdgeDatas=edge.getGraphmlEdgeDataList();
            List<GraphmlEdgeData> newGraphmlEdgeDatas=graphmlEdge.getGraphmlEdgeDataList();
            edge.setGraphmlEdgeDataList(new ArrayList<>(combineEdgeMetaDatas(existingGraphmlEdgeDatas,newGraphmlEdgeDatas)));
            graphmlEdges.set(index,edge);
          }
        }
        if (!edgeAlreadyDefined) {
          graphmlEdges.add(graphmlEdge);
        }
      }
    }
  }
  for (  DeviceNeighbour deviceNeighbour : device.getLogicalDeviceData().getDeviceNeighbourList()) {
    String neighbourIpAddress=deviceNeighbour.getNeighbourIpAddress();
    String neighbourHostName=deviceNeighbour.getNeighbourHostName();
    String neighbourMac=deviceNeighbour.getNeighbourMac();
    AliasResolver aliasResolver=new AliasResolver(node,neighbourHostName,neighbourIpAddress,neighbourMac);
    String neighbourId=aliasResolver.getNeighbourIdFromAliases();
    if (neighbourId == null)     continue;
    boolean neighbourInSubnet=false;
    if (neighbourIpAddress != null && !neighbourIpAddress.isEmpty()) {
      for (      Subnet subnet : subnetSet) {
        if (subnet.contains(neighbourIpAddress)) {
          EdgeIdGenerator edgeIdGenerator=new EdgeIdGenerator(neighbourId,subnet.getName(),neighbourIpAddress,subnet.getIpAddress());
          GraphmlEdge graphmlEdge=edgeIdGenerator.createEdge();
          graphmlEdge.setGraphmlEdgeDataList(getGraphmlDirectNeighbourEdgeMetaData(deviceNeighbour));
          boolean edgeAlreadyDefined=false;
          for (          GraphmlEdge edge : graphmlEdges) {
            if (edge.getId().equals(graphmlEdge.getId())) {
              edgeAlreadyDefined=true;
              int index=graphmlEdges.indexOf(edge);
              logger.info(graphmlEdge + ""String_Node_Str"");
              List<GraphmlEdgeData> existingGraphmlEdgeDatas=edge.getGraphmlEdgeDataList();
              List<GraphmlEdgeData> newGraphmlEdgeDatas=graphmlEdge.getGraphmlEdgeDataList();
              edge.setGraphmlEdgeDataList(new ArrayList<>(combineEdgeMetaDatas(existingGraphmlEdgeDatas,newGraphmlEdgeDatas)));
              graphmlEdges.set(index,edge);
            }
          }
          if (!edgeAlreadyDefined) {
            graphmlEdges.add(graphmlEdge);
          }
          neighbourInSubnet=true;
          break;
        }
      }
    }
    if (!neighbourInSubnet) {
      EdgeIdGenerator edgeIdGenerator=new EdgeIdGenerator(neighbourId,node.getId(),neighbourId,node.getId());
      GraphmlEdge graphmlEdge=edgeIdGenerator.createEdge();
      graphmlEdge.setGraphmlEdgeDataList(getGraphmlDirectNeighbourEdgeMetaData(deviceNeighbour));
      boolean edgeAlreadyDefined=false;
      for (      GraphmlEdge edge : graphmlEdges) {
        if (edge.getId().equals(graphmlEdge.getId())) {
          edgeAlreadyDefined=true;
          int index=graphmlEdges.indexOf(edge);
          logger.info(graphmlEdge + ""String_Node_Str"");
          edge.setGraphmlEdgeDataList(new ArrayList<>(combineEdgeMetaDatas(edge.getGraphmlEdgeDataList(),graphmlEdge.getGraphmlEdgeDataList())));
          graphmlEdges.set(index,edge);
        }
      }
      if (!edgeAlreadyDefined) {
        graphmlEdges.add(graphmlEdge);
      }
    }
  }
  return graphmlEdges;
}"
13035,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) @ResponseBody void deleteConnectionParam(@PathVariable String connectionDetailsName,@PathVariable String paramName){
  getConnectionDetailsManager().getConnection(connectionDetailsName).getParams().remove(paramName);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) @ResponseBody void deleteConnectionParam(@PathVariable String connectionDetailsName,@PathVariable String paramName){
  getConnectionDetailsManager().deleteConnectionParam(connectionDetailsName,paramName);
}"
13036,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody void createConnectionParam(@PathVariable String connectionDetailsName,@RequestBody String paramName,@RequestBody String paramValue){
  Map<String,String> params=getConnectionDetailsManager().getConnection(connectionDetailsName).getParams();
  params.put(paramName,paramValue);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody void createConnectionParam(@PathVariable String connectionDetailsName,@RequestParam String paramName,@RequestParam String paramValue){
  getConnectionDetailsManager().createConnectionParam(connectionDetailsName,paramName,paramValue);
}"
13037,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.PUT) @ResponseBody void updateConnectionParam(@PathVariable String connectionDetailsName,@PathVariable String paramName,@RequestBody String paramValue){
  Map<String,String> params=getConnectionDetailsManager().getConnection(connectionDetailsName).getParams();
  params.put(paramName,paramValue);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.PUT) @ResponseBody void updateConnectionParam(@PathVariable String connectionDetailsName,@PathVariable String paramName,@RequestBody String paramValue){
  getConnectionDetailsManager().updateConnectionParam(connectionDetailsName,paramName,paramValue);
}"
13038,"public void setDeviceSubnets(List<Subnet> deviceSubnets){
  this.deviceSubnets=deviceSubnets;
}","public void setDeviceSubnets(Set<Subnet> deviceSubnets){
  this.deviceSubnets=deviceSubnets;
}"
13039,"public List<Subnet> getDeviceSubnets(){
  return deviceSubnets;
}","public Set<Subnet> getDeviceSubnets(){
  return deviceSubnets;
}"
13040,"private List<Subnet> createDeviceSubnets(DiscoveredDeviceData discoveredDeviceData){
  List<ObjectType> objList1=discoveredDeviceData.getObject();
  List<Subnet> result=new ArrayList<Subnet>();
  for (  ObjectType objectType1 : objList1) {
    String objectType=objectType1.getObjectType();
    if (objectType.equals(""String_Node_Str"")) {
      String interfaceName=objectType1.getName();
      List<ObjectType> objList2=objectType1.getObject();
      for (      ObjectType objectType2 : objList2) {
        String objectTypeType2=objectType2.getObjectType();
        if (objectTypeType2.equals(""String_Node_Str"")) {
          ParametersType params2=objectType2.getParameters();
          HashMap<String,String> params2Map=new HashMap<String,String>();
          for (          ParameterType params2Param : params2.getParameter()) {
            params2Map.put(params2Param.getName(),params2Param.getValue());
          }
          String subnetType=""String_Node_Str"";
          String ipSubnetMask=params2Map.get(""String_Node_Str"");
          String ipv4Subnet=params2Map.get(""String_Node_Str"");
          Subnet subnet=new Subnet(ipv4Subnet + ""String_Node_Str"" + ipSubnetMask,ipv4Subnet,ipSubnetMask,interfaceName,subnetType);
          result.add(subnet);
          continue;
        }
        if (objectTypeType2.equals(""String_Node_Str"")) {
          ParametersType params2=objectType2.getParameters();
          HashMap<String,String> params2Map=new HashMap<String,String>();
          for (          ParameterType params2Param : params2.getParameter()) {
            params2Map.put(params2Param.getName(),params2Param.getValue());
          }
          String subnetType=""String_Node_Str"";
          String ipSubnetMask=params2Map.get(""String_Node_Str"");
          String ipv6Subnet=params2Map.get(""String_Node_Str"");
          Subnet subnet=new Subnet(ipv6Subnet + ""String_Node_Str"" + ipSubnetMask,ipv6Subnet,ipSubnetMask,interfaceName,subnetType);
          result.add(subnet);
          continue;
        }
      }
    }
  }
  return result;
}","private Set<Subnet> createDeviceSubnets(DiscoveredDeviceData discoveredDeviceData){
  List<ObjectType> objList1=discoveredDeviceData.getObject();
  Set<Subnet> result=new HashSet<>();
  for (  ObjectType objectType1 : objList1) {
    String objectType=objectType1.getObjectType();
    if (objectType.equals(""String_Node_Str"")) {
      String interfaceName=objectType1.getName();
      List<ObjectType> objList2=objectType1.getObject();
      for (      ObjectType objectType2 : objList2) {
        String objectTypeType2=objectType2.getObjectType();
        if (objectTypeType2.equals(""String_Node_Str"")) {
          ParametersType params2=objectType2.getParameters();
          HashMap<String,String> params2Map=new HashMap<String,String>();
          for (          ParameterType params2Param : params2.getParameter()) {
            params2Map.put(params2Param.getName(),params2Param.getValue());
          }
          String subnetType=""String_Node_Str"";
          String ipSubnetMask=params2Map.get(""String_Node_Str"");
          String ipv4Subnet=params2Map.get(""String_Node_Str"");
          Subnet subnet=new Subnet(ipv4Subnet + ""String_Node_Str"" + ipSubnetMask,ipv4Subnet,ipSubnetMask,interfaceName,subnetType);
          result.add(subnet);
          continue;
        }
        if (objectTypeType2.equals(""String_Node_Str"")) {
          ParametersType params2=objectType2.getParameters();
          HashMap<String,String> params2Map=new HashMap<String,String>();
          for (          ParameterType params2Param : params2.getParameter()) {
            params2Map.put(params2Param.getName(),params2Param.getValue());
          }
          String subnetType=""String_Node_Str"";
          String ipSubnetMask=params2Map.get(""String_Node_Str"");
          String ipv6Subnet=params2Map.get(""String_Node_Str"");
          Subnet subnet=new Subnet(ipv6Subnet + ""String_Node_Str"" + ipSubnetMask,ipv6Subnet,ipSubnetMask,interfaceName,subnetType);
          result.add(subnet);
          continue;
        }
      }
    }
  }
  return result;
}"
13041,"public Device createDevice(DiscoveredDeviceData discoveredDeviceData){
  Device device=new Device(discoveredDeviceData.getName());
  List<DeviceNeighbour> deviceNeighbours=createDeviceNeighbours(discoveredDeviceData);
  List<Subnet> deviceSubnets=createDeviceSubnets(discoveredDeviceData);
  List<MacAddress> deviceMacAddresses=createDeviceMacAddreses(discoveredDeviceData);
  device.setDeviceNeighbours(deviceNeighbours);
  device.setDeviceSubnets(deviceSubnets);
  device.setDeviceMacAddresses(deviceMacAddresses);
  return device;
}","public Device createDevice(DiscoveredDeviceData discoveredDeviceData){
  Device device=new Device(discoveredDeviceData.getName());
  List<DeviceNeighbour> deviceNeighbours=createDeviceNeighbours(discoveredDeviceData);
  Set<Subnet> deviceSubnets=createDeviceSubnets(discoveredDeviceData);
  List<MacAddress> deviceMacAddresses=createDeviceMacAddreses(discoveredDeviceData);
  device.setDeviceNeighbours(deviceNeighbours);
  device.setDeviceSubnets(deviceSubnets);
  device.setDeviceMacAddresses(deviceMacAddresses);
  return device;
}"
13042,"private LogicalDeviceData createLogicalData(ObjectType objectType){
  List<DeviceNeighbour> neighbours=new ArrayList<>();
  List<ObjectType> objList2=objectType.getObject();
  for (  ObjectType type : objList2) {
    if (type.getObjectType().equals(""String_Node_Str"")) {
      neighbours.add(createNeighbour(objectType));
    }
 else {
      logger.info(""String_Node_Str"" + type.getObjectType());
    }
  }
  return new LogicalDeviceData(neighbours);
}","private LogicalDeviceData createLogicalData(ObjectType objectType){
  List<DeviceNeighbour> neighbours=new ArrayList<>();
  List<ObjectType> objList2=objectType.getObject();
  for (  ObjectType type : objList2) {
    if (type.getObjectType().equals(""String_Node_Str"")) {
      neighbours.add(createNeighbour(type));
      System.out.println(""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"" + type.getObjectType());
    }
  }
  return new LogicalDeviceData(neighbours);
}"
13043,"public List<Subnet> getDeviceSubnetsFromActiveInterfaces(){
  List<Subnet> subnets=new ArrayList<>();
  for (  DiscoveredInterface discoveredInterface : interfaceList) {
    String status=discoveredInterface.getParams().get(""String_Node_Str"");
    if (status.equals(""String_Node_Str"")) {
      List<DiscoveredIPv4Address> iPv4Addresses=discoveredInterface.getiPv4AddressList();
      for (      DiscoveredIPv4Address iPv4Address : iPv4Addresses) {
        String ipv4Subnet=iPv4Address.getParams().get(""String_Node_Str"");
        String ipSubnetMask=iPv4Address.getParams().get(""String_Node_Str"");
        String ipv4SubnetPrefix=iPv4Address.getParams().get(""String_Node_Str"");
        String subnetName=ipv4Subnet + ""String_Node_Str"" + ipv4SubnetPrefix;
        String ipv4SubnetBroadcast=iPv4Address.getParams().get(""String_Node_Str"");
        Subnet subnet=new Subnet(subnetName);
        if (ipv4SubnetPrefix.equals(""String_Node_Str"") || iPv4Address.isBogon()) {
          continue;
        }
        subnet.setSubnetMask(ipSubnetMask);
        subnet.setSubnetPrefixMask(ipv4SubnetPrefix);
        subnet.setIpAddress(ipv4Subnet);
        subnet.setLocalInterface(discoveredInterface.getName());
        subnet.setSubnetProtocolType(""String_Node_Str"");
        subnet.setIpv4SubnetBroadcast(ipv4SubnetBroadcast);
        try {
          subnet.setSubnetDiscoveryMethods(discoveredInterface.getDiscoveryMethodsPerSubnet(subnetName,""String_Node_Str""));
        }
 catch (        UnknownHostException e) {
          e.printStackTrace();
        }
        subnets.add(subnet);
      }
    }
  }
  return subnets;
}","public Set<Subnet> getDeviceSubnetsFromActiveInterfaces(){
  Set<Subnet> subnets=new HashSet<>();
  for (  DiscoveredInterface discoveredInterface : interfaceList) {
    String status=discoveredInterface.getParams().get(""String_Node_Str"");
    if (status.equals(""String_Node_Str"")) {
      List<DiscoveredIPv4Address> iPv4Addresses=discoveredInterface.getiPv4AddressList();
      for (      DiscoveredIPv4Address iPv4Address : iPv4Addresses) {
        String ipv4Subnet=iPv4Address.getParams().get(""String_Node_Str"");
        String ipSubnetMask=iPv4Address.getParams().get(""String_Node_Str"");
        String ipv4SubnetPrefix=iPv4Address.getParams().get(""String_Node_Str"");
        String subnetName=ipv4Subnet + ""String_Node_Str"" + ipv4SubnetPrefix;
        String ipv4SubnetBroadcast=iPv4Address.getParams().get(""String_Node_Str"");
        Subnet subnet=new Subnet(subnetName);
        if (ipv4SubnetPrefix.equals(""String_Node_Str"") || iPv4Address.isBogon()) {
          continue;
        }
        subnet.setSubnetMask(ipSubnetMask);
        subnet.setSubnetPrefixMask(ipv4SubnetPrefix);
        subnet.setIpAddress(ipv4Subnet);
        subnet.setLocalInterface(discoveredInterface.getName());
        subnet.setSubnetProtocolType(""String_Node_Str"");
        subnet.setIpv4SubnetBroadcast(ipv4SubnetBroadcast);
        try {
          subnet.setSubnetDiscoveryMethods(discoveredInterface.getDiscoveryMethodsPerSubnet(subnetName,""String_Node_Str""));
        }
 catch (        UnknownHostException e) {
          e.printStackTrace();
        }
        subnets.add(subnet);
      }
    }
  }
  return subnets;
}"
13044,"public String render(String template,HashMap<String,Object> parameters) throws Exception {
  VelocityEngine ve=new VelocityEngine();
  ve.init();
  Template t=ve.getTemplate(template);
  VelocityContext context=new VelocityContext();
  for (  Map.Entry<String,Object> entry : parameters.entrySet()) {
    context.put(entry.getKey(),entry.getValue());
  }
  StringWriter writer=new StringWriter();
  t.merge(context,writer);
  return writer.toString();
}","public String render(String template,HashMap<String,Object> parameters) throws Exception {
  VelocityEngine ve=new VelocityEngine();
  ve.setProperty(RuntimeConstants.RESOURCE_LOADER,""String_Node_Str"");
  ve.setProperty(""String_Node_Str"",ClasspathResourceLoader.class.getName());
  ve.init();
  Template t=ve.getTemplate(template);
  VelocityContext context=new VelocityContext();
  for (  Map.Entry<String,Object> entry : parameters.entrySet()) {
    context.put(entry.getKey(),entry.getValue());
  }
  StringWriter writer=new StringWriter();
  t.merge(context,writer);
  return writer.toString();
}"
13045,"@Override public void networkDiscovered(NetworkDiscoveryResult result){
  File baseDir=new File(projectPath,ProjectConstants.networkGraphmlFileName);
  if (!baseDir.exists())   baseDir.mkdir();
  File labelDirPath=new File(baseDir,labelDirName);
  if (!labelDirPath.exists())   labelDirPath.mkdir();
  File graphmlDir=new File(labelDirName,getGraphmlDirName());
  if (!graphmlDir.exists())   graphmlDir.mkdir();
  Map<String,NodeDiscoveryResult> discoveryResultMap=result.getDiscoveredData();
  for (  String node : discoveryResultMap.keySet()) {
    byte[] discoveredDeviceData=(byte[])discoveryResultMap.get(node).getDiscoveredData(""String_Node_Str"");
    try {
      final String fileName=ProjectConstants.networkGraphmlFileName;
      final File nodeFile=new File(graphmlDir,fileName);
      String graphml=new String(discoveredDeviceData);
      FileUtils.writeStringToFile(nodeFile,graphml);
      FileWriter writer=new FileWriter(new File(labelDirName,""String_Node_Str"" + ""String_Node_Str""),true);
      writer.append(String.valueOf(fileName)).append(""String_Node_Str"");
      writer.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","@Override public void networkDiscovered(NetworkDiscoveryResult result){
  File baseDir=new File(projectPath);
  if (!baseDir.exists())   baseDir.mkdir();
  File labelDirPath=new File(baseDir,labelDirName);
  if (!labelDirPath.exists())   labelDirPath.mkdir();
  File graphmlDir=new File(labelDirPath,graphmlDirName);
  if (!graphmlDir.exists())   graphmlDir.mkdir();
  Map<String,NodeDiscoveryResult> discoveryResultMap=result.getDiscoveredData();
  for (  String node : discoveryResultMap.keySet()) {
    byte[] discoveredDeviceData=(byte[])discoveryResultMap.get(node).getDiscoveredData(""String_Node_Str"");
    try {
      final String fileName=ProjectConstants.networkGraphmlFileName;
      final File nodeFile=new File(graphmlDir,fileName);
      String graphml=new String(discoveredDeviceData);
      FileUtils.writeStringToFile(nodeFile,graphml);
      FileWriter writer=new FileWriter(new File(labelDirPath,""String_Node_Str"" + ""String_Node_Str""),true);
      writer.append(String.valueOf(fileName)).append(""String_Node_Str"");
      writer.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}"
13046,"@Override public void networkDiscovered(NetworkDiscoveryResult result){
  File outFile=new File(projectPath,labelDirName + File.separator + graphmlDataDirName+ File.separator+ ProjectConstants.networkGraphmlFileName);
  File dir=new File(projectPath,labelDirName + File.separator + graphmlDataDirName);
  File[] files=dir.listFiles(new FileFilter(){
    @Override public boolean accept(    File pathname){
      return pathname.getName().endsWith(""String_Node_Str"");
    }
  }
);
  if (files == null) {
    return;
  }
  try {
    new GrahmlMerge().merge(files,outFile,vertexTypes,edgesTypes,""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","@Override public void networkDiscovered(NetworkDiscoveryResult result){
  File outFile=new File(projectPath,labelDirName + File.separator + graphmlDataDirName+ File.separator+ ProjectConstants.networkGraphmlFileName);
  File dir=new File(projectPath,labelDirName + File.separator + graphmlDataDirName);
  File[] files=dir.listFiles(new FileFilter(){
    @Override public boolean accept(    File pathname){
      return pathname.getName().endsWith(""String_Node_Str"");
    }
  }
);
  if (files == null) {
    logger.error(""String_Node_Str"");
    return;
  }
  try {
    new GrahmlMerge().merge(files,outFile,vertexTypes,edgesTypes,""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
13047,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public void createConnection(@RequestBody String name,@RequestBody ConnectionDetails connectionDetails){
  getConnectionDetailsManager().createConnection(name,connectionDetails);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public void createConnection(@RequestBody String name){
  getConnectionDetailsManager().createConnection(name,null);
}"
13048,"public CmdRightClickHandler(ResourceManager resourceManager){
  this.resourceManager=resourceManager;
}","public CmdRightClickHandler(ResourceManager resourceManager,ResourceResolver resourceResolver){
  this.resourceManager=resourceManager;
  this.resourceResolver=resourceResolver;
}"
13049,"/** 
 * Create the panel.
 */
public DiscoveryResourcePanel(){
  this.resources=new ResourcesType();
  this.setLayout(new BorderLayout());
  this.setBorder(new EmptyBorder(5,5,5,5));
  JLabel label_1=new JLabel(""String_Node_Str"");
  label_1.setBounds(148,11,140,14);
  add(label_1);
  JLabel label_2=new JLabel(""String_Node_Str"");
  label_2.setBounds(148,182,140,14);
  add(label_2);
  JSeparator separator=new JSeparator();
  add(separator);
  comboBox=new JComboBox();
  comboBox.setEditable(true);
  comboBox.setModel(new DefaultComboBoxModel(new String[]{}));
  comboBox.setBounds(254,179,82,20);
  comboBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      int index=comboBox.getSelectedIndex();
      if (index < 0)       return;
      onConnectionComboBoxChanged(index);
    }
  }
);
  add(comboBox);
  JPanel description=new JPanel();
  JScrollPane scrollPane=new JScrollPane();
  scrollPane.setBounds(149,36,293,88);
  add(scrollPane);
  JTable resourceParamsTable=new JTable();
  resourceParamsTableModel=new DefaultTableModel(new Object[][]{},new String[]{""String_Node_Str"",""String_Node_Str""});
  resourceParamsTable.setModel(resourceParamsTableModel);
  scrollPane.setViewportView(resourceParamsTable);
  JScrollPane scrollPane_1=new JScrollPane();
  scrollPane_1.setBounds(148,207,294,143);
  add(scrollPane_1);
  JTable connectionParamsTable=new JTable();
  resourceConnectionParamsTableModel=new DefaultTableModel(new Object[][]{},new String[]{""String_Node_Str"",""String_Node_Str""});
  connectionParamsTable.setModel(resourceConnectionParamsTableModel);
  connectionParamsTable.getColumnModel().getColumn(0).setPreferredWidth(90);
  scrollPane_1.setViewportView(connectionParamsTable);
  resourcesTable=new JTable();
  String[] columnNames={""String_Node_Str""};
  Object[][] data={};
  resourcesTableModel=new DefaultTableModel(data,columnNames);
  resourcesTable.setModel(resourcesTableModel);
  resourcesTable.setSelectionMode(DefaultListSelectionModel.SINGLE_SELECTION);
  resourcesTable.getSelectionModel().addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (!e.getValueIsAdjusting()) {
        int selectedRow=resourcesTable.getSelectedRow();
        onSelectedResource(selectedRow);
      }
    }
  }
);
  resourcesTableModel.addTableModelListener(new TableModelListener(){
    @Override public void tableChanged(    TableModelEvent e){
      int index=e.getFirstRow();
      if (e.getType() == TableModelEvent.INSERT) {
        resources.getResource().add(index,new ResourceType());
      }
 else       if (e.getType() == TableModelEvent.DELETE) {
        resources.getResource().remove(index);
      }
 else {
        resources.getResource().get(index).setName((String)((DefaultTableModel)e.getSource()).getValueAt(index,0));
      }
    }
  }
);
  JScrollPane scrollPane_2=new JScrollPane();
  scrollPane_2.setBounds(20,36,102,314);
  add(scrollPane_2);
  scrollPane_2.setViewportView(resourcesTable);
  JButton button=new JButton(""String_Node_Str"");
  button.addActionListener(new RowAddListener(resourcesTable));
  button.setBounds(10,361,46,23);
  add(button);
  JButton button_1=new JButton(""String_Node_Str"");
  button_1.addActionListener(new RowRemoveListener(resourcesTable));
  button_1.setBounds(74,361,46,23);
  add(button_1);
  JButton button_2=new JButton(""String_Node_Str"");
  button_2.addActionListener(new RowAddListener(connectionParamsTable));
  button_2.setBounds(148,361,46,23);
  add(button_2);
  JButton button_3=new JButton(""String_Node_Str"");
  button_3.addActionListener(new RowRemoveListener(connectionParamsTable));
  button_3.setBounds(204,361,46,23);
  add(button_3);
  JButton button_4=new JButton(""String_Node_Str"");
  button_4.addActionListener(new RowAddListener(resourceParamsTable));
  button_4.setBounds(148,130,46,23);
  add(button_4);
  JButton button_5=new JButton(""String_Node_Str"");
  button_5.addActionListener(new RowRemoveListener(resourceParamsTable));
  button_5.setBounds(204,130,46,23);
  add(button_5);
  JButton button_6=new JButton(""String_Node_Str"");
  button_6.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      onAddConnection();
    }
  }
);
  button_6.setBounds(346,178,46,23);
  add(button_6);
  JButton btnNewButton=new JButton(""String_Node_Str"");
  btnNewButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      onRemoveConnection();
    }
  }
);
  btnNewButton.setBounds(396,178,46,23);
  add(btnNewButton);
  add(new Label());
  String text=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  JLabel help=new JLabel(text){
    public Dimension getPreferredSize(){
      return new Dimension(400,400);
    }
    public Dimension getMinimumSize(){
      return new Dimension(400,400);
    }
    public Dimension getMaximumSize(){
      return new Dimension(400,400);
    }
  }
;
  help.setVerticalAlignment(SwingConstants.TOP);
  help.setHorizontalAlignment(SwingConstants.LEFT);
  description.add(help);
  add(description,BorderLayout.EAST);
}","/** 
 * Create the panel.
 */
public DiscoveryResourcePanel(){
  this.resources=new ResourcesType();
  this.setLayout(new BorderLayout());
  this.setBorder(new EmptyBorder(5,5,5,5));
  JLabel label_1=new JLabel(""String_Node_Str"");
  label_1.setBounds(148,11,140,14);
  add(label_1);
  JLabel label_2=new JLabel(""String_Node_Str"");
  label_2.setBounds(148,182,140,14);
  add(label_2);
  JSeparator separator=new JSeparator();
  add(separator);
  comboBox=new JComboBox();
  comboBox.setEditable(true);
  comboBox.setModel(new DefaultComboBoxModel(new String[]{}));
  comboBox.setBounds(254,179,82,20);
  comboBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      int index=comboBox.getSelectedIndex();
      if (index < 0)       return;
      onConnectionComboBoxChanged(index);
    }
  }
);
  add(comboBox);
  JPanel description=new JPanel();
  JScrollPane scrollPane=new JScrollPane();
  scrollPane.setBounds(149,36,293,88);
  add(scrollPane);
  JTable resourceParamsTable=new JTable();
  resourceParamsTableModel=new DefaultTableModel(new Object[][]{},new String[]{""String_Node_Str"",""String_Node_Str""});
  resourceParamsTable.setModel(resourceParamsTableModel);
  scrollPane.setViewportView(resourceParamsTable);
  JScrollPane scrollPane_1=new JScrollPane();
  scrollPane_1.setBounds(148,207,294,143);
  add(scrollPane_1);
  JTable connectionParamsTable=new JTable();
  resourceConnectionParamsTableModel=new DefaultTableModel(new Object[][]{},new String[]{""String_Node_Str"",""String_Node_Str""});
  connectionParamsTable.setModel(resourceConnectionParamsTableModel);
  connectionParamsTable.getColumnModel().getColumn(0).setPreferredWidth(90);
  scrollPane_1.setViewportView(connectionParamsTable);
  resourcesTable=new JTable();
  String[] columnNames={""String_Node_Str""};
  Object[][] data={};
  resourcesTableModel=new DefaultTableModel(data,columnNames);
  resourcesTable.setModel(resourcesTableModel);
  resourcesTable.setSelectionMode(DefaultListSelectionModel.SINGLE_SELECTION);
  currentResourceIndex=-1;
  resourcesTable.getSelectionModel().addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (!e.getValueIsAdjusting()) {
        int selectedRow=resourcesTable.getSelectedRow();
        onSelectedResource(selectedRow);
      }
    }
  }
);
  resourcesTableModel.addTableModelListener(new TableModelListener(){
    @Override public void tableChanged(    TableModelEvent e){
      int index=e.getFirstRow();
      if (e.getType() == TableModelEvent.INSERT) {
        resources.getResource().add(index,new ResourceType());
      }
 else       if (e.getType() == TableModelEvent.DELETE) {
        resources.getResource().remove(index);
      }
 else {
        resources.getResource().get(index).setName((String)((DefaultTableModel)e.getSource()).getValueAt(index,0));
      }
    }
  }
);
  JScrollPane scrollPane_2=new JScrollPane();
  scrollPane_2.setBounds(20,36,102,314);
  add(scrollPane_2);
  scrollPane_2.setViewportView(resourcesTable);
  JButton button=new JButton(""String_Node_Str"");
  button.addActionListener(new RowAddListener(resourcesTable));
  button.setBounds(10,361,46,23);
  add(button);
  JButton button_1=new JButton(""String_Node_Str"");
  button_1.addActionListener(new RowRemoveListener(resourcesTable));
  button_1.setBounds(74,361,46,23);
  add(button_1);
  JButton button_2=new JButton(""String_Node_Str"");
  button_2.addActionListener(new RowAddListener(connectionParamsTable));
  button_2.setBounds(148,361,46,23);
  add(button_2);
  JButton button_3=new JButton(""String_Node_Str"");
  button_3.addActionListener(new RowRemoveListener(connectionParamsTable));
  button_3.setBounds(204,361,46,23);
  add(button_3);
  JButton button_4=new JButton(""String_Node_Str"");
  button_4.addActionListener(new RowAddListener(resourceParamsTable));
  button_4.setBounds(148,130,46,23);
  add(button_4);
  JButton button_5=new JButton(""String_Node_Str"");
  button_5.addActionListener(new RowRemoveListener(resourceParamsTable));
  button_5.setBounds(204,130,46,23);
  add(button_5);
  JButton button_6=new JButton(""String_Node_Str"");
  button_6.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      onAddConnection();
    }
  }
);
  button_6.setBounds(346,178,46,23);
  add(button_6);
  JButton btnNewButton=new JButton(""String_Node_Str"");
  btnNewButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      onRemoveConnection();
    }
  }
);
  btnNewButton.setBounds(396,178,46,23);
  add(btnNewButton);
  add(new Label());
  String text=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  JLabel help=new JLabel(text){
    public Dimension getPreferredSize(){
      return new Dimension(400,400);
    }
    public Dimension getMinimumSize(){
      return new Dimension(400,400);
    }
    public Dimension getMaximumSize(){
      return new Dimension(400,400);
    }
  }
;
  help.setVerticalAlignment(SwingConstants.TOP);
  help.setHorizontalAlignment(SwingConstants.LEFT);
  description.add(help);
  add(description,BorderLayout.EAST);
}"
13050,"public NetworkDiscoveryResult discoverNetwork(Set<ConnectionDetails> connectionDetailsList,int depth){
  nodes.clear();
  Set<ConnectionDetails> discoveredConnectionDetails=new HashSet<ConnectionDetails>();
  Map<String,List<Future<NodeDiscoveryResult>>> nodeNeighbourFuturesMap=new HashMap<String,List<Future<NodeDiscoveryResult>>>();
  Map<String,NodeDiscoveryResult> nodeDiscoveryResultMap=new HashMap<String,NodeDiscoveryResult>();
  int futureCounter=0;
  eventFutureCount=0;
  for (  ConnectionDetails connectionDetails : connectionDetailsList) {
    discoveredConnectionDetails.add(connectionDetails);
    executorCompletionService.submit(discoveryWorkerFactory.createDiscoveryWorker(nodeDiscoverers,connectionDetails,null));
    futureCounter++;
  }
  while (futureCounter > 0) {
    try {
      Future<NodeDiscoveryResult> future=executorCompletionService.take();
      futureCounter--;
      NodeDiscoveryResult result=future.get();
      String nodeId=result.getNodeId();
      String parentId=result.getParentId();
      if (nodeId == null) {
        logger.info(""String_Node_Str"" + parentId);
        continue;
      }
      if (nodes.containsKey(nodeId)) {
        logger.info(""String_Node_Str"" + nodeId);
        continue;
      }
      Node node=nodeFactory.createNode(nodeId);
      nodes.put(nodeId,node);
      Node parentNode=nodes.get(parentId);
      if (parentId != null) {
        parentNode.addNeighbour(node);
        List<Future<NodeDiscoveryResult>> parentNeighbourFutures=nodeNeighbourFuturesMap.get(parentId);
        if (parentNeighbourFutures == null) {
          logger.error(""String_Node_Str"" + parentId);
        }
        parentNeighbourFutures.remove(future);
        if (parentNeighbourFutures.isEmpty()) {
          NodeDiscoveryResult parentDiscoveryResult=nodeDiscoveryResultMap.remove(parentId);
          nodeNeighbourFuturesMap.remove(parentId);
          fireNeighboursDiscoveredEvent(parentDiscoveryResult);
        }
      }
      nodeDiscoveryResultMap.put(nodeId,result);
      fireNodeDiscoveredEvent((NodeDiscoveryResult)result.clone());
      Set<ConnectionDetails> neighboursConnectionDetailsSet=new HashSet<ConnectionDetails>(result.getNeighboursConnectionDetails());
      neighboursConnectionDetailsSet.removeAll(discoveredConnectionDetails);
      ArrayList<Future<NodeDiscoveryResult>> neighbourFutures=new ArrayList<Future<NodeDiscoveryResult>>();
      logger.info(""String_Node_Str"" + nodeId);
      nodeNeighbourFuturesMap.put(nodeId,neighbourFutures);
      for (      ConnectionDetails neighboursConnectionDetails : neighboursConnectionDetailsSet) {
        discoveredConnectionDetails.add(neighboursConnectionDetails);
        DiscoveryWorker discoveryWorker=new DiscoveryWorker(nodeDiscoverers,neighboursConnectionDetails,nodeId);
        Future<NodeDiscoveryResult> nodeNeighbourFuture=executorCompletionService.submit(discoveryWorker);
        neighbourFutures.add(nodeNeighbourFuture);
        futureCounter++;
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
  }
  NetworkDiscoveryResult result=new NetworkDiscoveryResult();
  result.setNodes(nodes);
  fireNetworkDiscoveredEvent(result);
  while (eventFutureCount > 0) {
    try {
      eventFutureCount--;
      eventExecutorCompletionService.take();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
  }
  logger.info(""String_Node_Str"");
  eventExecutorService.shutdown();
  logger.info(""String_Node_Str"");
  executorService.shutdown();
  return result;
}","public NetworkDiscoveryResult discoverNetwork(Set<ConnectionDetails> connectionDetailsList,int depth){
  nodes.clear();
  Set<ConnectionDetails> discoveredConnectionDetails=new HashSet<ConnectionDetails>();
  Map<String,List<Future<NodeDiscoveryResult>>> nodeNeighbourFuturesMap=new HashMap<String,List<Future<NodeDiscoveryResult>>>();
  Map<String,NodeDiscoveryResult> nodeDiscoveryResultMap=new HashMap<String,NodeDiscoveryResult>();
  int futureCounter=0;
  eventFutureCount=0;
  for (  ConnectionDetails connectionDetails : connectionDetailsList) {
    discoveredConnectionDetails.add(connectionDetails);
    executorCompletionService.submit(discoveryWorkerFactory.createDiscoveryWorker(nodeDiscoverers,connectionDetails,null));
    futureCounter++;
  }
  while (futureCounter > 0) {
    try {
      Future<NodeDiscoveryResult> future=executorCompletionService.take();
      futureCounter--;
      NodeDiscoveryResult result=future.get();
      String parentId=result.getParentId();
      if (parentId != null) {
        List<Future<NodeDiscoveryResult>> parentNeighbourFutures=nodeNeighbourFuturesMap.get(parentId);
        logger.info(""String_Node_Str"" + parentId + ""String_Node_Str""+ future.get().getNodeId());
        parentNeighbourFutures.remove(future);
        if (parentNeighbourFutures.isEmpty()) {
          NodeDiscoveryResult parentDiscoveryResult=nodeDiscoveryResultMap.remove(parentId);
          nodeNeighbourFuturesMap.remove(parentId);
          fireNeighboursDiscoveredEvent(parentDiscoveryResult);
        }
      }
      String nodeId=result.getNodeId();
      if (nodeId == null) {
        logger.info(""String_Node_Str"" + parentId);
        continue;
      }
      if (nodes.containsKey(nodeId)) {
        logger.info(""String_Node_Str"" + nodeId);
        continue;
      }
      Node node=nodeFactory.createNode(nodeId);
      nodes.put(nodeId,node);
      Node parentNode=nodes.get(parentId);
      if (parentNode != null) {
        parentNode.addNeighbour(node);
      }
      nodeDiscoveryResultMap.put(nodeId,result);
      fireNodeDiscoveredEvent((NodeDiscoveryResult)result.clone());
      Set<ConnectionDetails> neighboursConnectionDetailsSet=new HashSet<ConnectionDetails>(result.getNeighboursConnectionDetails());
      neighboursConnectionDetailsSet.removeAll(discoveredConnectionDetails);
      ArrayList<Future<NodeDiscoveryResult>> neighbourFutures=new ArrayList<Future<NodeDiscoveryResult>>();
      for (      ConnectionDetails neighboursConnectionDetails : neighboursConnectionDetailsSet) {
        discoveredConnectionDetails.add(neighboursConnectionDetails);
        DiscoveryWorker discoveryWorker=new DiscoveryWorker(nodeDiscoverers,neighboursConnectionDetails,nodeId);
        Future<NodeDiscoveryResult> nodeNeighbourFuture=executorCompletionService.submit(discoveryWorker);
        neighbourFutures.add(nodeNeighbourFuture);
        futureCounter++;
      }
      logger.info(""String_Node_Str"" + nodeId + ""String_Node_Str""+ neighbourFutures.size());
      nodeNeighbourFuturesMap.put(nodeId,neighbourFutures);
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
  }
  NetworkDiscoveryResult result=new NetworkDiscoveryResult();
  result.setNodes(nodes);
  fireNetworkDiscoveredEvent(result);
  while (eventFutureCount > 0) {
    try {
      eventFutureCount--;
      eventExecutorCompletionService.take();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
  }
  logger.info(""String_Node_Str"");
  eventExecutorService.shutdown();
  logger.info(""String_Node_Str"");
  executorService.shutdown();
  return result;
}"
13051,"public NetworkDiscoveryResult discoverNetwork(Set<ConnectionDetails> connectionDetailsList,int depth){
  nodes.clear();
  Set<ConnectionDetails> discoveredConnectionDetails=new HashSet<ConnectionDetails>();
  Map<String,List<Future<NodeDiscoveryResult>>> nodeNeighbourFuturesMap=new HashMap<String,List<Future<NodeDiscoveryResult>>>();
  Map<String,NodeDiscoveryResult> nodeDiscoveryResultMap=new HashMap<String,NodeDiscoveryResult>();
  int futureCounter=0;
  eventFutureCount=0;
  for (  ConnectionDetails connectionDetails : connectionDetailsList) {
    discoveredConnectionDetails.add(connectionDetails);
    executorCompletionService.submit(discoveryWorkerFactory.createDiscoveryWorker(nodeDiscoverers,connectionDetails,null));
    futureCounter++;
  }
  while (futureCounter > 0) {
    try {
      Future<NodeDiscoveryResult> future=executorCompletionService.take();
      futureCounter--;
      NodeDiscoveryResult result=future.get();
      String parentId=result.getParentId();
      if (parentId != null) {
        List<Future<NodeDiscoveryResult>> parentNeighbourFutures=nodeNeighbourFuturesMap.get(parentId);
        parentNeighbourFutures.remove(future);
        if (parentNeighbourFutures.isEmpty()) {
          NodeDiscoveryResult parentDiscoveryResult=nodeDiscoveryResultMap.remove(parentId);
          nodeNeighbourFuturesMap.remove(parentId);
          fireNeighboursDiscoveredEvent(parentDiscoveryResult);
        }
      }
      String nodeId=result.getNodeId();
      if (nodeId != null) {
        createNode(result);
        nodeDiscoveryResultMap.put(nodeId,result);
        try {
          fireNodeDiscoveredEvent((NodeDiscoveryResult)result.clone());
        }
 catch (        CloneNotSupportedException e) {
          e.printStackTrace();
        }
        Set<ConnectionDetails> neighboursConnectionDetailsSet=new HashSet<ConnectionDetails>(result.getNeighboursConnectionDetails());
        neighboursConnectionDetailsSet.removeAll(discoveredConnectionDetails);
        ArrayList<Future<NodeDiscoveryResult>> neighbourFutures=new ArrayList<Future<NodeDiscoveryResult>>();
        nodeNeighbourFuturesMap.put(nodeId,neighbourFutures);
        for (        ConnectionDetails neighboursConnectionDetails : neighboursConnectionDetailsSet) {
          discoveredConnectionDetails.add(neighboursConnectionDetails);
          DiscoveryWorker discoveryWorker=new DiscoveryWorker(nodeDiscoverers,neighboursConnectionDetails,nodeId);
          Future<NodeDiscoveryResult> nodeNeighbourFuture=executorCompletionService.submit(discoveryWorker);
          neighbourFutures.add(nodeNeighbourFuture);
          futureCounter++;
        }
      }
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
catch (    ExecutionException e) {
      logger.error(e.getMessage(),e);
    }
  }
  NetworkDiscoveryResult result=new NetworkDiscoveryResult();
  result.setNodes(nodes);
  fireNetworkDiscoveredEvent(result);
  while (futureCounter > 0) {
    try {
      futureCounter--;
      eventExecutorCompletionService.take();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
  }
  return result;
}","public NetworkDiscoveryResult discoverNetwork(Set<ConnectionDetails> connectionDetailsList,int depth){
  nodes.clear();
  Set<ConnectionDetails> discoveredConnectionDetails=new HashSet<ConnectionDetails>();
  Map<String,List<Future<NodeDiscoveryResult>>> nodeNeighbourFuturesMap=new HashMap<String,List<Future<NodeDiscoveryResult>>>();
  Map<String,NodeDiscoveryResult> nodeDiscoveryResultMap=new HashMap<String,NodeDiscoveryResult>();
  int futureCounter=0;
  eventFutureCount=0;
  for (  ConnectionDetails connectionDetails : connectionDetailsList) {
    discoveredConnectionDetails.add(connectionDetails);
    executorCompletionService.submit(discoveryWorkerFactory.createDiscoveryWorker(nodeDiscoverers,connectionDetails,null));
    futureCounter++;
  }
  while (futureCounter > 0) {
    try {
      Future<NodeDiscoveryResult> future=executorCompletionService.take();
      futureCounter--;
      NodeDiscoveryResult result=future.get();
      String nodeId=result.getNodeId();
      String parentId=result.getParentId();
      if (nodeId == null) {
        logger.info(""String_Node_Str"" + parentId);
        continue;
      }
      if (nodes.containsKey(nodeId)) {
        logger.info(""String_Node_Str"" + nodeId);
        continue;
      }
      Node node=nodeFactory.createNode(nodeId);
      nodes.put(nodeId,node);
      Node parentNode=nodes.get(parentId);
      if (parentId != null) {
        parentNode.addNeighbour(node);
        List<Future<NodeDiscoveryResult>> parentNeighbourFutures=nodeNeighbourFuturesMap.get(parentId);
        if (parentNeighbourFutures == null) {
          logger.error(""String_Node_Str"" + parentId);
        }
        parentNeighbourFutures.remove(future);
        if (parentNeighbourFutures.isEmpty()) {
          NodeDiscoveryResult parentDiscoveryResult=nodeDiscoveryResultMap.remove(parentId);
          nodeNeighbourFuturesMap.remove(parentId);
          fireNeighboursDiscoveredEvent(parentDiscoveryResult);
        }
      }
      nodeDiscoveryResultMap.put(nodeId,result);
      fireNodeDiscoveredEvent((NodeDiscoveryResult)result.clone());
      Set<ConnectionDetails> neighboursConnectionDetailsSet=new HashSet<ConnectionDetails>(result.getNeighboursConnectionDetails());
      neighboursConnectionDetailsSet.removeAll(discoveredConnectionDetails);
      ArrayList<Future<NodeDiscoveryResult>> neighbourFutures=new ArrayList<Future<NodeDiscoveryResult>>();
      logger.info(""String_Node_Str"" + nodeId);
      nodeNeighbourFuturesMap.put(nodeId,neighbourFutures);
      for (      ConnectionDetails neighboursConnectionDetails : neighboursConnectionDetailsSet) {
        discoveredConnectionDetails.add(neighboursConnectionDetails);
        DiscoveryWorker discoveryWorker=new DiscoveryWorker(nodeDiscoverers,neighboursConnectionDetails,nodeId);
        Future<NodeDiscoveryResult> nodeNeighbourFuture=executorCompletionService.submit(discoveryWorker);
        neighbourFutures.add(nodeNeighbourFuture);
        futureCounter++;
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
  }
  NetworkDiscoveryResult result=new NetworkDiscoveryResult();
  result.setNodes(nodes);
  fireNetworkDiscoveredEvent(result);
  while (eventFutureCount > 0) {
    try {
      eventFutureCount--;
      eventExecutorCompletionService.take();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
  }
  logger.info(""String_Node_Str"");
  eventExecutorService.shutdown();
  logger.info(""String_Node_Str"");
  executorService.shutdown();
  return result;
}"
13052,"private void createFileMenu(TopologyManagerFrame frame,JMenuBar menuBar){
  final JMenu file=new JMenu(""String_Node_Str"");
  file.setName(""String_Node_Str"");
  menuBar.add(file);
  final JMenuItem newProject=new JMenuItem(""String_Node_Str"");
  newProject.addActionListener(new NewProjectMenuHandler(frame));
  file.add(newProject);
  final JMenuItem open=new JMenuItem(""String_Node_Str"");
  open.addActionListener(new OpenProjectMenuHandler(frame));
  file.add(open);
  final JMenuItem close=new JMenuItem(""String_Node_Str"");
  close.addActionListener(new CloseProjectMenuHandler(frame));
  file.add(close);
  file.addSeparator();
  final JMenuItem openGraph=new JMenuItem(""String_Node_Str"");
  openGraph.addActionListener(new OpenGraphMenuHandler(frame));
  openGraph.setEnabled(false);
  file.add(openGraph);
  final JMenuItem closeGraph=new JMenuItem(""String_Node_Str"");
  closeGraph.addActionListener(new CloseGraphMenuHandler(frame));
  closeGraph.setEnabled(false);
  file.add(closeGraph);
  final JMenuItem diff=new JMenuItem(""String_Node_Str"");
  diff.addActionListener(new DiffMenuHandler(frame));
  diff.setEnabled(false);
  file.add(diff);
  file.addSeparator();
  final JMenu capture=new JMenu(""String_Node_Str"");
  capture.setEnabled(false);
  JMenuItem captureTpPNGMenuItem=new JMenuItem(""String_Node_Str"");
  captureTpPNGMenuItem.addActionListener(new CaptureToPNGMenuHandler(frame));
  capture.add(captureTpPNGMenuItem);
  JMenuItem captureTpEPSMenuItem=new JMenuItem(""String_Node_Str"");
  captureTpEPSMenuItem.addActionListener(new CaptureToEPSMenuHandler(frame));
  capture.add(captureTpEPSMenuItem);
  file.add(capture);
  final JMenuItem saveGraph=new JMenuItem(""String_Node_Str"");
  saveGraph.addActionListener(new SaveCurrentGraphMenuHandler(frame));
  saveGraph.setEnabled(true);
  capture.add(saveGraph);
  file.addSeparator();
  final JMenuItem exit=new JMenuItem(""String_Node_Str"");
  exit.addActionListener(new ExitMenuHandler(frame));
  file.add(exit);
}","private void createFileMenu(TopologyManagerFrame frame,JMenuBar menuBar){
  final JMenu file=new JMenu(""String_Node_Str"");
  file.setName(""String_Node_Str"");
  menuBar.add(file);
  final JMenuItem newProject=new JMenuItem(""String_Node_Str"");
  newProject.addActionListener(new NewProjectMenuHandler(frame));
  file.add(newProject);
  final JMenuItem open=new JMenuItem(""String_Node_Str"");
  open.addActionListener(new OpenProjectMenuHandler(frame));
  file.add(open);
  final JMenuItem close=new JMenuItem(""String_Node_Str"");
  close.addActionListener(new CloseProjectMenuHandler(frame));
  file.add(close);
  file.addSeparator();
  final JMenuItem addGraph=new JMenuItem(""String_Node_Str"");
  addGraph.addActionListener(new AddGraphMenuHandler(frame));
  addGraph.setEnabled(false);
  file.add(addGraph);
  final JMenuItem openGraph=new JMenuItem(""String_Node_Str"");
  openGraph.addActionListener(new OpenGraphMenuHandler(frame));
  openGraph.setEnabled(false);
  file.add(openGraph);
  final JMenuItem closeGraph=new JMenuItem(""String_Node_Str"");
  closeGraph.addActionListener(new CloseGraphMenuHandler(frame));
  closeGraph.setEnabled(false);
  file.add(closeGraph);
  final JMenuItem diff=new JMenuItem(""String_Node_Str"");
  diff.addActionListener(new DiffMenuHandler(frame));
  diff.setEnabled(false);
  file.add(diff);
  file.addSeparator();
  final JMenu capture=new JMenu(""String_Node_Str"");
  capture.setEnabled(false);
  JMenuItem captureTpPNGMenuItem=new JMenuItem(""String_Node_Str"");
  captureTpPNGMenuItem.addActionListener(new CaptureToPNGMenuHandler(frame));
  capture.add(captureTpPNGMenuItem);
  JMenuItem captureTpEPSMenuItem=new JMenuItem(""String_Node_Str"");
  captureTpEPSMenuItem.addActionListener(new CaptureToEPSMenuHandler(frame));
  capture.add(captureTpEPSMenuItem);
  file.add(capture);
  final JMenuItem saveGraph=new JMenuItem(""String_Node_Str"");
  saveGraph.addActionListener(new SaveCurrentGraphMenuHandler(frame));
  saveGraph.setEnabled(true);
  capture.add(saveGraph);
  file.addSeparator();
  final JMenuItem exit=new JMenuItem(""String_Node_Str"");
  exit.addActionListener(new ExitMenuHandler(frame));
  file.add(exit);
}"
13053,"@Override public void actionPerformed(ActionEvent e){
  DiffWizardDialog wizardDialog;
  try {
    File baseDir=frame.getPath();
    wizardDialog=new DiffWizardDialog(frame,baseDir);
  }
 catch (  MalformedURLException e1) {
    e1.printStackTrace();
    return;
  }
  wizardDialog.setVisible(true);
  System.out.println(frame.getPath());
  System.out.println(wizardDialog.getDiffPath1());
  System.out.println(wizardDialog.getDiffPath2());
  System.out.println(wizardDialog.getDiffPath3());
  System.out.println(wizardDialog.getResult() == DiffWizardDialog.Result.DONE);
  if (wizardDialog.getResult() == DiffWizardDialog.Result.DONE) {
    frame.doOpenGraph(new File(wizardDialog.getDiffPath3() + File.separator + ""String_Node_Str""));
  }
}","@Override public void actionPerformed(ActionEvent e){
  DiffWizardDialog wizardDialog;
  try {
    File baseDir=frame.getPath();
    wizardDialog=new DiffWizardDialog(frame,baseDir);
  }
 catch (  MalformedURLException e1) {
    e1.printStackTrace();
    return;
  }
  wizardDialog.setVisible(true);
  System.out.println(frame.getPath());
  System.out.println(wizardDialog.getDiffPath1());
  System.out.println(wizardDialog.getDiffPath2());
  System.out.println(wizardDialog.getDiffPath3());
  System.out.println(wizardDialog.getResult() == DiffWizardDialog.Result.DONE);
  if (wizardDialog.getResult() == DiffWizardDialog.Result.DONE) {
    frame.doOpenGraph(new File(wizardDialog.getDiffPath3() + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""));
  }
}"
13054,"public static void main(String[] args) throws IOException, JAXBException {
  FileInputStream is=null;
  try {
    is=new FileInputStream(""String_Node_Str"");
    ResourcesType resources=JaxbMarshalar.unmarshal(ResourcesType.class,is);
    final DiscoveryResourcePanel panel=new DiscoveryResourcePanel();
    panel.setResources(resources);
    EventQueue.invokeLater(new Runnable(){
      public void run(){
        try {
          JFrame frame=new JFrame();
          frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
          frame.setBounds(100,100,645,622);
          JPanel contentPane=new JPanel();
          contentPane.setBorder(new EmptyBorder(5,5,5,5));
          frame.setContentPane(contentPane);
          contentPane.setLayout(null);
          panel.setBounds(10,11,617,648);
          contentPane.add(panel);
          frame.setVisible(true);
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
);
  }
  finally {
    if (is != null)     is.close();
  }
}","public static void main(String[] args) throws IOException, JAXBException {
  FileInputStream is=null;
  try {
    is=new FileInputStream(""String_Node_Str"");
    ResourcesType resources=JaxbMarshalar.unmarshal(ResourcesType.class,is);
    final DiscoveryResourcePanel panel=new DiscoveryResourcePanel();
    panel.setResources(resources);
    EventQueue.invokeLater(new Runnable(){
      public void run(){
        try {
          JFrame frame=new JFrame();
          frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
          frame.setBounds(100,100,945,622);
          JPanel contentPane=new JPanel();
          contentPane.setBorder(new EmptyBorder(5,5,5,5));
          frame.setContentPane(contentPane);
          contentPane.setLayout(null);
          panel.setBounds(10,11,917,648);
          contentPane.add(panel);
          frame.setVisible(true);
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
);
  }
  finally {
    if (is != null)     is.close();
  }
}"
13055,"public void run(){
  try {
    JFrame frame=new JFrame();
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.setBounds(100,100,645,622);
    JPanel contentPane=new JPanel();
    contentPane.setBorder(new EmptyBorder(5,5,5,5));
    frame.setContentPane(contentPane);
    contentPane.setLayout(null);
    panel.setBounds(10,11,617,648);
    contentPane.add(panel);
    frame.setVisible(true);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void run(){
  try {
    JFrame frame=new JFrame();
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.setBounds(100,100,945,622);
    JPanel contentPane=new JPanel();
    contentPane.setBorder(new EmptyBorder(5,5,5,5));
    frame.setContentPane(contentPane);
    contentPane.setLayout(null);
    panel.setBounds(10,11,917,648);
    contentPane.add(panel);
    frame.setVisible(true);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
13056,"private void onSelectedResource(int index){
  updateCurrentResource();
  currentResourceIndex=index;
  mCurrentConnectionTypeIndex=0;
  updateResourceTable();
}","private void onSelectedResource(int index){
  if (index != -1) {
    updateCurrentResource();
  }
  currentResourceIndex=index;
  mCurrentConnectionTypeIndex=0;
  updateResourceTable();
}"
13057,"public void doOpenGraph(File selectedFile){
  try {
    logger.info(""String_Node_Str"" + projectType + ""String_Node_Str""+ viewerConfig+ ""String_Node_Str""+ selectedFile);
    GraphViewerPanelManager<UndirectedGraph<String,String>> viewerPanelManager=new GraphViewerPanelManager<UndirectedGraph<String,String>>(this,projectType,path,viewerConfig,selectedFile,UndirectedSparseMultigraph.<String,String>getFactory(),tabbedPane,GraphType.UNDIRECTED);
    viewerPanelManagerMap.put(viewerPanelManager.getVersionDir().getAbsolutePath(),viewerPanelManager);
    viewerPanelManager.createAndAddViewerPanel();
  }
 catch (  Exception e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + e.getMessage());
  }
}","public void doOpenGraph(File selectedFile){
  try {
    GraphmlEdgeDefaultResolver graphTypeResolver=new GraphmlEdgeDefaultResolver();
    String graphType=graphTypeResolver.resolveEdgeDefault(selectedFile);
    if (graphType.equals(""String_Node_Str"")) {
      logger.info(""String_Node_Str"" + projectType + ""String_Node_Str""+ viewerConfig+ ""String_Node_Str""+ selectedFile);
      GraphViewerPanelManager<UndirectedGraph<String,String>> viewerPanelManager=new GraphViewerPanelManager<UndirectedGraph<String,String>>(this,projectType,path,viewerConfig,selectedFile,UndirectedSparseMultigraph.<String,String>getFactory(),tabbedPane,GraphType.UNDIRECTED);
      viewerPanelManagerMap.put(viewerPanelManager.getVersionDir().getAbsolutePath(),viewerPanelManager);
      viewerPanelManager.createAndAddViewerPanel();
    }
 else     if (selectedFile.getAbsolutePath().contains(""String_Node_Str"")) {
      GraphViewerPanelManager<DirectedGraph<String,String>> viewerPanelManager=new GraphViewerPanelManager<DirectedGraph<String,String>>(this,projectType,path,viewerConfig,selectedFile,DirectedSparseMultigraph.<String,String>getFactory(),tabbedPane,GraphType.DIRECTED);
      viewerPanelManagerMap.put(viewerPanelManager.getVersionDir().getAbsolutePath(),viewerPanelManager);
      viewerPanelManager.createAndAddViewerPanel();
    }
 else {
      logger.error(String.format(""String_Node_Str"",selectedFile.getName()));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + e.getMessage());
  }
}"
13058,"static VertexPredicateFilter<String,String> createVertexFilter(final FilterType filter,final Map<String,DataMatcher> matcherMap,final Map<String,GraphMLMetadata<String>> vertexMetadata,final Graph<String,String> graph1){
  return new VertexPredicateFilter<String,String>(new Predicate<String>(){
    public boolean evaluate(    String v){
      if (graph1.getIncidentEdges(v).isEmpty()) {
        return false;
      }
 else {
        if (filter == null)         return true;
        List<IncludeType> includes=filter.getInclude();
        String filterType=filter.getType();
        if (filterType == null) {
          filterType=""String_Node_Str"";
        }
        boolean hasNodeInlcude=false;
        for (        IncludeType include : includes) {
          if (ForType.NODE.equals(include.getFor())) {
            String matcher=include.getMatcher();
            if (matcher == null) {
              matcher=""String_Node_Str"";
            }
            if (include.getClassType() == null) {
              final String dataKey=include.getDataKey();
              if (dataKey == null) {
                hasNodeInlcude=true;
                continue;
              }
              if (vertexMetadata.get(dataKey) == null) {
                throw new RuntimeException(""String_Node_Str"" + dataKey);
              }
              String value=vertexMetadata.get(dataKey).transformer.transform(v);
              if (value != null) {
                String[] dataValues=value.split(""String_Node_Str"");
                String includeDataValue=include.getDataValue();
                DataMatcher matcherInstance=matcherMap.get(matcher);
                if (""String_Node_Str"".equals(filterType)) {
                  for (                  String dataValue : dataValues) {
                    hasNodeInlcude=false;
                    if (matcherInstance.compareData(dataValue,includeDataValue)) {
                      logger.debug(""String_Node_Str"" + v + ""String_Node_Str""+ filter.getName()+ ""String_Node_Str""+ include.getDataKey()+ ""String_Node_Str""+ dataValue);
                      hasNodeInlcude=true;
                    }
                  }
                  if (!hasNodeInlcude) {
                    return false;
                  }
                }
 else {
                  for (                  String dataValue : dataValues) {
                    if (matcherInstance.compareData(dataValue,includeDataValue)) {
                      logger.debug(""String_Node_Str"" + v + ""String_Node_Str""+ filter.getName()+ ""String_Node_Str""+ include.getDataKey()+ ""String_Node_Str""+ dataValue);
                      hasNodeInlcude=true;
                    }
 else {
                      logger.debug(""String_Node_Str"" + v + ""String_Node_Str""+ filter.getName()+ ""String_Node_Str""+ include.getDataKey()+ ""String_Node_Str""+ dataValue);
                    }
                  }
                }
              }
            }
 else {
              String type=include.getClassType();
              Class<?> includeClazz;
              try {
                includeClazz=Class.forName(type);
                VertexIncluder includeInst=(VertexIncluder)includeClazz.newInstance();
                boolean hasToInlcude=includeInst.hasToInclude(v,vertexMetadata,graph1);
                if (""String_Node_Str"".equals(filterType)) {
                  if (!hasToInlcude) {
                    return false;
                  }
                }
 else {
                  if (hasToInlcude) {
                    hasNodeInlcude=true;
                  }
                }
              }
 catch (              ClassNotFoundException e) {
                e.printStackTrace();
                return false;
              }
catch (              InstantiationException e) {
                e.printStackTrace();
                return false;
              }
catch (              IllegalAccessException e) {
                e.printStackTrace();
                return false;
              }
            }
          }
        }
        if (!hasNodeInlcude) {
          System.out.println(""String_Node_Str"" + v + ""String_Node_Str"");
          return false;
        }
 else {
          System.out.println(""String_Node_Str"" + v + ""String_Node_Str"");
          return true;
        }
      }
    }
  }
);
}","static VertexPredicateFilter<String,String> createVertexFilter(final FilterType filter,final Map<String,DataMatcher> matcherMap,final Map<String,GraphMLMetadata<String>> vertexMetadata,final Graph<String,String> graph1){
  return new VertexPredicateFilter<String,String>(new Predicate<String>(){
    public boolean evaluate(    String v){
      if (graph1.getIncidentEdges(v).isEmpty()) {
        return false;
      }
 else {
        if (filter == null)         return true;
        List<IncludeType> includes=filter.getInclude();
        String filterType=filter.getType();
        if (filterType == null) {
          filterType=""String_Node_Str"";
        }
        boolean hasNodeInlcude=false;
        for (        IncludeType include : includes) {
          if (ForType.NODE.equals(include.getFor())) {
            String matcher=include.getMatcher();
            if (matcher == null) {
              matcher=""String_Node_Str"";
            }
            if (include.getClassType() == null) {
              final String dataKey=include.getDataKey();
              if (dataKey == null) {
                hasNodeInlcude=true;
                continue;
              }
              if (vertexMetadata.get(dataKey) == null) {
                logger.debug(""String_Node_Str"" + dataKey);
                continue;
              }
              String value=vertexMetadata.get(dataKey).transformer.transform(v);
              if (value != null) {
                String[] dataValues=value.split(""String_Node_Str"");
                String includeDataValue=include.getDataValue();
                DataMatcher matcherInstance=matcherMap.get(matcher);
                if (""String_Node_Str"".equals(filterType)) {
                  for (                  String dataValue : dataValues) {
                    hasNodeInlcude=false;
                    if (matcherInstance.compareData(dataValue,includeDataValue)) {
                      logger.debug(""String_Node_Str"" + v + ""String_Node_Str""+ filter.getName()+ ""String_Node_Str""+ include.getDataKey()+ ""String_Node_Str""+ dataValue);
                      hasNodeInlcude=true;
                    }
                  }
                  if (!hasNodeInlcude) {
                    return false;
                  }
                }
 else {
                  for (                  String dataValue : dataValues) {
                    if (matcherInstance.compareData(dataValue,includeDataValue)) {
                      logger.debug(""String_Node_Str"" + v + ""String_Node_Str""+ filter.getName()+ ""String_Node_Str""+ include.getDataKey()+ ""String_Node_Str""+ dataValue);
                      hasNodeInlcude=true;
                    }
 else {
                      logger.debug(""String_Node_Str"" + v + ""String_Node_Str""+ filter.getName()+ ""String_Node_Str""+ include.getDataKey()+ ""String_Node_Str""+ dataValue);
                    }
                  }
                }
              }
            }
 else {
              String type=include.getClassType();
              Class<?> includeClazz;
              try {
                includeClazz=Class.forName(type);
                VertexIncluder includeInst=(VertexIncluder)includeClazz.newInstance();
                boolean hasToInlcude=includeInst.hasToInclude(v,vertexMetadata,graph1);
                if (""String_Node_Str"".equals(filterType)) {
                  if (!hasToInlcude) {
                    return false;
                  }
                }
 else {
                  if (hasToInlcude) {
                    hasNodeInlcude=true;
                  }
                }
              }
 catch (              ClassNotFoundException e) {
                e.printStackTrace();
                return false;
              }
catch (              InstantiationException e) {
                e.printStackTrace();
                return false;
              }
catch (              IllegalAccessException e) {
                e.printStackTrace();
                return false;
              }
            }
          }
        }
        if (!hasNodeInlcude) {
          System.out.println(""String_Node_Str"" + v + ""String_Node_Str"");
          return false;
        }
 else {
          System.out.println(""String_Node_Str"" + v + ""String_Node_Str"");
          return true;
        }
      }
    }
  }
);
}"
13059,"public boolean evaluate(String v){
  if (graph1.getIncidentEdges(v).isEmpty()) {
    return false;
  }
 else {
    if (filter == null)     return true;
    List<IncludeType> includes=filter.getInclude();
    String filterType=filter.getType();
    if (filterType == null) {
      filterType=""String_Node_Str"";
    }
    boolean hasNodeInlcude=false;
    for (    IncludeType include : includes) {
      if (ForType.NODE.equals(include.getFor())) {
        String matcher=include.getMatcher();
        if (matcher == null) {
          matcher=""String_Node_Str"";
        }
        if (include.getClassType() == null) {
          final String dataKey=include.getDataKey();
          if (dataKey == null) {
            hasNodeInlcude=true;
            continue;
          }
          if (vertexMetadata.get(dataKey) == null) {
            throw new RuntimeException(""String_Node_Str"" + dataKey);
          }
          String value=vertexMetadata.get(dataKey).transformer.transform(v);
          if (value != null) {
            String[] dataValues=value.split(""String_Node_Str"");
            String includeDataValue=include.getDataValue();
            DataMatcher matcherInstance=matcherMap.get(matcher);
            if (""String_Node_Str"".equals(filterType)) {
              for (              String dataValue : dataValues) {
                hasNodeInlcude=false;
                if (matcherInstance.compareData(dataValue,includeDataValue)) {
                  logger.debug(""String_Node_Str"" + v + ""String_Node_Str""+ filter.getName()+ ""String_Node_Str""+ include.getDataKey()+ ""String_Node_Str""+ dataValue);
                  hasNodeInlcude=true;
                }
              }
              if (!hasNodeInlcude) {
                return false;
              }
            }
 else {
              for (              String dataValue : dataValues) {
                if (matcherInstance.compareData(dataValue,includeDataValue)) {
                  logger.debug(""String_Node_Str"" + v + ""String_Node_Str""+ filter.getName()+ ""String_Node_Str""+ include.getDataKey()+ ""String_Node_Str""+ dataValue);
                  hasNodeInlcude=true;
                }
 else {
                  logger.debug(""String_Node_Str"" + v + ""String_Node_Str""+ filter.getName()+ ""String_Node_Str""+ include.getDataKey()+ ""String_Node_Str""+ dataValue);
                }
              }
            }
          }
        }
 else {
          String type=include.getClassType();
          Class<?> includeClazz;
          try {
            includeClazz=Class.forName(type);
            VertexIncluder includeInst=(VertexIncluder)includeClazz.newInstance();
            boolean hasToInlcude=includeInst.hasToInclude(v,vertexMetadata,graph1);
            if (""String_Node_Str"".equals(filterType)) {
              if (!hasToInlcude) {
                return false;
              }
            }
 else {
              if (hasToInlcude) {
                hasNodeInlcude=true;
              }
            }
          }
 catch (          ClassNotFoundException e) {
            e.printStackTrace();
            return false;
          }
catch (          InstantiationException e) {
            e.printStackTrace();
            return false;
          }
catch (          IllegalAccessException e) {
            e.printStackTrace();
            return false;
          }
        }
      }
    }
    if (!hasNodeInlcude) {
      System.out.println(""String_Node_Str"" + v + ""String_Node_Str"");
      return false;
    }
 else {
      System.out.println(""String_Node_Str"" + v + ""String_Node_Str"");
      return true;
    }
  }
}","public boolean evaluate(String v){
  if (graph1.getIncidentEdges(v).isEmpty()) {
    return false;
  }
 else {
    if (filter == null)     return true;
    List<IncludeType> includes=filter.getInclude();
    String filterType=filter.getType();
    if (filterType == null) {
      filterType=""String_Node_Str"";
    }
    boolean hasNodeInlcude=false;
    for (    IncludeType include : includes) {
      if (ForType.NODE.equals(include.getFor())) {
        String matcher=include.getMatcher();
        if (matcher == null) {
          matcher=""String_Node_Str"";
        }
        if (include.getClassType() == null) {
          final String dataKey=include.getDataKey();
          if (dataKey == null) {
            hasNodeInlcude=true;
            continue;
          }
          if (vertexMetadata.get(dataKey) == null) {
            logger.debug(""String_Node_Str"" + dataKey);
            continue;
          }
          String value=vertexMetadata.get(dataKey).transformer.transform(v);
          if (value != null) {
            String[] dataValues=value.split(""String_Node_Str"");
            String includeDataValue=include.getDataValue();
            DataMatcher matcherInstance=matcherMap.get(matcher);
            if (""String_Node_Str"".equals(filterType)) {
              for (              String dataValue : dataValues) {
                hasNodeInlcude=false;
                if (matcherInstance.compareData(dataValue,includeDataValue)) {
                  logger.debug(""String_Node_Str"" + v + ""String_Node_Str""+ filter.getName()+ ""String_Node_Str""+ include.getDataKey()+ ""String_Node_Str""+ dataValue);
                  hasNodeInlcude=true;
                }
              }
              if (!hasNodeInlcude) {
                return false;
              }
            }
 else {
              for (              String dataValue : dataValues) {
                if (matcherInstance.compareData(dataValue,includeDataValue)) {
                  logger.debug(""String_Node_Str"" + v + ""String_Node_Str""+ filter.getName()+ ""String_Node_Str""+ include.getDataKey()+ ""String_Node_Str""+ dataValue);
                  hasNodeInlcude=true;
                }
 else {
                  logger.debug(""String_Node_Str"" + v + ""String_Node_Str""+ filter.getName()+ ""String_Node_Str""+ include.getDataKey()+ ""String_Node_Str""+ dataValue);
                }
              }
            }
          }
        }
 else {
          String type=include.getClassType();
          Class<?> includeClazz;
          try {
            includeClazz=Class.forName(type);
            VertexIncluder includeInst=(VertexIncluder)includeClazz.newInstance();
            boolean hasToInlcude=includeInst.hasToInclude(v,vertexMetadata,graph1);
            if (""String_Node_Str"".equals(filterType)) {
              if (!hasToInlcude) {
                return false;
              }
            }
 else {
              if (hasToInlcude) {
                hasNodeInlcude=true;
              }
            }
          }
 catch (          ClassNotFoundException e) {
            e.printStackTrace();
            return false;
          }
catch (          InstantiationException e) {
            e.printStackTrace();
            return false;
          }
catch (          IllegalAccessException e) {
            e.printStackTrace();
            return false;
          }
        }
      }
    }
    if (!hasNodeInlcude) {
      System.out.println(""String_Node_Str"" + v + ""String_Node_Str"");
      return false;
    }
 else {
      System.out.println(""String_Node_Str"" + v + ""String_Node_Str"");
      return true;
    }
  }
}"
13060,"private static Map<String,String> parse(String line,String body){
  String[] fields=body.split(""String_Node_Str"");
  Map<String,String> attributes=new HashMap<String,String>();
  for (  String field : fields) {
    String[] nameValPair=field.split(""String_Node_Str"");
    if (nameValPair.length != 2) {
      throw new RuntimeException(""String_Node_Str"" + field + ""String_Node_Str""+ line);
    }
    attributes.put(nameValPair[0].trim(),nameValPair[1].trim());
  }
  return attributes;
}","private static Map<String,String> parse(String line,String body){
  String[] fields=body.split(""String_Node_Str"");
  Map<String,String> attributes=new LinkedHashMap<String,String>();
  for (  String field : fields) {
    String[] nameValPair=field.split(""String_Node_Str"");
    if (nameValPair.length != 2) {
      throw new RuntimeException(""String_Node_Str"" + field + ""String_Node_Str""+ line);
    }
    attributes.put(nameValPair[0].trim(),nameValPair[1].trim());
  }
  return attributes;
}"
13061,"/** 
 * Create the dialog.
 * @param connDetails from which the dialog will be filled
 */
public ConnectionDetailsDialog(final java.util.Map<String,ConnectionDetails> connDetails,boolean modal){
  this.setTitle(""String_Node_Str"");
  this.setModal(modal);
  this.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
  this.connDetails=connDetails;
  setBounds(100,100,450,300);
  getContentPane().setLayout(new BorderLayout());
  JPanel contentPanel=new JPanel();
  contentPanel.setBorder(new EmptyBorder(5,5,5,5));
  getContentPane().add(contentPanel,BorderLayout.CENTER);
  initListModel();
  contentPanel.setLayout(new BorderLayout(0,0));
  JPanel listPanel=new JPanel();
  JPanel tablePanel=new JPanel();
  JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,listPanel,tablePanel);
  getContentPane().add(splitPane,BorderLayout.CENTER);
  listPanel.setLayout(new BorderLayout(0,0));
  JPanel listButtonsPanel=new JPanel();
  listPanel.add(listButtonsPanel,BorderLayout.SOUTH);
  final JButton addListButton=new JButton(""String_Node_Str"");
  addListButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      String connectionName;
      do {
        connectionName=JOptionPane.showInputDialog(""String_Node_Str"");
        if (listModel.contains(connectionName)) {
          JOptionPane.showMessageDialog(ConnectionDetailsDialog.this,""String_Node_Str"");
        }
      }
 while (listModel.contains(connectionName));
      int selectedIndex=list.getSelectedIndex();
      if (selectedIndex == -1) {
        listModel.addElement(connectionName);
      }
 else {
        listModel.insertElementAt(connectionName,selectedIndex + 1);
      }
      connDetails.put(connectionName,new ConnectionDetails());
    }
  }
);
  listButtonsPanel.add(addListButton);
  JButton removeListButton=new JButton(""String_Node_Str"");
  removeListButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      int selectedIndex=list.getSelectedIndex();
      if (selectedIndex != -1) {
        listModel.remove(selectedIndex);
      }
    }
  }
);
  listButtonsPanel.add(removeListButton);
  list=new JList<String>(listModel);
  JScrollPane listScrollPane=new JScrollPane(list);
  listPanel.add(listScrollPane);
  list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  list.getSelectionModel().addListSelectionListener(this);
  tablePanel.setLayout(new BorderLayout(0,0));
  JPanel headerPanel=new JPanel();
  tablePanel.add(headerPanel,BorderLayout.NORTH);
  JLabel lblConnectionType=new JLabel(""String_Node_Str"");
  headerPanel.add(lblConnectionType);
  connTypeTextField=new JTextField();
  headerPanel.add(connTypeTextField);
  connTypeTextField.setColumns(10);
  connTypeTextField.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      String text=e.getActionCommand();
      ConnectionDetails connectionDetail=connDetails.get(selectedConnection);
      connectionDetail.setConnectionType(text);
    }
  }
);
  JPanel tableButtonsPanel=new JPanel();
  tablePanel.add(tableButtonsPanel,BorderLayout.SOUTH);
  JButton addTableButton=new JButton(""String_Node_Str"");
  addTableButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      tableModel.addRow(new String[]{""String_Node_Str"",""String_Node_Str""});
    }
  }
);
  tableButtonsPanel.add(addTableButton);
  JButton removeTableButton=new JButton(""String_Node_Str"");
  removeTableButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      int selRow=table.getSelectedRow();
      tableModel.removeRow(selRow);
    }
  }
);
  tableButtonsPanel.add(removeTableButton);
  table=new JTable();
  JScrollPane tableScrollPane=new JScrollPane(table);
  tablePanel.add(tableScrollPane);
{
    JPanel buttonPane=new JPanel();
    buttonPane.setLayout(new FlowLayout(FlowLayout.RIGHT));
    getContentPane().add(buttonPane,BorderLayout.SOUTH);
{
      JButton okButton=new JButton(""String_Node_Str"");
      okButton.setActionCommand(""String_Node_Str"");
      buttonPane.add(okButton);
      getRootPane().setDefaultButton(okButton);
      okButton.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          option=JOptionPane.OK_OPTION;
          ConnectionDetailsDialog.this.setVisible(false);
        }
      }
);
    }
{
      JButton cancelButton=new JButton(""String_Node_Str"");
      cancelButton.setActionCommand(""String_Node_Str"");
      buttonPane.add(cancelButton);
      cancelButton.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          option=JOptionPane.CANCEL_OPTION;
          ConnectionDetailsDialog.this.setVisible(false);
        }
      }
);
    }
  }
  if (listModel.getSize() > 0) {
    list.setSelectedIndex(0);
    selectedConnection=listModel.get(0);
    updateConnDetails(connDetails.get(selectedConnection));
  }
}","/** 
 * Create the dialog.
 * @param connDetails from which the dialog will be filled
 */
public ConnectionDetailsDialog(final java.util.Map<String,ConnectionDetails> connDetails,boolean modal){
  this.setTitle(""String_Node_Str"");
  this.setModal(modal);
  this.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
  this.connDetails=connDetails;
  setBounds(100,100,450,300);
  getContentPane().setLayout(new BorderLayout());
  JPanel contentPanel=new JPanel();
  contentPanel.setBorder(new EmptyBorder(5,5,5,5));
  getContentPane().add(contentPanel,BorderLayout.CENTER);
  initListModel();
  contentPanel.setLayout(new BorderLayout(0,0));
  JPanel listPanel=new JPanel();
  JPanel tablePanel=new JPanel();
  JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,listPanel,tablePanel);
  getContentPane().add(splitPane,BorderLayout.CENTER);
  listPanel.setLayout(new BorderLayout(0,0));
  JPanel listButtonsPanel=new JPanel();
  listPanel.add(listButtonsPanel,BorderLayout.SOUTH);
  final JButton addListButton=new JButton(""String_Node_Str"");
  addListButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      String connectionName;
      do {
        connectionName=JOptionPane.showInputDialog(""String_Node_Str"");
        if (listModel.contains(connectionName)) {
          JOptionPane.showMessageDialog(ConnectionDetailsDialog.this,""String_Node_Str"");
        }
      }
 while (listModel.contains(connectionName));
      int selectedIndex=list.getSelectedIndex();
      if (selectedIndex == -1) {
        listModel.addElement(connectionName);
      }
 else {
        listModel.insertElementAt(connectionName,selectedIndex + 1);
      }
      connDetails.put(connectionName,new ConnectionDetails());
    }
  }
);
  listButtonsPanel.add(addListButton);
  JButton removeListButton=new JButton(""String_Node_Str"");
  removeListButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      int selectedIndex=list.getSelectedIndex();
      if (selectedIndex != -1) {
        listModel.remove(selectedIndex);
      }
    }
  }
);
  listButtonsPanel.add(removeListButton);
  list=new JList<String>(listModel);
  JScrollPane listScrollPane=new JScrollPane(list);
  listPanel.add(listScrollPane);
  list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  list.getSelectionModel().addListSelectionListener(this);
  tablePanel.setLayout(new BorderLayout(0,0));
  JPanel headerPanel=new JPanel();
  tablePanel.add(headerPanel,BorderLayout.NORTH);
  JLabel lblConnectionType=new JLabel(""String_Node_Str"");
  headerPanel.add(lblConnectionType);
  connTypeTextField=new JTextField();
  headerPanel.add(connTypeTextField);
  connTypeTextField.setColumns(10);
  connTypeTextField.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      String text=e.getActionCommand();
      ConnectionDetails connectionDetail=connDetails.get(selectedConnection);
      connectionDetail.setConnectionType(text);
    }
  }
);
  JPanel tableButtonsPanel=new JPanel();
  tablePanel.add(tableButtonsPanel,BorderLayout.SOUTH);
  JButton addTableButton=new JButton(""String_Node_Str"");
  addTableButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      tableModel.addRow(new String[]{""String_Node_Str"",""String_Node_Str""});
    }
  }
);
  tableButtonsPanel.add(addTableButton);
  JButton removeTableButton=new JButton(""String_Node_Str"");
  removeTableButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      int selRow=table.getSelectedRow();
      tableModel.removeRow(selRow);
    }
  }
);
  tableButtonsPanel.add(removeTableButton);
  table=new JTable();
  table.putClientProperty(""String_Node_Str"",true);
  JScrollPane tableScrollPane=new JScrollPane(table);
  tablePanel.add(tableScrollPane);
{
    JPanel buttonPane=new JPanel();
    buttonPane.setLayout(new FlowLayout(FlowLayout.RIGHT));
    getContentPane().add(buttonPane,BorderLayout.SOUTH);
{
      JButton okButton=new JButton(""String_Node_Str"");
      okButton.setActionCommand(""String_Node_Str"");
      buttonPane.add(okButton);
      getRootPane().setDefaultButton(okButton);
      okButton.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          option=JOptionPane.OK_OPTION;
          ConnectionDetailsDialog.this.setVisible(false);
        }
      }
);
    }
{
      JButton cancelButton=new JButton(""String_Node_Str"");
      cancelButton.setActionCommand(""String_Node_Str"");
      buttonPane.add(cancelButton);
      cancelButton.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          option=JOptionPane.CANCEL_OPTION;
          ConnectionDetailsDialog.this.setVisible(false);
        }
      }
);
    }
  }
  if (listModel.getSize() > 0) {
    list.setSelectedIndex(0);
    selectedConnection=listModel.get(0);
    updateConnDetails(connDetails.get(selectedConnection));
  }
}"
13062,"/** 
 * Launch the application.
 */
public static void main(String[] args){
  try {
    java.util.Map<String,ConnectionDetails> connectionDetailsList=CvsConnectionDetailsFactory.createConnectionDetail(new File(""String_Node_Str""));
    ConnectionDetailsDialog dialog=new ConnectionDetailsDialog(connectionDetailsList,true);
    int option=dialog.showDialog();
    if (option == JOptionPane.OK_OPTION) {
      System.out.println(dialog.getConnDetails());
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Launch the application.
 */
public static void main(String[] args){
  try {
    UIManager.put(""String_Node_Str"",new ColorUIResource(Color.gray));
    java.util.Map<String,ConnectionDetails> connectionDetailsList=CvsConnectionDetailsFactory.createConnectionDetail(new File(""String_Node_Str""));
    ConnectionDetailsDialog dialog=new ConnectionDetailsDialog(connectionDetailsList,true);
    int option=dialog.showDialog();
    if (option == JOptionPane.OK_OPTION) {
      System.out.println(dialog.getConnDetails());
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
13063,"private GraphViewerPanel createViewerPanel(){
  return new GraphViewerPanel<G>(frame,viewerConfig,graphmlLoader,iconMapLoader,edgeStrokeMapLoader,edgeColorMapLoader,entireGraph,projectPath,graphmlsFile,graphmlDir,initialNode);
}","private GraphViewerPanel createViewerPanel(){
  return new GraphViewerPanel<G>(frame,viewerConfig,graphmlLoader,iconMapLoader,edgeStrokeMapLoader,edgeColorMapLoader,entireGraph,projectPath,versionDir,graphmlDir,initialNode);
}"
13064,"public GraphViewerPanelManager(JFrame frame,File projectPath,File graphmlsFile,Factory<G> factory,JTabbedPane tabbedPane,GraphType graphType) throws Exception {
  this.frame=frame;
  this.projectPath=projectPath;
  this.graphType=graphType;
  this.graphmlsFile=graphmlsFile;
  if (graphType == GraphType.DIRECTED) {
    this.graphmlDir=new File(graphmlsFile.getParent(),""String_Node_Str"");
  }
 else {
    this.graphmlDir=new File(graphmlsFile.getParent(),""String_Node_Str"");
  }
  this.factory=factory;
  this.tabbedPane=tabbedPane;
  entireGraph=factory.create();
  String fName;
  fName=new File(""String_Node_Str"").toString();
  viewerConfig=ViewerConfigLoader.loadViewerConfig(new File(this.projectPath,fName));
  init();
}","public GraphViewerPanelManager(JFrame frame,File projectPath,File graphmlsFile,Factory<G> factory,JTabbedPane tabbedPane,GraphType graphType) throws Exception {
  this.frame=frame;
  this.projectPath=projectPath;
  this.graphType=graphType;
  this.graphmlsFile=graphmlsFile;
  versionDir=new File(graphmlsFile.getParent());
  if (graphType == GraphType.DIRECTED) {
    this.graphmlDir=new File(versionDir,""String_Node_Str"");
  }
 else {
    this.graphmlDir=new File(versionDir,""String_Node_Str"");
  }
  this.factory=factory;
  this.tabbedPane=tabbedPane;
  entireGraph=factory.create();
  String fName;
  fName=new File(""String_Node_Str"").toString();
  viewerConfig=ViewerConfigLoader.loadViewerConfig(new File(this.projectPath,fName));
  init();
}"
13065,"public void doOpenGraph(File selectedFile){
  try {
    if (selectedFile.getName().startsWith(""String_Node_Str"")) {
      GraphViewerPanelManager<UndirectedGraph<String,String>> viewerPanelManager=new GraphViewerPanelManager<UndirectedGraph<String,String>>(this,path,selectedFile,UndirectedSparseGraph.<String,String>getFactory(),tabbedPane,GraphType.UNDIRECTED);
      viewerPanelManagerMap.put(selectedFile.getAbsolutePath(),viewerPanelManager);
      viewerPanelManager.createAndAddViewerPanel();
    }
 else     if (selectedFile.getName().startsWith(""String_Node_Str"")) {
      GraphViewerPanelManager<DirectedGraph<String,String>> viewerPanelManager=new GraphViewerPanelManager<DirectedGraph<String,String>>(this,path,selectedFile,DirectedSparseMultigraph.<String,String>getFactory(),tabbedPane,GraphType.DIRECTED);
      viewerPanelManagerMap.put(selectedFile.getAbsolutePath(),viewerPanelManager);
      viewerPanelManager.createAndAddViewerPanel();
    }
 else {
      JOptionPane.showMessageDialog(this,String.format(""String_Node_Str"",selectedFile.getName()));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + e.getMessage());
  }
}","public void doOpenGraph(File selectedFile){
  try {
    if (selectedFile.getName().startsWith(""String_Node_Str"")) {
      GraphViewerPanelManager<UndirectedGraph<String,String>> viewerPanelManager=new GraphViewerPanelManager<UndirectedGraph<String,String>>(this,path,selectedFile,UndirectedSparseGraph.<String,String>getFactory(),tabbedPane,GraphType.UNDIRECTED);
      viewerPanelManagerMap.put(viewerPanelManager.getVersionDir().getAbsolutePath(),viewerPanelManager);
      viewerPanelManager.createAndAddViewerPanel();
    }
 else     if (selectedFile.getName().startsWith(""String_Node_Str"")) {
      GraphViewerPanelManager<DirectedGraph<String,String>> viewerPanelManager=new GraphViewerPanelManager<DirectedGraph<String,String>>(this,path,selectedFile,DirectedSparseMultigraph.<String,String>getFactory(),tabbedPane,GraphType.DIRECTED);
      viewerPanelManagerMap.put(viewerPanelManager.getVersionDir().getAbsolutePath(),viewerPanelManager);
      viewerPanelManager.createAndAddViewerPanel();
    }
 else {
      JOptionPane.showMessageDialog(this,String.format(""String_Node_Str"",selectedFile.getName()));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + e.getMessage());
  }
}"
13066,"private void storeDiscoveryParameters(DiscoveryHelperType discoveryHelperType){
  FileOutputStream os=null;
  File file;
  file=new File(frame.getPath(),""String_Node_Str"");
  try {
    os=new FileOutputStream(file);
    JaxbMarshalar.marshal(discoveryHelperType,os,""String_Node_Str"");
    JOptionPane.showMessageDialog(this.frame,""String_Node_Str"");
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this.frame,""String_Node_Str"" + file.getAbsolutePath());
  }
catch (  JAXBException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this.frame,""String_Node_Str"" + file.getAbsolutePath());
  }
 finally {
    if (os != null)     try {
      os.close();
    }
 catch (    IOException e) {
    }
  }
}","private void storeDiscoveryParameters(DiscoveryHelperType discoveryHelperType){
  FileOutputStream os=null;
  File file;
  file=new File(getPath(),""String_Node_Str"");
  try {
    os=new FileOutputStream(file);
    JaxbMarshalar.marshal(discoveryHelperType,os,""String_Node_Str"");
    JOptionPane.showMessageDialog(this.frame,""String_Node_Str"");
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this.frame,""String_Node_Str"" + file.getAbsolutePath());
  }
catch (  JAXBException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this.frame,""String_Node_Str"" + file.getAbsolutePath());
  }
 finally {
    if (os != null)     try {
      os.close();
    }
 catch (    IOException e) {
    }
  }
}"
13067,"private DiscoveryHelperType loadDiscoveryParameters(){
  FileInputStream is=null;
  File file;
  file=new File(frame.getPath(),""String_Node_Str"");
  try {
    is=new FileInputStream(file);
    DiscoveryHelperType discoveryHelperType=JaxbMarshalar.unmarshal(DiscoveryHelperType.class,is);
    return discoveryHelperType;
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this.frame,""String_Node_Str"" + file.getAbsolutePath());
  }
catch (  JAXBException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this.frame,""String_Node_Str"" + file.getAbsolutePath());
  }
 finally {
    if (is != null)     try {
      is.close();
    }
 catch (    IOException e) {
    }
  }
  return null;
}","private DiscoveryHelperType loadDiscoveryParameters(){
  FileInputStream is=null;
  File file;
  file=new File(getPath(),""String_Node_Str"");
  try {
    is=new FileInputStream(file);
    DiscoveryHelperType discoveryHelperType=JaxbMarshalar.unmarshal(DiscoveryHelperType.class,is);
    return discoveryHelperType;
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this.frame,""String_Node_Str"" + file.getAbsolutePath());
  }
catch (  JAXBException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this.frame,""String_Node_Str"" + file.getAbsolutePath());
  }
 finally {
    if (is != null)     try {
      is.close();
    }
 catch (    IOException e) {
    }
  }
  return null;
}"
13068,"private void updateOidsTable(){
  DiscoveryMethodType discoveryMethod=getCurrentDiscoveryMethod();
  if (discoveryMethod != null) {
    String discoveryMethodValueList=discoveryMethod.getValue();
    String[] oids=discoveryMethodValueList.split(""String_Node_Str"");
    Vector oidsTableModelData=oidsTableModel.getDataVector();
    oidsTableModelData.removeAllElements();
    for (    String oid : oids) {
      Vector vec=new Vector();
      vec.add(oid);
      oidsTableModelData.add(0,vec);
    }
    oidsTableModel.fireTableDataChanged();
  }
}","private void updateOidsTable(){
  DiscoveryMethodType discoveryMethod=getCurrentDiscoveryMethod();
  if (discoveryMethod != null) {
    String discoveryMethodValueList=discoveryMethod.getValue();
    String[] oids=discoveryMethodValueList.split(""String_Node_Str"");
    Vector oidsTableModelData=oidsTableModel.getDataVector();
    oidsTableModelData.removeAllElements();
    for (    String oid : oids) {
      Vector vec=new Vector();
      vec.add(oid);
      oidsTableModelData.add(vec);
    }
    oidsTableModel.fireTableDataChanged();
  }
}"
13069,"private void updateCurrentDiscoveryMethod(){
  DeviceType device=getCurrentDevice();
  if (device != null) {
    Vector discoveryMethodsRows=discoveryMethodTableModel.getDataVector();
    for (int i=0; i < discoveryMethodsRows.size(); i++) {
      String discoveryMethodName=(String)((Vector)discoveryMethodsRows.get(i)).get(0);
      device.getDiscoveryMethod().get(discoveryMethodsRows.size() - i - 1).setName(discoveryMethodName);
    }
  }
}","private void updateCurrentDiscoveryMethod(){
  DeviceType device=getCurrentDevice();
  if (device != null) {
    Vector discoveryMethodsRows=discoveryMethodTableModel.getDataVector();
    for (int i=0; i < discoveryMethodsRows.size(); i++) {
      String discoveryMethodName=(String)((Vector)discoveryMethodsRows.get(i)).get(0);
      device.getDiscoveryMethod().get(i).setName(discoveryMethodName);
    }
  }
}"
13070,"private void onSelectedDiscoveryMethod(int index){
  updateCurrentOids();
  currentDiscoveryMethodIndex=index;
  updateOidsTable();
}","private void onSelectedDiscoveryMethod(int index){
  if (currentDiscoveryMethodIndex != -1)   updateCurrentOids();
  currentDiscoveryMethodIndex=index;
  updateOidsTable();
}"
13071,"private void updateDiscoveryMethodTable(){
  DeviceType deviceType=getCurrentDevice();
  List<DiscoveryMethodType> discoveryMethodTypeList=deviceType.getDiscoveryMethod();
  Vector discoveryMethodTableModelData=discoveryMethodTableModel.getDataVector();
  discoveryMethodTableModelData.removeAllElements();
  for (  DiscoveryMethodType discoveryMethodType : discoveryMethodTypeList) {
    Vector vec=new Vector();
    vec.add(discoveryMethodType.getName());
    discoveryMethodTableModelData.add(0,vec);
  }
  discoveryMethodTableModel.fireTableDataChanged();
}","private void updateDiscoveryMethodTable(){
  DeviceType deviceType=getCurrentDevice();
  List<DiscoveryMethodType> discoveryMethodTypeList=deviceType.getDiscoveryMethod();
  Vector discoveryMethodTableModelData=discoveryMethodTableModel.getDataVector();
  discoveryMethodTableModelData.removeAllElements();
  for (  DiscoveryMethodType discoveryMethodType : discoveryMethodTypeList) {
    Vector vec=new Vector();
    vec.add(discoveryMethodType.getName());
    discoveryMethodTableModelData.add(vec);
  }
  discoveryMethodTableModel.fireTableDataChanged();
}"
13072,"private void onSelectedDevice(int index){
  updateCurrentDiscoveryMethod();
  updateCurrentOids();
  currentDeviceIndex=index;
  currentDiscoveryMethodIndex=-1;
  updateDiscoveryMethodTable();
  clearOidsTable();
}","private void onSelectedDevice(int index){
  if (currentDeviceIndex != -1) {
    updateCurrentDiscoveryMethod();
    updateCurrentOids();
  }
  currentDeviceIndex=index;
  currentDiscoveryMethodIndex=-1;
  updateDiscoveryMethodTable();
  clearOidsTable();
}"
13073,"private void updateCurrentOids(){
  DiscoveryMethodType discoveryMethod=getCurrentDiscoveryMethod();
  if (discoveryMethod != null) {
    StringBuilder sbs=new StringBuilder();
    Vector oidsTableModelData=oidsTableModel.getDataVector();
    for (int i=oidsTableModelData.size() - 1; i >= 0; i--) {
      Vector row=(Vector)oidsTableModelData.get(i);
      sbs.append(row.get(0));
      if (i > 0)       sbs.append(""String_Node_Str"");
    }
    discoveryMethod.setValue(sbs.toString());
  }
}","private void updateCurrentOids(){
  DiscoveryMethodType discoveryMethod=getCurrentDiscoveryMethod();
  if (discoveryMethod != null) {
    StringBuilder sbs=new StringBuilder();
    Vector oidsTableModelData=oidsTableModel.getDataVector();
    for (int i=0; i < oidsTableModelData.size(); i++) {
      Vector row=(Vector)oidsTableModelData.get(i);
      sbs.append(row.get(0));
      if (i < oidsTableModelData.size())       sbs.append(""String_Node_Str"");
    }
    discoveryMethod.setValue(sbs.toString());
  }
}"
13074,"public void bindFrom(DiscoveryHelperType discoveryHelperType){
  List<DeviceType> deviceTypeList=discoveryHelperType.getDevice();
  Vector devicesTableModelData=devicesTableModel.getDataVector();
  devicesTableModelData.removeAllElements();
  for (  DeviceType deviceType : deviceTypeList) {
    Vector vec=new Vector();
    vec.add(deviceType.getType());
    devicesTableModelData.add(0,vec);
  }
}","public void bindFrom(DiscoveryHelperType discoveryHelperType){
  List<DeviceType> deviceTypeList=discoveryHelperType.getDevice();
  Vector devicesTableModelData=devicesTableModel.getDataVector();
  devicesTableModelData.removeAllElements();
  for (  DeviceType deviceType : deviceTypeList) {
    Vector vec=new Vector();
    vec.add(deviceType.getType());
    devicesTableModelData.add(vec);
  }
}"
13075,"private void doDiff(){
  progressMonitor=new ProgressMonitor(this,""String_Node_Str"",""String_Node_Str"",0,1000);
  progressMonitor.setMillisToPopup(0);
  new File(getDiffPath3()).mkdirs();
  String path1=getDiffPath1();
  File path1File=new File(path1);
  File diffPath1;
  if (path1File.getName().startsWith(""String_Node_Str"")) {
    diffPath1=new File(path1File.getParent(),""String_Node_Str"");
  }
 else {
    diffPath1=new File(path1File.getParent(),""String_Node_Str"");
  }
  String path2=getDiffPath2();
  File path2File=new File(path2);
  File diffPath2;
  if (path2File.getName().startsWith(""String_Node_Str"")) {
    diffPath2=new File(path2File.getParent(),""String_Node_Str"");
  }
 else {
    diffPath2=new File(path2File.getParent(),""String_Node_Str"");
  }
  task=new GraphMLDiffTool(diffPath1.getAbsolutePath(),diffPath2.getAbsolutePath(),getDiffPath3(),getIgnoredKeysPath());
  task.addPropertyChangeListener(this);
  task.execute();
}","private void doDiff(){
  progressMonitor=new ProgressMonitor(this,""String_Node_Str"",""String_Node_Str"",0,1000);
  progressMonitor.setMillisToPopup(0);
  new File(getDiffPath3()).mkdirs();
  String path1=getDiffPath1();
  File path1File=new File(path1);
  File diffPath1;
  if (path1File.getName().startsWith(""String_Node_Str"")) {
    diffPath1=new File(path1File.getParent(),""String_Node_Str"");
  }
 else {
    diffPath1=new File(path1File.getParent(),""String_Node_Str"");
  }
  String path2=getDiffPath2();
  File path2File=new File(path2);
  File diffPath2;
  if (path2File.getName().startsWith(""String_Node_Str"")) {
    diffPath2=new File(path2File.getParent(),""String_Node_Str"");
  }
 else {
    diffPath2=new File(path2File.getParent(),""String_Node_Str"");
  }
  task=new GraphMLDiffTool(baseDir,diffPath1.getAbsolutePath(),diffPath2.getAbsolutePath(),getDiffPath3(),getIgnoredKeysPath());
  task.addPropertyChangeListener(this);
  task.execute();
}"
13076,"private static void createDiffGraphml(URI file1,URI file2,File OutputFile,File ignoredKeysFile) throws FileNotFoundException {
  File transformator=new File(""String_Node_Str"");
  ByteArrayInputStream fileInputStream=null;
  FileOutputStream fileOutputStream=null;
  try {
    System.out.println(""String_Node_Str"");
    String dummyXml=""String_Node_Str"";
    System.out.println(""String_Node_Str"");
    fileInputStream=new ByteArrayInputStream(dummyXml.getBytes());
    System.out.println(""String_Node_Str"" + OutputFile.getAbsolutePath());
    fileOutputStream=new FileOutputStream(OutputFile);
    System.out.println(""String_Node_Str"");
    XsltTransformer transformer=null;
    try {
      transformer=new XsltTransformer();
    }
 catch (    Error e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
    HashMap<String,String> xsltParams;
    xsltParams=new HashMap<String,String>();
    xsltParams.put(""String_Node_Str"",file1.toString());
    xsltParams.put(""String_Node_Str"",file2.toString());
    xsltParams.put(""String_Node_Str"",ignoredKeysFile.toURI().toString());
    System.out.println(""String_Node_Str"");
    System.out.println(fileInputStream.toString() + ""String_Node_Str"" + transformator.toString()+ ""String_Node_Str""+ fileOutputStream.toString());
    transformer.transformXML(fileInputStream,transformator,fileOutputStream,xsltParams,null);
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
catch (  TransformerException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      fileInputStream.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    try {
      fileOutputStream.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","private void createDiffGraphml(URI file1,URI file2,File OutputFile,File ignoredKeysFile) throws FileNotFoundException {
  File transformator=new File(baseDir,""String_Node_Str"");
  ByteArrayInputStream fileInputStream=null;
  FileOutputStream fileOutputStream=null;
  try {
    System.out.println(""String_Node_Str"");
    String dummyXml=""String_Node_Str"";
    System.out.println(""String_Node_Str"");
    fileInputStream=new ByteArrayInputStream(dummyXml.getBytes());
    System.out.println(""String_Node_Str"" + OutputFile.getAbsolutePath());
    fileOutputStream=new FileOutputStream(OutputFile);
    System.out.println(""String_Node_Str"");
    XsltTransformer transformer=null;
    try {
      transformer=new XsltTransformer();
    }
 catch (    Error e) {
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
    HashMap<String,String> xsltParams;
    xsltParams=new HashMap<String,String>();
    xsltParams.put(""String_Node_Str"",file1.toString());
    xsltParams.put(""String_Node_Str"",file2.toString());
    xsltParams.put(""String_Node_Str"",ignoredKeysFile.toURI().toString());
    System.out.println(""String_Node_Str"");
    System.out.println(fileInputStream.toString() + ""String_Node_Str"" + transformator.toString()+ ""String_Node_Str""+ fileOutputStream.toString());
    transformer.transformXML(fileInputStream,transformator,fileOutputStream,xsltParams,null);
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
catch (  TransformerException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      fileInputStream.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    try {
      fileOutputStream.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}"
13077,"public GraphMLDiffTool(String dirAPath,String dirBPath,String dirCPath,String ignoredKeysPath){
  this.dirAPath=dirAPath;
  this.dirBPath=dirBPath;
  this.dirCPath=dirCPath;
  this.ignoredKeysPath=ignoredKeysPath;
}","public GraphMLDiffTool(File baseDir,String dirAPath,String dirBPath,String dirCPath,String ignoredKeysPath){
  this.baseDir=baseDir;
  this.dirAPath=dirAPath;
  this.dirBPath=dirBPath;
  this.dirCPath=dirCPath;
  this.ignoredKeysPath=ignoredKeysPath;
}"
13078,"public static void main(String[] args) throws IOException {
  Map<String,String> params=new HashMap<String,String>();
  String key=null;
  for (  String arg : args) {
    if (key == null && arg.startsWith(""String_Node_Str"")) {
      key=arg;
    }
 else {
      params.put(key,arg);
      key=null;
    }
  }
  String dirAPath=params.get(""String_Node_Str"");
  String dirBPath=params.get(""String_Node_Str"");
  String dirCPath=params.get(""String_Node_Str"");
  String ignoredKeysPath=params.get(""String_Node_Str"");
  GraphMLDiffTool graphMLDiffTool=new GraphMLDiffTool(dirAPath,dirBPath,dirCPath,ignoredKeysPath);
  graphMLDiffTool.execute();
  long time=System.currentTimeMillis();
  graphMLDiffTool.doInBackground();
  System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - time) + ""String_Node_Str"");
}","public static void main(String[] args) throws IOException {
  Map<String,String> params=new HashMap<String,String>();
  String key=null;
  for (  String arg : args) {
    if (key == null && arg.startsWith(""String_Node_Str"")) {
      key=arg;
    }
 else {
      params.put(key,arg);
      key=null;
    }
  }
  String dirAPath=params.get(""String_Node_Str"");
  String dirBPath=params.get(""String_Node_Str"");
  String dirCPath=params.get(""String_Node_Str"");
  String ignoredKeysPath=params.get(""String_Node_Str"");
  GraphMLDiffTool graphMLDiffTool=new GraphMLDiffTool(null,dirAPath,dirBPath,dirCPath,ignoredKeysPath);
  graphMLDiffTool.execute();
  long time=System.currentTimeMillis();
  graphMLDiffTool.doInBackground();
  System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - time) + ""String_Node_Str"");
}"
13079,"private static void createNewGraphml(String newfile,String status,URI file,File OutputFile) throws FileNotFoundException {
  File transformator=new File(""String_Node_Str"");
  ByteArrayInputStream fileInputStream=null;
  FileOutputStream fileOutputStream=null;
  String dummyXml=""String_Node_Str"";
  fileInputStream=new ByteArrayInputStream(dummyXml.getBytes());
  fileOutputStream=new FileOutputStream(OutputFile);
  XsltTransformer transformer=new XsltTransformer();
  HashMap<String,String> xsltParams;
  xsltParams=new HashMap<String,String>();
  xsltParams.put(""String_Node_Str"",file.toString());
  xsltParams.put(""String_Node_Str"",status);
  xsltParams.put(""String_Node_Str"",""String_Node_Str"");
  try {
    transformer.transformXML(fileInputStream,transformator,fileOutputStream,xsltParams,null);
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
catch (  TransformerException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      fileInputStream.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    try {
      fileOutputStream.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","private void createNewGraphml(String newfile,String status,URI file,File OutputFile) throws FileNotFoundException {
  File transformator=new File(baseDir,""String_Node_Str"");
  ByteArrayInputStream fileInputStream=null;
  FileOutputStream fileOutputStream=null;
  String dummyXml=""String_Node_Str"";
  fileInputStream=new ByteArrayInputStream(dummyXml.getBytes());
  fileOutputStream=new FileOutputStream(OutputFile);
  XsltTransformer transformer=new XsltTransformer();
  HashMap<String,String> xsltParams;
  xsltParams=new HashMap<String,String>();
  xsltParams.put(""String_Node_Str"",file.toString());
  xsltParams.put(""String_Node_Str"",status);
  xsltParams.put(""String_Node_Str"",""String_Node_Str"");
  try {
    transformer.transformXML(fileInputStream,transformator,fileOutputStream,xsltParams,null);
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
catch (  TransformerException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      fileInputStream.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    try {
      fileOutputStream.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}"
13080,"private void doDiff(){
  progressMonitor=new ProgressMonitor(this,""String_Node_Str"",""String_Node_Str"",0,1000);
  progressMonitor.setMillisToPopup(0);
  task=new GraphMLDiffTool(getDiffPath1(),getDiffPath2(),getDiffPath3(),getIgnoredKeysPath());
  task.addPropertyChangeListener(this);
  task.execute();
}","private void doDiff(){
  progressMonitor=new ProgressMonitor(this,""String_Node_Str"",""String_Node_Str"",0,1000);
  progressMonitor.setMillisToPopup(0);
  new File(getDiffPath3()).mkdirs();
  task=new GraphMLDiffTool(getDiffPath1(),getDiffPath2(),getDiffPath3(),getIgnoredKeysPath());
  task.addPropertyChangeListener(this);
  task.execute();
}"
13081,"public <G>void handleRightClick(JFrame parent,String v,Map<String,String> graphMLParams,Map<String,String> rightClickParams,java.io.File deviceDataXmlFileName) throws Exception {
  TopologyManagerFrame viewer=(TopologyManagerFrame)parent;
  final GraphViewerPanel viewerPanel=(GraphViewerPanel)viewer.getTabbedPane().getSelectedComponent();
  final MyVisualizationViewer vv=(MyVisualizationViewer)viewerPanel.getVisualizationViewer();
  Object[] test=viewerPanel.getCurrentGraph().getVertices().toArray();
  Arrays.sort(test);
  final String mTo=(String)JOptionPane.showInputDialog(parent,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,test,test[0]);
  final Graph<String,String> mGraph=viewerPanel.getCurrentGraph();
  final Set<String> mPred=viewerPanel.findShortest(v,mTo,mGraph);
  if (mPred == null) {
    JOptionPane.showMessageDialog(parent,String.format(""String_Node_Str"",v,mTo),""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
    return;
  }
  ParameterFactoryBuilder builder=new ParameterFactoryBuilder(rightClickParams.get(""String_Node_Str""));
  ResourceManager resourceManager=new ResourceManager(rightClickParams.get(""String_Node_Str""));
}","public <G>void handleRightClick(JFrame parent,String v,Map<String,String> graphMLParams,Map<String,String> rightClickParams,java.io.File deviceDataXmlFileName) throws Exception {
  TopologyManagerFrame viewer=(TopologyManagerFrame)parent;
  final GraphViewerPanel viewerPanel=(GraphViewerPanel)viewer.getTabbedPane().getSelectedComponent();
  final MyVisualizationViewer vv=(MyVisualizationViewer)viewerPanel.getVisualizationViewer();
  Object[] test=viewerPanel.getCurrentGraph().getVertices().toArray();
  Arrays.sort(test);
  final String mTo=(String)JOptionPane.showInputDialog(parent,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,test,test[0]);
  final Graph<String,String> mGraph=viewerPanel.getCurrentGraph();
  final Set<String> mPred=viewerPanel.findShortest(v,mTo,mGraph);
  if (mPred == null) {
    JOptionPane.showMessageDialog(parent,String.format(""String_Node_Str"",v,mTo),""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
    return;
  }
  ParameterFactoryBuilder builder=new ParameterFactoryBuilder(rightClickParams.get(""String_Node_Str""));
  ResourceManager resourceManager=new ResourceManager(rightClickParams.get(""String_Node_Str""));
  Map<String,Map<String,GraphMLMetadata<String>>> vertexMetadatas=viewer.getCurrentGraphViewerManager().getVertexMetadatas();
  final Layout<String,String> layout=vv.getGraphLayout();
  for (  final String edge : layout.getGraph().getEdges()) {
    Pair<String> endpoints=mGraph.getEndpoints(edge);
    String v1=endpoints.getFirst();
    String v2=endpoints.getSecond();
    if (!v1.equals(v2) && mPred.contains(v1) && mPred.contains(v2)) {
      vv.setEdgeStroke(edge,new BasicStroke(4f));
    }
  }
  viewerPanel.repaint();
  Iterator it=mPred.iterator();
  while (it.hasNext()) {
    Object element=it.next();
    viewerPanel.Animator(element.toString());
    viewerPanel.SetPickedState(element.toString());
    Map<String,Object> context=new HashMap<String,Object>();
    Map<String,String> graphMLParams1=getParams(element.toString(),vertexMetadatas);
    context.put(""String_Node_Str"",graphMLParams1);
    context.put(""String_Node_Str"",rightClickParams);
    context.put(""String_Node_Str"",deviceDataXmlFileName.toURI().toString());
    context.put(""String_Node_Str"",parent);
    ResourceType resource=resourceManager.findResource(graphMLParams1);
    context.put(""String_Node_Str"",ResourceResolver.getConnectionParams(resource,graphMLParams1));
    FulfilmentAdapterFactory factory=new FulfilmentAdapterFactory(rightClickParams.get(""String_Node_Str""),builder,resource);
    String[] factoryNames=factory.getFulfilmentFactoryNamesForResource(resource.getName());
    createGUI(element.toString(),context,factoryNames,factory);
  }
}"
13082,"public <G>void handleRightClick(JFrame parent,String v,Map<String,String> graphMLParams,Map<String,String> rightClickParams,File deviceDataXmlFileName) throws Exception {
}","public <G>void handleRightClick(JFrame parent,String v,Map<String,String> graphMLParams,Map<String,String> rightClickParams,File deviceDataXmlFileName) throws Exception {
  TopologyManagerFrame viewer=(TopologyManagerFrame)parent;
  viewer.getCurrentGraphViewerManager().createAndAddViewerPanel();
}"
13083,"public DiffWizardDialog(final JFrame owner,final Properties preferences) throws MalformedURLException {
  super(owner,""String_Node_Str"",true);
  this.preferences=preferences;
  this.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
  Container cp=getContentPane();
  cp.setLayout(new BorderLayout());
  JPanel buttonsPanel=new JPanel();
  startButton=new JButton(""String_Node_Str"");
  startButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      startButton.setEnabled(false);
      doDiff();
    }
  }
);
  startButton.setPreferredSize(new Dimension(80,25));
  buttonsPanel.add(startButton);
  cancelButton=new JButton(""String_Node_Str"");
  cancelButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      result=Result.CANCELED;
      DiffWizardDialog.this.dispose();
    }
  }
);
  cancelButton.setPreferredSize(new Dimension(80,25));
  buttonsPanel.add(cancelButton);
  cp.add(buttonsPanel,BorderLayout.SOUTH);
  JPanel centralPanel=new JPanel();
  centralPanel.setLayout(new BoxLayout(centralPanel,BoxLayout.Y_AXIS));
  String diffPath1=(String)preferences.get(PreferencesKeys.DIFF_PATH1.name());
  if (diffPath1 == null) {
    diffPath1=(String)preferences.get(PreferencesKeys.PATH.name());
  }
  JPanel row1=new JPanel(new BorderLayout(10,10));
  row1.add(new JLabel(""String_Node_Str""),BorderLayout.WEST);
  diffPathTextField1=new JTextField(diffPath1);
  row1.add(diffPathTextField1,BorderLayout.CENTER);
  openButton1=new JButton(""String_Node_Str"");
  row1.add(openButton1,BorderLayout.EAST);
  centralPanel.add(row1);
  openButton1.addActionListener(new FileSelector(owner,diffPathTextField1,PreferencesKeys.DIFF_PATH1.name()));
  String diffPath2=(String)preferences.get(PreferencesKeys.DIFF_PATH2.name());
  JPanel row2=new JPanel(new BorderLayout(10,10));
  row2.add(new JLabel(""String_Node_Str""),BorderLayout.WEST);
  diffPathTextField2=new JTextField(diffPath2);
  row2.add(diffPathTextField2,BorderLayout.CENTER);
  openButton2=new JButton(""String_Node_Str"");
  row2.add(openButton2,BorderLayout.EAST);
  centralPanel.add(row2);
  openButton2.addActionListener(new FileSelector(owner,diffPathTextField2,PreferencesKeys.DIFF_PATH2.name()));
  diffPathTextField2.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void insertUpdate(    DocumentEvent e){
      System.out.println(""String_Node_Str"");
      final String path1=diffPathTextField1.getText();
      final String path2=diffPathTextField2.getText();
      final String ignoredKeysFile=ignoredKeysTextField.getText();
      File file1=new File(path1);
      File file2=new File(path2);
      diffPathTextField3.setText(new File(new File(file1.getParent()).getParent(),new File(file1.getParent()).getName() + ""String_Node_Str"" + new File(file2.getParent()).getName()).getAbsolutePath());
      preferences.setProperty(PreferencesKeys.DIFF_PATH3.name(),diffPathTextField3.getText());
      try {
        preferences.store(new FileOutputStream(TopologyManagerFrame.VIEWER_PREFERENCES_PROPERTIES),""String_Node_Str"");
      }
 catch (      IOException e1) {
        e1.printStackTrace();
        JOptionPane.showMessageDialog(owner,""String_Node_Str"" + e1.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
    public void removeUpdate(    DocumentEvent e){
    }
    @Override public void changedUpdate(    DocumentEvent e){
    }
  }
);
  String diffPath3=(String)preferences.get(PreferencesKeys.DIFF_PATH3.name());
  JPanel row3=new JPanel(new BorderLayout(10,10));
  row3.add(new JLabel(""String_Node_Str""),BorderLayout.WEST);
  diffPathTextField3=new JTextField(diffPath3);
  row3.add(diffPathTextField3,BorderLayout.CENTER);
  openButton3=new JButton(""String_Node_Str"");
  row3.add(openButton3,BorderLayout.EAST);
  centralPanel.add(row3);
  openButton3.addActionListener(new FileSelector(owner,diffPathTextField3,PreferencesKeys.DIFF_PATH3.name()));
  String diffConfigPath=(String)preferences.get(PreferencesKeys.DIFF_CONFIG.name());
  JPanel row4=new JPanel(new BorderLayout(10,10));
  row4.add(new JLabel(""String_Node_Str""),BorderLayout.WEST);
  diffConfigPathTextField=new JTextField(diffConfigPath);
  row4.add(diffConfigPathTextField,BorderLayout.CENTER);
  openConfigButton=new JButton(""String_Node_Str"");
  row4.add(openConfigButton,BorderLayout.EAST);
  centralPanel.add(row4);
  openConfigButton.addActionListener(new FileSelector(owner,diffConfigPathTextField,PreferencesKeys.DIFF_CONFIG.name(),false));
  String ignoredKeysPath=(String)preferences.get(PreferencesKeys.IGNORED_KEYS_PATH.name());
  JPanel row5=new JPanel(new BorderLayout(10,10));
  row5.add(new JLabel(""String_Node_Str""),BorderLayout.WEST);
  ignoredKeysTextField=new JTextField(ignoredKeysPath);
  row5.add(ignoredKeysTextField,BorderLayout.CENTER);
  ignoredKeysButton=new JButton(""String_Node_Str"");
  row5.add(ignoredKeysButton,BorderLayout.EAST);
  centralPanel.add(row5);
  ignoredKeysButton.addActionListener(new FileSelector(owner,ignoredKeysTextField,PreferencesKeys.IGNORED_KEYS_PATH.name(),false));
  cp.add(centralPanel,BorderLayout.NORTH);
  setPreferredSize(new Dimension(550,200));
  this.pack();
}","public DiffWizardDialog(final JFrame owner,final Properties preferences) throws MalformedURLException {
  super(owner,""String_Node_Str"",true);
  this.preferences=preferences;
  this.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
  Container cp=getContentPane();
  cp.setLayout(new BorderLayout());
  JPanel buttonsPanel=new JPanel();
  startButton=new JButton(""String_Node_Str"");
  startButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      startButton.setEnabled(false);
      doDiff();
    }
  }
);
  startButton.setPreferredSize(new Dimension(80,25));
  buttonsPanel.add(startButton);
  cancelButton=new JButton(""String_Node_Str"");
  cancelButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      result=Result.CANCELED;
      DiffWizardDialog.this.dispose();
    }
  }
);
  cancelButton.setPreferredSize(new Dimension(80,25));
  buttonsPanel.add(cancelButton);
  cp.add(buttonsPanel,BorderLayout.SOUTH);
  JPanel centralPanel=new JPanel();
  centralPanel.setLayout(new BoxLayout(centralPanel,BoxLayout.Y_AXIS));
  String diffPath1=(String)preferences.get(PreferencesKeys.DIFF_PATH1.name());
  if (diffPath1 == null) {
    diffPath1=(String)preferences.get(PreferencesKeys.PATH.name());
  }
  JPanel row1=new JPanel(new BorderLayout(10,10));
  row1.add(new JLabel(""String_Node_Str""),BorderLayout.WEST);
  diffPathTextField1=new JTextField(diffPath1);
  row1.add(diffPathTextField1,BorderLayout.CENTER);
  openButton1=new JButton(""String_Node_Str"");
  row1.add(openButton1,BorderLayout.EAST);
  centralPanel.add(row1);
  openButton1.addActionListener(new FileSelector(owner,diffPathTextField1,PreferencesKeys.DIFF_PATH1.name()));
  String diffPath2=(String)preferences.get(PreferencesKeys.DIFF_PATH2.name());
  JPanel row2=new JPanel(new BorderLayout(10,10));
  row2.add(new JLabel(""String_Node_Str""),BorderLayout.WEST);
  diffPathTextField2=new JTextField(diffPath2);
  row2.add(diffPathTextField2,BorderLayout.CENTER);
  openButton2=new JButton(""String_Node_Str"");
  row2.add(openButton2,BorderLayout.EAST);
  centralPanel.add(row2);
  openButton2.addActionListener(new FileSelector(owner,diffPathTextField2,PreferencesKeys.DIFF_PATH2.name()));
  diffPathTextField2.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void insertUpdate(    DocumentEvent e){
      System.out.println(""String_Node_Str"");
      final String path1=diffPathTextField1.getText();
      final String path2=diffPathTextField2.getText();
      File file1=new File(path1);
      File file2=new File(path2);
      String graphType=null;
      if (path1.endsWith(""String_Node_Str"") && path1.endsWith(""String_Node_Str"")) {
        graphType=""String_Node_Str"";
      }
 else       if (path1.endsWith(""String_Node_Str"") && path1.endsWith(""String_Node_Str"")) {
        graphType=""String_Node_Str"";
      }
      if (graphType != null) {
        diffPathTextField3.setText(new File(new File(new File(file1.getParent()).getParent(),new File(file1.getParent()).getName() + ""String_Node_Str"" + new File(file2.getParent()).getName()),""String_Node_Str"" + graphType).getAbsolutePath());
      }
      preferences.setProperty(PreferencesKeys.DIFF_PATH3.name(),diffPathTextField3.getText());
      try {
        preferences.store(new FileOutputStream(TopologyManagerFrame.VIEWER_PREFERENCES_PROPERTIES),""String_Node_Str"");
      }
 catch (      IOException e1) {
        e1.printStackTrace();
        JOptionPane.showMessageDialog(owner,""String_Node_Str"" + e1.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
    public void removeUpdate(    DocumentEvent e){
    }
    @Override public void changedUpdate(    DocumentEvent e){
    }
  }
);
  String diffPath3=(String)preferences.get(PreferencesKeys.DIFF_PATH3.name());
  JPanel row3=new JPanel(new BorderLayout(10,10));
  JLabel labelGraph3=new JLabel(""String_Node_Str"");
  labelGraph3.setBounds(40,0,100,20);
  row3.add(labelGraph3,BorderLayout.WEST);
  diffPathTextField3=new JTextField(diffPath3);
  diffPathTextField3.setEditable(false);
  row3.add(diffPathTextField3,BorderLayout.CENTER);
  openButton3=new JButton(""String_Node_Str"");
  openButton3.setEnabled(false);
  row3.add(openButton3,BorderLayout.EAST);
  centralPanel.add(row3);
  cp.add(centralPanel,BorderLayout.NORTH);
  setPreferredSize(new Dimension(550,200));
  this.pack();
}"
13084,"@Override public void insertUpdate(DocumentEvent e){
  System.out.println(""String_Node_Str"");
  final String path1=diffPathTextField1.getText();
  final String path2=diffPathTextField2.getText();
  final String ignoredKeysFile=ignoredKeysTextField.getText();
  File file1=new File(path1);
  File file2=new File(path2);
  diffPathTextField3.setText(new File(new File(file1.getParent()).getParent(),new File(file1.getParent()).getName() + ""String_Node_Str"" + new File(file2.getParent()).getName()).getAbsolutePath());
  preferences.setProperty(PreferencesKeys.DIFF_PATH3.name(),diffPathTextField3.getText());
  try {
    preferences.store(new FileOutputStream(TopologyManagerFrame.VIEWER_PREFERENCES_PROPERTIES),""String_Node_Str"");
  }
 catch (  IOException e1) {
    e1.printStackTrace();
    JOptionPane.showMessageDialog(owner,""String_Node_Str"" + e1.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}","@Override public void insertUpdate(DocumentEvent e){
  System.out.println(""String_Node_Str"");
  final String path1=diffPathTextField1.getText();
  final String path2=diffPathTextField2.getText();
  File file1=new File(path1);
  File file2=new File(path2);
  String graphType=null;
  if (path1.endsWith(""String_Node_Str"") && path1.endsWith(""String_Node_Str"")) {
    graphType=""String_Node_Str"";
  }
 else   if (path1.endsWith(""String_Node_Str"") && path1.endsWith(""String_Node_Str"")) {
    graphType=""String_Node_Str"";
  }
  if (graphType != null) {
    diffPathTextField3.setText(new File(new File(new File(file1.getParent()).getParent(),new File(file1.getParent()).getName() + ""String_Node_Str"" + new File(file2.getParent()).getName()),""String_Node_Str"" + graphType).getAbsolutePath());
  }
  preferences.setProperty(PreferencesKeys.DIFF_PATH3.name(),diffPathTextField3.getText());
  try {
    preferences.store(new FileOutputStream(TopologyManagerFrame.VIEWER_PREFERENCES_PROPERTIES),""String_Node_Str"");
  }
 catch (  IOException e1) {
    e1.printStackTrace();
    JOptionPane.showMessageDialog(owner,""String_Node_Str"" + e1.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}"
13085,"public GraphViewerPanel(JFrame parent,TopologyViewerConfType viewerConfig,GraphmlLoader<G> graphmlLoader,IconMapLoader iconMapLoader,EdgeStrokeMapLoader edgeStrokeMapLoader,EdgeColorMapLoader edgeColorMapLoader,G entireGraph,File path,String initialNode){
  super();
  this.parent=parent;
  this.viewerConfig=viewerConfig;
  this.graphmlLoader=graphmlLoader;
  this.entireGraph=entireGraph;
  this.initialNode=initialNode;
  this.deviceXmlPath=new File(path,""String_Node_Str"");
  this.path=path;
  vv=new MyVisualizationViewer(viewerConfig,entireGraph,graphmlLoader.getVertexMetadatas(),graphmlLoader.getEdgeMetadatas(),iconMapLoader.getIconMap(),edgeStrokeMapLoader.getEdgesStrokeMap(),edgeColorMapLoader.getEdgesColorMap());
  createPanel();
}","public GraphViewerPanel(JFrame parent,TopologyViewerConfType viewerConfig,GraphmlLoader<G> graphmlLoader,IconMapLoader iconMapLoader,EdgeStrokeMapLoader edgeStrokeMapLoader,EdgeColorMapLoader edgeColorMapLoader,G entireGraph,File path,File graphmlDir,String initialNode){
  super();
  this.parent=parent;
  this.viewerConfig=viewerConfig;
  this.graphmlLoader=graphmlLoader;
  this.entireGraph=entireGraph;
  this.graphmlDir=graphmlDir;
  this.initialNode=initialNode;
  this.deviceXmlPath=new File(path,""String_Node_Str"");
  this.path=path;
  vv=new MyVisualizationViewer(viewerConfig,entireGraph,graphmlLoader.getVertexMetadatas(),graphmlLoader.getEdgeMetadatas(),iconMapLoader.getIconMap(),edgeStrokeMapLoader.getEdgesStrokeMap(),edgeColorMapLoader.getEdgesColorMap());
  createPanel();
}"
13086,"private GraphViewerPanel createViewerPanel(){
  return new GraphViewerPanel<G>(frame,viewerConfig,graphmlLoader,iconMapLoader,edgeStrokeMapLoader,edgeColorMapLoader,entireGraph,projectPath,initialNode);
}","private GraphViewerPanel createViewerPanel(){
  return new GraphViewerPanel<G>(frame,viewerConfig,graphmlLoader,iconMapLoader,edgeStrokeMapLoader,edgeColorMapLoader,entireGraph,projectPath,graphmlDir,initialNode);
}"
13087,"public void init() throws JAXBException, ParserConfigurationException, SAXException, IOException {
  tabbedPane.removeAll();
  iconMapLoader=new IconMapLoader(viewerConfig);
  edgeStrokeMapLoader=new EdgeStrokeMapLoader(viewerConfig);
  edgeColorMapLoader=new EdgeColorMapLoader(viewerConfig);
  neo4jLoader=new Neo4jLoader<G>(entireGraph,factory,""String_Node_Str"");
  graphmlLoader=new GraphmlLoader<G>(viewerConfig,entireGraph,factory,neo4jLoader.getVertexMetadatas());
  graphmlLoader.addGraphmlLoaderListener(iconMapLoader);
  graphmlLoader.addGraphmlLoaderListener(edgeStrokeMapLoader);
  graphmlLoader.addGraphmlLoaderListener(edgeColorMapLoader);
  graphmlLoader.loadGraphml(graphmlDir);
}","public void init() throws JAXBException, ParserConfigurationException, SAXException, IOException {
  iconMapLoader=new IconMapLoader(viewerConfig);
  edgeStrokeMapLoader=new EdgeStrokeMapLoader(viewerConfig);
  edgeColorMapLoader=new EdgeColorMapLoader(viewerConfig);
  neo4jLoader=new Neo4jLoader<G>(entireGraph,factory,""String_Node_Str"");
  graphmlLoader=new GraphmlLoader<G>(viewerConfig,entireGraph,factory,neo4jLoader.getVertexMetadatas());
  graphmlLoader.addGraphmlLoaderListener(iconMapLoader);
  graphmlLoader.addGraphmlLoaderListener(edgeStrokeMapLoader);
  graphmlLoader.addGraphmlLoaderListener(edgeColorMapLoader);
  graphmlLoader.loadGraphml(graphmlDir);
}"
13088,"public GraphViewerPanelManager(JFrame frame,File projectPath,File graphmlDir,Factory<G> factory,JTabbedPane tabbedPane) throws Exception {
  this.frame=frame;
  this.projectPath=projectPath;
  this.graphmlDir=graphmlDir;
  this.factory=factory;
  this.tabbedPane=tabbedPane;
  entireGraph=factory.create();
  String fName=null;
  if (entireGraph instanceof UndirectedGraph) {
    fName=new File(""String_Node_Str"").toString();
  }
 else   if (entireGraph instanceof DirectedGraph) {
    fName=new File(""String_Node_Str"").toString();
  }
 else {
    JOptionPane.showMessageDialog(frame,""String_Node_Str"");
  }
  viewerConfig=ViewerConfigLoader.loadViewerConfig(new File(this.projectPath,fName));
  init();
}","public GraphViewerPanelManager(JFrame frame,File projectPath,File graphmlDir,Factory<G> factory,JTabbedPane tabbedPane) throws Exception {
  this.frame=frame;
  this.projectPath=projectPath;
  this.graphmlDir=graphmlDir;
  this.factory=factory;
  this.tabbedPane=tabbedPane;
  entireGraph=factory.create();
  String fName=null;
  String graphType=graphmlDir.getName();
  if (""String_Node_Str"".equals(graphType)) {
    fName=new File(""String_Node_Str"").toString();
  }
 else   if (""String_Node_Str"".equals(graphType)) {
    fName=new File(""String_Node_Str"").toString();
  }
 else   if (""String_Node_Str"".equals(graphType) || ""String_Node_Str"".equals(graphType)) {
    fName=new File(""String_Node_Str"").toString();
  }
 else {
    JOptionPane.showMessageDialog(frame,""String_Node_Str"");
  }
  viewerConfig=ViewerConfigLoader.loadViewerConfig(new File(this.projectPath,fName));
  init();
}"
13089,"public void doOpenGraph(File selectedFile){
  try {
    if (""String_Node_Str"".equals(selectedFile.getName())) {
      GraphViewerPanelManager<UndirectedGraph<String,String>> viewerPanelManager=new GraphViewerPanelManager<UndirectedGraph<String,String>>(this,path,selectedFile,UndirectedSparseGraph.<String,String>getFactory(),tabbedPane);
      viewerPanelManagerMap.put(selectedFile.getAbsolutePath(),viewerPanelManager);
      viewerPanelManager.createAndAddViewerPanel();
    }
 else     if (""String_Node_Str"".equals(selectedFile.getName())) {
      GraphViewerPanelManager<DirectedGraph<String,String>> viewerPanelManager=new GraphViewerPanelManager<DirectedGraph<String,String>>(this,path,selectedFile,DirectedSparseMultigraph.<String,String>getFactory(),tabbedPane);
      viewerPanelManagerMap.put(selectedFile.getAbsolutePath(),viewerPanelManager);
      viewerPanelManager.createAndAddViewerPanel();
    }
 else {
      JOptionPane.showMessageDialog(this,String.format(""String_Node_Str"",selectedFile.getName()));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + e.getMessage());
  }
}","public void doOpenGraph(File selectedFile){
  try {
    if (""String_Node_Str"".equals(selectedFile.getName()) || ""String_Node_Str"".equals(selectedFile.getName())) {
      GraphViewerPanelManager<UndirectedGraph<String,String>> viewerPanelManager=new GraphViewerPanelManager<UndirectedGraph<String,String>>(this,path,selectedFile,UndirectedSparseGraph.<String,String>getFactory(),tabbedPane);
      viewerPanelManagerMap.put(selectedFile.getAbsolutePath(),viewerPanelManager);
      viewerPanelManager.createAndAddViewerPanel();
    }
 else     if (""String_Node_Str"".equals(selectedFile.getName()) || ""String_Node_Str"".equals(selectedFile.getName())) {
      GraphViewerPanelManager<DirectedGraph<String,String>> viewerPanelManager=new GraphViewerPanelManager<DirectedGraph<String,String>>(this,path,selectedFile,DirectedSparseMultigraph.<String,String>getFactory(),tabbedPane);
      viewerPanelManagerMap.put(selectedFile.getAbsolutePath(),viewerPanelManager);
      viewerPanelManager.createAndAddViewerPanel();
    }
 else {
      JOptionPane.showMessageDialog(this,String.format(""String_Node_Str"",selectedFile.getName()));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + e.getMessage());
  }
}"
13090,"public void doCloseProject(){
  setPath(null);
  getTabbedPane().removeAll();
}","public void doCloseProject(){
  setPath(null);
  getTabbedPane().removeAll();
  viewerPanelManagerMap.clear();
}"
13091,"private void createFileMenu(TopologyManagerFrame frame,JMenuBar menuBar){
  final JMenu file=new JMenu(""String_Node_Str"");
  menuBar.add(file);
  final JMenuItem newProject=new JMenuItem(""String_Node_Str"");
  newProject.addActionListener(new NewProjectMenuHandler(frame));
  file.add(newProject);
  final JMenuItem open=new JMenuItem(""String_Node_Str"");
  open.addActionListener(new OpenProjectMenuHandler(frame));
  file.add(open);
  final JMenuItem close=new JMenuItem(""String_Node_Str"");
  open.addActionListener(new CloseProjectMenuHandler(frame));
  file.add(close);
  file.addSeparator();
  final JMenuItem openGraph=new JMenuItem(""String_Node_Str"");
  openGraph.addActionListener(new OpenGraphMenuHandler(frame));
  file.add(openGraph);
  final JMenuItem closeGraph=new JMenuItem(""String_Node_Str"");
  file.add(closeGraph);
  final JMenuItem diff=new JMenuItem(""String_Node_Str"");
  diff.addActionListener(new DiffMenuHandler(frame));
  file.add(diff);
  file.addSeparator();
  final JMenuItem config=new JMenuItem(""String_Node_Str"");
  config.addActionListener(new ConfigMenuHandler(frame));
  file.add(config);
  final JMenu capture=new JMenu(""String_Node_Str"");
  file.add(capture);
  JMenuItem captureTpPNGMenuItem=new JMenuItem(""String_Node_Str"");
  captureTpPNGMenuItem.addActionListener(new CaptureToPNGMenuHandler(frame));
  capture.add(captureTpPNGMenuItem);
  JMenuItem captureTpEPSMenuItem=new JMenuItem(""String_Node_Str"");
  captureTpEPSMenuItem.addActionListener(new CaptureToEPSMenuHandler(frame));
  capture.add(captureTpEPSMenuItem);
  file.addSeparator();
  final JMenuItem exit=new JMenuItem(""String_Node_Str"");
  exit.addActionListener(new ExitMenuHandler(frame));
  file.add(exit);
}","private void createFileMenu(TopologyManagerFrame frame,JMenuBar menuBar){
  final JMenu file=new JMenu(""String_Node_Str"");
  menuBar.add(file);
  final JMenuItem newProject=new JMenuItem(""String_Node_Str"");
  newProject.addActionListener(new NewProjectMenuHandler(frame));
  file.add(newProject);
  final JMenuItem open=new JMenuItem(""String_Node_Str"");
  open.addActionListener(new OpenProjectMenuHandler(frame));
  file.add(open);
  final JMenuItem close=new JMenuItem(""String_Node_Str"");
  close.addActionListener(new CloseProjectMenuHandler(frame));
  file.add(close);
  file.addSeparator();
  final JMenuItem openGraph=new JMenuItem(""String_Node_Str"");
  openGraph.addActionListener(new OpenGraphMenuHandler(frame));
  file.add(openGraph);
  final JMenuItem closeGraph=new JMenuItem(""String_Node_Str"");
  closeGraph.addActionListener(new CloseGraphMenuHandler(frame));
  file.add(closeGraph);
  final JMenuItem diff=new JMenuItem(""String_Node_Str"");
  diff.addActionListener(new DiffMenuHandler(frame));
  file.add(diff);
  file.addSeparator();
  final JMenuItem config=new JMenuItem(""String_Node_Str"");
  config.addActionListener(new ConfigMenuHandler(frame));
  file.add(config);
  final JMenu capture=new JMenu(""String_Node_Str"");
  file.add(capture);
  JMenuItem captureTpPNGMenuItem=new JMenuItem(""String_Node_Str"");
  captureTpPNGMenuItem.addActionListener(new CaptureToPNGMenuHandler(frame));
  capture.add(captureTpPNGMenuItem);
  JMenuItem captureTpEPSMenuItem=new JMenuItem(""String_Node_Str"");
  captureTpEPSMenuItem.addActionListener(new CaptureToEPSMenuHandler(frame));
  capture.add(captureTpEPSMenuItem);
  file.addSeparator();
  final JMenuItem exit=new JMenuItem(""String_Node_Str"");
  exit.addActionListener(new ExitMenuHandler(frame));
  file.add(exit);
}"
13092,"private void createWindowMenu(TopologyManagerFrame frame,JMenuBar menuBar){
  final JMenu tabs=new JMenu(""String_Node_Str"");
  menuBar.add(tabs);
  final JMenuItem newTab=new JMenuItem(""String_Node_Str"");
  newTab.addActionListener(new NewTabMenuHandler(frame));
  tabs.add(newTab);
  final JMenuItem close=new JMenuItem(""String_Node_Str"");
  close.addActionListener(new CloseOthersMenuHandler(frame));
  tabs.add(close);
  final JMenuItem closeOthers=new JMenuItem(""String_Node_Str"");
  closeOthers.addActionListener(new CloseAllMenuHandler(frame));
  tabs.add(closeOthers);
  final JMenuItem closeAll=new JMenuItem(""String_Node_Str"");
  closeAll.addActionListener(new CloseAllMenuHandler(frame));
  tabs.add(closeAll);
}","private void createWindowMenu(TopologyManagerFrame frame,JMenuBar menuBar){
  final JMenu tabs=new JMenu(""String_Node_Str"");
  menuBar.add(tabs);
  final JMenuItem newTab=new JMenuItem(""String_Node_Str"");
  newTab.addActionListener(new NewTabMenuHandler(frame));
  tabs.add(newTab);
  final JMenuItem close=new JMenuItem(""String_Node_Str"");
  close.addActionListener(new CloseTabMenuHandler(frame));
  tabs.add(close);
  final JMenuItem closeOthers=new JMenuItem(""String_Node_Str"");
  closeOthers.addActionListener(new CloseOthersMenuHandler(frame));
  tabs.add(closeOthers);
  final JMenuItem closeAll=new JMenuItem(""String_Node_Str"");
  closeAll.addActionListener(new CloseAllMenuHandler(frame));
  tabs.add(closeAll);
}"
13093,"private void fireNodeDiscoveredEvent(NodeDiscoveryResult discoveryResult){
  for (  NodeDiscoveryListener nodeDiscoveryListener : nodeDiscoveryListeners) {
    nodeDiscoveryListener.nodeDiscovered(discoveryResult);
  }
}","private void fireNodeDiscoveredEvent(NodeDiscoveryResult discoveryResult){
  if (nodeDiscoveryListeners != null)   for (  NodeDiscoveryListener nodeDiscoveryListener : nodeDiscoveryListeners) {
    nodeDiscoveryListener.nodeDiscovered(discoveryResult);
  }
}"
13094,"void doDiscoverNodes(List<ConnectionDetails> connectionDetailsList,Map<String,Node> nodes,Node initialNode,int level,int depth){
  for (  ConnectionDetails connectionDetails : connectionDetailsList) {
    String connectionType=connectionDetails.getConnectionType();
    NodeDiscoverer nodeDiscoverer=nodeDiscoverers.get(connectionType);
    if (level == depth)     return;
    if (nodeDiscoverFilter != null && nodeDiscoverFilter.match(connectionDetails))     return;
    NodeDiscoveryResult discoveryResult=nodeDiscoverer.discover(connectionDetails);
    fireNodeDiscoveredEvent(discoveryResult);
    String nodeId=discoveryResult.getNodeId();
    logger.info(""String_Node_Str"" + nodeId);
    logger.debug(""String_Node_Str"" + connectionDetails);
    Node currentNode=nodes.get(nodeId);
    if (currentNode == null) {
      currentNode=new Node(nodeId,connectionDetailsList);
      nodes.put(nodeId,currentNode);
    }
 else {
      logger.debug(""String_Node_Str"" + currentNode.getId() + ""String_Node_Str"");
      return;
    }
    if (initialNode != null)     initialNode.addNeighbour(currentNode);
    List<ConnectionDetails> neighboursConnectionDetails=discoveryResult.getNeighboursConnectionDetails();
    doDiscoverNodes(neighboursConnectionDetails,nodes,currentNode,level + 1,depth);
  }
}","void doDiscoverNodes(List<ConnectionDetails> connectionDetailsList,Map<String,Node> nodes,Node initialNode,int level,int depth){
  for (  ConnectionDetails connectionDetails : connectionDetailsList) {
    String connectionType=connectionDetails.getConnectionType();
    NodeDiscoverer nodeDiscoverer=nodeDiscoverers.get(connectionType);
    if (level == depth)     return;
    if (nodeDiscoverFilter != null && nodeDiscoverFilter.match(connectionDetails))     return;
    NodeDiscoveryResult discoveryResult=nodeDiscoverer.discover(connectionDetails);
    fireNodeDiscoveredEvent(discoveryResult);
    String nodeId=discoveryResult.getNodeId();
    Node currentNode=nodes.get(nodeId);
    if (currentNode == null) {
      if (logger.getLevel() == Level.INFO) {
        logger.info(""String_Node_Str"" + nodeId + ""String_Node_Str"");
      }
 else {
        logger.debug(""String_Node_Str"" + nodeId + ""String_Node_Str""+ connectionDetails);
      }
      currentNode=new Node(nodeId,Arrays.asList(connectionDetails));
      nodes.put(nodeId,currentNode);
    }
 else {
      logger.debug(""String_Node_Str"" + currentNode.getId() + ""String_Node_Str"");
      return;
    }
    if (initialNode != null)     initialNode.addNeighbour(currentNode);
    List<ConnectionDetails> neighboursConnectionDetails=discoveryResult.getNeighboursConnectionDetails();
    logger.debug(""String_Node_Str"" + neighboursConnectionDetails);
    doDiscoverNodes(neighboursConnectionDetails,nodes,currentNode,level + 1,depth);
  }
}"
13095,"@Override public NodeDiscoveryResult discover(ConnectionDetails connectionDetails){
  String node=connectionDetails.getParam(""String_Node_Str"");
  NodeDiscoveryResult result=new NodeDiscoveryResult();
  result.setNodeId(node);
  Set<ConnectionDetails> neighbours=new HashSet<ConnectionDetails>();
  for (  Pair<String,String> link : links) {
    String neighbour=null;
    if (link.getFirst().equals(node)) {
      neighbour=link.getSecond();
    }
 else {
      neighbour=link.getFirst();
    }
    if (neighbour != null) {
      ConnectionDetails conn=new ConnectionDetails(""String_Node_Str"");
      conn.put(""String_Node_Str"",neighbour);
      neighbours.add(conn);
    }
  }
  result.setNeighboursConnectionDetails(Arrays.asList(neighbours.toArray(new ConnectionDetails[0])));
  return result;
}","@Override public NodeDiscoveryResult discover(ConnectionDetails connectionDetails){
  String node=connectionDetails.getParam(""String_Node_Str"");
  NodeDiscoveryResult result=new NodeDiscoveryResult();
  result.setNodeId(node);
  Set<ConnectionDetails> neighbours=new HashSet<ConnectionDetails>();
  for (  Pair<String,String> link : links) {
    String neighbour;
    if (link.getFirst().equals(node)) {
      neighbour=link.getSecond();
    }
 else     if (link.getSecond().equals(node)) {
      neighbour=link.getFirst();
    }
 else {
      continue;
    }
    if (neighbour != null) {
      ConnectionDetails conn=new ConnectionDetails(""String_Node_Str"");
      conn.put(""String_Node_Str"",neighbour);
      neighbours.add(conn);
    }
  }
  result.setNeighboursConnectionDetails(Arrays.asList(neighbours.toArray(new ConnectionDetails[0])));
  return result;
}"
13096,"public MockNetworkDiscoverer(){
  networkNodes=new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  links=new HashSet<Pair<String,String>>();
  links.add(new Pair<String,String>(""String_Node_Str"",""String_Node_Str""));
  links.add(new Pair<String,String>(""String_Node_Str"",""String_Node_Str""));
  links.add(new Pair<String,String>(""String_Node_Str"",""String_Node_Str""));
  links.add(new Pair<String,String>(""String_Node_Str"",""String_Node_Str""));
}","public MockNetworkDiscoverer(){
  networkNodes=new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  links=new HashSet<Pair<String,String>>();
  links.add(new Pair<String,String>(""String_Node_Str"",""String_Node_Str""));
  links.add(new Pair<String,String>(""String_Node_Str"",""String_Node_Str""));
  links.add(new Pair<String,String>(""String_Node_Str"",""String_Node_Str""));
}"
13097,"public static void main1(String[] args){
  ConnectionDetails connectionDetails=new ConnectionDetails();
  ;
  connectionDetails.setConnectionType(""String_Node_Str"");
  Map<String,String> params=new HashMap();
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.setParams(params);
  NetworkDiscoverer discoverer=new NetworkDiscoverer();
  Map<String,Node> result=discoverer.discoverNodes(Arrays.asList(connectionDetails));
  System.out.println(result);
}","public static void main1(String[] args){
  ConnectionDetails connectionDetails=new ConnectionDetails();
  ;
  connectionDetails.setConnectionType(""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  NetworkDiscoverer discoverer=new NetworkDiscoverer();
  Map<String,Node> result=discoverer.discoverNodes(Arrays.asList(connectionDetails));
  System.out.println(result);
}"
13098,"public static void main(String[] args){
  ClassPathXmlApplicationContext applicationContext=new ClassPathXmlApplicationContext(""String_Node_Str"");
  NetworkDiscoverer discoverer=applicationContext.getBean(NetworkDiscoverer.class);
  ConnectionDetails connectionDetails=new ConnectionDetails();
  connectionDetails.setConnectionType(""String_Node_Str"");
  Map<String,String> params=new HashMap<String,String>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.setParams(params);
  Map<String,Node> result=discoverer.discoverNodes(Arrays.asList(connectionDetails));
  System.out.println(result);
}","public static void main(String[] args){
  ClassPathXmlApplicationContext applicationContext=new ClassPathXmlApplicationContext(""String_Node_Str"");
  NetworkDiscoverer discoverer=applicationContext.getBean(NetworkDiscoverer.class);
  ConnectionDetails connectionDetails=new ConnectionDetails();
  connectionDetails.setConnectionType(""String_Node_Str"");
  Map<String,String> params=new HashMap<String,String>();
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  connectionDetails.put(""String_Node_Str"",""String_Node_Str"");
  Map<String,Node> result=discoverer.discoverNodes(Arrays.asList(connectionDetails));
  System.out.println(result);
}"
13099,"public Map<String,Node> discoverNodes(List<ConnectionDetails> connectionDetailsList){
  this.filter=filter;
  Map<String,Node> nodes=new HashMap<String,Node>();
  doDiscoverNodes(connectionDetailsList,nodes,null);
  return nodes;
}","public Map<String,Node> discoverNodes(List<ConnectionDetails> connectionDetailsList,int depth){
  Map<String,Node> nodes=new HashMap<String,Node>();
  doDiscoverNodes(connectionDetailsList,nodes,null,0,depth);
  return nodes;
}"
13100,"private void doDiscoverNodes(List<ConnectionDetails> connectionDetailsList,Map<String,Node> nodes,Node initialNode){
  for (  ConnectionDetails connectionDetails : connectionDetailsList) {
    String connectionType=connectionDetails.getConnectionType();
    NodeDiscoverer nodeDiscoverer=nodeDiscoverers.get(connectionType);
    boolean stopDiscovery=filter.match(connectionDetails);
    if (stopDiscovery)     return;
    NodeDiscoveryResult discoveryResult=nodeDiscoverer.discover(connectionDetails);
    String nodeId=discoveryResult.getNodeId();
    System.out.println(""String_Node_Str"" + nodeId);
    Node currentNode=nodes.get(nodeId);
    if (currentNode == null) {
      currentNode=new Node(nodeId,connectionDetailsList);
      nodes.put(nodeId,currentNode);
    }
    if (initialNode != null) {
      initialNode.addNeighbour(currentNode);
    }
    List<ConnectionDetails> neighboursConnectionDetails=discoveryResult.getNeighboursConnectionDetails();
    doDiscoverNodes(neighboursConnectionDetails,nodes,currentNode);
  }
}","void doDiscoverNodes(List<ConnectionDetails> connectionDetailsList,Map<String,Node> nodes,Node initialNode,int level,int depth){
  for (  ConnectionDetails connectionDetails : connectionDetailsList) {
    String connectionType=connectionDetails.getConnectionType();
    NodeDiscoverer nodeDiscoverer=nodeDiscoverers.get(connectionType);
    if (level == depth)     return;
    if (filter != null) {
      boolean stopDiscovery=filter.match(connectionDetails);
      if (stopDiscovery)       return;
    }
    NodeDiscoveryResult discoveryResult=nodeDiscoverer.discover(connectionDetails);
    String nodeId=discoveryResult.getNodeId();
    System.out.println(""String_Node_Str"" + nodeId);
    Node currentNode=nodes.get(nodeId);
    if (currentNode == null) {
      currentNode=new Node(nodeId,connectionDetailsList);
      nodes.put(nodeId,currentNode);
    }
 else {
      System.out.println(""String_Node_Str"" + currentNode.getId() + ""String_Node_Str"");
      return;
    }
    if (initialNode != null) {
      initialNode.addNeighbour(currentNode);
    }
    List<ConnectionDetails> neighboursConnectionDetails=discoveryResult.getNeighboursConnectionDetails();
    doDiscoverNodes(neighboursConnectionDetails,nodes,currentNode,level + 1,depth);
  }
}"
13101,"@Override public boolean match(ConnectionDetails details){
  String host=details.getParams().get(""String_Node_Str"");
  for (  String notMatch : notMatches) {
    String propertyName=notMatch.substring(0,notMatch.indexOf(""String_Node_Str""));
    String propVal=host;
    String notMatchVal=notMatch.substring(notMatch.indexOf(""String_Node_Str"") + 1);
    logger.debug(""String_Node_Str"" + propertyName + ""String_Node_Str""+ propVal+ ""String_Node_Str""+ notMatchVal);
    if (propVal != null && propVal.matches(notMatchVal)) {
      return false;
    }
  }
  for (  String match : matches) {
    String propertyName=match.substring(0,match.indexOf(""String_Node_Str""));
    String propVal=host;
    String matchVal=match.substring(match.indexOf(""String_Node_Str"") + 1);
    logger.debug(""String_Node_Str"" + propertyName + ""String_Node_Str""+ propVal+ ""String_Node_Str""+ matchVal);
    if (propVal != null && propVal.matches(matchVal)) {
      return true;
    }
  }
  return false;
}","@Override public boolean match(ConnectionDetails details){
  String host=details.getParam(""String_Node_Str"");
  for (  String notMatch : notMatches) {
    String propertyName=notMatch.substring(0,notMatch.indexOf(""String_Node_Str""));
    String propVal=host;
    String notMatchVal=notMatch.substring(notMatch.indexOf(""String_Node_Str"") + 1);
    logger.debug(""String_Node_Str"" + propertyName + ""String_Node_Str""+ propVal+ ""String_Node_Str""+ notMatchVal);
    if (propVal != null && propVal.matches(notMatchVal)) {
      return false;
    }
  }
  for (  String match : matches) {
    String propertyName=match.substring(0,match.indexOf(""String_Node_Str""));
    String propVal=host;
    String matchVal=match.substring(match.indexOf(""String_Node_Str"") + 1);
    logger.debug(""String_Node_Str"" + propertyName + ""String_Node_Str""+ propVal+ ""String_Node_Str""+ matchVal);
    if (propVal != null && propVal.matches(matchVal)) {
      return true;
    }
  }
  return false;
}"
13102,"@Override public NodeDiscoveryResult discover(ConnectionDetails connectionDetails){
  Map<String,String> params=connectionDetails.getParams();
  NodeDiscoveryResult result=new NodeDiscoveryResult();
  String hostName=params.get(""String_Node_Str"");
  IPv4Address ipAddress=new IPv4Address(params.get(""String_Node_Str""),params.get(""String_Node_Str""));
  Map<String,String> params1=new HashMap<String,String>();
  params1.put(""String_Node_Str"",hostName);
  params1.put(""String_Node_Str"",""String_Node_Str"");
  ResourceType SNMP=this.discoveryResource.ReturnResourceByParam(params1);
  Map<String,String> SNMPconnParams=new HashMap<String,String>();
  SNMPconnParams=this.discoveryResource.getParamMap(SNMP);
  Resource resource=new Resource(hostName,ipAddress,params.get(""String_Node_Str""),Integer.parseInt(SNMPconnParams.get(""String_Node_Str"")),SNMPconnParams);
  String devName=walker.getDeviceName(resource);
  result.setNodeId(devName);
  String deviceType=walker.getDeviceType(resource);
  resource.setDeviceType(deviceType);
  DiscoveryHelper discoveryHelper=discoveryHelperFactory.createDiscoveryHelper(deviceType);
  String[] requestParamsList=discoveryHelper.getRequestParams(discoveryTypes);
  RawDeviceData rawData=walker.getRawDeviceData(resource,requestParamsList);
  DiscoveredDeviceData discoveredDeviceData=discoveryHelper.parseDeviceRawData(rawData,discoveryTypes,resource);
  Device device=discoveryHelper.createDevice(discoveredDeviceData);
  List<DeviceNeighbour> neighbours=device.getDeviceNeighbours();
  List<ConnectionDetails> neighboursConnDetails=createNeighbourConnectionDetails(connectionDetails,params,neighbours);
  result.setNeighboursConnectionDetails(neighboursConnDetails);
  return result;
}","@Override public NodeDiscoveryResult discover(ConnectionDetails connectionDetails){
  NodeDiscoveryResult result=new NodeDiscoveryResult();
  String hostName=connectionDetails.getParam(""String_Node_Str"");
  IPv4Address ipAddress=new IPv4Address(connectionDetails.getParam(""String_Node_Str""),connectionDetails.getParam(""String_Node_Str""));
  Map<String,String> params1=new HashMap<String,String>();
  params1.put(""String_Node_Str"",hostName);
  params1.put(""String_Node_Str"",""String_Node_Str"");
  ResourceType SNMP=this.discoveryResource.ReturnResourceByParam(params1);
  Map<String,String> SNMPconnParams=new HashMap<String,String>();
  SNMPconnParams=this.discoveryResource.getParamMap(SNMP);
  Resource resource=new Resource(hostName,ipAddress,connectionDetails.getParam(""String_Node_Str""),Integer.parseInt(SNMPconnParams.get(""String_Node_Str"")),SNMPconnParams);
  String devName=walker.getDeviceName(resource);
  result.setNodeId(devName);
  String deviceType=walker.getDeviceType(resource);
  resource.setDeviceType(deviceType);
  DiscoveryHelper discoveryHelper=discoveryHelperFactory.createDiscoveryHelper(deviceType);
  String[] requestParamsList=discoveryHelper.getRequestParams(discoveryTypes);
  RawDeviceData rawData=walker.getRawDeviceData(resource,requestParamsList);
  DiscoveredDeviceData discoveredDeviceData=discoveryHelper.parseDeviceRawData(rawData,discoveryTypes,resource);
  Device device=discoveryHelper.createDevice(discoveredDeviceData);
  List<DeviceNeighbour> neighbours=device.getDeviceNeighbours();
  List<ConnectionDetails> neighboursConnDetails=createNeighbourConnectionDetails(connectionDetails,neighbours);
  result.setNeighboursConnectionDetails(neighboursConnDetails);
  return result;
}"
13103,"private List<ConnectionDetails> createNeighbourConnectionDetails(ConnectionDetails connectionDetails,Map<String,String> params,List<DeviceNeighbour> neighbours){
  List<ConnectionDetails> neighboursConnDetails=new ArrayList<ConnectionDetails>();
  for (  DeviceNeighbour neighbour : neighbours) {
    params.put(""String_Node_Str"",neighbour.getDeviceType());
    if (neighbour.getStatus()) {
      params.put(""String_Node_Str"",neighbour.getHostName());
      params.put(""String_Node_Str"",neighbour.getIpAddress().getIpAddress());
      params.put(""String_Node_Str"",neighbour.getIpAddress().getNetMask());
      params.put(""String_Node_Str"",""String_Node_Str"" + neighbour.getROCommunity());
      ConnectionDetails neighbourConnectionDetails=new ConnectionDetails();
      neighbourConnectionDetails.setConnectionType(""String_Node_Str"");
      neighbourConnectionDetails.setParams(params);
      neighboursConnDetails.add(neighbourConnectionDetails);
    }
  }
  return neighboursConnDetails;
}","private List<ConnectionDetails> createNeighbourConnectionDetails(ConnectionDetails connectionDetails,List<DeviceNeighbour> neighbours){
  List<ConnectionDetails> neighboursConnDetails=new ArrayList<ConnectionDetails>();
  for (  DeviceNeighbour neighbour : neighbours) {
    connectionDetails.put(""String_Node_Str"",neighbour.getDeviceType());
    if (neighbour.getStatus()) {
      connectionDetails.put(""String_Node_Str"",neighbour.getHostName());
      connectionDetails.put(""String_Node_Str"",neighbour.getIpAddress().getIpAddress());
      connectionDetails.put(""String_Node_Str"",neighbour.getIpAddress().getNetMask());
      connectionDetails.put(""String_Node_Str"",""String_Node_Str"" + neighbour.getROCommunity());
      ConnectionDetails neighbourConnectionDetails=new ConnectionDetails();
      neighbourConnectionDetails.setConnectionType(""String_Node_Str"");
      neighboursConnDetails.add(neighbourConnectionDetails);
    }
  }
  return neighboursConnDetails;
}"
13104,"private List<ConnectionDetails> createNeigbourConnectionDetails(ConnectionDetails connectionDetails,Map<String,String> params,List<DeviceNeighbour> neighbours){
  List<ConnectionDetails> neighboursConnDetails=new ArrayList<ConnectionDetails>();
  for (  DeviceNeighbour neighbour : neighbours) {
    params.put(""String_Node_Str"",neighbour.getDeviceType());
    params.put(""String_Node_Str"",neighbour.getHostName());
    params.put(""String_Node_Str"",""String_Node_Str"" + neighbour.getIpAddress());
    params.put(""String_Node_Str"",""String_Node_Str"" + neighbour.getROCommunity());
    ConnectionDetails neighbourConnectionDetails=new ConnectionDetails();
    connectionDetails.setConnectionType(""String_Node_Str"");
    connectionDetails.setParams(params);
    neighboursConnDetails.add(neighbourConnectionDetails);
  }
  return neighboursConnDetails;
}","private List<ConnectionDetails> createNeigbourConnectionDetails(ConnectionDetails connectionDetails,Map<String,String> params,List<DeviceNeighbour> neighbours){
  List<ConnectionDetails> neighboursConnDetails=new ArrayList<ConnectionDetails>();
  for (  DeviceNeighbour neighbour : neighbours) {
    params.put(""String_Node_Str"",neighbour.getDeviceType());
    params.put(""String_Node_Str"",neighbour.getHostName());
    params.put(""String_Node_Str"",""String_Node_Str"" + neighbour.getIpAddress());
    params.put(""String_Node_Str"",""String_Node_Str"" + neighbour.getROCommunity());
    ConnectionDetails neighbourConnectionDetails=new ConnectionDetails();
    neighbourConnectionDetails.setConnectionType(""String_Node_Str"");
    neighbourConnectionDetails.setParams(params);
    neighboursConnDetails.add(neighbourConnectionDetails);
  }
  return neighboursConnDetails;
}"
13105,"private List<ConnectionDetails> createNeigbourConnectionDetails(ConnectionDetails connectionDetails,Map<String,String> params,List<DeviceNeighbour> neighbours){
  List<ConnectionDetails> neighboursConnDetails=new ArrayList<ConnectionDetails>();
  for (  DeviceNeighbour neighbour : neighbours) {
    params.put(""String_Node_Str"",neighbour.getDeviceType());
    params.put(""String_Node_Str"",neighbour.getHostName());
    params.put(""String_Node_Str"",""String_Node_Str"" + neighbour.getIpAddress());
    params.put(""String_Node_Str"",""String_Node_Str"" + neighbour.getROCommunity());
    ConnectionDetails neighbourConnectionDetails=new ConnectionDetails();
    neighbourConnectionDetails.setConnectionType(""String_Node_Str"");
    neighbourConnectionDetails.setParams(params);
    neighboursConnDetails.add(neighbourConnectionDetails);
  }
  return neighboursConnDetails;
}","private List<ConnectionDetails> createNeigbourConnectionDetails(ConnectionDetails connectionDetails,Map<String,String> params,List<DeviceNeighbour> neighbours){
  List<ConnectionDetails> neighboursConnDetails=new ArrayList<ConnectionDetails>();
  for (  DeviceNeighbour neighbour : neighbours) {
    params.put(""String_Node_Str"",neighbour.getDeviceType());
    if (neighbour.getStatus()) {
      params.put(""String_Node_Str"",neighbour.getHostName());
      params.put(""String_Node_Str"",""String_Node_Str"" + neighbour.getIpAddress());
      params.put(""String_Node_Str"",""String_Node_Str"" + neighbour.getROCommunity());
      ConnectionDetails neighbourConnectionDetails=new ConnectionDetails();
      neighbourConnectionDetails.setConnectionType(""String_Node_Str"");
      neighbourConnectionDetails.setParams(params);
      neighboursConnDetails.add(neighbourConnectionDetails);
    }
  }
  return neighboursConnDetails;
}"
13106,"@GET @Produces(MediaType.APPLICATION_XML + ""String_Node_Str"") @Path(""String_Node_Str"") public String getNodeAsXml(@PathParam(""String_Node_Str"") String nodeId) throws IOException, SAXException, ParserConfigurationException {
  if (graph == null) {
    File graphmlFile=new File(context.getInitParameter(""String_Node_Str""));
    this.init(DirectedSparseGraph.<String,String>getFactory(),graphmlFile);
  }
  StringBuilder sb=new StringBuilder();
  sb.append(String.format(""String_Node_Str"",nodeId));
  for (  Object mdKey : gmlr.getVertexMetadata().keySet()) {
    GraphMLMetadata<String> o=(GraphMLMetadata<String>)gmlr.getVertexMetadata().get(mdKey);
    String value=o.transformer.transform((String)nodeId);
    if (value != null) {
      sb.append(String.format(""String_Node_Str"",mdKey,value));
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","public String getNodeAsXml(@PathParam(""String_Node_Str"") String nodeId) throws IOException, SAXException, ParserConfigurationException {
  if (graph == null) {
    File graphmlFile=new File(context.getInitParameter(""String_Node_Str""));
    this.init(DirectedSparseGraph.<String,String>getFactory(),graphmlFile);
  }
  StringBuilder sb=new StringBuilder();
  sb.append(String.format(""String_Node_Str"",nodeId));
  for (  Object mdKey : gmlr.getVertexMetadata().keySet()) {
    GraphMLMetadata<String> o=(GraphMLMetadata<String>)gmlr.getVertexMetadata().get(mdKey);
    String value=o.transformer.transform((String)nodeId);
    if (value != null) {
      sb.append(String.format(""String_Node_Str"",mdKey,value));
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
13107,"@GET @Produces({MediaType.APPLICATION_XML + ""String_Node_Str"",MediaType.TEXT_HTML + ""String_Node_Str""}) @Path(""String_Node_Str"") public String getNodesAsXml() throws IOException, SAXException, ParserConfigurationException {
  if (graph == null) {
    File graphmlFile=new File(context.getInitParameter(""String_Node_Str""));
    this.init(DirectedSparseGraph.<String,String>getFactory(),graphmlFile);
  }
  StringBuilder sb=new StringBuilder();
  sb.append(String.format(""String_Node_Str"",graph.getVertices().size()));
  for (  String vertex : graph.getVertices()) {
    sb.append(String.format(""String_Node_Str"",vertex));
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@GET @Produces({MediaType.APPLICATION_XML + ""String_Node_Str""}) @Path(""String_Node_Str"") public String getNodesAsXml() throws IOException, SAXException, ParserConfigurationException {
  if (graph == null) {
    File graphmlFile=new File(context.getInitParameter(""String_Node_Str""));
    this.init(DirectedSparseGraph.<String,String>getFactory(),graphmlFile);
  }
  StringBuilder sb=new StringBuilder();
  sb.append(String.format(""String_Node_Str"",graph.getVertices().size()));
  for (  String vertex : graph.getVertices()) {
    sb.append(String.format(""String_Node_Str"",vertex));
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
13108,"@GET @Produces(""String_Node_Str"") @Path(""String_Node_Str"") public String getNodeAsHtmlById(@QueryParam(""String_Node_Str"") String nodeId) throws IOException, SAXException, ParserConfigurationException {
  if (graph == null) {
    File graphmlFile=new File(context.getInitParameter(""String_Node_Str""));
    this.init(DirectedSparseGraph.<String,String>getFactory(),graphmlFile);
  }
  if (nodeId == null) {
    return getNodesAsHtml();
  }
  StringBuilder sb=new StringBuilder();
  sb.append(String.format(""String_Node_Str"",nodeId));
  for (  Object mdKey : gmlr.getVertexMetadata().keySet()) {
    GraphMLMetadata<String> o=(GraphMLMetadata<String>)gmlr.getVertexMetadata().get(mdKey);
    String value=o.transformer.transform((String)nodeId);
    if (value != null) {
      sb.append(String.format(""String_Node_Str"",mdKey,value));
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@GET @Produces(MediaType.TEXT_HTML + ""String_Node_Str"") @Path(""String_Node_Str"") public String getNodeAsHtmlById(@QueryParam(""String_Node_Str"") String nodeId) throws IOException, SAXException, ParserConfigurationException {
  if (graph == null) {
    File graphmlFile=new File(context.getInitParameter(""String_Node_Str""));
    this.init(DirectedSparseGraph.<String,String>getFactory(),graphmlFile);
  }
  if (nodeId == null) {
    return getNodesAsHtml();
  }
  StringBuilder sb=new StringBuilder();
  sb.append(String.format(""String_Node_Str"",nodeId));
  for (  Object mdKey : gmlr.getVertexMetadata().keySet()) {
    GraphMLMetadata<String> o=(GraphMLMetadata<String>)gmlr.getVertexMetadata().get(mdKey);
    String value=o.transformer.transform((String)nodeId);
    if (value != null) {
      sb.append(String.format(""String_Node_Str"",mdKey,value));
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
13109,"public static void main(String[] args) throws Exception {
  Map<String,String> params=CmdLineParser.parseCmdLine(args);
  logger.info(""String_Node_Str"" + params.toString());
  final String settingsFile=params.get(""String_Node_Str"");
  if (settingsFile == null) {
    printUsage(""String_Node_Str"");
    return;
  }
  Map<String,String> settings=loadProperties(new File(System.getProperty(""String_Node_Str""),settingsFile));
  logger.info(""String_Node_Str"" + settings.toString());
  File outputDir=new File(System.getProperty(""String_Node_Str""),settings.get(""String_Node_Str""));
  System.out.println(outputDir.getAbsolutePath());
  boolean result=outputDir.mkdir();
  File graphmlDir=new File(System.getProperty(""String_Node_Str""),settings.get(""String_Node_Str""));
  result=outputDir.mkdir();
  XsltTransformer transformer=new XsltTransformer();
  byte[] rawData=snmpWalk(settings);
  File rawDataFile=new File(outputDir,""String_Node_Str"");
  FileUtils.writeStringToFile(rawDataFile,new String(rawData));
  ByteArrayOutputStream outputStream1=new ByteArrayOutputStream();
  File xsltFileName1=new File(System.getProperty(""String_Node_Str""),settings.get(""String_Node_Str""));
  ByteArrayInputStream inputStream1=new ByteArrayInputStream(rawData);
  transformer.transformXML(inputStream1,xsltFileName1,outputStream1,settings,null);
  System.out.println(new String(outputStream1.toByteArray()));
  ByteArrayOutputStream outputStream2=new ByteArrayOutputStream();
  File xsltFileName2=new File(System.getProperty(""String_Node_Str""),settings.get(""String_Node_Str""));
  ByteArrayInputStream inputStream2=new ByteArrayInputStream(outputStream1.toByteArray());
  transformer.transformXML(inputStream2,xsltFileName2,outputStream2,settings,null);
  File outputFile=new File(graphmlDir,""String_Node_Str"");
  File nodesFileListFile=new File(graphmlDir,""String_Node_Str"");
  FileUtils.writeStringToFile(outputFile,new String(outputStream2.toByteArray()));
  FileUtils.writeStringToFile(nodesFileListFile,""String_Node_Str"");
}","public static void main(String[] args) throws Exception {
  Map<String,String> params=CmdLineParser.parseCmdLine(args);
  logger.info(""String_Node_Str"" + params.toString());
  final String settingsFile=params.get(""String_Node_Str"");
  if (settingsFile == null) {
    printUsage(""String_Node_Str"");
    return;
  }
  Map<String,String> settings=loadProperties(new File(System.getProperty(""String_Node_Str""),settingsFile));
  logger.info(""String_Node_Str"" + settings.toString());
  File outputDir=new File(System.getProperty(""String_Node_Str""),settings.get(""String_Node_Str""));
  System.out.println(outputDir.getAbsolutePath());
  boolean result=outputDir.mkdir();
  File graphmlDir=new File(System.getProperty(""String_Node_Str""),settings.get(""String_Node_Str""));
  result=outputDir.mkdir();
  XsltTransformer transformer=new XsltTransformer();
  byte[] rawData=snmpWalk(settings);
  File rawDataFile=new File(outputDir,""String_Node_Str"");
  FileUtils.writeStringToFile(rawDataFile,new String(rawData));
  ByteArrayOutputStream outputStream1=new ByteArrayOutputStream();
  File xsltFileName1=new File(System.getProperty(""String_Node_Str""),settings.get(""String_Node_Str""));
  ByteArrayInputStream inputStream1=new ByteArrayInputStream(rawData);
  transformer.transformXML(inputStream1,xsltFileName1,outputStream1,settings,null);
  ByteArrayOutputStream outputStream2=new ByteArrayOutputStream();
  File xsltFileName2=new File(System.getProperty(""String_Node_Str""),settings.get(""String_Node_Str""));
  ByteArrayInputStream inputStream2=new ByteArrayInputStream(outputStream1.toByteArray());
  transformer.transformXML(inputStream2,xsltFileName2,outputStream2,settings,null);
  File outputFile=new File(graphmlDir,""String_Node_Str"");
  File nodesFileListFile=new File(graphmlDir,""String_Node_Str"");
  FileUtils.writeStringToFile(outputFile,new String(outputStream2.toByteArray()));
  FileUtils.writeStringToFile(nodesFileListFile,""String_Node_Str"");
}"
13110,"@Override public String toString(){
  final StringBuilder sb=new StringBuilder();
  sb.append(DateFormat.format(DATE_FORMAT,new Date(time))).append(""String_Node_Str"");
  sb.append(level.toString()).append(""String_Node_Str"");
  sb.append(tag).append(""String_Node_Str"");
  sb.append(message).append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  final SimpleDateFormat formatter=new SimpleDateFormat(DATE_FORMAT);
  final StringBuilder sb=new StringBuilder();
  sb.append(formatter.format(new Date(time))).append(""String_Node_Str"");
  sb.append(level.toString()).append(""String_Node_Str"");
  sb.append(tag).append(""String_Node_Str"");
  sb.append(message).append(""String_Node_Str"");
  return sb.toString();
}"
13111,"@Override public String toString(){
  final StringBuilder sb=new StringBuilder();
  sb.append(DATE_FORMAT.format(new Date(time))).append(""String_Node_Str"");
  sb.append(level.toString()).append(""String_Node_Str"");
  sb.append(tag).append(""String_Node_Str"");
  sb.append(message).append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  final StringBuilder sb=new StringBuilder();
  sb.append(DateFormat.format(DATE_FORMAT,new Date(time))).append(""String_Node_Str"");
  sb.append(level.toString()).append(""String_Node_Str"");
  sb.append(tag).append(""String_Node_Str"");
  sb.append(message).append(""String_Node_Str"");
  return sb.toString();
}"
13112,"public static void printlnLogOnScreen(final LogEvent event){
  if (appContext == null) {
    return;
  }
  final Collection<WeakReference<TextView>> weakTextViews=repository.getTextViews();
  if (weakTextViews.isEmpty()) {
    return;
  }
  final String logText=event.toString();
  final int logTextLength=logText.length();
  final Handler mainHandler=new Handler(appContext.getMainLooper());
  for (  final WeakReference<TextView> weakTextView : weakTextViews) {
    final TextView textView=weakTextView.get();
    if (textView == null) {
      continue;
    }
    final String viewText=textView.getText().toString();
    int viewTextLength=viewText.length();
    final StringBuilder sb=new StringBuilder(viewText);
    while (viewTextLength + logTextLength > MAX_LOG_TEXT_LENGHT_IN_VIEW) {
      final int index=sb.indexOf(""String_Node_Str"");
      sb.delete(0,index);
      viewTextLength=sb.length();
    }
    sb.append(logText);
    final String newViewText=sb.toString();
    mainHandler.post(new Runnable(){
      @Override public void run(){
        final TextView textView=weakTextView.get();
        if (textView != null) {
          textView.setText(newViewText);
        }
      }
    }
);
  }
}","public static void printlnLogOnScreen(final LogEvent event){
  if (appContext == null || event == null) {
    return;
  }
  final Collection<WeakReference<TextView>> weakTextViews=repository.getTextViews();
  if (weakTextViews.isEmpty()) {
    return;
  }
  final String logText=event.toString();
  final int logTextLength=logText.length();
  final Handler mainHandler=new Handler(appContext.getMainLooper());
  for (  final WeakReference<TextView> weakTextView : weakTextViews) {
    final TextView textView=weakTextView.get();
    if (textView == null) {
      continue;
    }
    final String viewText=textView.getText().toString();
    int viewTextLength=viewText.length();
    final StringBuilder sb=new StringBuilder(viewText);
    while (viewTextLength + logTextLength > MAX_LOG_TEXT_LENGHT_IN_VIEW) {
      final int index=sb.indexOf(""String_Node_Str"");
      sb.delete(0,index);
      viewTextLength=sb.length();
    }
    sb.append(logText);
    final String newViewText=sb.toString();
    mainHandler.post(new Runnable(){
      @Override public void run(){
        final TextView textView=weakTextView.get();
        if (textView != null) {
          textView.setText(newViewText);
        }
      }
    }
);
  }
}"
13113,"private static InputStream readConfiguresFromClasspath(){
  tryToloadPropertiesFromClasspath=true;
  final String filename=CONFIG_FILE_NAME + ""String_Node_Str"";
  InputStream in=null;
  try {
    in=LoggerFactory.class.getClassLoader().getResourceAsStream(filename);
  }
 catch (  final Exception e) {
  }
  if (in == null) {
    try {
      in=ClassLoader.getSystemClassLoader().getResourceAsStream(filename);
    }
 catch (    final Exception e) {
    }
  }
  if (in != null) {
    internalLogger.verbose(""String_Node_Str"",CONFIG_FILE_NAME);
  }
  return in;
}","private static InputStream readConfiguresFromClasspath(){
  tryToloadPropertiesFromClasspath=true;
  final String filename=CONFIG_FILE_NAME + ""String_Node_Str"";
  LoggerFactory.class.getClassLoader();
  InputStream in=LoggerFactory.class.getClassLoader().getResourceAsStream(""String_Node_Str"" + filename);
  if (in != null) {
    internalLogger.verbose(""String_Node_Str"",CONFIG_FILE_NAME);
  }
 else {
    in=LoggerFactory.class.getClassLoader().getResourceAsStream(""String_Node_Str"" + filename);
    if (in != null) {
      internalLogger.verbose(""String_Node_Str"",CONFIG_FILE_NAME);
    }
  }
  return in;
}"
13114,"/** 
 * Get the logger of the calling class.
 * @return logger of the calling class
 * @since 0.1.0-RELEASE
 */
public static Logger getLogger(){
synchronized (LoggerFactory.class) {
    if (!loadPropertiesSuccess && !tryToloadPropertiesFromClasspath) {
      final Properties configProperties=loadProperties(readConfiguresFromClasspath());
      if (configProperties != null) {
        parseProperties(configProperties);
      }
    }
    final String caller=getCallerClassName();
    internalLogger.verbose(""String_Node_Str"",caller);
    final Logger logger=getDeclaredLogger(caller);
    return logger != null ? logger : getNewLogger(caller);
  }
}","/** 
 * Get the logger of the calling class.
 * @return logger of the calling class
 * @since 0.1.0-RELEASE
 */
public static Logger getLogger(){
synchronized (LoggerFactory.class) {
    if (!loadPropertiesSuccess && !tryToloadPropertiesFromClasspath) {
      checkEnvironmentAndSetup(DEFAULT_RELEASE_LOG_LEVEL);
      final Properties configProperties=loadProperties(readConfiguresFromClasspath());
      if (configProperties != null) {
        parseProperties(configProperties);
      }
    }
    final String caller=getCallerClassName();
    internalLogger.verbose(""String_Node_Str"",caller);
    final Logger logger=getDeclaredLogger(caller);
    return logger != null ? logger : getNewLogger(caller);
  }
}"
13115,"/** 
 * Locate the config properties file, search assets folder, res/raw in order, read the file after found.
 * @return the properties of config file, if file not found return{@code null}
 */
private static Properties locateAndLoadProperties(){
  InputStream in=null;
  final String filename=CONFIG_FILE_NAME + ""String_Node_Str"";
  try {
    in=appContext.getAssets().open(filename);
    internalLogger.verbose(""String_Node_Str"",CONFIG_FILE_NAME);
  }
 catch (  final IOException e) {
  }
  if (in == null) {
    final String packageName=appContext.getPackageName();
    try {
      final int id=Utils.intReflectStaticFieldValue(packageName + ""String_Node_Str"",CONFIG_FILE_NAME,-1);
      if (id != -1) {
        in=appContext.getResources().openRawResource(id);
        internalLogger.verbose(""String_Node_Str"",CONFIG_FILE_NAME);
      }
    }
 catch (    final Exception e) {
    }
  }
  if (in == null) {
    in=readConfiguresFromClasspath();
  }
  return loadProperties(in);
}","/** 
 * Locate the config properties file, search assets folder, res/raw in order, read the file after found.
 * @return the properties of config file, if file not found return{@code null}
 */
private static Properties locateAndLoadProperties(){
  InputStream in=null;
  final String filename=CONFIG_FILE_NAME + ""String_Node_Str"";
  try {
    in=appContext.getAssets().open(filename);
    internalLogger.verbose(""String_Node_Str"",CONFIG_FILE_NAME);
  }
 catch (  final IOException e) {
  }
  if (in == null) {
    final String packageName=appContext.getPackageName();
    try {
      final int id=Utils.intReflectStaticFieldValue(packageName + ""String_Node_Str"",CONFIG_FILE_NAME,-1);
      if (id != -1) {
        in=appContext.getResources().openRawResource(id);
        internalLogger.verbose(""String_Node_Str"",CONFIG_FILE_NAME);
      }
    }
 catch (    final Exception e) {
    }
  }
  return loadProperties(in);
}"
13116,"/** 
 * Read the value of 'package.BuildConfig.DEBUG', this value is   {@code true}in developing and is   {@code false} after being packaged(release mode). Ingenerally, we want to hide the low level log message in release mode.
 * @param level log level of the root logger in release mode
 */
private static void checkEnvironmentAndSetup(final LogLevel level){
  final String packageName=appContext.getPackageName();
  final boolean underDevelopment=Utils.booleanReflectStaticFieldValue(packageName + ""String_Node_Str"",""String_Node_Str"",true);
  if (!underDevelopment) {
    ConfigureRepository.setInternalLogLevel(LogLevel.OFF);
    repository.setRootLoggerConfig(new LoggerConfig(""String_Node_Str"",null,level,false));
  }
}","/** 
 * Read the value of 'package.BuildConfig.DEBUG', this value is   {@code true}in developing and is   {@code false} after being packaged(release mode). Ingenerally, we want to hide the low level log message in release mode.
 * @param level log level of the root logger in release mode
 */
private static void checkEnvironmentAndSetup(final LogLevel level){
  String packageName;
  if (appContext != null) {
    packageName=appContext.getPackageName();
  }
 else {
    packageName=getPackageNameFromAndroidManifest();
  }
  final boolean underDevelopment=Utils.booleanReflectStaticFieldValue(packageName + ""String_Node_Str"",""String_Node_Str"",true);
  if (!underDevelopment) {
    ConfigureRepository.setInternalLogLevel(LogLevel.OFF);
    repository.setRootLoggerConfig(new LoggerConfig(""String_Node_Str"",null,level,false));
  }
}"
13117,"private static Properties loadProperties(final InputStream in){
  if (in == null) {
    return null;
  }
  final Properties properties=new Properties();
  try {
    properties.load(in);
  }
 catch (  final IOException e) {
    return null;
  }
 finally {
    try {
      in.close();
    }
 catch (    final IOException e) {
    }
  }
  return properties;
}","private static Properties loadProperties(final InputStream in){
  if (in == null) {
    internalLogger.verbose(""String_Node_Str"",CONFIG_FILE_NAME);
    return null;
  }
  final Properties properties=new Properties();
  try {
    properties.load(in);
  }
 catch (  final IOException e) {
    return null;
  }
 finally {
    try {
      in.close();
    }
 catch (    final IOException e) {
    }
  }
  return properties;
}"
13118,"public void start(){
  if (isStarted() || isStop()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  try {
    createAndOpenLogFile();
    worker.start();
  }
 catch (  final Exception e) {
    stop();
    internalLogger.verbose(e,""String_Node_Str"");
  }
  started=true;
}","public void start(){
  if (isStarted() || isStop()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  try {
    createAndOpenLogFile();
    worker.start();
    started=true;
  }
 catch (  final Exception e) {
    stop();
    internalLogger.verbose(e,""String_Node_Str"");
  }
}"
13119,"/** 
 * Internal method that prints log message.
 * @param level the LogLevel of the log message
 * @param t a throwable(exception) object, can be  {@code null}
 * @param format a format string of the log message, can be  {@code null}.
 * @param args an array of arguments, can be  {@code null}
 * @since 0.1.0-RELEASE
 */
protected void println(final LogLevel level,final Throwable t,final String format,final Object... args){
  if (this.level.includes(level) && (t != null || format != null)) {
    String message=null;
    if (format != null && format.length() > 0) {
      message=(args != null && args.length > 0) ? String.format(format,args) : format;
    }
    if (t != null) {
      message=message != null ? message + ""String_Node_Str"" + Log.getStackTraceString(t) : Log.getStackTraceString(t);
    }
    if (thread) {
      Log.println(level.intValue(),""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str"",message);
    }
 else {
      Log.println(level.intValue(),tag,message);
    }
  }
}","/** 
 * Internal method that prints log message.
 * @param level the LogLevel of the log message
 * @param t a throwable(exception) object, can be  {@code null}
 * @param format a format string of the log message, can be  {@code null}.
 * @param args an array of arguments, can be  {@code null}
 * @since 0.1.0-RELEASE
 */
protected void println(final LogLevel level,final Throwable t,final String format,final Object... args){
  if (this.level.includes(level) && (t != null || format != null)) {
    String message=null;
    if (format != null && format.length() > 0) {
      message=(args != null && args.length > 0) ? String.format(format,args) : format;
    }
    if (t != null) {
      message=message != null ? message + ""String_Node_Str"" + Log.getStackTraceString(t) : Log.getStackTraceString(t);
    }
    if (thread) {
      final StringBuilder sb=new StringBuilder();
      sb.append(""String_Node_Str"").append(Thread.currentThread().getName()).append(""String_Node_Str"").append(tag);
      Log.println(level.intValue(),sb.toString(),message);
    }
 else {
      Log.println(level.intValue(),tag,message);
    }
  }
}"
13120,"/** 
 * Internal method that prints log message.
 * @param level the LogLevel of the log message
 * @param t a throwable(exception) object, can be  {@code null}
 * @param format a format string of the log message, can be  {@code null}.
 * @param args an array of arguments, can be  {@code null}
 */
protected void println(final LogLevel level,final Throwable t,final String format,final Object... args){
  if (this.level.includes(level) && (t != null || format != null)) {
    String message=null;
    if (format != null && format.length() > 0) {
      message=(args != null && args.length > 0) ? String.format(format,args) : format;
    }
    if (t != null) {
      message=message != null ? message + Log.getStackTraceString(t) : Log.getStackTraceString(t);
    }
    Log.println(level.intValue(),tag,message);
  }
}","/** 
 * Internal method that prints log message.
 * @param level the LogLevel of the log message
 * @param t a throwable(exception) object, can be  {@code null}
 * @param format a format string of the log message, can be  {@code null}.
 * @param args an array of arguments, can be  {@code null}
 */
protected void println(final LogLevel level,final Throwable t,final String format,final Object... args){
  if (this.level.includes(level) && (t != null || format != null)) {
    String message=null;
    if (format != null && format.length() > 0) {
      message=(args != null && args.length > 0) ? String.format(format,args) : format;
    }
    if (t != null) {
      message=message != null ? message + ""String_Node_Str"" + Log.getStackTraceString(t) : Log.getStackTraceString(t);
    }
    Log.println(level.intValue(),tag,message);
  }
}"
13121,"@Test public void test() throws IOException, JBIG2Exception, NoSuchAlgorithmException {
  final URL imageUrl=JBIG2ImageReaderDemo.class.getResource(resourcePath);
  final InputStream inputStream=new FileInputStream(new File(imageUrl.getPath()));
  final InputStreamFactory disf=new DefaultInputStreamFactory();
  final ImageInputStream iis=disf.getInputStream(inputStream);
  final JBIG2DocumentFacade doc=new JBIG2DocumentFacade(iis);
  final Bitmap b=doc.getPageBitmap(pageNumber);
  final WritableRaster raster=Bitmaps.asRaster(b,param,filterType);
  final DataBufferByte dataBufferByte=(DataBufferByte)raster.getDataBuffer();
  final byte[] bytes=dataBufferByte.getData();
  final MessageDigest md=MessageDigest.getInstance(""String_Node_Str"");
  final byte[] digest=md.digest(bytes);
  final StringBuilder sb=new StringBuilder();
  for (  byte toAppend : digest) {
    sb.append(toAppend);
  }
  assertArrayEquals(checksum.getBytes(),sb.toString().getBytes());
}","@Test public void test() throws IOException, JBIG2Exception, NoSuchAlgorithmException {
  final InputStream inputStream=JBIG2ImageReaderDemo.class.getResourceAsStream(resourcePath);
  final InputStreamFactory disf=new DefaultInputStreamFactory();
  final ImageInputStream iis=disf.getInputStream(inputStream);
  final JBIG2DocumentFacade doc=new JBIG2DocumentFacade(iis);
  final Bitmap b=doc.getPageBitmap(pageNumber);
  final WritableRaster raster=Bitmaps.asRaster(b,param,filterType);
  final DataBufferByte dataBufferByte=(DataBufferByte)raster.getDataBuffer();
  final byte[] bytes=dataBufferByte.getData();
  final MessageDigest md=MessageDigest.getInstance(""String_Node_Str"");
  final byte[] digest=md.digest(bytes);
  final StringBuilder sb=new StringBuilder();
  for (  byte toAppend : digest) {
    sb.append(toAppend);
  }
  assertArrayEquals(checksum.getBytes(),sb.toString().getBytes());
}"
13122,"private void preprocessCodes(List<Code> codeTable){
  int maxPrefixLength=0;
  for (  Code c : codeTable) {
    maxPrefixLength=Math.max(maxPrefixLength,c.prefixLength);
  }
  int lenCount[]=new int[maxPrefixLength + 1];
  for (  Code c : codeTable) {
    lenCount[c.prefixLength]++;
  }
  int curCode, curTemp;
  int firstCode[]=new int[lenCount.length + 1];
  lenCount[0]=0;
  for (int curLen=1; curLen <= lenCount.length; curLen++) {
    firstCode[curLen]=(firstCode[curLen - 1] + (lenCount[curLen - 1]) << 1);
    curCode=firstCode[curLen];
    for (    Code code : codeTable) {
      if (code.prefixLength == curLen) {
        code.code=curCode;
        curCode++;
      }
    }
  }
  if (JBIG2ImageReader.DEBUG)   System.out.println(codeTableToString(codeTable));
}","private void preprocessCodes(List<Code> codeTable){
  int maxPrefixLength=0;
  for (  Code c : codeTable) {
    maxPrefixLength=Math.max(maxPrefixLength,c.prefixLength);
  }
  int lenCount[]=new int[maxPrefixLength + 1];
  for (  Code c : codeTable) {
    lenCount[c.prefixLength]++;
  }
  int curCode;
  int firstCode[]=new int[lenCount.length + 1];
  lenCount[0]=0;
  for (int curLen=1; curLen <= lenCount.length; curLen++) {
    firstCode[curLen]=(firstCode[curLen - 1] + (lenCount[curLen - 1]) << 1);
    curCode=firstCode[curLen];
    for (    Code code : codeTable) {
      if (code.prefixLength == curLen) {
        code.code=curCode;
        curCode++;
      }
    }
  }
  if (JBIG2ImageReader.DEBUG)   System.out.println(codeTableToString(codeTable));
}"
13123,"public void initTree(List<Code> codeTable){
  preprocessCodes(codeTable);
  for (  Code c : codeTable) {
    rootNode.append(c);
  }
  System.out.println(""String_Node_Str"");
}","public void initTree(List<Code> codeTable){
  preprocessCodes(codeTable);
  for (  Code c : codeTable) {
    rootNode.append(c);
  }
}"
13124,"private void preprocessCodes(List<Code> codeTable){
  int maxPrefixLength=0;
  for (  Code c : codeTable) {
    maxPrefixLength=Math.max(maxPrefixLength,c.prefixLength);
  }
  int lenCount[]=new int[maxPrefixLength + 1];
  for (  Code c : codeTable) {
    lenCount[c.prefixLength]++;
  }
  int curCode, curTemp;
  int firstCode[]=new int[lenCount.length + 1];
  lenCount[0]=0;
  for (int curLen=1; curLen <= lenCount.length; curLen++) {
    firstCode[curLen]=(firstCode[curLen - 1] + (lenCount[curLen - 1]) << 1);
    curCode=firstCode[curLen];
    for (    Code code : codeTable) {
      if (code.prefixLength == curLen) {
        code.code=curCode;
        curCode++;
      }
    }
  }
  if (JBIG2ImageReader.DEBUG)   System.out.println(codeTableToString(codeTable));
}","private void preprocessCodes(List<Code> codeTable){
  int maxPrefixLength=0;
  for (  Code c : codeTable) {
    maxPrefixLength=Math.max(maxPrefixLength,c.prefixLength);
  }
  int lenCount[]=new int[maxPrefixLength + 1];
  for (  Code c : codeTable) {
    lenCount[c.prefixLength]++;
  }
  int curCode;
  int firstCode[]=new int[lenCount.length + 1];
  lenCount[0]=0;
  for (int curLen=1; curLen <= lenCount.length; curLen++) {
    firstCode[curLen]=(firstCode[curLen - 1] + (lenCount[curLen - 1]) << 1);
    curCode=firstCode[curLen];
    for (    Code code : codeTable) {
      if (code.prefixLength == curLen) {
        code.code=curCode;
        curCode++;
      }
    }
  }
  if (JBIG2ImageReader.DEBUG)   System.out.println(codeTableToString(codeTable));
}"
13125,"public void initTree(List<Code> codeTable){
  preprocessCodes(codeTable);
  for (  Code c : codeTable) {
    rootNode.append(c);
  }
  System.out.println(""String_Node_Str"");
}","public void initTree(List<Code> codeTable){
  preprocessCodes(codeTable);
  for (  Code c : codeTable) {
    rootNode.append(c);
  }
}"
13126,"/** 
 * <a href=""https://github.com/levigo/jbig2-imageio/issues/21"">Github issue 21s</a>
 */
@Test public void issue21() throws Exception {
  final byte[] md5Expected=new byte[]{-79,69,103,64,59,120,-74,117,-96,-86,-23,36,-122,113,101,-99};
  final InputStream imageStream=getClass().getResourceAsStream(""String_Node_Str"");
  final InputStream globalsStream=getClass().getResourceAsStream(""String_Node_Str"");
  final ImageInputStream globalsIIS=ImageIO.createImageInputStream(globalsStream);
  final ImageInputStream imageIIS=ImageIO.createImageInputStream(imageStream);
  byte[] md5Actual=null;
  try {
    final JBIG2Document doc=doc(imageIIS,globalsIIS);
    final JBIG2Page page=doc.getPage(1);
    final Bitmap bitmap=page.getBitmap();
    md5Actual=md5(bitmap);
  }
  finally {
    Assert.assertArrayEquals(md5Expected,md5Actual);
    globalsIIS.close();
    globalsStream.close();
    imageIIS.close();
    imageStream.close();
  }
}","/** 
 * <a href=""https://github.com/levigo/jbig2-imageio/issues/21"">Github issue 21s</a>
 */
@Test public void issue21() throws Exception {
  final byte[] md5Expected=new byte[]{83,74,-69,-60,-122,-99,21,126,-115,13,9,107,-31,-109,77,-119};
  final InputStream imageStream=getClass().getResourceAsStream(""String_Node_Str"");
  final InputStream globalsStream=getClass().getResourceAsStream(""String_Node_Str"");
  final ImageInputStream globalsIIS=ImageIO.createImageInputStream(globalsStream);
  final ImageInputStream imageIIS=ImageIO.createImageInputStream(imageStream);
  byte[] md5Actual=null;
  try {
    final JBIG2Document doc=doc(imageIIS,globalsIIS);
    final JBIG2Page page=doc.getPage(1);
    final Bitmap bitmap=page.getBitmap();
    md5Actual=md5(bitmap);
  }
  finally {
    Assert.assertArrayEquals(md5Expected,md5Actual);
    globalsIIS.close();
    globalsStream.close();
    imageIIS.close();
    imageStream.close();
  }
}"
13127,"public Iterator<B> getServices(Class<B> cls,ClassLoader clsLoader){
  Iterator<B> services=ServiceRegistry.lookupProviders(cls);
  if (!services.hasNext()) {
    services=ServiceRegistry.lookupProviders(cls,cls.getClass().getClassLoader());
  }
  if (!services.hasNext() && clsLoader != null) {
    services=ServiceRegistry.lookupProviders(cls,clsLoader);
  }
  return services;
}","public Iterator<B> getServices(Class<B> cls,ClassLoader clsLoader){
  Iterator<B> services=ServiceLoader.load(cls).iterator();
  if (!services.hasNext()) {
    services=ServiceLoader.load(cls,cls.getClass().getClassLoader()).iterator();
  }
  if (!services.hasNext() && clsLoader != null) {
    services=ServiceLoader.load(cls,clsLoader).iterator();
  }
  return services;
}"
13128,"/** 
 * Convert every key-value pair of a map into a string and append them all into a single string, in iteration order.
 */
@Test @Ignore public void c4_appendToMapValues(){
  Map<Integer,StringBuilder> map=new TreeMap<>();
  map.put(1,new StringBuilder(""String_Node_Str""));
  map.put(2,new StringBuilder(""String_Node_Str""));
  map.put(3,new StringBuilder(""String_Node_Str""));
  assertEquals(3,map.size());
  assertTrue(map.values().stream().allMatch(x -> x instanceof StringBuilder));
  assertEquals(""String_Node_Str"",map.get(1).toString());
  assertEquals(""String_Node_Str"",map.get(2).toString());
  assertEquals(""String_Node_Str"",map.get(3).toString());
}","/** 
 * Given a map whose keys are Integers and whose values are StringBuilders, append to each StringBuilder the string representation of its corresponding Integer key. This should mutate each StringBuilder value in-place.
 */
@Test @Ignore public void c4_appendToMapValues(){
  Map<Integer,StringBuilder> map=new TreeMap<>();
  map.put(1,new StringBuilder(""String_Node_Str""));
  map.put(2,new StringBuilder(""String_Node_Str""));
  map.put(3,new StringBuilder(""String_Node_Str""));
  assertEquals(3,map.size());
  assertTrue(map.values().stream().allMatch(x -> x instanceof StringBuilder));
  assertEquals(""String_Node_Str"",map.get(1).toString());
  assertEquals(""String_Node_Str"",map.get(2).toString());
  assertEquals(""String_Node_Str"",map.get(3).toString());
}"
13129,"/** 
 * Convert every key-value pair of a map into a string and append them all into a single string, in iteration order.
 */
@Test public void c4_appendToMapValues(){
  Map<Integer,StringBuilder> map=new TreeMap<>();
  map.put(1,new StringBuilder(""String_Node_Str""));
  map.put(2,new StringBuilder(""String_Node_Str""));
  map.put(3,new StringBuilder(""String_Node_Str""));
  map.forEach((k,v) -> v.append(k));
  assertEquals(3,map.size());
  assertTrue(map.values().stream().allMatch(x -> x instanceof StringBuilder));
  assertEquals(""String_Node_Str"",map.get(1).toString());
  assertEquals(""String_Node_Str"",map.get(2).toString());
  assertEquals(""String_Node_Str"",map.get(3).toString());
}","/** 
 * Given a map whose keys are Integers and whose values are StringBuilders, append to each StringBuilder the string representation of its corresponding Integer key. This should mutate each StringBuilder value in-place.
 */
@Test public void c4_appendToMapValues(){
  Map<Integer,StringBuilder> map=new TreeMap<>();
  map.put(1,new StringBuilder(""String_Node_Str""));
  map.put(2,new StringBuilder(""String_Node_Str""));
  map.put(3,new StringBuilder(""String_Node_Str""));
  map.forEach((k,v) -> v.append(k));
  assertEquals(3,map.size());
  assertTrue(map.values().stream().allMatch(x -> x instanceof StringBuilder));
  assertEquals(""String_Node_Str"",map.get(1).toString());
  assertEquals(""String_Node_Str"",map.get(2).toString());
  assertEquals(""String_Node_Str"",map.get(3).toString());
}"
13130,"public void disconnect(){
  if (connection != null) {
    try {
      connection.disconnect();
    }
 catch (    NotConnectedException ignored) {
      logger.debug(""String_Node_Str"");
    }
  }
}","public void disconnect(){
  if (connection != null) {
    try {
      connection.disconnect();
    }
 catch (    NotConnectedException ignored) {
      logger.debug(""String_Node_Str"");
    }
  }
  if (heartbeat != null) {
    heartbeat.cancel(false);
  }
}"
13131,"@Override public void run(){
  try {
    if (!connection.isConnected()) {
      if (heartbeat != null) {
        heartbeat.cancel(false);
      }
      return;
    }
    sendPing();
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"",e);
  }
}","@Override public void run(){
  try {
    if (connection.isConnected()) {
      sendPing();
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"",e);
  }
}"
13132,"public void connect(String host,String username,String password){
  LoginToken loginToken=authService.getLoginToken(username,password);
  ConnectionConfiguration connectionConfig=createConnectionConfig(host,DEFAULT_PORT);
  XMPPTCPConnection authConnection=new XMPPTCPConnection(connectionConfig);
  try {
    addPacketLogging(authConnection,""String_Node_Str"");
    authConnection.connect();
    authConnection.login(DEFAULT_XMPP_USER,DEFAULT_XMPP_PASSWORD,""String_Node_Str"");
    authConnection.setFromMode(FromMode.USER);
    AuthRequest sessionRequest=createSessionRequest(loginToken);
    AuthReply oaResponse=sendOAPacket(authConnection,sessionRequest,AuthReply.class);
    authConnection.disconnect();
    connection=new XMPPTCPConnection(connectionConfig);
    addPacketLogging(connection,""String_Node_Str"");
    connection.connect();
    connection.login(oaResponse.getUsername(),oaResponse.getPassword(),""String_Node_Str"");
    connection.setFromMode(FromMode.USER);
    connection.addConnectionListener(new ConnectionListener(){
      @Override public void reconnectionSuccessful(){
        getCurrentActivity();
      }
      @Override public void connected(      XMPPConnection connection){
      }
      @Override public void authenticated(      XMPPConnection connection){
      }
      @Override public void connectionClosed(){
      }
      @Override public void connectionClosedOnError(      Exception e){
      }
      @Override public void reconnectingIn(      int seconds){
      }
      @Override public void reconnectionFailed(      Exception e){
      }
    }
);
    heartbeat=scheduler.scheduleAtFixedRate(new Runnable(){
      @Override public void run(){
        try {
          if (!connection.isConnected()) {
            if (heartbeat != null) {
              heartbeat.cancel(false);
            }
            return;
          }
          sendPing();
        }
 catch (        Exception e) {
          logger.warn(""String_Node_Str"",e);
        }
      }
    }
,30,30,TimeUnit.SECONDS);
    monitorActivityChanges();
    getCurrentActivity();
  }
 catch (  XMPPException|SmackException|IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","public void connect(String host,String username,String password){
  LoginToken loginToken=authService.getLoginToken(username,password);
  ConnectionConfiguration connectionConfig=createConnectionConfig(host,DEFAULT_PORT);
  XMPPTCPConnection authConnection=new XMPPTCPConnection(connectionConfig);
  try {
    addPacketLogging(authConnection,""String_Node_Str"");
    authConnection.connect();
    authConnection.login(DEFAULT_XMPP_USER,DEFAULT_XMPP_PASSWORD,""String_Node_Str"");
    authConnection.setFromMode(FromMode.USER);
    AuthRequest sessionRequest=createSessionRequest(loginToken);
    AuthReply oaResponse=sendOAPacket(authConnection,sessionRequest,AuthReply.class);
    authConnection.disconnect();
    connection=new XMPPTCPConnection(connectionConfig);
    addPacketLogging(connection,""String_Node_Str"");
    connection.connect();
    connection.login(oaResponse.getUsername(),oaResponse.getPassword(),""String_Node_Str"");
    connection.setFromMode(FromMode.USER);
    connection.addConnectionListener(new ConnectionListener(){
      @Override public void reconnectionSuccessful(){
        getCurrentActivity();
      }
      @Override public void connected(      XMPPConnection connection){
      }
      @Override public void authenticated(      XMPPConnection connection){
      }
      @Override public void connectionClosed(){
      }
      @Override public void connectionClosedOnError(      Exception e){
      }
      @Override public void reconnectingIn(      int seconds){
      }
      @Override public void reconnectionFailed(      Exception e){
      }
    }
);
    heartbeat=scheduler.scheduleAtFixedRate(new Runnable(){
      @Override public void run(){
        try {
          if (connection.isConnected()) {
            sendPing();
          }
        }
 catch (        Exception e) {
          logger.warn(""String_Node_Str"",e);
        }
      }
    }
,30,30,TimeUnit.SECONDS);
    monitorActivityChanges();
    getCurrentActivity();
  }
 catch (  XMPPException|SmackException|IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}"
13133,"private <R extends OAPacket>R sendOAPacket(XMPPTCPConnection authConnection,OAPacket packet,Class<R> replyClass,long replyTimeout){
  PacketCollector collector=authConnection.createPacketCollector(new OAReplyFilter(packet,authConnection));
  try {
    authConnection.sendPacket(packet);
    return replyClass.cast(getNextPacketSkipContinues(collector,replyTimeout));
  }
 catch (  SmackException|XMPPErrorException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
 finally {
    collector.cancel();
  }
}","private <R extends OAPacket>R sendOAPacket(XMPPTCPConnection authConnection,OAPacket packet,Class<R> replyClass,long replyTimeout){
  PacketCollector collector=authConnection.createPacketCollector(new OAReplyFilter(packet,authConnection));
  messageLock.lock();
  try {
    authConnection.sendPacket(packet);
    return replyClass.cast(getNextPacketSkipContinues(collector,replyTimeout));
  }
 catch (  SmackException|XMPPErrorException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
 finally {
    messageLock.unlock();
    collector.cancel();
  }
}"
13134,"public NearestNeighborCollector(final E origin,final DistanceFunction<E> distanceFunction,final int capacity){
  if (capacity < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.origin=origin;
  this.distanceFunction=distanceFunction;
  this.capacity=capacity;
  this.distanceComparator=new DistanceComparator<E>(origin,distanceFunction);
  this.priorityQueue=new PriorityQueue<E>(this.capacity,java.util.Collections.reverseOrder(this.distanceComparator));
}","public NearestNeighborCollector(final E queryPoint,final DistanceFunction<E> distanceFunction,final int capacity){
  if (capacity < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.queryPoint=queryPoint;
  this.distanceFunction=distanceFunction;
  this.capacity=capacity;
  this.distanceComparator=new DistanceComparator<E>(queryPoint,distanceFunction);
  this.priorityQueue=new PriorityQueue<E>(this.capacity,java.util.Collections.reverseOrder(this.distanceComparator));
}"
13135,"public boolean remove(final E point){
  if (this.points == null) {
    final VPNode<E> childNode=this.getChildNodeForPoint(point);
    final boolean modified=childNode.remove(point);
    if (childNode.size() == 0) {
      final ArrayList<E> collectedPoints=new ArrayList<E>(this.size());
      this.addAllPointsToCollection(collectedPoints);
      this.threshold=this.thresholdSelectionStrategy.selectThreshold(collectedPoints,this.vantagePoint,this.distanceFunction);
      try {
        final int firstIndexPastThreshold=VPNode.partitionPoints(collectedPoints,this.vantagePoint,this.threshold,this.distanceFunction);
        this.closer=new VPNode<E>(collectedPoints.subList(0,firstIndexPastThreshold),this.distanceFunction,this.thresholdSelectionStrategy,this.capacity);
        this.farther=new VPNode<E>(collectedPoints.subList(firstIndexPastThreshold,collectedPoints.size()),this.distanceFunction,this.thresholdSelectionStrategy,this.capacity);
      }
 catch (      PartitionException e) {
        this.closer=null;
        this.farther=null;
        this.points=collectedPoints;
      }
    }
    return modified;
  }
 else {
    return this.points.remove(point);
  }
}","public boolean remove(final E point){
  if (this.points == null) {
    final VPNode<E> childNode=this.getChildNodeForPoint(point);
    final boolean modified=childNode.remove(point);
    if (childNode.size() == 0) {
      this.redistributePointsFromChildNodes();
    }
    return modified;
  }
 else {
    return this.points.remove(point);
  }
}"
13136,"public void collectNearestNeighbors(final E queryPoint,final NearestNeighborCollector<E> collector){
  if (this.points == null) {
    final VPNode<E> firstNodeSearched=this.getChildNodeForPoint(queryPoint);
    firstNodeSearched.collectNearestNeighbors(queryPoint,collector);
    final double distanceFromVantagePointToQueryPoint=this.distanceFunction.getDistance(this.vantagePoint,queryPoint);
    final double distanceFromQueryPointToFarthestPoint=this.distanceFunction.getDistance(queryPoint,collector.getFarthestPoint());
    if (firstNodeSearched == this.closer) {
      final double distanceFromQueryPointToThreshold=this.threshold - distanceFromVantagePointToQueryPoint;
      if (distanceFromQueryPointToFarthestPoint > distanceFromQueryPointToThreshold) {
        this.farther.collectNearestNeighbors(queryPoint,collector);
      }
    }
 else {
      double distanceFromQueryPointToThreshold=distanceFromVantagePointToQueryPoint - this.threshold;
      if (distanceFromQueryPointToThreshold <= distanceFromQueryPointToFarthestPoint) {
        this.closer.collectNearestNeighbors(queryPoint,collector);
      }
    }
  }
 else {
    for (    final E point : this.points) {
      collector.offerPoint(point);
    }
  }
}","public void collectNearestNeighbors(final NearestNeighborCollector<E> collector){
  if (this.points == null) {
    final VPNode<E> firstNodeSearched=this.getChildNodeForPoint(collector.getQueryPoint());
    firstNodeSearched.collectNearestNeighbors(collector);
    final double distanceFromVantagePointToQueryPoint=this.distanceFunction.getDistance(this.vantagePoint,collector.getQueryPoint());
    final double distanceFromQueryPointToFarthestPoint=this.distanceFunction.getDistance(collector.getQueryPoint(),collector.getFarthestPoint());
    if (firstNodeSearched == this.closer) {
      final double distanceFromQueryPointToThreshold=this.threshold - distanceFromVantagePointToQueryPoint;
      if (distanceFromQueryPointToFarthestPoint > distanceFromQueryPointToThreshold) {
        this.farther.collectNearestNeighbors(collector);
      }
    }
 else {
      double distanceFromQueryPointToThreshold=distanceFromVantagePointToQueryPoint - this.threshold;
      if (distanceFromQueryPointToThreshold <= distanceFromQueryPointToFarthestPoint) {
        this.closer.collectNearestNeighbors(collector);
      }
    }
  }
 else {
    for (    final E point : this.points) {
      collector.offerPoint(point);
    }
  }
}"
13137,"public boolean retainAll(final Collection<?> points){
  return this.points == null ? this.closer.retainAll(points) || this.farther.retainAll(points) : this.points.retainAll(points);
}","public boolean retainAll(final Collection<?> points){
  final boolean modified;
  if (this.points == null) {
    final boolean modifiedCloser=this.closer.retainAll(points);
    final boolean modifiedFarther=this.farther.retainAll(points);
    modified=modifiedCloser || modifiedFarther;
    if ((this.closer.size() == 0 || this.farther.size() == 0) && this.size() > 0) {
      this.redistributePointsFromChildNodes();
    }
  }
 else {
    modified=this.points.retainAll(points);
  }
  return modified;
}"
13138,"public VPNode(final List<E> points,final int capacity,final DistanceFunction<E> distanceFunction,final ThresholdSelectionStrategy<E> thresholdSelectionStrategy){
  if (capacity < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (points.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.capacity=capacity;
  this.distanceFunction=distanceFunction;
  this.thresholdSelectionStrategy=thresholdSelectionStrategy;
  if (points.size() > this.capacity) {
    this.vantagePoint=points.get(0);
    this.threshold=this.thresholdSelectionStrategy.selectThreshold(this.vantagePoint,points,this.distanceFunction);
    final int firstIndexPastThreshold;
{
      int i=0;
      int j=points.size() - 1;
      for (; i <= j; i++) {
        if (this.distanceFunction.getDistance(this.vantagePoint,points.get(i)) > this.threshold) {
          for (; j >= i; j--) {
            if (this.distanceFunction.getDistance(this.vantagePoint,points.get(j)) <= this.threshold) {
              Collections.swap(points,i,j--);
              break;
            }
          }
        }
      }
      firstIndexPastThreshold=this.distanceFunction.getDistance(this.vantagePoint,points.get(i - 1)) > this.threshold ? i - 1 : i;
    }
    if (this.distanceFunction.getDistance(this.vantagePoint,points.get(0)) <= this.threshold && this.distanceFunction.getDistance(this.vantagePoint,points.get(points.size() - 1)) > this.threshold) {
      this.closer=new VPNode<E>(points.subList(0,firstIndexPastThreshold),this.capacity,this.distanceFunction,this.thresholdSelectionStrategy);
      this.farther=new VPNode<E>(points.subList(firstIndexPastThreshold,points.size()),this.capacity,this.distanceFunction,this.thresholdSelectionStrategy);
    }
  }
  if (this.closer == null) {
    this.points=new ArrayList<E>(points);
  }
}","public VPNode(final List<E> points,final int capacity,final DistanceFunction<E> distanceFunction,final ThresholdSelectionStrategy<E> thresholdSelectionStrategy){
  if (capacity < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (points.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.capacity=capacity;
  this.distanceFunction=distanceFunction;
  this.thresholdSelectionStrategy=thresholdSelectionStrategy;
  if (points.size() > this.capacity) {
    this.vantagePoint=points.get(new Random().nextInt(points.size()));
    this.threshold=this.thresholdSelectionStrategy.selectThreshold(this.vantagePoint,points,this.distanceFunction);
    final int firstIndexPastThreshold;
{
      int i=0;
      int j=points.size() - 1;
      for (; i <= j; i++) {
        if (this.distanceFunction.getDistance(this.vantagePoint,points.get(i)) > this.threshold) {
          for (; j >= i; j--) {
            if (this.distanceFunction.getDistance(this.vantagePoint,points.get(j)) <= this.threshold) {
              Collections.swap(points,i,j--);
              break;
            }
          }
        }
      }
      firstIndexPastThreshold=this.distanceFunction.getDistance(this.vantagePoint,points.get(i - 1)) > this.threshold ? i - 1 : i;
    }
    if (this.distanceFunction.getDistance(this.vantagePoint,points.get(0)) <= this.threshold && this.distanceFunction.getDistance(this.vantagePoint,points.get(points.size() - 1)) > this.threshold) {
      this.closer=new VPNode<E>(points.subList(0,firstIndexPastThreshold),this.capacity,this.distanceFunction,this.thresholdSelectionStrategy);
      this.farther=new VPNode<E>(points.subList(firstIndexPastThreshold,points.size()),this.capacity,this.distanceFunction,this.thresholdSelectionStrategy);
    }
  }
  if (this.closer == null) {
    this.points=new ArrayList<E>(points);
  }
}"
13139,"/** 
 * Generates a unique signature of a collection of types.
 */
private static String createTypeCollectionId(Collection<? extends Type> types){
  return types.stream().sorted(comparing(CdiSpiHelper::createTypeId)).map(CdiSpiHelper::createTypeId).collect(joining(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","/** 
 * Generates a unique signature of a collection of types.
 */
private static String createTypeCollectionId(Collection<Type> types){
  return types.stream().sorted(comparing(CdiSpiHelper::createTypeId)).map(CdiSpiHelper::createTypeId).collect(joining(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}"
13140,"/** 
 * Return the type of this property. Enhanced getter to enforce supported types
 * @return
 */
public String getType(){
  return isConfidential() && type.equals(""String_Node_Str"") ? ""String_Node_Str"" : type;
}","/** 
 * Return the type of this property. Enhanced getter to enforce supported types
 * @return
 */
public String getType(){
  return isConfidential() && type.equals(""String_Node_Str"") ? ""String_Node_Str"" : type.substring(0,1).toUpperCase() + type.substring(1);
}"
13141,"private void populateVirtualProperties(final Context context,final Request request,final JsonValue content) throws ForbiddenException, InternalServerErrorException {
  for (  JsonPointer key : Collections.unmodifiableSet(getSchema().getFields().keySet())) {
    SchemaField field=getSchema().getField(key);
    if (field.isVirtual() && (field.isReturnedByDefault() || request.getFields().contains(field))) {
      field.onRetrieve(context,content);
    }
  }
}","private void populateVirtualProperties(final Context context,final Request request,final JsonValue content) throws ForbiddenException, InternalServerErrorException {
  for (  JsonPointer key : Collections.unmodifiableSet(getSchema().getFields().keySet())) {
    SchemaField field=getSchema().getField(key);
    if (field.isVirtual() && (field.isReturnedByDefault() || request.getFields().contains(key))) {
      field.onRetrieve(context,content);
    }
  }
}"
13142,"/** 
 * Expands the provided resource represented by a   {@link JsonValue} relationship object.  A read request  will be issued for the resource identified by the ""_ref"" field in the supplied relationship object. A supplied  {@link List} of fields indicates which fields to read and then merge with the relationship object.
 * @param context the {@link Context} of the request
 * @param value the value of the relationship object
 * @param fieldsList the list of fields to read and merge with the relationship object.
 * @throws ResourceException if an error is encountered.
 */
private void expandResource(Context context,final JsonValue value,List<JsonPointer> fieldsList) throws ResourceException {
  if (!value.isNull() && value.get(SchemaField.FIELD_REFERENCE) != null) {
    ReadRequest request=Requests.newReadRequest(value.get(SchemaField.FIELD_REFERENCE).asString());
    request.addField(fieldsList.toArray(new JsonPointer[fieldsList.size()]));
    connectionFactory.getConnection().readAsync(context,request).thenOnResultOrException(new ResultHandler<ResourceResponse>(){
      @Override public void handleResult(      ResourceResponse resource){
        value.asMap().putAll(resource.getContent().asMap());
      }
    }
,new ExceptionHandler<ResourceException>(){
      @Override public void handleException(      ResourceException exception){
        Map<String,Object> valueMap=value.asMap();
        valueMap.put(RelationshipUtil.REFERENCE_ERROR,true);
        valueMap.put(RelationshipUtil.REFERENCE_ERROR_MESSAGE,exception.getMessage());
      }
    }
);
  }
 else {
    logger.warn(""String_Node_Str"");
  }
}","/** 
 * Expands the provided resource represented by a   {@link JsonValue} relationship object.  A read request  will be issued for the resource identified by the ""_ref"" field in the supplied relationship object. A supplied  {@link List} of fields indicates which fields to read and then merge with the relationship object.
 * @param context the {@link Context} of the request
 * @param value the value of the relationship object
 * @param fieldsList the list of fields to read and merge with the relationship object.
 * @throws ResourceException if an error is encountered.
 */
private void expandResource(Context context,final JsonValue value,List<JsonPointer> fieldsList) throws ResourceException {
  if (!value.isNull() && value.get(SchemaField.FIELD_REFERENCE) != null) {
    final Connection connection=ContextUtil.isExternal(context) ? connectionFactory.getExternalConnection() : connectionFactory.getConnection();
    ReadRequest request=Requests.newReadRequest(value.get(SchemaField.FIELD_REFERENCE).asString());
    request.addField(fieldsList.toArray(new JsonPointer[fieldsList.size()]));
    connection.readAsync(context,request).thenOnResultOrException(new ResultHandler<ResourceResponse>(){
      @Override public void handleResult(      ResourceResponse resource){
        value.asMap().putAll(resource.getContent().asMap());
      }
    }
,new ExceptionHandler<ResourceException>(){
      @Override public void handleException(      ResourceException exception){
        Map<String,Object> valueMap=value.asMap();
        valueMap.put(RelationshipUtil.REFERENCE_ERROR,true);
        valueMap.put(RelationshipUtil.REFERENCE_ERROR_MESSAGE,exception.getMessage());
      }
    }
);
  }
 else {
    logger.warn(""String_Node_Str"");
  }
}"
13143,"/** 
 * Constructs a new managed object set.
 * @param scriptRegistry the script registry
 * @param cryptoService the cryptographic service
 * @param syncRoute a reference to the RouteService on ""sync""
 * @param connectionFactory the router connection factory
 * @param config configuration object to use to initialize managed object set.
 * @throws JsonValueException when the configuration is malformed
 * @throws ScriptException when the script configuration is malformed or the script is invalid.
 */
public ManagedObjectSet(final ScriptRegistry scriptRegistry,final CryptoService cryptoService,final AtomicReference<RouteService> syncRoute,ConnectionFactory connectionFactory,JsonValue config) throws JsonValueException, ScriptException {
  this.cryptoService=cryptoService;
  this.syncRoute=syncRoute;
  this.connectionFactory=connectionFactory;
  this.activityLogger=new RouterActivityLogger(connectionFactory);
  name=config.get(""String_Node_Str"").required().asString();
  if (name.trim().isEmpty() || name.indexOf('{') > 0 | name.indexOf('}') > 0) {
    throw new JsonValueException(config.get(""String_Node_Str""),""String_Node_Str"");
  }
  this.managedObjectPath=new ResourcePath(""String_Node_Str"").child(name);
  this.schema=new ManagedObjectSchema(config.get(""String_Node_Str"").expect(Map.class),scriptRegistry,cryptoService);
  for (  JsonPointer relationship : schema.getRelationshipFields()) {
    final SchemaField field=schema.getField(relationship);
    relationshipProviders.put(relationship,RelationshipProvider.newProvider(connectionFactory,managedObjectPath,field,activityLogger,this));
  }
  for (  ScriptHook hook : ScriptHook.values()) {
    if (config.isDefined(hook.name())) {
      scriptHooks.put(hook,scriptRegistry.takeScript(config.get(hook.name())));
    }
  }
  enforcePolicies=Boolean.parseBoolean(IdentityServer.getInstance().getProperty(""String_Node_Str"",""String_Node_Str""));
  logger.debug(""String_Node_Str"",name);
}","/** 
 * Constructs a new managed object set.
 * @param scriptRegistry the script registry
 * @param cryptoService the cryptographic service
 * @param syncRoute a reference to the RouteService on ""sync""
 * @param connectionFactory the router connection factory
 * @param config configuration object to use to initialize managed object set.
 * @throws JsonValueException when the configuration is malformed
 * @throws ScriptException when the script configuration is malformed or the script is invalid.
 */
public ManagedObjectSet(final ScriptRegistry scriptRegistry,final CryptoService cryptoService,final AtomicReference<RouteService> syncRoute,IDMConnectionFactory connectionFactory,JsonValue config) throws JsonValueException, ScriptException {
  this.cryptoService=cryptoService;
  this.syncRoute=syncRoute;
  this.connectionFactory=connectionFactory;
  this.activityLogger=new RouterActivityLogger(connectionFactory);
  name=config.get(""String_Node_Str"").required().asString();
  if (name.trim().isEmpty() || name.indexOf('{') > 0 | name.indexOf('}') > 0) {
    throw new JsonValueException(config.get(""String_Node_Str""),""String_Node_Str"");
  }
  this.managedObjectPath=new ResourcePath(""String_Node_Str"").child(name);
  this.schema=new ManagedObjectSchema(config.get(""String_Node_Str"").expect(Map.class),scriptRegistry,cryptoService);
  for (  JsonPointer relationship : schema.getRelationshipFields()) {
    final SchemaField field=schema.getField(relationship);
    relationshipProviders.put(relationship,RelationshipProvider.newProvider(connectionFactory,managedObjectPath,field,activityLogger,this));
  }
  for (  ScriptHook hook : ScriptHook.values()) {
    if (config.isDefined(hook.name())) {
      scriptHooks.put(hook,scriptRegistry.takeScript(config.get(hook.name())));
    }
  }
  enforcePolicies=Boolean.parseBoolean(IdentityServer.getInstance().getProperty(""String_Node_Str"",""String_Node_Str""));
  logger.debug(""String_Node_Str"",name);
}"
13144,"@Override public Promise<ResourceResponse,ResourceException> createAsync(Context context,CreateRequest request){
  final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
  return super.createAsync(context,request).thenAlways(new Runnable(){
    @Override public void run(){
      measure.end();
    }
  }
);
}","@Override public Promise<ResourceResponse,ResourceException> createAsync(Context context,CreateRequest request){
  final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
  return super.createAsync(context,copyOfCreateRequest(request)).thenAlways(new Runnable(){
    @Override public void run(){
      measure.end();
    }
  }
);
}"
13145,"@Override public ResourceResponse create(Context context,CreateRequest request) throws ResourceException {
  EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
  try {
    return super.create(context,request);
  }
  finally {
    measure.end();
  }
}","@Override public ResourceResponse create(Context context,CreateRequest request) throws ResourceException {
  EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
  try {
    return super.create(context,copyOfCreateRequest(request));
  }
  finally {
    measure.end();
  }
}"
13146,"private ConnectionFactory newWrappedInternalConnectionFactory(final ConnectionFactory connectionFactory){
  return new ConnectionFactory(){
    @Override public void close(){
      connectionFactory.close();
    }
    @Override public Connection getConnection() throws ResourceException {
      return new AbstractConnectionWrapper<Connection>(connectionFactory.getConnection()){
        @Override public ResourceResponse create(        Context context,        CreateRequest request) throws ResourceException {
          EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.create(context,request);
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<ResourceResponse,ResourceException> createAsync(        Context context,        CreateRequest request){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.createAsync(context,request).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
        @Override public ResourceResponse read(        Context context,        ReadRequest request) throws ResourceException {
          EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.read(context,request);
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<ResourceResponse,ResourceException> readAsync(        Context context,        ReadRequest request){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.readAsync(context,request).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
        @Override public ResourceResponse update(        Context context,        UpdateRequest request) throws ResourceException {
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.update(context,request);
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<ResourceResponse,ResourceException> updateAsync(        Context context,        UpdateRequest request){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.updateAsync(context,request).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
        @Override public ResourceResponse delete(        Context context,        DeleteRequest request) throws ResourceException {
          EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.delete(context,request);
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<ResourceResponse,ResourceException> deleteAsync(        Context context,        DeleteRequest request){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.deleteAsync(context,request).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
        @Override public ResourceResponse patch(        Context context,        PatchRequest request) throws ResourceException {
          EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.patch(context,request);
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<ResourceResponse,ResourceException> patchAsync(        Context context,        PatchRequest request){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.patchAsync(context,request).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
        @Override public ActionResponse action(        Context context,        ActionRequest request) throws ResourceException {
          EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.action(context,request);
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<ActionResponse,ResourceException> actionAsync(        Context context,        ActionRequest request){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.actionAsync(context,request).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
        @Override public QueryResponse query(        Context context,        QueryRequest request,        QueryResourceHandler handler) throws ResourceException {
          EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.query(context,request,handler);
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<QueryResponse,ResourceException> queryAsync(        Context context,        QueryRequest request,        QueryResourceHandler handler){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.queryAsync(context,request,handler).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
      }
;
    }
    @Override public Promise<Connection,ResourceException> getConnectionAsync(){
      try {
        return newResultPromise(getConnection());
      }
 catch (      ResourceException e) {
        return e.asPromise();
      }
    }
    /** 
 * @param request the router request
 * @return an event name For monitoring purposes
 */
    private Name getRouterEventName(    Request request){
      RequestType requestType=request.getRequestType();
      String idContext;
      if (RequestType.QUERY.equals(requestType) || RequestType.ACTION.equals(requestType) || RequestType.CREATE.equals(requestType)) {
        idContext=request.getResourcePath();
      }
 else {
        idContext=request.getResourcePathObject().head(request.getResourcePathObject().size() - 1).toString();
      }
      String eventName=new StringBuilder(EVENT_ROUTER_PREFIX).append(idContext).append(""String_Node_Str"").append(requestType.toString().toLowerCase()).toString();
      return Name.get(eventName);
    }
  }
;
}","private ConnectionFactory newWrappedInternalConnectionFactory(final ConnectionFactory connectionFactory){
  return new ConnectionFactory(){
    @Override public void close(){
      connectionFactory.close();
    }
    @Override public Connection getConnection() throws ResourceException {
      return new AbstractConnectionWrapper<Connection>(connectionFactory.getConnection()){
        @Override public ResourceResponse create(        Context context,        CreateRequest request) throws ResourceException {
          EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.create(context,copyOfCreateRequest(request));
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<ResourceResponse,ResourceException> createAsync(        Context context,        CreateRequest request){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.createAsync(context,copyOfCreateRequest(request)).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
        @Override public ResourceResponse read(        Context context,        ReadRequest request) throws ResourceException {
          EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.read(context,request);
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<ResourceResponse,ResourceException> readAsync(        Context context,        ReadRequest request){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.readAsync(context,request).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
        @Override public ResourceResponse update(        Context context,        UpdateRequest request) throws ResourceException {
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.update(context,request);
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<ResourceResponse,ResourceException> updateAsync(        Context context,        UpdateRequest request){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.updateAsync(context,request).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
        @Override public ResourceResponse delete(        Context context,        DeleteRequest request) throws ResourceException {
          EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.delete(context,request);
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<ResourceResponse,ResourceException> deleteAsync(        Context context,        DeleteRequest request){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.deleteAsync(context,request).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
        @Override public ResourceResponse patch(        Context context,        PatchRequest request) throws ResourceException {
          EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.patch(context,request);
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<ResourceResponse,ResourceException> patchAsync(        Context context,        PatchRequest request){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.patchAsync(context,request).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
        @Override public ActionResponse action(        Context context,        ActionRequest request) throws ResourceException {
          EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.action(context,request);
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<ActionResponse,ResourceException> actionAsync(        Context context,        ActionRequest request){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.actionAsync(context,request).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
        @Override public QueryResponse query(        Context context,        QueryRequest request,        QueryResourceHandler handler) throws ResourceException {
          EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          try {
            return super.query(context,request,handler);
          }
  finally {
            measure.end();
          }
        }
        @Override public Promise<QueryResponse,ResourceException> queryAsync(        Context context,        QueryRequest request,        QueryResourceHandler handler){
          final EventEntry measure=Publisher.start(getRouterEventName(request),request,null);
          return super.queryAsync(context,request,handler).thenAlways(new Runnable(){
            @Override public void run(){
              measure.end();
            }
          }
);
        }
      }
;
    }
    @Override public Promise<Connection,ResourceException> getConnectionAsync(){
      try {
        return newResultPromise(getConnection());
      }
 catch (      ResourceException e) {
        return e.asPromise();
      }
    }
    /** 
 * @param request the router request
 * @return an event name For monitoring purposes
 */
    private Name getRouterEventName(    Request request){
      RequestType requestType=request.getRequestType();
      String idContext;
      if (RequestType.QUERY.equals(requestType) || RequestType.ACTION.equals(requestType) || RequestType.CREATE.equals(requestType)) {
        idContext=request.getResourcePath();
      }
 else {
        idContext=request.getResourcePathObject().head(request.getResourcePathObject().size() - 1).toString();
      }
      String eventName=new StringBuilder(EVENT_ROUTER_PREFIX).append(idContext).append(""String_Node_Str"").append(requestType.toString().toLowerCase()).toString();
      return Name.get(eventName);
    }
  }
;
}"
13147,"@Override public Promise<ResourceResponse,ResourceException> updateInstance(final Context context,final String resourceId,final UpdateRequest request){
  logger.debug(""String_Node_Str"",""String_Node_Str"" + name + ""String_Node_Str""+ resourceId+ ""String_Node_Str""+ request.getRevision());
  Context managedContext=new ManagedObjectContext(context);
  try {
    JsonValue _new=decrypt(request.getContent());
    ReadRequest readRequest=Requests.newReadRequest(repoId(resourceId));
    for (    JsonPointer pointer : request.getFields()) {
      readRequest.addField(pointer);
    }
    ResourceResponse readResponse=connectionFactory.getConnection().read(managedContext,readRequest);
    ResourceResponse decryptedResponse=decrypt(readResponse);
    ResourceResponse updatedResponse=update(managedContext,request,resourceId,request.getRevision(),decryptedResponse.getContent(),_new);
    activityLogger.log(managedContext,request,""String_Node_Str"",managedId(readResponse.getId()).toString(),readResponse.getContent(),updatedResponse.getContent(),Status.SUCCESS);
    return prepareResponse(managedContext,updatedResponse,request.getFields()).asPromise();
  }
 catch (  ResourceException e) {
    return e.asPromise();
  }
catch (  Exception e) {
    return new InternalServerErrorException(e.getMessage(),e).asPromise();
  }
}","@Override public Promise<ResourceResponse,ResourceException> updateInstance(final Context context,final String resourceId,final UpdateRequest request){
  logger.debug(""String_Node_Str"",""String_Node_Str"" + name + ""String_Node_Str""+ resourceId+ ""String_Node_Str""+ request.getRevision());
  Context managedContext=new ManagedObjectContext(context);
  try {
    JsonValue _new=decrypt(request.getContent());
    ReadRequest readRequest=Requests.newReadRequest(repoId(resourceId));
    for (    JsonPointer pointer : request.getFields()) {
      if (pointer.equals(new JsonPointer(""String_Node_Str""))) {
        readRequest.addField(""String_Node_Str"");
      }
 else       if (!pointer.equals(SchemaField.FIELD_ALL_RELATIONSHIPS)) {
        readRequest.addField(pointer);
      }
    }
    ResourceResponse readResponse=connectionFactory.getConnection().read(managedContext,readRequest);
    ResourceResponse decryptedResponse=decrypt(readResponse);
    ResourceResponse updatedResponse=update(managedContext,request,resourceId,request.getRevision(),decryptedResponse.getContent(),_new);
    activityLogger.log(managedContext,request,""String_Node_Str"",managedId(readResponse.getId()).toString(),readResponse.getContent(),updatedResponse.getContent(),Status.SUCCESS);
    return prepareResponse(managedContext,updatedResponse,request.getFields()).asPromise();
  }
 catch (  ResourceException e) {
    return e.asPromise();
  }
catch (  Exception e) {
    return new InternalServerErrorException(e.getMessage(),e).asPromise();
  }
}"
13148,"@Override public Promise<ActionResponse,ResourceException> actionInstance(Context context,ActionRequest request){
  try {
    String alias=request.getContent().get(""String_Node_Str"").asString();
    if (ACTION_GENERATE_CERT.equalsIgnoreCase(request.getAction()) || ACTION_GENERATE_CSR.equalsIgnoreCase(request.getAction())) {
      if (alias == null) {
        return new BadRequestException(""String_Node_Str"").asPromise();
      }
      String algorithm=request.getContent().get(""String_Node_Str"").defaultTo(DEFAULT_ALGORITHM).asString();
      String signatureAlgorithm=request.getContent().get(""String_Node_Str"").defaultTo(DEFAULT_SIGNATURE_ALGORITHM).asString();
      int keySize=request.getContent().get(""String_Node_Str"").defaultTo(DEFAULT_KEY_SIZE).asInteger();
      JsonValue result=null;
      if (ACTION_GENERATE_CERT.equalsIgnoreCase(request.getAction())) {
        if (store.getStore().containsAlias(alias)) {
          return new ConflictException(""String_Node_Str"" + alias + ""String_Node_Str"").asPromise();
        }
 else {
          logger.info(""String_Node_Str"",alias);
          String domainName=request.getContent().get(""String_Node_Str"").required().asString();
          String validFrom=request.getContent().get(""String_Node_Str"").asString();
          String validTo=request.getContent().get(""String_Node_Str"").asString();
          Pair<X509Certificate,PrivateKey> pair=generateCertificate(domainName,algorithm,keySize,signatureAlgorithm,validFrom,validTo);
          Certificate cert=pair.getKey();
          PrivateKey key=pair.getValue();
          logger.debug(""String_Node_Str"",alias);
          store.getStore().setEntry(alias,new KeyStore.PrivateKeyEntry(key,new Certificate[]{cert}),new KeyStore.PasswordProtection(store.getPassword().toCharArray()));
          store.store();
          manager.reload();
          saveStore();
          result=returnCertificate(alias,cert);
          if (request.getContent().get(""String_Node_Str"").defaultTo(false).asBoolean()) {
            result.put(""String_Node_Str"",getKeyMap(key));
          }
        }
      }
 else {
        Pair<PKCS10CertificationRequest,PrivateKey> csr=generateCSR(alias,algorithm,signatureAlgorithm,keySize,request.getContent());
        result=returnCertificateRequest(alias,csr.getKey());
        if (request.getContent().get(""String_Node_Str"").defaultTo(false).asBoolean()) {
          result.put(""String_Node_Str"",getKeyMap(csr.getRight()));
        }
      }
      return Responses.newActionResponse(result).asPromise();
    }
 else {
      return new BadRequestException(""String_Node_Str"" + request.getAction()).asPromise();
    }
  }
 catch (  Exception e) {
    return new InternalServerErrorException(e).asPromise();
  }
}","@Override public Promise<ActionResponse,ResourceException> actionInstance(Context context,ActionRequest request){
  try {
    String alias=request.getContent().get(""String_Node_Str"").asString();
    if (ACTION_GENERATE_CERT.equalsIgnoreCase(request.getAction()) || ACTION_GENERATE_CSR.equalsIgnoreCase(request.getAction())) {
      if (alias == null) {
        return new BadRequestException(""String_Node_Str"").asPromise();
      }
      String algorithm=request.getContent().get(""String_Node_Str"").defaultTo(DEFAULT_ALGORITHM).asString();
      String signatureAlgorithm=request.getContent().get(""String_Node_Str"").defaultTo(DEFAULT_SIGNATURE_ALGORITHM).asString();
      int keySize=request.getContent().get(""String_Node_Str"").defaultTo(DEFAULT_KEY_SIZE).asInteger();
      JsonValue result=null;
      if (ACTION_GENERATE_CERT.equalsIgnoreCase(request.getAction())) {
        if (store.getStore().containsAlias(alias)) {
          return new ConflictException(""String_Node_Str"" + alias + ""String_Node_Str"").asPromise();
        }
 else {
          logger.info(""String_Node_Str"",alias);
          String domainName=request.getContent().get(""String_Node_Str"").required().asString();
          String validFrom=request.getContent().get(""String_Node_Str"").asString();
          String validTo=request.getContent().get(""String_Node_Str"").asString();
          Pair<X509Certificate,PrivateKey> pair=generateCertificate(domainName,algorithm,keySize,signatureAlgorithm,validFrom,validTo);
          Certificate cert=pair.getKey();
          PrivateKey key=pair.getValue();
          logger.debug(""String_Node_Str"",alias);
          store.getStore().setEntry(alias,new KeyStore.PrivateKeyEntry(key,new Certificate[]{cert}),new KeyStore.PasswordProtection(store.getPassword().toCharArray()));
          store.store();
          manager.reload();
          saveStore();
          result=returnCertificate(alias,cert);
          if (request.getContent().get(""String_Node_Str"").defaultTo(false).asBoolean()) {
            result.put(""String_Node_Str"",getKeyMap(key));
          }
        }
      }
 else {
        Pair<PKCS10CertificationRequest,PrivateKey> csr=generateCSR(alias,algorithm,signatureAlgorithm,keySize,request.getContent());
        result=returnCertificateRequest(alias,csr.getKey());
        if (request.getContent().get(""String_Node_Str"").defaultTo(false).asBoolean()) {
          result.put(""String_Node_Str"",getKeyMap(csr.getRight()));
        }
      }
      return Responses.newActionResponse(result).asPromise();
    }
 else {
      return new BadRequestException(""String_Node_Str"" + request.getAction()).asPromise();
    }
  }
 catch (  JsonValueException e) {
    return new BadRequestException(e.getMessage(),e).asPromise();
  }
catch (  Exception e) {
    return new InternalServerErrorException(e).asPromise();
  }
}"
13149,"/** 
 * {@inheritDoc} 
 */
@Override public Promise<QueryResponse,ResourceException> queryCollection(final Context context,final QueryRequest request,final QueryResourceHandler handler){
  try {
    if (request.getQueryExpression() != null) {
      return new BadRequestException(HttpUtils.PARAM_QUERY_EXPRESSION + ""String_Node_Str"").asPromise();
    }
    final QueryRequest queryRequest=Requests.newQueryRequest(REPO_RESOURCE_PATH);
    final boolean queryAllIds=ServerConstants.QUERY_ALL_IDS.equals(request.getQueryId());
    if (request.getQueryId() != null) {
      request.setQueryFilter(QueryFilter.<JsonPointer>alwaysTrue());
      if (ServerConstants.QUERY_ALL_IDS.equals(request.getQueryId())) {
        request.addField(FIELD_ID);
      }
 else       if (!""String_Node_Str"".equals(request.getQueryId())) {
        return new BadRequestException(""String_Node_Str"" + HttpUtils.PARAM_QUERY_ID + ""String_Node_Str"").asPromise();
      }
    }
    queryRequest.setQueryFilter(request.getQueryFilter());
    queryRequest.setPageSize(request.getPageSize());
    queryRequest.setPagedResultsOffset(request.getPagedResultsOffset());
    queryRequest.setPagedResultsCookie(request.getPagedResultsCookie());
    queryRequest.setTotalPagedResultsPolicy(request.getTotalPagedResultsPolicy());
    queryRequest.addSortKey(request.getSortKeys().toArray(new SortKey[request.getSortKeys().size()]));
    for (    String key : request.getAdditionalParameters().keySet()) {
      queryRequest.setAdditionalParameter(key,request.getAdditionalParameter(key));
    }
    QueryFilter<JsonPointer> filter;
    ResourcePath resourcePath=firstResourcePath(context,request);
    if (isRevereseRelationship) {
      QueryFilter<JsonPointer> firstFilter=and(equalTo(new JsonPointer(REPO_FIELD_FIRST_ID),resourcePath),equalTo(new JsonPointer(REPO_FIELD_FIRST_PROPERTY_NAME),propertyName));
      QueryFilter<JsonPointer> secondFilter=and(equalTo(new JsonPointer(REPO_FIELD_SECOND_ID),resourcePath),equalTo(new JsonPointer(REPO_FIELD_SECOND_PROPERTY_NAME),propertyName));
      if (request.getQueryFilter() != null) {
        filter=or(and(firstFilter,and(firstFilter,asRelationshipQueryFilter(false,request.getQueryFilter()))),and(secondFilter,and(secondFilter,asRelationshipQueryFilter(true,request.getQueryFilter()))));
      }
 else {
        filter=or(firstFilter,secondFilter);
      }
    }
 else {
      filter=and(equalTo(new JsonPointer(REPO_FIELD_FIRST_ID),resourcePath),equalTo(new JsonPointer(REPO_FIELD_FIRST_PROPERTY_NAME),propertyName));
      if (request.getQueryFilter() != null) {
        filter=and(filter,asRelationshipQueryFilter(isRevereseRelationship,request.getQueryFilter()));
      }
    }
    queryRequest.setQueryFilter(filter);
    final Promise<QueryResponse,ResourceException> response=getConnection().queryAsync(context,queryRequest,new QueryResourceHandler(){
      @Override public boolean handleResource(      ResourceResponse resource){
        ResourceResponse filteredResourceResponse=formatResponseNoException(context,request).apply(resource);
        if (queryAllIds) {
          filteredResourceResponse.addField(FIELD_ID);
          return handler.handleResource(filteredResourceResponse);
        }
        try {
          filteredResourceResponse=expandFields(context,request,filteredResourceResponse).getOrThrow();
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"" + e.getMessage(),e);
        }
        return handler.handleResource(filteredResourceResponse);
      }
    }
);
    if (context.containsContext(ManagedObjectContext.class)) {
      return response;
    }
    QueryResponse result=response.getOrThrow();
    final ResourceResponse value=getManagedObject(context);
    activityLogger.log(context,request,""String_Node_Str"",getManagedObjectPath(context),null,value.getContent(),Status.SUCCESS);
    return newResultPromise(result);
  }
 catch (  ResourceException e) {
    return e.asPromise();
  }
catch (  Exception e) {
    return new InternalServerErrorException(e.getMessage(),e).asPromise();
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public Promise<QueryResponse,ResourceException> queryCollection(final Context context,final QueryRequest request,final QueryResourceHandler handler){
  try {
    if (request.getQueryExpression() != null) {
      return new BadRequestException(HttpUtils.PARAM_QUERY_EXPRESSION + ""String_Node_Str"").asPromise();
    }
    final QueryRequest queryRequest=Requests.newQueryRequest(REPO_RESOURCE_PATH);
    final boolean queryAllIds=ServerConstants.QUERY_ALL_IDS.equals(request.getQueryId());
    if (request.getQueryId() != null) {
      request.setQueryFilter(QueryFilter.<JsonPointer>alwaysTrue());
      if (ServerConstants.QUERY_ALL_IDS.equals(request.getQueryId())) {
        request.addField(FIELD_ID);
      }
 else       if (!""String_Node_Str"".equals(request.getQueryId())) {
        return new BadRequestException(""String_Node_Str"" + HttpUtils.PARAM_QUERY_ID + ""String_Node_Str"").asPromise();
      }
    }
    queryRequest.setQueryFilter(request.getQueryFilter());
    queryRequest.setPageSize(request.getPageSize());
    queryRequest.setPagedResultsOffset(request.getPagedResultsOffset());
    queryRequest.setPagedResultsCookie(request.getPagedResultsCookie());
    queryRequest.setTotalPagedResultsPolicy(request.getTotalPagedResultsPolicy());
    queryRequest.addSortKey(request.getSortKeys().toArray(new SortKey[request.getSortKeys().size()]));
    for (    String key : request.getAdditionalParameters().keySet()) {
      queryRequest.setAdditionalParameter(key,request.getAdditionalParameter(key));
    }
    QueryFilter<JsonPointer> filter;
    ResourcePath resourcePath=firstResourcePath(context,request);
    if (isReverseRelationship) {
      QueryFilter<JsonPointer> firstFilter=and(equalTo(new JsonPointer(REPO_FIELD_FIRST_ID),resourcePath),equalTo(new JsonPointer(REPO_FIELD_FIRST_PROPERTY_NAME),propertyName));
      QueryFilter<JsonPointer> secondFilter=and(equalTo(new JsonPointer(REPO_FIELD_SECOND_ID),resourcePath),equalTo(new JsonPointer(REPO_FIELD_SECOND_PROPERTY_NAME),propertyName));
      if (request.getQueryFilter() != null) {
        filter=or(and(firstFilter,and(firstFilter,asRelationshipQueryFilter(false,request.getQueryFilter()))),and(secondFilter,and(secondFilter,asRelationshipQueryFilter(true,request.getQueryFilter()))));
      }
 else {
        filter=or(firstFilter,secondFilter);
      }
    }
 else {
      filter=and(equalTo(new JsonPointer(REPO_FIELD_FIRST_ID),resourcePath),equalTo(new JsonPointer(REPO_FIELD_FIRST_PROPERTY_NAME),propertyName));
      if (request.getQueryFilter() != null) {
        filter=and(filter,asRelationshipQueryFilter(isReverseRelationship,request.getQueryFilter()));
      }
    }
    queryRequest.setQueryFilter(filter);
    final Promise<QueryResponse,ResourceException> response=getConnection().queryAsync(context,queryRequest,new QueryResourceHandler(){
      @Override public boolean handleResource(      ResourceResponse resource){
        ResourceResponse filteredResourceResponse=formatResponseNoException(context,request).apply(resource);
        if (queryAllIds) {
          filteredResourceResponse.addField(FIELD_ID);
          return handler.handleResource(filteredResourceResponse);
        }
        try {
          filteredResourceResponse=expandFields(context,request,filteredResourceResponse).getOrThrow();
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"" + e.getMessage(),e);
        }
        return handler.handleResource(filteredResourceResponse);
      }
    }
);
    if (context.containsContext(ManagedObjectContext.class)) {
      return response;
    }
    QueryResponse result=response.getOrThrow();
    final ResourceResponse value=getManagedObject(context);
    activityLogger.log(context,request,""String_Node_Str"",getManagedObjectPath(context),null,value.getContent(),Status.SUCCESS);
    return newResultPromise(result);
  }
 catch (  ResourceException e) {
    return e.asPromise();
  }
catch (  Exception e) {
    return new InternalServerErrorException(e.getMessage(),e).asPromise();
  }
}"
13150,"/** 
 * {@inheritDoc} 
 */
@Override public Promise<JsonValue,ResourceException> clear(final Context context,final String resourceId){
  return getRelationshipValueForResource(context,resourceId).thenAsync(new AsyncFunction<JsonValue,JsonValue,ResourceException>(){
    @Override public Promise<JsonValue,ResourceException> apply(    JsonValue existing) throws ResourceException {
      final List<Promise<ResourceResponse,ResourceException>> deleted=new ArrayList<>();
      for (      JsonValue relationship : existing) {
        final String id=relationship.get(FIELD_ID).asString();
        deleted.add(deleteInstance(context,id,Requests.newDeleteRequest(""String_Node_Str"")));
      }
      return when(deleted).then(new Function<List<ResourceResponse>,JsonValue,ResourceException>(){
        @Override public JsonValue apply(        List<ResourceResponse> resourceResponses) throws ResourceException {
          final JsonValue deleted=json(array());
          for (          ResourceResponse resourceResponse : resourceResponses) {
            deleted.add(resourceResponse.getContent());
          }
          return deleted;
        }
      }
);
    }
  }
);
}","/** 
 * {@inheritDoc} 
 */
@Override public Promise<JsonValue,ResourceException> clear(final Context context,final String resourceId){
  return getRelationshipValueForResource(context,resourceId).thenAsync(new AsyncFunction<JsonValue,JsonValue,ResourceException>(){
    @Override public Promise<JsonValue,ResourceException> apply(    JsonValue existing) throws ResourceException {
      final List<Promise<ResourceResponse,ResourceException>> deleted=new ArrayList<>();
      for (      JsonValue relationship : existing) {
        final String id=relationship.get(FIELD_ID).asString();
        DeleteRequest deleteRequest=Requests.newDeleteRequest(""String_Node_Str"");
        deleteRequest.setAdditionalParameter(PARAM_MANAGED_OBJECT_ID,resourceId);
        deleted.add(deleteInstance(context,id,deleteRequest));
      }
      return when(deleted).then(new Function<List<ResourceResponse>,JsonValue,ResourceException>(){
        @Override public JsonValue apply(        List<ResourceResponse> resourceResponses) throws ResourceException {
          final JsonValue deleted=json(array());
          for (          ResourceResponse resourceResponse : resourceResponses) {
            deleted.add(resourceResponse.getContent());
          }
          return deleted;
        }
      }
);
    }
  }
);
}"
13151,"/** 
 * Clear all relationships not present in   {@code relationshipsToKeep}.
 * @param context The current context.
 * @param resourceId The resource whose relationships we wish to clear
 * @param relationshipsToKeep Set of relationship ids that should not be deleted
 * @return A promised JsonValue array of delete responses
 */
private Promise<JsonValue,ResourceException> clearNotIn(final Context context,final String resourceId,final Set<String> relationshipsToKeep){
  return getRelationshipValueForResource(context,resourceId).thenAsync(new AsyncFunction<JsonValue,JsonValue,ResourceException>(){
    @Override public Promise<JsonValue,ResourceException> apply(    JsonValue existingRelationships) throws ResourceException {
      final List<Promise<ResourceResponse,ResourceException>> promises=new ArrayList<>();
      for (      JsonValue relationship : existingRelationships) {
        final String id=relationship.get(FIELD_ID).asString();
        if (!relationshipsToKeep.contains(id)) {
          final DeleteRequest deleteRequest=Requests.newDeleteRequest(""String_Node_Str"",id);
          promises.add(deleteInstance(context,id,deleteRequest));
        }
      }
      return when(promises).then(new Function<List<ResourceResponse>,JsonValue,ResourceException>(){
        @Override public JsonValue apply(        List<ResourceResponse> resourceResponses) throws ResourceException {
          final JsonValue result=json(array());
          for (          ResourceResponse resourceResponse : resourceResponses) {
            result.add(resourceResponse.getContent());
          }
          return result;
        }
      }
);
    }
  }
);
}","/** 
 * Clear all relationships not present in   {@code relationshipsToKeep}.
 * @param context The current context.
 * @param resourceId The resource whose relationships we wish to clear
 * @param relationshipsToKeep Set of relationship ids that should not be deleted
 * @return A promised JsonValue array of delete responses
 */
private Promise<JsonValue,ResourceException> clearNotIn(final Context context,final String resourceId,final Set<String> relationshipsToKeep){
  return getRelationshipValueForResource(context,resourceId).thenAsync(new AsyncFunction<JsonValue,JsonValue,ResourceException>(){
    @Override public Promise<JsonValue,ResourceException> apply(    JsonValue existingRelationships) throws ResourceException {
      final List<Promise<ResourceResponse,ResourceException>> promises=new ArrayList<>();
      for (      JsonValue relationship : existingRelationships) {
        final String id=relationship.get(FIELD_ID).asString();
        if (!relationshipsToKeep.contains(id)) {
          final DeleteRequest deleteRequest=Requests.newDeleteRequest(""String_Node_Str"",id);
          deleteRequest.setAdditionalParameter(PARAM_MANAGED_OBJECT_ID,resourceId);
          promises.add(deleteInstance(context,id,deleteRequest));
        }
      }
      return when(promises).then(new Function<List<ResourceResponse>,JsonValue,ResourceException>(){
        @Override public JsonValue apply(        List<ResourceResponse> resourceResponses) throws ResourceException {
          final JsonValue result=json(array());
          for (          ResourceResponse resourceResponse : resourceResponses) {
            result.add(resourceResponse.getContent());
          }
          return result;
        }
      }
);
    }
  }
);
}"
13152,"/** 
 * Reads and returns the managed object associated with the specified context.
 * @param context the {@link Context} object.
 * @return the managed object.
 * @throws ResourceException if an error was encountered while reading the managed object.
 */
protected ResourceResponse getManagedObject(Context context) throws ResourceException {
  String managedObjectPath=resourcePath.child(getManagedObjectId(context)).toString();
  return getConnection().read(context,Requests.newReadRequest(managedObjectPath));
}","/** 
 * Reads and returns the managed object associated with the specified context.
 * @param context the {@link Context} object.
 * @return the managed object.
 * @throws ResourceException if an error was encountered while reading the managed object.
 */
protected ResourceResponse getManagedObject(Context context) throws ResourceException {
  String managedObjectPath=resourceContainer.child(getManagedObjectId(context)).toString();
  return getConnection().read(context,Requests.newReadRequest(managedObjectPath));
}"
13153,"/** 
 * Create a new relationship set for the given managed resource
 * @param connectionFactory Connection factory used to access the repository
 * @param resourcePath Name of the resource we are handling relationships for eg. managed/user
 * @param propertyName Name of property on first object represents the relationship
 * @param isReverse Whether or not this relationship is isReverse
 */
protected RelationshipProvider(final ConnectionFactory connectionFactory,final ResourcePath resourcePath,final JsonPointer propertyName,final JsonPointer reversePropertyName,final boolean isReverse,ActivityLogger activityLogger,final ManagedObjectSyncService managedObjectSyncService){
  this.connectionFactory=connectionFactory;
  this.resourcePath=resourcePath;
  this.propertyName=propertyName;
  this.reversePropertyName=reversePropertyName;
  this.isRevereseRelationship=isReverse;
  this.activityLogger=activityLogger;
  this.managedObjectSyncService=managedObjectSyncService;
}","/** 
 * Create a new relationship set for the given managed resource
 * @param connectionFactory Connection factory used to access the repository
 * @param resourcePath Name of the resource we are handling relationships for eg. managed/user
 * @param propertyName Name of property on first object represents the relationship
 * @param isReverse Whether or not this relationship is isReverse
 */
protected RelationshipProvider(final ConnectionFactory connectionFactory,final ResourcePath resourcePath,final JsonPointer propertyName,final JsonPointer reversePropertyName,final boolean isReverse,ActivityLogger activityLogger,final ManagedObjectSyncService managedObjectSyncService){
  this.connectionFactory=connectionFactory;
  this.resourceContainer=resourcePath;
  this.propertyName=propertyName;
  this.reversePropertyName=reversePropertyName;
  this.isReverseRelationship=isReverse;
  this.activityLogger=activityLogger;
  this.managedObjectSyncService=managedObjectSyncService;
}"
13154,"/** 
 * Returns the managed object's full path corresponding to the passed in   {@link Context}.
 * @param context the {@link Context} object.
 * @return a String representing the managed object's ID.
 */
protected String getManagedObjectPath(Context context){
  return resourcePath.child(getManagedObjectId(context)).toString();
}","/** 
 * Returns the managed object's full path corresponding to the passed in   {@link Context}.
 * @param context the {@link Context} object.
 * @return a String representing the managed object's ID.
 */
protected String getManagedObjectPath(Context context){
  return resourceContainer.child(getManagedObjectId(context)).toString();
}"
13155,"/** 
 * Convert the given incoming request object to repo format. This converts _ref fields to secondId and populates first* fields.
 * @param firstResourcePath The path of the first object in a relationship instance
 * @param object A {@link JsonValue} object from a resource response or incoming request to be converted forstorage in the repo
 * @return A new JsonValue containing the converted object in a format accepted by the repo
 * @see #getFormatResponseNoException()
 */
protected JsonValue convertToRepoObject(final ResourcePath firstResourcePath,final JsonValue object){
  final JsonValue properties=object.get(FIELD_PROPERTIES);
  if (properties != null) {
    properties.remove(FIELD_CONTENT_ID);
    properties.remove(FIELD_CONTENT_REVISION);
  }
  if (isRevereseRelationship) {
    if (firstResourcePath.toString().compareTo(object.get(FIELD_REFERENCE).asString()) < 0) {
      return json(object(field(REPO_FIELD_FIRST_ID,firstResourcePath.toString()),field(REPO_FIELD_FIRST_PROPERTY_NAME,propertyName.toString()),field(REPO_FIELD_SECOND_ID,object.get(FIELD_REFERENCE).asString()),field(REPO_FIELD_SECOND_PROPERTY_NAME,reversePropertyName.toString()),field(REPO_FIELD_PROPERTIES,properties == null ? null : properties.asMap())));
    }
 else {
      return json(object(field(REPO_FIELD_FIRST_ID,object.get(FIELD_REFERENCE).asString()),field(REPO_FIELD_FIRST_PROPERTY_NAME,reversePropertyName.toString()),field(REPO_FIELD_SECOND_ID,firstResourcePath.toString()),field(REPO_FIELD_SECOND_PROPERTY_NAME,propertyName.toString()),field(REPO_FIELD_PROPERTIES,properties == null ? null : properties.asMap())));
    }
  }
 else {
    return json(object(field(REPO_FIELD_FIRST_ID,firstResourcePath.toString()),field(REPO_FIELD_FIRST_PROPERTY_NAME,propertyName.toString()),field(REPO_FIELD_SECOND_ID,object.get(FIELD_REFERENCE).asString()),field(REPO_FIELD_SECOND_PROPERTY_NAME,null),field(REPO_FIELD_PROPERTIES,properties == null ? null : properties.asMap())));
  }
}","/** 
 * Convert the given incoming request object to repo format. This converts _ref fields to secondId and populates first* fields.
 * @param firstResourcePath The path of the first object in a relationship instance
 * @param object A {@link JsonValue} object from a resource response or incoming request to be converted forstorage in the repo
 * @return A new JsonValue containing the converted object in a format accepted by the repo
 * @see #getFormatResponseNoException()
 */
protected JsonValue convertToRepoObject(final ResourcePath firstResourcePath,final JsonValue object){
  final JsonValue properties=object.get(FIELD_PROPERTIES);
  if (properties != null) {
    properties.remove(FIELD_CONTENT_ID);
    properties.remove(FIELD_CONTENT_REVISION);
  }
  if (isReverseRelationship) {
    if (firstResourcePath.toString().compareTo(object.get(FIELD_REFERENCE).asString()) < 0) {
      return json(object(field(REPO_FIELD_FIRST_ID,firstResourcePath.toString()),field(REPO_FIELD_FIRST_PROPERTY_NAME,propertyName.toString()),field(REPO_FIELD_SECOND_ID,object.get(FIELD_REFERENCE).asString()),field(REPO_FIELD_SECOND_PROPERTY_NAME,reversePropertyName.toString()),field(REPO_FIELD_PROPERTIES,properties == null ? null : properties.asMap())));
    }
 else {
      return json(object(field(REPO_FIELD_FIRST_ID,object.get(FIELD_REFERENCE).asString()),field(REPO_FIELD_FIRST_PROPERTY_NAME,reversePropertyName.toString()),field(REPO_FIELD_SECOND_ID,firstResourcePath.toString()),field(REPO_FIELD_SECOND_PROPERTY_NAME,propertyName.toString()),field(REPO_FIELD_PROPERTIES,properties == null ? null : properties.asMap())));
    }
  }
 else {
    return json(object(field(REPO_FIELD_FIRST_ID,firstResourcePath.toString()),field(REPO_FIELD_FIRST_PROPERTY_NAME,propertyName.toString()),field(REPO_FIELD_SECOND_ID,object.get(FIELD_REFERENCE).asString()),field(REPO_FIELD_SECOND_PROPERTY_NAME,null),field(REPO_FIELD_PROPERTIES,properties == null ? null : properties.asMap())));
  }
}"
13156,"/** 
 * Returns the path of the first resource in this relationship using the firstId parameter from either the URI or  the Request. If firstId is not found in the URI context then the request parameter is used.
 * @param context Context containing a {@link UriRouterContext} to check for template variables
 * @param request Request containing a fall-back firstId parameter
 * @see #resourcePath
 * @return The resource path of the first resource as a child of resourcePath
 */
protected final ResourcePath firstResourcePath(final Context context,final Request request) throws BadRequestException {
  final String uriFirstId=context.asContext(UriRouterContext.class).getUriTemplateVariables().get(PARAM_MANAGED_OBJECT_ID);
  final String firstId=uriFirstId != null ? uriFirstId : request.getAdditionalParameter(PARAM_MANAGED_OBJECT_ID);
  if (StringUtils.isNotBlank(firstId)) {
    return resourcePath.child(firstId);
  }
 else {
    throw new BadRequestException(""String_Node_Str"" + PARAM_MANAGED_OBJECT_ID + ""String_Node_Str""+ PARAM_MANAGED_OBJECT_ID+ ""String_Node_Str"");
  }
}","/** 
 * Returns the path of the first resource in this relationship using the firstId parameter from either the URI or  the Request. If firstId is not found in the URI context then the request parameter is used.
 * @param context Context containing a {@link UriRouterContext} to check for template variables
 * @param request Request containing a fall-back firstId parameter
 * @see #resourceContainer
 * @return The resource path of the first resource as a child of resourcePath
 */
protected final ResourcePath firstResourcePath(final Context context,final Request request) throws BadRequestException {
  final String uriFirstId=context.asContext(UriRouterContext.class).getUriTemplateVariables().get(PARAM_MANAGED_OBJECT_ID);
  final String firstId=uriFirstId != null ? uriFirstId : request.getAdditionalParameter(PARAM_MANAGED_OBJECT_ID);
  if (StringUtils.isNotBlank(firstId)) {
    return resourceContainer.child(firstId);
  }
 else {
    throw new BadRequestException(""String_Node_Str"" + PARAM_MANAGED_OBJECT_ID + ""String_Node_Str""+ PARAM_MANAGED_OBJECT_ID+ ""String_Node_Str"");
  }
}"
13157,"/** 
 * Returns a Function to format a resource from the repository to that expected by the provider consumer. First  object properties are removed and   {@code secondId} (or {@code firstId} if {@link #isRevereseRelationship}) will be converted  to   {@code _ref}This will convert repo resources in the format of: <pre> { ""_id"": ""someId"", ""_rev"": ""someRev"", ""firstId"": ""/managed/object/uuid"", ""firstPropertyName"": ""roles"", ""secondId"": ""/managed/roles/uuid"" ""properties"": { ... } } </pre> To a provider response format of: <pre> { ""_ref"": ""/managed/roles/uuid"" ""_refProperties"": { ""_id"": ""someId"", ""_rev"": ""someRev"", ... } } </pre>
 */
protected Function<ResourceResponse,ResourceResponse,NeverThrowsException> formatResponseNoException(final Context context,final Request request){
  return new Function<ResourceResponse,ResourceResponse,NeverThrowsException>(){
    public String resourcePath=getResourcePath(context,request).toString();
    @Override public ResourceResponse apply(    final ResourceResponse raw){
      final JsonValue formatted=json(object());
      final Map<String,Object> properties=new LinkedHashMap<>();
      final Map<String,Object> repoProperties=raw.getContent().get(REPO_FIELD_PROPERTIES).asMap();
      final String ref;
      if (isRevereseRelationship && raw.getContent().get(REPO_FIELD_FIRST_ID).asString().equals(resourcePath)) {
        ref=raw.getContent().get(REPO_FIELD_SECOND_ID).asString();
      }
 else {
        ref=raw.getContent().get(REPO_FIELD_FIRST_ID).asString();
      }
      if (repoProperties != null) {
        properties.putAll(repoProperties);
      }
      properties.put(FIELD_CONTENT_ID,raw.getId());
      properties.put(FIELD_CONTENT_REVISION,raw.getRevision());
      formatted.put(SchemaField.FIELD_REFERENCE,ref);
      formatted.put(SchemaField.FIELD_PROPERTIES,properties);
      return newResourceResponse(null,null,formatted);
    }
  }
;
}","/** 
 * Returns a Function to format a resource from the repository to that expected by the provider consumer. First  object properties are removed and   {@code secondId} (or {@code firstId} if {@link #isReverseRelationship}) will be converted  to   {@code _ref}This will convert repo resources in the format of: <pre> { ""_id"": ""someId"", ""_rev"": ""someRev"", ""firstId"": ""/managed/object/uuid"", ""firstPropertyName"": ""roles"", ""secondId"": ""/managed/roles/uuid"" ""properties"": { ... } } </pre> To a provider response format of: <pre> { ""_ref"": ""/managed/roles/uuid"" ""_refProperties"": { ""_id"": ""someId"", ""_rev"": ""someRev"", ... } } </pre>
 */
protected Function<ResourceResponse,ResourceResponse,NeverThrowsException> formatResponseNoException(final Context context,final Request request){
  return new Function<ResourceResponse,ResourceResponse,NeverThrowsException>(){
    public String resourceFullPath=getResourceFullPath(context,request).toString();
    @Override public ResourceResponse apply(    final ResourceResponse raw){
      final JsonValue formatted=json(object());
      final Map<String,Object> properties=new LinkedHashMap<>();
      final Map<String,Object> repoProperties=raw.getContent().get(REPO_FIELD_PROPERTIES).asMap();
      final String ref;
      if (isReverseRelationship && !raw.getContent().get(REPO_FIELD_FIRST_ID).asString().equals(resourceFullPath)) {
        ref=raw.getContent().get(REPO_FIELD_FIRST_ID).asString();
      }
 else {
        ref=raw.getContent().get(REPO_FIELD_SECOND_ID).asString();
      }
      if (repoProperties != null) {
        properties.putAll(repoProperties);
      }
      properties.put(FIELD_CONTENT_ID,raw.getId());
      properties.put(FIELD_CONTENT_REVISION,raw.getRevision());
      formatted.put(SchemaField.FIELD_REFERENCE,ref);
      formatted.put(SchemaField.FIELD_PROPERTIES,properties);
      return newResourceResponse(null,null,formatted);
    }
  }
;
}"
13158,"/** 
 * Queries relationships, returning the relationship associated with this providers resource path and the specified  relationship field.
 * @param context The current context
 * @param managedObjectId The id of the managed object to find relationships associated with
 * @return
 */
private Promise<ResourceResponse,ResourceException> queryRelationship(final Context context,final String managedObjectId){
  try {
    final QueryRequest queryRequest=Requests.newQueryRequest(REPO_RESOURCE_PATH);
    final List<ResourceResponse> relationships=new ArrayList<>();
    queryRequest.setQueryFilter(QueryFilter.and(QueryFilter.equalTo(new JsonPointer(isRevereseRelationship ? REPO_FIELD_SECOND_ID : REPO_FIELD_FIRST_ID),resourcePath.child(managedObjectId)),QueryFilter.equalTo(new JsonPointer(REPO_FIELD_FIRST_PROPERTY_NAME),propertyName)));
    connectionFactory.getConnection().query(context,queryRequest,relationships);
    if (relationships.isEmpty()) {
      return new NotFoundException().asPromise();
    }
 else {
      return newResultPromise(formatResponse(context,null).apply(relationships.get(0)));
    }
  }
 catch (  ResourceException e) {
    return e.asPromise();
  }
}","/** 
 * Queries relationships, returning the relationship associated with this providers resource path and the specified  relationship field.
 * @param context The current context
 * @param managedObjectId The id of the managed object to find relationships associated with
 * @return
 */
private Promise<ResourceResponse,ResourceException> queryRelationship(final Context context,final String managedObjectId){
  try {
    final QueryRequest queryRequest=Requests.newQueryRequest(REPO_RESOURCE_PATH);
    final List<ResourceResponse> relationships=new ArrayList<>();
    queryRequest.setQueryFilter(QueryFilter.and(QueryFilter.equalTo(new JsonPointer(isReverseRelationship ? REPO_FIELD_SECOND_ID : REPO_FIELD_FIRST_ID),resourceContainer.child(managedObjectId)),QueryFilter.equalTo(new JsonPointer(REPO_FIELD_FIRST_PROPERTY_NAME),propertyName)));
    connectionFactory.getConnection().query(context,queryRequest,relationships);
    if (relationships.isEmpty()) {
      return new NotFoundException().asPromise();
    }
 else {
      return newResultPromise(formatResponse(context,null).apply(relationships.get(0)));
    }
  }
 catch (  ResourceException e) {
    return e.asPromise();
  }
}"
13159,"/** 
 * Patches the given resource and will also remove private properties if it is an external call based upon context.
 * @param context
 * @param request
 * @param resource The resource to be patched
 * @param revision
 * @param patchOperations
 * @return The patched ResourceResponse with private properties omitted if called externally.
 * @throws ResourceException
 */
private ResourceResponse patchResource(Context context,Request request,ResourceResponse resource,String revision,List<PatchOperation> patchOperations) throws ResourceException {
  boolean forceUpdate=(revision == null);
  boolean retry=forceUpdate;
  String rev=revision;
  do {
    logger.debug(""String_Node_Str"",name,request.getResourcePath());
    try {
      JsonValue decrypted=decrypt(resource.getContent());
      if (revision == null) {
        rev=decrypted.get(""String_Node_Str"").asString();
      }
      final JsonValue relationships=fetchRelationshipFields(context,resource.getId());
      decrypted.asMap().putAll(relationships.asMap());
      JsonValue newValue=decrypted.copy();
      boolean modified=JsonValuePatch.apply(newValue,patchOperations);
      if (!modified) {
        return null;
      }
      if (enforcePolicies) {
        JsonValue propertiesToValidate=json(object());
        for (        PatchOperation operation : patchOperations) {
          JsonPointer field=operation.getField();
          propertiesToValidate.put(field,newValue.get(field));
        }
        ActionRequest policyAction=Requests.newActionRequest(ResourcePath.valueOf(""String_Node_Str"").concat(managedId(resource.getId())).toString(),""String_Node_Str"").setContent(propertiesToValidate);
        if (ContextUtil.isExternal(context)) {
          policyAction.setAdditionalParameter(""String_Node_Str"",""String_Node_Str"");
        }
        JsonValue result=connectionFactory.getConnection().action(context,policyAction).getJsonContent();
        if (!result.isNull() && !result.get(""String_Node_Str"").asBoolean()) {
          logger.debug(""String_Node_Str"",result);
          throw new ForbiddenException(""String_Node_Str"").setDetail(result);
        }
      }
      ResourceResponse patchedResource=update(context,request,resource.getId(),rev,resource.getContent(),newValue);
      activityLogger.log(context,request,""String_Node_Str"",managedId(patchedResource.getId()).toString(),resource.getContent(),patchedResource.getContent(),Status.SUCCESS);
      retry=false;
      logger.debug(""String_Node_Str"");
      return prepareResponse(context,patchedResource,request.getFields());
    }
 catch (    PreconditionFailedException e) {
      if (forceUpdate) {
        logger.debug(""String_Node_Str"");
      }
 else {
        throw e;
      }
    }
catch (    ResourceException e) {
      throw e;
    }
catch (    Exception e) {
      throw new InternalServerErrorException(e.getMessage(),e);
    }
  }
 while (retry);
  return null;
}","/** 
 * Patches the given resource and will also remove private properties if it is an external call based upon context.
 * @param context
 * @param request
 * @param resource The resource to be patched
 * @param revision
 * @param patchOperations
 * @return The patched ResourceResponse with private properties omitted if called externally.
 * @throws ResourceException
 */
private ResourceResponse patchResource(Context context,Request request,ResourceResponse resource,String revision,List<PatchOperation> patchOperations) throws ResourceException {
  boolean forceUpdate=(revision == null);
  boolean retry=forceUpdate;
  String rev=revision;
  do {
    logger.debug(""String_Node_Str"",name,request.getResourcePath());
    try {
      JsonValue decrypted=decrypt(resource.getContent());
      if (revision == null) {
        rev=decrypted.get(""String_Node_Str"").asString();
      }
      final JsonValue relationships=fetchRelationshipFields(context,resource.getId());
      decrypted.asMap().putAll(relationships.asMap());
      JsonValue newValue=decrypted.copy();
      boolean modified=JsonValuePatch.apply(newValue,patchOperations);
      if (!modified) {
        return null;
      }
      if (enforcePolicies) {
        JsonValue propertiesToValidate=json(object());
        for (        PatchOperation operation : patchOperations) {
          JsonPointer field=operation.getField();
          propertiesToValidate.putPermissive(field,newValue.get(field));
        }
        ActionRequest policyAction=Requests.newActionRequest(ResourcePath.valueOf(""String_Node_Str"").concat(managedId(resource.getId())).toString(),""String_Node_Str"").setContent(propertiesToValidate);
        if (ContextUtil.isExternal(context)) {
          policyAction.setAdditionalParameter(""String_Node_Str"",""String_Node_Str"");
        }
        JsonValue result=connectionFactory.getConnection().action(context,policyAction).getJsonContent();
        if (!result.isNull() && !result.get(""String_Node_Str"").asBoolean()) {
          logger.debug(""String_Node_Str"",result);
          throw new ForbiddenException(""String_Node_Str"").setDetail(result);
        }
      }
      ResourceResponse patchedResource=update(context,request,resource.getId(),rev,resource.getContent(),newValue);
      activityLogger.log(context,request,""String_Node_Str"",managedId(patchedResource.getId()).toString(),resource.getContent(),patchedResource.getContent(),Status.SUCCESS);
      retry=false;
      logger.debug(""String_Node_Str"");
      return prepareResponse(context,patchedResource,request.getFields());
    }
 catch (    PreconditionFailedException e) {
      if (forceUpdate) {
        logger.debug(""String_Node_Str"");
      }
 else {
        throw e;
      }
    }
catch (    ResourceException e) {
      throw e;
    }
catch (    Exception e) {
      throw new InternalServerErrorException(e.getMessage(),e);
    }
  }
 while (retry);
  return null;
}"
13160,"/** 
 * Read and process Workflow configuration file
 * @param compContext
 */
private void readConfiguration(ComponentContext compContext){
  JsonValue config=enhancedConfig.getConfigurationAsJson(compContext);
  if (!config.isNull()) {
    enabled=config.get(CONFIG_ENABLED).defaultTo(true).asBoolean();
    location=config.get(CONFIG_LOCATION).defaultTo(EngineLocation.embedded.name()).asEnum(EngineLocation.class);
    JsonValue connectionConfig=config.get(CONFIG_CONNECTION);
    jndiName=connectionConfig.get(CONFIG_JNDI_NAME).asString();
    JsonValue mailconfig=config.get(CONFIG_MAIL);
    if (!mailconfig.isNull()) {
      mailhost=mailconfig.get(new JsonPointer(CONFIG_MAIL_HOST)).asString();
      mailport=mailconfig.get(new JsonPointer(CONFIG_MAIL_PORT)).asInteger();
      mailusername=mailconfig.get(new JsonPointer(CONFIG_MAIL_USERNAME)).asString();
      mailpassword=mailconfig.get(new JsonPointer(CONFIG_MAIL_PASSWORD)).asString();
      starttls=mailconfig.get(new JsonPointer(CONFIG_MAIL_STARTTLS)).asBoolean();
    }
    JsonValue engineConfig=config.get(CONFIG_ENGINE);
    if (!engineConfig.isNull()) {
      url=config.get(new JsonPointer(CONFIG_ENGINE_URL)).asString();
      username=config.get(new JsonPointer(CONFIG_ENGINE_USERNAME)).asString();
      password=config.get(new JsonPointer(CONFIG_ENGINE_PASSWORD)).asString();
    }
    tablePrefix=config.get(CONFIG_TABLE_PREFIX).defaultTo(""String_Node_Str"").asString();
    tablePrefixIsSchema=config.get(CONFIG_TABLE_PREFIX_IS_SCHEMA).defaultTo(false).asBoolean();
    historyLevel=config.get(CONFIG_HISTORY).asString();
    workflowDir=config.get(CONFIG_WORKFLOWDIR).defaultTo(""String_Node_Str"").asString();
  }
}","/** 
 * Read and process Workflow configuration file
 * @param compContext
 */
private void readConfiguration(ComponentContext compContext){
  JsonValue config=enhancedConfig.getConfigurationAsJson(compContext);
  if (!config.isNull()) {
    enabled=config.get(CONFIG_ENABLED).defaultTo(true).asBoolean();
    location=config.get(CONFIG_LOCATION).defaultTo(EngineLocation.embedded.name()).asEnum(EngineLocation.class);
    JsonValue connectionConfig=config.get(CONFIG_CONNECTION);
    jndiName=connectionConfig.get(CONFIG_JNDI_NAME).asString();
    JsonValue mailconfig=config.get(CONFIG_MAIL);
    if (mailconfig.isNotNull()) {
      mailhost=mailconfig.get(CONFIG_MAIL_HOST).defaultTo(LOCALHOST).asString();
      mailport=mailconfig.get(CONFIG_MAIL_PORT).defaultTo(DEFAULT_MAIL_PORT).asInteger();
      mailusername=mailconfig.get(CONFIG_MAIL_USERNAME).asString();
      mailpassword=mailconfig.get(CONFIG_MAIL_PASSWORD).asString();
      starttls=mailconfig.get(CONFIG_MAIL_STARTTLS).defaultTo(false).asBoolean();
    }
    JsonValue engineConfig=config.get(CONFIG_ENGINE);
    if (!engineConfig.isNull()) {
      url=config.get(new JsonPointer(CONFIG_ENGINE_URL)).asString();
      username=config.get(new JsonPointer(CONFIG_ENGINE_USERNAME)).asString();
      password=config.get(new JsonPointer(CONFIG_ENGINE_PASSWORD)).asString();
    }
    tablePrefix=config.get(CONFIG_TABLE_PREFIX).defaultTo(""String_Node_Str"").asString();
    tablePrefixIsSchema=config.get(CONFIG_TABLE_PREFIX_IS_SCHEMA).defaultTo(false).asBoolean();
    historyLevel=config.get(CONFIG_HISTORY).asString();
    workflowDir=config.get(CONFIG_WORKFLOWDIR).defaultTo(""String_Node_Str"").asString();
  }
}"
13161,"@Override public Promise<ResourceResponse,ResourceException> createInstance(Context context,CreateRequest request){
  String resourceId=request.getNewResourceId();
  JsonValue content=request.getContent();
  if (!content.get(FIELD_CONTENT_ID).isNull()) {
    resourceId=content.get(FIELD_CONTENT_ID).asString();
  }
  logger.debug(""String_Node_Str"",name,resourceId);
  try {
    JsonValue value=decrypt(content);
    execScript(context,ScriptHook.onCreate,value,null);
    populateVirtualProperties(context,value);
    JsonValue strippedRelationshipFields=stripRelationshipFields(value);
    onStore(context,value);
    CreateRequest createRequest=Requests.newCreateRequest(repoId(null),resourceId,value);
    ResourceResponse createResponse=connectionFactory.getConnection().create(context,createRequest);
    content=createResponse.getContent();
    resourceId=createResponse.getId();
    activityLogger.log(context,request,""String_Node_Str"",managedId(resourceId).toString(),null,content,Status.SUCCESS);
    content.asMap().putAll(strippedRelationshipFields.asMap());
    content.asMap().putAll(persistRelationships(context,resourceId,value).asMap());
    execScript(context,ScriptHook.postCreate,content,prepareScriptBindings(context,request,resourceId,new JsonValue(null),content));
    performSyncAction(context,request,resourceId,SynchronizationService.SyncServiceAction.notifyCreate,new JsonValue(null),content);
    return prepareResponse(context,createResponse,request.getFields()).asPromise();
  }
 catch (  ResourceException e) {
    return e.asPromise();
  }
catch (  Exception e) {
    return new InternalServerErrorException(e.getMessage(),e).asPromise();
  }
}","@Override public Promise<ResourceResponse,ResourceException> createInstance(Context context,CreateRequest request){
  String resourceId=request.getNewResourceId();
  JsonValue content=request.getContent();
  if (!content.get(FIELD_CONTENT_ID).isNull()) {
    resourceId=content.get(FIELD_CONTENT_ID).asString();
  }
  logger.debug(""String_Node_Str"",name,resourceId);
  try {
    JsonValue value=decrypt(content);
    execScript(context,ScriptHook.onCreate,value,null);
    populateVirtualProperties(context,value);
    JsonValue strippedRelationshipFields=stripRelationshipFields(value);
    onStore(context,value);
    CreateRequest createRequest=Requests.newCreateRequest(repoId(null),resourceId,value);
    ResourceResponse createResponse=connectionFactory.getConnection().create(context,createRequest);
    content=createResponse.getContent();
    resourceId=createResponse.getId();
    activityLogger.log(context,request,""String_Node_Str"",managedId(resourceId).toString(),null,content,Status.SUCCESS);
    content.asMap().putAll(strippedRelationshipFields.asMap());
    content.asMap().putAll(persistRelationships(context,resourceId,content).asMap());
    execScript(context,ScriptHook.postCreate,content,prepareScriptBindings(context,request,resourceId,new JsonValue(null),content));
    performSyncAction(context,request,resourceId,SynchronizationService.SyncServiceAction.notifyCreate,new JsonValue(null),content);
    return prepareResponse(context,createResponse,request.getFields()).asPromise();
  }
 catch (  ResourceException e) {
    return e.asPromise();
  }
catch (  Exception e) {
    return new InternalServerErrorException(e.getMessage(),e).asPromise();
  }
}"
13162,"static QueryFilter<JsonPointer> asRelationshipQueryFilter(QueryFilter<JsonPointer> filter){
  return filter.accept(VISITOR,null);
}","static QueryFilter<JsonPointer> asRelationshipQueryFilter(Boolean isReverse,QueryFilter<JsonPointer> filter){
  return filter.accept(VISITOR,isReverse);
}"
13163,"/** 
 * Visits each   {@link QueryFilter} in a list of filters and returns a list of thevisited filters.
 * @param subFilters a list of the filters to visit
 * @return a list of visited filters
 */
private List<QueryFilter<JsonPointer>> visitQueryFilters(List<QueryFilter<JsonPointer>> subFilters){
  List<QueryFilter<JsonPointer>> visitedFilters=new ArrayList<>();
  for (  QueryFilter<JsonPointer> filter : subFilters) {
    visitedFilters.add(asRelationshipQueryFilter(filter));
  }
  return visitedFilters;
}","/** 
 * Visits each   {@link QueryFilter} in a list of filters and returns a list of thevisited filters.
 * @param subFilters a list of the filters to visit
 * @return a list of visited filters
 */
private List<QueryFilter<JsonPointer>> visitQueryFilters(Boolean isReverse,List<QueryFilter<JsonPointer>> subFilters){
  List<QueryFilter<JsonPointer>> visitedFilters=new ArrayList<>();
  for (  QueryFilter<JsonPointer> filter : subFilters) {
    visitedFilters.add(asRelationshipQueryFilter(isReverse,filter));
  }
  return visitedFilters;
}"
13164,"/** 
 * {@inheritDoc} 
 */
@Override public Promise<QueryResponse,ResourceException> queryCollection(final Context context,final QueryRequest request,final QueryResourceHandler handler){
  try {
    if (request.getQueryExpression() != null) {
      return new BadRequestException(HttpUtils.PARAM_QUERY_EXPRESSION + ""String_Node_Str"").asPromise();
    }
    final QueryRequest queryRequest=Requests.newQueryRequest(REPO_RESOURCE_PATH);
    final boolean queryAllIds=ServerConstants.QUERY_ALL_IDS.equals(request.getQueryId());
    if (request.getQueryId() != null) {
      request.setQueryFilter(QueryFilter.<JsonPointer>alwaysTrue());
      if (ServerConstants.QUERY_ALL_IDS.equals(request.getQueryId())) {
        request.addField(FIELD_ID);
      }
 else       if (!""String_Node_Str"".equals(request.getQueryId())) {
        return new BadRequestException(""String_Node_Str"" + HttpUtils.PARAM_QUERY_ID + ""String_Node_Str"").asPromise();
      }
    }
    queryRequest.setQueryFilter(request.getQueryFilter());
    queryRequest.setPageSize(request.getPageSize());
    queryRequest.setPagedResultsOffset(request.getPagedResultsOffset());
    queryRequest.setPagedResultsCookie(request.getPagedResultsCookie());
    queryRequest.setTotalPagedResultsPolicy(request.getTotalPagedResultsPolicy());
    queryRequest.addSortKey(request.getSortKeys().toArray(new SortKey[request.getSortKeys().size()]));
    for (    String key : request.getAdditionalParameters().keySet()) {
      queryRequest.setAdditionalParameter(key,request.getAdditionalParameter(key));
    }
    QueryFilter<JsonPointer> filter=QueryFilter.and(QueryFilter.equalTo(new JsonPointer(isReverse ? REPO_FIELD_SECOND_ID : REPO_FIELD_FIRST_ID),firstResourcePath(context,request)),QueryFilter.equalTo(new JsonPointer(REPO_FIELD_FIRST_PROPERTY_NAME),propertyName));
    if (request.getQueryFilter() != null) {
      filter=QueryFilter.and(filter,asRelationshipQueryFilter(request.getQueryFilter()));
    }
    queryRequest.setQueryFilter(filter);
    final Promise<QueryResponse,ResourceException> response=getConnection().queryAsync(context,queryRequest,new QueryResourceHandler(){
      @Override public boolean handleResource(      ResourceResponse resource){
        ResourceResponse filteredResourceResponse=FORMAT_RESPONSE_NO_EXCEPTION.apply(resource);
        if (queryAllIds) {
          filteredResourceResponse.addField(FIELD_ID);
          return handler.handleResource(filteredResourceResponse);
        }
        try {
          filteredResourceResponse=expandFields(context,request,filteredResourceResponse).getOrThrow();
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"" + e.getMessage(),e);
        }
        return handler.handleResource(filteredResourceResponse);
      }
    }
);
    if (context.containsContext(ManagedObjectSetContext.class)) {
      return response;
    }
    QueryResponse result=response.getOrThrow();
    final ResourceResponse value=getManagedObject(context);
    activityLogger.log(context,request,""String_Node_Str"",getManagedObjectPath(context),null,value.getContent(),Status.SUCCESS);
    return newResultPromise(result);
  }
 catch (  ResourceException e) {
    return e.asPromise();
  }
catch (  Exception e) {
    return new InternalServerErrorException(e.getMessage(),e).asPromise();
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public Promise<QueryResponse,ResourceException> queryCollection(final Context context,final QueryRequest request,final QueryResourceHandler handler){
  try {
    if (request.getQueryExpression() != null) {
      return new BadRequestException(HttpUtils.PARAM_QUERY_EXPRESSION + ""String_Node_Str"").asPromise();
    }
    final QueryRequest queryRequest=Requests.newQueryRequest(REPO_RESOURCE_PATH);
    final boolean queryAllIds=ServerConstants.QUERY_ALL_IDS.equals(request.getQueryId());
    if (request.getQueryId() != null) {
      request.setQueryFilter(QueryFilter.<JsonPointer>alwaysTrue());
      if (ServerConstants.QUERY_ALL_IDS.equals(request.getQueryId())) {
        request.addField(FIELD_ID);
      }
 else       if (!""String_Node_Str"".equals(request.getQueryId())) {
        return new BadRequestException(""String_Node_Str"" + HttpUtils.PARAM_QUERY_ID + ""String_Node_Str"").asPromise();
      }
    }
    queryRequest.setQueryFilter(request.getQueryFilter());
    queryRequest.setPageSize(request.getPageSize());
    queryRequest.setPagedResultsOffset(request.getPagedResultsOffset());
    queryRequest.setPagedResultsCookie(request.getPagedResultsCookie());
    queryRequest.setTotalPagedResultsPolicy(request.getTotalPagedResultsPolicy());
    queryRequest.addSortKey(request.getSortKeys().toArray(new SortKey[request.getSortKeys().size()]));
    for (    String key : request.getAdditionalParameters().keySet()) {
      queryRequest.setAdditionalParameter(key,request.getAdditionalParameter(key));
    }
    QueryFilter<JsonPointer> filter=QueryFilter.and(QueryFilter.equalTo(new JsonPointer(isReverse ? REPO_FIELD_SECOND_ID : REPO_FIELD_FIRST_ID),firstResourcePath(context,request)),QueryFilter.equalTo(new JsonPointer(REPO_FIELD_FIRST_PROPERTY_NAME),propertyName));
    if (request.getQueryFilter() != null) {
      filter=QueryFilter.and(filter,asRelationshipQueryFilter(isReverse,request.getQueryFilter()));
    }
    queryRequest.setQueryFilter(filter);
    final Promise<QueryResponse,ResourceException> response=getConnection().queryAsync(context,queryRequest,new QueryResourceHandler(){
      @Override public boolean handleResource(      ResourceResponse resource){
        ResourceResponse filteredResourceResponse=FORMAT_RESPONSE_NO_EXCEPTION.apply(resource);
        if (queryAllIds) {
          filteredResourceResponse.addField(FIELD_ID);
          return handler.handleResource(filteredResourceResponse);
        }
        try {
          filteredResourceResponse=expandFields(context,request,filteredResourceResponse).getOrThrow();
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"" + e.getMessage(),e);
        }
        return handler.handleResource(filteredResourceResponse);
      }
    }
);
    if (context.containsContext(ManagedObjectSetContext.class)) {
      return response;
    }
    QueryResponse result=response.getOrThrow();
    final ResourceResponse value=getManagedObject(context);
    activityLogger.log(context,request,""String_Node_Str"",getManagedObjectPath(context),null,value.getContent(),Status.SUCCESS);
    return newResultPromise(result);
  }
 catch (  ResourceException e) {
    return e.asPromise();
  }
catch (  Exception e) {
    return new InternalServerErrorException(e.getMessage(),e).asPromise();
  }
}"
13165,"@Override public QueryFilter<JsonPointer> visitOrFilter(Boolean isReverse,List<QueryFilter<JsonPointer>> subFilters){
  return QueryFilter.or(visitQueryFilters(subFilters));
}","@Override public QueryFilter<JsonPointer> visitOrFilter(Boolean isReverse,List<QueryFilter<JsonPointer>> subFilters){
  return QueryFilter.or(visitQueryFilters(isReverse,subFilters));
}"
13166,"@Override public QueryFilter<JsonPointer> visitAndFilter(Boolean isReverse,List<QueryFilter<JsonPointer>> subFilters){
  return QueryFilter.and(visitQueryFilters(subFilters));
}","@Override public QueryFilter<JsonPointer> visitAndFilter(Boolean isReverse,List<QueryFilter<JsonPointer>> subFilters){
  return QueryFilter.and(visitQueryFilters(isReverse,subFilters));
}"
13167,"/** 
 * Patches the given resource and will also remove private properties if it is an external call based upon context.
 * @param context
 * @param request
 * @param resource The resource to be patched
 * @param revision
 * @param patchOperations
 * @return The patched ResourceResponse with private properties omitted if called externally.
 * @throws ResourceException
 */
private ResourceResponse patchResource(Context context,Request request,ResourceResponse resource,String revision,List<PatchOperation> patchOperations) throws ResourceException {
  boolean forceUpdate=(revision == null);
  boolean retry=forceUpdate;
  String rev=revision;
  do {
    logger.debug(""String_Node_Str"",name,request.getResourcePath());
    try {
      JsonValue decrypted=decrypt(resource.getContent());
      if (revision == null) {
        rev=decrypted.get(""String_Node_Str"").asString();
      }
      JsonValue newValue=decrypted.copy();
      boolean modified=JsonValuePatch.apply(newValue,patchOperations);
      if (!modified) {
        return null;
      }
      if (enforcePolicies) {
        ActionRequest policyAction=Requests.newActionRequest(ResourcePath.valueOf(""String_Node_Str"").concat(managedId(resource.getId())).toString(),""String_Node_Str"");
        policyAction.setContent(newValue);
        if (ContextUtil.isExternal(context)) {
          policyAction.setAdditionalParameter(""String_Node_Str"",""String_Node_Str"");
        }
        JsonValue result=connectionFactory.getConnection().action(context,policyAction).getJsonContent();
        if (!result.isNull() && !result.get(""String_Node_Str"").asBoolean()) {
          logger.debug(""String_Node_Str"",result);
          throw new ForbiddenException(""String_Node_Str"").setDetail(result);
        }
      }
      ResourceResponse patchedResource=update(context,request,resource.getId(),rev,resource.getContent(),newValue);
      activityLogger.log(context,request,""String_Node_Str"",managedId(patchedResource.getId()).toString(),resource.getContent(),patchedResource.getContent(),Status.SUCCESS);
      retry=false;
      logger.debug(""String_Node_Str"");
      return prepareResponse(context,patchedResource,request.getFields());
    }
 catch (    PreconditionFailedException e) {
      if (forceUpdate) {
        logger.debug(""String_Node_Str"");
      }
 else {
        throw e;
      }
    }
catch (    ResourceException e) {
      throw e;
    }
  }
 while (retry);
  return null;
}","/** 
 * Patches the given resource and will also remove private properties if it is an external call based upon context.
 * @param context
 * @param request
 * @param resource The resource to be patched
 * @param revision
 * @param patchOperations
 * @return The patched ResourceResponse with private properties omitted if called externally.
 * @throws ResourceException
 */
private ResourceResponse patchResource(Context context,Request request,ResourceResponse resource,String revision,List<PatchOperation> patchOperations) throws ResourceException {
  boolean forceUpdate=(revision == null);
  boolean retry=forceUpdate;
  String rev=revision;
  do {
    logger.debug(""String_Node_Str"",name,request.getResourcePath());
    try {
      JsonValue decrypted=decrypt(resource.getContent());
      if (revision == null) {
        rev=decrypted.get(""String_Node_Str"").asString();
      }
      final JsonValue relationships=fetchRelationshipFields(context,resource.getId());
      decrypted.asMap().putAll(relationships.asMap());
      JsonValue newValue=decrypted.copy();
      boolean modified=JsonValuePatch.apply(newValue,patchOperations);
      if (!modified) {
        return null;
      }
      if (enforcePolicies) {
        ActionRequest policyAction=Requests.newActionRequest(ResourcePath.valueOf(""String_Node_Str"").concat(managedId(resource.getId())).toString(),""String_Node_Str"");
        policyAction.setContent(newValue);
        if (ContextUtil.isExternal(context)) {
          policyAction.setAdditionalParameter(""String_Node_Str"",""String_Node_Str"");
        }
        JsonValue result=connectionFactory.getConnection().action(context,policyAction).getJsonContent();
        if (!result.isNull() && !result.get(""String_Node_Str"").asBoolean()) {
          logger.debug(""String_Node_Str"",result);
          throw new ForbiddenException(""String_Node_Str"").setDetail(result);
        }
      }
      ResourceResponse patchedResource=update(context,request,resource.getId(),rev,resource.getContent(),newValue);
      activityLogger.log(context,request,""String_Node_Str"",managedId(patchedResource.getId()).toString(),resource.getContent(),patchedResource.getContent(),Status.SUCCESS);
      retry=false;
      logger.debug(""String_Node_Str"");
      return prepareResponse(context,patchedResource,request.getFields());
    }
 catch (    PreconditionFailedException e) {
      if (forceUpdate) {
        logger.debug(""String_Node_Str"");
      }
 else {
        throw e;
      }
    }
catch (    ResourceException e) {
      throw e;
    }
catch (    Exception e) {
      throw new InternalServerErrorException(e.getMessage(),e);
    }
  }
 while (retry);
  return null;
}"
13168,"@Override public void frameworkEvent(FrameworkEvent event){
  logger.debug(""String_Node_Str"",event.getType(),event.toString());
  if (event.getType() == FrameworkEvent.STARTED) {
    logger.debug(""String_Node_Str"");
    frameworkStarted=true;
  }
  if (frameworkStarted) {
switch (event.getType()) {
case FrameworkEvent.PACKAGES_REFRESHED:
case FrameworkEvent.STARTLEVEL_CHANGED:
case FrameworkEvent.WARNING:
case FrameworkEvent.INFO:
      break;
default :
    checkState();
}
}
if (event.getType() == FrameworkEvent.STARTED) {
if (!stateDetail.state.equals(AppState.ACTIVE_READY)) {
  scheduleCheckStartup();
}
}
}","@Override public void frameworkEvent(FrameworkEvent event){
  final int eventType=event.getType();
  logger.debug(""String_Node_Str"",eventType,event.toString());
  frameworkStatusService.setFrameworkStatus(eventType);
  if (eventType == FrameworkEvent.STARTED) {
    logger.debug(""String_Node_Str"");
    frameworkStarted=true;
  }
  if (frameworkStarted) {
switch (eventType) {
case FrameworkEvent.PACKAGES_REFRESHED:
case FrameworkEvent.STARTLEVEL_CHANGED:
case FrameworkEvent.WARNING:
case FrameworkEvent.INFO:
      break;
default :
    checkState();
}
}
if (eventType == FrameworkEvent.STARTED) {
if (!stateDetail.state.equals(AppState.ACTIVE_READY)) {
  scheduleCheckStartup(serviceStartMax);
}
}
}"
13169,"@Deactivate protected void deactivate(ComponentContext context){
  if (scheduledExecutor != null) {
    scheduledExecutor.shutdown();
  }
  if (frameworkListener != null) {
    context.getBundleContext().removeFrameworkListener(frameworkListener);
  }
  if (svcListener != null) {
    context.getBundleContext().removeServiceListener(svcListener);
  }
  if (bundleListener != null) {
    context.getBundleContext().removeBundleListener(bundleListener);
  }
  frameworkStarted=false;
  setState(AppState.STOPPING,""String_Node_Str"");
  logger.info(""String_Node_Str"");
}","@Deactivate protected void deactivate(ComponentContext context){
  if (scheduledExecutor != null) {
    scheduledExecutor.shutdown();
  }
  if (frameworkListener != null) {
    context.getBundleContext().removeFrameworkListener(frameworkListener);
  }
  if (svcListener != null) {
    context.getBundleContext().removeServiceListener(svcListener);
  }
  if (bundleListener != null) {
    context.getBundleContext().removeBundleListener(bundleListener);
  }
  if (tracker != null) {
    tracker.close();
    tracker=null;
  }
  frameworkStarted=false;
  setState(AppState.STOPPING,""String_Node_Str"");
  logger.info(""String_Node_Str"");
}"
13170,"@Override public void addedService(ServiceReference reference,Object service){
  ClusterManagementService clusterService=(ClusterManagementService)service;
  if (clusterService != null) {
    clusterService.register(LISTENER_ID,this);
    clusterEnabled=clusterService.isEnabled();
    cluster=clusterService;
  }
}","@Override public void addedService(ServiceReference reference,Object service){
  ClusterManagementService clusterService=(ClusterManagementService)service;
  if (clusterService != null) {
    clusterService.register(LISTENER_ID,this);
    clusterEnabled=clusterService.isEnabled();
    cluster=clusterService;
    if (clusterEnabled && !cluster.isStarted()) {
      cluster.startClusterManagement();
    }
  }
}"
13171,"/** 
 * Check and update the application state
 */
private void checkState(){
  Bundle[] bundles=context.getBundleContext().getBundles();
  List<String> missingBundles=new ArrayList<String>(requiredBundles);
  List<String> bundleFailures=new ArrayList<String>();
  List<String> fragmentFailures=new ArrayList<String>();
  for (  String req : requiredBundles) {
    for (    Bundle bundle : bundles) {
      String symbolicName=bundle.getSymbolicName();
      if (symbolicName != null && symbolicName.matches(req)) {
        if (isFragment(bundle)) {
          if (bundle.getState() != Bundle.RESOLVED) {
            fragmentFailures.add(bundle.getSymbolicName());
          }
        }
 else {
          if (bundle.getState() != Bundle.ACTIVE) {
            bundleFailures.add(bundle.getSymbolicName());
          }
        }
        missingBundles.remove(req);
      }
    }
  }
  ServiceReference[] refs=null;
  try {
    refs=context.getBundleContext().getAllServiceReferences(null,null);
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"",e);
  }
  List<String> missingServices=new ArrayList<String>(requiredServices);
  if (refs != null && refs.length > 0) {
    for (    String req : requiredServices) {
      for (      ServiceReference ref : refs) {
        String pid=(String)ref.getProperty(Constants.SERVICE_PID);
        if (pid != null && pid.matches(req)) {
          missingServices.remove(req);
          break;
        }
      }
    }
  }
  AppState updatedAppState=null;
  String updatedShortDesc=null;
  if (missingBundles.size() > 0 || bundleFailures.size() > 0 || fragmentFailures.size() > 0) {
    updatedAppState=AppState.ACTIVE_NOT_READY;
    updatedShortDesc=""String_Node_Str"" + missingBundles + ""String_Node_Str""+ bundleFailures+ ""String_Node_Str""+ fragmentFailures;
  }
 else   if (missingServices.size() > 0) {
    updatedAppState=AppState.ACTIVE_NOT_READY;
    updatedShortDesc=""String_Node_Str"" + missingServices;
  }
 else   if (clusterEnabled && !clusterUp) {
    if (cluster != null && !cluster.isStarted()) {
      cluster.startClusterManagement();
    }
    updatedAppState=AppState.ACTIVE_NOT_READY;
    updatedShortDesc=""String_Node_Str"";
  }
 else {
    updatedAppState=AppState.ACTIVE_READY;
    updatedShortDesc=""String_Node_Str"";
  }
  setState(updatedAppState,updatedShortDesc);
}","/** 
 * Check and update the application state
 */
private void checkState(){
  Bundle[] bundles=context.getBundleContext().getBundles();
  List<String> missingBundles=new ArrayList<String>(requiredBundles);
  List<String> bundleFailures=new ArrayList<String>();
  List<String> fragmentFailures=new ArrayList<String>();
  for (  String req : requiredBundles) {
    for (    Bundle bundle : bundles) {
      String symbolicName=bundle.getSymbolicName();
      if (symbolicName != null && symbolicName.matches(req)) {
        if (isFragment(bundle)) {
          if (bundle.getState() != Bundle.RESOLVED) {
            fragmentFailures.add(bundle.getSymbolicName());
          }
        }
 else {
          if (bundle.getState() != Bundle.ACTIVE) {
            bundleFailures.add(bundle.getSymbolicName());
          }
        }
        missingBundles.remove(req);
      }
    }
  }
  ServiceReference[] refs=null;
  try {
    refs=context.getBundleContext().getAllServiceReferences(null,null);
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"",e);
  }
  List<String> missingServices=new ArrayList<String>(requiredServices);
  if (refs != null && refs.length > 0) {
    for (    String req : requiredServices) {
      for (      ServiceReference ref : refs) {
        String pid=(String)ref.getProperty(Constants.SERVICE_PID);
        if (pid != null && pid.matches(req)) {
          missingServices.remove(req);
          break;
        }
      }
    }
  }
  AppState updatedAppState=null;
  String updatedShortDesc=null;
  if (missingBundles.size() > 0 || bundleFailures.size() > 0 || fragmentFailures.size() > 0) {
    updatedAppState=AppState.ACTIVE_NOT_READY;
    updatedShortDesc=""String_Node_Str"" + missingBundles + ""String_Node_Str""+ bundleFailures+ ""String_Node_Str""+ fragmentFailures;
  }
 else   if (missingServices.size() > 0) {
    updatedAppState=AppState.ACTIVE_NOT_READY;
    updatedShortDesc=""String_Node_Str"" + missingServices;
  }
 else   if (clusterEnabled && !clusterUp) {
    updatedAppState=AppState.ACTIVE_NOT_READY;
    updatedShortDesc=""String_Node_Str"";
  }
 else {
    updatedAppState=AppState.ACTIVE_READY;
    updatedShortDesc=""String_Node_Str"";
  }
  setState(updatedAppState,updatedShortDesc);
}"
13172,"/** 
 * After the timeout period passes past framework start event, check that the required services are present. If not, report startup error
 */
private void scheduleCheckStartup(){
  Runnable command=new Runnable(){
    @Override public void run(){
      appStarting=false;
      checkState();
      if (!stateDetail.state.equals(AppState.ACTIVE_READY)) {
        logger.error(""String_Node_Str"",stateDetail.state,stateDetail.shortDesc);
      }
 else {
        logger.debug(""String_Node_Str"");
      }
    }
  }
;
  if (scheduledExecutor.isShutdown()) {
    scheduledExecutor=Executors.newSingleThreadScheduledExecutor();
  }
  scheduledExecutor.schedule(command,serviceStartMax,TimeUnit.MILLISECONDS);
}","/** 
 * After the timeout period passes past framework start event, check that the required services are present. If not, report startup error
 * @param delay a delay in milliseconds before checking the state.
 */
private void scheduleCheckStartup(long delay){
  Runnable command=new Runnable(){
    @Override public void run(){
      appStarting=false;
      checkState();
      if (!stateDetail.state.equals(AppState.ACTIVE_READY)) {
        logger.error(""String_Node_Str"",stateDetail.state,stateDetail.shortDesc);
      }
 else {
        logger.debug(""String_Node_Str"");
      }
    }
  }
;
  if (scheduledExecutor.isShutdown()) {
    scheduledExecutor=Executors.newSingleThreadScheduledExecutor();
  }
  scheduledExecutor.schedule(command,delay,TimeUnit.MILLISECONDS);
}"
13173,"@Activate protected void activate(final ComponentContext context){
  this.context=context;
  requiredBundles=new ArrayList<String>();
  requiredBundles.addAll(Arrays.asList(defaultRequiredBundles));
  requiredServices=new ArrayList<String>();
  requiredServices.addAll(Arrays.asList(defaultRequiredServices));
  applyPropertyConfig();
  BundleContext ctx=FrameworkUtil.getBundle(HealthService.class).getBundleContext();
  tracker=initServiceTracker(ctx);
  frameworkListener=new FrameworkListener(){
    @Override public void frameworkEvent(    FrameworkEvent event){
      logger.debug(""String_Node_Str"",event.getType(),event.toString());
      if (event.getType() == FrameworkEvent.STARTED) {
        logger.debug(""String_Node_Str"");
        frameworkStarted=true;
      }
      if (frameworkStarted) {
switch (event.getType()) {
case FrameworkEvent.PACKAGES_REFRESHED:
case FrameworkEvent.STARTLEVEL_CHANGED:
case FrameworkEvent.WARNING:
case FrameworkEvent.INFO:
          break;
default :
        checkState();
    }
  }
  if (event.getType() == FrameworkEvent.STARTED) {
    if (!stateDetail.state.equals(AppState.ACTIVE_READY)) {
      scheduleCheckStartup();
    }
  }
}
}
;
svcListener=new ServiceListener(){
@Override public void serviceChanged(ServiceEvent event){
  logger.debug(""String_Node_Str"",event.getType(),event.toString());
  if (frameworkStarted) {
switch (event.getType()) {
case ServiceEvent.REGISTERED:
case ServiceEvent.UNREGISTERING:
case ServiceEvent.MODIFIED:
      checkState();
    break;
}
}
}
}
;
bundleListener=new BundleListener(){
@Override public void bundleChanged(BundleEvent event){
logger.debug(""String_Node_Str"",event.getType(),event.toString());
if (frameworkStarted) {
switch (event.getType()) {
case BundleEvent.STARTED:
case BundleEvent.STOPPED:
case BundleEvent.UNRESOLVED:
  checkState();
break;
case BundleEvent.RESOLVED:
if (isFragment(event.getBundle())) {
checkState();
}
break;
}
}
}
}
;
context.getBundleContext().addServiceListener(svcListener);
context.getBundleContext().addBundleListener(bundleListener);
context.getBundleContext().addFrameworkListener(frameworkListener);
router.addRoute(uriTemplate(""String_Node_Str""),new OsInfoResourceProvider());
router.addRoute(uriTemplate(""String_Node_Str""),new MemoryInfoResourceProvider());
router.addRoute(uriTemplate(""String_Node_Str""),new ReconInfoResourceProvider());
router.addRoute(uriTemplate(""String_Node_Str""),new DatabaseInfoResourceProvider());
logger.info(""String_Node_Str"");
}","@Activate protected void activate(final ComponentContext context){
  this.context=context;
  requiredBundles=new ArrayList<String>();
  requiredBundles.addAll(Arrays.asList(defaultRequiredBundles));
  requiredServices=new ArrayList<String>();
  requiredServices.addAll(Arrays.asList(defaultRequiredServices));
  applyPropertyConfig();
  frameworkStatusService=FrameworkStatusService.getInstance();
  BundleContext ctx=FrameworkUtil.getBundle(HealthService.class).getBundleContext();
  tracker=initServiceTracker(ctx);
  frameworkListener=new FrameworkListener(){
    @Override public void frameworkEvent(    FrameworkEvent event){
      final int eventType=event.getType();
      logger.debug(""String_Node_Str"",eventType,event.toString());
      frameworkStatusService.setFrameworkStatus(eventType);
      if (eventType == FrameworkEvent.STARTED) {
        logger.debug(""String_Node_Str"");
        frameworkStarted=true;
      }
      if (frameworkStarted) {
switch (eventType) {
case FrameworkEvent.PACKAGES_REFRESHED:
case FrameworkEvent.STARTLEVEL_CHANGED:
case FrameworkEvent.WARNING:
case FrameworkEvent.INFO:
          break;
default :
        checkState();
    }
  }
  if (eventType == FrameworkEvent.STARTED) {
    if (!stateDetail.state.equals(AppState.ACTIVE_READY)) {
      scheduleCheckStartup(serviceStartMax);
    }
  }
}
}
;
svcListener=new ServiceListener(){
@Override public void serviceChanged(ServiceEvent event){
  logger.debug(""String_Node_Str"",event.getType(),event.toString());
  if (frameworkStarted) {
switch (event.getType()) {
case ServiceEvent.REGISTERED:
case ServiceEvent.UNREGISTERING:
case ServiceEvent.MODIFIED:
      checkState();
    break;
}
}
}
}
;
bundleListener=new BundleListener(){
@Override public void bundleChanged(BundleEvent event){
logger.debug(""String_Node_Str"",event.getType(),event.toString());
if (frameworkStarted) {
switch (event.getType()) {
case BundleEvent.STARTED:
case BundleEvent.STOPPED:
case BundleEvent.UNRESOLVED:
  checkState();
break;
case BundleEvent.RESOLVED:
if (isFragment(event.getBundle())) {
checkState();
}
break;
}
}
}
}
;
context.getBundleContext().addServiceListener(svcListener);
context.getBundleContext().addBundleListener(bundleListener);
context.getBundleContext().addFrameworkListener(frameworkListener);
router.addRoute(uriTemplate(""String_Node_Str""),new OsInfoResourceProvider());
router.addRoute(uriTemplate(""String_Node_Str""),new MemoryInfoResourceProvider());
router.addRoute(uriTemplate(""String_Node_Str""),new ReconInfoResourceProvider());
router.addRoute(uriTemplate(""String_Node_Str""),new DatabaseInfoResourceProvider());
if (frameworkStatusService.getFrameworkStatus() == FrameworkEvent.STARTED || frameworkStatusService.getFrameworkStatus() == FrameworkEvent.PACKAGES_REFRESHED || frameworkStatusService.getFrameworkStatus() == FrameworkEvent.STARTLEVEL_CHANGED || frameworkStatusService.getFrameworkStatus() == FrameworkEvent.WARNING || frameworkStatusService.getFrameworkStatus() == FrameworkEvent.INFO) {
scheduleCheckStartup(2000);
}
logger.info(""String_Node_Str"");
}"
13174,"@Test public void testListCurrentlyExecutingJobsAction() throws Exception {
  final ActionRequest readRequest=Requests.newActionRequest(""String_Node_Str"",SchedulerService.ACTION_LIST_CURRENTLY_EXECUTING_JOBS);
  Promise<ActionResponse,ResourceException> promise=schedulerService.handleAction(new RootContext(),readRequest);
  AssertJPromiseAssert.assertThat(promise).isNotNull().succeeded();
  ActionResponse resourceResponse=promise.getOrThrow();
  assertThat(resourceResponse.getJsonContent().asList().size()).isEqualTo(0);
}","@Test public void testListCurrentlyExecutingJobsAction() throws Exception {
  final ActionRequest readRequest=Requests.newActionRequest(""String_Node_Str"",SchedulerAction.listCurrentlyExecutingJobs.toString());
  Promise<ActionResponse,ResourceException> promise=schedulerService.handleAction(new RootContext(),readRequest);
  AssertJPromiseAssert.assertThat(promise).isNotNull().succeeded();
  ActionResponse resourceResponse=promise.getOrThrow();
  assertThat(resourceResponse.getJsonContent().asList().size()).isEqualTo(0);
}"
13175,"@Test public void testPauseJobsAction() throws Exception {
  final ActionRequest readRequest=Requests.newActionRequest(""String_Node_Str"",SchedulerService.ACTION_PAUSE_JOBS);
  Promise<ActionResponse,ResourceException> promise=schedulerService.handleAction(new RootContext(),readRequest);
  AssertJPromiseAssert.assertThat(promise).isNotNull().succeeded();
  ActionResponse resourceResponse=promise.getOrThrow();
  assertThat(resourceResponse.getJsonContent().get(""String_Node_Str"").getObject()).isEqualTo(new Boolean(true));
}","@Test public void testPauseJobsAction() throws Exception {
  final ActionRequest readRequest=Requests.newActionRequest(""String_Node_Str"",SchedulerAction.pauseJobs.toString());
  Promise<ActionResponse,ResourceException> promise=schedulerService.handleAction(new RootContext(),readRequest);
  AssertJPromiseAssert.assertThat(promise).isNotNull().succeeded();
  ActionResponse resourceResponse=promise.getOrThrow();
  assertThat(resourceResponse.getJsonContent().get(""String_Node_Str"").getObject()).isEqualTo(new Boolean(true));
}"
13176,"@Test public void testResumeJobsAction() throws Exception {
  final ActionRequest readRequest=Requests.newActionRequest(""String_Node_Str"",SchedulerService.ACTION_RESUME_JOBS);
  Promise<ActionResponse,ResourceException> promise=schedulerService.handleAction(new RootContext(),readRequest);
  AssertJPromiseAssert.assertThat(promise).isNotNull().succeeded();
  ActionResponse resourceResponse=promise.getOrThrow();
  assertThat(resourceResponse.getJsonContent().get(""String_Node_Str"").getObject()).isEqualTo(new Boolean(true));
}","@Test public void testResumeJobsAction() throws Exception {
  final ActionRequest readRequest=Requests.newActionRequest(""String_Node_Str"",SchedulerAction.resumeJobs.toString());
  Promise<ActionResponse,ResourceException> promise=schedulerService.handleAction(new RootContext(),readRequest);
  AssertJPromiseAssert.assertThat(promise).isNotNull().succeeded();
  ActionResponse resourceResponse=promise.getOrThrow();
  assertThat(resourceResponse.getJsonContent().get(""String_Node_Str"").getObject()).isEqualTo(new Boolean(true));
}"
13177,"/** 
 * Update a resource as part of an update or patch request.
 * @param context the current Context
 * @param request the source Request
 * @param resourceId the resource id of the object being modified
 * @param rev the revision of hte object being modified
 * @param oldValue the old value of the object
 * @param newValue the new value of the object
 * @return a {@link ResourceResponse} object representing the updated resource
 * @throws ResourceException
 */
private ResourceResponse update(final Context context,Request request,String resourceId,String rev,JsonValue oldValue,JsonValue newValue) throws ResourceException {
  if (newValue.asMap().equals(oldValue.asMap())) {
    return newResourceResponse(resourceId,rev,null);
  }
  final JsonValue persistRelationships=persistRelationships(context,resourceId,newValue);
  newValue.asMap().putAll(persistRelationships.asMap());
  execScript(context,ScriptHook.onUpdate,newValue,prepareScriptBindings(context,request,resourceId,oldValue,newValue));
  populateVirtualProperties(context,newValue);
  newValue=stripRelationshipFields(newValue);
  onStore(context,newValue);
  UpdateRequest updateRequest=Requests.newUpdateRequest(repoId(resourceId),newValue);
  updateRequest.setRevision(rev);
  ResourceResponse response=connectionFactory.getConnection().update(context,updateRequest);
  response.getContent().asMap().putAll(persistRelationships.asMap());
  execScript(context,ScriptHook.postUpdate,response.getContent(),prepareScriptBindings(context,request,resourceId,oldValue,response.getContent()));
  performSyncAction(context,request,resourceId,SynchronizationService.SyncServiceAction.notifyUpdate,oldValue,response.getContent());
  return response;
}","/** 
 * Update a resource as part of an update or patch request.
 * @param context the current Context
 * @param request the source Request
 * @param resourceId the resource id of the object being modified
 * @param rev the revision of hte object being modified
 * @param oldValue the old value of the object
 * @param newValue the new value of the object
 * @return a {@link ResourceResponse} object representing the updated resource
 * @throws ResourceException
 */
private ResourceResponse update(final Context context,Request request,String resourceId,String rev,JsonValue oldValue,JsonValue newValue) throws ResourceException {
  if (newValue.asMap().equals(oldValue.asMap())) {
    return newResourceResponse(resourceId,rev,null);
  }
  newValue.asMap().putAll(persistRelationships(context,resourceId,newValue).asMap());
  execScript(context,ScriptHook.onUpdate,newValue,prepareScriptBindings(context,request,resourceId,oldValue,newValue));
  populateVirtualProperties(context,newValue);
  JsonValue strippedRelationshipFields=stripRelationshipFields(newValue);
  onStore(context,newValue);
  UpdateRequest updateRequest=Requests.newUpdateRequest(repoId(resourceId),newValue);
  updateRequest.setRevision(rev);
  ResourceResponse response=connectionFactory.getConnection().update(context,updateRequest);
  response.getContent().asMap().putAll(strippedRelationshipFields.asMap());
  execScript(context,ScriptHook.postUpdate,response.getContent(),prepareScriptBindings(context,request,resourceId,oldValue,response.getContent()));
  performSyncAction(context,request,resourceId,SynchronizationService.SyncServiceAction.notifyUpdate,oldValue,response.getContent());
  return response;
}"
13178,"/** 
 * Returns a deep copy of the supplied   {@link JsonValue}. Used to remove special relation fields before persisting the value to the repository.
 * @param value The JsonValue map to strip relationship fields from
 * @return A deep copy of the JsonValue value with relationship fields removed
 */
protected JsonValue stripRelationshipFields(JsonValue value){
  final JsonValue stripped=value.copy();
  for (  JsonPointer field : schema.getRelationshipFields()) {
    stripped.remove(field);
  }
  return stripped;
}","/** 
 * Removes all relationship fields from the supplied   {@link JsonValue} instance of a managed object.  Returns a {@link JsonValue} object containing the stripped fields.
 * @param value The JsonValue map to strip relationship fields from
 * @return A {@link JsonValue} object containing the stripped fields.
 */
protected JsonValue stripRelationshipFields(JsonValue value){
  final JsonValue stripped=json(object());
  for (  JsonPointer field : schema.getRelationshipFields()) {
    JsonValue fieldValue=value.get(field);
    stripped.put(field,fieldValue != null ? fieldValue.getObject() : null);
    value.remove(field);
  }
  return stripped;
}"
13179,"@Override public Promise<ResourceResponse,ResourceException> createInstance(Context context,CreateRequest request){
  String resourceId=request.getNewResourceId();
  JsonValue content=request.getContent();
  if (!content.get(FIELD_CONTENT_ID).isNull()) {
    resourceId=content.get(FIELD_CONTENT_ID).asString();
  }
  logger.debug(""String_Node_Str"",name,resourceId);
  try {
    JsonValue value=decrypt(content);
    final JsonValue persistedRelationships=persistRelationships(context,resourceId,value);
    value.asMap().putAll(persistedRelationships.asMap());
    execScript(context,ScriptHook.onCreate,value,null);
    populateVirtualProperties(context,value);
    value=stripRelationshipFields(value);
    onStore(context,value);
    CreateRequest createRequest=Requests.newCreateRequest(repoId(null),resourceId,value);
    ResourceResponse createResponse=connectionFactory.getConnection().create(context,createRequest);
    activityLogger.log(context,request,""String_Node_Str"",managedId(createResponse.getId()).toString(),null,createResponse.getContent(),Status.SUCCESS);
    createResponse.getContent().asMap().putAll(persistedRelationships.asMap());
    execScript(context,ScriptHook.postCreate,createResponse.getContent(),prepareScriptBindings(context,request,resourceId,new JsonValue(null),createResponse.getContent()));
    performSyncAction(context,request,createResponse.getId(),SynchronizationService.SyncServiceAction.notifyCreate,new JsonValue(null),createResponse.getContent());
    return prepareResponse(context,createResponse,request.getFields()).asPromise();
  }
 catch (  ResourceException e) {
    return e.asPromise();
  }
catch (  Exception e) {
    return new InternalServerErrorException(e.getMessage(),e).asPromise();
  }
}","@Override public Promise<ResourceResponse,ResourceException> createInstance(Context context,CreateRequest request){
  String resourceId=request.getNewResourceId();
  JsonValue content=request.getContent();
  if (!content.get(FIELD_CONTENT_ID).isNull()) {
    resourceId=content.get(FIELD_CONTENT_ID).asString();
  }
  logger.debug(""String_Node_Str"",name,resourceId);
  try {
    JsonValue value=decrypt(content);
    value.asMap().putAll(persistRelationships(context,resourceId,value).asMap());
    execScript(context,ScriptHook.onCreate,value,null);
    populateVirtualProperties(context,value);
    JsonValue strippedRelationshipFields=stripRelationshipFields(value);
    onStore(context,value);
    CreateRequest createRequest=Requests.newCreateRequest(repoId(null),resourceId,value);
    ResourceResponse createResponse=connectionFactory.getConnection().create(context,createRequest);
    activityLogger.log(context,request,""String_Node_Str"",managedId(createResponse.getId()).toString(),null,createResponse.getContent(),Status.SUCCESS);
    createResponse.getContent().asMap().putAll(strippedRelationshipFields.asMap());
    execScript(context,ScriptHook.postCreate,createResponse.getContent(),prepareScriptBindings(context,request,resourceId,new JsonValue(null),createResponse.getContent()));
    performSyncAction(context,request,createResponse.getId(),SynchronizationService.SyncServiceAction.notifyCreate,new JsonValue(null),createResponse.getContent());
    return prepareResponse(context,createResponse,request.getFields()).asPromise();
  }
 catch (  ResourceException e) {
    return e.asPromise();
  }
catch (  Exception e) {
    return new InternalServerErrorException(e.getMessage(),e).asPromise();
  }
}"
13180,"/** 
 * Converts relationship client object pointers to repo format. Converts /_refProperties/_id to /_id Converts /_refProperties/_rev to /_rev Converts /_ref to /secondId Converts /_refProperties/... to /properties/...
 * @param field a {@link JsonPointer} representing the field to modify.
 * @return a {@link JsonPointer} representing the modified field
 */
private JsonPointer getRelationshipPointer(JsonPointer field){
  if (FIELD_ID.equals(field)) {
    return new JsonPointer(FIELD_CONTENT_ID);
  }
  if (FIELD_REV.equals(field)) {
    return new JsonPointer(FIELD_CONTENT_REVISION);
  }
  if (FIELD_REFERENCE.equals(field.toString())) {
    return new JsonPointer(REPO_FIELD_SECOND_ID);
  }
  if (FIELD_PROPERTIES.leaf().equals(field.get(0))) {
    JsonPointer ptr=new JsonPointer(REPO_FIELD_PROPERTIES);
    for (    String s : field.relativePointer(field.size() - 1)) {
      ptr=ptr.child(s);
    }
    return ptr;
  }
  return field;
}","/** 
 * Converts relationship client object pointers to repo format. Converts /_refProperties/_id to /_id Converts /_refProperties/_rev to /_rev Converts /_ref to /secondId Converts /_refProperties/... to /properties/...
 * @param field a {@link JsonPointer} representing the field to modify.
 * @return a {@link JsonPointer} representing the modified field
 */
private JsonPointer getRelationshipPointer(JsonPointer field){
  if (FIELD_ID.equals(field)) {
    return new JsonPointer(FIELD_CONTENT_ID);
  }
  if (FIELD_REV.equals(field)) {
    return new JsonPointer(FIELD_CONTENT_REVISION);
  }
  if (FIELD_REFERENCE.equals(field)) {
    return new JsonPointer(REPO_FIELD_SECOND_ID);
  }
  if (FIELD_PROPERTIES.leaf().equals(field.get(0))) {
    JsonPointer ptr=new JsonPointer(REPO_FIELD_PROPERTIES);
    for (    String s : field.relativePointer(field.size() - 1)) {
      ptr=ptr.child(s);
    }
    return ptr;
  }
  return field;
}"
13181,"public JsonValue mapToJsonValue(ResultSet rs,Set<String> columnNames) throws SQLException, InternalServerErrorException {
  JsonValue mappedResult=new JsonValue(new LinkedHashMap<String,Object>());
  for (  ColumnMapping entry : columnMappings) {
    Object value=null;
    if (columnNames.contains(entry.dbColName)) {
      if (ColumnMapping.TYPE_STRING.equals(entry.dbColType)) {
        value=rs.getString(entry.dbColName);
        if (cryptoServiceAccessor == null || cryptoServiceAccessor.access() == null) {
          throw new InternalServerErrorException(""String_Node_Str"");
        }
        if (JsonUtil.isEncrypted((String)value)) {
          value=convertToJson(entry.dbColName,""String_Node_Str"",(String)value,Map.class).asMap();
        }
      }
 else       if (ColumnMapping.TYPE_JSON_MAP.equals(entry.dbColType)) {
        value=convertToJson(entry.dbColName,entry.dbColType,rs.getString(entry.dbColName),Map.class).asMap();
      }
 else       if (ColumnMapping.TYPE_JSON_LIST.equals(entry.dbColType)) {
        value=convertToJson(entry.dbColName,entry.dbColType,rs.getString(entry.dbColName),List.class).asList();
      }
 else {
        throw new InternalServerErrorException(""String_Node_Str"" + entry.dbColType);
      }
      mappedResult.put(entry.objectColPointer,value);
    }
  }
  logger.debug(""String_Node_Str"",rs,mappedResult);
  return mappedResult;
}","public JsonValue mapToJsonValue(ResultSet rs,Set<String> columnNames) throws SQLException, InternalServerErrorException {
  JsonValue mappedResult=new JsonValue(new LinkedHashMap<String,Object>());
  for (  ColumnMapping entry : columnMappings) {
    Object value=null;
    if (columnNames.contains(entry.dbColName)) {
      if (ColumnMapping.TYPE_STRING.equals(entry.dbColType)) {
        value=rs.getString(entry.dbColName);
        if (cryptoServiceAccessor == null || cryptoServiceAccessor.access() == null) {
          throw new InternalServerErrorException(""String_Node_Str"");
        }
        if (JsonUtil.isEncrypted((String)value)) {
          value=convertToJson(entry.dbColName,""String_Node_Str"",(String)value,Map.class).asMap();
        }
      }
 else       if (ColumnMapping.TYPE_JSON_MAP.equals(entry.dbColType)) {
        value=convertToJson(entry.dbColName,entry.dbColType,rs.getString(entry.dbColName),Map.class).asMap();
      }
 else       if (ColumnMapping.TYPE_JSON_LIST.equals(entry.dbColType)) {
        value=convertToJson(entry.dbColName,entry.dbColType,rs.getString(entry.dbColName),List.class).asList();
      }
 else {
        throw new InternalServerErrorException(""String_Node_Str"" + entry.dbColType);
      }
      mappedResult.putPermissive(entry.objectColPointer,value);
    }
  }
  logger.debug(""String_Node_Str"",rs,mappedResult);
  return mappedResult;
}"
13182,"@Activate protected void activate(ComponentContext context) throws ServletException, NamespaceException {
  logger.debug(""String_Node_Str"",SERVLET_ALIAS);
  servlet=new HttpFrameworkServlet(new HttpApplication(){
    @Override public Handler start() throws HttpApplicationException {
      return CrestHttp.newHttpHandler(connectionFactory,new IDMSecurityContextFactory(augmentSecurityScripts));
    }
    @Override public Factory<Buffer> getBufferFactory(){
      return null;
    }
    @Override public void stop(){
    }
  }
);
  servletRegistration.registerServlet(SERVLET_ALIAS,servlet,new Hashtable());
  logger.info(""String_Node_Str"",SERVLET_ALIAS);
}","@Activate protected void activate(ComponentContext context) throws ServletException, NamespaceException {
  logger.debug(""String_Node_Str"",SERVLET_ALIAS);
  final Handler handler=CrestHttp.newHttpHandler(connectionFactory,new IDMSecurityContextFactory(augmentSecurityScripts));
  servlet=new HttpFrameworkServlet(new HttpApplication(){
    @Override public Handler start() throws HttpApplicationException {
      return handler;
    }
    @Override public Factory<Buffer> getBufferFactory(){
      return null;
    }
    @Override public void stop(){
    }
  }
);
  servletRegistration.registerServlet(SERVLET_ALIAS,servlet,new Hashtable());
  logger.info(""String_Node_Str"",SERVLET_ALIAS);
}"
13183,"@Override public Handler start() throws HttpApplicationException {
  return CrestHttp.newHttpHandler(connectionFactory,new IDMSecurityContextFactory(augmentSecurityScripts));
}","@Override public Handler start() throws HttpApplicationException {
  return handler;
}"
13184,"public void start(BundleContext context){
  logger.debug(""String_Node_Str"");
  Hashtable<String,String> logHandlerProp=new Hashtable<String,String>();
  logHandlerProp.put(""String_Node_Str"",""String_Node_Str"");
  logHandlerProp.put(""String_Node_Str"",""String_Node_Str"");
  OsgiLogHandler logHandler=new OsgiLogHandler(context);
  context.registerService(OsgiLogHandler.class.getName(),logHandler,logHandlerProp);
  logger.debug(""String_Node_Str"");
  Hashtable<String,String> persistenceProp=new Hashtable<String,String>();
  persistenceProp.put(""String_Node_Str"",""String_Node_Str"");
  RepoPersistenceManager persistenceMgr=new RepoPersistenceManager(context);
  context.registerService(new String[]{PersistenceManager.class.getName(),ConfigPersisterMarker.class.getName()},persistenceMgr,persistenceProp);
  logger.debug(""String_Node_Str"");
  JSONConfigInstaller installer=new JSONConfigInstaller();
  installer.start(context);
  Hashtable<String,String> installerProp=new Hashtable<String,String>();
  installerProp.put(""String_Node_Str"",""String_Node_Str"");
  context.registerService(new String[]{ArtifactInstaller.class.getName(),ConfigurationListener.class.getName()},installer,installerProp);
  logger.debug(""String_Node_Str"");
  logger.info(""String_Node_Str"",IdentityServer.getInstance().getServerRoot());
}","public void start(BundleContext context){
  logger.debug(""String_Node_Str"");
  Hashtable<String,String> logHandlerProp=new Hashtable<String,String>();
  logHandlerProp.put(""String_Node_Str"",""String_Node_Str"");
  logHandlerProp.put(""String_Node_Str"",""String_Node_Str"");
  OsgiLogHandler logHandler=new OsgiLogHandler(context);
  context.registerService(OsgiLogHandler.class.getName(),logHandler,logHandlerProp);
  logger.debug(""String_Node_Str"");
  Hashtable<String,String> persistenceProp=new Hashtable<String,String>();
  persistenceProp.put(""String_Node_Str"",""String_Node_Str"");
  RepoPersistenceManager persistenceMgr=new RepoPersistenceManager(context);
  context.registerService(new String[]{PersistenceManager.class.getName(),ConfigPersisterMarker.class.getName()},persistenceMgr,persistenceProp);
  logger.debug(""String_Node_Str"");
  JSONConfigInstaller installer=new JSONConfigInstaller();
  installer.start(context);
  Hashtable<String,String> installerProp=new Hashtable<String,String>();
  installerProp.put(""String_Node_Str"",""String_Node_Str"");
  context.registerService(new String[]{ArtifactInstaller.class.getName(),ConfigurationListener.class.getName()},installer,installerProp);
  logger.debug(""String_Node_Str"");
  PaxWeb.configurePaxWebProperties();
  logger.info(""String_Node_Str"",IdentityServer.getInstance().getServerRoot());
}"
13185,"/** 
 * @return Requested OpenIDM configuration property
 */
public static void add(Object connector){
  int port=-1;
  if (connector instanceof SslConnector) {
    SslConnector sslConnector=(SslConnector)connector;
    port=sslConnector.getPort();
    boolean needClientAuth=sslConnector.getNeedClientAuth();
    if (needClientAuth == false) {
      logger.warn(""String_Node_Str"",port);
    }
 else {
      logger.info(""String_Node_Str"",port);
    }
  }
 else   if (connector instanceof Connector) {
    Connector plainConnector=(Connector)connector;
    port=plainConnector.getPort();
    logger.warn(""String_Node_Str"",port);
  }
 else {
    logger.warn(""String_Node_Str"",connector);
    return;
  }
  clientAuthOnly.add(Integer.valueOf(port));
  setProperty();
}","/** 
 * Sets openidm.auth.clientauthonlyports if client auth is required.
 * @param serverConnector A instance of the ServerConnector
 */
public static void add(ServerConnector serverConnector){
  int port=-1;
  SslConnectionFactory sslConnectionFactory=(SslConnectionFactory)serverConnector.getConnectionFactory(""String_Node_Str"");
  port=serverConnector.getPort();
  if (sslConnectionFactory != null) {
    boolean needClientAuth=sslConnectionFactory.getSslContextFactory().getNeedClientAuth();
    if (needClientAuth == false) {
      logger.warn(""String_Node_Str"",port);
    }
 else {
      logger.info(""String_Node_Str"",port);
    }
  }
  clientAuthOnly.add(Integer.valueOf(port));
  setProperty();
}"
13186,"public ClusterManagerThread(long checkinInterval,long checkinOffset){
  this.checkinInterval=checkinInterval;
}","public ClusterManagerThread(long checkinInterval,long checkinOffset){
  this.checkinInterval=checkinInterval;
  this.checkinOffset=checkinOffset;
}"
13187,"@BeforeMethod public void setUp() throws ResourceException {
  final ClusterManager clusterManager=new ClusterManager();
  final MockRepositoryService mockRepoService=new MockRepositoryService();
  clusterManager.repoService=mockRepoService;
  clusterManager.connectionFactory=Resources.newInternalConnectionFactory(mockRepoService);
  clusterManager.init(config);
  clusterHandler=clusterManager;
  clusterService=clusterManager;
  clusterService.startClusterManagement();
}","@BeforeMethod public void setUp() throws ResourceException, InterruptedException {
  final ClusterManager clusterManager=new ClusterManager();
  final MockRepositoryService mockRepoService=new MockRepositoryService();
  clusterManager.repoService=mockRepoService;
  clusterManager.connectionFactory=Resources.newInternalConnectionFactory(mockRepoService);
  clusterManager.init(config);
  clusterHandler=clusterManager;
  clusterService=clusterManager;
  clusterService.startClusterManagement();
  Thread.sleep(1000);
}"
13188,"public JsonValue build(ConnectorObject source) throws Exception {
  JsonValue result=objectClassInfoHelper.build(source,cryptoService).getContent();
  resetUid(source.getUid(),result);
  if (null != source.getUid().getRevision()) {
    result.put(Resource.FIELD_CONTENT_REVISION,source.getUid().getRevision());
  }
  return result;
}","public JsonValue build(ConnectorObject source) throws Exception {
  JsonValue result=objectClassInfoHelper.build(source,cryptoService).getContent();
  resetUid(source.getUid(),result);
  if (null != source.getUid().getRevision()) {
    result.put(ResourceResponse.FIELD_CONTENT_REVISION,source.getUid().getRevision());
  }
  return result;
}"
13189,"public void resetUid(Uid uid,JsonValue target){
  if (null != uid && null != target) {
    target.put(Resource.FIELD_CONTENT_ID,uid.getUidValue());
  }
}","public void resetUid(Uid uid,JsonValue target){
  if (null != uid && null != target) {
    target.put(ResourceResponse.FIELD_CONTENT_ID,uid.getUidValue());
  }
}"
13190,"@Override public Promise<ActionResponse,ResourceException> actionInstance(Context context,ActionRequest request){
  try {
    logger.debug(""String_Node_Str"",request.getAction(),request);
    JsonValue content=request.getContent();
    if (content == null || !content.isMap() || content.asMap().isEmpty()) {
      return Promises.newExceptionPromise(ResourceException.newBadRequestException(""String_Node_Str"" + request.getResourcePath() + ""String_Node_Str""+ request.getAction()+ ""String_Node_Str""));
    }
    String url=content.get(ARG_URL).required().asString();
    String method=content.get(ARG_METHOD).required().asString();
    JsonValue auth=content.get(ARG_AUTHENTICATE);
    Map<String,Object> headers=content.get(ARG_HEADERS).asMap();
    String contentType=content.get(ARG_CONTENT_TYPE).asString();
    String body=content.get(ARG_BODY).asString();
    boolean detectResultFormat=content.get(ARG_DETECT_RESULT_FORMAT).defaultTo(true).asBoolean();
    MediaType mediaType;
    if (contentType != null) {
      mediaType=new MediaType(contentType);
    }
 else {
      mediaType=MediaType.APPLICATION_JSON;
    }
    ClientResource cr=null;
    try {
      cr=new ClientResource(url);
      Map<String,Object> attrs=cr.getRequestAttributes();
      setAttributes(cr.getRequest(),attrs,headers);
      if (!auth.isNull()) {
        String type=auth.get(""String_Node_Str"").defaultTo(""String_Node_Str"").asString();
        if (""String_Node_Str"".equalsIgnoreCase(type)) {
          String identifier=auth.get(""String_Node_Str"").required().asString();
          String secret=auth.get(""String_Node_Str"").required().asString();
          logger.debug(""String_Node_Str"",identifier,secret != null && secret.length() > 0);
          ChallengeResponse challengeResponse=new ChallengeResponse(ChallengeScheme.HTTP_BASIC,identifier,secret);
          cr.setChallengeResponse(challengeResponse);
        }
 else         if (""String_Node_Str"".equalsIgnoreCase(type)) {
          String token=auth.get(""String_Node_Str"").required().asString();
          logger.debug(""String_Node_Str"");
          Series<Header> extraHeaders=(Series<Header>)attrs.get(""String_Node_Str"");
          if (extraHeaders == null) {
            extraHeaders=new Series<Header>(Header.class);
          }
          extraHeaders.set(""String_Node_Str"",""String_Node_Str"" + token);
          attrs.put(""String_Node_Str"",extraHeaders);
        }
 else {
          return Promises.newExceptionPromise(ResourceException.newBadRequestException(""String_Node_Str"" + type + ""String_Node_Str""+ request.getResourcePath()+ ""String_Node_Str""+ request.getAction()));
        }
      }
      StringRepresentation rep=new StringRepresentation(body);
      rep.setMediaType(mediaType);
      Representation representation=null;
      try {
        if (""String_Node_Str"".equalsIgnoreCase(method)) {
          representation=cr.get();
        }
 else         if (""String_Node_Str"".equalsIgnoreCase(method)) {
          representation=cr.post(rep);
        }
 else         if (""String_Node_Str"".equalsIgnoreCase(method)) {
          representation=cr.put(rep);
        }
 else         if (""String_Node_Str"".equalsIgnoreCase(method)) {
          representation=cr.delete();
        }
 else         if (""String_Node_Str"".equalsIgnoreCase(method)) {
          representation=cr.head();
        }
 else         if (""String_Node_Str"".equalsIgnoreCase(method)) {
          representation=cr.options();
        }
 else {
          return Promises.newExceptionPromise(ResourceException.newBadRequestException(""String_Node_Str"" + method));
        }
      }
 catch (      org.restlet.resource.ResourceException e) {
        int code=e.getStatus().getCode();
        String text=null;
        Representation responseEntity=cr.getResponseEntity();
        if (responseEntity != null && !(responseEntity instanceof EmptyRepresentation)) {
          text=responseEntity.getText();
        }
        final ResourceException exception=ResourceException.getException(code,""String_Node_Str"" + method + ""String_Node_Str""+ e.getMessage(),e);
        if (text != null) {
          JsonValue detail=new JsonValue(new HashMap<String,Object>());
          detail.put(""String_Node_Str"",text);
          exception.setDetail(detail);
        }
        return Promises.newExceptionPromise(exception);
      }
      String text=representation.getText();
      logger.debug(""String_Node_Str"",text,cr.getResponseAttributes());
      if (detectResultFormat && representation.getMediaType().isCompatible(MediaType.APPLICATION_JSON)) {
        try {
          if (text != null && text.trim().length() > 0) {
            return Promises.newResultPromise(Responses.newActionResponse(JsonUtil.parseStringified(text)));
          }
 else {
            return Promises.newExceptionPromise(ResourceException.newBadRequestException(""String_Node_Str"" + url));
          }
        }
 catch (        Exception ex) {
          return Promises.newExceptionPromise(ResourceException.newInternalServerErrorException(""String_Node_Str"" + text + ""String_Node_Str""+ ex.getMessage(),ex));
        }
      }
 else {
        try {
          Map<String,Object> resultHeaders=new HashMap<String,Object>();
          Series<Header> respHeaders=(Series<Header>)cr.getResponseAttributes().get(HeaderConstants.ATTRIBUTE_HEADERS);
          if (respHeaders != null) {
            for (            Header param : respHeaders) {
              String name=param.getName();
              String value=param.getValue();
              resultHeaders.put(name,value);
              logger.debug(""String_Node_Str"",name,value);
            }
          }
          JsonValue result=new JsonValue(new HashMap<String,Object>());
          result.put(""String_Node_Str"",resultHeaders);
          result.put(""String_Node_Str"",text);
          return Promises.newResultPromise(Responses.newActionResponse(result));
        }
 catch (        Exception ex) {
          return Promises.newExceptionPromise(ResourceException.newInternalServerErrorException(""String_Node_Str"" + text + ""String_Node_Str""+ ex.getMessage(),ex));
        }
      }
    }
 catch (    java.io.IOException ex) {
      return Promises.newExceptionPromise(ResourceException.newInternalServerErrorException(""String_Node_Str"" + content,ex));
    }
 finally {
      if (null != cr) {
        cr.release();
      }
    }
  }
 catch (  Exception e) {
    return Promises.newExceptionPromise(ResourceException.newInternalServerErrorException(e));
  }
}","@Override public Promise<ActionResponse,ResourceException> actionInstance(Context context,ActionRequest request){
  try {
    logger.debug(""String_Node_Str"",request.getAction(),request);
    JsonValue content=request.getContent();
    if (content == null || !content.isMap() || content.asMap().isEmpty()) {
      return Promises.newExceptionPromise(ResourceException.newBadRequestException(""String_Node_Str"" + request.getResourcePath() + ""String_Node_Str""+ request.getAction()+ ""String_Node_Str""));
    }
    String url=content.get(ARG_URL).required().asString();
    String method=content.get(ARG_METHOD).required().asString();
    JsonValue auth=content.get(ARG_AUTHENTICATE);
    Map<String,Object> headers=content.get(ARG_HEADERS).asMap();
    String contentType=content.get(ARG_CONTENT_TYPE).asString();
    String body=content.get(ARG_BODY).asString();
    boolean detectResultFormat=content.get(ARG_DETECT_RESULT_FORMAT).defaultTo(true).asBoolean();
    MediaType mediaType;
    if (contentType != null) {
      mediaType=new MediaType(contentType);
    }
 else {
      mediaType=MediaType.APPLICATION_JSON;
    }
    ClientResource cr=null;
    try {
      cr=new ClientResource(url);
      Map<String,Object> attrs=cr.getRequestAttributes();
      setAttributes(cr.getRequest(),attrs,headers);
      if (!auth.isNull()) {
        String type=auth.get(""String_Node_Str"").defaultTo(""String_Node_Str"").asString();
        if (""String_Node_Str"".equalsIgnoreCase(type)) {
          String identifier=auth.get(""String_Node_Str"").required().asString();
          String secret=auth.get(""String_Node_Str"").required().asString();
          logger.debug(""String_Node_Str"",identifier,secret != null && secret.length() > 0);
          ChallengeResponse challengeResponse=new ChallengeResponse(ChallengeScheme.HTTP_BASIC,identifier,secret);
          cr.setChallengeResponse(challengeResponse);
        }
 else         if (""String_Node_Str"".equalsIgnoreCase(type)) {
          String token=auth.get(""String_Node_Str"").required().asString();
          logger.debug(""String_Node_Str"");
          Series<Header> extraHeaders=(Series<Header>)attrs.get(""String_Node_Str"");
          if (extraHeaders == null) {
            extraHeaders=new Series<Header>(Header.class);
          }
          extraHeaders.set(""String_Node_Str"",""String_Node_Str"" + token);
          attrs.put(""String_Node_Str"",extraHeaders);
        }
 else {
          return Promises.newExceptionPromise(ResourceException.newBadRequestException(""String_Node_Str"" + type + ""String_Node_Str""+ request.getResourcePath()+ ""String_Node_Str""+ request.getAction()));
        }
      }
      StringRepresentation rep=new StringRepresentation(body);
      rep.setMediaType(mediaType);
      Representation representation=null;
      try {
        if (""String_Node_Str"".equalsIgnoreCase(method)) {
          representation=cr.get();
        }
 else         if (""String_Node_Str"".equalsIgnoreCase(method)) {
          representation=cr.post(rep);
        }
 else         if (""String_Node_Str"".equalsIgnoreCase(method)) {
          representation=cr.put(rep);
        }
 else         if (""String_Node_Str"".equalsIgnoreCase(method)) {
          representation=cr.delete();
        }
 else         if (""String_Node_Str"".equalsIgnoreCase(method)) {
          representation=cr.head();
        }
 else         if (""String_Node_Str"".equalsIgnoreCase(method)) {
          representation=cr.options();
        }
 else {
          return Promises.newExceptionPromise(ResourceException.newBadRequestException(""String_Node_Str"" + method));
        }
      }
 catch (      org.restlet.resource.ResourceException e) {
        int code=e.getStatus().getCode();
        String text=null;
        Representation responseEntity=cr.getResponseEntity();
        if (responseEntity != null && !(responseEntity instanceof EmptyRepresentation)) {
          text=responseEntity.getText();
        }
        final ResourceException exception=ResourceException.getException(code,""String_Node_Str"" + method + ""String_Node_Str""+ e.getMessage(),e);
        if (text != null) {
          JsonValue detail=new JsonValue(new HashMap<String,Object>());
          detail.put(""String_Node_Str"",text);
          exception.setDetail(detail);
        }
        return Promises.newExceptionPromise(exception);
      }
      String text=representation.getText();
      logger.debug(""String_Node_Str"",text,cr.getResponseAttributes());
      if (detectResultFormat && representation.getMediaType().isCompatible(MediaType.APPLICATION_JSON)) {
        try {
          if (text != null && text.trim().length() > 0) {
            return Promises.newResultPromise(Responses.newActionResponse(JsonUtil.parseStringified(text)));
          }
 else {
            return Promises.newExceptionPromise(ResourceException.newBadRequestException(""String_Node_Str"" + url));
          }
        }
 catch (        Exception ex) {
          return Promises.newExceptionPromise(ResourceException.newInternalServerErrorException(""String_Node_Str"" + text + ""String_Node_Str""+ ex.getMessage(),ex));
        }
      }
 else {
        try {
          Map<String,Object> resultHeaders=new HashMap<String,Object>();
          Series<Header> respHeaders=(Series<Header>)cr.getResponseAttributes().get(HeaderConstants.ATTRIBUTE_HEADERS);
          if (respHeaders != null) {
            for (            Header param : respHeaders) {
              String name=param.getName();
              String value=param.getValue();
              resultHeaders.put(name,value);
              logger.debug(""String_Node_Str"",name,value);
            }
          }
          JsonValue result=new JsonValue(new HashMap<String,Object>());
          result.put(""String_Node_Str"",resultHeaders);
          result.put(""String_Node_Str"",text);
          return Promises.newResultPromise(Responses.newActionResponse(result));
        }
 catch (        Exception ex) {
          return Promises.newExceptionPromise(ResourceException.newInternalServerErrorException(""String_Node_Str"" + text + ""String_Node_Str""+ ex.getMessage(),ex));
        }
      }
    }
 catch (    java.io.IOException ex) {
      return Promises.newExceptionPromise(ResourceException.newInternalServerErrorException(""String_Node_Str"" + content,ex));
    }
 finally {
      if (null != cr) {
        cr.release();
      }
    }
  }
 catch (  Exception e) {
    return Promises.newExceptionPromise(ResourceException.newInternalServerErrorException(e.getMessage(),e));
  }
}"
13191,"@Override public Promise<QueryResponse,ResourceException> queryCollection(final Context context,final QueryRequest request,final QueryResourceHandler handler){
  logger.debug(""String_Node_Str"",name,request.getResourcePath());
  QueryRequest repoRequest=Requests.copyOfQueryRequest(request);
  repoRequest.setResourcePath(repoId(null));
  String executeOnRetrieve=request.getAdditionalParameter(""String_Node_Str"");
  final boolean onRetrieve=executeOnRetrieve == null ? false : Boolean.parseBoolean(executeOnRetrieve);
  final List<Map<String,Object>> results=new ArrayList<Map<String,Object>>();
  final ResourceException[] ex=new ResourceException[]{null};
  try {
    QueryResponse queryResponse=connectionFactory.getConnection().query(context,repoRequest,new QueryResourceHandler(){
      @Override public boolean handleResource(      ResourceResponse resource){
        if (onRetrieve) {
          try {
            onRetrieve(context,request,resource.getId(),resource);
          }
 catch (          ResourceException e) {
            ex[0]=e;
            return false;
          }
        }
        results.add(resource.getContent().asMap());
        if (ContextUtil.isExternal(context)) {
          return handler.handleResource(cullPrivateProperties(resource));
        }
        return handler.handleResource(resource);
      }
    }
);
    if (ex[0] == null) {
      return newExceptionPromise(ex[0]);
    }
    activityLogger.log(context,request,""String_Node_Str"" + request.getQueryId() + ""String_Node_Str""+ request.getAdditionalParameters(),request.getQueryId(),null,new JsonValue(results),Status.SUCCESS);
    return newResultPromise(queryResponse);
  }
 catch (  ResourceException e) {
    return newExceptionPromise(e);
  }
}","@Override public Promise<QueryResponse,ResourceException> queryCollection(final Context context,final QueryRequest request,final QueryResourceHandler handler){
  logger.debug(""String_Node_Str"",name,request.getResourcePath());
  QueryRequest repoRequest=Requests.copyOfQueryRequest(request);
  repoRequest.setResourcePath(repoId(null));
  String executeOnRetrieve=request.getAdditionalParameter(""String_Node_Str"");
  final boolean onRetrieve=executeOnRetrieve == null ? false : Boolean.parseBoolean(executeOnRetrieve);
  final List<Map<String,Object>> results=new ArrayList<Map<String,Object>>();
  final ResourceException[] ex=new ResourceException[]{null};
  try {
    QueryResponse queryResponse=connectionFactory.getConnection().query(context,repoRequest,new QueryResourceHandler(){
      @Override public boolean handleResource(      ResourceResponse resource){
        if (onRetrieve) {
          try {
            onRetrieve(context,request,resource.getId(),resource);
          }
 catch (          ResourceException e) {
            ex[0]=e;
            return false;
          }
        }
        results.add(resource.getContent().asMap());
        if (ContextUtil.isExternal(context)) {
          return handler.handleResource(cullPrivateProperties(resource));
        }
        return handler.handleResource(resource);
      }
    }
);
    if (ex[0] != null) {
      return newExceptionPromise(ex[0]);
    }
    activityLogger.log(context,request,""String_Node_Str"" + request.getQueryId() + ""String_Node_Str""+ request.getAdditionalParameters(),request.getQueryId(),null,new JsonValue(results),Status.SUCCESS);
    return newResultPromise(queryResponse);
  }
 catch (  ResourceException e) {
    return newExceptionPromise(e);
  }
}"
13192,"public RouteBuilder verify(){
  if ((null == collection) && (null == singleton) && (null == handler)) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (uriTemplate != null && uriTemplate.toString().length() > 0) {
    throw new NullPointerException(""String_Node_Str"");
  }
  return this;
}","public RouteBuilder verify(){
  if ((null == collection) && (null == singleton) && (null == handler)) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (uriTemplate == null || uriTemplate.toString().length() == 0) {
    throw new NullPointerException(""String_Node_Str"");
  }
  return this;
}"
13193,"/** 
 * TEMPORARY. Future version will have this break-down into discrete units of work.
 * @param reconContext
 * @throws SynchronizationException
 */
private void doRecon(ReconciliationContext reconContext) throws SynchronizationException {
  reconContext.getStatistics().reconStart();
  String reconId=reconContext.getReconId();
  EventEntry measureIdQueries=Publisher.start(EVENT_RECON_ID_QUERIES,reconId,null);
  reconContext.setStage(ReconStage.ACTIVE_QUERY_ENTRIES);
  ServerContext context=ObjectSetContext.get();
  try {
    context=new TriggerContext(context,""String_Node_Str"");
    ObjectSetContext.push(context);
    logReconStart(reconContext,context);
    reconContext.getStatistics().sourceQueryStart();
    ReconQueryResult sourceQueryResult=reconContext.querySourceIter(reconSourceQueryPageSize,null);
    Iterator<ResultEntry> sourceIter=sourceQueryResult.getIterator();
    reconContext.getStatistics().sourceQueryEnd();
    if (!sourceIter.hasNext()) {
      if (!reconContext.getReconHandler().allowEmptySourceSet()) {
        LOGGER.warn(""String_Node_Str"");
        reconContext.setStage(ReconStage.COMPLETED_FAILED);
        reconContext.getStatistics().reconEnd();
        logReconEndFailure(reconContext,context);
        return;
      }
    }
    Collection<String> remainingTargetIds=null;
    ResultIterable targetIterable=null;
    if (reconContext.getReconHandler().isRunTargetPhase()) {
      reconContext.getStatistics().targetQueryStart();
      targetIterable=reconContext.queryTarget();
      remainingTargetIds=targetIterable.getAllIds();
      reconContext.getStatistics().targetQueryEnd();
    }
 else {
      remainingTargetIds=new ArrayList<String>();
    }
    Map<String,Map<String,Link>> allLinks=null;
    if (prefetchLinks) {
      allLinks=new HashMap<String,Map<String,Link>>();
      Integer totalLinkEntries=new Integer(0);
      reconContext.getStatistics().linkQueryStart();
      for (      String linkQualifier : getAllLinkQualifiers()) {
        Map<String,Link> linksByQualifier=Link.getLinksForMapping(ObjectMapping.this,linkQualifier);
        allLinks.put(linkQualifier,linksByQualifier);
        totalLinkEntries+=linksByQualifier.size();
      }
      reconContext.setTotalLinkEntries(totalLinkEntries);
      reconContext.getStatistics().linkQueryEnd();
    }
    measureIdQueries.end();
    EventEntry measureSource=Publisher.start(EVENT_RECON_SOURCE,reconId,null);
    reconContext.setStage(ReconStage.ACTIVE_RECONCILING_SOURCE);
    reconContext.getStatistics().sourcePhaseStart();
    boolean queryNextPage=false;
    LOGGER.info(""String_Node_Str"",new Object[]{reconId,name});
    do {
      if (queryNextPage) {
        LOGGER.debug(""String_Node_Str"");
        sourceQueryResult=reconContext.querySourceIter(reconSourceQueryPageSize,sourceQueryResult.getPagingCookie());
        sourceIter=sourceQueryResult.getIterator();
      }
      ReconPhase sourcePhase=new ReconPhase(sourceIter,reconContext,context,allLinks,remainingTargetIds,sourceRecon);
      sourcePhase.execute();
      queryNextPage=true;
    }
 while (reconSourceQueryPaging && sourceQueryResult.getPagingCookie() != null);
    reconContext.getStatistics().sourcePhaseEnd();
    measureSource.end();
    LOGGER.debug(""String_Node_Str"",remainingTargetIds);
    if (reconContext.getReconHandler().isRunTargetPhase()) {
      EventEntry measureTarget=Publisher.start(EVENT_RECON_TARGET,reconId,null);
      reconContext.setStage(ReconStage.ACTIVE_RECONCILING_TARGET);
      targetIterable.removeNotMatchingEntries(remainingTargetIds);
      reconContext.getStatistics().targetPhaseStart();
      ReconPhase targetPhase=new ReconPhase(targetIterable.iterator(),reconContext,context,allLinks,null,targetRecon);
      targetPhase.execute();
      reconContext.getStatistics().targetPhaseEnd();
      measureTarget.end();
    }
    reconContext.getStatistics().reconEnd();
    reconContext.setStage(ReconStage.ACTIVE_PROCESSING_RESULTS);
    doResults(reconContext);
    reconContext.setStage(ReconStage.COMPLETED_SUCCESS);
    logReconEndSuccess(reconContext,context);
  }
 catch (  InterruptedException ex) {
    reconContext.checkCanceled();
    throw new SynchronizationException(""String_Node_Str"",ex);
  }
catch (  Exception e) {
    reconContext.setStage(ReconStage.COMPLETED_FAILED);
    reconContext.getStatistics().reconEnd();
    logReconEndFailure(reconContext,context);
    throw new SynchronizationException(""String_Node_Str"",e);
  }
 finally {
    ObjectSetContext.pop();
    if (!reconContext.getStatistics().hasEnded()) {
      reconContext.getStatistics().reconEnd();
    }
  }
}","/** 
 * TEMPORARY. Future version will have this break-down into discrete units of work.
 * @param reconContext
 * @throws SynchronizationException
 */
private void doRecon(ReconciliationContext reconContext) throws SynchronizationException {
  reconContext.getStatistics().reconStart();
  String reconId=reconContext.getReconId();
  EventEntry measureIdQueries=Publisher.start(EVENT_RECON_ID_QUERIES,reconId,null);
  reconContext.setStage(ReconStage.ACTIVE_QUERY_ENTRIES);
  ServerContext context=ObjectSetContext.get();
  try {
    context=new TriggerContext(context,""String_Node_Str"");
    ObjectSetContext.push(context);
    logReconStart(reconContext,context);
    reconContext.getStatistics().sourceQueryStart();
    ReconQueryResult sourceQueryResult=reconContext.querySourceIter(reconSourceQueryPageSize,null);
    Iterator<ResultEntry> sourceIter=sourceQueryResult.getIterator();
    reconContext.getStatistics().sourceQueryEnd();
    if (!sourceIter.hasNext()) {
      if (!reconContext.getReconHandler().allowEmptySourceSet()) {
        LOGGER.warn(""String_Node_Str"");
        reconContext.setStage(ReconStage.COMPLETED_FAILED);
        reconContext.getStatistics().reconEnd();
        logReconEndFailure(reconContext,context);
        return;
      }
    }
    Collection<String> remainingTargetIds=null;
    ResultIterable targetIterable=null;
    if (reconContext.getReconHandler().isRunTargetPhase()) {
      reconContext.getStatistics().targetQueryStart();
      targetIterable=reconContext.queryTarget();
      remainingTargetIds=targetIterable.getAllIds();
      reconContext.getStatistics().targetQueryEnd();
    }
 else {
      remainingTargetIds=new ArrayList<String>();
    }
    Map<String,Map<String,Link>> allLinks=null;
    if (prefetchLinks) {
      allLinks=new HashMap<String,Map<String,Link>>();
      Integer totalLinkEntries=new Integer(0);
      reconContext.getStatistics().linkQueryStart();
      for (      String linkQualifier : getAllLinkQualifiers()) {
        Map<String,Link> linksByQualifier=Link.getLinksForMapping(ObjectMapping.this,linkQualifier);
        allLinks.put(linkQualifier,linksByQualifier);
        totalLinkEntries+=linksByQualifier.size();
      }
      reconContext.setTotalLinkEntries(totalLinkEntries);
      reconContext.getStatistics().linkQueryEnd();
    }
    measureIdQueries.end();
    EventEntry measureSource=Publisher.start(EVENT_RECON_SOURCE,reconId,null);
    reconContext.setStage(ReconStage.ACTIVE_RECONCILING_SOURCE);
    reconContext.getStatistics().sourcePhaseStart();
    boolean queryNextPage=false;
    LOGGER.info(""String_Node_Str"",new Object[]{reconId,name});
    do {
      if (queryNextPage) {
        LOGGER.debug(""String_Node_Str"");
        sourceQueryResult=reconContext.querySourceIter(reconSourceQueryPageSize,sourceQueryResult.getPagingCookie());
        sourceIter=sourceQueryResult.getIterator();
      }
      ReconPhase sourcePhase=new ReconPhase(sourceIter,reconContext,context,allLinks,remainingTargetIds,sourceRecon);
      sourcePhase.setFeedSize(feedSize);
      sourcePhase.execute();
      queryNextPage=true;
    }
 while (reconSourceQueryPaging && sourceQueryResult.getPagingCookie() != null);
    reconContext.getStatistics().sourcePhaseEnd();
    measureSource.end();
    LOGGER.debug(""String_Node_Str"",remainingTargetIds);
    if (reconContext.getReconHandler().isRunTargetPhase()) {
      EventEntry measureTarget=Publisher.start(EVENT_RECON_TARGET,reconId,null);
      reconContext.setStage(ReconStage.ACTIVE_RECONCILING_TARGET);
      targetIterable.removeNotMatchingEntries(remainingTargetIds);
      reconContext.getStatistics().targetPhaseStart();
      ReconPhase targetPhase=new ReconPhase(targetIterable.iterator(),reconContext,context,allLinks,null,targetRecon);
      targetPhase.setFeedSize(feedSize);
      targetPhase.execute();
      reconContext.getStatistics().targetPhaseEnd();
      measureTarget.end();
    }
    reconContext.getStatistics().reconEnd();
    reconContext.setStage(ReconStage.ACTIVE_PROCESSING_RESULTS);
    doResults(reconContext);
    reconContext.setStage(ReconStage.COMPLETED_SUCCESS);
    logReconEndSuccess(reconContext,context);
  }
 catch (  InterruptedException ex) {
    reconContext.checkCanceled();
    throw new SynchronizationException(""String_Node_Str"",ex);
  }
catch (  Exception e) {
    reconContext.setStage(ReconStage.COMPLETED_FAILED);
    reconContext.getStatistics().reconEnd();
    logReconEndFailure(reconContext,context);
    throw new SynchronizationException(""String_Node_Str"",e);
  }
 finally {
    ObjectSetContext.pop();
    if (!reconContext.getStatistics().hasEnded()) {
      reconContext.getStatistics().reconEnd();
    }
  }
}"
13194,"/** 
 * Create an instance of a mapping between source and target
 * @param service The associated synchronization service
 * @param config The configuration for this mapping
 * @throws JsonValueException if there is an issue initializing based on the configuration.
 */
public ObjectMapping(SynchronizationService service,JsonValue config) throws JsonValueException {
  this.service=service;
  this.config=config;
  name=config.get(""String_Node_Str"").required().asString();
  linkTypeName=config.get(""String_Node_Str"").defaultTo(name).asString();
  sourceObjectSet=config.get(""String_Node_Str"").required().asString();
  targetObjectSet=config.get(""String_Node_Str"").required().asString();
  sourceIdsCaseSensitive=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  targetIdsCaseSensitive=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  validSource=Scripts.newInstance(config.get(""String_Node_Str""));
  validTarget=Scripts.newInstance(config.get(""String_Node_Str""));
  sourceCondition=new Condition(config.get(""String_Node_Str""));
  correlation=new Correlation(config);
  JsonValue linkQualifiersValue=config.get(""String_Node_Str"");
  if (linkQualifiersValue.isNull()) {
    linkQualifiersList.add(Link.DEFAULT_LINK_QUALIFIER);
  }
 else   if (linkQualifiersValue.isList() || linkQualifiersValue.isSet()) {
    linkQualifiersList.addAll(config.get(""String_Node_Str"").asSet(String.class));
  }
 else   if (linkQualifiersValue.isMap()) {
    linkQualifiersScript=Scripts.newInstance(linkQualifiersValue);
  }
 else {
    linkQualifiersValue.expect(List.class);
  }
  for (  JsonValue jv : config.get(""String_Node_Str"").expect(List.class)) {
    properties.add(new PropertyMapping(jv));
  }
  for (  JsonValue jv : config.get(""String_Node_Str"").expect(List.class)) {
    String situation=jv.get(""String_Node_Str"").asString();
    if (policies.containsKey(situation)) {
      List<Policy> policy=policies.get(situation);
      policy.add(new Policy(jv));
      continue;
    }
    List<Policy> policyArrayList=new ArrayList<Policy>();
    policies.put(situation,policyArrayList);
    policyArrayList.add(new Policy(jv));
  }
  defaultMapping=Scripts.newInstance(config.get(""String_Node_Str"").defaultTo(json(object(field(SourceUnit.ATTR_TYPE,""String_Node_Str""),field(SourceUnit.ATTR_NAME,""String_Node_Str"")))));
  onCreateScript=Scripts.newInstance(config.get(""String_Node_Str""));
  onUpdateScript=Scripts.newInstance(config.get(""String_Node_Str""));
  onDeleteScript=Scripts.newInstance(config.get(""String_Node_Str""));
  onLinkScript=Scripts.newInstance(config.get(""String_Node_Str""));
  onUnlinkScript=Scripts.newInstance(config.get(""String_Node_Str""));
  resultScript=Scripts.newInstance(config.get(""String_Node_Str""));
  prefetchLinks=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  Integer confTaskThreads=config.get(""String_Node_Str"").asInteger();
  if (confTaskThreads != null) {
    taskThreads=confTaskThreads.intValue();
  }
  correlateEmptyTargetSet=config.get(""String_Node_Str"").defaultTo(Boolean.FALSE).asBoolean();
  syncEnabled=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  linkingEnabled=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  reconSourceQueryPaging=config.get(""String_Node_Str"").defaultTo(false).asBoolean();
  reconSourceQueryPageSize=config.get(""String_Node_Str"").defaultTo(reconSourceQueryPaging ? ReconFeeder.DEFAULT_FEED_SIZE : 0).asInteger();
  LOGGER.debug(""String_Node_Str"",name);
}","/** 
 * Create an instance of a mapping between source and target
 * @param service The associated synchronization service
 * @param config The configuration for this mapping
 * @throws JsonValueException if there is an issue initializing based on the configuration.
 */
public ObjectMapping(SynchronizationService service,JsonValue config) throws JsonValueException {
  this.service=service;
  this.config=config;
  name=config.get(""String_Node_Str"").required().asString();
  linkTypeName=config.get(""String_Node_Str"").defaultTo(name).asString();
  sourceObjectSet=config.get(""String_Node_Str"").required().asString();
  targetObjectSet=config.get(""String_Node_Str"").required().asString();
  sourceIdsCaseSensitive=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  targetIdsCaseSensitive=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  validSource=Scripts.newInstance(config.get(""String_Node_Str""));
  validTarget=Scripts.newInstance(config.get(""String_Node_Str""));
  sourceCondition=new Condition(config.get(""String_Node_Str""));
  correlation=new Correlation(config);
  JsonValue linkQualifiersValue=config.get(""String_Node_Str"");
  if (linkQualifiersValue.isNull()) {
    linkQualifiersList.add(Link.DEFAULT_LINK_QUALIFIER);
  }
 else   if (linkQualifiersValue.isList() || linkQualifiersValue.isSet()) {
    linkQualifiersList.addAll(config.get(""String_Node_Str"").asSet(String.class));
  }
 else   if (linkQualifiersValue.isMap()) {
    linkQualifiersScript=Scripts.newInstance(linkQualifiersValue);
  }
 else {
    linkQualifiersValue.expect(List.class);
  }
  for (  JsonValue jv : config.get(""String_Node_Str"").expect(List.class)) {
    properties.add(new PropertyMapping(jv));
  }
  for (  JsonValue jv : config.get(""String_Node_Str"").expect(List.class)) {
    String situation=jv.get(""String_Node_Str"").asString();
    if (policies.containsKey(situation)) {
      List<Policy> policy=policies.get(situation);
      policy.add(new Policy(jv));
      continue;
    }
    List<Policy> policyArrayList=new ArrayList<Policy>();
    policies.put(situation,policyArrayList);
    policyArrayList.add(new Policy(jv));
  }
  defaultMapping=Scripts.newInstance(config.get(""String_Node_Str"").defaultTo(json(object(field(SourceUnit.ATTR_TYPE,""String_Node_Str""),field(SourceUnit.ATTR_NAME,""String_Node_Str"")))));
  onCreateScript=Scripts.newInstance(config.get(""String_Node_Str""));
  onUpdateScript=Scripts.newInstance(config.get(""String_Node_Str""));
  onDeleteScript=Scripts.newInstance(config.get(""String_Node_Str""));
  onLinkScript=Scripts.newInstance(config.get(""String_Node_Str""));
  onUnlinkScript=Scripts.newInstance(config.get(""String_Node_Str""));
  resultScript=Scripts.newInstance(config.get(""String_Node_Str""));
  prefetchLinks=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  taskThreads=config.get(""String_Node_Str"").defaultTo(DEFAULT_TASK_THREADS).asInteger();
  feedSize=config.get(""String_Node_Str"").defaultTo(ReconFeeder.DEFAULT_FEED_SIZE).asInteger();
  correlateEmptyTargetSet=config.get(""String_Node_Str"").defaultTo(Boolean.FALSE).asBoolean();
  syncEnabled=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  linkingEnabled=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  reconSourceQueryPaging=config.get(""String_Node_Str"").defaultTo(false).asBoolean();
  reconSourceQueryPageSize=config.get(""String_Node_Str"").defaultTo(reconSourceQueryPaging ? ReconFeeder.DEFAULT_FEED_SIZE : 0).asInteger();
  LOGGER.debug(""String_Node_Str"",name);
}"
13195,"/** 
 * Execute the specified query
 * @param objectSet the object set to query
 * @param query the query parameters
 * @param collectionToPopulate the collection to populate with results
 * @param caseSensitive whether the collection should be populated in casesensitive fashion, or if false it populates as lower case only
 * @param pageSize the page size if paging
 * @param pagingCookie the cookie to use if paging, null if first page
 * @param reconContext the {@link RconciliationContext} object associated with this recon
 * @param querySide an indicator for which side of a reconciliation (source or target) a query is for
 * @return a {@link ReconQueryResult} containing the collection of (unqualified) ids
 * @throws SynchronizationException if retrieving or processing the ids failed
 */
protected ReconQueryResult query(final String objectSet,final JsonValue query,final ReconciliationContext reconContext,final Collection<String> collectionToPopulate,final boolean caseSensitive,final QuerySide querySide,int pageSize,String pagingCookie) throws SynchronizationException {
  final Collection<String> ids=collectionToPopulate;
  final JsonValue objList=new JsonValue(new ArrayList());
  final ReconQueryResult reconQueryResult=new ReconQueryResult();
  try {
    QueryRequest request=RequestUtil.buildQueryRequestFromParameterMap(objectSet,query.asMap());
    request.setPageSize(pageSize);
    request.setPagedResultsCookie(pagingCookie);
    reconContext.getService().getConnectionFactory().getConnection().query(reconContext.getService().getRouter(),request,new QueryResultHandler(){
      private boolean fullEntriesDetected=false;
      @Override public void handleError(      ResourceException error){
      }
      @Override public boolean handleResource(      Resource resource){
        if (resource.getId() == null) {
          logger.warn(""String_Node_Str"",resource);
        }
 else {
          if (fullEntriesDetected == false && hasFullEntry(resource.getContent(),querySide)) {
            fullEntriesDetected=true;
            logger.debug(""String_Node_Str"");
          }
          if (fullEntriesDetected) {
            objList.add(resource.getContent());
          }
          ids.add(caseSensitive ? resource.getId() : reconContext.getObjectMapping().getLinkType().normalizeId(resource.getId()));
        }
        return true;
      }
      @Override public void handleResult(      QueryResult result){
        reconQueryResult.setPagingCookie(result.getPagedResultsCookie());
      }
    }
);
  }
 catch (  JsonValueException jve) {
    throw new SynchronizationException(jve);
  }
catch (  ResourceException ose) {
    throw new SynchronizationException(ose);
  }
  reconContext.checkCanceled();
  reconQueryResult.setResultIterable(new ResultIterable(ids,objList.size() > 0 ? objList : null));
  return reconQueryResult;
}","/** 
 * Execute the specified query
 * @param objectSet the object set to query
 * @param query the query parameters
 * @param collectionToPopulate the collection to populate with results
 * @param caseSensitive whether the collection should be populated in casesensitive fashion, or if false it populates as lower case only
 * @param pageSize the page size if paging
 * @param pagingCookie the cookie to use if paging, null if first page
 * @param reconContext the {@link RconciliationContext} object associated with this recon
 * @param querySide an indicator for which side of a reconciliation (source or target) a query is for
 * @return a {@link ReconQueryResult} containing the collection of (unqualified) ids
 * @throws SynchronizationException if retrieving or processing the ids failed
 */
protected ReconQueryResult query(final String objectSet,final JsonValue query,final ReconciliationContext reconContext,final Collection<String> collectionToPopulate,final boolean caseSensitive,final QuerySide querySide,int pageSize,String pagingCookie) throws SynchronizationException {
  final Collection<String> ids=collectionToPopulate;
  final JsonValue objList=new JsonValue(new LinkedList());
  final ReconQueryResult reconQueryResult=new ReconQueryResult();
  try {
    QueryRequest request=RequestUtil.buildQueryRequestFromParameterMap(objectSet,query.asMap());
    request.setPageSize(pageSize);
    request.setPagedResultsCookie(pagingCookie);
    reconContext.getService().getConnectionFactory().getConnection().query(reconContext.getService().getRouter(),request,new QueryResultHandler(){
      private boolean fullEntriesDetected=false;
      @Override public void handleError(      ResourceException error){
      }
      @Override public boolean handleResource(      Resource resource){
        if (resource.getId() == null) {
          logger.warn(""String_Node_Str"",resource);
        }
 else {
          if (fullEntriesDetected == false && hasFullEntry(resource.getContent(),querySide)) {
            fullEntriesDetected=true;
            logger.debug(""String_Node_Str"");
          }
          if (fullEntriesDetected) {
            objList.add(resource.getContent());
          }
          ids.add(caseSensitive ? resource.getId() : reconContext.getObjectMapping().getLinkType().normalizeId(resource.getId()));
        }
        return true;
      }
      @Override public void handleResult(      QueryResult result){
        reconQueryResult.setPagingCookie(result.getPagedResultsCookie());
      }
    }
);
  }
 catch (  JsonValueException jve) {
    throw new SynchronizationException(jve);
  }
catch (  ResourceException ose) {
    throw new SynchronizationException(ose);
  }
  reconContext.checkCanceled();
  reconQueryResult.setResultIterable(new ResultIterable(ids,objList.size() > 0 ? objList : null));
  return reconQueryResult;
}"
13196,"/** 
 * {@inheritDoc}
 */
@Override public ReconQueryResult querySource(int pageSize,String pagingCookie) throws SynchronizationException {
  return query(sourceQuery.get(""String_Node_Str"").asString(),sourceQuery,reconContext,((Collection<String>)Collections.synchronizedList(new ArrayList<String>())),true,QuerySide.SOURCE,pageSize,pagingCookie);
}","/** 
 * {@inheritDoc}
 */
@Override public ReconQueryResult querySource(int pageSize,String pagingCookie) throws SynchronizationException {
  return query(sourceQuery.get(""String_Node_Str"").asString(),sourceQuery,reconContext,Collections.synchronizedSet(new LinkedHashSet<String>()),true,QuerySide.SOURCE,pageSize,pagingCookie);
}"
13197,"/** 
 * {@inheritDoc}
 */
@Override public ResultIterable queryTarget() throws SynchronizationException {
  return query(targetQuery.get(""String_Node_Str"").asString(),targetQuery,reconContext,Collections.synchronizedList(new ArrayList<String>()),reconContext.getObjectMapping().getLinkType().isTargetCaseSensitive(),QuerySide.TARGET,0,null).getResultIterable();
}","/** 
 * {@inheritDoc}
 */
@Override public ResultIterable queryTarget() throws SynchronizationException {
  return query(targetQuery.get(""String_Node_Str"").asString(),targetQuery,reconContext,Collections.synchronizedSet(new LinkedHashSet<String>()),reconContext.getObjectMapping().getLinkType().isTargetCaseSensitive(),QuerySide.TARGET,0,null).getResultIterable();
}"
13198,"private void logAuditAccessEntry(final ServerContext context,final AuditState state,final ResourceException resourceException){
  if (!context.containsContext(HttpContext.class) || context.containsContext(InternalServerContext.class)) {
    return;
  }
  final long elapsedTime=System.currentTimeMillis() - state.actionTime;
  final AccessAuditEventBuilder accessAuditEventBuilder=new AccessAuditEventBuilder();
  accessAuditEventBuilder.forHttpCrestRequest(context,state.request).authorizationIdFromSecurityContext(context).serverFromHttpContext(context).resourceOperationFromRequest(state.request).clientFromHttpContext(context).transactionIdFromRootContext(context).timestamp(System.currentTimeMillis()).authenticationFromSecurityContext(context).eventName(""String_Node_Str"");
  if (resourceException != null) {
    accessAuditEventBuilder.responseWithMessage(""String_Node_Str"" + String.valueOf(resourceException.getCode()),elapsedTime,resourceException.getReason());
  }
 else {
    accessAuditEventBuilder.response(""String_Node_Str"",elapsedTime);
  }
  try {
    final CreateRequest createRequest=Requests.newCreateRequest(""String_Node_Str"",accessAuditEventBuilder.toEvent().getValue());
    connectionFactory.getConnection().create(context,createRequest);
  }
 catch (  ResourceException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}","private void logAuditAccessEntry(final ServerContext context,final AuditState state,final ResourceException resourceException){
  if (!context.containsContext(HttpContext.class) || context.containsContext(InternalServerContext.class)) {
    return;
  }
  final long elapsedTime=System.currentTimeMillis() - state.actionTime;
  final AccessAuditEventBuilder accessAuditEventBuilder=new AccessAuditEventBuilder();
  accessAuditEventBuilder.forHttpCrestRequest(context,state.request).authorizationIdFromSecurityContext(context).serverFromHttpContext(context).resourceOperationFromRequest(state.request).clientFromHttpContext(context).transactionIdFromRootContext(context).timestamp(System.currentTimeMillis()).authenticationFromSecurityContext(context).eventName(""String_Node_Str"");
  if (resourceException != null) {
    accessAuditEventBuilder.responseWithMessage(""String_Node_Str"" + String.valueOf(resourceException.getCode()),elapsedTime,resourceException.getReason());
  }
 else {
    accessAuditEventBuilder.response(""String_Node_Str"",elapsedTime);
  }
  try {
    final CreateRequest createRequest=Requests.newCreateRequest(""String_Node_Str"",accessAuditEventBuilder.toEvent().getValue());
    connectionFactory.getConnection().create(new InternalServerContext(context),createRequest);
  }
 catch (  ResourceException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}"
13199,"/** 
 * Calls buildAuditEvent() and invokes the request to the audit path.
 * @param connectionFactory
 * @throws ResourceException
 */
public final void log(ConnectionFactory connectionFactory) throws ResourceException {
  try {
    T eventBuilder=getEventBuilder().transactionIdFromRootContext(context).timestamp(System.currentTimeMillis()).eventName(getEventName()).authenticationFromSecurityContext(context).action(null != syncOperation ? syncOperation.action : null).exception(exception).linkQualifier(linkQualifier).mapping(mapping).message(message).messageDetail(messageDetail).situation(null != syncOperation ? syncOperation.situation : null).sourceObjectId(sourceObjectId).status(status).targetObjectId(targetObjectId);
    AuditEvent auditEvent=applyCustomFields(eventBuilder).toEvent();
    connectionFactory.getConnection().create(new ServerContext(context),Requests.newCreateRequest(getAuditPath(),auditEvent.getValue()));
  }
 catch (  ResourceException e) {
    throw e;
  }
catch (  Exception e) {
    throw new InternalServerErrorException(e.getMessage(),e);
  }
}","/** 
 * Calls buildAuditEvent() and invokes the request to the audit path.
 * @param connectionFactory
 * @throws ResourceException
 */
public final void log(ConnectionFactory connectionFactory) throws ResourceException {
  try {
    T eventBuilder=getEventBuilder().transactionIdFromRootContext(context).timestamp(System.currentTimeMillis()).eventName(getEventName()).authenticationFromSecurityContext(context).action(null != syncOperation ? syncOperation.action : null).exception(exception).linkQualifier(linkQualifier).mapping(mapping).message(message).messageDetail(messageDetail).situation(null != syncOperation ? syncOperation.situation : null).sourceObjectId(sourceObjectId).status(status).targetObjectId(targetObjectId);
    AuditEvent auditEvent=applyCustomFields(eventBuilder).toEvent();
    connectionFactory.getConnection().create(context,Requests.newCreateRequest(getAuditPath(),auditEvent.getValue()));
  }
 catch (  ResourceException e) {
    throw e;
  }
catch (  Exception e) {
    throw new InternalServerErrorException(e.getMessage(),e);
  }
}"
13200,"public void execute(JobExecutionContext context) throws JobExecutionException {
  JobDataMap data=context.getMergedJobDataMap();
  String invokeLogLevel=(String)data.get(ScheduledService.CONFIGURED_INVOKE_LOG_LEVEL);
  logLevel=LogUtil.asLogLevel(invokeLogLevel);
  String invokeService=(String)data.get(ScheduledService.CONFIGURED_INVOKE_SERVICE);
  Object invokeContext=data.get(ScheduledService.CONFIGURED_INVOKE_CONTEXT);
  ServiceTracker scheduledServiceTracker=(ServiceTracker)getServiceTracker(invokeService);
  logger.debug(""String_Node_Str"",new Object[]{invokeService,invokeContext,context});
  logger.debug(""String_Node_Str"",new Object[]{invokeService,context});
  Map<String,Object> scheduledServiceContext=new HashMap<String,Object>();
  scheduledServiceContext.putAll(data);
  scheduledServiceContext.put(ScheduledService.INVOKER_NAME,""String_Node_Str"" + context.getJobDetail().getName() + ""String_Node_Str""+ context.getScheduledFireTime());
  scheduledServiceContext.put(ScheduledService.SCHEDULED_FIRE_TIME,context.getScheduledFireTime());
  scheduledServiceContext.put(ScheduledService.ACTUAL_FIRE_TIME,context.getFireTime());
  scheduledServiceContext.put(ScheduledService.NEXT_FIRE_TIME,context.getNextFireTime());
  ScheduledService scheduledService=(ScheduledService)scheduledServiceTracker.getService();
  if (scheduledService == null) {
    logger.info(""String_Node_Str"",invokeService);
  }
 else {
    final long startTime=System.currentTimeMillis();
    final ServerContext serverContext=newScheduledServerContext((String)scheduledServiceContext.get(ScheduledService.INVOKER_NAME));
    try {
      LogUtil.logAtLevel(logger,logLevel,""String_Node_Str"",context.getJobDetail().getFullName());
      scheduledService.execute(serverContext,scheduledServiceContext);
      scheduledService.auditScheduledService(serverContext,createScheduledAuditEvent(serverContext,startTime,context,Status.SUCCESS,null));
      LogUtil.logAtLevel(logger,logLevel,""String_Node_Str"",context.getJobDetail().getFullName());
    }
 catch (    Exception ex) {
      logger.warn(""String_Node_Str"",new Object[]{context.getJobDetail().getFullName(),ex.getMessage(),ex});
      try {
        scheduledService.auditScheduledService(serverContext,createScheduledAuditEvent(serverContext,startTime,context,Status.FAILURE,ex));
      }
 catch (      ExecutionException exception) {
        logger.error(""String_Node_Str"",context.getJobDetail().getFullName(),exception);
      }
    }
  }
  scheduledServiceTracker.close();
}","public void execute(JobExecutionContext context) throws JobExecutionException {
  JobDataMap data=context.getMergedJobDataMap();
  String invokeLogLevel=(String)data.get(ScheduledService.CONFIGURED_INVOKE_LOG_LEVEL);
  logLevel=LogUtil.asLogLevel(invokeLogLevel);
  String invokeService=(String)data.get(ScheduledService.CONFIGURED_INVOKE_SERVICE);
  Object invokeContext=data.get(ScheduledService.CONFIGURED_INVOKE_CONTEXT);
  ServiceTracker scheduledServiceTracker=(ServiceTracker)getServiceTracker(invokeService);
  logger.debug(""String_Node_Str"",new Object[]{invokeService,invokeContext,context});
  logger.debug(""String_Node_Str"",invokeService,context);
  Map<String,Object> scheduledServiceContext=new HashMap<>();
  scheduledServiceContext.putAll(data);
  scheduledServiceContext.put(ScheduledService.INVOKER_NAME,""String_Node_Str"" + context.getJobDetail().getName() + ""String_Node_Str""+ context.getScheduledFireTime());
  scheduledServiceContext.put(ScheduledService.SCHEDULED_FIRE_TIME,context.getScheduledFireTime());
  scheduledServiceContext.put(ScheduledService.ACTUAL_FIRE_TIME,context.getFireTime());
  scheduledServiceContext.put(ScheduledService.NEXT_FIRE_TIME,context.getNextFireTime());
  ScheduledService scheduledService=(ScheduledService)scheduledServiceTracker.getService();
  if (scheduledService == null) {
    logger.info(""String_Node_Str"",invokeService);
  }
 else {
    final long startTime=System.currentTimeMillis();
    final ServerContext serverContext=newScheduledServerContext((String)scheduledServiceContext.get(ScheduledService.INVOKER_NAME));
    try {
      LogUtil.logAtLevel(logger,logLevel,""String_Node_Str"",context.getJobDetail().getFullName());
      scheduledService.execute(serverContext,scheduledServiceContext);
      scheduledService.auditScheduledService(serverContext,createScheduledAuditEvent(serverContext,startTime,context,Status.SUCCESS,null));
      LogUtil.logAtLevel(logger,logLevel,""String_Node_Str"",context.getJobDetail().getFullName());
    }
 catch (    Exception ex) {
      logger.warn(""String_Node_Str"",new Object[]{context.getJobDetail().getFullName(),ex.getMessage(),ex});
      try {
        scheduledService.auditScheduledService(serverContext,createScheduledAuditEvent(serverContext,startTime,context,Status.FAILURE,ex));
      }
 catch (      ExecutionException exception) {
        logger.error(""String_Node_Str"",context.getJobDetail().getFullName(),exception);
      }
    }
  }
  scheduledServiceTracker.close();
}"
13201,"/** 
 * {@inheritDoc}
 */
@Override public void log(ServerContext context,Request request,String message,String objectId,JsonValue before,JsonValue after,Status status) throws ResourceException {
  if (null == request) {
    throw new NullPointerException(""String_Node_Str"");
  }
  try {
    String authenticationId=getRequester(context);
    String revision=getRevision(before,after);
    boolean passwordChanged=false;
    String[] changedFields=new String[0];
    RequestType requestType=request.getRequestType();
    String beforeValue=getJsonForLog(before,requestType);
    String afterValue=getJsonForLog(after,requestType);
    AuditEvent auditEvent=OpenIDMActivityAuditEventBuilder.auditEventBuilder().transactionIdFromRootContext(context).timestamp(System.currentTimeMillis()).eventName(ACTIVITY_EVENT_NAME).authenticationFromSecurityContext(context).runAs(authenticationId).resourceOperationFromRequest(request).before(beforeValue).after(afterValue).changedFields(changedFields).revision(revision).message(message).objectId(objectId).passwordChanged(passwordChanged).status(status).toEvent();
    connectionFactory.getConnection().create(new ServerContext(context),Requests.newCreateRequest(AUDIT_ACTIVITY_PATH,auditEvent.getValue()));
  }
 catch (  ResourceException ex) {
    if (suspendException) {
      logger.warn(""String_Node_Str"",ex);
    }
 else {
      throw ex;
    }
  }
catch (  Exception ex) {
    if (suspendException) {
      logger.warn(""String_Node_Str"",ex);
    }
 else {
      throw new InternalServerErrorException(ex.getMessage(),ex);
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void log(ServerContext context,Request request,String message,String objectId,JsonValue before,JsonValue after,Status status) throws ResourceException {
  if (null == request) {
    throw new NullPointerException(""String_Node_Str"");
  }
  try {
    String authenticationId=getRequester(context);
    String revision=getRevision(before,after);
    boolean passwordChanged=false;
    String[] changedFields=new String[0];
    RequestType requestType=request.getRequestType();
    String beforeValue=getJsonForLog(before,requestType);
    String afterValue=getJsonForLog(after,requestType);
    AuditEvent auditEvent=OpenIDMActivityAuditEventBuilder.auditEventBuilder().transactionIdFromRootContext(context).timestamp(System.currentTimeMillis()).eventName(ACTIVITY_EVENT_NAME).authenticationFromSecurityContext(context).runAs(authenticationId).resourceOperationFromRequest(request).before(beforeValue).after(afterValue).changedFields(changedFields).revision(revision).message(message).objectId(objectId).passwordChanged(passwordChanged).status(status).toEvent();
    connectionFactory.getConnection().create(context,Requests.newCreateRequest(AUDIT_ACTIVITY_PATH,auditEvent.getValue()));
  }
 catch (  ResourceException ex) {
    if (suspendException) {
      logger.warn(""String_Node_Str"",ex);
    }
 else {
      throw ex;
    }
  }
catch (  Exception ex) {
    if (suspendException) {
      logger.warn(""String_Node_Str"",ex);
    }
 else {
      throw new InternalServerErrorException(ex.getMessage(),ex);
    }
  }
}"
13202,"public ActivitiResource(ProcessEngine engine){
  resources.addRoute(""String_Node_Str"",new ProcessDefinitionResource(engine));
  resources.addRoute(""String_Node_Str"",new TaskDefinitionResource(engine));
  resources.addRoute(""String_Node_Str"",new ProcessInstanceResource(engine,engine.getHistoryService().createHistoricProcessInstanceQuery().unfinished()));
  resources.addRoute(""String_Node_Str"",new ProcessInstanceResource(engine,engine.getHistoryService().createHistoricProcessInstanceQuery()));
  resources.addRoute(""String_Node_Str"",new TaskInstanceResource(engine));
  resources.addRoute(""String_Node_Str"",new TaskInstanceHistoryResource(engine));
}","public ActivitiResource(ProcessEngine engine){
  resources.addRoute(""String_Node_Str"",new ProcessDefinitionResource(engine));
  resources.addRoute(""String_Node_Str"",new TaskDefinitionResource(engine));
  resources.addRoute(""String_Node_Str"",new ProcessInstanceResource(engine,new Function<ProcessEngine,HistoricProcessInstanceQuery,NeverThrowsException>(){
    public HistoricProcessInstanceQuery apply(    ProcessEngine engine){
      return engine.getHistoryService().createHistoricProcessInstanceQuery().unfinished();
    }
  }
));
  resources.addRoute(""String_Node_Str"",new ProcessInstanceResource(engine,new Function<ProcessEngine,HistoricProcessInstanceQuery,NeverThrowsException>(){
    public HistoricProcessInstanceQuery apply(    ProcessEngine engine){
      return engine.getHistoryService().createHistoricProcessInstanceQuery();
    }
  }
));
  resources.addRoute(""String_Node_Str"",new TaskInstanceResource(engine));
  resources.addRoute(""String_Node_Str"",new TaskInstanceHistoryResource(engine));
}"
13203,"@Override public void queryCollection(ServerContext context,QueryRequest request,QueryResultHandler handler){
  try {
    Authentication.setAuthenticatedUserId(context.asContext(SecurityContext.class).getAuthenticationId());
    if (ActivitiConstants.QUERY_ALL_IDS.equals(request.getQueryId())) {
      for (      HistoricProcessInstance i : historicProcessInstanceQuery.list()) {
        Map<String,Object> value=MAPPER.convertValue(i,Map.class);
        value.put(ActivitiConstants.ACTIVITI_PROCESSDEFINITIONRESOURCENAME,getProcessDefName(i));
        Resource r=new Resource(i.getId(),null,new JsonValue(value));
        handler.handleResource(r);
      }
      handler.handleResult(new QueryResult());
    }
 else     if (ActivitiConstants.QUERY_FILTERED.equals(request.getQueryId())) {
      setProcessInstanceParams(historicProcessInstanceQuery,request);
      setSortKeys(historicProcessInstanceQuery,request);
      for (      HistoricProcessInstance processinstance : historicProcessInstanceQuery.list()) {
        Map<String,Object> value=MAPPER.convertValue(processinstance,Map.class);
        value.put(ActivitiConstants.ACTIVITI_PROCESSDEFINITIONRESOURCENAME,getProcessDefName(processinstance));
        handler.handleResource(new Resource(processinstance.getId(),null,new JsonValue(value)));
      }
      handler.handleResult(new QueryResult());
    }
 else {
      handler.handleError(new BadRequestException(""String_Node_Str""));
    }
  }
 catch (  Exception ex) {
    handler.handleError(new InternalServerErrorException(ex.getMessage(),ex));
  }
}","@Override public void queryCollection(ServerContext context,QueryRequest request,QueryResultHandler handler){
  try {
    Authentication.setAuthenticatedUserId(context.asContext(SecurityContext.class).getAuthenticationId());
    final HistoricProcessInstanceQuery query=queryFunction.apply(processEngine);
    if (ActivitiConstants.QUERY_ALL_IDS.equals(request.getQueryId())) {
      for (      HistoricProcessInstance i : query.list()) {
        Map<String,Object> value=MAPPER.convertValue(i,Map.class);
        value.put(ActivitiConstants.ACTIVITI_PROCESSDEFINITIONRESOURCENAME,getProcessDefName(i));
        Resource r=new Resource(i.getId(),null,new JsonValue(value));
        handler.handleResource(r);
      }
      handler.handleResult(new QueryResult());
    }
 else     if (ActivitiConstants.QUERY_FILTERED.equals(request.getQueryId())) {
      setProcessInstanceParams(query,request);
      setSortKeys(query,request);
      for (      HistoricProcessInstance processinstance : query.list()) {
        Map<String,Object> value=MAPPER.convertValue(processinstance,Map.class);
        value.put(ActivitiConstants.ACTIVITI_PROCESSDEFINITIONRESOURCENAME,getProcessDefName(processinstance));
        handler.handleResource(new Resource(processinstance.getId(),null,new JsonValue(value)));
      }
      handler.handleResult(new QueryResult());
    }
 else {
      handler.handleError(new BadRequestException(""String_Node_Str""));
    }
  }
 catch (  Exception ex) {
    handler.handleError(new InternalServerErrorException(ex.getMessage(),ex));
  }
}"
13204,"public ProcessInstanceResource(ProcessEngine processEngine,HistoricProcessInstanceQuery query){
  this.processEngine=processEngine;
  historicProcessInstanceQuery=query;
}","/** 
 * Create a new ProcessInstanceResource.
 * @param processEngine Activiti engine used for this resource
 * @param queryFunction a Function to provide a the properly-configured HistoricProcessInstanceQuery as appropriatefor the type of query issued by this CollectionResourceProvider; allows this class to support both present and historic queries
 */
public ProcessInstanceResource(ProcessEngine processEngine,Function<ProcessEngine,HistoricProcessInstanceQuery,NeverThrowsException> queryFunction){
  this.processEngine=processEngine;
  this.queryFunction=queryFunction;
}"
13205,"private JsonValue applyDefaultMappings(JsonValue source,JsonValue oldSource,JsonValue target,JsonValue existingTarget,String linkQualifier) throws SynchronizationException {
  JsonValue result=null;
  if (defaultMapping != null) {
    Map<String,Object> queryScope=new HashMap<String,Object>();
    queryScope.put(""String_Node_Str"",source.asMap());
    if (oldSource != null) {
      queryScope.put(""String_Node_Str"",oldSource.asMap());
    }
    queryScope.put(""String_Node_Str"",target.asMap());
    queryScope.put(""String_Node_Str"",config.asMap());
    queryScope.put(""String_Node_Str"",existingTarget.asMap());
    queryScope.put(""String_Node_Str"",linkQualifier);
    try {
      result=json(defaultMapping.exec(queryScope));
    }
 catch (    ScriptThrownException ste) {
      throw toSynchronizationException(ste,name,""String_Node_Str"");
    }
catch (    ScriptException se) {
      LOGGER.debug(""String_Node_Str"",name,se);
      throw new SynchronizationException(se);
    }
  }
  return result;
}","private JsonValue applyDefaultMappings(JsonValue source,JsonValue oldSource,JsonValue target,JsonValue existingTarget,String linkQualifier) throws SynchronizationException {
  JsonValue result=null;
  if (defaultMapping != null) {
    Map<String,Object> queryScope=new HashMap<String,Object>();
    queryScope.put(""String_Node_Str"",source.asMap());
    if (oldSource != null) {
      queryScope.put(""String_Node_Str"",oldSource.asMap());
    }
    queryScope.put(""String_Node_Str"",target.asMap());
    queryScope.put(""String_Node_Str"",config.asMap());
    queryScope.put(""String_Node_Str"",existingTarget.copy().asMap());
    queryScope.put(""String_Node_Str"",linkQualifier);
    try {
      result=json(defaultMapping.exec(queryScope));
    }
 catch (    ScriptThrownException ste) {
      throw toSynchronizationException(ste,name,""String_Node_Str"");
    }
catch (    ScriptException se) {
      LOGGER.debug(""String_Node_Str"",name,se);
      throw new SynchronizationException(se);
    }
  }
  return result;
}"
13206,"public boolean setAttributesToGet(final OperationOptionsBuilder builder,final List<JsonPointer> fieldFilters){
  boolean returnResource=false;
  if (null != fieldFilters) {
    for (    JsonPointer field : fieldFilters) {
      if (field.isEmpty() || returnResource || !Resource.FIELD_CONTENT_ID.equals(field.leaf())|| !Resource.FIELD_CONTENT_REVISION.equals(field.leaf())) {
        returnResource=true;
      }
      if (field.isEmpty()) {
        builder.setAttributesToGet(attributesReturnedByDefault);
        continue;
      }
      for (      AttributeInfoHelper attribute : attributes) {
        if (attribute.getName().equals(field.leaf()) && attribute.getAttributeInfo().isReadable()) {
          builder.setAttributesToGet(attribute.getAttributeInfo().getName());
          break;
        }
      }
    }
  }
  return returnResource;
}","public boolean setAttributesToGet(final OperationOptionsBuilder builder,final List<JsonPointer> fieldFilters){
  boolean returnResource=false;
  if (null != fieldFilters) {
    Set<String> attrsToGet=new HashSet();
    for (    JsonPointer field : fieldFilters) {
      if (field.isEmpty() || returnResource || !Resource.FIELD_CONTENT_ID.equals(field.leaf())|| !Resource.FIELD_CONTENT_REVISION.equals(field.leaf())) {
        returnResource=true;
      }
      if (field.isEmpty()) {
        attrsToGet.addAll(attributesReturnedByDefault);
        continue;
      }
      for (      AttributeInfoHelper attribute : attributes) {
        if (attribute.getName().equals(field.leaf()) && attribute.getAttributeInfo().isReadable()) {
          attrsToGet.add(attribute.getAttributeInfo().getName());
          break;
        }
      }
    }
    builder.setAttributesToGet(attrsToGet);
  }
  return returnResource;
}"
13207,"/** 
 * Stores a KeyPair (associated with a CSR request on the specified alias) in the repository.
 * @param alias the alias from the CSR
 * @param keyPair the KeyPair object
 * @throws JsonResourceException
 */
protected void storeKeyPair(String alias,KeyPair keyPair) throws ResourceException {
  try {
    JsonValue keyPairValue=new JsonValue(new HashMap<String,Object>());
    keyPairValue.put(""String_Node_Str"",toPem(keyPair));
    JsonValue encrypted=getCryptoService().encrypt(keyPairValue,cryptoCipher,cryptoAlias);
    JsonValue keyMap=new JsonValue(new HashMap<String,Object>());
    keyMap.put(""String_Node_Str"",encrypted);
    storeInRepo(KEYS_CONTAINER,alias,keyMap);
  }
 catch (  Exception e) {
    throw ResourceException.getException(ResourceException.INTERNAL_ERROR,e.getMessage(),e);
  }
}","/** 
 * Stores a KeyPair (associated with a CSR request on the specified alias) in the repository.
 * @param alias the alias from the CSR
 * @param keyPair the KeyPair object
 * @throws JsonResourceException
 */
protected void storeKeyPair(String alias,KeyPair keyPair) throws ResourceException {
  try {
    JsonValue keyPairValue=new JsonValue(new HashMap<String,Object>());
    keyPairValue.put(""String_Node_Str"",toPem(keyPair));
    JsonValue encrypted=getCryptoService().encrypt(keyPairValue,cryptoCipher,cryptoAlias);
    JsonValue keyMap=new JsonValue(new HashMap<String,Object>());
    keyMap.put(""String_Node_Str"",encrypted.getObject());
    storeInRepo(KEYS_CONTAINER,alias,keyMap);
  }
 catch (  Exception e) {
    throw ResourceException.getException(ResourceException.INTERNAL_ERROR,e.getMessage(),e);
  }
}"
13208,"public void unregisterConfigService(ScheduleConfigService service){
synchronized (CONFIG_SERVICE_LOCK) {
    if (!started) {
      configMap.remove(service.getJobName());
    }
 else {
    }
  }
}","/** 
 * Unregisters a   {@link ScheduleConfigService} and deletes the schedule if the scheduler has been started.
 * @param service the {@link ScheduleConfigService} to register.
 * @throws SchedulerException
 * @throws ParseException
 */
public void unregisterConfigService(ScheduleConfigService service){
synchronized (CONFIG_SERVICE_LOCK) {
    logger.debug(""String_Node_Str"");
    configMap.remove(service.getJobName());
    if (started) {
      try {
        logger.debug(""String_Node_Str"",service.getJobName());
        deleteSchedule(service.getJobName());
      }
 catch (      SchedulerException e) {
        logger.warn(""String_Node_Str"",service.getJobName(),e.getMessage());
      }
    }
  }
}"
13209,"public void registerConfigService(ScheduleConfigService service) throws SchedulerException, ParseException {
synchronized (CONFIG_SERVICE_LOCK) {
    logger.debug(""String_Node_Str"");
    configMap.put(service.getJobName(),service);
    if (!started) {
      logger.debug(""String_Node_Str"",service.getJobName());
    }
 else {
      logger.debug(""String_Node_Str"",service.getJobName());
      try {
        addSchedule(service.getScheduleConfig(),service.getJobName(),true);
      }
 catch (      ObjectAlreadyExistsException e) {
        logger.debug(""String_Node_Str"",service.getJobName());
      }
    }
  }
}","/** 
 * Registers a   {@link ScheduleConfigService} and adds the scheduler if the scheduler has been started.
 * @param service the {@link ScheduleConfigService} to register.
 * @throws SchedulerException
 * @throws ParseException
 */
public void registerConfigService(ScheduleConfigService service) throws SchedulerException, ParseException {
synchronized (CONFIG_SERVICE_LOCK) {
    logger.debug(""String_Node_Str"");
    configMap.put(service.getJobName(),service);
    if (!started) {
      logger.debug(""String_Node_Str"",service.getJobName());
    }
 else {
      try {
        logger.debug(""String_Node_Str"",service.getJobName());
        addSchedule(service.getScheduleConfig(),service.getJobName(),true);
      }
 catch (      ObjectAlreadyExistsException e) {
        logger.debug(""String_Node_Str"",service.getJobName());
      }
    }
  }
}"
13210,"/** 
 * Deletes a schedule from the scheduler
 * @throws SchedulerException 
 */
public void deleteSchedule(String jobName) throws SchedulerException {
  if (inMemoryScheduler.getJobDetail(jobName,GROUP_NAME) != null) {
    inMemoryScheduler.deleteJob(jobName,GROUP_NAME);
  }
  if (persistentScheduler.getJobDetail(jobName,GROUP_NAME) != null) {
    persistentScheduler.deleteJob(jobName,GROUP_NAME);
  }
}","/** 
 * Deletes a schedule from the scheduler
 * @param jobName the job name associated with this schedule.
 * @throws SchedulerException 
 */
public void deleteSchedule(String jobName) throws SchedulerException {
  if (inMemoryScheduler.getJobDetail(jobName,GROUP_NAME) != null) {
    inMemoryScheduler.deleteJob(jobName,GROUP_NAME);
  }
  if (persistentScheduler.getJobDetail(jobName,GROUP_NAME) != null) {
    persistentScheduler.deleteJob(jobName,GROUP_NAME);
  }
}"
13211,"/** 
 * @see org.forgerock.openidm.repo.jdbc.TableHandler#read(java.lang.String,java.lang.String,java.lang.String,java.sql.Connection)
 */
@Override public Resource read(String fullId,String type,String localId,Connection connection) throws NotFoundException, SQLException, IOException, InternalServerErrorException {
  JsonValue resultValue=null;
  Resource result=null;
  PreparedStatement readStatement=null;
  ResultSet rs=null;
  try {
    readStatement=queries.getPreparedStatement(connection,readQueryStr);
    logger.debug(""String_Node_Str"",readStatement,fullId);
    readStatement.setString(1,localId);
    logger.debug(""String_Node_Str"",readStatement);
    rs=readStatement.executeQuery();
    if (rs.next()) {
      resultValue=explicitMapping.mapToJsonValue(rs,Mapping.getColumnNames(rs));
      JsonValue rev=resultValue.get(""String_Node_Str"");
      logger.debug(""String_Node_Str"",new Object[]{fullId,rev,resultValue});
      result=new Resource(fullId,rev.asString(),resultValue);
    }
 else {
      throw new NotFoundException(""String_Node_Str"" + fullId + ""String_Node_Str""+ type);
    }
  }
  finally {
    CleanupHelper.loggedClose(rs);
    CleanupHelper.loggedClose(readStatement);
  }
  return result;
}","/** 
 * @see org.forgerock.openidm.repo.jdbc.TableHandler#read(java.lang.String,java.lang.String,java.lang.String,java.sql.Connection)
 */
@Override public Resource read(String fullId,String type,String localId,Connection connection) throws NotFoundException, SQLException, IOException, InternalServerErrorException {
  JsonValue resultValue=null;
  Resource result=null;
  PreparedStatement readStatement=null;
  ResultSet rs=null;
  try {
    readStatement=queries.getPreparedStatement(connection,readQueryStr);
    logger.debug(""String_Node_Str"",readStatement,fullId);
    readStatement.setString(1,localId);
    logger.debug(""String_Node_Str"",readStatement);
    rs=readStatement.executeQuery();
    if (rs.next()) {
      resultValue=explicitMapping.mapToJsonValue(rs,Mapping.getColumnNames(rs));
      JsonValue rev=resultValue.get(""String_Node_Str"");
      logger.debug(""String_Node_Str"",new Object[]{fullId,rev,resultValue});
      result=new Resource(localId,rev.asString(),resultValue);
    }
 else {
      throw new NotFoundException(""String_Node_Str"" + fullId + ""String_Node_Str""+ type);
    }
  }
  finally {
    CleanupHelper.loggedClose(rs);
    CleanupHelper.loggedClose(readStatement);
  }
  return result;
}"
13212,"/** 
 * Returns a JsonValue map representing a certificate
 * @param alias  the certificate alias
 * @param cert  The certificate
 * @return a JsonValue map representing the certificate
 * @throws Exception
 */
protected JsonValue returnCertificate(String alias,Certificate cert) throws Exception {
  JsonValue content=new JsonValue(new LinkedHashMap<String,Object>());
  content.put(Resource.FIELD_CONTENT_ID,alias);
  content.put(""String_Node_Str"",cert.getType());
  content.put(""String_Node_Str"",getCertString(cert));
  content.put(""String_Node_Str"",getKeyMap(cert.getPublicKey()));
  if (cert instanceof X509Certificate) {
    Map<String,Object> issuer=new HashMap<String,Object>();
    X500Name name=X500Name.getInstance(PrincipalUtil.getIssuerX509Principal((X509Certificate)cert));
    issuer.put(""String_Node_Str"",name.getRDNs(BCStyle.C)[0].getFirst().getValue().toString());
    issuer.put(""String_Node_Str"",name.getRDNs(BCStyle.ST)[0].getFirst().getValue().toString());
    issuer.put(""String_Node_Str"",name.getRDNs(BCStyle.L)[0].getFirst().getValue().toString());
    issuer.put(""String_Node_Str"",name.getRDNs(BCStyle.OU)[0].getFirst().getValue().toString());
    issuer.put(""String_Node_Str"",name.getRDNs(BCStyle.O)[0].getFirst().getValue().toString());
    issuer.put(""String_Node_Str"",name.getRDNs(BCStyle.CN)[0].getFirst().getValue().toString());
    content.put(""String_Node_Str"",issuer);
    content.put(""String_Node_Str"",((X509Certificate)cert).getNotBefore());
    content.put(""String_Node_Str"",((X509Certificate)cert).getNotAfter());
  }
  return content;
}","/** 
 * Returns a JsonValue map representing a certificate
 * @param alias  the certificate alias
 * @param cert  The certificate
 * @return a JsonValue map representing the certificate
 * @throws Exception
 */
protected JsonValue returnCertificate(String alias,Certificate cert) throws Exception {
  JsonValue content=new JsonValue(new LinkedHashMap<String,Object>());
  content.put(Resource.FIELD_CONTENT_ID,alias);
  content.put(""String_Node_Str"",cert.getType());
  content.put(""String_Node_Str"",getCertString(cert));
  content.put(""String_Node_Str"",getKeyMap(cert.getPublicKey()));
  if (cert instanceof X509Certificate) {
    Map<String,Object> issuer=new HashMap<String,Object>();
    X500Name name=X500Name.getInstance(PrincipalUtil.getIssuerX509Principal((X509Certificate)cert));
    addAttributeToIssuer(issuer,name,""String_Node_Str"",BCStyle.C);
    addAttributeToIssuer(issuer,name,""String_Node_Str"",BCStyle.ST);
    addAttributeToIssuer(issuer,name,""String_Node_Str"",BCStyle.L);
    addAttributeToIssuer(issuer,name,""String_Node_Str"",BCStyle.OU);
    addAttributeToIssuer(issuer,name,""String_Node_Str"",BCStyle.O);
    addAttributeToIssuer(issuer,name,""String_Node_Str"",BCStyle.CN);
    content.put(""String_Node_Str"",issuer);
    content.put(""String_Node_Str"",((X509Certificate)cert).getNotBefore());
    content.put(""String_Node_Str"",((X509Certificate)cert).getNotAfter());
  }
  return content;
}"
13213,"public boolean evaluateOnResponse(final ServerContext context,final ScriptState state,final Resource resource) throws ResourceException {
  if (onResponse != null) {
    ScriptEntry scriptEntry=onResponse.getRight();
    if (!scriptEntry.isActive()) {
      throw new ServiceUnavailableException(""String_Node_Str"" + onResponse.getRight().getName());
    }
    Script script=populateScript(scriptEntry,context,state.request);
    script.put(""String_Node_Str"",resource);
    try {
      state.state=script.eval();
    }
 catch (    Throwable t) {
      logger.debug(""String_Node_Str"",onResponse.getRight().getName(),onResponse.getLeft(),t);
      throw Utils.adapt(t);
    }
  }
  return true;
}","public boolean evaluateOnResponse(final ServerContext context,final ScriptState state,final Resource resource) throws ResourceException {
  if (onResponse != null) {
    ScriptEntry scriptEntry=onResponse.getRight();
    if (!scriptEntry.isActive()) {
      throw new ServiceUnavailableException(""String_Node_Str"" + onResponse.getRight().getName());
    }
    Script script=populateScript(scriptEntry,context,state.request);
    script.put(""String_Node_Str"",resource.getContent());
    try {
      state.state=script.eval();
    }
 catch (    Throwable t) {
      logger.debug(""String_Node_Str"",onResponse.getRight().getName(),onResponse.getLeft(),t);
      throw Utils.adapt(t);
    }
  }
  return true;
}"
13214,"public Attribute filterAttribute(JsonPointer field,Object valueAssertion){
  if (field.size() != 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String attributeName=field.leaf();
  for (  AttributeInfoHelper ai : attributes) {
    if (ai.getName().equals(attributeName)) {
      return ai.build(valueAssertion);
    }
  }
  return null;
}","public Attribute filterAttribute(JsonPointer field,Object valueAssertion){
  if (field.size() != 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String attributeName=field.leaf();
  for (  AttributeInfoHelper ai : attributes) {
    if (ai.getName().equals(attributeName)) {
      return ai.build(valueAssertion);
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"" + attributeName + ""String_Node_Str""+ objectClass);
}"
13215,"@Override public void handleCreate(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  try {
    String id=request.getNewResourceId() == null ? UUID.randomUUID().toString() : trimTrailingSlash(request.getNewResourceId());
    Map<String,Object> object=request.getContent().asMap();
    object.put(""String_Node_Str"",id);
    if (jobExists(id)) {
      throw new ConflictException(""String_Node_Str"");
    }
    ScheduleConfig scheduleConfig=new ScheduleConfig(new JsonValue(object));
    if (scheduleConfig.isEnabled() == null) {
      scheduleConfig.setEnabled(true);
    }
    if (scheduleConfig.isPersisted() == null) {
      scheduleConfig.setPersisted(true);
    }
    addSchedule(scheduleConfig,id,false);
    handler.handleResult(new Resource(id,null,getSchedule(request.getResourceName())));
  }
 catch (  ParseException e) {
    handler.handleError(new BadRequestException(e.getMessage(),e));
  }
catch (  ObjectAlreadyExistsException e) {
    handler.handleError(new ConflictException(e.getMessage(),e));
  }
catch (  SchedulerException e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
catch (  JsonException e) {
    handler.handleError(new BadRequestException(""String_Node_Str"",e));
  }
catch (  Throwable t) {
    handler.handleError(ResourceUtil.adapt(t));
  }
}","@Override public void handleCreate(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  try {
    String id=request.getNewResourceId() == null ? UUID.randomUUID().toString() : request.getNewResourceId();
    Map<String,Object> object=request.getContent().asMap();
    object.put(""String_Node_Str"",id);
    if (jobExists(id)) {
      throw new ConflictException(""String_Node_Str"");
    }
    ScheduleConfig scheduleConfig=new ScheduleConfig(new JsonValue(object));
    if (scheduleConfig.isEnabled() == null) {
      scheduleConfig.setEnabled(true);
    }
    if (scheduleConfig.isPersisted() == null) {
      scheduleConfig.setPersisted(true);
    }
    addSchedule(scheduleConfig,id,false);
    handler.handleResult(new Resource(id,null,getSchedule(id)));
  }
 catch (  ParseException e) {
    handler.handleError(new BadRequestException(e.getMessage(),e));
  }
catch (  ObjectAlreadyExistsException e) {
    handler.handleError(new ConflictException(e.getMessage(),e));
  }
catch (  SchedulerException e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
catch (  JsonException e) {
    handler.handleError(new BadRequestException(""String_Node_Str"",e));
  }
catch (  Throwable t) {
    handler.handleError(ResourceUtil.adapt(t));
  }
}"
13216,"@Override public void handleQuery(ServerContext context,QueryRequest request,QueryResultHandler handler){
  try {
    String queryId=request.getQueryId();
    if (queryId == null) {
      throw new BadRequestException(""String_Node_Str"");
    }
    Map<String,Object> resultMap=null;
    if (queryId.equals(""String_Node_Str"")) {
      String[] persistentJobNames=null;
      persistentJobNames=persistentScheduler.getJobNames(GROUP_NAME);
      String[] inMemoryJobNames=inMemoryScheduler.getJobNames(GROUP_NAME);
      List<Map<String,String>> resultList=new ArrayList<Map<String,String>>();
      if (persistentJobNames != null) {
        for (        String job : persistentJobNames) {
          Map<String,String> idMap=new HashMap<String,String>();
          idMap.put(""String_Node_Str"",job);
          resultList.add(idMap);
        }
      }
      if (inMemoryJobNames != null) {
        for (        String job : inMemoryJobNames) {
          Map<String,String> idMap=new HashMap<String,String>();
          idMap.put(""String_Node_Str"",job);
          resultList.add(idMap);
        }
      }
      resultMap=new HashMap<String,Object>();
      resultMap.put(QueryResult.FIELD_RESULT,resultList);
    }
 else {
      throw new ForbiddenException(""String_Node_Str"" + queryId);
    }
    for (    Map<String,String> r : (List<Map<String,String>>)resultMap.get(QueryResult.FIELD_RESULT)) {
      handler.handleResource(new Resource(r.get(""String_Node_Str""),null,new JsonValue(r)));
    }
    handler.handleResult(new QueryResult());
  }
 catch (  SchedulerException e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
catch (  JsonException e) {
    handler.handleError(new BadRequestException(""String_Node_Str"",e));
  }
catch (  Throwable t) {
    handler.handleError(ResourceUtil.adapt(t));
  }
}","@Override public void handleQuery(ServerContext context,QueryRequest request,QueryResultHandler handler){
  try {
    String queryId=request.getQueryId();
    if (queryId == null) {
      throw new BadRequestException(""String_Node_Str"");
    }
    Map<String,Object> resultMap=null;
    if (queryId.equals(""String_Node_Str"")) {
      String[] persistentJobNames=null;
      persistentJobNames=persistentScheduler.getJobNames(GROUP_NAME);
      String[] inMemoryJobNames=inMemoryScheduler.getJobNames(GROUP_NAME);
      List<Map<String,String>> resultList=new ArrayList<Map<String,String>>();
      if (persistentJobNames != null) {
        for (        String job : persistentJobNames) {
          Map<String,String> idMap=new HashMap<String,String>();
          idMap.put(""String_Node_Str"",job);
          resultList.add(idMap);
        }
      }
      if (inMemoryJobNames != null) {
        for (        String job : inMemoryJobNames) {
          Map<String,String> idMap=new HashMap<String,String>();
          idMap.put(""String_Node_Str"",job);
          resultList.add(idMap);
        }
      }
      resultMap=new HashMap<String,Object>();
      resultMap.put(QueryResult.FIELD_RESULT,resultList);
    }
 else {
      throw new BadRequestException(""String_Node_Str"" + queryId);
    }
    for (    Map<String,String> r : (List<Map<String,String>>)resultMap.get(QueryResult.FIELD_RESULT)) {
      handler.handleResource(new Resource(r.get(""String_Node_Str""),null,new JsonValue(r)));
    }
    handler.handleResult(new QueryResult());
  }
 catch (  SchedulerException e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
catch (  JsonException e) {
    handler.handleError(new BadRequestException(""String_Node_Str"",e));
  }
catch (  Throwable t) {
    handler.handleError(ResourceUtil.adapt(t));
  }
}"
13217,"@Override public void handleDelete(ServerContext context,DeleteRequest request,ResultHandler<Resource> handler){
  try {
    if (request.getResourceNameObject().isEmpty()) {
      throw new BadRequestException(""String_Node_Str"");
    }
    if (jobExists(request.getResourceName(),true)) {
      persistentScheduler.deleteJob(request.getResourceName(),GROUP_NAME);
    }
 else     if (jobExists(request.getResourceName(),false)) {
      inMemoryScheduler.deleteJob(request.getResourceName(),GROUP_NAME);
    }
 else {
      throw new NotFoundException(""String_Node_Str"");
    }
    handler.handleResult(new Resource(request.getResourceName(),null,new JsonValue(null)));
  }
 catch (  JsonException e) {
    handler.handleError(new BadRequestException(""String_Node_Str"",e));
  }
catch (  SchedulerException e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
catch (  Throwable t) {
    handler.handleError(ResourceUtil.adapt(t));
  }
}","@Override public void handleDelete(ServerContext context,DeleteRequest request,ResultHandler<Resource> handler){
  try {
    if (request.getResourceNameObject().isEmpty()) {
      throw new BadRequestException(""String_Node_Str"");
    }
    Scheduler scheduler=getScheduler(request.getResourceName());
    JsonValue schedule=getSchedule(scheduler,request.getResourceName());
    scheduler.deleteJob(request.getResourceName(),GROUP_NAME);
    handler.handleResult(new Resource(request.getResourceName(),null,schedule));
  }
 catch (  JsonException e) {
    handler.handleError(new BadRequestException(""String_Node_Str"",e));
  }
catch (  SchedulerException e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
catch (  Throwable t) {
    handler.handleError(ResourceUtil.adapt(t));
  }
}"
13218,"/** 
 * Returns the Scheduler corresponding to whether the supplied schedule configuration is persistent.
 * @param scheduleConfig    The schedule configuration
 * @return                  The Scheduler
 * @throws SchedulerException
 */
private Scheduler getScheduler(ScheduleConfig scheduleConfig) throws SchedulerException {
  if (scheduleConfig.getPersisted()) {
    return persistentScheduler;
  }
  return inMemoryScheduler;
}","/** 
 * Returns the scheduler containing the schedule with the supplied name.
 * @param scheduleName the name of the schedule
 * @return the Scheduler
 * @throws SchedulerException
 * @throws NotFoundException
 */
private Scheduler getScheduler(String scheduleName) throws SchedulerException, NotFoundException {
  if (jobExists(scheduleName,true)) {
    return persistentScheduler;
  }
 else   if (jobExists(scheduleName,false)) {
    return inMemoryScheduler;
  }
 else {
    throw new NotFoundException(""String_Node_Str"");
  }
}"
13219,"@Override public void handleRead(ServerContext context,ReadRequest request,ResultHandler<Resource> handler){
  try {
    if (request.getResourceNameObject().isEmpty()) {
      throw new BadRequestException(""String_Node_Str"");
    }
    Scheduler scheduler=null;
    if (jobExists(request.getResourceName(),true)) {
      scheduler=persistentScheduler;
    }
 else     if (jobExists(request.getResourceName(),false)) {
      scheduler=inMemoryScheduler;
    }
 else {
      throw new NotFoundException(""String_Node_Str"");
    }
    JobDetail job=scheduler.getJobDetail(request.getResourceName(),GROUP_NAME);
    JobDataMap dataMap=job.getJobDataMap();
    ScheduleConfig config=new ScheduleConfig(parseStringified((String)dataMap.get(CONFIG)));
    Map<String,Object> resultMap=(Map<String,Object>)config.getConfig().getObject();
    resultMap.put(""String_Node_Str"",request.getResourceName());
    handler.handleResult(new Resource(request.getResourceName(),null,new JsonValue(resultMap)));
  }
 catch (  SchedulerException e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
catch (  Throwable t) {
    handler.handleError(ResourceUtil.adapt(t));
  }
}","@Override public void handleRead(ServerContext context,ReadRequest request,ResultHandler<Resource> handler){
  try {
    if (request.getResourceNameObject().isEmpty()) {
      throw new BadRequestException(""String_Node_Str"");
    }
    Scheduler scheduler=getScheduler(request.getResourceName());
    JsonValue schedule=getSchedule(scheduler,request.getResourceName());
    handler.handleResult(new Resource(request.getResourceName(),null,schedule));
  }
 catch (  SchedulerException e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
catch (  Throwable t) {
    handler.handleError(ResourceUtil.adapt(t));
  }
}"
13220,"/** 
 * Gets an object from the object set by identifier. <p/> The object may contain metadata properties, including object identifier   {@code _id}, and object version   {@code _rev} to enable optimistic concurrency supported by OpenIDM.
 * @param resourceName the identifier of the resource to retrieve from the object set.
 * @return the requested object.
 * @throws NotFoundException   if the specified object could not be found.
 * @throws ForbiddenException  if access to the object is forbidden.
 * @throws BadRequestException if the passed identifier is invalid
 */
public Map<String,Object> read(ResourceName resourceName) throws ResourceException {
  logger.debug(""String_Node_Str"",resourceName.toString());
  Map<String,Object> result=null;
  try {
    if (resourceName.isEmpty()) {
      result=new HashMap<String,Object>();
      Configuration[] rawConfigs=configAdmin.listConfigurations(null);
      List configList=new ArrayList();
      if (null != rawConfigs) {
        for (        Configuration conf : rawConfigs) {
          Map<String,Object> configEntry=new LinkedHashMap<String,Object>();
          String alias=null;
          Dictionary properties=conf.getProperties();
          if (properties != null) {
            alias=(String)properties.get(JSONConfigInstaller.SERVICE_FACTORY_PID_ALIAS);
          }
          String pid=ConfigBootstrapHelper.unqualifyPid(conf.getPid());
          String factoryPid=ConfigBootstrapHelper.unqualifyPid(conf.getFactoryPid());
          String id=factoryPid != null && alias != null ? factoryPid + ""String_Node_Str"" + alias : pid;
          configEntry.put(""String_Node_Str"",id);
          configEntry.put(""String_Node_Str"",pid);
          configEntry.put(""String_Node_Str"",factoryPid);
          configList.add(configEntry);
        }
      }
      result.put(""String_Node_Str"",configList);
      logger.debug(""String_Node_Str"",configList.size());
    }
 else {
      Configuration config=findExistingConfiguration(new ParsedId(resourceName));
      if (config == null) {
        throw new NotFoundException(""String_Node_Str"" + resourceName.toString());
      }
      Dictionary props=config.getProperties();
      JSONEnhancedConfig enhancedConfig=new JSONEnhancedConfig();
      JsonValue value=enhancedConfig.getConfiguration(props,resourceName.toString(),false);
      result=value.asMap();
      logger.debug(""String_Node_Str"",resourceName);
    }
  }
 catch (  ResourceException ex) {
    throw ex;
  }
catch (  Exception ex) {
    logger.warn(""String_Node_Str"",resourceName,ex);
    throw new InternalServerErrorException(""String_Node_Str"" + resourceName + ""String_Node_Str""+ ex.getMessage(),ex);
  }
  return result;
}","/** 
 * Gets an object from the object set by identifier. <p/> The object may contain metadata properties, including object identifier   {@code _id}, and object version   {@code _rev} to enable optimistic concurrency supported by OpenIDM.
 * @param resourceName the identifier of the resource to retrieve from the object set.
 * @return the requested object.
 * @throws NotFoundException   if the specified object could not be found.
 * @throws ForbiddenException  if access to the object is forbidden.
 * @throws BadRequestException if the passed identifier is invalid
 */
public JsonValue read(ResourceName resourceName) throws ResourceException {
  logger.debug(""String_Node_Str"",resourceName.toString());
  JsonValue result=null;
  try {
    if (resourceName.isEmpty()) {
      result=new JsonValue(new HashMap<String,Object>());
      Configuration[] rawConfigs=configAdmin.listConfigurations(null);
      List configList=new ArrayList();
      if (null != rawConfigs) {
        for (        Configuration conf : rawConfigs) {
          Map<String,Object> configEntry=new LinkedHashMap<String,Object>();
          String alias=null;
          Dictionary properties=conf.getProperties();
          if (properties != null) {
            alias=(String)properties.get(JSONConfigInstaller.SERVICE_FACTORY_PID_ALIAS);
          }
          String pid=ConfigBootstrapHelper.unqualifyPid(conf.getPid());
          String factoryPid=ConfigBootstrapHelper.unqualifyPid(conf.getFactoryPid());
          String id=factoryPid != null && alias != null ? factoryPid + ""String_Node_Str"" + alias : pid;
          configEntry.put(""String_Node_Str"",id);
          configEntry.put(""String_Node_Str"",pid);
          configEntry.put(""String_Node_Str"",factoryPid);
          configList.add(configEntry);
        }
      }
      result.put(""String_Node_Str"",configList);
      logger.debug(""String_Node_Str"",configList.size());
    }
 else {
      Configuration config=findExistingConfiguration(new ParsedId(resourceName));
      if (config == null) {
        throw new NotFoundException(""String_Node_Str"" + resourceName.toString());
      }
      Dictionary props=config.getProperties();
      JSONEnhancedConfig enhancedConfig=new JSONEnhancedConfig();
      result=enhancedConfig.getConfiguration(props,resourceName.toString(),false);
      logger.debug(""String_Node_Str"",resourceName);
    }
  }
 catch (  ResourceException ex) {
    throw ex;
  }
catch (  Exception ex) {
    logger.warn(""String_Node_Str"",resourceName,ex);
    throw new InternalServerErrorException(""String_Node_Str"" + resourceName + ""String_Node_Str""+ ex.getMessage(),ex);
  }
  return result;
}"
13221,"/** 
 * Updates the specified object in the object set. <p/> This implementation requires MVCC and hence enforces that clients state what revision they expect to be updating <p/> If successful, this method updates metadata properties within the passed object, including: a new   {@code _rev} value for the revised object's version
 * @param resourceName the identifier of the resource to be updated
 * @param rev    the version of the object to update; or {@code null} if not provided.
 * @param obj    the contents of the object to put in the object set.
 * @throws ConflictException           if version is required but is {@code null}.
 * @throws ForbiddenException          if access to the object is forbidden.
 * @throws NotFoundException           if the specified object could not be found.
 * @throws PreconditionFailedException if version did not match the existing object in the set.
 * @throws BadRequestException         if the passed identifier is invalid
 */
public void update(ResourceName resourceName,String rev,Map<String,Object> obj) throws ResourceException {
  logger.debug(""String_Node_Str"",resourceName.toString(),rev);
  if (resourceName.isEmpty()) {
    throw new BadRequestException(""String_Node_Str"");
  }
 else   if (resourceName.size() > 2) {
    throw new BadRequestException(""String_Node_Str"");
  }
  try {
    ParsedId parsedId=new ParsedId(resourceName);
    Configuration config=findExistingConfiguration(parsedId);
    Dictionary existingConfig=(config == null ? null : config.getProperties());
    if (existingConfig == null) {
      throw new NotFoundException(""String_Node_Str"" + resourceName.toString() + ""String_Node_Str"");
    }
    existingConfig=configCrypto.encrypt(parsedId.getPidOrFactoryPid(),parsedId.instanceAlias,existingConfig,new JsonValue(obj));
    config.update(existingConfig);
    logger.debug(""String_Node_Str"",resourceName.toString(),existingConfig);
  }
 catch (  ResourceException ex) {
    throw ex;
  }
catch (  Exception ex) {
    logger.warn(""String_Node_Str"",resourceName.toString(),ex);
    throw new InternalServerErrorException(""String_Node_Str"" + resourceName.toString() + ""String_Node_Str""+ ex.getMessage(),ex);
  }
}","/** 
 * Updates the specified object in the object set. <p/> This implementation requires MVCC and hence enforces that clients state what revision they expect to be updating <p/> If successful, this method updates metadata properties within the passed object, including: a new   {@code _rev} value for the revised object's version
 * @param resourceName the identifier of the resource to be updated
 * @param rev    the version of the object to update; or {@code null} if not provided.
 * @param obj    the contents of the object to put in the object set.
 * @throws ConflictException           if version is required but is {@code null}.
 * @throws ForbiddenException          if access to the object is forbidden.
 * @throws NotFoundException           if the specified object could not be found.
 * @throws PreconditionFailedException if version did not match the existing object in the set.
 * @throws BadRequestException         if the passed identifier is invalid
 */
public void update(ResourceName resourceName,String rev,Map<String,Object> obj) throws ResourceException {
  logger.debug(""String_Node_Str"",resourceName.toString(),rev);
  if (resourceName.isEmpty()) {
    throw new BadRequestException(""String_Node_Str"");
  }
 else   if (resourceName.size() > 2) {
    throw new BadRequestException(""String_Node_Str"");
  }
  ParsedId parsedId=new ParsedId(resourceName);
  try {
    Configuration config=findExistingConfiguration(parsedId);
    Dictionary existingConfig=(config == null ? null : config.getProperties());
    if (existingConfig == null) {
      throw new NotFoundException(""String_Node_Str"" + resourceName.toString() + ""String_Node_Str"");
    }
    existingConfig=configCrypto.encrypt(parsedId.getPidOrFactoryPid(),parsedId.instanceAlias,existingConfig,new JsonValue(obj));
    config.update(existingConfig);
    logger.debug(""String_Node_Str"",resourceName.toString(),existingConfig);
  }
 catch (  ResourceException ex) {
    throw ex;
  }
catch (  JsonValueException ex) {
    logger.warn(""String_Node_Str"" + ex.getMessage(),resourceName.toString(),ex);
    throw new BadRequestException(""String_Node_Str"" + resourceName.toString() + ""String_Node_Str""+ ex.getMessage(),ex);
  }
catch (  WaitForMetaData ex) {
    logger.info(""String_Node_Str"",parsedId.toString(),ex);
    throw new InternalServerErrorException(""String_Node_Str"" + parsedId.toString() + ""String_Node_Str"",ex);
  }
catch (  Exception ex) {
    logger.warn(""String_Node_Str"",resourceName.toString(),ex);
    throw new InternalServerErrorException(""String_Node_Str"" + resourceName.toString() + ""String_Node_Str""+ ex.getMessage(),ex);
  }
}"
13222,"/** 
 * Deletes the specified object from the object set.
 * @param resourceName the identifier of the resource to be deleted.
 * @param rev    the version of the object to delete or {@code null} if not provided.
 * @throws NotFoundException           if the specified object could not be found.
 * @throws ForbiddenException          if access to the object is forbidden.
 * @throws ConflictException           if version is required but is {@code null}.
 * @throws PreconditionFailedException if version did not match the existing object in the set.
 */
public void delete(ResourceName resourceName,String rev) throws ResourceException {
  logger.debug(""String_Node_Str"",resourceName.toString(),rev);
  if (resourceName.isEmpty()) {
    throw new BadRequestException(""String_Node_Str"");
  }
  try {
    Configuration config=findExistingConfiguration(new ParsedId(resourceName));
    Dictionary existingConfig=config.getProperties();
    if (existingConfig == null) {
      throw new NotFoundException(""String_Node_Str"" + resourceName.toString() + ""String_Node_Str"");
    }
    config.delete();
    logger.debug(""String_Node_Str"",resourceName.toString());
  }
 catch (  ResourceException ex) {
    throw ex;
  }
catch (  Exception ex) {
    logger.warn(""String_Node_Str"",resourceName.toString(),ex);
    throw new InternalServerErrorException(""String_Node_Str"" + resourceName.toString() + ""String_Node_Str""+ ex.getMessage(),ex);
  }
}","/** 
 * Deletes the specified object from the object set.
 * @param resourceName the identifier of the resource to be deleted.
 * @param rev    the version of the object to delete or {@code null} if not provided.
 * @return the deleted object.
 * @throws NotFoundException           if the specified object could not be found.
 * @throws ForbiddenException          if access to the object is forbidden.
 * @throws ConflictException           if version is required but is {@code null}.
 * @throws PreconditionFailedException if version did not match the existing object in the set.
 */
public JsonValue delete(ResourceName resourceName,String rev) throws ResourceException {
  logger.debug(""String_Node_Str"",resourceName.toString(),rev);
  if (resourceName.isEmpty()) {
    throw new BadRequestException(""String_Node_Str"");
  }
  try {
    Configuration config=findExistingConfiguration(new ParsedId(resourceName));
    if (config == null) {
      throw new NotFoundException(""String_Node_Str"" + resourceName.toString() + ""String_Node_Str"");
    }
    Dictionary existingConfig=config.getProperties();
    JSONEnhancedConfig enhancedConfig=new JSONEnhancedConfig();
    JsonValue value=enhancedConfig.getConfiguration(existingConfig,resourceName.toString(),false);
    if (existingConfig == null) {
      throw new NotFoundException(""String_Node_Str"" + resourceName.toString() + ""String_Node_Str"");
    }
    config.delete();
    logger.debug(""String_Node_Str"",resourceName.toString());
    return value;
  }
 catch (  ResourceException ex) {
    throw ex;
  }
catch (  Exception ex) {
    logger.warn(""String_Node_Str"",resourceName.toString(),ex);
    throw new InternalServerErrorException(""String_Node_Str"" + resourceName.toString() + ""String_Node_Str""+ ex.getMessage(),ex);
  }
}"
13223,"@Override public void handleDelete(ServerContext context,DeleteRequest request,ResultHandler<Resource> handler){
  try {
    String rev=request.getRevision();
    delete(request.getResourceNameObject(),rev);
    Resource resource=new Resource(request.getResourceName(),null,new JsonValue(null));
    handler.handleResult(resource);
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}","@Override public void handleDelete(ServerContext context,DeleteRequest request,ResultHandler<Resource> handler){
  try {
    String rev=request.getRevision();
    Resource resource=new Resource(request.getResourceName(),null,delete(request.getResourceNameObject(),rev));
    handler.handleResult(resource);
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}"
13224,"/** 
 * Creates a new object in the object set. <p/> This method sets the   {@code _id} property to the assigned identifier for the object,and the  {@code _rev} property to the revised object version (For optimistic concurrency)
 * @param resourceName for multi-instance config, the factory pid to use
 * @param id the client-generated identifier to use, or {@code null} if server-generated identifier is requested.
 * @param obj    the contents of the object to create in the object set.
 * @throws NotFoundException           if the specified id could not be resolved.
 * @throws ForbiddenException          if access to the object or object set is forbidden.
 * @throws PreconditionFailedException if an object with the same ID already exists.
 * @throws BadRequestException         if the passed identifier is invalid
 */
public void create(ResourceName resourceName,String id,Map<String,Object> obj) throws ResourceException {
  logger.debug(""String_Node_Str"",new Object[]{resourceName.toString(),id,obj});
  if (id == null || id.length() == 0) {
    throw new BadRequestException(""String_Node_Str"");
  }
  ParsedId parsedId=new ParsedId(resourceName,id);
  try {
    Configuration config=null;
    if (parsedId.isFactoryConfig()) {
      String qualifiedFactoryPid=ConfigBootstrapHelper.qualifyPid(parsedId.factoryPid);
      if (""String_Node_Str"".equalsIgnoreCase(qualifiedFactoryPid)) {
        throw new BadRequestException(""String_Node_Str"");
      }
      config=configAdmin.createFactoryConfiguration(qualifiedFactoryPid,null);
    }
 else {
      String qualifiedPid=ConfigBootstrapHelper.qualifyPid(parsedId.pid);
      config=configAdmin.getConfiguration(qualifiedPid,null);
    }
    if (config.getProperties() != null) {
      throw new PreconditionFailedException(""String_Node_Str"" + parsedId + ""String_Node_Str"");
    }
    Dictionary dict=configCrypto.encrypt(parsedId.getPidOrFactoryPid(),parsedId.instanceAlias,null,new JsonValue(obj));
    if (parsedId.isFactoryConfig()) {
      dict.put(JSONConfigInstaller.SERVICE_FACTORY_PID_ALIAS,parsedId.instanceAlias);
    }
    config.update(dict);
    logger.debug(""String_Node_Str"",parsedId.toString(),dict);
  }
 catch (  ResourceException ex) {
    throw ex;
  }
catch (  WaitForMetaData ex) {
    logger.info(""String_Node_Str"",parsedId.toString(),ex);
    throw new InternalServerErrorException(""String_Node_Str"" + parsedId.toString() + ""String_Node_Str"",ex);
  }
catch (  Exception ex) {
    logger.warn(""String_Node_Str"",parsedId.toString(),ex);
    throw new InternalServerErrorException(""String_Node_Str"" + parsedId.toString() + ""String_Node_Str""+ ex.getMessage(),ex);
  }
}","/** 
 * Creates a new object in the object set. <p/> This method sets the   {@code _id} property to the assigned identifier for the object,and the  {@code _rev} property to the revised object version (For optimistic concurrency)
 * @param resourceName for multi-instance config, the factory pid to use
 * @param id the client-generated identifier to use, or {@code null} if server-generated identifier is requested.
 * @param obj    the contents of the object to create in the object set.
 * @throws NotFoundException           if the specified id could not be resolved.
 * @throws ForbiddenException          if access to the object or object set is forbidden.
 * @throws PreconditionFailedException if an object with the same ID already exists.
 * @throws BadRequestException         if the passed identifier is invalid
 */
public void create(ResourceName resourceName,String id,Map<String,Object> obj) throws ResourceException {
  logger.debug(""String_Node_Str"",new Object[]{resourceName.toString(),id,obj});
  if (id == null || id.length() == 0) {
    throw new BadRequestException(""String_Node_Str"");
  }
  ParsedId parsedId=new ParsedId(resourceName,id);
  try {
    Configuration config=null;
    if (parsedId.isFactoryConfig()) {
      String qualifiedFactoryPid=ConfigBootstrapHelper.qualifyPid(parsedId.factoryPid);
      if (""String_Node_Str"".equalsIgnoreCase(qualifiedFactoryPid)) {
        throw new BadRequestException(""String_Node_Str"");
      }
      config=configAdmin.createFactoryConfiguration(qualifiedFactoryPid,null);
    }
 else {
      String qualifiedPid=ConfigBootstrapHelper.qualifyPid(parsedId.pid);
      config=configAdmin.getConfiguration(qualifiedPid,null);
    }
    if (config.getProperties() != null) {
      throw new PreconditionFailedException(""String_Node_Str"" + parsedId + ""String_Node_Str"");
    }
    Dictionary dict=configCrypto.encrypt(parsedId.getPidOrFactoryPid(),parsedId.instanceAlias,null,new JsonValue(obj));
    if (parsedId.isFactoryConfig()) {
      dict.put(JSONConfigInstaller.SERVICE_FACTORY_PID_ALIAS,parsedId.instanceAlias);
    }
    config.update(dict);
    logger.debug(""String_Node_Str"",parsedId.toString(),dict);
  }
 catch (  ResourceException ex) {
    throw ex;
  }
catch (  JsonValueException ex) {
    logger.warn(""String_Node_Str"" + ex.getMessage(),resourceName.toString(),ex);
    throw new BadRequestException(""String_Node_Str"" + resourceName.toString() + ""String_Node_Str""+ ex.getMessage(),ex);
  }
catch (  WaitForMetaData ex) {
    logger.info(""String_Node_Str"",parsedId.toString(),ex);
    throw new InternalServerErrorException(""String_Node_Str"" + parsedId.toString() + ""String_Node_Str"",ex);
  }
catch (  Exception ex) {
    logger.warn(""String_Node_Str"",parsedId.toString(),ex);
    throw new InternalServerErrorException(""String_Node_Str"" + parsedId.toString() + ""String_Node_Str""+ ex.getMessage(),ex);
  }
}"
13225,"/** 
 * {@inheritDoc}
 */
public List<JsonPointer> getPropertiesToEncrypt(String pidOrFactory,String instanceAlias,JsonValue config) throws WaitForMetaData {
  List<JsonPointer> result=null;
  if (null != pidOrFactory && null != config) {
    if (PID.equals(pidOrFactory)) {
      try {
        JsonValue remoteConnectorHosts=config.get(ConnectorUtil.OPENICF_REMOTE_CONNECTOR_SERVERS).expect(List.class);
        if (!remoteConnectorHosts.isNull()) {
          result=new ArrayList<JsonPointer>(remoteConnectorHosts.size());
          for (          JsonValue hostConfig : remoteConnectorHosts) {
            result.add(hostConfig.get(ConnectorUtil.OPENICF_KEY).getPointer());
          }
        }
      }
 catch (      JsonValueException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
 else     if (OpenICFProvisionerService.PID.equals(pidOrFactory)) {
      if (isOSGiServiceInstance) {
        ConfigurationProperties properties=null;
        try {
          ConnectorReference connectorReference=ConnectorUtil.getConnectorReference(config);
          ConnectorInfo ci=findConnectorInfo(connectorReference);
          if (null != ci) {
            properties=ci.createDefaultAPIConfiguration().getConfigurationProperties();
          }
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"",new Object[]{pidOrFactory,instanceAlias},e);
        }
        if (null != properties) {
          JsonPointer configurationProperties=new JsonPointer(ConnectorUtil.OPENICF_CONFIGURATION_PROPERTIES);
          result=new ArrayList<JsonPointer>(properties.getPropertyNames().size());
          for (          String name : properties.getPropertyNames()) {
            ConfigurationProperty property=properties.getProperty(name);
            if (property.isConfidential() || property.getType().equals(GuardedString.class) || property.getType().equals(GuardedByteArray.class)) {
              result.add(configurationProperties.child(name));
            }
          }
        }
 else {
          throw new WaitForMetaData(pidOrFactory);
        }
      }
 else {
        throw new WaitForMetaData(""String_Node_Str"");
      }
    }
  }
  return result;
}","/** 
 * {@inheritDoc}
 */
public List<JsonPointer> getPropertiesToEncrypt(String pidOrFactory,String instanceAlias,JsonValue config) throws WaitForMetaData {
  List<JsonPointer> result=null;
  if (null != pidOrFactory && null != config) {
    if (PID.equals(pidOrFactory)) {
      try {
        JsonValue remoteConnectorHosts=config.get(ConnectorUtil.OPENICF_REMOTE_CONNECTOR_SERVERS).expect(List.class);
        if (!remoteConnectorHosts.isNull()) {
          result=new ArrayList<JsonPointer>(remoteConnectorHosts.size());
          for (          JsonValue hostConfig : remoteConnectorHosts) {
            result.add(hostConfig.get(ConnectorUtil.OPENICF_KEY).getPointer());
          }
        }
      }
 catch (      JsonValueException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
 else     if (OpenICFProvisionerService.PID.equals(pidOrFactory)) {
      if (isOSGiServiceInstance) {
        ConfigurationProperties properties=null;
        try {
          ConnectorReference connectorReference=ConnectorUtil.getConnectorReference(config);
          ConnectorInfo ci=findConnectorInfo(connectorReference);
          if (null != ci) {
            properties=ci.createDefaultAPIConfiguration().getConfigurationProperties();
          }
        }
 catch (        JsonValueException jve) {
          throw jve;
        }
catch (        Exception e) {
          logger.error(""String_Node_Str"",new Object[]{pidOrFactory,instanceAlias,e.getMessage()},e);
        }
        if (null != properties) {
          JsonPointer configurationProperties=new JsonPointer(ConnectorUtil.OPENICF_CONFIGURATION_PROPERTIES);
          result=new ArrayList<JsonPointer>(properties.getPropertyNames().size());
          for (          String name : properties.getPropertyNames()) {
            ConfigurationProperty property=properties.getProperty(name);
            if (property.isConfidential() || property.getType().equals(GuardedString.class) || property.getType().equals(GuardedByteArray.class)) {
              result.add(configurationProperties.child(name));
            }
          }
        }
 else {
          throw new WaitForMetaData(pidOrFactory);
        }
      }
 else {
        throw new WaitForMetaData(""String_Node_Str"");
      }
    }
  }
  return result;
}"
13226,"protected Map<QueryDefinition,String> initializeQueryMap(){
  Map<QueryDefinition,String> result=super.initializeQueryMap();
  String typeTable=dbSchemaName == null ? ""String_Node_Str"" : dbSchemaName + ""String_Node_Str"";
  String mainTable=dbSchemaName == null ? mainTableName : dbSchemaName + ""String_Node_Str"" + mainTableName;
  String propertyTable=dbSchemaName == null ? propTableName : dbSchemaName + ""String_Node_Str"" + propTableName;
  result.put(QueryDefinition.UPDATEQUERYSTR,""String_Node_Str"" + mainTable + ""String_Node_Str"");
  result.put(QueryDefinition.CREATEQUERYSTR,""String_Node_Str"" + mainTable + ""String_Node_Str"");
  result.put(QueryDefinition.PROPDELETEQUERYSTR,""String_Node_Str"" + propertyTable + ""String_Node_Str""+ mainTableName+ ""String_Node_Str""+ mainTable+ ""String_Node_Str""+ typeTable+ ""String_Node_Str"");
  return result;
}","protected Map<QueryDefinition,String> initializeQueryMap(){
  Map<QueryDefinition,String> result=super.initializeQueryMap();
  String typeTable=dbSchemaName == null ? ""String_Node_Str"" : dbSchemaName + ""String_Node_Str"";
  String mainTable=dbSchemaName == null ? mainTableName : dbSchemaName + ""String_Node_Str"" + mainTableName;
  String propertyTable=dbSchemaName == null ? propTableName : dbSchemaName + ""String_Node_Str"" + propTableName;
  result.put(QueryDefinition.UPDATEQUERYSTR,""String_Node_Str"" + mainTable + ""String_Node_Str"");
  result.put(QueryDefinition.CREATEQUERYSTR,""String_Node_Str"" + mainTable + ""String_Node_Str"");
  result.put(QueryDefinition.DELETEQUERYSTR,""String_Node_Str"" + mainTable + ""String_Node_Str""+ typeTable+ ""String_Node_Str"");
  result.put(QueryDefinition.PROPDELETEQUERYSTR,""String_Node_Str"" + propertyTable + ""String_Node_Str""+ mainTableName+ ""String_Node_Str""+ mainTable+ ""String_Node_Str""+ typeTable+ ""String_Node_Str"");
  return result;
}"
13227,"@Override public void actionInstance(ServerContext context,ActionRequest request,ResultHandler<JsonValue> handler){
  try {
    String alias=request.getContent().get(""String_Node_Str"").asString();
    if (ACTION_GENERATE_CERT.equalsIgnoreCase(request.getAction()) || ACTION_GENERATE_CSR.equalsIgnoreCase(request.getAction())) {
      if (alias == null) {
        throw ResourceException.getException(ResourceException.BAD_REQUEST,""String_Node_Str"");
      }
      String algorithm=request.getContent().get(""String_Node_Str"").defaultTo(DEFAULT_ALGORITHM).asString();
      String signatureAlgorithm=request.getContent().get(""String_Node_Str"").defaultTo(DEFAULT_SIGNATURE_ALGORITHM).asString();
      int keySize=request.getContent().get(""String_Node_Str"").defaultTo(DEFAULT_KEY_SIZE).asInteger();
      JsonValue result=null;
      if (ACTION_GENERATE_CERT.equalsIgnoreCase(request.getAction())) {
        if (store.getStore().containsAlias(alias)) {
          handler.handleError(new ConflictException(""String_Node_Str"" + alias + ""String_Node_Str""));
        }
 else {
          logger.info(""String_Node_Str"",alias);
          String domainName=request.getContent().get(""String_Node_Str"").required().asString();
          String validFrom=request.getContent().get(""String_Node_Str"").asString();
          String validTo=request.getContent().get(""String_Node_Str"").asString();
          Pair<X509Certificate,PrivateKey> pair=generateCertificate(domainName,algorithm,keySize,signatureAlgorithm,validFrom,validTo);
          Certificate cert=pair.getKey();
          PrivateKey key=pair.getValue();
          String password=request.getContent().get(""String_Node_Str"").defaultTo(Param.getKeystoreKeyPassword()).asString();
          logger.debug(""String_Node_Str"",alias);
          store.getStore().setCertificateEntry(alias,cert);
          store.store();
          manager.reload();
          saveStore();
          result=returnCertificate(alias,cert);
        }
      }
 else {
        Pair<PKCS10CertificationRequest,PrivateKey> csr=generateCSR(alias,algorithm,signatureAlgorithm,keySize,request.getContent());
        result=returnCertificateRequest(alias,csr.getKey());
        if (request.getContent().get(""String_Node_Str"").defaultTo(false).asBoolean()) {
          result.put(""String_Node_Str"",getKeyMap(csr.getRight()));
        }
      }
      handler.handleResult(result);
    }
 else {
      handler.handleError(new BadRequestException(""String_Node_Str"" + request.getAction()));
    }
  }
 catch (  Throwable t) {
    handler.handleError(ResourceUtil.adapt(t));
  }
}","@Override public void actionInstance(ServerContext context,ActionRequest request,ResultHandler<JsonValue> handler){
  try {
    String alias=request.getContent().get(""String_Node_Str"").asString();
    if (ACTION_GENERATE_CERT.equalsIgnoreCase(request.getAction()) || ACTION_GENERATE_CSR.equalsIgnoreCase(request.getAction())) {
      if (alias == null) {
        throw ResourceException.getException(ResourceException.BAD_REQUEST,""String_Node_Str"");
      }
      String algorithm=request.getContent().get(""String_Node_Str"").defaultTo(DEFAULT_ALGORITHM).asString();
      String signatureAlgorithm=request.getContent().get(""String_Node_Str"").defaultTo(DEFAULT_SIGNATURE_ALGORITHM).asString();
      int keySize=request.getContent().get(""String_Node_Str"").defaultTo(DEFAULT_KEY_SIZE).asInteger();
      JsonValue result=null;
      if (ACTION_GENERATE_CERT.equalsIgnoreCase(request.getAction())) {
        if (store.getStore().containsAlias(alias)) {
          handler.handleError(new ConflictException(""String_Node_Str"" + alias + ""String_Node_Str""));
        }
 else {
          logger.info(""String_Node_Str"",alias);
          String domainName=request.getContent().get(""String_Node_Str"").required().asString();
          String validFrom=request.getContent().get(""String_Node_Str"").asString();
          String validTo=request.getContent().get(""String_Node_Str"").asString();
          Pair<X509Certificate,PrivateKey> pair=generateCertificate(domainName,algorithm,keySize,signatureAlgorithm,validFrom,validTo);
          Certificate cert=pair.getKey();
          PrivateKey key=pair.getValue();
          logger.debug(""String_Node_Str"",alias);
          store.getStore().setEntry(alias,new KeyStore.PrivateKeyEntry(key,new Certificate[]{cert}),new KeyStore.PasswordProtection(store.getPassword().toCharArray()));
          store.store();
          manager.reload();
          saveStore();
          result=returnCertificate(alias,cert);
          if (request.getContent().get(""String_Node_Str"").defaultTo(false).asBoolean()) {
            result.put(""String_Node_Str"",getKeyMap(key));
          }
        }
      }
 else {
        Pair<PKCS10CertificationRequest,PrivateKey> csr=generateCSR(alias,algorithm,signatureAlgorithm,keySize,request.getContent());
        result=returnCertificateRequest(alias,csr.getKey());
        if (request.getContent().get(""String_Node_Str"").defaultTo(false).asBoolean()) {
          result.put(""String_Node_Str"",getKeyMap(csr.getRight()));
        }
      }
      handler.handleResult(result);
    }
 else {
      handler.handleError(new BadRequestException(""String_Node_Str"" + request.getAction()));
    }
  }
 catch (  Throwable t) {
    handler.handleError(ResourceUtil.adapt(t));
  }
}"
13228,"/** 
 * Adds a Trigger to the list of acquired triggers.
 * @param trigger    the Trigger to add
 * @param instanceId the instance ID
 * @throws JobPersistenceException
 * @throws ObjectSetException
 */
private void addAcquiredTrigger(Trigger trigger,String instanceId) throws JobPersistenceException {
synchronized (lock) {
    try {
      int retries=0;
      while (writeRetries == -1 || retries <= writeRetries) {
        try {
          addRepoListName(getTriggerId(trigger.getGroup(),trigger.getName()),getAcquiredTriggersRepoId(),instanceId);
          break;
        }
 catch (        PreconditionFailedException e) {
          logger.debug(""String_Node_Str"",e);
          retries++;
        }
      }
    }
 catch (    ResourceException e) {
      throw new JobPersistenceException(""String_Node_Str"",e);
    }
  }
}","/** 
 * Adds a Trigger to the list of acquired triggers.
 * @param trigger    the Trigger to add
 * @param instanceId the instance ID
 * @throws JobPersistenceException
 * @throws ObjectSetException
 */
private void addAcquiredTrigger(Trigger trigger,String instanceId) throws JobPersistenceException {
synchronized (lock) {
    try {
      logger.debug(""String_Node_Str"",new Object[]{trigger.getName(),instanceId});
      int retries=0;
      while (writeRetries == -1 || retries <= writeRetries) {
        try {
          addRepoListName(getTriggerId(trigger.getGroup(),trigger.getName()),getAcquiredTriggersRepoId(),instanceId);
          break;
        }
 catch (        PreconditionFailedException e) {
          logger.debug(""String_Node_Str"",e);
          retries++;
        }
      }
    }
 catch (    ResourceException e) {
      throw new JobPersistenceException(""String_Node_Str"",e);
    }
  }
}"
13229,"@Override public Trigger acquireNextTrigger(SchedulingContext context,long noLaterThan) throws JobPersistenceException {
synchronized (lock) {
    Trigger trigger=null;
    WaitingTriggers waitingTriggers=null;
    while (trigger == null) {
      try {
        waitingTriggers=getWaitingTriggers();
        trigger=waitingTriggers.getTriggers().first();
      }
 catch (      NoSuchElementException e1) {
        logger.debug(""String_Node_Str"");
        return null;
      }
      if (trigger == null) {
        logger.debug(""String_Node_Str"");
        return null;
      }
      Date nextFireTime=trigger.getNextFireTime();
      if (nextFireTime == null) {
        logger.debug(""String_Node_Str"");
        removeWaitingTrigger(trigger);
        trigger=null;
        continue;
      }
      if (!removeWaitingTrigger(trigger)) {
        trigger=null;
        continue;
      }
      TriggerWrapper tw=getTriggerWrapper(trigger.getGroup(),trigger.getName());
      if (hasTriggerMisfired(trigger)) {
        logger.debug(""String_Node_Str"");
        processTriggerMisfired(tw);
        if (trigger.getNextFireTime() != null) {
          addWaitingTrigger(trigger);
        }
        trigger=null;
        continue;
      }
      if (noLaterThan > 0) {
        if (nextFireTime.getTime() > noLaterThan) {
          addWaitingTrigger(trigger);
          return null;
        }
      }
      tw.setAcquired(true);
      trigger.setFireInstanceId(getFiredTriggerRecordId());
      try {
        tw.updateTrigger(trigger);
      }
 catch (      Exception e) {
        logger.warn(""String_Node_Str"",e);
        throw new JobPersistenceException(""String_Node_Str"",e);
      }
      updateTriggerInRepo(trigger.getGroup(),trigger.getName(),tw,tw.getRevision());
      addAcquiredTrigger(trigger,instanceId);
      logger.debug(""String_Node_Str"",new Object[]{trigger.getName(),trigger.getNextFireTime()});
      return (Trigger)trigger.clone();
    }
    logger.debug(""String_Node_Str"");
    return null;
  }
}","@Override public Trigger acquireNextTrigger(SchedulingContext context,long noLaterThan) throws JobPersistenceException {
synchronized (lock) {
    logger.debug(""String_Node_Str"");
    Trigger trigger=null;
    WaitingTriggers waitingTriggers=null;
    while (trigger == null) {
      try {
        waitingTriggers=getWaitingTriggers();
        trigger=waitingTriggers.getTriggers().first();
      }
 catch (      NoSuchElementException e1) {
        logger.debug(""String_Node_Str"");
        return null;
      }
      if (trigger == null) {
        logger.debug(""String_Node_Str"");
        return null;
      }
      Date nextFireTime=trigger.getNextFireTime();
      if (nextFireTime == null) {
        logger.debug(""String_Node_Str"");
        removeWaitingTrigger(trigger);
        trigger=null;
        continue;
      }
      if (!removeWaitingTrigger(trigger)) {
        trigger=null;
        continue;
      }
      TriggerWrapper tw=getTriggerWrapper(trigger.getGroup(),trigger.getName());
      if (hasTriggerMisfired(trigger)) {
        logger.debug(""String_Node_Str"");
        processTriggerMisfired(tw);
        if (trigger.getNextFireTime() != null) {
          addWaitingTrigger(trigger);
        }
        trigger=null;
        continue;
      }
      if (noLaterThan > 0) {
        if (nextFireTime.getTime() > noLaterThan) {
          addWaitingTrigger(trigger);
          return null;
        }
      }
      tw.setAcquired(true);
      trigger.setFireInstanceId(getFiredTriggerRecordId());
      try {
        tw.updateTrigger(trigger);
      }
 catch (      Exception e) {
        logger.warn(""String_Node_Str"",e);
        throw new JobPersistenceException(""String_Node_Str"",e);
      }
      updateTriggerInRepo(trigger.getGroup(),trigger.getName(),tw,tw.getRevision());
      addAcquiredTrigger(trigger,instanceId);
      logger.debug(""String_Node_Str"",new Object[]{trigger.getName(),trigger.getNextFireTime()});
      return (Trigger)trigger.clone();
    }
    logger.debug(""String_Node_Str"");
    return null;
  }
}"
13230,"/** 
 * <p> Called by the QuartzScheduler before the <code>JobStore</code> is used, in order to give the it a chance to initialize. </p>
 */
@Override public void initialize(ClassLoadHelper loadHelper,SchedulerSignaler schedSignaler){
  logger.debug(""String_Node_Str"");
  this.schedulerSignaler=schedSignaler;
  this.loadHelper=loadHelper;
  this.writeRetries=Integer.parseInt(IdentityServer.getInstance().getProperty(""String_Node_Str"",""String_Node_Str""));
  if (!isClustered()) {
    cleanUpInstance();
  }
}","/** 
 * <p> Called by the QuartzScheduler before the <code>JobStore</code> is used, in order to give the it a chance to initialize. </p>
 */
@Override public void initialize(ClassLoadHelper loadHelper,SchedulerSignaler schedSignaler){
  logger.debug(""String_Node_Str"");
  this.schedulerSignaler=schedSignaler;
  this.loadHelper=loadHelper;
  this.writeRetries=Integer.parseInt(IdentityServer.getInstance().getProperty(""String_Node_Str"",""String_Node_Str""));
  cleanUpInstance();
}"
13231,"@Override public boolean handleEvent(ClusterEvent event){
  String eventInstanceId=event.getInstanceId();
switch (event.getType()) {
case RECOVERY_INITIATED:
    try {
      AcquiredTriggers triggers=getAcquiredTriggers(eventInstanceId);
      for (      Trigger trigger : triggers.getTriggers()) {
        boolean removed=false;
        int retry=0;
        while (writeRetries == -1 || retry <= writeRetries) {
          try {
            removed=removeAcquiredTrigger(trigger,eventInstanceId);
            break;
          }
 catch (          JobPersistenceException e) {
            logger.debug(""String_Node_Str"",e);
            retry++;
          }
        }
        if (removed) {
          retry=0;
          while (writeRetries == -1 || retry <= writeRetries) {
            try {
              addWaitingTrigger(trigger);
              break;
            }
 catch (            JobPersistenceException e) {
              logger.debug(""String_Node_Str"",e);
              retry++;
            }
          }
        }
        logger.info(""String_Node_Str"",trigger.getName(),eventInstanceId);
        clusterManager.renewRecoveryLease(eventInstanceId);
      }
      schedulerSignaler.signalSchedulingChange(0L);
    }
 catch (    JobPersistenceException e) {
      logger.warn(""String_Node_Str"",eventInstanceId,e.getMessage());
      return false;
    }
  break;
case INSTANCE_FAILED:
break;
case INSTANCE_RUNNING:
cleanUpInstance();
break;
}
return true;
}","@Override public boolean handleEvent(ClusterEvent event){
  String eventInstanceId=event.getInstanceId();
switch (event.getType()) {
case RECOVERY_INITIATED:
    try {
      AcquiredTriggers triggers=getAcquiredTriggers(eventInstanceId);
      for (      Trigger trigger : triggers.getTriggers()) {
        boolean removed=false;
        int retry=0;
        while (writeRetries == -1 || retry <= writeRetries) {
          try {
            removed=removeAcquiredTrigger(trigger,eventInstanceId);
            break;
          }
 catch (          JobPersistenceException e) {
            logger.debug(""String_Node_Str"",e);
            retry++;
          }
        }
        if (removed) {
          retry=0;
          while (writeRetries == -1 || retry <= writeRetries) {
            try {
              addWaitingTrigger(trigger);
              break;
            }
 catch (            JobPersistenceException e) {
              logger.debug(""String_Node_Str"",e);
              retry++;
            }
          }
        }
        logger.info(""String_Node_Str"",trigger.getName(),eventInstanceId);
        clusterManager.renewRecoveryLease(eventInstanceId);
      }
      schedulerSignaler.signalSchedulingChange(0L);
    }
 catch (    JobPersistenceException e) {
      logger.warn(""String_Node_Str"",eventInstanceId,e.getMessage());
      return false;
    }
  break;
case INSTANCE_FAILED:
break;
case INSTANCE_RUNNING:
break;
}
return true;
}"
13232,"/** 
 * Removes a Trigger from the list of acquired triggers.
 * @param trigger    the Trigger to remove
 * @param instanceId the instance ID
 * @throws JobPersistenceException
 * @throws ObjectSetException
 */
private boolean removeAcquiredTrigger(Trigger trigger,String instanceId) throws JobPersistenceException {
synchronized (lock) {
    try {
      boolean result=false;
      int retries=0;
      while (writeRetries == -1 || retries <= writeRetries) {
        try {
          result=removeRepoListName(getTriggerId(trigger.getGroup(),trigger.getName()),getAcquiredTriggersRepoId(),instanceId);
          break;
        }
 catch (        PreconditionFailedException e) {
          logger.debug(""String_Node_Str"",e);
          retries++;
        }
      }
      return result;
    }
 catch (    ResourceException e) {
      throw new JobPersistenceException(""String_Node_Str"",e);
    }
  }
}","/** 
 * Removes a Trigger from the list of acquired triggers.
 * @param trigger    the Trigger to remove
 * @param instanceId the instance ID
 * @throws JobPersistenceException
 * @throws ObjectSetException
 */
private boolean removeAcquiredTrigger(Trigger trigger,String instanceId) throws JobPersistenceException {
synchronized (lock) {
    try {
      logger.debug(""String_Node_Str"",new Object[]{trigger.getName(),instanceId});
      boolean result=false;
      int retries=0;
      while (writeRetries == -1 || retries <= writeRetries) {
        try {
          result=removeRepoListName(getTriggerId(trigger.getGroup(),trigger.getName()),getAcquiredTriggersRepoId(),instanceId);
          break;
        }
 catch (        PreconditionFailedException e) {
          logger.debug(""String_Node_Str"",e);
          retries++;
        }
      }
      return result;
    }
 catch (    ResourceException e) {
      throw new JobPersistenceException(""String_Node_Str"",e);
    }
  }
}"
13233,"@Override public void removedService(ServiceReference reference,Object service){
  if (cluster != null) {
    cluster.unregister(LISTENER_ID);
    cluster=null;
  }
}","@Override public void removedService(ServiceReference reference,Object service){
  if (cluster != null) {
    cluster.unregister(LISTENER_ID);
    cluster=null;
    clusterUp=false;
  }
}"
13234,"/** 
 * <p> Called by the QuartzScheduler before the <code>JobStore</code> is used, in order to give the it a chance to initialize. </p>
 */
@Override public void initialize(ClassLoadHelper loadHelper,SchedulerSignaler schedSignaler){
  logger.debug(""String_Node_Str"");
  this.schedulerSignaler=schedSignaler;
  this.loadHelper=loadHelper;
  this.writeRetries=Integer.parseInt(IdentityServer.getInstance().getProperty(""String_Node_Str"",""String_Node_Str""));
synchronized (lock) {
    if (!isClustered()) {
      try {
        logger.trace(""String_Node_Str"");
        AcquiredTriggers at=getAcquiredTriggers(instanceId);
        List<Trigger> acquiredTriggers=at.getTriggers();
        for (Iterator<Trigger> it=acquiredTriggers.iterator(); it.hasNext(); ) {
          Trigger t=it.next();
          if (hasTriggerMisfired(t)) {
            logger.trace(""String_Node_Str"",t.getName());
            processTriggerMisfired(getTriggerWrapper(t.getGroup(),t.getName()));
            if (t.getNextFireTime() != null) {
              addWaitingTrigger(t);
              removeAcquiredTrigger(t,instanceId);
            }
          }
 else {
            releaseAcquiredTrigger(null,t);
          }
        }
      }
 catch (      JobPersistenceException e) {
        logger.warn(""String_Node_Str"",e);
      }
    }
  }
}","/** 
 * <p> Called by the QuartzScheduler before the <code>JobStore</code> is used, in order to give the it a chance to initialize. </p>
 */
@Override public void initialize(ClassLoadHelper loadHelper,SchedulerSignaler schedSignaler){
  logger.debug(""String_Node_Str"");
  this.schedulerSignaler=schedSignaler;
  this.loadHelper=loadHelper;
  this.writeRetries=Integer.parseInt(IdentityServer.getInstance().getProperty(""String_Node_Str"",""String_Node_Str""));
  if (!isClustered()) {
    cleanUpInstance();
  }
}"
13235,"@Override public boolean handleEvent(ClusterEvent event){
switch (event.getType()) {
case RECOVERY_INITIATED:
    try {
      AcquiredTriggers triggers=getAcquiredTriggers(instanceId);
      for (      Trigger trigger : triggers.getTriggers()) {
        boolean removed=false;
        int retry=0;
        while (writeRetries == -1 || retry <= writeRetries) {
          try {
            removed=removeAcquiredTrigger(trigger,instanceId);
            break;
          }
 catch (          JobPersistenceException e) {
            logger.debug(""String_Node_Str"",e);
            retry++;
          }
        }
        if (removed) {
          retry=0;
          while (writeRetries == -1 || retry <= writeRetries) {
            try {
              addWaitingTrigger(trigger);
              break;
            }
 catch (            JobPersistenceException e) {
              logger.debug(""String_Node_Str"",e);
              retry++;
            }
          }
        }
        logger.info(""String_Node_Str"",trigger.getName(),instanceId);
        clusterManager.renewRecoveryLease(instanceId);
      }
      schedulerSignaler.signalSchedulingChange(0L);
    }
 catch (    JobPersistenceException e) {
      logger.warn(""String_Node_Str"",instanceId,e.getMessage());
      return false;
    }
  break;
case INSTANCE_FAILED:
break;
}
return true;
}","@Override public boolean handleEvent(ClusterEvent event){
  String eventInstanceId=event.getInstanceId();
switch (event.getType()) {
case RECOVERY_INITIATED:
    try {
      AcquiredTriggers triggers=getAcquiredTriggers(eventInstanceId);
      for (      Trigger trigger : triggers.getTriggers()) {
        boolean removed=false;
        int retry=0;
        while (writeRetries == -1 || retry <= writeRetries) {
          try {
            removed=removeAcquiredTrigger(trigger,eventInstanceId);
            break;
          }
 catch (          JobPersistenceException e) {
            logger.debug(""String_Node_Str"",e);
            retry++;
          }
        }
        if (removed) {
          retry=0;
          while (writeRetries == -1 || retry <= writeRetries) {
            try {
              addWaitingTrigger(trigger);
              break;
            }
 catch (            JobPersistenceException e) {
              logger.debug(""String_Node_Str"",e);
              retry++;
            }
          }
        }
        logger.info(""String_Node_Str"",trigger.getName(),eventInstanceId);
        clusterManager.renewRecoveryLease(eventInstanceId);
      }
      schedulerSignaler.signalSchedulingChange(0L);
    }
 catch (    JobPersistenceException e) {
      logger.warn(""String_Node_Str"",eventInstanceId,e.getMessage());
      return false;
    }
  break;
case INSTANCE_FAILED:
break;
case INSTANCE_RUNNING:
cleanUpInstance();
break;
}
return true;
}"
13236,"@Override public void createInstance(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  try {
    if (objectClassInfoHelper.isCreateable()) {
      if (null == request.getNewResourceId()) {
        final ConnectorFacade facade=getConnectorFacade0(handler,CreateApiOp.class);
        if (null == facade) {
          return;
        }
        final Set<Attribute> createAttributes=objectClassInfoHelper.getCreateAttributes(request,cryptoService);
        OperationOptions operationOptions=operations.get(CreateApiOp.class).build(jsonConfiguration,objectClassInfoHelper).build();
        Uid uid=facade.create(objectClassInfoHelper.getObjectClass(),AttributeUtil.filterUid(createAttributes),operationOptions);
        Resource resource=getCurrentResource(facade,uid,null);
        activityLogger.log(context,RequestType.CREATE,""String_Node_Str"",getSource(objectClass,uid.getUidValue()),null,resource.getContent(),Status.SUCCESS);
        handler.handleResult(resource);
      }
 else {
        final ResourceException e=new NotSupportedException(""String_Node_Str"");
        handler.handleError(e);
      }
    }
 else {
      final ResourceException e=new NotSupportedException(""String_Node_Str"" + objectClassInfoHelper.getObjectClass());
      handler.handleError(e);
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,objectClassInfoHelper.getCreateResourceId(request),request.getContent(),null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e.getMessage(),e));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}","@Override public void createInstance(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  try {
    if (objectClassInfoHelper.isCreateable()) {
      if (null == request.getNewResourceId()) {
        final ConnectorFacade facade=getConnectorFacade0(handler,CreateApiOp.class);
        if (null == facade) {
          return;
        }
        final Set<Attribute> createAttributes=objectClassInfoHelper.getCreateAttributes(request,cryptoService);
        OperationOptions operationOptions=operations.get(CreateApiOp.class).build(jsonConfiguration,objectClassInfoHelper).build();
        Uid uid=facade.create(objectClassInfoHelper.getObjectClass(),AttributeUtil.filterUid(createAttributes),operationOptions);
        Resource resource=getCurrentResource(facade,uid,null);
        activityLogger.log(context,RequestType.CREATE,""String_Node_Str"",getSource(objectClass,uid.getUidValue()),null,resource.getContent(),Status.SUCCESS);
        handler.handleResult(resource);
      }
 else {
        final ResourceException e=new NotSupportedException(""String_Node_Str"");
        handler.handleError(e);
      }
    }
 else {
      final ResourceException e=new NotSupportedException(""String_Node_Str"" + objectClassInfoHelper.getObjectClass());
      handler.handleError(e);
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,getSource(objectClass),objectClassInfoHelper.getCreateResourceId(request),request.getContent(),null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e.getMessage(),e));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}"
13237,"@Override public void queryCollection(final ServerContext context,final QueryRequest request,final QueryResultHandler handler){
  EventEntry measure=null;
  try {
    final ConnectorFacade facade=getConnectorFacade0(handler,SearchApiOp.class);
    if (null == facade) {
      return;
    }
    OperationOptionsBuilder operationOptionsBuilder=operations.get(SearchApiOp.class).build(jsonConfiguration,objectClassInfoHelper);
    Filter filter=null;
    if (request.getQueryId() != null) {
      if (ServerConstants.QUERY_ALL_IDS.equals(request.getQueryId())) {
        operationOptionsBuilder.setAttributesToGet(Uid.NAME);
      }
 else {
        handler.handleError(new BadRequestException(""String_Node_Str"" + request.getQueryId()));
        return;
      }
    }
 else     if (request.getQueryExpression() != null) {
      filter=QueryFilter.valueOf(request.getQueryExpression()).accept(RESOURCE_FILTER,objectClassInfoHelper);
    }
 else {
      filter=request.getQueryFilter().accept(RESOURCE_FILTER,objectClassInfoHelper);
    }
    final int pageSize=request.getPageSize();
    final String pagedResultsCookie=request.getPagedResultsCookie();
    final boolean pagedResultsRequested=request.getPageSize() > 0;
    if (pageSize > 0) {
      operationOptionsBuilder.setPageSize(pageSize);
    }
    if (null != pagedResultsCookie) {
      operationOptionsBuilder.setPagedResultsCookie(pagedResultsCookie);
    }
    operationOptionsBuilder.setPagedResultsOffset(request.getPagedResultsOffset());
    if (null != request.getSortKeys()) {
      List<SortKey> sortKeys=new ArrayList<SortKey>(request.getSortKeys().size());
      for (      org.forgerock.json.resource.SortKey s : request.getSortKeys()) {
        sortKeys.add(new SortKey(s.getField().leaf(),s.isAscendingOrder()));
      }
      operationOptionsBuilder.setSortKeys(sortKeys);
    }
    SearchResult searchResult=facade.search(objectClassInfoHelper.getObjectClass(),filter,new ResultsHandler(){
      @Override public boolean handle(      ConnectorObject obj){
        try {
          return handler.handleResource(objectClassInfoHelper.build(obj,cryptoService));
        }
 catch (        Exception e) {
          handler.handleError(new InternalServerErrorException(e.getMessage(),e));
          return false;
        }
      }
    }
,operationOptionsBuilder.build());
    handler.handleResult(new QueryResult(searchResult != null ? searchResult.getPagedResultsCookie() : null,searchResult != null ? searchResult.getRemainingPagedResults() : -1));
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,null,null,null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e.getMessage(),e));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
 finally {
  }
}","@Override public void queryCollection(final ServerContext context,final QueryRequest request,final QueryResultHandler handler){
  EventEntry measure=null;
  try {
    final ConnectorFacade facade=getConnectorFacade0(handler,SearchApiOp.class);
    if (null == facade) {
      return;
    }
    OperationOptionsBuilder operationOptionsBuilder=operations.get(SearchApiOp.class).build(jsonConfiguration,objectClassInfoHelper);
    Filter filter=null;
    if (request.getQueryId() != null) {
      if (ServerConstants.QUERY_ALL_IDS.equals(request.getQueryId())) {
        operationOptionsBuilder.setAttributesToGet(Uid.NAME);
      }
 else {
        handler.handleError(new BadRequestException(""String_Node_Str"" + request.getQueryId()));
        return;
      }
    }
 else     if (request.getQueryExpression() != null) {
      filter=QueryFilter.valueOf(request.getQueryExpression()).accept(RESOURCE_FILTER,objectClassInfoHelper);
    }
 else {
      filter=request.getQueryFilter().accept(RESOURCE_FILTER,objectClassInfoHelper);
    }
    final int pageSize=request.getPageSize();
    final String pagedResultsCookie=request.getPagedResultsCookie();
    final boolean pagedResultsRequested=request.getPageSize() > 0;
    if (pageSize > 0) {
      operationOptionsBuilder.setPageSize(pageSize);
    }
    if (null != pagedResultsCookie) {
      operationOptionsBuilder.setPagedResultsCookie(pagedResultsCookie);
    }
    operationOptionsBuilder.setPagedResultsOffset(request.getPagedResultsOffset());
    if (null != request.getSortKeys()) {
      List<SortKey> sortKeys=new ArrayList<SortKey>(request.getSortKeys().size());
      for (      org.forgerock.json.resource.SortKey s : request.getSortKeys()) {
        sortKeys.add(new SortKey(s.getField().leaf(),s.isAscendingOrder()));
      }
      operationOptionsBuilder.setSortKeys(sortKeys);
    }
    SearchResult searchResult=facade.search(objectClassInfoHelper.getObjectClass(),filter,new ResultsHandler(){
      @Override public boolean handle(      ConnectorObject obj){
        try {
          return handler.handleResource(objectClassInfoHelper.build(obj,cryptoService));
        }
 catch (        Exception e) {
          handler.handleError(new InternalServerErrorException(e.getMessage(),e));
          return false;
        }
      }
    }
,operationOptionsBuilder.build());
    handler.handleResult(new QueryResult(searchResult != null ? searchResult.getPagedResultsCookie() : null,searchResult != null ? searchResult.getRemainingPagedResults() : -1));
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,null,null,null,null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e.getMessage(),e));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
 finally {
  }
}"
13238,"private void handleAuthenticate(ServerContext context,ActionRequest request,ResultHandler<JsonValue> handler) throws ResourceException, IOException {
  try {
    final ConnectorFacade facade=getConnectorFacade0(handler,AuthenticationApiOp.class);
    if (null == facade) {
      return;
    }
    final JsonValue params=new JsonValue(request.getAdditionalParameters());
    final String username=params.get(""String_Node_Str"").required().asString();
    final String password=params.get(""String_Node_Str"").required().asString();
    OperationOptions operationOptions=operations.get(AuthenticationApiOp.class).build(jsonConfiguration,objectClassInfoHelper).build();
    Uid uid=facade.authenticate(objectClassInfoHelper.getObjectClass(),username,new GuardedString(password.toCharArray()),operationOptions);
    JsonValue result=new JsonValue(new HashMap<String,Object>());
    result.put(Resource.FIELD_CONTENT_ID,uid.getUidValue());
    if (null != uid.getRevision()) {
      result.put(Resource.FIELD_CONTENT_REVISION,uid.getRevision());
    }
    handler.handleResult(result);
  }
 catch (  ConnectorException e) {
    handleConnectorException(context,request,e,null,null,null,handler,ContextUtil.isExternal(context) ? activityLogger : NullActivityLogger.INSTANCE);
  }
}","private void handleAuthenticate(ServerContext context,ActionRequest request,ResultHandler<JsonValue> handler) throws ResourceException, IOException {
  try {
    final ConnectorFacade facade=getConnectorFacade0(handler,AuthenticationApiOp.class);
    if (null == facade) {
      return;
    }
    final JsonValue params=new JsonValue(request.getAdditionalParameters());
    final String username=params.get(""String_Node_Str"").required().asString();
    final String password=params.get(""String_Node_Str"").required().asString();
    OperationOptions operationOptions=operations.get(AuthenticationApiOp.class).build(jsonConfiguration,objectClassInfoHelper).build();
    Uid uid=facade.authenticate(objectClassInfoHelper.getObjectClass(),username,new GuardedString(password.toCharArray()),operationOptions);
    JsonValue result=new JsonValue(new HashMap<String,Object>());
    result.put(Resource.FIELD_CONTENT_ID,uid.getUidValue());
    if (null != uid.getRevision()) {
      result.put(Resource.FIELD_CONTENT_REVISION,uid.getRevision());
    }
    handler.handleResult(result);
  }
 catch (  ConnectorException e) {
    handleConnectorException(context,request,e,null,null,null,null,handler,ContextUtil.isExternal(context) ? activityLogger : NullActivityLogger.INSTANCE);
  }
}"
13239,"/** 
 * Checks the RemoteWrappedException to determine which Exception has been wrapped and handles the appropriate Exception which is wrapped.
 * @param context the ServerContext from the original request
 * @param request the original request
 * @param exception the ConnectorException that was thrown by the facade
 * @param resourceId the resourceId being operated on
 * @param before the object value ""before"" the request
 * @param after the object value ""after"" the request
 * @param handler the ResultHandler on which to call handleError
 * @param connectorExceptionActivityLogger the ActivityLogger to use to log the exception
 */
private void handleRemoteWrappedException(ServerContext context,Request request,ConnectorException exception,String resourceId,JsonValue before,JsonValue after,ResultHandler<?> handler,ActivityLogger connectorExceptionActivityLogger){
  RemoteWrappedException remoteWrappedException=(RemoteWrappedException)exception;
  final String message=exception.getMessage();
  final Throwable cause=exception.getCause();
  if (remoteWrappedException.is(AlreadyExistsException.class)) {
    handleConnectorException(context,request,new AlreadyExistsException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(ConfigurationException.class)) {
    handleConnectorException(context,request,new ConfigurationException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(ConnectionBrokenException.class)) {
    handleConnectorException(context,request,new ConnectionBrokenException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(ConnectionFailedException.class)) {
    handleConnectorException(context,request,new ConnectionFailedException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(ConnectorIOException.class)) {
    handleConnectorException(context,request,new ConnectorIOException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(InvalidAttributeValueException.class)) {
    handleConnectorException(context,request,new InvalidAttributeValueException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(InvalidCredentialException.class)) {
    handleConnectorException(context,request,new InvalidCredentialException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(InvalidPasswordException.class)) {
    handleConnectorException(context,request,new InvalidPasswordException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(OperationTimeoutException.class)) {
    handleConnectorException(context,request,new OperationTimeoutException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(PasswordExpiredException.class)) {
    handleConnectorException(context,request,new PasswordExpiredException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(PermissionDeniedException.class)) {
    handleConnectorException(context,request,new PermissionDeniedException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(PreconditionFailedException.class)) {
    handleConnectorException(context,request,new PreconditionFailedException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(PreconditionRequiredException.class)) {
    handleConnectorException(context,request,new PreconditionRequiredException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(RetryableException.class)) {
    handleConnectorException(context,request,RetryableException.wrap(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(UnknownUidException.class)) {
    handleConnectorException(context,request,new UnknownUidException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(ConnectorException.class)) {
    handleConnectorException(context,request,new ConnectorException(message,cause),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else {
    handleConnectorException(context,request,DotNetExceptionHelper.fromExceptionClass(remoteWrappedException.getExceptionClass()).getConnectorException(remoteWrappedException),resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
}","/** 
 * Checks the RemoteWrappedException to determine which Exception has been wrapped and handles the appropriate Exception which is wrapped.
 * @param context the ServerContext from the original request
 * @param request the original request
 * @param exception the ConnectorException that was thrown by the facade
 * @param resourceId the resourceId being operated on
 * @param before the object value ""before"" the request
 * @param after the object value ""after"" the request
 * @param handler the ResultHandler on which to call handleError
 * @param connectorExceptionActivityLogger the ActivityLogger to use to log the exception
 */
private void handleRemoteWrappedException(ServerContext context,Request request,ConnectorException exception,String resourceContainer,String resourceId,JsonValue before,JsonValue after,ResultHandler<?> handler,ActivityLogger connectorExceptionActivityLogger){
  RemoteWrappedException remoteWrappedException=(RemoteWrappedException)exception;
  final String message=exception.getMessage();
  final Throwable cause=exception.getCause();
  if (remoteWrappedException.is(AlreadyExistsException.class)) {
    handleConnectorException(context,request,new AlreadyExistsException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(ConfigurationException.class)) {
    handleConnectorException(context,request,new ConfigurationException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(ConnectionBrokenException.class)) {
    handleConnectorException(context,request,new ConnectionBrokenException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(ConnectionFailedException.class)) {
    handleConnectorException(context,request,new ConnectionFailedException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(ConnectorIOException.class)) {
    handleConnectorException(context,request,new ConnectorIOException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(InvalidAttributeValueException.class)) {
    handleConnectorException(context,request,new InvalidAttributeValueException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(InvalidCredentialException.class)) {
    handleConnectorException(context,request,new InvalidCredentialException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(InvalidPasswordException.class)) {
    handleConnectorException(context,request,new InvalidPasswordException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(OperationTimeoutException.class)) {
    handleConnectorException(context,request,new OperationTimeoutException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(PasswordExpiredException.class)) {
    handleConnectorException(context,request,new PasswordExpiredException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(PermissionDeniedException.class)) {
    handleConnectorException(context,request,new PermissionDeniedException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(PreconditionFailedException.class)) {
    handleConnectorException(context,request,new PreconditionFailedException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(PreconditionRequiredException.class)) {
    handleConnectorException(context,request,new PreconditionRequiredException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(RetryableException.class)) {
    handleConnectorException(context,request,RetryableException.wrap(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(UnknownUidException.class)) {
    handleConnectorException(context,request,new UnknownUidException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else   if (remoteWrappedException.is(ConnectorException.class)) {
    handleConnectorException(context,request,new ConnectorException(message,cause),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
 else {
    handleConnectorException(context,request,DotNetExceptionHelper.fromExceptionClass(remoteWrappedException.getExceptionClass()).getConnectorException(remoteWrappedException),resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
}"
13240,"@Override public void deleteInstance(ServerContext context,String resourceId,DeleteRequest request,ResultHandler<Resource> handler){
  try {
    final ConnectorFacade facade=getConnectorFacade0(handler,DeleteApiOp.class);
    if (null == facade) {
      return;
    }
    final Uid uid=request.getRevision() != null ? new Uid(resourceId,request.getRevision()) : new Uid(resourceId);
    Resource before=getCurrentResource(facade,uid,null);
    OperationOptions operationOptions=operations.get(DeleteApiOp.class).build(jsonConfiguration,objectClassInfoHelper).build();
    facade.delete(objectClassInfoHelper.getObjectClass(),uid,operationOptions);
    JsonValue result=new JsonValue(new HashMap<String,Object>());
    result.put(Resource.FIELD_CONTENT_ID,uid.getUidValue());
    if (null != uid.getRevision()) {
      result.put(Resource.FIELD_CONTENT_REVISION,uid.getRevision());
    }
    activityLogger.log(context,RequestType.DELETE,""String_Node_Str"",getSource(objectClass,uid.getUidValue()),before.getContent(),null,Status.SUCCESS);
    handler.handleResult(new Resource(uid.getUidValue(),uid.getRevision(),result));
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,resourceId,null,null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e.getMessage(),e));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}","@Override public void deleteInstance(ServerContext context,String resourceId,DeleteRequest request,ResultHandler<Resource> handler){
  try {
    final ConnectorFacade facade=getConnectorFacade0(handler,DeleteApiOp.class);
    if (null == facade) {
      return;
    }
    final Uid uid=request.getRevision() != null ? new Uid(resourceId,request.getRevision()) : new Uid(resourceId);
    Resource before=getCurrentResource(facade,uid,null);
    OperationOptions operationOptions=operations.get(DeleteApiOp.class).build(jsonConfiguration,objectClassInfoHelper).build();
    facade.delete(objectClassInfoHelper.getObjectClass(),uid,operationOptions);
    JsonValue result=new JsonValue(new HashMap<String,Object>());
    result.put(Resource.FIELD_CONTENT_ID,uid.getUidValue());
    if (null != uid.getRevision()) {
      result.put(Resource.FIELD_CONTENT_REVISION,uid.getRevision());
    }
    activityLogger.log(context,RequestType.DELETE,""String_Node_Str"",getSource(objectClass,uid.getUidValue()),before.getContent(),null,Status.SUCCESS);
    handler.handleResult(new Resource(uid.getUidValue(),uid.getRevision(),result));
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,getSource(objectClass),resourceId,null,null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e.getMessage(),e));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}"
13241,"/** 
 * Handle ConnectorExceptions from ConnectorFacade invocations.  Maps each ConnectorException subtype to the appropriate   {@link ResourceException} for passing to {@code handleError}.  Optionally logs to activity log.
 * @param context the ServerContext from the original request
 * @param request the original request
 * @param exception the ConnectorException that was thrown by the facade
 * @param resourceId the resourceId being operated on
 * @param before the object value ""before"" the request
 * @param after the object value ""after"" the request
 * @param handler the ResultHandler on which to call handleError
 * @param connectorExceptionActivityLogger the ActivityLogger to use to log the exception
 */
private void handleConnectorException(ServerContext context,Request request,ConnectorException exception,String resourceId,JsonValue before,JsonValue after,ResultHandler<?> handler,ActivityLogger connectorExceptionActivityLogger){
  String message=MessageFormat.format(""String_Node_Str"",request.getRequestType(),exception.getClass().getSimpleName(),resourceId);
  try {
    throw exception;
  }
 catch (  AlreadyExistsException e) {
    message=MessageFormat.format(""String_Node_Str"",resourceId);
    handler.handleError(new ConflictException(message,exception));
  }
catch (  ConfigurationException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
catch (  ConnectionBrokenException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  ConnectionFailedException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  ConnectorIOException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  OperationTimeoutException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  PasswordExpiredException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ForbiddenException(message,exception));
  }
catch (  InvalidPasswordException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(ResourceException.getException(UNAUTHORIZED_ERROR_CODE,message,exception));
  }
catch (  UnknownUidException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),request.getResourceName(),resourceId);
    handler.handleError(new NotFoundException(message,exception).setDetail(new JsonValue(new HashMap<String,Object>())));
  }
catch (  InvalidCredentialException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(ResourceException.getException(UNAUTHORIZED_ERROR_CODE,message,exception));
  }
catch (  PermissionDeniedException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ForbiddenException(message,exception));
  }
catch (  ConnectorSecurityException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
catch (  InvalidAttributeValueException e) {
    message=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new BadRequestException(message,exception));
  }
catch (  PreconditionFailedException e) {
    message=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",request.getResourceName(),request.getRequestType().toString(),resourceId);
    handler.handleError(new org.forgerock.json.resource.PreconditionFailedException(message,exception));
  }
catch (  PreconditionRequiredException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getResourceName(),request.getRequestType().toString(),resourceId);
    handler.handleError(new org.forgerock.json.resource.PreconditionRequiredException(message,exception));
  }
catch (  RetryableException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  UnsupportedOperationException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new NotFoundException(message,exception));
  }
catch (  IllegalArgumentException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,e));
  }
catch (  RemoteWrappedException e) {
    handleRemoteWrappedException(context,request,exception,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
catch (  ConnectorException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
 finally {
    logger.debug(message,exception);
    try {
      connectorExceptionActivityLogger.log(context,request.getRequestType(),message,resourceId,before,after,Status.FAILURE);
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
    }
  }
}","/** 
 * Handle ConnectorExceptions from ConnectorFacade invocations.  Maps each ConnectorException subtype to the appropriate   {@link ResourceException} for passing to {@code handleError}.  Optionally logs to activity log.
 * @param context the ServerContext from the original request
 * @param request the original request
 * @param exception the ConnectorException that was thrown by the facade
 * @param resourceId the resourceId being operated on
 * @param before the object value ""before"" the request
 * @param after the object value ""after"" the request
 * @param handler the ResultHandler on which to call handleError
 * @param connectorExceptionActivityLogger the ActivityLogger to use to log the exception
 */
private void handleConnectorException(ServerContext context,Request request,ConnectorException exception,String resourceContainer,String resourceId,JsonValue before,JsonValue after,ResultHandler<?> handler,ActivityLogger connectorExceptionActivityLogger){
  String message=MessageFormat.format(""String_Node_Str"",request.getRequestType(),exception.getClass().getSimpleName(),resourceId);
  try {
    throw exception;
  }
 catch (  AlreadyExistsException e) {
    message=MessageFormat.format(""String_Node_Str"",resourceId);
    handler.handleError(new ConflictException(message,exception));
  }
catch (  ConfigurationException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
catch (  ConnectionBrokenException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  ConnectionFailedException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  ConnectorIOException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  OperationTimeoutException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  PasswordExpiredException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ForbiddenException(message,exception));
  }
catch (  InvalidPasswordException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(ResourceException.getException(UNAUTHORIZED_ERROR_CODE,message,exception));
  }
catch (  UnknownUidException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId,resourceContainer);
    handler.handleError(new NotFoundException(message,exception).setDetail(new JsonValue(new HashMap<String,Object>())));
  }
catch (  InvalidCredentialException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(ResourceException.getException(UNAUTHORIZED_ERROR_CODE,message,exception));
  }
catch (  PermissionDeniedException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ForbiddenException(message,exception));
  }
catch (  ConnectorSecurityException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
catch (  InvalidAttributeValueException e) {
    message=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new BadRequestException(message,exception));
  }
catch (  PreconditionFailedException e) {
    message=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",resourceId,request.getRequestType().toString(),resourceContainer);
    handler.handleError(new org.forgerock.json.resource.PreconditionFailedException(message,exception));
  }
catch (  PreconditionRequiredException e) {
    message=MessageFormat.format(""String_Node_Str"",resourceId,request.getRequestType().toString(),resourceContainer);
    handler.handleError(new org.forgerock.json.resource.PreconditionRequiredException(message,exception));
  }
catch (  RetryableException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  UnsupportedOperationException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new NotFoundException(message,exception));
  }
catch (  IllegalArgumentException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,e));
  }
catch (  RemoteWrappedException e) {
    handleRemoteWrappedException(context,request,exception,resourceContainer,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
catch (  ConnectorException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
 finally {
    logger.debug(message,exception);
    try {
      connectorExceptionActivityLogger.log(context,request.getRequestType(),message,resourceId,before,after,Status.FAILURE);
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
    }
  }
}"
13242,"@Activate protected void activate(ComponentContext context) throws ServletException, NamespaceException {
  logger.info(""String_Node_Str"",context.getProperties());
  JsonValue config=new JSONEnhancedConfig().getConfigurationAsJson(context);
  if (!config.get(CONFIG_ENABLED).isNull() && Boolean.FALSE.equals(config.get(CONFIG_ENABLED).asBoolean())) {
    logger.info(""String_Node_Str"");
    return;
  }
 else   if (config.get(CONFIG_CONTEXT_ROOT) == null || config.get(CONFIG_CONTEXT_ROOT).isNull()) {
    logger.info(""String_Node_Str"");
    return;
  }
 else   if (config.get(CONFIG_BUNDLE) == null || config.get(CONFIG_BUNDLE).isNull() || !config.get(CONFIG_BUNDLE).isMap() || config.get(CONFIG_BUNDLE).get(CONFIG_NAME) == null || config.get(CONFIG_BUNDLE).get(CONFIG_NAME).isNull()) {
    logger.info(""String_Node_Str"");
    return;
  }
 else   if (config.get(CONFIG_BUNDLE) == null || config.get(CONFIG_BUNDLE).isNull() || !config.get(CONFIG_BUNDLE).isMap() || config.get(CONFIG_BUNDLE).get(CONFIG_RESOURCE_DIR) == null || config.get(CONFIG_BUNDLE).get(CONFIG_RESOURCE_DIR).isNull()) {
    logger.info(""String_Node_Str"");
    return;
  }
  bundleName=config.get(CONFIG_BUNDLE).get(CONFIG_NAME).asString();
  resourceDir=prependSlash(config.get(CONFIG_BUNDLE).get(CONFIG_RESOURCE_DIR).asString());
  contextRoot=prependSlash(config.get(CONFIG_CONTEXT_ROOT).asString());
  if (bundleName != null) {
    for (    Bundle aBundle : context.getBundleContext().getBundles()) {
      if (bundleName.equals(aBundle.getSymbolicName())) {
        this.bundle=aBundle;
        break;
      }
    }
  }
  if (bundle == null) {
    logger.info(""String_Node_Str"" + bundleName + ""String_Node_Str"");
  }
  bundleListener=new BundleListener(){
    public void bundleChanged(    BundleEvent event){
      if (event == null) {
        logger.debug(""String_Node_Str"",bundleName);
        return;
      }
      Bundle bundle=event.getBundle();
      if (bundle != null && bundle.getSymbolicName() != null && bundle.getSymbolicName().equals(bundleName)) {
        if (event.getType() == BundleEvent.STARTED) {
          ResourceServlet.this.bundle=bundle;
          logger.info(""String_Node_Str"" + bundleName + ""String_Node_Str"");
        }
 else         if (event.getType() == BundleEvent.STOPPED) {
          ResourceServlet.this.bundle=null;
          logger.info(""String_Node_Str"" + bundleName + ""String_Node_Str"");
        }
      }
    }
  }
;
  context.getBundleContext().addBundleListener(bundleListener);
  extFolders=new ArrayList<String>();
  extFolders.add(""String_Node_Str"");
  extFolders.add(""String_Node_Str"");
  extFolders.add(""String_Node_Str"");
  extFolders.add(""String_Node_Str"");
  Dictionary<String,Object> props=new Hashtable<String,Object>();
  webContainer.registerServlet(contextRoot,this,props,webContainer.getDefaultSharedHttpContext());
  logger.debug(""String_Node_Str"",contextRoot);
}","@Activate protected void activate(ComponentContext context) throws ServletException, NamespaceException {
  logger.info(""String_Node_Str"",context.getProperties());
  init(context);
}"
13243,"@Deactivate protected void deactivate(ComponentContext context){
  if (bundleListener != null) {
    bundle.getBundleContext().removeBundleListener(bundleListener);
  }
  webContainer.unregister(contextRoot);
  logger.debug(""String_Node_Str"",contextRoot);
}","@Deactivate protected void deactivate(ComponentContext context){
  logger.info(""String_Node_Str"",context.getProperties());
  clear();
}"
13244,"public Set<Attribute> getCreateAttributes(final CreateRequest request,final CryptoService cryptoService) throws ResourceException {
  JsonValue content=request.getContent().required().expect(Map.class);
  String nameValue=request.getNewResourceId();
  if (null == nameValue) {
    JsonValue o=content.get(nameAttribute);
    if (o.isNull()) {
      o=content.get(Resource.FIELD_CONTENT_ID);
    }
    if (o.isString()) {
      nameValue=o.asString();
    }
  }
  if (StringUtils.isBlank(nameValue)) {
    throw new BadRequestException(""String_Node_Str"" + nameAttribute + ""String_Node_Str"");
  }
  Set<String> keySet=content.keys();
  Map<String,Attribute> result=new HashMap<String,Attribute>(keySet.size());
  result.put(Name.NAME,new Name(nameValue));
  for (  AttributeInfoHelper attributeInfo : attributes) {
    if (Name.NAME.equals(attributeInfo.getAttributeInfo().getName()) || Uid.NAME.equals(attributeInfo.getAttributeInfo().getName()) || (!keySet.contains(attributeInfo.getName()) && !attributeInfo.getAttributeInfo().isRequired())) {
      continue;
    }
    if (attributeInfo.getAttributeInfo().isCreateable()) {
      JsonValue v=content.get(attributeInfo.getName());
      if (v.isNull() && attributeInfo.getAttributeInfo().isRequired()) {
        throw new BadRequestException(""String_Node_Str"" + attributeInfo.getName() + ""String_Node_Str"");
      }
      Attribute a=attributeInfo.build(v.getObject(),cryptoService);
      if (null != a) {
        result.put(attributeInfo.getAttributeInfo().getName(),a);
      }
    }
  }
  if (logger.isTraceEnabled()) {
    ConnectorObjectBuilder builder=new ConnectorObjectBuilder().addAttributes(result.values());
    builder.setName(nameValue);
    builder.setUid(nameValue);
    logger.trace(""String_Node_Str"",SerializerUtil.serializeXmlObject(builder.build(),false));
  }
  return new HashSet<Attribute>(result.values());
}","/** 
 * Get the attributes are that are writable on a create
 * @param request CreateRequest
 * @param cryptoService encryption and decryption service
 * @return Set of attributes to that are writable on create
 * @throws BadRequestException when attribute is missing or has a null value
 */
public Set<Attribute> getCreateAttributes(final CreateRequest request,final CryptoService cryptoService) throws ResourceException {
  JsonValue content=request.getContent().required().expect(Map.class);
  String nameValue=getCreateNameValue(request);
  if (StringUtils.isBlank(nameValue)) {
    throw new BadRequestException(""String_Node_Str"" + nameAttribute + ""String_Node_Str"");
  }
  Set<String> keySet=content.keys();
  Map<String,Attribute> result=new HashMap<String,Attribute>(keySet.size());
  result.put(Name.NAME,new Name(nameValue));
  for (  AttributeInfoHelper attributeInfo : attributes) {
    if (Name.NAME.equals(attributeInfo.getAttributeInfo().getName()) || Uid.NAME.equals(attributeInfo.getAttributeInfo().getName()) || (!keySet.contains(attributeInfo.getName()) && !attributeInfo.getAttributeInfo().isRequired())) {
      continue;
    }
    if (attributeInfo.getAttributeInfo().isCreateable()) {
      JsonValue v=content.get(attributeInfo.getName());
      if (v.isNull() && attributeInfo.getAttributeInfo().isRequired()) {
        throw new BadRequestException(""String_Node_Str"" + attributeInfo.getName() + ""String_Node_Str"");
      }
      Attribute a=attributeInfo.build(v.getObject(),cryptoService);
      if (null != a) {
        result.put(attributeInfo.getAttributeInfo().getName(),a);
      }
    }
  }
  if (logger.isTraceEnabled()) {
    ConnectorObjectBuilder builder=new ConnectorObjectBuilder().addAttributes(result.values());
    builder.setName(nameValue);
    builder.setUid(nameValue);
    logger.trace(""String_Node_Str"",SerializerUtil.serializeXmlObject(builder.build(),false));
  }
  return new HashSet<Attribute>(result.values());
}"
13245,"@Override public void createInstance(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  try {
    if (objectClassInfoHelper.isCreateable()) {
      if (null == request.getNewResourceId()) {
        final ConnectorFacade facade=getConnectorFacade0(handler,CreateApiOp.class);
        if (null == facade) {
          return;
        }
        final Set<Attribute> createAttributes=objectClassInfoHelper.getCreateAttributes(request,cryptoService);
        OperationOptions operationOptions=operations.get(CreateApiOp.class).build(jsonConfiguration,objectClassInfoHelper).build();
        Uid uid=facade.create(objectClassInfoHelper.getObjectClass(),AttributeUtil.filterUid(createAttributes),operationOptions);
        Resource resource=getCurrentResource(facade,uid,null);
        activityLogger.log(context,RequestType.CREATE,""String_Node_Str"",getSource(objectClass,uid.getUidValue()),null,resource.getContent(),Status.SUCCESS);
        handler.handleResult(resource);
      }
 else {
        final ResourceException e=new NotSupportedException(""String_Node_Str"");
        handler.handleError(e);
      }
    }
 else {
      final ResourceException e=new NotSupportedException(""String_Node_Str"" + objectClassInfoHelper.getObjectClass());
      handler.handleError(e);
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,request.getNewResourceId(),request.getContent(),null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e.getMessage(),e));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}","@Override public void createInstance(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  try {
    if (objectClassInfoHelper.isCreateable()) {
      if (null == request.getNewResourceId()) {
        final ConnectorFacade facade=getConnectorFacade0(handler,CreateApiOp.class);
        if (null == facade) {
          return;
        }
        final Set<Attribute> createAttributes=objectClassInfoHelper.getCreateAttributes(request,cryptoService);
        OperationOptions operationOptions=operations.get(CreateApiOp.class).build(jsonConfiguration,objectClassInfoHelper).build();
        Uid uid=facade.create(objectClassInfoHelper.getObjectClass(),AttributeUtil.filterUid(createAttributes),operationOptions);
        Resource resource=getCurrentResource(facade,uid,null);
        activityLogger.log(context,RequestType.CREATE,""String_Node_Str"",getSource(objectClass,uid.getUidValue()),null,resource.getContent(),Status.SUCCESS);
        handler.handleResult(resource);
      }
 else {
        final ResourceException e=new NotSupportedException(""String_Node_Str"");
        handler.handleError(e);
      }
    }
 else {
      final ResourceException e=new NotSupportedException(""String_Node_Str"" + objectClassInfoHelper.getObjectClass());
      handler.handleError(e);
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,objectClassInfoHelper.getCreateNameValue(request),request.getContent(),null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e.getMessage(),e));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}"
13246,"/** 
 * Handle ConnectorExceptions from ConnectorFacade invocations.  Maps each ConnectorException subtype to the appropriate   {@link ResourceException} for passing to {@code handleError}.  Optionally logs to activity log.
 * @param context the ServerContext from the original request
 * @param request the original request
 * @param exception the ConnectorException that was thrown by the facade
 * @param resourceId the resourceId being operated on
 * @param before the object value ""before"" the request
 * @param after the object value ""after"" the request
 * @param handler the ResultHandler on which to call handleError
 * @param connectorExceptionActivityLogger the ActivityLogger to use to log the exception
 */
private void handleConnectorException(ServerContext context,Request request,ConnectorException exception,String resourceId,JsonValue before,JsonValue after,ResultHandler<?> handler,ActivityLogger connectorExceptionActivityLogger){
  String message=MessageFormat.format(""String_Node_Str"",request.getRequestType(),exception.getClass().getSimpleName(),resourceId);
  try {
    throw exception;
  }
 catch (  AlreadyExistsException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getResourceName());
    handler.handleError(new ConflictException(message,exception));
  }
catch (  ConfigurationException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
catch (  ConnectionBrokenException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  ConnectionFailedException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  ConnectorIOException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  OperationTimeoutException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  PasswordExpiredException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ForbiddenException(message,exception));
  }
catch (  InvalidPasswordException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(ResourceException.getException(UNAUTHORIZED_ERROR_CODE,message,exception));
  }
catch (  UnknownUidException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),request.getResourceName(),resourceId);
    handler.handleError(new NotFoundException(message,exception).setDetail(new JsonValue(new HashMap<String,Object>())));
  }
catch (  InvalidCredentialException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(ResourceException.getException(UNAUTHORIZED_ERROR_CODE,message,exception));
  }
catch (  PermissionDeniedException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ForbiddenException(message,exception));
  }
catch (  ConnectorSecurityException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
catch (  InvalidAttributeValueException e) {
    message=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new BadRequestException(message,exception));
  }
catch (  PreconditionFailedException e) {
    message=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",request.getResourceName(),request.getRequestType().toString(),resourceId);
    handler.handleError(new org.forgerock.json.resource.PreconditionFailedException(message,exception));
  }
catch (  PreconditionRequiredException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getResourceName(),request.getRequestType().toString(),resourceId);
    handler.handleError(new org.forgerock.json.resource.PreconditionRequiredException(message,exception));
  }
catch (  RetryableException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  UnsupportedOperationException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new NotFoundException(message,exception));
  }
catch (  IllegalArgumentException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,e));
  }
catch (  RemoteWrappedException e) {
    handleRemoteWrappedException(context,request,exception,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
catch (  ConnectorException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
 finally {
    logger.debug(message,exception);
    try {
      connectorExceptionActivityLogger.log(context,request.getRequestType(),message,resourceId,before,after,Status.FAILURE);
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
    }
  }
}","/** 
 * Handle ConnectorExceptions from ConnectorFacade invocations.  Maps each ConnectorException subtype to the appropriate   {@link ResourceException} for passing to {@code handleError}.  Optionally logs to activity log.
 * @param context the ServerContext from the original request
 * @param request the original request
 * @param exception the ConnectorException that was thrown by the facade
 * @param resourceId the resourceId being operated on
 * @param before the object value ""before"" the request
 * @param after the object value ""after"" the request
 * @param handler the ResultHandler on which to call handleError
 * @param connectorExceptionActivityLogger the ActivityLogger to use to log the exception
 */
private void handleConnectorException(ServerContext context,Request request,ConnectorException exception,String resourceId,JsonValue before,JsonValue after,ResultHandler<?> handler,ActivityLogger connectorExceptionActivityLogger){
  String message=MessageFormat.format(""String_Node_Str"",request.getRequestType(),exception.getClass().getSimpleName(),resourceId);
  try {
    throw exception;
  }
 catch (  AlreadyExistsException e) {
    message=MessageFormat.format(""String_Node_Str"",resourceId);
    handler.handleError(new ConflictException(message,exception));
  }
catch (  ConfigurationException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
catch (  ConnectionBrokenException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  ConnectionFailedException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  ConnectorIOException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  OperationTimeoutException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  PasswordExpiredException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ForbiddenException(message,exception));
  }
catch (  InvalidPasswordException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(ResourceException.getException(UNAUTHORIZED_ERROR_CODE,message,exception));
  }
catch (  UnknownUidException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),request.getResourceName(),resourceId);
    handler.handleError(new NotFoundException(message,exception).setDetail(new JsonValue(new HashMap<String,Object>())));
  }
catch (  InvalidCredentialException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(ResourceException.getException(UNAUTHORIZED_ERROR_CODE,message,exception));
  }
catch (  PermissionDeniedException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ForbiddenException(message,exception));
  }
catch (  ConnectorSecurityException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
catch (  InvalidAttributeValueException e) {
    message=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new BadRequestException(message,exception));
  }
catch (  PreconditionFailedException e) {
    message=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",request.getResourceName(),request.getRequestType().toString(),resourceId);
    handler.handleError(new org.forgerock.json.resource.PreconditionFailedException(message,exception));
  }
catch (  PreconditionRequiredException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getResourceName(),request.getRequestType().toString(),resourceId);
    handler.handleError(new org.forgerock.json.resource.PreconditionRequiredException(message,exception));
  }
catch (  RetryableException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  UnsupportedOperationException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new NotFoundException(message,exception));
  }
catch (  IllegalArgumentException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,e));
  }
catch (  RemoteWrappedException e) {
    handleRemoteWrappedException(context,request,exception,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
catch (  ConnectorException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
 finally {
    logger.debug(message,exception);
    try {
      connectorExceptionActivityLogger.log(context,request.getRequestType(),message,resourceId,before,after,Status.FAILURE);
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
    }
  }
}"
13247,"/** 
 * This newBuilder and this method can not be scheduled. The call MUST go through the   {@code org.forgerock.openidm.provisioner}<p/> Invoked by the scheduler when the scheduler triggers. <p/> Synchronization object:   {@code ""connectorData"" : ""syncToken"" :""1305555929000"", ""nativeType"" : ""JAVA_TYPE_LONG"" }, ""synchronizationStatus"" : { ""errorStatus"" : null, ""lastKnownServer"" : ""localServer"", ""lastModDate"" : ""2011-05-16T14:47:58.587Z"", ""lastModNum"" : 668, ""lastPollDate"" : ""2011-05-16T14:47:52.875Z"", ""lastStartTime"" : ""2011-05-16T14:29:07.863Z"", ""progressMessage"" : ""SUCCEEDED"" } }} <p/>  {@inheritDoc} Synchronise the changes from the end system for the given{@code objectType}. <p/> OpenIDM takes active role in the synchronization process by asking the end system to get all changed object. Not all systems are capable to fulfill this kind of request but if the end system is capable then the implementation sends each change to a new request on the router and when it is finished, it returns a new <b>stage</b> object. <p/> The   {@code previousStage} object is the previously returned value of thismethod.
 * @param previousStage The previously returned object. If null then it's the first execution.
 * @return The new updated stage object. This will be the{@code previousStage} at buildNext call.
 * @throws IllegalArgumentException if the value of  {@code connectorData} can not be converted to{@link SyncToken}.
 * @throws UnsupportedOperationException if the  {@link SyncApiOp} operation is not implemented inconnector.
 * @throws org.forgerock.json.fluent.JsonValueException if the  {@code previousStage} is not Map.
 * @see {@link ConnectorUtil#convertToSyncToken(org.forgerock.json.fluent.JsonValue)}or any exception happed inside the connector.
 */
public JsonValue liveSynchronize(final String objectType,final JsonValue previousStage) throws ResourceException {
  if (!serviceAvailable) {
    return previousStage;
  }
  JsonValue stage=previousStage != null ? previousStage.copy() : new JsonValue(new LinkedHashMap<String,Object>());
  JsonValue connectorData=stage.get(""String_Node_Str"");
  SyncToken token=null;
  if (!connectorData.isNull()) {
    if (connectorData.isMap()) {
      token=ConnectorUtil.convertToSyncToken(connectorData);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  stage.remove(""String_Node_Str"");
  try {
    final OperationHelper helper=operationHelperBuilder.build(objectType,stage,cryptoService);
    if (helper.isOperationPermitted(SyncApiOp.class)) {
      ConnectorFacade connector=getConnectorFacade();
      SyncApiOp operation=(SyncApiOp)connector.getOperation(SyncApiOp.class);
      if (null == operation) {
        throw new UnsupportedOperationException(SyncApiOp.class.getCanonicalName());
      }
      if (null == token) {
        token=operation.getLatestSyncToken(helper.getObjectClass());
        logger.debug(""String_Node_Str"",token);
      }
 else {
        final SyncToken[] lastToken=new SyncToken[]{token};
        final String[] failedRecord=new String[1];
        OperationOptionsBuilder operationOptionsBuilder=helper.getOperationOptionsBuilder(SyncApiOp.class,null,previousStage);
        try {
          logger.debug(""String_Node_Str"",new Object[]{helper.getObjectClass().getObjectClassValue(),token});
          SyncToken syncToken=operation.sync(helper.getObjectClass(),token,new SyncResultsHandler(){
            /** 
 * Called to handle a delta in the stream. The Connector framework will call this method multiple times, once for each result. Although this method is callback, the framework will invoke it synchronously. Thus, the framework guarantees that once an application's call to  {@link org.identityconnectors.framework.api.operations.SyncApiOp#sync(org.identityconnectors.framework.common.objects.ObjectClass,org.identityconnectors.framework.common.objects.SyncToken,org.identityconnectors.framework.common.objects.SyncResultsHandler,org.identityconnectors.framework.common.objects.OperationOptions)} SyncApiOp#sync() returns,the framework will no longer call this method to handle results from that <code>sync()</code> operation.
 * @param syncDelta The change
 * @return True iff the application wants to continue processing more results.
 * @throws RuntimeException If the application encounters an exception. This willstop iteration and the exception will propagate to the application.
 */
            @SuppressWarnings(""String_Node_Str"") public boolean handle(            SyncDelta syncDelta){
              try {
                final String resourceId=syncDelta.getUid().getUidValue();
                final String resourceContainer=getSource(objectType);
                final JsonValue content=new JsonValue(new LinkedHashMap<String,Object>(2));
switch (syncDelta.getDeltaType()) {
case CREATE:
{
                    JsonValue deltaObject=helper.build(syncDelta.getObject());
                    content.put(""String_Node_Str"",null);
                    content.put(""String_Node_Str"",deltaObject.getObject());
                    ActionRequest onCreateRequest=Requests.newActionRequest(""String_Node_Str"",""String_Node_Str"").setAdditionalParameter(""String_Node_Str"",resourceContainer).setAdditionalParameter(""String_Node_Str"",resourceId).setContent(content);
                    connectionFactory.getConnection().action(routerContext,onCreateRequest);
                    activityLogger.log(routerContext,RequestType.ACTION,""String_Node_Str"",onCreateRequest.getResourceName(),deltaObject,deltaObject,Status.SUCCESS);
                    break;
                  }
case UPDATE:
case CREATE_OR_UPDATE:
{
                  JsonValue deltaObject=helper.build(syncDelta.getObject());
                  content.put(""String_Node_Str"",null);
                  content.put(""String_Node_Str"",deltaObject.getObject());
                  if (null != syncDelta.getPreviousUid()) {
                    deltaObject.put(""String_Node_Str"",syncDelta.getPreviousUid().getUidValue());
                  }
                  ActionRequest onUpdateRequest=Requests.newActionRequest(""String_Node_Str"",""String_Node_Str"").setAdditionalParameter(""String_Node_Str"",resourceContainer).setAdditionalParameter(""String_Node_Str"",resourceId).setContent(content);
                  connectionFactory.getConnection().action(routerContext,onUpdateRequest);
                  activityLogger.log(routerContext,RequestType.ACTION,""String_Node_Str"",onUpdateRequest.getResourceName(),deltaObject,deltaObject,Status.SUCCESS);
                  break;
                }
case DELETE:
              content.put(""String_Node_Str"",null);
            ActionRequest onDeleteRequest=Requests.newActionRequest(""String_Node_Str"",""String_Node_Str"").setAdditionalParameter(""String_Node_Str"",resourceContainer).setAdditionalParameter(""String_Node_Str"",resourceId).setContent(content);
          connectionFactory.getConnection().action(routerContext,onDeleteRequest);
        activityLogger.log(routerContext,RequestType.ACTION,""String_Node_Str"",onDeleteRequest.getResourceName(),null,null,Status.SUCCESS);
      break;
  }
}
 catch (Exception e) {
  failedRecord[0]=SerializerUtil.serializeXmlObject(syncDelta,true);
  if (logger.isDebugEnabled()) {
    logger.error(""String_Node_Str"",syncDelta.getUid(),syncFailureHandler,e);
  }
  Map<String,Object> syncFailure=new HashMap<String,Object>(6);
  syncFailure.put(""String_Node_Str"",syncDelta.getToken().getValue());
  syncFailure.put(""String_Node_Str"",systemIdentifier.getName());
  syncFailure.put(""String_Node_Str"",objectType);
  syncFailure.put(""String_Node_Str"",syncDelta.getUid().getUidValue());
  syncFailure.put(""String_Node_Str"",failedRecord[0]);
  syncFailureHandler.invoke(syncFailure,e);
}
lastToken[0]=syncDelta.getToken();
return true;
}
}
,operationOptionsBuilder.build());
if (syncToken != null) {
lastToken[0]=syncToken;
}
}
 catch (Throwable t) {
Map<String,Object> lastException=new LinkedHashMap<String,Object>(2);
lastException.put(""String_Node_Str"",t.getMessage());
if (null != failedRecord[0]) {
lastException.put(""String_Node_Str"",failedRecord[0]);
}
stage.put(""String_Node_Str"",lastException);
if (logger.isDebugEnabled()) {
logger.error(""String_Node_Str"",new Object[]{objectType,systemIdentifier.getName()},t);
}
}
 finally {
token=lastToken[0];
logger.debug(""String_Node_Str"",token);
}
}
if (null != token) {
stage.put(""String_Node_Str"",ConnectorUtil.convertFromSyncToken(token));
}
}
}
 catch (ResourceException e) {
logger.debug(""String_Node_Str"",e);
throw new RuntimeException(e);
}
catch (UnsupportedOperationException e) {
logger.debug(""String_Node_Str"",e);
throw new NotFoundException(""String_Node_Str"" + e.getMessage(),e);
}
catch (Exception e) {
logger.debug(""String_Node_Str"",e);
throw new InternalServerErrorException(""String_Node_Str"" + e.getMessage(),e);
}
return stage;
}","/** 
 * This newBuilder and this method can not be scheduled. The call MUST go through the   {@code org.forgerock.openidm.provisioner}<p/> Invoked by the scheduler when the scheduler triggers. <p/> Synchronization object:   {@code ""connectorData"" : ""syncToken"" :""1305555929000"", ""nativeType"" : ""JAVA_TYPE_LONG"" }, ""synchronizationStatus"" : { ""errorStatus"" : null, ""lastKnownServer"" : ""localServer"", ""lastModDate"" : ""2011-05-16T14:47:58.587Z"", ""lastModNum"" : 668, ""lastPollDate"" : ""2011-05-16T14:47:52.875Z"", ""lastStartTime"" : ""2011-05-16T14:29:07.863Z"", ""progressMessage"" : ""SUCCEEDED"" } }} <p/>  {@inheritDoc} Synchronise the changes from the end system for the given{@code objectType}. <p/> OpenIDM takes active role in the synchronization process by asking the end system to get all changed object. Not all systems are capable to fulfill this kind of request but if the end system is capable then the implementation sends each change to a new request on the router and when it is finished, it returns a new <b>stage</b> object. <p/> The   {@code previousStage} object is the previously returned value of thismethod.
 * @param previousStage The previously returned object. If null then it's the first execution.
 * @return The new updated stage object. This will be the{@code previousStage} at buildNext call.
 * @throws IllegalArgumentException if the value of  {@code connectorData} can not be converted to{@link SyncToken}.
 * @throws UnsupportedOperationException if the  {@link SyncApiOp} operation is not implemented inconnector.
 * @throws org.forgerock.json.fluent.JsonValueException if the  {@code previousStage} is not Map.
 * @see {@link ConnectorUtil#convertToSyncToken(org.forgerock.json.fluent.JsonValue)}or any exception happed inside the connector.
 */
public JsonValue liveSynchronize(final String objectType,final JsonValue previousStage) throws ResourceException {
  if (!serviceAvailable) {
    return previousStage;
  }
  JsonValue stage=previousStage != null ? previousStage.copy() : new JsonValue(new LinkedHashMap<String,Object>());
  JsonValue connectorData=stage.get(""String_Node_Str"");
  SyncToken token=null;
  if (!connectorData.isNull()) {
    if (connectorData.isMap()) {
      token=ConnectorUtil.convertToSyncToken(connectorData);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  stage.remove(""String_Node_Str"");
  try {
    final OperationHelper helper=operationHelperBuilder.build(objectType,stage,cryptoService);
    if (helper.isOperationPermitted(SyncApiOp.class)) {
      ConnectorFacade connector=getConnectorFacade();
      SyncApiOp operation=(SyncApiOp)connector.getOperation(SyncApiOp.class);
      if (null == operation) {
        throw new UnsupportedOperationException(SyncApiOp.class.getCanonicalName());
      }
      if (null == token) {
        token=operation.getLatestSyncToken(helper.getObjectClass());
        logger.debug(""String_Node_Str"",token);
      }
 else {
        final SyncToken[] lastToken=new SyncToken[]{token};
        final String[] failedRecord=new String[1];
        OperationOptionsBuilder operationOptionsBuilder=helper.getOperationOptionsBuilder(SyncApiOp.class,null,previousStage);
        try {
          logger.debug(""String_Node_Str"",new Object[]{helper.getObjectClass().getObjectClassValue(),token});
          SyncToken syncToken=operation.sync(helper.getObjectClass(),token,new SyncResultsHandler(){
            /** 
 * Called to handle a delta in the stream. The Connector framework will call this method multiple times, once for each result. Although this method is callback, the framework will invoke it synchronously. Thus, the framework guarantees that once an application's call to  {@link org.identityconnectors.framework.api.operations.SyncApiOp#sync(org.identityconnectors.framework.common.objects.ObjectClass,org.identityconnectors.framework.common.objects.SyncToken,org.identityconnectors.framework.common.objects.SyncResultsHandler,org.identityconnectors.framework.common.objects.OperationOptions)} SyncApiOp#sync() returns,the framework will no longer call this method to handle results from that <code>sync()</code> operation.
 * @param syncDelta The change
 * @return True iff the application wants to continue processing more results.
 * @throws RuntimeException If the application encounters an exception. This willstop iteration and the exception will propagate to the application.
 */
            @SuppressWarnings(""String_Node_Str"") public boolean handle(            SyncDelta syncDelta){
              try {
                final String resourceId=syncDelta.getUid().getUidValue();
                final String resourceContainer=getSource(objectType);
                final JsonValue content=new JsonValue(new LinkedHashMap<String,Object>(2));
switch (syncDelta.getDeltaType()) {
case CREATE:
{
                    JsonValue deltaObject=helper.build(syncDelta.getObject());
                    content.put(""String_Node_Str"",null);
                    content.put(""String_Node_Str"",deltaObject.getObject());
                    ActionRequest onCreateRequest=Requests.newActionRequest(""String_Node_Str"",""String_Node_Str"").setAdditionalParameter(""String_Node_Str"",resourceContainer).setAdditionalParameter(""String_Node_Str"",resourceId).setContent(content);
                    connectionFactory.getConnection().action(routerContext,onCreateRequest);
                    activityLogger.log(routerContext,RequestType.ACTION,""String_Node_Str"",onCreateRequest.getResourceName(),deltaObject,deltaObject,Status.SUCCESS);
                    break;
                  }
case UPDATE:
case CREATE_OR_UPDATE:
{
                  JsonValue deltaObject=helper.build(syncDelta.getObject());
                  content.put(""String_Node_Str"",null);
                  content.put(""String_Node_Str"",deltaObject.getObject());
                  if (null != syncDelta.getPreviousUid()) {
                    deltaObject.put(""String_Node_Str"",syncDelta.getPreviousUid().getUidValue());
                  }
                  ActionRequest onUpdateRequest=Requests.newActionRequest(""String_Node_Str"",""String_Node_Str"").setAdditionalParameter(""String_Node_Str"",resourceContainer).setAdditionalParameter(""String_Node_Str"",resourceId).setContent(content);
                  connectionFactory.getConnection().action(routerContext,onUpdateRequest);
                  activityLogger.log(routerContext,RequestType.ACTION,""String_Node_Str"",onUpdateRequest.getResourceName(),deltaObject,deltaObject,Status.SUCCESS);
                  break;
                }
case DELETE:
              content.put(""String_Node_Str"",null);
            ActionRequest onDeleteRequest=Requests.newActionRequest(""String_Node_Str"",""String_Node_Str"").setAdditionalParameter(""String_Node_Str"",resourceContainer).setAdditionalParameter(""String_Node_Str"",resourceId).setContent(content);
          connectionFactory.getConnection().action(routerContext,onDeleteRequest);
        activityLogger.log(routerContext,RequestType.ACTION,""String_Node_Str"",onDeleteRequest.getResourceName(),null,null,Status.SUCCESS);
      break;
  }
}
 catch (Exception e) {
  failedRecord[0]=SerializerUtil.serializeXmlObject(syncDelta,true);
  if (logger.isDebugEnabled()) {
    logger.error(""String_Node_Str"",syncDelta.getUid(),syncFailureHandler,e);
  }
  Map<String,Object> syncFailure=new HashMap<String,Object>(6);
  syncFailure.put(""String_Node_Str"",syncDelta.getToken().getValue());
  syncFailure.put(""String_Node_Str"",systemIdentifier.getName());
  syncFailure.put(""String_Node_Str"",objectType);
  syncFailure.put(""String_Node_Str"",syncDelta.getUid().getUidValue());
  syncFailure.put(""String_Node_Str"",failedRecord[0]);
  syncFailureHandler.invoke(syncFailure,e);
}
lastToken[0]=syncDelta.getToken();
return true;
}
}
,operationOptionsBuilder.build());
if (syncToken != null) {
lastToken[0]=syncToken;
}
}
 catch (Throwable t) {
Map<String,Object> lastException=new LinkedHashMap<String,Object>(2);
lastException.put(""String_Node_Str"",t.getMessage());
if (null != failedRecord[0]) {
lastException.put(""String_Node_Str"",failedRecord[0]);
}
stage.put(""String_Node_Str"",lastException);
if (logger.isDebugEnabled()) {
logger.error(""String_Node_Str"",new Object[]{objectType,systemIdentifier.getName()},t);
}
}
 finally {
token=lastToken[0];
logger.debug(""String_Node_Str"",token);
}
}
if (null != token) {
stage.put(""String_Node_Str"",ConnectorUtil.convertFromSyncToken(token));
}
}
}
 catch (ResourceException e) {
logger.debug(""String_Node_Str"",e);
throw new RuntimeException(e);
}
catch (UnsupportedOperationException e) {
logger.debug(""String_Node_Str"",e);
throw new NotFoundException(""String_Node_Str"",e).setDetail(new JsonValue(e.getMessage()));
}
catch (Exception e) {
logger.debug(""String_Node_Str"",e);
throw new InternalServerErrorException(""String_Node_Str"" + e.getMessage(),e);
}
return stage;
}"
13248,"public void evaluateOnFailure(final ServerContext context,final ScriptState state,final ResourceException error,final ResultHandler<?> handler) throws ResourceException {
  if (onFailure != null) {
    ScriptEntry scriptEntry=onFailure.getRight();
    if (!scriptEntry.isActive()) {
      throw new ServiceUnavailableException(""String_Node_Str"" + onFailure.getRight().getName());
    }
    Script script=populateScript(scriptEntry,context,state.request);
    script.put(""String_Node_Str"",error.toJsonValue().asMap());
    try {
      state.state=script.eval();
    }
 catch (    Throwable t) {
      logger.debug(""String_Node_Str"",onFailure.getRight().getName(),onFailure.getLeft(),t);
      throw Utils.adapt(t);
    }
  }
}","public void evaluateOnFailure(final ServerContext context,final ScriptState state,final ResourceException error,final ResultHandler<?> handler) throws ResourceException {
  if (onFailure != null) {
    ScriptEntry scriptEntry=onFailure.getRight();
    if (!scriptEntry.isActive()) {
      throw new ServiceUnavailableException(""String_Node_Str"" + onFailure.getRight().getName());
    }
    Script script=populateScript(scriptEntry,context,state.request);
    script.put(""String_Node_Str"",error.includeCauseInJsonValue().toJsonValue().asMap());
    try {
      state.state=script.eval();
    }
 catch (    Throwable t) {
      logger.debug(""String_Node_Str"",onFailure.getRight().getName(),onFailure.getLeft(),t);
      throw Utils.adapt(t);
    }
  }
}"
13249,"@Override public void createInstance(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  try {
    if (objectClassInfoHelper.isCreateable()) {
      if (null == request.getNewResourceId()) {
        final ConnectorFacade facade=getConnectorFacade0(handler,CreateApiOp.class);
        if (null == facade) {
          return;
        }
        final Set<Attribute> createAttributes=objectClassInfoHelper.getCreateAttributes(request,cryptoService);
        OperationOptions operationOptions=operations.get(CreateApiOp.class).build(jsonConfiguration,objectClassInfoHelper).build();
        Uid uid=facade.create(objectClassInfoHelper.getObjectClass(),AttributeUtil.filterUid(createAttributes),operationOptions);
        returnResource(request,handler,facade,uid);
      }
 else {
        final ResourceException e=new NotSupportedException(""String_Node_Str"");
        handler.handleError(e);
      }
    }
 else {
      final ResourceException e=new NotSupportedException(""String_Node_Str"" + objectClassInfoHelper.getObjectClass());
      handler.handleError(e);
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,request.getNewResourceId(),request.getContent(),null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e.getMessage()));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage()));
  }
}","@Override public void createInstance(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  try {
    if (objectClassInfoHelper.isCreateable()) {
      if (null == request.getNewResourceId()) {
        final ConnectorFacade facade=getConnectorFacade0(handler,CreateApiOp.class);
        if (null == facade) {
          return;
        }
        final Set<Attribute> createAttributes=objectClassInfoHelper.getCreateAttributes(request,cryptoService);
        OperationOptions operationOptions=operations.get(CreateApiOp.class).build(jsonConfiguration,objectClassInfoHelper).build();
        Uid uid=facade.create(objectClassInfoHelper.getObjectClass(),AttributeUtil.filterUid(createAttributes),operationOptions);
        returnResource(request,handler,facade,uid);
      }
 else {
        final ResourceException e=new NotSupportedException(""String_Node_Str"");
        handler.handleError(e);
      }
    }
 else {
      final ResourceException e=new NotSupportedException(""String_Node_Str"" + objectClassInfoHelper.getObjectClass());
      handler.handleError(e);
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,request.getNewResourceId(),request.getContent(),null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e.getMessage(),e));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}"
13250,"@Override public void queryCollection(final ServerContext context,final QueryRequest request,final QueryResultHandler handler){
  EventEntry measure=null;
  try {
    final ConnectorFacade facade=getConnectorFacade0(handler,SearchApiOp.class);
    if (null == facade) {
      return;
    }
    OperationOptionsBuilder operationOptionsBuilder=operations.get(SearchApiOp.class).build(jsonConfiguration,objectClassInfoHelper);
    Filter filter=null;
    if (request.getQueryId() != null) {
      if (ServerConstants.QUERY_ALL_IDS.equals(request.getQueryId())) {
        operationOptionsBuilder.setAttributesToGet(Uid.NAME);
      }
 else {
        handler.handleError(new BadRequestException(""String_Node_Str"" + request.getQueryId()));
        return;
      }
    }
 else     if (request.getQueryExpression() != null) {
      filter=QueryFilter.valueOf(request.getQueryExpression()).accept(RESOURCE_FILTER,objectClassInfoHelper);
    }
 else {
      filter=request.getQueryFilter().accept(RESOURCE_FILTER,objectClassInfoHelper);
    }
    final int pageSize=request.getPageSize();
    final String pagedResultsCookie=request.getPagedResultsCookie();
    final boolean pagedResultsRequested=request.getPageSize() > 0;
    if (pageSize > 0) {
      operationOptionsBuilder.setPageSize(pageSize);
    }
    if (null != pagedResultsCookie) {
      operationOptionsBuilder.setPagedResultsCookie(pagedResultsCookie);
    }
    operationOptionsBuilder.setPagedResultsOffset(request.getPagedResultsOffset());
    if (null != request.getSortKeys()) {
      List<SortKey> sortKeys=new ArrayList<SortKey>(request.getSortKeys().size());
      for (      org.forgerock.json.resource.SortKey s : request.getSortKeys()) {
        sortKeys.add(new SortKey(s.getField().leaf(),s.isAscendingOrder()));
      }
      operationOptionsBuilder.setSortKeys(sortKeys);
    }
    SearchResult searchResult=facade.search(objectClassInfoHelper.getObjectClass(),filter,new ResultsHandler(){
      @Override public boolean handle(      ConnectorObject obj){
        try {
          return handler.handleResource(objectClassInfoHelper.build(obj,cryptoService));
        }
 catch (        Exception e) {
          handler.handleError(new InternalServerErrorException(e));
          return false;
        }
      }
    }
,operationOptionsBuilder.build());
    handler.handleResult(new QueryResult(searchResult != null ? searchResult.getPagedResultsCookie() : null,searchResult != null ? searchResult.getRemainingPagedResults() : -1));
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,null,null,null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e));
  }
 finally {
  }
}","@Override public void queryCollection(final ServerContext context,final QueryRequest request,final QueryResultHandler handler){
  EventEntry measure=null;
  try {
    final ConnectorFacade facade=getConnectorFacade0(handler,SearchApiOp.class);
    if (null == facade) {
      return;
    }
    OperationOptionsBuilder operationOptionsBuilder=operations.get(SearchApiOp.class).build(jsonConfiguration,objectClassInfoHelper);
    Filter filter=null;
    if (request.getQueryId() != null) {
      if (ServerConstants.QUERY_ALL_IDS.equals(request.getQueryId())) {
        operationOptionsBuilder.setAttributesToGet(Uid.NAME);
      }
 else {
        handler.handleError(new BadRequestException(""String_Node_Str"" + request.getQueryId()));
        return;
      }
    }
 else     if (request.getQueryExpression() != null) {
      filter=QueryFilter.valueOf(request.getQueryExpression()).accept(RESOURCE_FILTER,objectClassInfoHelper);
    }
 else {
      filter=request.getQueryFilter().accept(RESOURCE_FILTER,objectClassInfoHelper);
    }
    final int pageSize=request.getPageSize();
    final String pagedResultsCookie=request.getPagedResultsCookie();
    final boolean pagedResultsRequested=request.getPageSize() > 0;
    if (pageSize > 0) {
      operationOptionsBuilder.setPageSize(pageSize);
    }
    if (null != pagedResultsCookie) {
      operationOptionsBuilder.setPagedResultsCookie(pagedResultsCookie);
    }
    operationOptionsBuilder.setPagedResultsOffset(request.getPagedResultsOffset());
    if (null != request.getSortKeys()) {
      List<SortKey> sortKeys=new ArrayList<SortKey>(request.getSortKeys().size());
      for (      org.forgerock.json.resource.SortKey s : request.getSortKeys()) {
        sortKeys.add(new SortKey(s.getField().leaf(),s.isAscendingOrder()));
      }
      operationOptionsBuilder.setSortKeys(sortKeys);
    }
    SearchResult searchResult=facade.search(objectClassInfoHelper.getObjectClass(),filter,new ResultsHandler(){
      @Override public boolean handle(      ConnectorObject obj){
        try {
          return handler.handleResource(objectClassInfoHelper.build(obj,cryptoService));
        }
 catch (        Exception e) {
          handler.handleError(new InternalServerErrorException(e.getMessage(),e));
          return false;
        }
      }
    }
,operationOptionsBuilder.build());
    handler.handleResult(new QueryResult(searchResult != null ? searchResult.getPagedResultsCookie() : null,searchResult != null ? searchResult.getRemainingPagedResults() : -1));
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,null,null,null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e.getMessage(),e));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
 finally {
  }
}"
13251,"public void handlePatch(ServerContext context,PatchRequest request,ResultHandler<Resource> handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handlePatch(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e));
  }
}","public void handlePatch(ServerContext context,PatchRequest request,ResultHandler<Resource> handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handlePatch(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}"
13252,"public void handleRead(ServerContext context,ReadRequest request,ResultHandler<Resource> handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handleRead(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e));
  }
}","public void handleRead(ServerContext context,ReadRequest request,ResultHandler<Resource> handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handleRead(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}"
13253,"public void handleQuery(ServerContext context,QueryRequest request,QueryResultHandler handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handleQuery(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e));
  }
}","public void handleQuery(ServerContext context,QueryRequest request,QueryResultHandler handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handleQuery(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}"
13254,"public void handleUpdate(ServerContext context,UpdateRequest request,ResultHandler<Resource> handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handleUpdate(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e));
  }
}","public void handleUpdate(ServerContext context,UpdateRequest request,ResultHandler<Resource> handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handleUpdate(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}"
13255,"public void handleDelete(ServerContext context,DeleteRequest request,ResultHandler<Resource> handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handleDelete(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e));
  }
}","public void handleDelete(ServerContext context,DeleteRequest request,ResultHandler<Resource> handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handleDelete(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}"
13256,"@Override public void deleteInstance(ServerContext context,String resourceId,DeleteRequest request,ResultHandler<Resource> handler){
  try {
    final ConnectorFacade facade=getConnectorFacade0(handler,DeleteApiOp.class);
    if (null == facade) {
      return;
    }
    OperationOptions operationOptions=operations.get(DeleteApiOp.class).build(jsonConfiguration,objectClassInfoHelper).build();
    Uid uid=null != request.getRevision() ? new Uid(resourceId,request.getRevision()) : new Uid(resourceId);
    facade.delete(objectClassInfoHelper.getObjectClass(),uid,operationOptions);
    JsonValue result=new JsonValue(new HashMap<String,Object>());
    result.put(Resource.FIELD_CONTENT_ID,uid.getUidValue());
    if (null != uid.getRevision()) {
      result.put(Resource.FIELD_CONTENT_REVISION,uid.getRevision());
    }
    handler.handleResult(new Resource(uid.getUidValue(),uid.getRevision(),result));
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,resourceId,null,null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e.getMessage()));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage()));
  }
}","@Override public void deleteInstance(ServerContext context,String resourceId,DeleteRequest request,ResultHandler<Resource> handler){
  try {
    final ConnectorFacade facade=getConnectorFacade0(handler,DeleteApiOp.class);
    if (null == facade) {
      return;
    }
    OperationOptions operationOptions=operations.get(DeleteApiOp.class).build(jsonConfiguration,objectClassInfoHelper).build();
    Uid uid=null != request.getRevision() ? new Uid(resourceId,request.getRevision()) : new Uid(resourceId);
    facade.delete(objectClassInfoHelper.getObjectClass(),uid,operationOptions);
    JsonValue result=new JsonValue(new HashMap<String,Object>());
    result.put(Resource.FIELD_CONTENT_ID,uid.getUidValue());
    if (null != uid.getRevision()) {
      result.put(Resource.FIELD_CONTENT_REVISION,uid.getRevision());
    }
    handler.handleResult(new Resource(uid.getUidValue(),uid.getRevision(),result));
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  ConnectorException e) {
    handleConnectorException(context,request,e,resourceId,null,null,handler,activityLogger);
  }
catch (  JsonValueException e) {
    handler.handleError(new BadRequestException(e.getMessage(),e));
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}"
13257,"@Override public void actionCollection(ServerContext context,ActionRequest request,ResultHandler<JsonValue> handler){
  try {
switch (request.getActionAsEnum(ObjectClassAction.class)) {
case authenticate:
      handleAuthenticate(context,request,handler);
    break;
case liveSync:
  handleLiveSync(context,request,handler);
break;
default :
throw new BadRequestException(""String_Node_Str"" + request.getAction());
}
}
 catch (ResourceException e) {
handler.handleError(e);
}
catch (JsonValueException e) {
handler.handleError(new BadRequestException(e));
}
catch (Exception e) {
handler.handleError(new InternalServerErrorException(e));
}
}","@Override public void actionCollection(ServerContext context,ActionRequest request,ResultHandler<JsonValue> handler){
  try {
switch (request.getActionAsEnum(ObjectClassAction.class)) {
case authenticate:
      handleAuthenticate(context,request,handler);
    break;
case liveSync:
  handleLiveSync(context,request,handler);
break;
default :
throw new BadRequestException(""String_Node_Str"" + request.getAction());
}
}
 catch (ResourceException e) {
handler.handleError(e);
}
catch (JsonValueException e) {
handler.handleError(new BadRequestException(e.getMessage(),e));
}
catch (Exception e) {
handler.handleError(new InternalServerErrorException(e.getMessage(),e));
}
}"
13258,"public void handleAction(ServerContext context,ActionRequest request,ResultHandler<JsonValue> handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handleAction(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e));
  }
}","public void handleAction(ServerContext context,ActionRequest request,ResultHandler<JsonValue> handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handleAction(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}"
13259,"/** 
 * Handle ConnectorExceptions from ConnectorFacade invocations.  Maps each ConnectorException subtype to the appropriate   {@link ResourceException} for passing to {@code handleError}.  Optionally logs to activity log.
 * @param context the ServerContext from the original request
 * @param request the original request
 * @param exception the ConnectorException that was thrown by the facade
 * @param resourceId the resourceId being operated on
 * @param before the object value ""before"" the request
 * @param after the object value ""after"" the request
 * @param handler the ResultHandler on which to call handleError
 * @param connectorExceptionActivityLogger the ActivityLogger to use to log the exception
 */
private void handleConnectorException(ServerContext context,Request request,ConnectorException exception,String resourceId,JsonValue before,JsonValue after,ResultHandler<?> handler,ActivityLogger connectorExceptionActivityLogger){
  String message=MessageFormat.format(""String_Node_Str"",request.getRequestType(),exception.getClass().getSimpleName(),resourceId);
  try {
    throw exception;
  }
 catch (  AlreadyExistsException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getResourceName());
    handler.handleError(new ConflictException(message,exception));
  }
catch (  ConfigurationException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
catch (  ConnectionBrokenException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  ConnectionFailedException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  ConnectorIOException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  OperationTimeoutException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  PasswordExpiredException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ForbiddenException(message,exception));
  }
catch (  InvalidPasswordException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(ResourceException.getException(UNAUTHORIZED_ERROR_CODE,message,exception));
  }
catch (  UnknownUidException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),request.getResourceName(),resourceId);
    handler.handleError(new NotFoundException(message,exception).setDetail(new JsonValue(new HashMap<String,Object>())));
  }
catch (  InvalidCredentialException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(ResourceException.getException(UNAUTHORIZED_ERROR_CODE,message,exception));
  }
catch (  PermissionDeniedException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ForbiddenException(message,exception));
  }
catch (  ConnectorSecurityException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
catch (  InvalidAttributeValueException e) {
    message=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new BadRequestException(e));
  }
catch (  PreconditionFailedException e) {
    message=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",request.getResourceName(),request.getRequestType().toString(),resourceId);
    handler.handleError(new org.forgerock.json.resource.PreconditionFailedException(e));
  }
catch (  PreconditionRequiredException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getResourceName(),request.getRequestType().toString(),resourceId);
    handler.handleError(new org.forgerock.json.resource.PreconditionRequiredException(e));
  }
catch (  RetryableException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(e));
  }
catch (  UnsupportedOperationException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new NotFoundException(e));
  }
catch (  IllegalArgumentException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(e));
  }
catch (  RemoteWrappedException e) {
    handleRemoteWrappedException(context,request,exception,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
catch (  ConnectorException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
 finally {
    logger.debug(message,exception);
    try {
      connectorExceptionActivityLogger.log(context,request.getRequestType(),message,resourceId,before,after,Status.FAILURE);
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
    }
  }
}","/** 
 * Handle ConnectorExceptions from ConnectorFacade invocations.  Maps each ConnectorException subtype to the appropriate   {@link ResourceException} for passing to {@code handleError}.  Optionally logs to activity log.
 * @param context the ServerContext from the original request
 * @param request the original request
 * @param exception the ConnectorException that was thrown by the facade
 * @param resourceId the resourceId being operated on
 * @param before the object value ""before"" the request
 * @param after the object value ""after"" the request
 * @param handler the ResultHandler on which to call handleError
 * @param connectorExceptionActivityLogger the ActivityLogger to use to log the exception
 */
private void handleConnectorException(ServerContext context,Request request,ConnectorException exception,String resourceId,JsonValue before,JsonValue after,ResultHandler<?> handler,ActivityLogger connectorExceptionActivityLogger){
  String message=MessageFormat.format(""String_Node_Str"",request.getRequestType(),exception.getClass().getSimpleName(),resourceId);
  try {
    throw exception;
  }
 catch (  AlreadyExistsException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getResourceName());
    handler.handleError(new ConflictException(message,exception));
  }
catch (  ConfigurationException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
catch (  ConnectionBrokenException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  ConnectionFailedException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  ConnectorIOException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  OperationTimeoutException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  PasswordExpiredException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ForbiddenException(message,exception));
  }
catch (  InvalidPasswordException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(ResourceException.getException(UNAUTHORIZED_ERROR_CODE,message,exception));
  }
catch (  UnknownUidException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),request.getResourceName(),resourceId);
    handler.handleError(new NotFoundException(message,exception).setDetail(new JsonValue(new HashMap<String,Object>())));
  }
catch (  InvalidCredentialException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(ResourceException.getException(UNAUTHORIZED_ERROR_CODE,message,exception));
  }
catch (  PermissionDeniedException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ForbiddenException(message,exception));
  }
catch (  ConnectorSecurityException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
catch (  InvalidAttributeValueException e) {
    message=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new BadRequestException(message,exception));
  }
catch (  PreconditionFailedException e) {
    message=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",request.getResourceName(),request.getRequestType().toString(),resourceId);
    handler.handleError(new org.forgerock.json.resource.PreconditionFailedException(message,exception));
  }
catch (  PreconditionRequiredException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getResourceName(),request.getRequestType().toString(),resourceId);
    handler.handleError(new org.forgerock.json.resource.PreconditionRequiredException(message,exception));
  }
catch (  RetryableException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new ServiceUnavailableException(message,exception));
  }
catch (  UnsupportedOperationException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new NotFoundException(message,exception));
  }
catch (  IllegalArgumentException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,e));
  }
catch (  RemoteWrappedException e) {
    handleRemoteWrappedException(context,request,exception,resourceId,before,after,handler,connectorExceptionActivityLogger);
  }
catch (  ConnectorException e) {
    message=MessageFormat.format(""String_Node_Str"",request.getRequestType().toString(),resourceId);
    handler.handleError(new InternalServerErrorException(message,exception));
  }
 finally {
    logger.debug(message,exception);
    try {
      connectorExceptionActivityLogger.log(context,request.getRequestType(),message,resourceId,before,after,Status.FAILURE);
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
    }
  }
}"
13260,"public void handleCreate(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handleCreate(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e));
  }
}","public void handleCreate(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  try {
    String objectClass=getObjectClass(context);
    RequestHandler delegate=objectClassHandlers.get(objectClass);
    if (null != delegate) {
      delegate.handleCreate(context,request,handler);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + objectClass));
    }
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e.getMessage(),e));
  }
}"
13261,"@Override public void readInstance(ServerContext context,String resourceId,ReadRequest request,ResultHandler<Resource> handler){
  try {
    Authentication.setAuthenticatedUserId(context.asContext(SecurityContext.class).getAuthenticationId());
    String processDefinitionId=((RouterContext)context).getUriTemplateVariables().get(""String_Node_Str"");
    ProcessDefinitionEntity procdef=(ProcessDefinitionEntity)((RepositoryServiceImpl)processEngine.getRepositoryService()).getDeployedProcessDefinition(processDefinitionId);
    TaskDefinition taskDefinition=procdef.getTaskDefinitions().get(resourceId);
    Map value=mapper.convertValue(taskDefinition,HashMap.class);
    Resource r=new Resource(taskDefinition.getKey(),null,new JsonValue(value));
    FormService formService=processEngine.getFormService();
    String taskFormKey=formService.getTaskFormKey(processDefinitionId,resourceId);
    if (taskFormKey != null) {
      r.getContent().add(ActivitiConstants.ACTIVITI_FORMRESOURCEKEY,taskFormKey);
      ByteArrayInputStream startForm=(ByteArrayInputStream)((RepositoryServiceImpl)processEngine.getRepositoryService()).getResourceAsStream(procdef.getDeploymentId(),taskFormKey);
      Reader reader=new InputStreamReader(startForm);
      try {
        Scanner s=new Scanner(reader).useDelimiter(""String_Node_Str"");
        String formTemplate=s.hasNext() ? s.next() : ""String_Node_Str"";
        r.getContent().add(ActivitiConstants.ACTIVITI_FORMGENERATIONTEMPLATE,formTemplate);
      }
  finally {
        reader.close();
      }
    }
    handler.handleResult(r);
  }
 catch (  ActivitiObjectNotFoundException ex) {
    handler.handleError(new NotFoundException(ex.getMessage()));
  }
catch (  IllegalArgumentException ex) {
    handler.handleError(new InternalServerErrorException(ex.getMessage(),ex));
  }
catch (  Exception ex) {
    handler.handleError(new InternalServerErrorException(ex.getMessage(),ex));
  }
}","@Override public void readInstance(ServerContext context,String resourceId,ReadRequest request,ResultHandler<Resource> handler){
  try {
    Authentication.setAuthenticatedUserId(context.asContext(SecurityContext.class).getAuthenticationId());
    String processDefinitionId=((RouterContext)context).getUriTemplateVariables().get(""String_Node_Str"");
    ProcessDefinitionEntity procdef=(ProcessDefinitionEntity)((RepositoryServiceImpl)processEngine.getRepositoryService()).getDeployedProcessDefinition(processDefinitionId);
    TaskDefinition taskDefinition=procdef.getTaskDefinitions().get(resourceId);
    if (taskDefinition != null) {
      Map value=mapper.convertValue(taskDefinition,HashMap.class);
      Resource r=new Resource(taskDefinition.getKey(),null,new JsonValue(value));
      FormService formService=processEngine.getFormService();
      String taskFormKey=formService.getTaskFormKey(processDefinitionId,resourceId);
      if (taskFormKey != null) {
        r.getContent().add(ActivitiConstants.ACTIVITI_FORMRESOURCEKEY,taskFormKey);
        ByteArrayInputStream startForm=(ByteArrayInputStream)((RepositoryServiceImpl)processEngine.getRepositoryService()).getResourceAsStream(procdef.getDeploymentId(),taskFormKey);
        Reader reader=new InputStreamReader(startForm);
        try {
          Scanner s=new Scanner(reader).useDelimiter(""String_Node_Str"");
          String formTemplate=s.hasNext() ? s.next() : ""String_Node_Str"";
          r.getContent().add(ActivitiConstants.ACTIVITI_FORMGENERATIONTEMPLATE,formTemplate);
        }
  finally {
          reader.close();
        }
      }
      handler.handleResult(r);
    }
 else {
      handler.handleError(new NotFoundException(""String_Node_Str"" + resourceId + ""String_Node_Str""));
    }
  }
 catch (  ActivitiObjectNotFoundException ex) {
    handler.handleError(new NotFoundException(ex.getMessage()));
  }
catch (  IllegalArgumentException ex) {
    handler.handleError(new InternalServerErrorException(ex.getMessage(),ex));
  }
catch (  Exception ex) {
    handler.handleError(new InternalServerErrorException(ex.getMessage(),ex));
  }
}"
13262,"public Set<Attribute> getCreateAttributes(final CreateRequest request,final CryptoService cryptoService) throws ResourceException {
  JsonValue content=request.getContent().required().expect(Map.class);
  String nameValue=request.getNewResourceId();
  if (null == nameValue) {
    JsonValue o=content.get(nameAttribute);
    if (o.isNull()) {
      o=content.get(Resource.FIELD_CONTENT_ID);
    }
    if (o.isString()) {
      nameValue=o.asString();
    }
  }
  if (StringUtils.isBlank(nameValue)) {
    throw new BadRequestException(""String_Node_Str"" + nameAttribute + ""String_Node_Str"");
  }
  Set<String> keySet=content.keys();
  Map<String,Attribute> result=new HashMap<String,Attribute>(keySet.size());
  result.put(Name.NAME,new Name(nameValue));
  for (  AttributeInfoHelper attributeInfo : attributes) {
    if (Name.NAME.equals(attributeInfo.getAttributeInfo().getName()) || Uid.NAME.equals(attributeInfo.getAttributeInfo().getName()) || !keySet.contains(attributeInfo.getName())) {
      continue;
    }
    if (attributeInfo.getAttributeInfo().isCreateable()) {
      JsonValue v=content.get(attributeInfo.getName());
      if (v.isNull() && attributeInfo.getAttributeInfo().isRequired()) {
        throw new BadRequestException(""String_Node_Str"" + attributeInfo.getName() + ""String_Node_Str"");
      }
      Attribute a=attributeInfo.build(v.getObject(),cryptoService);
      if (null != a) {
        result.put(attributeInfo.getAttributeInfo().getName(),a);
      }
    }
  }
  if (logger.isTraceEnabled()) {
    ConnectorObjectBuilder builder=new ConnectorObjectBuilder().addAttributes(result.values());
    builder.setName(nameValue);
    builder.setUid(nameValue);
    logger.trace(""String_Node_Str"",SerializerUtil.serializeXmlObject(builder.build(),false));
  }
  return new HashSet<Attribute>(result.values());
}","public Set<Attribute> getCreateAttributes(final CreateRequest request,final CryptoService cryptoService) throws ResourceException {
  JsonValue content=request.getContent().required().expect(Map.class);
  String nameValue=request.getNewResourceId();
  if (null == nameValue) {
    JsonValue o=content.get(nameAttribute);
    if (o.isNull()) {
      o=content.get(Resource.FIELD_CONTENT_ID);
    }
    if (o.isString()) {
      nameValue=o.asString();
    }
  }
  if (StringUtils.isBlank(nameValue)) {
    throw new BadRequestException(""String_Node_Str"" + nameAttribute + ""String_Node_Str"");
  }
  Set<String> keySet=content.keys();
  Map<String,Attribute> result=new HashMap<String,Attribute>(keySet.size());
  result.put(Name.NAME,new Name(nameValue));
  for (  AttributeInfoHelper attributeInfo : attributes) {
    if (Name.NAME.equals(attributeInfo.getAttributeInfo().getName()) || Uid.NAME.equals(attributeInfo.getAttributeInfo().getName()) || (!keySet.contains(attributeInfo.getName()) && !attributeInfo.getAttributeInfo().isRequired())) {
      continue;
    }
    if (attributeInfo.getAttributeInfo().isCreateable()) {
      JsonValue v=content.get(attributeInfo.getName());
      if (v.isNull() && attributeInfo.getAttributeInfo().isRequired()) {
        throw new BadRequestException(""String_Node_Str"" + attributeInfo.getName() + ""String_Node_Str"");
      }
      Attribute a=attributeInfo.build(v.getObject(),cryptoService);
      if (null != a) {
        result.put(attributeInfo.getAttributeInfo().getName(),a);
      }
    }
  }
  if (logger.isTraceEnabled()) {
    ConnectorObjectBuilder builder=new ConnectorObjectBuilder().addAttributes(result.values());
    builder.setName(nameValue);
    builder.setUid(nameValue);
    logger.trace(""String_Node_Str"",SerializerUtil.serializeXmlObject(builder.build(),false));
  }
  return new HashSet<Attribute>(result.values());
}"
13263,"/** 
 * Execute the specified query
 * @param objectSet the object set to query
 * @param query the query parameters
 * @param collectionToPopulate the collection to populate with results
 * @param caseSensitive whether the collection should be populated in casesensitive fashion, or if false it populates as lower case only
 * @return the collection of (unqualified) ids
 * @throws SynchronizationException if retrieving or processing the ids failed
 */
protected Collection<String> query(final String objectSet,JsonValue query,final ReconciliationContext reconContext,Collection<String> collectionToPopulate,final boolean caseSensitive) throws SynchronizationException {
  final Collection<String> ids=collectionToPopulate;
  try {
    QueryRequest r=Requests.newQueryRequest(objectSet);
    r.setQueryId(query.get(QueryRequest.FIELD_QUERY_ID).asString());
    r.setQueryExpression(query.get(QueryRequest.FIELD_QUERY_EXPRESSION).asString());
    for (    Map.Entry<String,Object> e : query.asMap().entrySet()) {
      r.setAdditionalParameter(e.getKey(),String.valueOf(e.getValue()));
    }
    reconContext.getService().getConnectionFactory().getConnection().query(reconContext.getService().getRouter(),r,new QueryResultHandler(){
      @Override public void handleError(      ResourceException error){
      }
      @Override public boolean handleResource(      Resource resource){
        if (resource.getId() == null) {
          logger.warn(""String_Node_Str"",resource.toString());
        }
 else {
          ids.add(caseSensitive ? resource.getId() : reconContext.getObjectMapping().getLinkType().normalizeId(resource.getId()));
        }
        return true;
      }
      @Override public void handleResult(      QueryResult result){
      }
    }
);
  }
 catch (  JsonValueException jve) {
    throw new SynchronizationException(jve);
  }
catch (  ResourceException ose) {
    throw new SynchronizationException(ose);
  }
  reconContext.checkCanceled();
  return ids;
}","/** 
 * Execute the specified query
 * @param objectSet the object set to query
 * @param query the query parameters
 * @param collectionToPopulate the collection to populate with results
 * @param caseSensitive whether the collection should be populated in casesensitive fashion, or if false it populates as lower case only
 * @return the collection of (unqualified) ids
 * @throws SynchronizationException if retrieving or processing the ids failed
 */
protected Collection<String> query(final String objectSet,JsonValue query,final ReconciliationContext reconContext,Collection<String> collectionToPopulate,final boolean caseSensitive) throws SynchronizationException {
  final Collection<String> ids=collectionToPopulate;
  try {
    QueryRequest r=Requests.newQueryRequest(objectSet);
    r.setQueryId(query.get(QueryRequest.FIELD_QUERY_ID).asString());
    r.setQueryExpression(query.get(QueryRequest.FIELD_QUERY_EXPRESSION).asString());
    JsonValue queryFilter=query.get(QueryRequest.FIELD_QUERY_FILTER);
    if (!queryFilter.isNull()) {
      r.setQueryFilter(QueryFilter.valueOf(queryFilter.asString()));
    }
    for (    Map.Entry<String,Object> e : query.asMap().entrySet()) {
      r.setAdditionalParameter(e.getKey(),String.valueOf(e.getValue()));
    }
    reconContext.getService().getConnectionFactory().getConnection().query(reconContext.getService().getRouter(),r,new QueryResultHandler(){
      @Override public void handleError(      ResourceException error){
      }
      @Override public boolean handleResource(      Resource resource){
        if (resource.getId() == null) {
          logger.warn(""String_Node_Str"",resource.toString());
        }
 else {
          ids.add(caseSensitive ? resource.getId() : reconContext.getObjectMapping().getLinkType().normalizeId(resource.getId()));
        }
        return true;
      }
      @Override public void handleResult(      QueryResult result){
      }
    }
);
  }
 catch (  JsonValueException jve) {
    throw new SynchronizationException(jve);
  }
catch (  ResourceException ose) {
    throw new SynchronizationException(ose);
  }
  reconContext.checkCanceled();
  return ids;
}"
13264,"/** 
 * TODO: Description.
 * @param query TODO.
 * @return TODO.
 * @throws SynchronizationException TODO.
 */
private Map<String,Object> queryTargetObjectSet(Map<String,Object> query) throws SynchronizationException {
  try {
    Map<String,Object> result=new HashMap<String,Object>(1);
    final Collection<Object> list=new HashSet<Object>();
    result.put(QueryResult.FIELD_RESULT,list);
    QueryRequest r=Requests.newQueryRequest(targetObjectSet);
    r.setQueryId((String)query.get(""String_Node_Str"" + QueryRequest.FIELD_QUERY_ID));
    r.setQueryExpression((String)query.get(""String_Node_Str"" + QueryRequest.FIELD_QUERY_EXPRESSION));
    for (    Map.Entry<String,Object> e : query.entrySet()) {
      r.setAdditionalQueryParameter(e.getKey(),String.valueOf(e.getValue()));
    }
    service.getRouter().getConnection().query(service.getRouter(),r,new QueryResultHandler(){
      @Override public void handleError(      ResourceException error){
      }
      @Override public boolean handleResource(      Resource resource){
        list.add(resource.getContent().asMap());
        return true;
      }
      @Override public void handleResult(      QueryResult result){
      }
    }
);
    return result;
  }
 catch (  ResourceException ose) {
    throw new SynchronizationException(ose);
  }
}","/** 
 * TODO: Description.
 * @param query TODO.
 * @return TODO.
 * @throws SynchronizationException TODO.
 */
private Map<String,Object> queryTargetObjectSet(Map<String,Object> query) throws SynchronizationException {
  try {
    Map<String,Object> result=new HashMap<String,Object>(1);
    final Collection<Object> list=new ArrayList<Object>();
    result.put(QueryResult.FIELD_RESULT,list);
    QueryRequest r=Requests.newQueryRequest(targetObjectSet);
    r.setQueryId((String)query.get(""String_Node_Str"" + QueryRequest.FIELD_QUERY_ID));
    r.setQueryExpression((String)query.get(""String_Node_Str"" + QueryRequest.FIELD_QUERY_EXPRESSION));
    for (    Map.Entry<String,Object> e : query.entrySet()) {
      r.setAdditionalQueryParameter(e.getKey(),String.valueOf(e.getValue()));
    }
    service.getRouter().getConnection().query(service.getRouter(),r,new QueryResultHandler(){
      @Override public void handleError(      ResourceException error){
      }
      @Override public boolean handleResource(      Resource resource){
        list.add(resource.getContent().asMap());
        return true;
      }
      @Override public void handleResult(      QueryResult result){
      }
    }
);
    return result;
  }
 catch (  ResourceException ose) {
    throw new SynchronizationException(ose);
  }
}"
13265,"@Override public void createInstance(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  logger.debug(""String_Node_Str"",name,request.getNewResourceId());
  try {
    JsonValue value=decrypt(request.getContent());
    execScript(context,""String_Node_Str"",onCreate,value);
    onStore(context,value);
    CreateRequest createRequest=Requests.copyOfCreateRequest(request);
    createRequest.setContent(value);
    createRequest.setResourceName(repoId(null));
    Resource _new=context.getConnection().create(context,createRequest);
    ActivityLog.log(context,request.getRequestType(),""String_Node_Str"",managedId(_new.getId()),null,_new.getContent(),Status.SUCCESS);
    onCreate(context,managedId(_new.getId()),_new);
    handler.handleResult(_new);
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e));
  }
}","@Override public void createInstance(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  String id=request.getNewResourceId();
  JsonValue content=request.getContent();
  if (!content.get(Resource.FIELD_CONTENT_ID).isNull()) {
    id=content.get(Resource.FIELD_CONTENT_ID).asString();
  }
  logger.debug(""String_Node_Str"",name,id);
  try {
    JsonValue value=decrypt(request.getContent());
    execScript(context,""String_Node_Str"",onCreate,value);
    onStore(context,value);
    CreateRequest createRequest=Requests.copyOfCreateRequest(request);
    createRequest.setNewResourceId(id);
    createRequest.setContent(value);
    createRequest.setResourceName(repoId(null));
    Resource _new=context.getConnection().create(context,createRequest);
    ActivityLog.log(context,request.getRequestType(),""String_Node_Str"",managedId(_new.getId()),null,_new.getContent(),Status.SUCCESS);
    onCreate(context,managedId(_new.getId()),_new);
    handler.handleResult(_new);
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e));
  }
}"
13266,"/** 
 * Create an instance of a mapping between source and target
 * @param service The associated sychronization service
 * @param config The configuration for this mapping
 * @throws JsonValueException if there is an issue initializing based on the configuration.
 */
public ObjectMapping(SynchronizationService service,JsonValue config) throws JsonValueException {
  this.service=service;
  this.config=config;
  name=config.get(""String_Node_Str"").required().asString();
  linkTypeName=config.get(""String_Node_Str"").defaultTo(name).asString();
  sourceObjectSet=config.get(""String_Node_Str"").required().asString();
  targetObjectSet=config.get(""String_Node_Str"").required().asString();
  sourceIdsCaseSensitive=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  targetIdsCaseSensitive=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  validSource=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  validTarget=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  correlationQuery=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  for (  JsonValue jv : config.get(""String_Node_Str"").expect(List.class)) {
    properties.add(new PropertyMapping(service,jv));
  }
  for (  JsonValue jv : config.get(""String_Node_Str"").expect(List.class)) {
    policies.add(new Policy(service,jv));
  }
  onCreateScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onUpdateScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onDeleteScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onLinkScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onUnlinkScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  resultScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  prefetchLinks=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  Integer confTaskThreads=config.get(""String_Node_Str"").asInteger();
  if (confTaskThreads != null) {
    taskThreads=confTaskThreads.intValue();
  }
  correlateEmptyTargetSet=config.get(""String_Node_Str"").defaultTo(Boolean.FALSE).asBoolean();
  syncEnabled=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  linkingEnabled=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  LOGGER.debug(""String_Node_Str"",name);
}","/** 
 * Create an instance of a mapping between source and target
 * @param service The associated sychronization service
 * @param config The configuration for this mapping
 * @throws JsonValueException if there is an issue initializing based on the configuration.
 */
public ObjectMapping(SynchronizationService service,JsonValue config) throws JsonValueException {
  this.service=service;
  this.config=config;
  name=config.get(""String_Node_Str"").required().asString();
  linkTypeName=config.get(""String_Node_Str"").defaultTo(name).asString();
  sourceObjectSet=config.get(""String_Node_Str"").required().asString();
  targetObjectSet=config.get(""String_Node_Str"").required().asString();
  sourceIdsCaseSensitive=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  targetIdsCaseSensitive=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  validSource=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  validTarget=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  sourceCondition=config.get(""String_Node_Str"").expect(Map.class);
  correlationQuery=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  for (  JsonValue jv : config.get(""String_Node_Str"").expect(List.class)) {
    properties.add(new PropertyMapping(service,jv));
  }
  for (  JsonValue jv : config.get(""String_Node_Str"").expect(List.class)) {
    policies.add(new Policy(service,jv));
  }
  onCreateScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onUpdateScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onDeleteScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onLinkScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onUnlinkScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  resultScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  prefetchLinks=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  Integer confTaskThreads=config.get(""String_Node_Str"").asInteger();
  if (confTaskThreads != null) {
    taskThreads=confTaskThreads.intValue();
  }
  correlateEmptyTargetSet=config.get(""String_Node_Str"").defaultTo(Boolean.FALSE).asBoolean();
  syncEnabled=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  linkingEnabled=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  LOGGER.debug(""String_Node_Str"",name);
}"
13267,"/** 
 * Source synchronization
 * @param id fully-qualified source object identifier.
 * @param value null to have it query the source state if applicable,or JsonValue to tell it the value of the existing source to sync
 * @param sourceDeleted Whether the source object has been deleted
 * @throws SynchronizationException if sync-ing fails.
 */
private void doSourceSync(String id,JsonValue value,boolean sourceDeleted,JsonValue oldValue) throws SynchronizationException {
  LOGGER.trace(""String_Node_Str"",id,(value == null ? ""String_Node_Str"" : ""String_Node_Str""));
  String localId=id.substring(sourceObjectSet.length() + 1);
  SourceSyncOperation op=new SourceSyncOperation();
  op.oldValue=oldValue;
  if (sourceDeleted) {
    op.sourceObjectAccessor=new LazyObjectAccessor(service,sourceObjectSet,localId,null);
  }
 else   if (value != null) {
    value.put(""String_Node_Str"",localId);
    op.sourceObjectAccessor=new LazyObjectAccessor(service,sourceObjectSet,localId,value);
  }
 else {
    op.sourceObjectAccessor=new LazyObjectAccessor(service,sourceObjectSet,localId);
  }
  op.sync();
}","/** 
 * Source synchronization
 * @param id fully-qualified source object identifier.
 * @param value null to have it query the source state if applicable,or JsonValue to tell it the value of the existing source to sync
 * @param sourceDeleted Whether the source object has been deleted
 * @throws SynchronizationException if sync-ing fails.
 */
private void doSourceSync(String id,JsonValue value,boolean sourceDeleted,JsonValue oldValue) throws SynchronizationException {
  LOGGER.trace(""String_Node_Str"",id,(value == null ? ""String_Node_Str"" : ""String_Node_Str""));
  String localId=id.substring(sourceObjectSet.length() + 2);
  SourceSyncOperation op=new SourceSyncOperation();
  op.oldValue=oldValue;
  if (sourceDeleted) {
    op.sourceObjectAccessor=new LazyObjectAccessor(service,sourceObjectSet,localId,null);
  }
 else   if (value != null) {
    value.put(""String_Node_Str"",localId);
    op.sourceObjectAccessor=new LazyObjectAccessor(service,sourceObjectSet,localId,value);
  }
 else {
    op.sourceObjectAccessor=new LazyObjectAccessor(service,sourceObjectSet,localId);
  }
  op.sync();
}"
13268,"/** 
 * Returns   {@code true} if the specified object identifer is in this mapping's sourceobject set.
 */
private boolean isSourceObject(String id){
  return (id.startsWith(sourceObjectSet + '/') && id.length() > sourceObjectSet.length() + 1);
}","/** 
 * Returns   {@code true} if the specified object identifer is in this mapping's sourceobject set.
 */
private boolean isSourceObject(String id){
  return (id.startsWith(""String_Node_Str"" + sourceObjectSet + '/') && id.length() > sourceObjectSet.length() + 2);
}"
13269,"public Map<String,Object> testConfig(JsonValue config){
  Map<String,Object> result=new LinkedHashMap<String,Object>();
  JsonValue jv=new JsonValue(result);
  jv.add(""String_Node_Str"",systemIdentifier.getName());
  jv.add(""String_Node_Str"",false);
  SimpleSystemIdentifier testIdentifier=null;
  ConnectorReference connectorReference=null;
  try {
    testIdentifier=new SimpleSystemIdentifier(config);
    connectorReference=ConnectorUtil.getConnectorReference(jsonConfiguration);
  }
 catch (  JsonValueException e) {
    jv.add(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
    return result;
  }
  ConnectorInfo connectorInfo=connectorInfoProvider.findConnectorInfo(connectorReference);
  if (null != connectorInfo) {
    ConnectorFacade facade=null;
    try {
      ConnectorFacadeFactory connectorFacadeFactory=ConnectorFacadeFactory.getInstance();
      facade=connectorFacadeFactory.newInstance(connectorInfo.createDefaultAPIConfiguration());
    }
 catch (    Exception e) {
      e.printStackTrace();
      jv.add(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
      return result;
    }
    if (null != facade && facade.getSupportedOperations().contains(TestApiOp.class)) {
      try {
        facade.test();
      }
 catch (      UnsupportedOperationException e) {
        jv.put(""String_Node_Str"",""String_Node_Str"");
      }
catch (      Throwable e) {
        jv.put(""String_Node_Str"",e.getMessage());
        return result;
      }
      jv.put(""String_Node_Str"",true);
    }
 else     if (null == facade) {
      jv.add(""String_Node_Str"",""String_Node_Str"" + connectorReference + ""String_Node_Str"");
    }
 else {
      jv.add(""String_Node_Str"",""String_Node_Str"" + connectorReference + ""String_Node_Str"");
    }
  }
 else   if (connectorReference.getConnectorLocation().equals(ConnectorReference.ConnectorLocation.LOCAL)) {
    jv.add(""String_Node_Str"",""String_Node_Str"" + connectorReference + ""String_Node_Str"");
  }
 else {
    jv.add(""String_Node_Str"",""String_Node_Str"" + connectorReference + ""String_Node_Str"");
  }
  return result;
}","public Map<String,Object> testConfig(JsonValue config){
  Map<String,Object> result=new LinkedHashMap<String,Object>();
  JsonValue jv=new JsonValue(result);
  jv.add(""String_Node_Str"",systemIdentifier.getName());
  jv.add(""String_Node_Str"",false);
  SimpleSystemIdentifier testIdentifier=null;
  ConnectorReference connectorReference=null;
  try {
    testIdentifier=new SimpleSystemIdentifier(config);
    connectorReference=ConnectorUtil.getConnectorReference(jsonConfiguration);
  }
 catch (  JsonValueException e) {
    jv.add(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
    return result;
  }
  ConnectorInfo connectorInfo=connectorInfoProvider.findConnectorInfo(connectorReference);
  if (null != connectorInfo) {
    ConnectorFacade facade=null;
    try {
      OperationHelperBuilder ohb=new OperationHelperBuilder(testIdentifier.getName(),config,connectorInfo.createDefaultAPIConfiguration());
      ConnectorFacadeFactory connectorFacadeFactory=ConnectorFacadeFactory.getInstance();
      facade=connectorFacadeFactory.newInstance(ohb.getRuntimeAPIConfiguration());
    }
 catch (    Exception e) {
      jv.add(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
      return result;
    }
    if (null != facade && facade.getSupportedOperations().contains(TestApiOp.class)) {
      try {
        facade.test();
      }
 catch (      UnsupportedOperationException e) {
        jv.put(""String_Node_Str"",""String_Node_Str"");
      }
catch (      Throwable e) {
        jv.put(""String_Node_Str"",e.getMessage());
        return result;
      }
      jv.put(""String_Node_Str"",true);
    }
 else     if (null == facade) {
      jv.add(""String_Node_Str"",""String_Node_Str"" + connectorReference + ""String_Node_Str"");
    }
 else {
      jv.add(""String_Node_Str"",""String_Node_Str"" + connectorReference + ""String_Node_Str"");
    }
  }
 else   if (connectorReference.getConnectorLocation().equals(ConnectorReference.ConnectorLocation.LOCAL)) {
    jv.add(""String_Node_Str"",""String_Node_Str"" + connectorReference + ""String_Node_Str"");
  }
 else {
    jv.add(""String_Node_Str"",""String_Node_Str"" + connectorReference + ""String_Node_Str"");
  }
  return result;
}"
13270,"public boolean evaluateOnResponse(final ServerContext context,final ScriptState state,final Resource resource) throws ResourceException {
  if (onFailure != null) {
    ScriptEntry scriptEntry=onFailure.getRight();
    if (!scriptEntry.isActive()) {
      throw new ServiceUnavailableException(""String_Node_Str"" + onFailure.getRight().getName());
    }
    Script script=scriptEntry.getScript(context);
    script.put(""String_Node_Str"",getRequestMap(state.request,context));
    script.put(""String_Node_Str"",context);
    script.put(""String_Node_Str"",resource);
    script.put(""String_Node_Str"",getLazyContext(context));
    try {
      state.state=script.eval();
    }
 catch (    Throwable t) {
      logger.debug(""String_Node_Str"",onFailure.getRight().getName(),onFailure.getLeft(),t);
      throw Utils.adapt(t);
    }
  }
  return true;
}","public boolean evaluateOnResponse(final ServerContext context,final ScriptState state,final Resource resource) throws ResourceException {
  if (onResponse != null) {
    ScriptEntry scriptEntry=onResponse.getRight();
    if (!scriptEntry.isActive()) {
      throw new ServiceUnavailableException(""String_Node_Str"" + onResponse.getRight().getName());
    }
    Script script=scriptEntry.getScript(context);
    script.put(""String_Node_Str"",getRequestMap(state.request,context));
    script.put(""String_Node_Str"",context);
    script.put(""String_Node_Str"",resource);
    script.put(""String_Node_Str"",getLazyContext(context));
    try {
      state.state=script.eval();
    }
 catch (    Throwable t) {
      logger.debug(""String_Node_Str"",onResponse.getRight().getName(),onResponse.getLeft(),t);
      throw Utils.adapt(t);
    }
  }
  return true;
}"
13271,"public List<Resource> query(QueryRequest request) throws ResourceException {
  List<Resource> results=new ArrayList<Resource>();
  logger.trace(""String_Node_Str"",request.getResourceName(),request.getResourceName());
  Map<String,Object> result=new HashMap<String,Object>();
  ODatabaseDocumentTx db=getConnection();
  try {
    long start=System.currentTimeMillis();
    List<ODocument> queryResult=queries.query(request.getResourceName(),request,db);
    long end=System.currentTimeMillis();
    if (queryResult != null) {
      long convStart=System.currentTimeMillis();
      for (      ODocument entry : queryResult) {
        Map<String,Object> convertedEntry=DocumentUtil.toMap(entry);
        results.add(new Resource((String)convertedEntry.get(DocumentUtil.TAG_ID),(String)convertedEntry.get(DocumentUtil.TAG_REV),new JsonValue(convertedEntry)));
      }
      long convEnd=System.currentTimeMillis();
      result.put(QueryConstants.STATISTICS_CONVERSION_TIME,Long.valueOf(convEnd - convStart));
    }
    result.put(QueryConstants.STATISTICS_QUERY_TIME,Long.valueOf(end - start));
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",new Object[]{((List)result.get(QueryConstants.QUERY_RESULT)).size(),result.get(QueryConstants.STATISTICS_QUERY_TIME),result.get(QueryConstants.STATISTICS_CONVERSION_TIME)});
    }
    return results;
  }
  finally {
    if (db != null) {
      db.close();
    }
  }
}","public List<Resource> query(QueryRequest request) throws ResourceException {
  List<Resource> results=new ArrayList<Resource>();
  logger.trace(""String_Node_Str"",request.getResourceName(),request.getResourceName());
  Map<String,Object> result=new HashMap<String,Object>();
  ODatabaseDocumentTx db=getConnection();
  try {
    long start=System.currentTimeMillis();
    List<ODocument> queryResult=queries.query(request.getResourceName(),request,db);
    long end=System.currentTimeMillis();
    if (queryResult != null) {
      long convStart=System.currentTimeMillis();
      for (      ODocument entry : queryResult) {
        Map<String,Object> convertedEntry=DocumentUtil.toMap(entry);
        results.add(new Resource((String)convertedEntry.get(DocumentUtil.TAG_ID),(String)convertedEntry.get(DocumentUtil.TAG_REV),new JsonValue(convertedEntry)));
      }
      long convEnd=System.currentTimeMillis();
      result.put(QueryConstants.STATISTICS_CONVERSION_TIME,Long.valueOf(convEnd - convStart));
    }
    result.put(QueryConstants.STATISTICS_QUERY_TIME,Long.valueOf(end - start));
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",new Object[]{results.size(),result.get(QueryConstants.STATISTICS_QUERY_TIME),result.get(QueryConstants.STATISTICS_CONVERSION_TIME)});
    }
    return results;
  }
  finally {
    if (db != null) {
      db.close();
    }
  }
}"
13272,"private JsonValue getRequestMap(String resourceName,String method){
  JsonValue req=new JsonValue(new HashMap<String,Object>());
  req.add(""String_Node_Str"",resourceName.substring(1));
  req.add(""String_Node_Str"",method);
  return req;
}","private JsonValue getRequestMap(String resourceName,String method){
  JsonValue req=new JsonValue(new HashMap<String,Object>());
  req.add(""String_Node_Str"",resourceName);
  req.add(""String_Node_Str"",method);
  return req;
}"
13273,"/** 
 * Validates the request by authenticating against either the client certificate in the request, internally or Basic Authentication from the request header internally.
 * @param messageInfo {@inheritDoc}
 * @param clientSubject {@inheritDoc}
 * @param serviceSubject {@inheritDoc}
 * @param securityContextMapper {@inheritDoc}
 * @return {@inheritDoc}
 */
@Override protected AuthStatus validateRequest(MessageInfo messageInfo,Subject clientSubject,Subject serviceSubject,SecurityContextMapper securityContextMapper){
  HttpServletRequest req=(HttpServletRequest)messageInfo.getRequestMessage();
  boolean authenticated;
  final String headerLogin=req.getHeader(HEADER_USERNAME);
  String basicAuth=req.getHeader(""String_Node_Str"");
  if (allowClientCertOnly(req)) {
    authenticated=authenticateUsingClientCert(req,securityContextMapper);
  }
 else   if (headerLogin != null) {
    authenticated=authenticateUser(req,securityContextMapper);
  }
 else   if (basicAuth != null) {
    authenticated=authenticateUsingBasicAuth(basicAuth,securityContextMapper);
  }
 else {
    return AuthStatus.SEND_FAILURE;
  }
  securityContextMapper.setResource(queryOnResource);
  if (authenticated) {
    clientSubject.getPrincipals().add(new Principal(){
      public String getName(){
        return headerLogin;
      }
    }
);
  }
  return authenticated ? AuthStatus.SUCCESS : AuthStatus.SEND_FAILURE;
}","/** 
 * Validates the request by authenticating against either the client certificate in the request, internally or Basic Authentication from the request header internally.
 * @param messageInfo {@inheritDoc}
 * @param clientSubject {@inheritDoc}
 * @param serviceSubject {@inheritDoc}
 * @param securityContextMapper {@inheritDoc}
 * @return {@inheritDoc}
 */
@Override protected AuthStatus validateRequest(MessageInfo messageInfo,Subject clientSubject,Subject serviceSubject,SecurityContextMapper securityContextMapper){
  HttpServletRequest req=(HttpServletRequest)messageInfo.getRequestMessage();
  boolean authenticated;
  final String headerLogin=req.getHeader(HEADER_USERNAME);
  String basicAuth=req.getHeader(""String_Node_Str"");
  if (allowClientCertOnly(req)) {
    authenticated=authenticateUsingClientCert(req,securityContextMapper);
  }
 else   if (headerLogin != null) {
    authenticated=authenticateUser(req,securityContextMapper);
  }
 else   if (basicAuth != null) {
    authenticated=authenticateUsingBasicAuth(basicAuth,securityContextMapper);
  }
 else {
    return AuthStatus.SEND_FAILURE;
  }
  securityContextMapper.setResource(queryOnResource);
  final String authcid=securityContextMapper.getAuthcid();
  if (authenticated) {
    clientSubject.getPrincipals().add(new Principal(){
      public String getName(){
        return authcid;
      }
    }
);
  }
  return authenticated ? AuthStatus.SUCCESS : AuthStatus.SEND_FAILURE;
}"
13274,"public String getName(){
  return headerLogin;
}","public String getName(){
  return authcid;
}"
13275,"/** 
 * Copies the authentication principal header, set by the authentication filter, into the request as an attribute with the key SecurityContextFactory.ATTRIBUTE_AUTHCID and copies the authentication context attribute, set by the authentication filter, into the request as an attributes with the key SecurityContextFactory.ATTRIBUTES_AUTHZID.
 * @param servletRequest {@inheritDoc}
 * @param servletResponse {@inheritDoc}
 * @throws IOException {@inheritDoc}
 * @throws ServletException {@inheritDoc}
 */
@Override public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)servletRequest;
  Map<String,Object> authzid=(Map<String,Object>)request.getAttribute(AuthNFilter.ATTRIBUTE_AUTH_CONTEXT);
  String authcid=null;
  if (authzid != null) {
    authcid=(String)authzid.get(""String_Node_Str"");
  }
  request.setAttribute(SecurityContextFactory.ATTRIBUTE_AUTHCID,authcid);
  request.setAttribute(SecurityContextFactory.ATTRIBUTE_AUTHZID,authzid);
  filterChain.doFilter(request,servletResponse);
}","/** 
 * Copies the authentication principal header, set by the authentication filter, into the request as an attribute with the key SecurityContextFactory.ATTRIBUTE_AUTHCID and copies the authentication context attribute, set by the authentication filter, into the request as an attributes with the key SecurityContextFactory.ATTRIBUTES_AUTHZID.
 * @param servletRequest {@inheritDoc}
 * @param servletResponse {@inheritDoc}
 * @throws IOException {@inheritDoc}
 * @throws ServletException {@inheritDoc}
 */
@Override public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)servletRequest;
  Map<String,Object> authzid=(Map<String,Object>)request.getAttribute(AuthNFilter.ATTRIBUTE_AUTH_CONTEXT);
  String authcid=request.getHeader(AuthNFilter.ATTRIBUTE_AUTH_PRINCIPAL);
  request.setAttribute(SecurityContextFactory.ATTRIBUTE_AUTHCID,authcid);
  request.setAttribute(SecurityContextFactory.ATTRIBUTE_AUTHZID,authzid);
  filterChain.doFilter(request,servletResponse);
}"
13276,"private Map<String,Object> getRequestMap(Request request,ServerContext context){
  Map<String,Object> requestMap=new HashMap<String,Object>();
  JsonValue value=new JsonValue(null);
  String id=request.getResourceName();
  if (request instanceof ActionRequest) {
    value=((ActionRequest)request).getContent();
    requestMap.put(""String_Node_Str"",((ActionRequest)request).getAdditionalActionParameters());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    requestMap.put(""String_Node_Str"",((ActionRequest)request).getAction());
  }
 else   if (request instanceof CreateRequest) {
    CreateRequest createRequest=(CreateRequest)request;
    value=createRequest.getContent();
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    id=createRequest.getResourceName() + ""String_Node_Str"" + createRequest.getNewResourceId();
  }
 else   if (request instanceof ReadRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof UpdateRequest) {
    value=((UpdateRequest)request).getNewContent();
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof DeleteRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof PatchRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof QueryRequest) {
    requestMap.put(""String_Node_Str"",((QueryRequest)request).getAdditionalQueryParameters());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    requestMap.put(""String_Node_Str"",null);
  }
  if (context.containsContext(SecurityContext.class)) {
    requestMap.put(""String_Node_Str"",context.asContext(SecurityContext.class).getAuthorizationId());
  }
  if (isFromHttp(context)) {
    HttpContext httpContext=context.asContext(HttpContext.class);
    requestMap.put(""String_Node_Str"",httpContext.getHeaders());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    requestMap.put(""String_Node_Str"",httpContext.getParameters());
  }
 else {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  requestMap.put(""String_Node_Str"",request.getRequestType());
  requestMap.put(""String_Node_Str"",value.getObject());
  requestMap.put(""String_Node_Str"",id);
  return requestMap;
}","private Map<String,Object> getRequestMap(Request request,ServerContext context){
  Map<String,Object> requestMap=new HashMap<String,Object>();
  JsonValue value=new JsonValue(null);
  String id=request.getResourceName();
  if (request instanceof ActionRequest) {
    value=((ActionRequest)request).getContent();
    requestMap.put(""String_Node_Str"",((ActionRequest)request).getAdditionalActionParameters());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    requestMap.put(""String_Node_Str"",((ActionRequest)request).getAction());
  }
 else   if (request instanceof CreateRequest) {
    CreateRequest createRequest=(CreateRequest)request;
    value=createRequest.getContent();
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    id=createRequest.getResourceName() + ""String_Node_Str"" + createRequest.getNewResourceId();
  }
 else   if (request instanceof ReadRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof UpdateRequest) {
    value=((UpdateRequest)request).getNewContent();
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof DeleteRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof PatchRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof QueryRequest) {
    requestMap.put(""String_Node_Str"",((QueryRequest)request).getAdditionalQueryParameters());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    requestMap.put(""String_Node_Str"",null);
  }
  if (context.containsContext(SecurityContext.class)) {
    SecurityContext securityContext=context.asContext(SecurityContext.class);
    Map<String,Object> security=new HashMap<String,Object>();
    security.putAll(securityContext.getAuthorizationId());
    security.put(""String_Node_Str"",securityContext.getAuthenticationId());
    requestMap.put(""String_Node_Str"",security);
  }
  if (isFromHttp(context)) {
    HttpContext httpContext=context.asContext(HttpContext.class);
    requestMap.put(""String_Node_Str"",httpContext.getHeaders());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    requestMap.put(""String_Node_Str"",httpContext.getParameters());
  }
 else {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  requestMap.put(""String_Node_Str"",request.getRequestType());
  requestMap.put(""String_Node_Str"",value.getObject());
  requestMap.put(""String_Node_Str"",id);
  return requestMap;
}"
13277,"public CryptoService access(){
  return null;
}","public CryptoService access(){
  return cryptoService;
}"
13278,"@Override public Resource update(UpdateRequest request) throws ResourceException {
  String fullId=request.getResourceName();
  String[] resourceName=ResourceUtil.parseResourceName(fullId);
  if (resourceName == null) {
    throw new BadRequestException(""String_Node_Str"");
  }
  String localId=getLocalId(fullId);
  String type=getObjectType(fullId);
  Map<String,Object> obj=request.getNewContent().asMap();
  String rev=request.getRevision();
  Connection connection=null;
  Integer previousIsolationLevel=null;
  boolean retry=false;
  int tryCount=0;
  do {
    TableHandler handler=getTableHandler(type);
    if (handler == null) {
      throw ResourceException.getException(ResourceException.INTERNAL_ERROR,""String_Node_Str"" + type);
    }
    retry=false;
    ++tryCount;
    try {
      connection=getConnection();
      previousIsolationLevel=new Integer(connection.getTransactionIsolation());
      connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
      connection.setAutoCommit(false);
      handler.update(fullId,type,localId,rev,obj,connection);
      connection.commit();
      logger.debug(""String_Node_Str"",fullId);
    }
 catch (    SQLException ex) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",new Object[]{fullId,ex.getErrorCode(),ex.getSQLState(),ex});
      }
      rollback(connection);
      if (handler.isRetryable(ex,connection)) {
        if (tryCount <= maxTxRetry) {
          retry=true;
          logger.debug(""String_Node_Str"",ex.getMessage());
        }
      }
      if (!retry) {
        throw new InternalServerErrorException(""String_Node_Str"" + ex.getMessage(),ex);
      }
    }
catch (    ResourceException ex) {
      logger.debug(""String_Node_Str"",fullId,ex);
      rollback(connection);
      throw ex;
    }
catch (    java.io.IOException ex) {
      logger.debug(""String_Node_Str"",fullId,ex);
      rollback(connection);
      throw new InternalServerErrorException(""String_Node_Str"",ex);
    }
catch (    RuntimeException ex) {
      logger.debug(""String_Node_Str"",fullId,ex);
      rollback(connection);
      throw new InternalServerErrorException(""String_Node_Str"" + ex.getMessage(),ex);
    }
 finally {
      if (connection != null) {
        try {
          if (previousIsolationLevel != null) {
            connection.setTransactionIsolation(previousIsolationLevel.intValue());
          }
        }
 catch (        SQLException ex) {
          logger.warn(""String_Node_Str"",ex);
        }
        CleanupHelper.loggedClose(connection);
      }
    }
  }
 while (retry);
  return read(Requests.newReadRequest(fullId));
}","@Override public Resource update(UpdateRequest request) throws ResourceException {
  String fullId=request.getResourceName();
  String[] resourceName=ResourceUtil.parseResourceName(fullId);
  if (resourceName == null) {
    throw new BadRequestException(""String_Node_Str"");
  }
  String localId=getLocalId(fullId);
  String type=getObjectType(fullId);
  Map<String,Object> obj=request.getNewContent().asMap();
  String rev=request.getRevision();
  if (rev == null) {
    rev=read(Requests.newReadRequest(fullId)).getRevision();
  }
  Connection connection=null;
  Integer previousIsolationLevel=null;
  boolean retry=false;
  int tryCount=0;
  do {
    TableHandler handler=getTableHandler(type);
    if (handler == null) {
      throw ResourceException.getException(ResourceException.INTERNAL_ERROR,""String_Node_Str"" + type);
    }
    retry=false;
    ++tryCount;
    try {
      connection=getConnection();
      previousIsolationLevel=new Integer(connection.getTransactionIsolation());
      connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
      connection.setAutoCommit(false);
      handler.update(fullId,type,localId,rev,obj,connection);
      connection.commit();
      logger.debug(""String_Node_Str"",fullId);
    }
 catch (    SQLException ex) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",new Object[]{fullId,ex.getErrorCode(),ex.getSQLState(),ex});
      }
      rollback(connection);
      if (handler.isRetryable(ex,connection)) {
        if (tryCount <= maxTxRetry) {
          retry=true;
          logger.debug(""String_Node_Str"",ex.getMessage());
        }
      }
      if (!retry) {
        throw new InternalServerErrorException(""String_Node_Str"" + ex.getMessage(),ex);
      }
    }
catch (    ResourceException ex) {
      logger.debug(""String_Node_Str"",fullId,ex);
      rollback(connection);
      throw ex;
    }
catch (    java.io.IOException ex) {
      logger.debug(""String_Node_Str"",fullId,ex);
      rollback(connection);
      throw new InternalServerErrorException(""String_Node_Str"",ex);
    }
catch (    RuntimeException ex) {
      logger.debug(""String_Node_Str"",fullId,ex);
      rollback(connection);
      throw new InternalServerErrorException(""String_Node_Str"" + ex.getMessage(),ex);
    }
 finally {
      if (connection != null) {
        try {
          if (previousIsolationLevel != null) {
            connection.setTransactionIsolation(previousIsolationLevel.intValue());
          }
        }
 catch (        SQLException ex) {
          logger.warn(""String_Node_Str"",ex);
        }
        CleanupHelper.loggedClose(connection);
      }
    }
  }
 while (retry);
  return read(Requests.newReadRequest(fullId));
}"
13279,"@Override public List<Resource> query(QueryRequest request) throws ResourceException {
  String fullId=request.getResourceName();
  String type=fullId;
  logger.trace(""String_Node_Str"",fullId,type);
  Map<String,Object> params=new HashMap<String,Object>();
  params.putAll(request.getAdditionalQueryParameters());
  params.put(TableQueries.QUERY_ID,request.getQueryId());
  params.put(TableQueries.QUERY_EXPRESSION,request.getQueryExpression());
  Connection connection=null;
  try {
    TableHandler tableHandler=getTableHandler(type);
    if (tableHandler == null) {
      throw ResourceException.getException(ResourceException.INTERNAL_ERROR,""String_Node_Str"" + type);
    }
    connection=getConnection();
    connection.setAutoCommit(true);
    List<Map<String,Object>> docs=tableHandler.query(type,params,connection);
    List<Resource> results=new ArrayList<Resource>();
    for (    Map<String,Object> resultMap : docs) {
      String id=(String)resultMap.get(""String_Node_Str"");
      String rev=(String)resultMap.get(""String_Node_Str"");
      JsonValue value=new JsonValue(resultMap);
      Resource resultResource=new Resource(id,rev,value);
      results.add(resultResource);
    }
    return results;
  }
 catch (  SQLException ex) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",new Object[]{fullId,ex.getErrorCode(),ex.getSQLState(),ex});
    }
    throw new InternalServerErrorException(""String_Node_Str"" + ex.getMessage(),ex);
  }
catch (  ResourceException ex) {
    logger.debug(""String_Node_Str"",fullId,ex);
    throw ex;
  }
 finally {
    CleanupHelper.loggedClose(connection);
  }
}","@Override public List<Resource> query(QueryRequest request) throws ResourceException {
  String fullId=request.getResourceName();
  String type=trimStartingSlash(fullId);
  logger.trace(""String_Node_Str"",fullId,type);
  Map<String,Object> params=new HashMap<String,Object>();
  params.putAll(request.getAdditionalQueryParameters());
  params.put(TableQueries.QUERY_ID,request.getQueryId());
  params.put(TableQueries.QUERY_EXPRESSION,request.getQueryExpression());
  Connection connection=null;
  try {
    TableHandler tableHandler=getTableHandler(type);
    if (tableHandler == null) {
      throw ResourceException.getException(ResourceException.INTERNAL_ERROR,""String_Node_Str"" + type);
    }
    connection=getConnection();
    connection.setAutoCommit(true);
    List<Map<String,Object>> docs=tableHandler.query(type,params,connection);
    List<Resource> results=new ArrayList<Resource>();
    for (    Map<String,Object> resultMap : docs) {
      String id=(String)resultMap.get(""String_Node_Str"");
      String rev=(String)resultMap.get(""String_Node_Str"");
      JsonValue value=new JsonValue(resultMap);
      Resource resultResource=new Resource(id,rev,value);
      results.add(resultResource);
    }
    return results;
  }
 catch (  SQLException ex) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",new Object[]{fullId,ex.getErrorCode(),ex.getSQLState(),ex});
    }
    throw new InternalServerErrorException(""String_Node_Str"" + ex.getMessage(),ex);
  }
catch (  ResourceException ex) {
    logger.debug(""String_Node_Str"",fullId,ex);
    throw ex;
  }
 finally {
    CleanupHelper.loggedClose(connection);
  }
}"
13280,"MappedTableHandler getMappedTableHandler(DatabaseType databaseType,JsonValue tableConfig,String table,Map objectToColumn,String dbSchemaName,JsonValue explicitQueries,int maxBatchSize) throws InternalServerErrorException {
  final Accessor<CryptoService> cryptoServiceAccessor=new Accessor<CryptoService>(){
    public CryptoService access(){
      return null;
    }
  }
;
  MappedTableHandler handler=null;
switch (databaseType) {
case DB2:
    handler=new MappedTableHandler(table,objectToColumn,dbSchemaName,explicitQueries,new DB2SQLExceptionHandler(),cryptoServiceAccessor);
  break;
case ORACLE:
handler=new MappedTableHandler(table,objectToColumn,dbSchemaName,explicitQueries,new DefaultSQLExceptionHandler(),cryptoServiceAccessor);
break;
case POSTGRESQL:
handler=new MappedTableHandler(table,objectToColumn,dbSchemaName,explicitQueries,new DefaultSQLExceptionHandler(),cryptoServiceAccessor);
break;
case MYSQL:
handler=new MappedTableHandler(table,objectToColumn,dbSchemaName,explicitQueries,new MySQLExceptionHandler(),cryptoServiceAccessor);
break;
case SQLSERVER:
handler=new MSSQLMappedTableHandler(table,objectToColumn,dbSchemaName,explicitQueries,new DefaultSQLExceptionHandler(),cryptoServiceAccessor);
break;
default :
handler=new MappedTableHandler(table,objectToColumn,dbSchemaName,explicitQueries,new DefaultSQLExceptionHandler(),cryptoServiceAccessor);
}
return handler;
}","MappedTableHandler getMappedTableHandler(DatabaseType databaseType,JsonValue tableConfig,String table,Map objectToColumn,String dbSchemaName,JsonValue explicitQueries,int maxBatchSize) throws InternalServerErrorException {
  final Accessor<CryptoService> cryptoServiceAccessor=new Accessor<CryptoService>(){
    public CryptoService access(){
      return cryptoService;
    }
  }
;
  MappedTableHandler handler=null;
switch (databaseType) {
case DB2:
    handler=new MappedTableHandler(table,objectToColumn,dbSchemaName,explicitQueries,new DB2SQLExceptionHandler(),cryptoServiceAccessor);
  break;
case ORACLE:
handler=new MappedTableHandler(table,objectToColumn,dbSchemaName,explicitQueries,new DefaultSQLExceptionHandler(),cryptoServiceAccessor);
break;
case POSTGRESQL:
handler=new MappedTableHandler(table,objectToColumn,dbSchemaName,explicitQueries,new DefaultSQLExceptionHandler(),cryptoServiceAccessor);
break;
case MYSQL:
handler=new MappedTableHandler(table,objectToColumn,dbSchemaName,explicitQueries,new MySQLExceptionHandler(),cryptoServiceAccessor);
break;
case SQLSERVER:
handler=new MSSQLMappedTableHandler(table,objectToColumn,dbSchemaName,explicitQueries,new DefaultSQLExceptionHandler(),cryptoServiceAccessor);
break;
default :
handler=new MappedTableHandler(table,objectToColumn,dbSchemaName,explicitQueries,new DefaultSQLExceptionHandler(),cryptoServiceAccessor);
}
return handler;
}"
13281,"private Map<String,Object> getRequestMap(Request request,ServerContext context){
  Map<String,Object> requestMap=new HashMap<String,Object>();
  JsonValue value=new JsonValue(null);
  String id=request.getResourceName();
  if (request instanceof ActionRequest) {
    value=((ActionRequest)request).getContent();
    requestMap.put(""String_Node_Str"",((ActionRequest)request).getAdditionalActionParameters());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    requestMap.put(""String_Node_Str"",((ActionRequest)request).getAction());
  }
 else   if (request instanceof CreateRequest) {
    CreateRequest createRequest=(CreateRequest)request;
    value=createRequest.getContent();
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    id=createRequest.getResourceName() + ""String_Node_Str"" + createRequest.getNewResourceId();
  }
 else   if (request instanceof ReadRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof UpdateRequest) {
    value=((UpdateRequest)request).getNewContent();
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof DeleteRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof PatchRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof QueryRequest) {
    requestMap.put(""String_Node_Str"",((QueryRequest)request).getAdditionalQueryParameters());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    requestMap.put(""String_Node_Str"",null);
  }
  if (context.containsContext(SecurityContext.class)) {
    requestMap.put(""String_Node_Str"",context.asContext(SecurityContext.class).getAuthorizationId());
  }
  if (context.containsContext(HttpContext.class)) {
    HttpContext httpContext=context.asContext(HttpContext.class);
    requestMap.put(""String_Node_Str"",httpContext.getHeaders());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    requestMap.put(""String_Node_Str"",httpContext.getParameters());
  }
 else {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  requestMap.put(""String_Node_Str"",request.getRequestType());
  requestMap.put(""String_Node_Str"",value.getObject());
  requestMap.put(""String_Node_Str"",id);
  return requestMap;
}","private Map<String,Object> getRequestMap(Request request,ServerContext context){
  Map<String,Object> requestMap=new HashMap<String,Object>();
  JsonValue value=new JsonValue(null);
  String id=request.getResourceName();
  if (request instanceof ActionRequest) {
    value=((ActionRequest)request).getContent();
    requestMap.put(""String_Node_Str"",((ActionRequest)request).getAdditionalActionParameters());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    requestMap.put(""String_Node_Str"",((ActionRequest)request).getAction());
  }
 else   if (request instanceof CreateRequest) {
    CreateRequest createRequest=(CreateRequest)request;
    value=createRequest.getContent();
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    id=createRequest.getResourceName() + ""String_Node_Str"" + createRequest.getNewResourceId();
  }
 else   if (request instanceof ReadRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof UpdateRequest) {
    value=((UpdateRequest)request).getNewContent();
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof DeleteRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof PatchRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof QueryRequest) {
    requestMap.put(""String_Node_Str"",((QueryRequest)request).getAdditionalQueryParameters());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    requestMap.put(""String_Node_Str"",null);
  }
  if (context.containsContext(SecurityContext.class)) {
    requestMap.put(""String_Node_Str"",context.asContext(SecurityContext.class).getAuthorizationId());
  }
  if (isFromHttp(context)) {
    HttpContext httpContext=context.asContext(HttpContext.class);
    requestMap.put(""String_Node_Str"",httpContext.getHeaders());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    requestMap.put(""String_Node_Str"",httpContext.getParameters());
  }
 else {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  requestMap.put(""String_Node_Str"",request.getRequestType());
  requestMap.put(""String_Node_Str"",value.getObject());
  requestMap.put(""String_Node_Str"",id);
  return requestMap;
}"
13282,"/** 
 * Constructs a new managed object set.
 * @param scriptRegistry
 * @param cryptoService
 * @param config configuration object to use to initialize managed object set.
 * @throws JsonValueException when the configuration is malformed
 * @throws ScriptException when the script configuration is malformed or the script is invalid.
 */
public ManagedObjectSet(final ScriptRegistry scriptRegistry,final CryptoService cryptoService,final AtomicReference<RouteService> syncRefrence,JsonValue config) throws JsonValueException, ScriptException {
  this.service=cryptoService;
  this.syncRoute=syncRefrence;
  name=config.get(""String_Node_Str"").required().asString();
  if (name.trim().isEmpty() || name.indexOf('{') > 0 | name.indexOf('}') > 0) {
    throw new JsonValueException(config.get(""String_Node_Str""),""String_Node_Str"");
  }
  schema=config.get(""String_Node_Str"").expect(Map.class);
  if (config.isDefined(""String_Node_Str"")) {
    onCreate=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onCreate=null;
  }
  if (config.isDefined(""String_Node_Str"")) {
    onRead=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onRead=null;
  }
  if (config.isDefined(""String_Node_Str"")) {
    onUpdate=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onUpdate=null;
  }
  if (config.isDefined(""String_Node_Str"")) {
    onDelete=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onDelete=null;
  }
  if (config.isDefined(""String_Node_Str"")) {
    onValidate=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onValidate=null;
  }
  if (config.isDefined(""String_Node_Str"")) {
    onRetrieve=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onRetrieve=null;
  }
  if (config.isDefined(""String_Node_Str"")) {
    onStore=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onStore=null;
  }
  for (  JsonValue property : config.get(""String_Node_Str"").expect(List.class)) {
    properties.add(new ManagedObjectProperty(scriptRegistry,cryptoService,property));
  }
  enforcePolicies=Boolean.parseBoolean(IdentityServer.getInstance().getProperty(""String_Node_Str"",""String_Node_Str""));
  logger.debug(""String_Node_Str"",name);
}","/** 
 * Constructs a new managed object set.
 * @param scriptRegistry
 * @param cryptoService the cryptographic service
 * @param syncRoute
 * @param config configuration object to use to initialize managed object set.
 * @throws JsonValueException when the configuration is malformed
 * @throws ScriptException when the script configuration is malformed or the script is invalid.
 */
public ManagedObjectSet(final ScriptRegistry scriptRegistry,final CryptoService cryptoService,final AtomicReference<RouteService> syncRoute,JsonValue config) throws JsonValueException, ScriptException {
  this.cryptoService=cryptoService;
  this.syncRoute=syncRoute;
  name=config.get(""String_Node_Str"").required().asString();
  if (name.trim().isEmpty() || name.indexOf('{') > 0 | name.indexOf('}') > 0) {
    throw new JsonValueException(config.get(""String_Node_Str""),""String_Node_Str"");
  }
  schema=config.get(""String_Node_Str"").expect(Map.class);
  if (config.isDefined(""String_Node_Str"")) {
    onCreate=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onCreate=null;
  }
  if (config.isDefined(""String_Node_Str"")) {
    onRead=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onRead=null;
  }
  if (config.isDefined(""String_Node_Str"")) {
    onUpdate=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onUpdate=null;
  }
  if (config.isDefined(""String_Node_Str"")) {
    onDelete=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onDelete=null;
  }
  if (config.isDefined(""String_Node_Str"")) {
    onValidate=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onValidate=null;
  }
  if (config.isDefined(""String_Node_Str"")) {
    onRetrieve=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onRetrieve=null;
  }
  if (config.isDefined(""String_Node_Str"")) {
    onStore=scriptRegistry.takeScript(config.get(""String_Node_Str""));
  }
 else {
    onStore=null;
  }
  for (  JsonValue property : config.get(""String_Node_Str"").expect(List.class)) {
    properties.add(new ManagedObjectProperty(scriptRegistry,cryptoService,property));
  }
  enforcePolicies=Boolean.parseBoolean(IdentityServer.getInstance().getProperty(""String_Node_Str"",""String_Node_Str""));
  logger.debug(""String_Node_Str"",name);
}"
13283,"/** 
 * Deallocate every resource use by this service.
 */
void dispose(){
  if (null != onCreate) {
    onCreate.deleteScriptListener(this);
  }
  if (null != onCreate) {
    onRead.deleteScriptListener(this);
  }
  if (null != onCreate) {
    onUpdate.deleteScriptListener(this);
  }
  if (null != onCreate) {
    onDelete.deleteScriptListener(this);
  }
  if (null != onCreate) {
    onValidate.deleteScriptListener(this);
  }
  if (null != onCreate) {
    onRetrieve.deleteScriptListener(this);
  }
  if (null != onCreate) {
    onStore.deleteScriptListener(this);
  }
}","/** 
 * Deallocate every resource use by this service.
 */
void dispose(){
  if (null != onCreate) {
    onCreate.deleteScriptListener(this);
  }
  if (null != onRead) {
    onRead.deleteScriptListener(this);
  }
  if (null != onUpdate) {
    onUpdate.deleteScriptListener(this);
  }
  if (null != onDelete) {
    onDelete.deleteScriptListener(this);
  }
  if (null != onValidate) {
    onValidate.deleteScriptListener(this);
  }
  if (null != onRetrieve) {
    onRetrieve.deleteScriptListener(this);
  }
  if (null != onStore) {
    onStore.deleteScriptListener(this);
  }
}"
13284,"/** 
 * Decrypt the value
 * @param value an json value with poentially encrypted value(s)
 * @return object with values decrypted
 * @throws InternalServerErrorException if decryption failed for any reason
 */
private Resource decrypt(final Resource value) throws InternalServerErrorException {
  try {
    return new Resource(value.getId(),value.getRevision(),null != value.getContent() ? service.decrypt(value.getContent()) : null);
  }
 catch (  JsonException je) {
    throw new InternalServerErrorException(je);
  }
}","/** 
 * Decrypt the value
 * @param value a json value with potentially encrypted value(s)
 * @return object with values decrypted
 * @throws InternalServerErrorException if decryption failed for any reason
 */
private Resource decrypt(final Resource value) throws InternalServerErrorException {
  try {
    return new Resource(value.getId(),value.getRevision(),null != value.getContent() ? cryptoService.decrypt(value.getContent()) : null);
  }
 catch (  JsonException je) {
    throw new InternalServerErrorException(je);
  }
}"
13285,"@Override public void createInstance(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  logger.debug(""String_Node_Str"",name,request.getNewResourceId());
  try {
    JsonValue jv=decrypt(request.getContent());
    execScript(context,""String_Node_Str"",onCreate,jv);
    onStore(context,jv);
    CreateRequest createRequest=Requests.copyOfCreateRequest(request);
    createRequest.setResourceName(repoId(null));
    Resource _new=context.getConnection().create(context,createRequest);
    logActivity(context,managedId(_new.getId()),null,null,jv);
    onCreate(context,managedId(_new.getId()),_new);
    handler.handleResult(_new);
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e));
  }
}","@Override public void createInstance(ServerContext context,CreateRequest request,ResultHandler<Resource> handler){
  logger.debug(""String_Node_Str"",name,request.getNewResourceId());
  try {
    JsonValue value=decrypt(request.getContent());
    execScript(context,""String_Node_Str"",onCreate,value);
    onStore(context,value);
    CreateRequest createRequest=Requests.copyOfCreateRequest(request);
    createRequest.setContent(value);
    createRequest.setResourceName(repoId(null));
    Resource _new=context.getConnection().create(context,createRequest);
    logActivity(context,managedId(_new.getId()),null,null,value);
    onCreate(context,managedId(_new.getId()),_new);
    handler.handleResult(_new);
  }
 catch (  ResourceException e) {
    handler.handleError(e);
  }
catch (  Exception e) {
    handler.handleError(new InternalServerErrorException(e));
  }
}"
13286,"/** 
 * Create an instance of a mapping between source and target
 * @param service The associated sychronization service
 * @param config The configuration for this mapping
 * @throws JsonValueException if there is an issue initializing based on the configuration.
 */
public ObjectMapping(SynchronizationService service,JsonValue config) throws JsonValueException {
  this.service=service;
  this.config=config;
  name=config.get(""String_Node_Str"").required().asString();
  linkTypeName=config.get(""String_Node_Str"").defaultTo(name).asString();
  sourceObjectSet=config.get(""String_Node_Str"").required().asString();
  targetObjectSet=config.get(""String_Node_Str"").required().asString();
  sourceIdsCaseSensitive=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  targetIdsCaseSensitive=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  validSource=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  validTarget=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  JsonValue corrQuery=config.get(""String_Node_Str"");
  if (!corrQuery.isNull()) {
    correlationQuery=new RegisteredScript(getParameters(corrQuery),Scripts.newInstance(""String_Node_Str"",corrQuery));
  }
  for (  JsonValue jv : config.get(""String_Node_Str"").expect(List.class)) {
    properties.add(new PropertyMapping(service,jv));
  }
  for (  JsonValue jv : config.get(""String_Node_Str"").expect(List.class)) {
    policies.add(new Policy(service,jv));
  }
  onCreateScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onUpdateScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onDeleteScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onLinkScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onUnlinkScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  resultScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  prefetchLinks=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  Integer confTaskThreads=config.get(""String_Node_Str"").asInteger();
  if (confTaskThreads != null) {
    taskThreads=confTaskThreads.intValue();
  }
  correlateEmptyTargetSet=config.get(""String_Node_Str"").defaultTo(Boolean.FALSE).asBoolean();
  syncEnabled=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  linkingEnabled=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  LOGGER.debug(""String_Node_Str"",name);
}","/** 
 * Create an instance of a mapping between source and target
 * @param service The associated sychronization service
 * @param config The configuration for this mapping
 * @throws JsonValueException if there is an issue initializing based on the configuration.
 */
public ObjectMapping(SynchronizationService service,JsonValue config) throws JsonValueException {
  this.service=service;
  this.config=config;
  name=config.get(""String_Node_Str"").required().asString();
  linkTypeName=config.get(""String_Node_Str"").defaultTo(name).asString();
  sourceObjectSet=config.get(""String_Node_Str"").required().asString();
  targetObjectSet=config.get(""String_Node_Str"").required().asString();
  sourceIdsCaseSensitive=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  targetIdsCaseSensitive=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  validSource=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  validTarget=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  JsonValue corrQuery=config.get(""String_Node_Str"");
  if (!corrQuery.isNull()) {
    correlationQuery=new RegisteredScript(Scripts.newInstance(""String_Node_Str"",corrQuery),corrQuery);
  }
  for (  JsonValue jv : config.get(""String_Node_Str"").expect(List.class)) {
    properties.add(new PropertyMapping(service,jv));
  }
  for (  JsonValue jv : config.get(""String_Node_Str"").expect(List.class)) {
    policies.add(new Policy(service,jv));
  }
  onCreateScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onUpdateScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onDeleteScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onLinkScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  onUnlinkScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  resultScript=Scripts.newInstance(""String_Node_Str"",config.get(""String_Node_Str""));
  prefetchLinks=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  Integer confTaskThreads=config.get(""String_Node_Str"").asInteger();
  if (confTaskThreads != null) {
    taskThreads=confTaskThreads.intValue();
  }
  correlateEmptyTargetSet=config.get(""String_Node_Str"").defaultTo(Boolean.FALSE).asBoolean();
  syncEnabled=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  linkingEnabled=config.get(""String_Node_Str"").defaultTo(Boolean.TRUE).asBoolean();
  LOGGER.debug(""String_Node_Str"",name);
}"
13287,"/** 
 * Register a service implementation if this component is active If a service already exists at the resource context, this replaces it
 * @param scriptConfig the configuration for the script as a service to register the resource context
 */
protected void register(JsonValue scriptConfig,String configName){
  if (context != null) {
    String resourceContext=scriptConfig.get(CONFIG_RESOURCE_CONTEXT).asString();
    if (resourceContext != null) {
      Script script=Scripts.newInstance((String)context.getProperties().get(Constants.SERVICE_PID),scriptConfig);
      scripts.put(resourceContext,new RegisteredScript(getParameters(scriptConfig),script,scriptConfig));
      logger.info(""String_Node_Str"",resourceContext,scriptConfig.get(""String_Node_Str""));
    }
 else {
      logger.warn(""String_Node_Str"",configName,scriptConfig);
    }
  }
 else {
    logger.debug(""String_Node_Str"");
  }
}","/** 
 * Register a service implementation if this component is active If a service already exists at the resource context, this replaces it
 * @param scriptConfig the configuration for the script as a service to register the resource context
 */
protected void register(JsonValue scriptConfig,String configName){
  if (context != null) {
    String resourceContext=scriptConfig.get(CONFIG_RESOURCE_CONTEXT).asString();
    if (resourceContext != null) {
      Script script=Scripts.newInstance((String)context.getProperties().get(Constants.SERVICE_PID),scriptConfig);
      scripts.put(resourceContext,new RegisteredScript(script,scriptConfig));
      logger.info(""String_Node_Str"",resourceContext,scriptConfig.get(""String_Node_Str""));
    }
 else {
      logger.warn(""String_Node_Str"",configName,scriptConfig);
    }
  }
 else {
    logger.debug(""String_Node_Str"");
  }
}"
13288,"private Map<String,Object> getRequestMap(Request request,ServerContext context){
  Map<String,Object> requestMap=new HashMap<String,Object>();
  JsonValue value=new JsonValue(null);
  if (request instanceof ActionRequest) {
    value=((ActionRequest)request).getContent();
    requestMap.put(""String_Node_Str"",((ActionRequest)request).getAdditionalActionParameters());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    requestMap.put(""String_Node_Str"",((ActionRequest)request).getAction());
  }
 else   if (request instanceof CreateRequest) {
    value=((CreateRequest)request).getContent();
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof ReadRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof UpdateRequest) {
    value=((UpdateRequest)request).getNewContent();
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof DeleteRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof PatchRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof QueryRequest) {
    requestMap.put(""String_Node_Str"",((QueryRequest)request).getAdditionalQueryParameters());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    requestMap.put(""String_Node_Str"",null);
  }
  if (context.containsContext(SecurityContext.class)) {
    requestMap.put(""String_Node_Str"",context.asContext(SecurityContext.class).getAuthorizationId());
  }
  if (context.containsContext(HttpContext.class)) {
    HttpContext httpContext=context.asContext(HttpContext.class);
    requestMap.put(""String_Node_Str"",httpContext.getHeaders());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    requestMap.put(""String_Node_Str"",httpContext.getParameters());
  }
 else {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  requestMap.put(""String_Node_Str"",request.getRequestType());
  requestMap.put(""String_Node_Str"",value.getObject());
  requestMap.put(""String_Node_Str"",request.getResourceName());
  return requestMap;
}","private Map<String,Object> getRequestMap(Request request,ServerContext context){
  Map<String,Object> requestMap=new HashMap<String,Object>();
  JsonValue value=new JsonValue(null);
  String id=request.getResourceName();
  if (request instanceof ActionRequest) {
    value=((ActionRequest)request).getContent();
    requestMap.put(""String_Node_Str"",((ActionRequest)request).getAdditionalActionParameters());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    requestMap.put(""String_Node_Str"",((ActionRequest)request).getAction());
  }
 else   if (request instanceof CreateRequest) {
    CreateRequest createRequest=(CreateRequest)request;
    value=createRequest.getContent();
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    id=createRequest.getResourceName() + ""String_Node_Str"" + createRequest.getNewResourceId();
  }
 else   if (request instanceof ReadRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof UpdateRequest) {
    value=((UpdateRequest)request).getNewContent();
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof DeleteRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof PatchRequest) {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (request instanceof QueryRequest) {
    requestMap.put(""String_Node_Str"",((QueryRequest)request).getAdditionalQueryParameters());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    requestMap.put(""String_Node_Str"",null);
  }
  if (context.containsContext(SecurityContext.class)) {
    requestMap.put(""String_Node_Str"",context.asContext(SecurityContext.class).getAuthorizationId());
  }
  if (context.containsContext(HttpContext.class)) {
    HttpContext httpContext=context.asContext(HttpContext.class);
    requestMap.put(""String_Node_Str"",httpContext.getHeaders());
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
    requestMap.put(""String_Node_Str"",httpContext.getParameters());
  }
 else {
    requestMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  requestMap.put(""String_Node_Str"",request.getRequestType());
  requestMap.put(""String_Node_Str"",value.getObject());
  requestMap.put(""String_Node_Str"",id);
  return requestMap;
}"
13289,"protected int evaluateOnRequest(final ServerContext context,final ScriptState state) throws ResourceException {
  if (onRequest != null) {
    ScriptEntry scriptEntry=onRequest.getRight();
    if (!scriptEntry.isActive()) {
      throw new ServiceUnavailableException(""String_Node_Str"" + onRequest.getRight().getName());
    }
    Script script=scriptEntry.getScript(context);
    script.put(""String_Node_Str"",getRequestMap(state.request,context));
    script.put(""String_Node_Str"",context);
    script.put(""String_Node_Str"",getLazyContext(context));
    try {
      state.state=script.eval();
    }
 catch (    Throwable t) {
      logger.debug(""String_Node_Str"",onRequest.getRight().getName(),onRequest.getLeft(),t);
      throw Utils.adapt(t);
    }
  }
  return CONTINUE;
}","protected int evaluateOnRequest(final ServerContext context,final ScriptState state) throws ResourceException {
  if (onRequest != null) {
    ScriptEntry scriptEntry=onRequest.getRight();
    if (!scriptEntry.isActive()) {
      throw new ServiceUnavailableException(""String_Node_Str"" + onRequest.getRight().getName());
    }
    Script script=scriptEntry.getScript(context);
    script.put(""String_Node_Str"",getRequestMap(state.request,context));
    script.put(""String_Node_Str"",context);
    script.put(""String_Node_Str"",getLazyContext(context));
    try {
      state.state=script.eval();
    }
 catch (    Throwable t) {
      logger.debug(""String_Node_Str"",onRequest.getRight().getName(),onRequest.getLeft(),t);
      ResourceException re=Utils.adapt(t);
      logger.debug(""String_Node_Str"" + re.getDetail());
      throw re;
    }
  }
  return CONTINUE;
}"
13290,"/** 
 * Copies the authentication principal header, set by the authentication filter, into the request as an attribute with the key SecurityContextFactory.ATTRIBUTE_AUTHCID and copies the authentication context attribute, set by the authentication filter, into the request as an attributes with the key SecurityContextFactory.ATTRIBUTES_AUTHZID.
 * @param servletRequest {@inheritDoc}
 * @param servletResponse {@inheritDoc}
 * @param filterChain {@inheritDoc}
 * @throws IOException {@inheritDoc}
 * @throws ServletException {@inheritDoc}
 */
@Override public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse,FilterChain filterChain) throws IOException, ServletException {
  if ((!HttpServletRequest.class.isAssignableFrom(servletRequest.getClass()) || !HttpServletResponse.class.isAssignableFrom(servletResponse.getClass()))) {
    throw new ServletException(""String_Node_Str"");
  }
  HttpServletRequest request=(HttpServletRequest)servletRequest;
  String authcid=request.getHeader(AuthNFilter.ATTRIBUTE_AUTH_PRINCIPAL);
  Map<String,Object> authzid=(Map<String,Object>)request.getAttribute(AuthNFilter.ATTRIBUTE_AUTH_CONTEXT);
  request.setAttribute(SecurityContextFactory.ATTRIBUTE_AUTHCID,authcid);
  request.setAttribute(SecurityContextFactory.ATTRIBUTE_AUTHZID,authzid);
  filterChain.doFilter(request,servletResponse);
}","/** 
 * Copies the authentication principal header, set by the authentication filter, into the request as an attribute with the key SecurityContextFactory.ATTRIBUTE_AUTHCID and copies the authentication context attribute, set by the authentication filter, into the request as an attributes with the key SecurityContextFactory.ATTRIBUTES_AUTHZID.
 * @param servletRequest {@inheritDoc}
 * @param servletResponse {@inheritDoc}
 * @param filterChain {@inheritDoc}
 * @throws IOException {@inheritDoc}
 * @throws ServletException {@inheritDoc}
 */
@Override public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse,FilterChain filterChain) throws IOException, ServletException {
  if ((!HttpServletRequest.class.isAssignableFrom(servletRequest.getClass()) || !HttpServletResponse.class.isAssignableFrom(servletResponse.getClass()))) {
    throw new ServletException(""String_Node_Str"");
  }
  HttpServletRequest request=(HttpServletRequest)servletRequest;
  Map<String,Object> authzid=(Map<String,Object>)request.getAttribute(AuthNFilter.ATTRIBUTE_AUTH_CONTEXT);
  String authcid=(String)authzid.get(""String_Node_Str"");
  request.setAttribute(SecurityContextFactory.ATTRIBUTE_AUTHCID,authcid);
  request.setAttribute(SecurityContextFactory.ATTRIBUTE_AUTHZID,authzid);
  filterChain.doFilter(request,servletResponse);
}"
13291,"public void bundleChanged(BundleEvent event){
  if (event.getBundle().getSymbolicName().equals(bundleName)) {
    if (event.getType() == BundleEvent.STARTED) {
      ResourceServlet.this.bundle=event.getBundle();
      logger.info(""String_Node_Str"" + bundleName + ""String_Node_Str"");
    }
 else     if (event.getType() == BundleEvent.STOPPED) {
      ResourceServlet.this.bundle=null;
      logger.info(""String_Node_Str"" + bundleName + ""String_Node_Str"");
    }
  }
}","public void bundleChanged(BundleEvent event){
  Bundle bundle=event.getBundle();
  if (bundle != null && bundle.getSymbolicName() != null && bundle.getSymbolicName().equals(bundleName)) {
    if (event.getType() == BundleEvent.STARTED) {
      ResourceServlet.this.bundle=bundle;
      logger.info(""String_Node_Str"" + bundleName + ""String_Node_Str"");
    }
 else     if (event.getType() == BundleEvent.STOPPED) {
      ResourceServlet.this.bundle=null;
      logger.info(""String_Node_Str"" + bundleName + ""String_Node_Str"");
    }
  }
}"
13292,"@Activate protected void activate(ComponentContext context) throws ServletException, NamespaceException {
  logger.info(""String_Node_Str"",context.getProperties());
  JsonValue config=new JSONEnhancedConfig().getConfigurationAsJson(context);
  if (!config.get(CONFIG_ENABLED).isNull() && Boolean.FALSE.equals(config.get(CONFIG_ENABLED).asBoolean())) {
    logger.info(""String_Node_Str"");
    return;
  }
 else   if (config.get(CONFIG_CONTEXT_ROOT) == null || config.get(CONFIG_CONTEXT_ROOT).isNull()) {
    logger.info(""String_Node_Str"");
    return;
  }
 else   if (config.get(CONFIG_BUNDLE) == null || config.get(CONFIG_BUNDLE).isNull() || !config.get(CONFIG_BUNDLE).isMap() || config.get(CONFIG_BUNDLE).get(CONFIG_NAME) == null || config.get(CONFIG_BUNDLE).get(CONFIG_NAME).isNull()) {
    logger.info(""String_Node_Str"");
    return;
  }
 else   if (config.get(CONFIG_BUNDLE) == null || config.get(CONFIG_BUNDLE).isNull() || !config.get(CONFIG_BUNDLE).isMap() || config.get(CONFIG_BUNDLE).get(CONFIG_RESOURCE_DIR) == null || config.get(CONFIG_BUNDLE).get(CONFIG_RESOURCE_DIR).isNull()) {
    logger.info(""String_Node_Str"");
    return;
  }
  bundleName=config.get(CONFIG_BUNDLE).get(CONFIG_NAME).asString();
  resourceDir=prependSlash(config.get(CONFIG_BUNDLE).get(CONFIG_RESOURCE_DIR).asString());
  contextRoot=prependSlash(config.get(CONFIG_CONTEXT_ROOT).asString());
  if (bundleName != null) {
    for (    Bundle aBundle : context.getBundleContext().getBundles()) {
      if (bundleName.equals(aBundle.getSymbolicName())) {
        this.bundle=aBundle;
        break;
      }
    }
  }
  if (bundle == null) {
    logger.info(""String_Node_Str"" + bundleName + ""String_Node_Str"");
  }
  bundleListener=new BundleListener(){
    public void bundleChanged(    BundleEvent event){
      if (event.getBundle().getSymbolicName().equals(bundleName)) {
        if (event.getType() == BundleEvent.STARTED) {
          ResourceServlet.this.bundle=event.getBundle();
          logger.info(""String_Node_Str"" + bundleName + ""String_Node_Str"");
        }
 else         if (event.getType() == BundleEvent.STOPPED) {
          ResourceServlet.this.bundle=null;
          logger.info(""String_Node_Str"" + bundleName + ""String_Node_Str"");
        }
      }
    }
  }
;
  context.getBundleContext().addBundleListener(bundleListener);
  extFolders=new ArrayList<String>();
  extFolders.add(""String_Node_Str"");
  extFolders.add(""String_Node_Str"");
  extFolders.add(""String_Node_Str"");
  extFolders.add(""String_Node_Str"");
  Dictionary<String,Object> props=new Hashtable<String,Object>();
  webContainer.registerServlet(contextRoot,this,props,webContainer.getDefaultSharedHttpContext());
  logger.debug(""String_Node_Str"",contextRoot);
}","@Activate protected void activate(ComponentContext context) throws ServletException, NamespaceException {
  logger.info(""String_Node_Str"",context.getProperties());
  JsonValue config=new JSONEnhancedConfig().getConfigurationAsJson(context);
  if (!config.get(CONFIG_ENABLED).isNull() && Boolean.FALSE.equals(config.get(CONFIG_ENABLED).asBoolean())) {
    logger.info(""String_Node_Str"");
    return;
  }
 else   if (config.get(CONFIG_CONTEXT_ROOT) == null || config.get(CONFIG_CONTEXT_ROOT).isNull()) {
    logger.info(""String_Node_Str"");
    return;
  }
 else   if (config.get(CONFIG_BUNDLE) == null || config.get(CONFIG_BUNDLE).isNull() || !config.get(CONFIG_BUNDLE).isMap() || config.get(CONFIG_BUNDLE).get(CONFIG_NAME) == null || config.get(CONFIG_BUNDLE).get(CONFIG_NAME).isNull()) {
    logger.info(""String_Node_Str"");
    return;
  }
 else   if (config.get(CONFIG_BUNDLE) == null || config.get(CONFIG_BUNDLE).isNull() || !config.get(CONFIG_BUNDLE).isMap() || config.get(CONFIG_BUNDLE).get(CONFIG_RESOURCE_DIR) == null || config.get(CONFIG_BUNDLE).get(CONFIG_RESOURCE_DIR).isNull()) {
    logger.info(""String_Node_Str"");
    return;
  }
  bundleName=config.get(CONFIG_BUNDLE).get(CONFIG_NAME).asString();
  resourceDir=prependSlash(config.get(CONFIG_BUNDLE).get(CONFIG_RESOURCE_DIR).asString());
  contextRoot=prependSlash(config.get(CONFIG_CONTEXT_ROOT).asString());
  if (bundleName != null) {
    for (    Bundle aBundle : context.getBundleContext().getBundles()) {
      if (bundleName.equals(aBundle.getSymbolicName())) {
        this.bundle=aBundle;
        break;
      }
    }
  }
  if (bundle == null) {
    logger.info(""String_Node_Str"" + bundleName + ""String_Node_Str"");
  }
  bundleListener=new BundleListener(){
    public void bundleChanged(    BundleEvent event){
      Bundle bundle=event.getBundle();
      if (bundle != null && bundle.getSymbolicName() != null && bundle.getSymbolicName().equals(bundleName)) {
        if (event.getType() == BundleEvent.STARTED) {
          ResourceServlet.this.bundle=bundle;
          logger.info(""String_Node_Str"" + bundleName + ""String_Node_Str"");
        }
 else         if (event.getType() == BundleEvent.STOPPED) {
          ResourceServlet.this.bundle=null;
          logger.info(""String_Node_Str"" + bundleName + ""String_Node_Str"");
        }
      }
    }
  }
;
  context.getBundleContext().addBundleListener(bundleListener);
  extFolders=new ArrayList<String>();
  extFolders.add(""String_Node_Str"");
  extFolders.add(""String_Node_Str"");
  extFolders.add(""String_Node_Str"");
  extFolders.add(""String_Node_Str"");
  Dictionary<String,Object> props=new Hashtable<String,Object>();
  webContainer.registerServlet(contextRoot,this,props,webContainer.getDefaultSharedHttpContext());
  logger.debug(""String_Node_Str"",contextRoot);
}"
13293,"@Override public boolean removeTrigger(SchedulingContext context,String triggerName,String groupName) throws JobPersistenceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    String triggerId=getTriggersRepoId(groupName,triggerName);
    try {
      TriggerGroupWrapper tgw=getOrCreateTriggerGroupWrapper(groupName);
      String rev=tgw.getRevision();
      List<String> triggerNames=tgw.getTriggerNames();
      if (triggerNames.contains(triggerName)) {
        tgw.removeTrigger(triggerName);
        UpdateRequest r=Requests.newUpdateRequest(getTriggerGroupsRepoId(groupName),tgw.getValue());
        r.setRevision(tgw.getRevision());
        accessor.getConnection().update(accessor,r);
      }
      TriggerWrapper tw=getTriggerWrapper(groupName,triggerName);
      if (tw != null) {
        removeWaitingTrigger(tw.getTrigger());
        removeAcquiredTrigger(tw.getTrigger(),instanceId);
        rev=tw.getRevision();
        logger.debug(""String_Node_Str"",new Object[]{triggerName,groupName});
        DeleteRequest r=Requests.newDeleteRequest(triggerId);
        r.setRevision(rev);
        accessor.getConnection().delete(accessor,r);
        String jobName=tw.getTrigger().getJobName();
        JobWrapper jw=getJobWrapper(groupName,jobName);
        if (jw != null) {
          if (!jw.getJobDetail().isDurable()) {
            String jobId=getJobsRepoId(groupName,jobName);
            JobGroupWrapper jgw=getOrCreateJobGroupWrapper(groupName);
            List<String> jobNames=jgw.getJobNames();
            if (jobNames.contains(jobName)) {
              jgw.removeJob(jobName);
              UpdateRequest ru=Requests.newUpdateRequest(getJobGroupsRepoId(groupName),jgw.getValue());
              r.setRevision(jgw.getRevision());
              accessor.getConnection().update(accessor,ru);
            }
            logger.debug(""String_Node_Str"",new Object[]{jobName,groupName});
            r=Requests.newDeleteRequest(jobId);
            r.setRevision(jw.getRevision());
            accessor.getConnection().delete(accessor,r);
          }
        }
        return true;
      }
      return false;
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"",triggerName,e);
      throw new JobPersistenceException(""String_Node_Str"",e);
    }
  }
}","@Override public boolean removeTrigger(SchedulingContext context,String triggerName,String groupName) throws JobPersistenceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    String triggerId=getTriggersRepoId(groupName,triggerName);
    try {
      TriggerGroupWrapper tgw=getOrCreateTriggerGroupWrapper(groupName);
      String rev=tgw.getRevision();
      List<String> triggerNames=tgw.getTriggerNames();
      if (triggerNames.contains(triggerName)) {
        tgw.removeTrigger(triggerName);
        UpdateRequest r=Requests.newUpdateRequest(getTriggerGroupsRepoId(groupName),tgw.getValue());
        r.setRevision(tgw.getRevision());
        accessor.getConnection().update(accessor,r);
      }
      TriggerWrapper tw=getTriggerWrapper(groupName,triggerName);
      if (tw != null) {
        removeWaitingTrigger(tw.getTrigger());
        removeAcquiredTrigger(tw.getTrigger(),instanceId);
        rev=tw.getRevision();
        logger.debug(""String_Node_Str"",new Object[]{triggerName,groupName});
        DeleteRequest r=Requests.newDeleteRequest(triggerId);
        r.setRevision(rev);
        accessor.getConnection().delete(accessor,r);
        String jobName=tw.getTrigger().getJobName();
        JobWrapper jw=getJobWrapper(groupName,jobName);
        if (jw != null) {
          if (!jw.getJobDetail().isDurable()) {
            String jobId=getJobsRepoId(groupName,jobName);
            JobGroupWrapper jgw=getOrCreateJobGroupWrapper(groupName);
            List<String> jobNames=jgw.getJobNames();
            if (jobNames.contains(jobName)) {
              jgw.removeJob(jobName);
              UpdateRequest ru=Requests.newUpdateRequest(getJobGroupsRepoId(groupName),jgw.getValue());
              ru.setRevision(jgw.getRevision());
              accessor.getConnection().update(accessor,ru);
            }
            logger.debug(""String_Node_Str"",new Object[]{jobName,groupName});
            r=Requests.newDeleteRequest(jobId);
            r.setRevision(jw.getRevision());
            accessor.getConnection().delete(accessor,r);
          }
        }
        return true;
      }
      return false;
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"",triggerName,e);
      throw new JobPersistenceException(""String_Node_Str"",e);
    }
  }
}"
13294,"/** 
 * TODO: Description.
 * @throws SynchronizationException TODO.
 */
void create() throws SynchronizationException {
  _id=UUID.randomUUID().toString();
  JsonValue jv=toJsonValue();
  try {
    CreateRequest r=Requests.newCreateRequest(linkId(null),_id,jv);
    mapping.getService().getRouter().getConnection().create(mapping.getService().getRouter(),r);
  }
 catch (  ResourceException ose) {
    LOGGER.debug(""String_Node_Str"",ose);
    throw new SynchronizationException(ose);
  }
  this._id=jv.get(""String_Node_Str"").required().asString();
  this._rev=jv.get(""String_Node_Str"").asString();
  this.initialized=true;
}","/** 
 * TODO: Description.
 * @throws SynchronizationException TODO.
 */
void create() throws SynchronizationException {
  _id=UUID.randomUUID().toString();
  JsonValue jv=toJsonValue();
  try {
    CreateRequest r=Requests.newCreateRequest(linkId(null),_id,jv);
    Resource resource=mapping.getService().getRouter().getConnection().create(mapping.getService().getRouter(),r);
    this._id=resource.getId();
    this._rev=resource.getRevision();
    this.initialized=true;
  }
 catch (  ResourceException ose) {
    LOGGER.debug(""String_Node_Str"",ose);
    throw new SynchronizationException(ose);
  }
}"
13295,"/** 
 * TODO: Description.
 * @param target TODO.
 * @throws SynchronizationException TODO.
 */
private LazyObjectAccessor createTargetObject(JsonValue target) throws SynchronizationException {
  EventEntry measure=Publisher.start(EVENT_CREATE_OBJ,target,null);
  LazyObjectAccessor targetObject=null;
  StringBuilder sb=new StringBuilder();
  sb.append(targetObjectSet);
  if (target.get(""String_Node_Str"").isString()) {
    sb.append('/').append(target.get(""String_Node_Str"").asString());
  }
  String id=sb.toString();
  LOGGER.trace(""String_Node_Str"",id);
  try {
    CreateRequest cr=Requests.newCreateRequest(id,null,target);
    Resource r=service.getRouter().getConnection().create(service.getRouter(),cr);
    targetObject=new LazyObjectAccessor(service,targetObjectSet,r.getId(),target);
    measure.setResult(target);
  }
 catch (  JsonValueException jve) {
    throw new SynchronizationException(jve);
  }
catch (  ResourceException ose) {
    LOGGER.warn(""String_Node_Str"",ose);
    throw new SynchronizationException(ose);
  }
 finally {
    measure.end();
  }
  return targetObject;
}","/** 
 * TODO: Description.
 * @param target TODO.
 * @throws SynchronizationException TODO.
 */
private LazyObjectAccessor createTargetObject(JsonValue target) throws SynchronizationException {
  EventEntry measure=Publisher.start(EVENT_CREATE_OBJ,target,null);
  LazyObjectAccessor targetObject=null;
  LOGGER.trace(""String_Node_Str"",targetObjectSet,target.get(""String_Node_Str"").asString());
  try {
    CreateRequest cr=Requests.newCreateRequest(targetObjectSet,target.get(""String_Node_Str"").asString(),target);
    Resource r=service.getRouter().getConnection().create(service.getRouter(),cr);
    targetObject=new LazyObjectAccessor(service,targetObjectSet,r.getId(),target);
    measure.setResult(target);
  }
 catch (  JsonValueException jve) {
    throw new SynchronizationException(jve);
  }
catch (  ResourceException ose) {
    LOGGER.warn(""String_Node_Str"",ose);
    throw new SynchronizationException(ose);
  }
 finally {
    measure.end();
  }
  return targetObject;
}"
13296,"/** 
 * Returns the an AcquiredTriggers object which wraps the List of all triggers in the ""acquired"" state
 * @param instanceId    the ID of the instance that acquired the triggers
 * @return  the WaitingTriggers object
 * @throws JobPersistenceException
 */
private AcquiredTriggers getAcquiredTriggers(String instanceId) throws JobPersistenceException {
  List<Trigger> acquiredTriggers=new ArrayList<Trigger>();
  List<String> acquiredTriggerIds=new ArrayList<String>();
  String repoId=getAcquiredTriggersRepoId();
  String revision=null;
  Map<String,Object> map;
  if (!setAccessor()) {
    throw new JobPersistenceException(""String_Node_Str"");
  }
  try {
    try {
      map=accessor.getConnection().read(accessor,Requests.newReadRequest(repoId)).getContent().asMap();
    }
 catch (    NotFoundException e) {
      logger.debug(""String_Node_Str"",""String_Node_Str"");
      map=null;
    }
    if (map == null) {
      map=new HashMap<String,Object>();
      map.put(instanceId,acquiredTriggerIds);
      map=accessor.getConnection().create(accessor,Requests.newCreateRequest(repoId.substring(0,repoId.lastIndexOf(""String_Node_Str"")),repoId.substring(repoId.lastIndexOf(""String_Node_Str"") + 1),new JsonValue(map))).getContent().asMap();
      revision=(String)map.get(""String_Node_Str"");
    }
 else {
      acquiredTriggerIds=(List<String>)map.get(instanceId);
      revision=(String)map.get(""String_Node_Str"");
      if (acquiredTriggerIds == null) {
        acquiredTriggerIds=new ArrayList<String>();
        map.put(instanceId,acquiredTriggerIds);
        UpdateRequest r=Requests.newUpdateRequest(repoId,new JsonValue(map));
        r.setRevision(revision);
        JsonValue updatedValue=accessor.getConnection().update(accessor,r).getContent();
        ;
        revision=(String)updatedValue.asMap().get(""String_Node_Str"");
      }
    }
    for (    String id : acquiredTriggerIds) {
      TriggerWrapper tw=getTriggerWrapper(getGroupFromId(id),getNameFromId(id));
      if (tw == null) {
        logger.warn(""String_Node_Str"",id);
      }
 else {
        logger.debug(""String_Node_Str"",new Object[]{tw.getName(),tw.getGroup()});
        acquiredTriggers.add(tw.getTrigger());
      }
    }
    return new AcquiredTriggers(acquiredTriggers,revision);
  }
 catch (  ResourceException e) {
    logger.warn(""String_Node_Str"",e);
    throw new JobPersistenceException(""String_Node_Str"",e);
  }
}","/** 
 * Returns the an AcquiredTriggers object which wraps the List of all triggers in the ""acquired"" state
 * @param instanceId    the ID of the instance that acquired the triggers
 * @return  the WaitingTriggers object
 * @throws JobPersistenceException
 */
private AcquiredTriggers getAcquiredTriggers(String instanceId) throws JobPersistenceException {
  List<Trigger> acquiredTriggers=new ArrayList<Trigger>();
  List<String> acquiredTriggerIds=new ArrayList<String>();
  String repoId=getAcquiredTriggersRepoId();
  String revision=null;
  Map<String,Object> map;
  if (!setAccessor()) {
    throw new JobPersistenceException(""String_Node_Str"");
  }
  try {
    try {
      map=accessor.getConnection().read(accessor,Requests.newReadRequest(repoId)).getContent().asMap();
    }
 catch (    NotFoundException e) {
      logger.debug(""String_Node_Str"",""String_Node_Str"");
      map=null;
    }
    if (map == null) {
      map=new HashMap<String,Object>();
      map.put(instanceId,acquiredTriggerIds);
      map=accessor.getConnection().create(accessor,getCreateRequest(repoId,map)).getContent().asMap();
      revision=(String)map.get(""String_Node_Str"");
    }
 else {
      acquiredTriggerIds=(List<String>)map.get(instanceId);
      revision=(String)map.get(""String_Node_Str"");
      if (acquiredTriggerIds == null) {
        acquiredTriggerIds=new ArrayList<String>();
        map.put(instanceId,acquiredTriggerIds);
        UpdateRequest r=Requests.newUpdateRequest(repoId,new JsonValue(map));
        r.setRevision(revision);
        JsonValue updatedValue=accessor.getConnection().update(accessor,r).getContent();
        ;
        revision=(String)updatedValue.asMap().get(""String_Node_Str"");
      }
    }
    for (    String id : acquiredTriggerIds) {
      TriggerWrapper tw=getTriggerWrapper(getGroupFromId(id),getNameFromId(id));
      if (tw == null) {
        logger.warn(""String_Node_Str"",id);
      }
 else {
        logger.debug(""String_Node_Str"",new Object[]{tw.getName(),tw.getGroup()});
        acquiredTriggers.add(tw.getTrigger());
      }
    }
    return new AcquiredTriggers(acquiredTriggers,revision);
  }
 catch (  ResourceException e) {
    logger.warn(""String_Node_Str"",e);
    throw new JobPersistenceException(""String_Node_Str"",e);
  }
}"
13297,"/** 
 * Returns the a WaitingTriggers object which wraps the Tree of all triggers in the ""waiting"" state
 * @return  the WaitingTriggers object
 * @throws JobPersistenceException
 */
private WaitingTriggers getWaitingTriggers() throws JobPersistenceException {
  TreeSet<Trigger> waitingTriggers=new TreeSet(new TriggerComparator());
  List<String> waitingTriggersRepoList=null;
  String repoId=getWaitingTriggersRepoId();
  String revision=null;
  Map<String,Object> map;
  if (!setAccessor()) {
    throw new JobPersistenceException(""String_Node_Str"");
  }
  try {
    try {
      map=accessor.getConnection().read(accessor,Requests.newReadRequest(repoId)).getContent().asMap();
    }
 catch (    NotFoundException e) {
      logger.debug(""String_Node_Str"",""String_Node_Str"");
      map=null;
    }
    if (map == null) {
      map=new HashMap<String,Object>();
      waitingTriggersRepoList=new ArrayList<String>();
      map.put(""String_Node_Str"",waitingTriggersRepoList);
      map=accessor.getConnection().create(accessor,Requests.newCreateRequest(repoId.substring(0,repoId.lastIndexOf(""String_Node_Str"")),repoId.substring(repoId.lastIndexOf(""String_Node_Str"") + 1),new JsonValue(map))).getContent().asMap();
      revision=(String)map.get(""String_Node_Str"");
    }
 else {
      waitingTriggersRepoList=(List<String>)map.get(""String_Node_Str"");
      revision=(String)map.get(""String_Node_Str"");
      if (waitingTriggersRepoList == null) {
        waitingTriggersRepoList=new ArrayList<String>();
        map.put(""String_Node_Str"",waitingTriggersRepoList);
        UpdateRequest r=Requests.newUpdateRequest(repoId,new JsonValue(map));
        r.setRevision(revision);
        JsonValue updatedValue=accessor.getConnection().update(accessor,r).getContent();
        revision=(String)updatedValue.asMap().get(""String_Node_Str"");
      }
    }
    for (    String id : waitingTriggersRepoList) {
      TriggerWrapper tw=getTriggerWrapper(getGroupFromId(id),getNameFromId(id));
      if (tw == null) {
        logger.warn(""String_Node_Str"",id);
      }
 else {
        logger.debug(""String_Node_Str"",new Object[]{tw.getName(),tw.getGroup()});
        waitingTriggers.add(tw.getTrigger());
      }
    }
    return new WaitingTriggers(waitingTriggers,revision);
  }
 catch (  ResourceException e) {
    logger.warn(""String_Node_Str"",e);
    throw new JobPersistenceException(""String_Node_Str"",e);
  }
}","/** 
 * Returns the a WaitingTriggers object which wraps the Tree of all triggers in the ""waiting"" state
 * @return  the WaitingTriggers object
 * @throws JobPersistenceException
 */
private WaitingTriggers getWaitingTriggers() throws JobPersistenceException {
  TreeSet<Trigger> waitingTriggers=new TreeSet(new TriggerComparator());
  List<String> waitingTriggersRepoList=null;
  String repoId=getWaitingTriggersRepoId();
  String revision=null;
  Map<String,Object> map;
  if (!setAccessor()) {
    throw new JobPersistenceException(""String_Node_Str"");
  }
  try {
    try {
      map=accessor.getConnection().read(accessor,Requests.newReadRequest(repoId)).getContent().asMap();
    }
 catch (    NotFoundException e) {
      logger.debug(""String_Node_Str"",""String_Node_Str"");
      map=null;
    }
    if (map == null) {
      map=new HashMap<String,Object>();
      waitingTriggersRepoList=new ArrayList<String>();
      map.put(""String_Node_Str"",waitingTriggersRepoList);
      map=accessor.getConnection().create(accessor,getCreateRequest(repoId,map)).getContent().asMap();
      revision=(String)map.get(""String_Node_Str"");
    }
 else {
      waitingTriggersRepoList=(List<String>)map.get(""String_Node_Str"");
      revision=(String)map.get(""String_Node_Str"");
      if (waitingTriggersRepoList == null) {
        waitingTriggersRepoList=new ArrayList<String>();
        map.put(""String_Node_Str"",waitingTriggersRepoList);
        UpdateRequest r=Requests.newUpdateRequest(repoId,new JsonValue(map));
        r.setRevision(revision);
        JsonValue updatedValue=accessor.getConnection().update(accessor,r).getContent();
        revision=(String)updatedValue.asMap().get(""String_Node_Str"");
      }
    }
    for (    String id : waitingTriggersRepoList) {
      TriggerWrapper tw=getTriggerWrapper(getGroupFromId(id),getNameFromId(id));
      if (tw == null) {
        logger.warn(""String_Node_Str"",id);
      }
 else {
        logger.debug(""String_Node_Str"",new Object[]{tw.getName(),tw.getGroup()});
        waitingTriggers.add(tw.getTrigger());
      }
    }
    return new WaitingTriggers(waitingTriggers,revision);
  }
 catch (  ResourceException e) {
    logger.warn(""String_Node_Str"",e);
    throw new JobPersistenceException(""String_Node_Str"",e);
  }
}"
13298,"private List<String> getOrCreateRepoList(String repoId,String listId) throws JobPersistenceException, ResourceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    List<String> list=null;
    Map<String,Object> map;
    String revision=null;
    try {
      map=accessor.getConnection().read(accessor,Requests.newReadRequest(repoId)).getContent().asMap();
    }
 catch (    NotFoundException e) {
      logger.debug(""String_Node_Str"",listId);
      map=null;
    }
    if (map == null) {
      map=new HashMap<String,Object>();
      list=new ArrayList<String>();
      map.put(listId,list);
      map=accessor.getConnection().create(accessor,Requests.newCreateRequest(repoId.substring(0,repoId.lastIndexOf(""String_Node_Str"")),repoId.substring(repoId.lastIndexOf(""String_Node_Str"") + 1),new JsonValue(map))).getContent().asMap();
    }
 else {
      list=(List<String>)map.get(listId);
      if (list == null) {
        list=new ArrayList<String>();
        map.put(listId,list);
        revision=(String)map.get(""String_Node_Str"");
        UpdateRequest r=Requests.newUpdateRequest(repoId,new JsonValue(map));
        r.setRevision(revision);
        accessor.getConnection().update(accessor,r);
      }
    }
    return list;
  }
}","private List<String> getOrCreateRepoList(String repoId,String listId) throws JobPersistenceException, ResourceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    List<String> list=null;
    Map<String,Object> map;
    String revision=null;
    try {
      map=accessor.getConnection().read(accessor,Requests.newReadRequest(repoId)).getContent().asMap();
    }
 catch (    NotFoundException e) {
      logger.debug(""String_Node_Str"",listId);
      map=null;
    }
    if (map == null) {
      map=new HashMap<String,Object>();
      list=new ArrayList<String>();
      map.put(listId,list);
      map=accessor.getConnection().create(accessor,getCreateRequest(repoId,map)).getContent().asMap();
    }
 else {
      list=(List<String>)map.get(listId);
      if (list == null) {
        list=new ArrayList<String>();
        map.put(listId,list);
        revision=(String)map.get(""String_Node_Str"");
        UpdateRequest r=Requests.newUpdateRequest(repoId,new JsonValue(map));
        r.setRevision(revision);
        accessor.getConnection().update(accessor,r);
      }
    }
    return list;
  }
}"
13299,"@Override public void storeTrigger(SchedulingContext context,Trigger trigger,boolean replaceExisting) throws ObjectAlreadyExistsException, JobPersistenceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    String triggerName=trigger.getKey().getName();
    String groupName=trigger.getKey().getGroup();
    String triggerId=getTriggersRepoId(groupName,triggerName);
    TriggerGroupWrapper tgw=null;
    try {
      tgw=getOrCreateTriggerGroupWrapper(groupName);
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
      throw new JobPersistenceException(""String_Node_Str"" + ""String_Node_Str"",e);
    }
    List<String> triggerNames=tgw.getTriggerNames();
    TriggerWrapper tw;
    try {
      tw=new TriggerWrapper(trigger,tgw.isPaused());
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"",e);
      throw new JobPersistenceException(""String_Node_Str"" + ""String_Node_Str"",e);
    }
    if (triggerNames.contains(triggerName) && !replaceExisting) {
      throw new ObjectAlreadyExistsException(trigger);
    }
    try {
      if (triggerNames.contains(triggerName)) {
        TriggerWrapper oldTw=getTriggerWrapper(groupName,triggerName);
        logger.debug(""String_Node_Str"",triggerId);
        UpdateRequest r=Requests.newUpdateRequest(triggerId,tw.getValue());
        r.setRevision(oldTw.getRevision());
        accessor.getConnection().update(accessor,r);
      }
 else {
        tgw.addTrigger(triggerName);
        UpdateRequest r=Requests.newUpdateRequest(getTriggerGroupsRepoId(groupName),tgw.getValue());
        r.setRevision(tgw.getRevision());
        accessor.getConnection().update(accessor,r);
        logger.debug(""String_Node_Str"",triggerId);
        accessor.getConnection().create(accessor,Requests.newCreateRequest(triggerId,tw.getValue()));
      }
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
      throw new JobPersistenceException(""String_Node_Str"" + ""String_Node_Str"",e);
    }
    logger.debug(""String_Node_Str"",trigger.getName());
    addWaitingTrigger(trigger);
  }
}","@Override public void storeTrigger(SchedulingContext context,Trigger trigger,boolean replaceExisting) throws ObjectAlreadyExistsException, JobPersistenceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    String triggerName=trigger.getKey().getName();
    String groupName=trigger.getKey().getGroup();
    String triggerId=getTriggersRepoId(groupName,triggerName);
    TriggerGroupWrapper tgw=null;
    try {
      tgw=getOrCreateTriggerGroupWrapper(groupName);
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
      throw new JobPersistenceException(""String_Node_Str"" + ""String_Node_Str"",e);
    }
    List<String> triggerNames=tgw.getTriggerNames();
    TriggerWrapper tw;
    try {
      tw=new TriggerWrapper(trigger,tgw.isPaused());
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"",e);
      throw new JobPersistenceException(""String_Node_Str"" + ""String_Node_Str"",e);
    }
    if (triggerNames.contains(triggerName) && !replaceExisting) {
      throw new ObjectAlreadyExistsException(trigger);
    }
    try {
      if (triggerNames.contains(triggerName)) {
        TriggerWrapper oldTw=getTriggerWrapper(groupName,triggerName);
        logger.debug(""String_Node_Str"",triggerId);
        UpdateRequest r=Requests.newUpdateRequest(triggerId,tw.getValue());
        r.setRevision(oldTw.getRevision());
        accessor.getConnection().update(accessor,r);
      }
 else {
        tgw.addTrigger(triggerName);
        UpdateRequest r=Requests.newUpdateRequest(getTriggerGroupsRepoId(groupName),tgw.getValue());
        r.setRevision(tgw.getRevision());
        accessor.getConnection().update(accessor,r);
        logger.debug(""String_Node_Str"",triggerId);
        accessor.getConnection().create(accessor,getCreateRequest(triggerId,tw.getValue().asMap()));
      }
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
      throw new JobPersistenceException(""String_Node_Str"" + ""String_Node_Str"",e);
    }
    logger.debug(""String_Node_Str"",trigger.getName());
    addWaitingTrigger(trigger);
  }
}"
13300,"@Override public void storeJob(SchedulingContext context,JobDetail newJob,boolean replaceExisting) throws ObjectAlreadyExistsException, JobPersistenceException {
synchronized (lock) {
    logger.debug(""String_Node_Str"",newJob.getFullName());
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    String jobName=newJob.getName();
    String jobGroup=newJob.getGroup();
    String jobId=getJobsRepoId(jobGroup,jobName);
    JobGroupWrapper jgw=null;
    try {
      jgw=getOrCreateJobGroupWrapper(jobGroup);
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
      throw new JobPersistenceException(""String_Node_Str"" + ""String_Node_Str"",e);
    }
    List<String> jobNames=jgw.getJobNames();
    JobWrapper jw=new JobWrapper(newJob,jgw.isPaused());
    if (jobNames.contains(jobName) && !replaceExisting) {
      throw new ObjectAlreadyExistsException(newJob);
    }
    try {
      if (jobNames.contains(jobName)) {
        JobWrapper oldJw=getJobWrapper(jobGroup,jobName);
        logger.debug(""String_Node_Str"",new Object[]{jobName,jobGroup});
        UpdateRequest r=Requests.newUpdateRequest(jobId,jw.getValue());
        r.setRevision(oldJw.getRevision());
        accessor.getConnection().update(accessor,r);
      }
 else {
        jgw.addJob(jobName);
        UpdateRequest r=Requests.newUpdateRequest(getJobGroupsRepoId(jobGroup),jgw.getValue());
        r.setRevision(jgw.getRevision());
        accessor.getConnection().update(accessor,r);
        logger.debug(""String_Node_Str"",new Object[]{jobName,jobGroup});
        accessor.getConnection().create(accessor,Requests.newCreateRequest(jobId,jw.getValue()));
      }
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
      throw new JobPersistenceException(""String_Node_Str"" + ""String_Node_Str"",e);
    }
  }
}","@Override public void storeJob(SchedulingContext context,JobDetail newJob,boolean replaceExisting) throws ObjectAlreadyExistsException, JobPersistenceException {
synchronized (lock) {
    logger.debug(""String_Node_Str"",newJob.getFullName());
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    String jobName=newJob.getName();
    String jobGroup=newJob.getGroup();
    String jobId=getJobsRepoId(jobGroup,jobName);
    JobGroupWrapper jgw=null;
    try {
      jgw=getOrCreateJobGroupWrapper(jobGroup);
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
      throw new JobPersistenceException(""String_Node_Str"" + ""String_Node_Str"",e);
    }
    List<String> jobNames=jgw.getJobNames();
    JobWrapper jw=new JobWrapper(newJob,jgw.isPaused());
    if (jobNames.contains(jobName) && !replaceExisting) {
      throw new ObjectAlreadyExistsException(newJob);
    }
    try {
      if (jobNames.contains(jobName)) {
        JobWrapper oldJw=getJobWrapper(jobGroup,jobName);
        logger.debug(""String_Node_Str"",new Object[]{jobName,jobGroup});
        UpdateRequest r=Requests.newUpdateRequest(jobId,jw.getValue());
        r.setRevision(oldJw.getRevision());
        accessor.getConnection().update(accessor,r);
      }
 else {
        jgw.addJob(jobName);
        UpdateRequest r=Requests.newUpdateRequest(getJobGroupsRepoId(jobGroup),jgw.getValue());
        r.setRevision(jgw.getRevision());
        accessor.getConnection().update(accessor,r);
        logger.debug(""String_Node_Str"",new Object[]{jobName,jobGroup});
        accessor.getConnection().create(accessor,getCreateRequest(jobId,jw.getValue().asMap()));
      }
    }
 catch (    ResourceException e) {
      logger.warn(""String_Node_Str"",e);
      throw new JobPersistenceException(""String_Node_Str"" + ""String_Node_Str"",e);
    }
  }
}"
13301,"@Override public void storeCalendar(SchedulingContext context,String name,Calendar calendar,boolean replaceExisting,boolean updateTriggers) throws ObjectAlreadyExistsException, JobPersistenceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    try {
      CalendarWrapper cw=new CalendarWrapper(calendar,name);
      if (retrieveCalendar(context,name) == null) {
        logger.debug(""String_Node_Str"",name);
        accessor.getConnection().create(accessor,Requests.newCreateRequest(getCalendarsRepoId(name),cw.getValue()));
      }
 else {
        if (!replaceExisting) {
          throw new ObjectAlreadyExistsException(name);
        }
        CalendarWrapper oldCw=getCalendarWrapper(name);
        logger.debug(""String_Node_Str"",name);
        UpdateRequest r=Requests.newUpdateRequest(getCalendarsRepoId(name),cw.getValue());
        r.setRevision(oldCw.getRevision());
        accessor.getConnection().update(accessor,r);
      }
      if (updateTriggers) {
        List<TriggerWrapper> twList=getTriggerWrappersForCalendar(name);
        for (        TriggerWrapper tw : twList) {
          Trigger t=tw.getTrigger();
          boolean removed=removeWaitingTrigger(t);
          t.updateWithNewCalendar(calendar,getMisfireThreshold());
          tw.updateTrigger(t);
          logger.debug(""String_Node_Str"",new Object[]{tw.getName(),tw.getGroup()});
          updateTriggerInRepo(tw.getGroup(),tw.getName(),tw,tw.getRevision());
          if (removed) {
            addWaitingTrigger(t);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"",name,e);
      throw new JobPersistenceException(""String_Node_Str"",e);
    }
  }
}","@Override public void storeCalendar(SchedulingContext context,String name,Calendar calendar,boolean replaceExisting,boolean updateTriggers) throws ObjectAlreadyExistsException, JobPersistenceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    try {
      CalendarWrapper cw=new CalendarWrapper(calendar,name);
      if (retrieveCalendar(context,name) == null) {
        logger.debug(""String_Node_Str"",name);
        accessor.getConnection().create(accessor,getCreateRequest(getCalendarsRepoId(name),cw.getValue().asMap()));
      }
 else {
        if (!replaceExisting) {
          throw new ObjectAlreadyExistsException(name);
        }
        CalendarWrapper oldCw=getCalendarWrapper(name);
        logger.debug(""String_Node_Str"",name);
        UpdateRequest r=Requests.newUpdateRequest(getCalendarsRepoId(name),cw.getValue());
        r.setRevision(oldCw.getRevision());
        accessor.getConnection().update(accessor,r);
      }
      if (updateTriggers) {
        List<TriggerWrapper> twList=getTriggerWrappersForCalendar(name);
        for (        TriggerWrapper tw : twList) {
          Trigger t=tw.getTrigger();
          boolean removed=removeWaitingTrigger(t);
          t.updateWithNewCalendar(calendar,getMisfireThreshold());
          tw.updateTrigger(t);
          logger.debug(""String_Node_Str"",new Object[]{tw.getName(),tw.getGroup()});
          updateTriggerInRepo(tw.getGroup(),tw.getName(),tw,tw.getRevision());
          if (removed) {
            addWaitingTrigger(t);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"",name,e);
      throw new JobPersistenceException(""String_Node_Str"",e);
    }
  }
}"
13302,"private Map<String,Object> getOrCreateRepo(String repoId) throws JobPersistenceException, ResourceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    Map<String,Object> map;
    map=readFromRepo(repoId).asMap();
    if (map == null) {
      map=new HashMap<String,Object>();
      logger.debug(""String_Node_Str"",repoId);
      map=accessor.getConnection().create(accessor,Requests.newCreateRequest(repoId.substring(0,repoId.lastIndexOf(""String_Node_Str"")),repoId.substring(repoId.lastIndexOf(""String_Node_Str"") + 1),new JsonValue(map))).getContent().asMap();
    }
    return map;
  }
}","private Map<String,Object> getOrCreateRepo(String repoId) throws JobPersistenceException, ResourceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    Map<String,Object> map;
    map=readFromRepo(repoId).asMap();
    if (map == null) {
      map=new HashMap<String,Object>();
      logger.debug(""String_Node_Str"",repoId);
      map=accessor.getConnection().create(accessor,getCreateRequest(repoId,map)).getContent().asMap();
    }
    return map;
  }
}"
13303,"/** 
 * Gets a Job group from the repo and wraps it in a JobGroupWapper(). Creates the group if it doesn't already exist
 * @param groupName name of group
 * @return a job group wrapped in a JobGroupWrapper
 * @throws ObjectSetException
 */
private JobGroupWrapper getOrCreateJobGroupWrapper(String groupName) throws JobPersistenceException, ResourceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    Map<String,Object> map;
    map=readFromRepo(getJobGroupsRepoId(groupName)).asMap();
    JobGroupWrapper jgw=null;
    if (map == null) {
      jgw=new JobGroupWrapper(groupName);
      JsonValue newValue=accessor.getConnection().create(accessor,Requests.newCreateRequest(getJobGroupsRepoId(groupName),jgw.getValue())).getContent();
      jgw=new JobGroupWrapper(newValue);
      addJobGroupName(groupName);
    }
 else {
      jgw=new JobGroupWrapper(map);
    }
    return jgw;
  }
}","/** 
 * Gets a Job group from the repo and wraps it in a JobGroupWapper(). Creates the group if it doesn't already exist
 * @param groupName name of group
 * @return a job group wrapped in a JobGroupWrapper
 * @throws ObjectSetException
 */
private JobGroupWrapper getOrCreateJobGroupWrapper(String groupName) throws JobPersistenceException, ResourceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    Map<String,Object> map;
    map=readFromRepo(getJobGroupsRepoId(groupName)).asMap();
    JobGroupWrapper jgw=null;
    if (map == null) {
      jgw=new JobGroupWrapper(groupName);
      JsonValue newValue=accessor.getConnection().create(accessor,getCreateRequest(getJobGroupsRepoId(groupName),jgw.getValue().asMap())).getContent();
      jgw=new JobGroupWrapper(newValue);
      addJobGroupName(groupName);
    }
 else {
      jgw=new JobGroupWrapper(map);
    }
    return jgw;
  }
}"
13304,"/** 
 * Gets a Trigger group from the repo and wraps it in a TriggerGroupWapper(). Creates the group if it doesn't already exist
 * @param groupName name of group
 * @return a trigger group wrapped in a TriggerGroupWrapper
 * @throws ObjectSetException
 */
private TriggerGroupWrapper getOrCreateTriggerGroupWrapper(String groupName) throws JobPersistenceException, ResourceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    Map<String,Object> map;
    map=readFromRepo(getTriggerGroupsRepoId(groupName)).asMap();
    TriggerGroupWrapper tgw=null;
    if (map == null) {
      tgw=new TriggerGroupWrapper(groupName);
      JsonValue newValue=accessor.getConnection().create(accessor,Requests.newCreateRequest(getTriggerGroupsRepoId(groupName),tgw.getValue())).getContent();
      tgw=new TriggerGroupWrapper(newValue);
      addTriggerGroupName(groupName);
    }
 else {
      tgw=new TriggerGroupWrapper(map);
    }
    return tgw;
  }
}","/** 
 * Gets a Trigger group from the repo and wraps it in a TriggerGroupWapper(). Creates the group if it doesn't already exist
 * @param groupName name of group
 * @return a trigger group wrapped in a TriggerGroupWrapper
 * @throws ObjectSetException
 */
private TriggerGroupWrapper getOrCreateTriggerGroupWrapper(String groupName) throws JobPersistenceException, ResourceException {
synchronized (lock) {
    if (!setAccessor()) {
      throw new JobPersistenceException(""String_Node_Str"");
    }
    Map<String,Object> map;
    map=readFromRepo(getTriggerGroupsRepoId(groupName)).asMap();
    TriggerGroupWrapper tgw=null;
    if (map == null) {
      tgw=new TriggerGroupWrapper(groupName);
      JsonValue newValue=accessor.getConnection().create(accessor,getCreateRequest(getTriggerGroupsRepoId(groupName),tgw.getValue().asMap())).getContent();
      tgw=new TriggerGroupWrapper(newValue);
      addTriggerGroupName(groupName);
    }
 else {
      tgw=new TriggerGroupWrapper(map);
    }
    return tgw;
  }
}"
13305,"/** 
 * Returns a audit log recon entry formatted based on the entryType (summary, start, recon entry).
 * @param entry the full entry to format
 * @return the formatted entry
 */
public static Map<String,Object> formatReconEntry(Map<String,Object> entry){
  Map<String,Object> formattedEntry=new LinkedHashMap<String,Object>();
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  if (""String_Node_Str"".equals(entry.get(""String_Node_Str""))) {
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  }
 else {
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  }
  return formattedEntry;
}","/** 
 * Returns a audit log recon entry formatted based on the entryType (summary, start, recon entry).
 * @param entry the full entry to format
 * @return the formatted entry
 */
public static Map<String,Object> formatReconEntry(Map<String,Object> entry){
  Map<String,Object> formattedEntry=new LinkedHashMap<String,Object>();
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  if (""String_Node_Str"".equals(entry.get(""String_Node_Str"")) || null == entry.get(""String_Node_Str"")) {
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  }
 else {
    formattedEntry.put(""String_Node_Str"",entry.get(""String_Node_Str""));
  }
  return formattedEntry;
}"
13306,"public static Map<String,Object> getReconResults(List<Map<String,Object>> entryList,String reconId,boolean formatted){
  Map<String,Object> results=new HashMap<String,Object>();
  List<Map<String,Object>> resultEntries=new ArrayList<Map<String,Object>>();
  if (formatted) {
    if (reconId != null) {
      for (      Map<String,Object> entry : entryList) {
        if (reconId.equals(entry.get(""String_Node_Str""))) {
          if (""String_Node_Str"".equals(entry.get(""String_Node_Str""))) {
            results.put(""String_Node_Str"",AuditServiceImpl.formatReconEntry(entry));
          }
 else           if (""String_Node_Str"".equals(entry.get(""String_Node_Str""))) {
            results.put(""String_Node_Str"",AuditServiceImpl.formatReconEntry(entry));
          }
 else {
            resultEntries.add(AuditServiceImpl.formatReconEntry(entry));
          }
        }
      }
    }
 else {
      for (      Map<String,Object> entry : entryList) {
        resultEntries.add(AuditServiceImpl.formatReconEntry(entry));
      }
    }
    if (resultEntries.size() > 0) {
      results.put(""String_Node_Str"",resultEntries);
    }
  }
 else {
    results.put(""String_Node_Str"",entryList);
  }
  return results;
}","public static Map<String,Object> getReconResults(List<Map<String,Object>> entryList,boolean formatted){
  Map<String,Object> results=new HashMap<String,Object>();
  if (formatted) {
    List<Map<String,Object>> resultEntries=new ArrayList<Map<String,Object>>();
    for (    Map<String,Object> entry : entryList) {
      resultEntries.add(AuditServiceImpl.formatReconEntry(entry));
    }
    if (resultEntries.size() > 0) {
      results.put(""String_Node_Str"",resultEntries);
    }
  }
 else {
    results.put(""String_Node_Str"",entryList);
  }
  return results;
}"
13307,"/** 
 * {@inheritDoc}
 */
@Override public Map<String,Object> query(ServerContext context,String fullId,Map<String,String> params) throws ResourceException {
  String queryId=params.get(""String_Node_Str"");
  boolean formatted=true;
  String[] split=AuditServiceImpl.splitFirstLevel(fullId);
  String type=split[0];
  try {
    if (params.get(""String_Node_Str"") != null && !AuditServiceImpl.getBoolValue(params.get(""String_Node_Str""))) {
      formatted=false;
    }
    List<Map<String,Object>> reconEntryList=getEntryList(type);
    if (reconEntryList == null) {
      throw new NotFoundException(type + ""String_Node_Str"");
    }
    String reconId=params.get(""String_Node_Str"");
    if (AuditServiceImpl.QUERY_BY_RECON_ID.equals(queryId) && type.equals(AuditServiceImpl.TYPE_RECON)) {
      return AuditServiceImpl.getReconResults(reconEntryList,reconId,formatted);
    }
 else     if (AuditServiceImpl.QUERY_BY_MAPPING.equals(queryId) && type.equals(AuditServiceImpl.TYPE_RECON)) {
      return getReconQueryResults(reconEntryList,reconId,""String_Node_Str"",params.get(""String_Node_Str""),formatted);
    }
 else     if (AuditServiceImpl.QUERY_BY_RECON_ID_AND_SITUATION.equals(queryId) && type.equals(AuditServiceImpl.TYPE_RECON)) {
      return getReconQueryResults(reconEntryList,reconId,""String_Node_Str"",params.get(""String_Node_Str""),formatted);
    }
 else     if (AuditServiceImpl.QUERY_BY_RECON_ID_AND_TYPE.equals(queryId) && type.equals(AuditServiceImpl.TYPE_RECON)) {
      return getReconQueryResults(reconEntryList,reconId,""String_Node_Str"",params.get(""String_Node_Str""),formatted);
    }
 else     if (AuditServiceImpl.QUERY_BY_ACTIVITY_PARENT_ACTION.equals(queryId) && type.equals(AuditServiceImpl.TYPE_ACTIVITY)) {
      String actionId=params.get(""String_Node_Str"");
      List<Map<String,Object>> rawEntryList=new ArrayList<Map<String,Object>>();
      for (      Map<String,Object> entry : reconEntryList) {
        if (entry.get(""String_Node_Str"").equals(actionId)) {
          rawEntryList.add(entry);
        }
      }
      return AuditServiceImpl.getActivityResults(rawEntryList,formatted);
    }
 else {
      throw new BadRequestException(""String_Node_Str"" + queryId + ""String_Node_Str""+ type);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new BadRequestException(e);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public Map<String,Object> query(ServerContext context,String fullId,Map<String,String> params) throws ResourceException {
  String queryId=params.get(""String_Node_Str"");
  boolean formatted=true;
  String[] split=AuditServiceImpl.splitFirstLevel(fullId);
  String type=split[0];
  try {
    if (params.get(""String_Node_Str"") != null && !AuditServiceImpl.getBoolValue(params.get(""String_Node_Str""))) {
      formatted=false;
    }
    List<Map<String,Object>> reconEntryList=getEntryList(type);
    if (reconEntryList == null) {
      throw new NotFoundException(type + ""String_Node_Str"");
    }
    String reconId=params.get(""String_Node_Str"");
    if (AuditServiceImpl.QUERY_BY_RECON_ID.equals(queryId) && type.equals(AuditServiceImpl.TYPE_RECON)) {
      return AuditServiceImpl.getReconResults(reconEntryList,formatted);
    }
 else     if (AuditServiceImpl.QUERY_BY_MAPPING.equals(queryId) && type.equals(AuditServiceImpl.TYPE_RECON)) {
      return getReconQueryResults(reconEntryList,reconId,""String_Node_Str"",params.get(""String_Node_Str""),formatted);
    }
 else     if (AuditServiceImpl.QUERY_BY_RECON_ID_AND_SITUATION.equals(queryId) && type.equals(AuditServiceImpl.TYPE_RECON)) {
      return getReconQueryResults(reconEntryList,reconId,""String_Node_Str"",params.get(""String_Node_Str""),formatted);
    }
 else     if (AuditServiceImpl.QUERY_BY_RECON_ID_AND_TYPE.equals(queryId) && type.equals(AuditServiceImpl.TYPE_RECON)) {
      return getReconQueryResults(reconEntryList,reconId,""String_Node_Str"",params.get(""String_Node_Str""),formatted);
    }
 else     if (AuditServiceImpl.QUERY_BY_ACTIVITY_PARENT_ACTION.equals(queryId) && type.equals(AuditServiceImpl.TYPE_ACTIVITY)) {
      String actionId=params.get(""String_Node_Str"");
      List<Map<String,Object>> rawEntryList=new ArrayList<Map<String,Object>>();
      for (      Map<String,Object> entry : reconEntryList) {
        if (entry.get(""String_Node_Str"").equals(actionId)) {
          rawEntryList.add(entry);
        }
      }
      return AuditServiceImpl.getActivityResults(rawEntryList,formatted);
    }
 else {
      throw new BadRequestException(""String_Node_Str"" + queryId + ""String_Node_Str""+ type);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new BadRequestException(e);
  }
}"
13308,"private Map<String,Object> getReconQueryResults(List<Map<String,Object>> list,String reconId,String param,String paramValue,boolean formatted){
  List<Map<String,Object>> rawEntryList=new ArrayList<Map<String,Object>>();
  for (  Map<String,Object> entry : list) {
    if ((reconId == null || (entry.get(""String_Node_Str"").equals(reconId))) && (param == null || paramValue.equals(entry.get(param)))) {
      rawEntryList.add(entry);
    }
  }
  return AuditServiceImpl.getReconResults(rawEntryList,reconId,formatted);
}","private Map<String,Object> getReconQueryResults(List<Map<String,Object>> list,String reconId,String param,String paramValue,boolean formatted){
  List<Map<String,Object>> rawEntryList=new ArrayList<Map<String,Object>>();
  for (  Map<String,Object> entry : list) {
    if ((reconId == null || (entry.get(""String_Node_Str"").equals(reconId))) && (param == null || paramValue.equals(entry.get(param)))) {
      rawEntryList.add(entry);
    }
  }
  return AuditServiceImpl.getReconResults(rawEntryList,formatted);
}"
13309,"/** 
 * {@inheritDoc}
 */
@Override public Map<String,Object> query(ServerContext context,String fullId,Map<String,String> params) throws ResourceException {
  String queryId=params.get(""String_Node_Str"");
  boolean formatted=true;
  String[] split=AuditServiceImpl.splitFirstLevel(fullId);
  String type=split[0];
  try {
    if (params.get(""String_Node_Str"") != null && !AuditServiceImpl.getBoolValue(params.get(""String_Node_Str""))) {
      formatted=false;
    }
    QueryRequest request=Requests.newQueryRequest(repoPrefix + fullId);
    request.setQueryId(queryId);
    request.getAdditionalQueryParameters().putAll(params);
    final List<Map<String,Object>> queryResults=new ArrayList<Map<String,Object>>();
    context.getConnection().query(context,request,new QueryResultHandler(){
      @Override public void handleError(      ResourceException error){
      }
      @Override public boolean handleResource(      Resource resource){
        queryResults.add(resource.getContent().asMap());
        return true;
      }
      @Override public void handleResult(      QueryResult result){
      }
    }
);
    if (type.equals(AuditServiceImpl.TYPE_RECON)) {
      return AuditServiceImpl.getReconResults(queryResults,params.get(""String_Node_Str""),formatted);
    }
 else     if (type.equals(AuditServiceImpl.TYPE_ACTIVITY)) {
      formatActivityList(queryResults);
      return AuditServiceImpl.getActivityResults(queryResults,formatted);
    }
 else     if (type.equals(AuditServiceImpl.TYPE_ACCESS)) {
      return AuditServiceImpl.getAccessResults(queryResults,formatted);
    }
 else {
      throw new BadRequestException(""String_Node_Str"" + queryId + ""String_Node_Str""+ type);
    }
  }
 catch (  Exception e) {
    throw new BadRequestException(e);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public Map<String,Object> query(ServerContext context,String fullId,Map<String,String> params) throws ResourceException {
  String queryId=params.get(""String_Node_Str"");
  boolean formatted=true;
  String[] split=AuditServiceImpl.splitFirstLevel(fullId);
  String type=split[0];
  try {
    if (params.get(""String_Node_Str"") != null && !AuditServiceImpl.getBoolValue(params.get(""String_Node_Str""))) {
      formatted=false;
    }
    QueryRequest request=Requests.newQueryRequest(repoPrefix + fullId);
    request.setQueryId(queryId);
    request.getAdditionalQueryParameters().putAll(params);
    final List<Map<String,Object>> queryResults=new ArrayList<Map<String,Object>>();
    context.getConnection().query(context,request,new QueryResultHandler(){
      @Override public void handleError(      ResourceException error){
      }
      @Override public boolean handleResource(      Resource resource){
        queryResults.add(resource.getContent().asMap());
        return true;
      }
      @Override public void handleResult(      QueryResult result){
      }
    }
);
    if (type.equals(AuditServiceImpl.TYPE_RECON)) {
      return AuditServiceImpl.getReconResults(queryResults,formatted);
    }
 else     if (type.equals(AuditServiceImpl.TYPE_ACTIVITY)) {
      formatActivityList(queryResults);
      return AuditServiceImpl.getActivityResults(queryResults,formatted);
    }
 else     if (type.equals(AuditServiceImpl.TYPE_ACCESS)) {
      return AuditServiceImpl.getAccessResults(queryResults,formatted);
    }
 else {
      throw new BadRequestException(""String_Node_Str"" + queryId + ""String_Node_Str""+ type);
    }
  }
 catch (  Exception e) {
    throw new BadRequestException(e);
  }
}"
13310,"/** 
 * {@inheritDoc}
 */
@Override public Map<String,Object> query(ServerContext context,String fullId,Map<String,String> params) throws ResourceException {
  final String[] split=AuditServiceImpl.splitFirstLevel(fullId);
  final String type=split[0];
  try {
    boolean formatted=true;
    if (params.get(""String_Node_Str"") != null && !AuditServiceImpl.getBoolValue(params.get(""String_Node_Str""))) {
      formatted=false;
    }
    QueryRequest request=Requests.newQueryRequest(location + ""String_Node_Str"" + type);
    request.setQueryId(params.get(""String_Node_Str""));
    request.getAdditionalQueryParameters().putAll(params);
    final List<Map<String,Object>> queryResults=new ArrayList<Map<String,Object>>();
    routerContext.getConnection().query(context,request,new QueryResultHandler(){
      @Override public void handleError(      ResourceException error){
      }
      @Override public boolean handleResource(      Resource resource){
        queryResults.add(resource.getContent().asMap());
        return true;
      }
      @Override public void handleResult(      QueryResult result){
      }
    }
);
    if (AuditServiceImpl.TYPE_RECON.equals(type)) {
      return AuditServiceImpl.getReconResults(queryResults,params.get(""String_Node_Str""),formatted);
    }
 else     if (AuditServiceImpl.TYPE_ACTIVITY.equals(type)) {
      return AuditServiceImpl.getActivityResults(unflattenActivityList(queryResults),formatted);
    }
 else     if (AuditServiceImpl.TYPE_ACCESS.equals(type)) {
      return AuditServiceImpl.getAccessResults(queryResults,formatted);
    }
 else {
      String queryId=params.get(""String_Node_Str"");
      throw new BadRequestException(""String_Node_Str"" + queryId + ""String_Node_Str""+ type);
    }
  }
 catch (  Exception e) {
    throw new BadRequestException(e);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public Map<String,Object> query(ServerContext context,String fullId,Map<String,String> params) throws ResourceException {
  final String[] split=AuditServiceImpl.splitFirstLevel(fullId);
  final String type=split[0];
  try {
    boolean formatted=true;
    if (params.get(""String_Node_Str"") != null && !AuditServiceImpl.getBoolValue(params.get(""String_Node_Str""))) {
      formatted=false;
    }
    QueryRequest request=Requests.newQueryRequest(location + ""String_Node_Str"" + type);
    request.setQueryId(params.get(""String_Node_Str""));
    request.getAdditionalQueryParameters().putAll(params);
    final List<Map<String,Object>> queryResults=new ArrayList<Map<String,Object>>();
    routerContext.getConnection().query(context,request,new QueryResultHandler(){
      @Override public void handleError(      ResourceException error){
      }
      @Override public boolean handleResource(      Resource resource){
        queryResults.add(resource.getContent().asMap());
        return true;
      }
      @Override public void handleResult(      QueryResult result){
      }
    }
);
    if (AuditServiceImpl.TYPE_RECON.equals(type)) {
      return AuditServiceImpl.getReconResults(queryResults,formatted);
    }
 else     if (AuditServiceImpl.TYPE_ACTIVITY.equals(type)) {
      return AuditServiceImpl.getActivityResults(unflattenActivityList(queryResults),formatted);
    }
 else     if (AuditServiceImpl.TYPE_ACCESS.equals(type)) {
      return AuditServiceImpl.getAccessResults(queryResults,formatted);
    }
 else {
      String queryId=params.get(""String_Node_Str"");
      throw new BadRequestException(""String_Node_Str"" + queryId + ""String_Node_Str""+ type);
    }
  }
 catch (  Exception e) {
    throw new BadRequestException(e);
  }
}"
13311,"/** 
 * Convert from JSON object structures (akin to simple binding), composed of the basic Java types:   {@link Map},   {@link List},   {@link String},  {@link Number},   {@link Boolean}. to OrientDB document
 * @param id
 * @param revision
 * @param content the JSON object structure to convert
 * @param docToPopulate an optional existing ODocument to update with new values from {@code objModel}
 * @return the converted orientdb document, or null if objModel was null
 * @throws ConflictException when the revision in the Object model is invalid
 */
public static ODocument toDocument(final String id,final String revision,final JsonValue content,final ODocument docToPopulate) throws ResourceException {
  if (null == docToPopulate) {
    return null;
  }
  try {
    if (null != content) {
      for (      String name : content.keys()) {
        if (isSpecialAttribute(name) || name.startsWith(""String_Node_Str"")) {
          content.remove(name);
        }
      }
    }
    if (null != content && content.size() > 0) {
      docToPopulate.fromJSON(JsonUtil.writeValueAsString(content));
    }
 else {
      for (      String iFieldName : docToPopulate.fieldNames()) {
        docToPopulate.removeField(iFieldName);
      }
    }
    if (StringUtils.isNotBlank(id)) {
      if (!docToPopulate.containsField(ORIENTDB_PRIMARY_KEY) || !docToPopulate.field(ORIENTDB_PRIMARY_KEY).equals(id)) {
        logger.trace(""String_Node_Str"",id);
        docToPopulate.field(ORIENTDB_PRIMARY_KEY,id);
      }
    }
    if (StringUtils.isNotBlank(revision) && !""String_Node_Str"".equalsIgnoreCase(revision)) {
      int rev=parseVersion(revision);
      logger.trace(""String_Node_Str"",rev);
      if (docToPopulate.getVersion() != rev) {
        docToPopulate.setVersion(rev);
      }
    }
    return docToPopulate;
  }
 catch (  JsonProcessingException e) {
    throw new BadRequestException(""String_Node_Str"",e);
  }
}","/** 
 * Convert from JSON object structures (akin to simple binding), composed of the basic Java types:   {@link Map},   {@link List},   {@link String},  {@link Number},   {@link Boolean}. to OrientDB document
 * @param id
 * @param revision
 * @param content the JSON object structure to convert
 * @param docToPopulate an optional existing ODocument to update with new values from {@code objModel}
 * @return the converted orientdb document, or null if objModel was null
 * @throws ConflictException when the revision in the Object model is invalid
 */
public static ODocument toDocument(final String id,final String revision,final JsonValue content,final ODocument docToPopulate) throws ResourceException {
  if (null == docToPopulate) {
    return null;
  }
  try {
    if (null != content) {
      for (      String name : content.keys()) {
        if (isSpecialAttribute(name) || name.startsWith(""String_Node_Str"")) {
          content.remove(name);
        }
      }
    }
    String tmpId=id;
    if (null == tmpId) {
      tmpId=docToPopulate.field(ORIENTDB_PRIMARY_KEY);
    }
    if (null != content && content.size() > 0) {
      docToPopulate.fromJSON(JsonUtil.writeValueAsString(content));
    }
 else {
      for (      String iFieldName : docToPopulate.fieldNames()) {
        docToPopulate.removeField(iFieldName);
      }
    }
    if (StringUtils.isNotBlank(tmpId)) {
      if (!docToPopulate.containsField(ORIENTDB_PRIMARY_KEY) || !docToPopulate.field(ORIENTDB_PRIMARY_KEY).equals(id)) {
        logger.trace(""String_Node_Str"",tmpId);
        docToPopulate.field(ORIENTDB_PRIMARY_KEY,tmpId);
      }
    }
    if (StringUtils.isNotBlank(revision) && !""String_Node_Str"".equalsIgnoreCase(revision)) {
      int rev=parseVersion(revision);
      logger.trace(""String_Node_Str"",rev);
      if (docToPopulate.getVersion() != rev) {
        docToPopulate.setVersion(rev);
      }
    }
    return docToPopulate;
  }
 catch (  JsonProcessingException e) {
    throw new BadRequestException(""String_Node_Str"",e);
  }
}"
13312,"@Deactivate void deactivate(ComponentContext compContext){
  logger.debug(""String_Node_Str"",compContext);
  clusterManagerThread.shutdown();
synchronized (repoLock) {
    try {
      InstanceState state=getInstanceState(instanceId);
      state.updateShutdown();
      state.setState(InstanceState.STATE_DOWN);
      updateInstanceState(instanceId,state);
    }
 catch (    JsonResourceException e) {
      logger.warn(""String_Node_Str"",e);
    }
  }
}","@Deactivate void deactivate(ComponentContext compContext){
  logger.debug(""String_Node_Str"",compContext);
  if (clusterConfig.isEnabled()) {
    clusterManagerThread.shutdown();
synchronized (repoLock) {
      try {
        InstanceState state=getInstanceState(instanceId);
        state.updateShutdown();
        state.setState(InstanceState.STATE_DOWN);
        updateInstanceState(instanceId,state);
      }
 catch (      JsonResourceException e) {
        logger.warn(""String_Node_Str"",e);
      }
    }
  }
}"
13313,"@Override public void addedService(ServiceReference reference,Object service){
  ClusterManagementService clusterService=(ClusterManagementService)service;
  if (clusterService != null) {
    clusterService.register(LISTENER_ID,this);
    cluster=clusterService;
  }
}","@Override public void addedService(ServiceReference reference,Object service){
  ClusterManagementService clusterService=(ClusterManagementService)service;
  if (clusterService != null) {
    clusterService.register(LISTENER_ID,this);
    clusterEnabled=clusterService.isEnabled();
    cluster=clusterService;
  }
}"
13314,"/** 
 * Check and update the application state
 */
private void checkState(){
  Bundle[] bundles=context.getBundleContext().getBundles();
  List<String> bundleFailures=new ArrayList<String>();
  List<String> fragmentFailures=new ArrayList<String>();
  for (  Bundle bundle : bundles) {
    if (requiredBundles.contains(bundle.getSymbolicName())) {
      if (isFragment(bundle)) {
        if (bundle.getState() != Bundle.RESOLVED) {
          fragmentFailures.add(bundle.getSymbolicName());
        }
      }
 else {
        if (bundle.getState() != Bundle.ACTIVE) {
          bundleFailures.add(bundle.getSymbolicName());
        }
      }
    }
  }
  ServiceReference[] refs=null;
  try {
    refs=context.getBundleContext().getAllServiceReferences(null,null);
  }
 catch (  InvalidSyntaxException e) {
    logger.debug(""String_Node_Str"",e);
  }
  Map<String,ServiceReference> pidToRef=new HashMap<String,ServiceReference>();
  for (  ServiceReference ref : refs) {
    String pid=(String)ref.getProperty(Constants.SERVICE_PID);
    if (pid != null) {
      pidToRef.put(pid,ref);
    }
  }
  List<String> missingServices=new ArrayList<String>();
  for (  String req : requiredServices) {
    if (!pidToRef.containsKey(req)) {
      missingServices.add(req);
    }
  }
  AppState updatedAppState=null;
  String updatedShortDesc=null;
  if (bundleFailures.size() > 0 || fragmentFailures.size() > 0) {
    updatedAppState=AppState.ACTIVE_NOT_READY;
    updatedShortDesc=""String_Node_Str"" + bundleFailures + ""String_Node_Str""+ fragmentFailures;
  }
 else   if (missingServices.size() > 0) {
    updatedAppState=AppState.ACTIVE_NOT_READY;
    updatedShortDesc=""String_Node_Str"" + missingServices;
  }
 else   if (!clusterUp) {
    if (cluster != null && !cluster.isStarted()) {
      cluster.startClusterManagement();
    }
    updatedAppState=AppState.ACTIVE_NOT_READY;
    updatedShortDesc=""String_Node_Str"";
  }
 else {
    updatedAppState=AppState.ACTIVE_READY;
    updatedShortDesc=""String_Node_Str"";
  }
  setState(updatedAppState,updatedShortDesc);
}","/** 
 * Check and update the application state
 */
private void checkState(){
  Bundle[] bundles=context.getBundleContext().getBundles();
  List<String> bundleFailures=new ArrayList<String>();
  List<String> fragmentFailures=new ArrayList<String>();
  for (  Bundle bundle : bundles) {
    if (requiredBundles.contains(bundle.getSymbolicName())) {
      if (isFragment(bundle)) {
        if (bundle.getState() != Bundle.RESOLVED) {
          fragmentFailures.add(bundle.getSymbolicName());
        }
      }
 else {
        if (bundle.getState() != Bundle.ACTIVE) {
          bundleFailures.add(bundle.getSymbolicName());
        }
      }
    }
  }
  ServiceReference[] refs=null;
  try {
    refs=context.getBundleContext().getAllServiceReferences(null,null);
  }
 catch (  InvalidSyntaxException e) {
    logger.debug(""String_Node_Str"",e);
  }
  Map<String,ServiceReference> pidToRef=new HashMap<String,ServiceReference>();
  for (  ServiceReference ref : refs) {
    String pid=(String)ref.getProperty(Constants.SERVICE_PID);
    if (pid != null) {
      pidToRef.put(pid,ref);
    }
  }
  List<String> missingServices=new ArrayList<String>();
  for (  String req : requiredServices) {
    if (!pidToRef.containsKey(req)) {
      missingServices.add(req);
    }
  }
  AppState updatedAppState=null;
  String updatedShortDesc=null;
  if (bundleFailures.size() > 0 || fragmentFailures.size() > 0) {
    updatedAppState=AppState.ACTIVE_NOT_READY;
    updatedShortDesc=""String_Node_Str"" + bundleFailures + ""String_Node_Str""+ fragmentFailures;
  }
 else   if (missingServices.size() > 0) {
    updatedAppState=AppState.ACTIVE_NOT_READY;
    updatedShortDesc=""String_Node_Str"" + missingServices;
  }
 else   if (clusterEnabled && !clusterUp) {
    if (cluster != null && !cluster.isStarted()) {
      cluster.startClusterManagement();
    }
    updatedAppState=AppState.ACTIVE_NOT_READY;
    updatedShortDesc=""String_Node_Str"";
  }
 else {
    updatedAppState=AppState.ACTIVE_READY;
    updatedShortDesc=""String_Node_Str"";
  }
  setState(updatedAppState,updatedShortDesc);
}"
13315,"/** 
 * Creates a map representing an instance's state and recovery statistics that can be used for  responses to read requests.
 * @param instanceValue an instances state object
 * @return a map representing an instance's state and recovery statistics
 */
private Map<String,Object> getInstanceMap(JsonValue instanceValue){
  DateUtil dateUtil=DateUtil.getDateUtil();
  Map<String,Object> instanceInfo=new HashMap<String,Object>();
  String instanceId=instanceValue.get(""String_Node_Str"").asString();
  InstanceState state=new InstanceState(instanceId,instanceValue.asMap());
  instanceInfo.put(""String_Node_Str"",instanceId);
  instanceInfo.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getStartup())));
  instanceInfo.put(""String_Node_Str"",""String_Node_Str"");
  Map<String,Object> recoveryMap=new HashMap<String,Object>();
switch (state.getState()) {
case InstanceState.STATE_RUNNING:
    instanceInfo.put(""String_Node_Str"",""String_Node_Str"");
  break;
case InstanceState.STATE_DOWN:
instanceInfo.put(""String_Node_Str"",""String_Node_Str"");
if (!state.hasShutdown() && state.getRecoveryAttempts() > 0) {
recoveryMap.put(""String_Node_Str"",state.getRecoveringInstanceId());
recoveryMap.put(""String_Node_Str"",state.getRecoveryAttempts());
recoveryMap.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getRecoveryStarted())));
recoveryMap.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getRecoveryFinished())));
recoveryMap.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getDetectedDown())));
instanceInfo.put(""String_Node_Str"",recoveryMap);
}
 else if (state.getRecoveryAttempts() > 0) {
instanceInfo.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getShutdown())));
}
break;
case InstanceState.STATE_PROCESSING_DOWN:
recoveryMap.put(""String_Node_Str"",""String_Node_Str"");
recoveryMap.put(""String_Node_Str"",state.getRecoveryAttempts());
recoveryMap.put(""String_Node_Str"",state.getRecoveringInstanceId());
recoveryMap.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getRecoveryStarted())));
recoveryMap.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getDetectedDown())));
instanceInfo.put(""String_Node_Str"",recoveryMap);
}
return instanceInfo;
}","/** 
 * Creates a map representing an instance's state and recovery statistics that can be used for  responses to read requests.
 * @param instanceValue an instances state object
 * @return a map representing an instance's state and recovery statistics
 */
private Map<String,Object> getInstanceMap(JsonValue instanceValue){
  DateUtil dateUtil=DateUtil.getDateUtil();
  Map<String,Object> instanceInfo=new HashMap<String,Object>();
  String instanceId=instanceValue.get(""String_Node_Str"").asString();
  InstanceState state=new InstanceState(instanceId,instanceValue.asMap());
  instanceInfo.put(""String_Node_Str"",instanceId);
  instanceInfo.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getStartup())));
  instanceInfo.put(""String_Node_Str"",""String_Node_Str"");
  Map<String,Object> recoveryMap=new HashMap<String,Object>();
switch (state.getState()) {
case InstanceState.STATE_RUNNING:
    instanceInfo.put(""String_Node_Str"",""String_Node_Str"");
  break;
case InstanceState.STATE_DOWN:
instanceInfo.put(""String_Node_Str"",""String_Node_Str"");
if (!state.hasShutdown()) {
if (state.getRecoveryAttempts() > 0) {
  recoveryMap.put(""String_Node_Str"",state.getRecoveringInstanceId());
  recoveryMap.put(""String_Node_Str"",state.getRecoveryAttempts());
  recoveryMap.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getRecoveryStarted())));
  recoveryMap.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getRecoveryFinished())));
  recoveryMap.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getDetectedDown())));
  instanceInfo.put(""String_Node_Str"",recoveryMap);
}
 else {
  logger.error(""String_Node_Str"",instanceId);
}
}
 else {
instanceInfo.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getShutdown())));
}
break;
case InstanceState.STATE_PROCESSING_DOWN:
recoveryMap.put(""String_Node_Str"",""String_Node_Str"");
recoveryMap.put(""String_Node_Str"",state.getRecoveryAttempts());
recoveryMap.put(""String_Node_Str"",state.getRecoveringInstanceId());
recoveryMap.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getRecoveryStarted())));
recoveryMap.put(""String_Node_Str"",dateUtil.formatDateTime(new Date(state.getDetectedDown())));
instanceInfo.put(""String_Node_Str"",recoveryMap);
}
return instanceInfo;
}"
13316,"/** 
 * Gets a Jetty configuration property. If obfuscated is true, it will return a value obfuscated in Jetty format.
 * @param propName  name of the property.
 * @param obfuscated if value should be obfuscated.
 * @return the property value.
 */
public static String getProperty(String propName,boolean obfuscated){
  String prop=IdentityServer.getInstance().getProperty(propName);
  if (obfuscated && prop != null) {
    try {
      String clear=new String(Main.unfold(prop));
      prop=Main.obfuscate(prop);
    }
 catch (    GeneralSecurityException ex) {
      throw new RuntimeException(""String_Node_Str"" + propName + ""String_Node_Str"",ex);
    }
  }
  return prop;
}","/** 
 * Gets a Jetty configuration property. If obfuscated is true, it will return a value obfuscated in Jetty format.
 * @param propName  name of the property.
 * @param obfuscated if value should be obfuscated.
 * @return the property value.
 */
public static String getProperty(String propName,boolean obfuscated){
  String prop=IdentityServer.getInstance().getProperty(propName);
  if (prop == null) {
    return null;
  }
  try {
    String clear=new String(Main.unfold(prop));
    if (obfuscated) {
      prop=Main.obfuscate(clear);
    }
 else {
      prop=clear;
    }
  }
 catch (  GeneralSecurityException ex) {
    throw new RuntimeException(""String_Node_Str"" + propName + ""String_Node_Str"",ex);
  }
  return prop;
}"
13317,"public static Object substVars(String val,final PropertyAccessor propertyAccessor,Delimiter delimiter,boolean doEscape){
  int stopDelim=-1;
  int startDelim=-1;
  if (!doEscape) {
    stopDelim=val.indexOf(DELIM_STOP,stopDelim + 1);
    if (stopDelim < 0) {
      return val;
    }
    startDelim=val.indexOf(delimiter.getStartString());
    if (startDelim < 0) {
      return val;
    }
  }
  StringBuilder parentBuilder=new StringBuilder(val.length());
  Stack<StringBuilder> propertyStack=new Stack<StringBuilder>();
  propertyStack.push(parentBuilder);
  for (int index=0; index < val.length(); index++) {
switch (val.charAt(index)) {
case '\\':
{
        if (doEscape) {
          index++;
          if (index < val.length()) {
            propertyStack.peek().append(val.charAt(index));
          }
        }
 else {
          propertyStack.peek().append(val.charAt(index));
        }
        break;
      }
case '&':
{
      if ('{' == val.charAt(index + 1) && val.charAt(index) == delimiter.getStartChar()) {
        propertyStack.push(new StringBuilder(val.length()));
        index++;
      }
 else {
        propertyStack.peek().append(val.charAt(index));
      }
      break;
    }
case '$':
{
    if ('{' == val.charAt(index + 1) && val.charAt(index) == delimiter.getStartChar()) {
      propertyStack.push(new StringBuilder(val.length()));
      index++;
    }
 else {
      propertyStack.peek().append(val.charAt(index));
    }
    break;
  }
case DELIM_STOP:
{
  if (propertyStack.size() == 1) {
    propertyStack.peek().append(val.charAt(index));
  }
 else {
    String variable=propertyStack.pop().toString();
    if ((index == val.length() - 1) && propertyStack.size() == 1 && parentBuilder.length() == 0) {
      Object substValue=getSubstituteValue(Object.class,variable,propertyAccessor);
      if (null != substValue) {
        return substValue;
      }
 else {
        propertyStack.peek().append(delimiter.getStartChar()).append(variable).append(DELIM_STOP);
        return propertyStack.peek().toString();
      }
    }
 else {
      String substValue=getSubstituteValue(String.class,variable,propertyAccessor);
      if (null != substValue) {
        propertyStack.peek().append(substValue);
      }
 else {
        propertyStack.peek().append(delimiter.getStartChar()).append(variable).append(DELIM_STOP);
      }
    }
  }
  break;
}
default :
{
propertyStack.peek().append(val.charAt(index));
}
}
}
for (int index=propertyStack.size(); index > 1; index--) {
StringBuilder top=propertyStack.pop();
propertyStack.peek().append(delimiter.getStartString()).append(top.toString());
}
return parentBuilder.toString();
}","public static Object substVars(String val,final PropertyAccessor propertyAccessor,Delimiter delimiter,boolean doEscape){
  int stopDelim=-1;
  int startDelim=-1;
  if (!doEscape) {
    stopDelim=val.indexOf(DELIM_STOP,stopDelim + 1);
    if (stopDelim < 0) {
      return val;
    }
    startDelim=val.indexOf(delimiter.getStartString());
    if (startDelim < 0) {
      return val;
    }
  }
  StringBuilder parentBuilder=new StringBuilder(val.length());
  Stack<StringBuilder> propertyStack=new Stack<StringBuilder>();
  propertyStack.push(parentBuilder);
  for (int index=0; index < val.length(); index++) {
switch (val.charAt(index)) {
case '\\':
{
        if (doEscape) {
          index++;
          if (index < val.length()) {
            propertyStack.peek().append(val.charAt(index));
          }
        }
 else {
          propertyStack.peek().append(val.charAt(index));
        }
        break;
      }
case '&':
{
      if ('{' == val.charAt(index + 1) && val.charAt(index) == delimiter.getStartChar()) {
        propertyStack.push(new StringBuilder(val.length()));
        index++;
      }
 else {
        propertyStack.peek().append(val.charAt(index));
      }
      break;
    }
case '$':
{
    if ('{' == val.charAt(index + 1) && val.charAt(index) == delimiter.getStartChar()) {
      propertyStack.push(new StringBuilder(val.length()));
      index++;
    }
 else {
      propertyStack.peek().append(val.charAt(index));
    }
    break;
  }
case DELIM_STOP:
{
  if (propertyStack.size() == 1) {
    propertyStack.peek().append(val.charAt(index));
  }
 else {
    String variable=propertyStack.pop().toString();
    if ((index == val.length() - 1) && propertyStack.size() == 1 && parentBuilder.length() == 0) {
      Object substValue=getSubstituteValue(Object.class,variable,propertyAccessor);
      if (null != substValue) {
        return substValue;
      }
 else {
        propertyStack.peek().append(delimiter.getStartString()).append(variable).append(DELIM_STOP);
        return propertyStack.peek().toString();
      }
    }
 else {
      String substValue=getSubstituteValue(String.class,variable,propertyAccessor);
      if (null != substValue) {
        propertyStack.peek().append(substValue);
      }
 else {
        propertyStack.peek().append(delimiter.getStartString()).append(variable).append(DELIM_STOP);
      }
    }
  }
  break;
}
default :
{
propertyStack.peek().append(val.charAt(index));
}
}
}
for (int index=propertyStack.size(); index > 1; index--) {
StringBuilder top=propertyStack.pop();
propertyStack.peek().append(delimiter.getStartString()).append(top.toString());
}
return parentBuilder.toString();
}"
13318,"@Override public Map<String,Object> read(String id) throws ObjectSetException {
  Map<String,Object> resultMap=null;
  try {
    Scheduler scheduler=null;
    JobDetail job=null;
    boolean persisted=false;
    if (jobExists(id,true)) {
      persisted=true;
      scheduler=persistentScheduler;
    }
 else     if (jobExists(id,false)) {
      scheduler=inMemoryScheduler;
    }
 else {
      throw new ObjectSetException(ObjectSetException.NOT_FOUND,""String_Node_Str"");
    }
    job=scheduler.getJobDetail(id,GROUP_NAME);
    CronTrigger trigger=(CronTrigger)scheduler.getTrigger(""String_Node_Str"" + id,GROUP_NAME);
    JobDataMap dataMap=job.getJobDataMap();
    if (trigger == null) {
      ScheduleConfig config=new ScheduleConfig(parseStringified((String)dataMap.get(CONFIG)));
      trigger=createTrigger(config,job.getName());
    }
    ScheduleConfig config=new ScheduleConfig(trigger,dataMap,persisted,job.isStateful());
    resultMap=(Map<String,Object>)config.getConfig().getObject();
    resultMap.put(""String_Node_Str"",id);
  }
 catch (  SchedulerException e) {
    e.printStackTrace();
    throw new ObjectSetException(ObjectSetException.INTERNAL_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  return resultMap;
}","@Override public Map<String,Object> read(String id) throws ObjectSetException {
  Map<String,Object> resultMap=null;
  try {
    Scheduler scheduler=null;
    JobDetail job=null;
    if (jobExists(id,true)) {
      scheduler=persistentScheduler;
    }
 else     if (jobExists(id,false)) {
      scheduler=inMemoryScheduler;
    }
 else {
      throw new ObjectSetException(ObjectSetException.NOT_FOUND,""String_Node_Str"");
    }
    job=scheduler.getJobDetail(id,GROUP_NAME);
    JobDataMap dataMap=job.getJobDataMap();
    ScheduleConfig config=new ScheduleConfig(parseStringified((String)dataMap.get(CONFIG)));
    resultMap=(Map<String,Object>)config.getConfig().getObject();
    resultMap.put(""String_Node_Str"",id);
  }
 catch (  SchedulerException e) {
    e.printStackTrace();
    throw new ObjectSetException(ObjectSetException.INTERNAL_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  return resultMap;
}"
13319,"@Override public void patch(String id,String rev,Patch patch) throws ObjectSetException {
  boolean forceUpdate=(rev == null);
  boolean retry=forceUpdate;
  String _rev=rev;
  do {
    LOGGER.debug(""String_Node_Str"",name,id);
    idRequired(id);
    noSubObjects(id);
    JsonValue oldValue=new JsonValue(service.getRouter().read(repoId(id)));
    JsonValue decrypted=decrypt(oldValue);
    if (rev == null) {
      _rev=decrypted.get(""String_Node_Str"").asString();
    }
    JsonValue newValue=decrypted.copy();
    patch.apply(newValue.asMap());
    JsonValue params=new JsonValue(new HashMap<String,Object>());
    params.add(""String_Node_Str"",""String_Node_Str"");
    params.add(""String_Node_Str"",newValue);
    if (enforcePolicies) {
      JsonValue result=new JsonValue(service.getRouter().action(""String_Node_Str"" + managedId(id),params.asMap()));
      if (!result.isNull() && !result.get(""String_Node_Str"").asBoolean()) {
        LOGGER.debug(""String_Node_Str"",result);
        throw new ForbiddenException(""String_Node_Str"",result.asMap());
      }
    }
    try {
      update(id,_rev,decrypted,newValue);
      retry=false;
      logActivity(id,""String_Node_Str"" + patch,oldValue,newValue);
    }
 catch (    ConflictException e) {
      if (forceUpdate) {
        LOGGER.debug(""String_Node_Str"");
      }
 else {
        throw e;
      }
    }
  }
 while (retry);
}","@Override public void patch(String id,String rev,Patch patch) throws ObjectSetException {
  boolean forceUpdate=(rev == null);
  boolean retry=forceUpdate;
  String _rev=rev;
  do {
    LOGGER.debug(""String_Node_Str"",name,id);
    idRequired(id);
    noSubObjects(id);
    JsonValue oldValue=new JsonValue(service.getRouter().read(repoId(id)));
    JsonValue decrypted=decrypt(oldValue);
    if (rev == null) {
      _rev=decrypted.get(""String_Node_Str"").asString();
    }
    JsonValue newValue=decrypted.copy();
    patch.apply(newValue.asMap());
    JsonValue params=new JsonValue(new HashMap<String,Object>());
    params.add(""String_Node_Str"",""String_Node_Str"");
    params.add(""String_Node_Str"",newValue);
    if (isPublicContext()) {
      ObjectSetContext.get().add(""String_Node_Str"",true);
    }
    if (enforcePolicies) {
      JsonValue result=new JsonValue(service.getRouter().action(""String_Node_Str"" + managedId(id),params.asMap()));
      if (!result.isNull() && !result.get(""String_Node_Str"").asBoolean()) {
        LOGGER.debug(""String_Node_Str"",result);
        throw new ForbiddenException(""String_Node_Str"",result.asMap());
      }
    }
    try {
      update(id,_rev,decrypted,newValue);
      retry=false;
      logActivity(id,""String_Node_Str"" + patch,oldValue,newValue);
    }
 catch (    ConflictException e) {
      if (forceUpdate) {
        LOGGER.debug(""String_Node_Str"");
      }
 else {
        throw e;
      }
    }
  }
 while (retry);
}"
13320,"public JsonValue handle(JsonValue request) throws JsonResourceException {
  Map<String,Object> scope=Utils.deepCopy(parameters.asMap());
  ObjectSetContext.push(request);
  try {
    scope.putAll(scopeFactory.newInstance(ObjectSetContext.get()));
    scope.put(""String_Node_Str"",request.getObject());
    return new JsonValue(script.exec(scope));
  }
 catch (  ScriptThrownException ste) {
    throw ste.toJsonResourceException(null);
  }
catch (  ScriptException se) {
    throw se.toJsonResourceException(""String_Node_Str"" + se.getMessage());
  }
 finally {
    ObjectSetContext.pop();
  }
}","public JsonValue handle(JsonValue request) throws JsonResourceException {
  Map<String,Object> scope=Utils.deepCopy(parameters.asMap());
  JsonValue params=request.get(""String_Node_Str"");
  JsonValue caller=params.get(""String_Node_Str"");
  JsonValue parent=request.get(""String_Node_Str"");
  if (parent.get(""String_Node_Str"").isNull()) {
    boolean isHttp=false;
    if (!caller.isNull() && caller.asString().equals(""String_Node_Str"")) {
      parent=parent.get(""String_Node_Str"");
    }
    if (!parent.isNull() && !parent.get(""String_Node_Str"").isNull()) {
      isHttp=parent.get(""String_Node_Str"").asString().equals(""String_Node_Str"");
    }
    request.add(""String_Node_Str"",isHttp);
  }
 else {
    request.add(""String_Node_Str"",parent.get(""String_Node_Str"").asBoolean());
  }
  ObjectSetContext.push(request);
  try {
    scope.putAll(scopeFactory.newInstance(ObjectSetContext.get()));
    scope.put(""String_Node_Str"",request.getObject());
    return new JsonValue(script.exec(scope));
  }
 catch (  ScriptThrownException ste) {
    throw ste.toJsonResourceException(null);
  }
catch (  ScriptException se) {
    throw se.toJsonResourceException(""String_Node_Str"" + se.getMessage());
  }
 finally {
    ObjectSetContext.pop();
  }
}"
13321,"/** 
 * Get the   {@link org.apache.felix.service.command.CommandProcessor#COMMAND_SCOPE} value.<p/> TODO add description
 * @return
 */
public String getScope();","/** 
 * Get the   {@link org.apache.felix.service.command.CommandProcessor#COMMAND_SCOPE} value.<p/> TODO add description
 * @return
 */
public abstract String getScope();"
13322,"/** 
 * Get the   {@link org.apache.felix.service.command.CommandProcessor#COMMAND_FUNCTION} value.<p/> TODO add description
 * @return retrun a new map where the key is the command name and the value is the description.
 */
public Map<String,String> getFunctionMap();","/** 
 * Get the   {@link org.apache.felix.service.command.CommandProcessor#COMMAND_FUNCTION} value.<p/> TODO add description
 * @return retrun a new map where the key is the command name and the value is the description.
 */
public abstract Map<String,String> getFunctionMap();"
13323,"/** 
 * Coerce the   {@code source} object to an object of {@code clazz} type.<p/>
 * @param < T >
 * @param source
 * @param clazz
 * @return
 * @throws NumberFormatException
 * @throws URISyntaxException
 * @throws UnsupportedOperationException
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T coercedTypeCasting(Object source,Class<T> clazz) throws IllegalArgumentException {
  if (null == clazz) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (source instanceof JsonValue) {
    source=((JsonValue)source).getObject();
  }
  Class<T> targetClazz=clazz;
  Class sourceClass=(source == null ? null : source.getClass());
  boolean coerced=false;
  T result=null;
  try {
    if (source == null) {
      return null;
    }
    if (targetClazz.equals(Object.class)) {
      if ((Number.class.isAssignableFrom(sourceClass)) || (int.class == clazz) || (double.class == clazz)|| (float.class == clazz)|| (long.class == clazz)) {
        return (T)source;
      }
 else       if ((Boolean.class.isAssignableFrom(sourceClass)) || (boolean.class == clazz)) {
        return (T)source;
      }
 else       if (String.class.isAssignableFrom(sourceClass)) {
        return (T)source;
      }
 else       if (Map.class.isAssignableFrom(sourceClass)) {
        return (T)source;
      }
 else       if (List.class.isAssignableFrom(sourceClass)) {
        return (T)source;
      }
 else       if (sourceClass == QualifiedUid.class) {
        Map<String,Object> v=new HashMap<String,Object>(2);
        v.put(""String_Node_Str"",((QualifiedUid)source).getUid().getUidValue());
        v.put(""String_Node_Str"",((QualifiedUid)source).getObjectClass().getObjectClassValue());
        return (T)v;
      }
 else       if (sourceClass == Script.class) {
        Map<String,Object> v=new HashMap<String,Object>(2);
        v.put(""String_Node_Str"",((Script)source).getScriptLanguage());
        v.put(""String_Node_Str"",((Script)source).getScriptText());
        return (T)v;
      }
 else {
        targetClazz=(Class<T>)String.class;
      }
    }
    if (targetClazz.isAssignableFrom(sourceClass)) {
      return (T)source;
    }
 else     if (targetClazz == sourceClass) {
      return (T)source;
    }
 else     if (targetClazz.equals(java.math.BigDecimal.class)) {
      if (Double.class.isAssignableFrom(sourceClass) || sourceClass == double.class) {
        result=(T)BigDecimal.valueOf((Double)source);
        coerced=true;
      }
 else       if (Integer.class.isAssignableFrom(sourceClass) || sourceClass == int.class) {
        result=(T)BigDecimal.valueOf((Integer)source);
        coerced=true;
      }
 else       if (Long.class.isAssignableFrom(sourceClass) || sourceClass == long.class) {
        result=(T)BigDecimal.valueOf((Long)source);
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        java.math.BigDecimal v=new java.math.BigDecimal((String)source);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(java.math.BigInteger.class)) {
      if (Long.class.isAssignableFrom(sourceClass) || sourceClass == long.class) {
        result=(T)BigInteger.valueOf((Long)source);
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        java.math.BigInteger v=new java.math.BigInteger((String)source);
        result=targetClazz.cast(v);
        coerced=true;
      }
 else {
        result=(T)BigInteger.valueOf(coercedTypeCasting(source,Long.class));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(boolean.class) || targetClazz.equals(Boolean.class)) {
      if (sourceClass == Boolean.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        int val=((Integer)source).intValue();
        if (val == 0) {
          result=targetClazz.cast(Boolean.FALSE);
          coerced=true;
        }
 else         if (val == 1) {
          result=targetClazz.cast(Boolean.TRUE);
          coerced=true;
        }
      }
 else       if (sourceClass == String.class) {
        String s=(String)source;
        if (s.equalsIgnoreCase(""String_Node_Str"") || s.equalsIgnoreCase(""String_Node_Str"")) {
          result=targetClazz.cast(Boolean.valueOf((String)source));
          coerced=true;
        }
      }
    }
 else     if (targetClazz.equals(byte[].class)) {
      if (sourceClass == String.class) {
        result=targetClazz.cast(((String)source).getBytes());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Base64.decode((String)source));
        coerced=true;
      }
 else       if (sourceClass == GuardedByteArray.class) {
        GuardedByteArray gba=(GuardedByteArray)source;
        byte[] byteArray=decrypt(gba);
        result=targetClazz.cast(byteArray);
        coerced=true;
      }
    }
 else     if ((targetClazz.equals(Character.class)) || (targetClazz.equals(char.class))) {
      if (sourceClass == String.class) {
        Character v=((String)source).charAt(0);
        result=(T)v;
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Character[].class)) {
      if (sourceClass == String.class) {
        char[] charArray=((String)source).toCharArray();
        Character[] characterArray=new Character[charArray.length];
        for (int i=0; i < charArray.length; i++) {
          characterArray[i]=new Character(charArray[i]);
        }
        result=targetClazz.cast(characterArray);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(char[].class)) {
      if (sourceClass == String.class) {
        char[] charArray=((String)source).toCharArray();
        result=targetClazz.cast(charArray);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Date.class)) {
      if (sourceClass == String.class) {
      }
    }
 else     if (targetClazz.equals(double.class)) {
      if (sourceClass == Double.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == int.class) {
        result=(T)Double.valueOf((((Integer)source).doubleValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Double.valueOf(((Integer)source).doubleValue());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Double.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Double.class)) {
      if (sourceClass == double.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == int.class) {
        result=(T)Double.valueOf((((Integer)source).doubleValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Double.valueOf(((Integer)source).doubleValue());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Double.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(java.io.File.class)) {
      if (sourceClass == String.class) {
        result=(T)new File((String)source);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(float.class) || targetClazz.equals(Float.class)) {
      if (sourceClass == Float.class || sourceClass == float.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == Double.class || sourceClass == double.class) {
        result=(T)new Float((Double)source);
        coerced=true;
      }
 else       if (sourceClass == int.class) {
        result=(T)Float.valueOf((((Integer)source).floatValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Float.valueOf(((Integer)source).floatValue());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Float.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(GuardedByteArray.class)) {
      if (sourceClass == String.class) {
        byte[] byteArray=((String)source).getBytes();
        GuardedByteArray v=new GuardedByteArray(byteArray);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(GuardedString.class)) {
      if (sourceClass == String.class) {
        char[] charArray=((String)source).toCharArray();
        GuardedString v=new GuardedString(charArray);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(int.class) || targetClazz.equals(Integer.class)) {
      if (sourceClass == Integer.class || sourceClass == int.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=(T)Integer.valueOf((String)source);
        coerced=true;
      }
 else       if (sourceClass == Float.class) {
        result=targetClazz.cast(((Float)source).intValue());
        coerced=true;
      }
 else       if (sourceClass == Long.class) {
        Long l=(Long)source;
        if (l.longValue() <= Integer.MAX_VALUE) {
          result=targetClazz.cast(l.intValue());
          coerced=true;
        }
      }
 else       if (sourceClass == Boolean.class) {
        boolean val=((Boolean)source).booleanValue();
        if (val) {
          result=targetClazz.cast(1);
        }
 else {
          result=targetClazz.cast(new Integer(0));
        }
        coerced=true;
      }
    }
 else     if (targetClazz.equals(long.class) || targetClazz.equals(Long.class)) {
      if (sourceClass == int.class) {
        result=(T)Long.valueOf((((Integer)source).longValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Long.valueOf(((Integer)source).longValue());
        coerced=true;
      }
 else       if (sourceClass == Long.class || sourceClass == long.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Long.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Name.class)) {
      if (sourceClass == String.class) {
        result=targetClazz.cast(new Name((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(ObjectClass.class)) {
      if (sourceClass == String.class) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage(""String_Node_Str"");
        sb.setScriptText(""String_Node_Str"");
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
    }
 else     if (targetClazz.equals(QualifiedUid.class)) {
      if (sourceClass == String.class) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage(""String_Node_Str"");
        sb.setScriptText(""String_Node_Str"");
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Script.class)) {
      if (sourceClass == String.class) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage(""String_Node_Str"");
        sb.setScriptText(""String_Node_Str"");
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
 else       if (Map.class.isAssignableFrom(sourceClass)) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage((String)((Map)source).get(""String_Node_Str""));
        sb.setScriptText((String)((Map)source).get(""String_Node_Str""));
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
    }
 else     if (targetClazz.equals(String.class)) {
      if (sourceClass == byte[].class) {
        result=(T)new String((byte[])source);
        coerced=true;
      }
 else       if (sourceClass == char.class) {
        result=(T)new String((char[])source);
        coerced=true;
      }
 else       if (sourceClass == Character[].class) {
        Character[] characterArray=(Character[])source;
        char[] charArray=new char[characterArray.length];
        for (int i=0; i < characterArray.length; i++) {
          charArray[i]=characterArray[i];
        }
        result=(T)new String(charArray);
        coerced=true;
      }
 else       if (sourceClass == Double.class) {
        String s=((Double)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Float.class) {
        String s=((Float)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Boolean.class) {
        Boolean b=(Boolean)source;
        result=targetClazz.cast(Boolean.toString(b.booleanValue()));
        coerced=true;
      }
 else       if (sourceClass == Long.class) {
        String s=((Long)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        String s=((Integer)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.math.BigInteger.class) {
        String s=source.toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.math.BigDecimal.class) {
        String s=((java.math.BigDecimal)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.io.File.class) {
        File file=(File)source;
        String s=file.getPath();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.net.URI.class) {
        java.net.URI uri=(java.net.URI)source;
        String s=uri.toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Character.class) {
        Character c=(Character)source;
        char[] charArray=new char[1];
        charArray[0]=c.charValue();
        String s=new String(charArray);
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == GuardedString.class) {
        String s=decrypt((GuardedString)source);
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == GuardedByteArray.class) {
        byte[] s=decrypt((GuardedByteArray)source);
        result=targetClazz.cast(new String(s));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Uid.class)) {
      if (sourceClass == String.class) {
        Uid v=new Uid((String)source);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(java.net.URI.class)) {
      if (sourceClass == String.class) {
        try {
          java.net.URI v=new java.net.URI((String)source);
          result=targetClazz.cast(v);
          coerced=true;
        }
 catch (        URISyntaxException e) {
          throw new IOException(e);
        }
      }
    }
  }
 catch (  Exception e) {
    if (TRACE.isDebugEnabled()) {
      TRACE.error(""String_Node_Str"",new Object[]{source,sourceClass.getCanonicalName(),targetClazz.getCanonicalName()},e);
    }
 else {
      TRACE.error(""String_Node_Str"",new Object[]{sourceClass.getCanonicalName(),targetClazz.getCanonicalName()},e);
    }
    throw new IllegalArgumentException(source.getClass().getCanonicalName() + ""String_Node_Str"" + targetClazz.getCanonicalName(),e);
  }
  if (!coerced) {
    TRACE.error(""String_Node_Str"",sourceClass.getCanonicalName(),targetClazz.getCanonicalName());
    throw new IllegalArgumentException(source.getClass().getCanonicalName() + ""String_Node_Str"" + targetClazz.getCanonicalName());
  }
  return result;
}","/** 
 * Coerce the   {@code source} object to an object of {@code clazz} type.<p/>
 * @param < T >
 * @param source
 * @param clazz
 * @return
 * @throws NumberFormatException
 * @throws URISyntaxException
 * @throws UnsupportedOperationException
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T coercedTypeCasting(Object source,Class<T> clazz) throws IllegalArgumentException {
  if (null == clazz) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (source instanceof JsonValue) {
    source=((JsonValue)source).getObject();
  }
  Class<T> targetClazz=clazz;
  Class sourceClass=(source == null ? null : source.getClass());
  boolean coerced=false;
  T result=null;
  try {
    if (source == null) {
      return null;
    }
    if (targetClazz.equals(Object.class)) {
      if ((Number.class.isAssignableFrom(sourceClass)) || (int.class == clazz) || (double.class == clazz)|| (float.class == clazz)|| (long.class == clazz)) {
        return (T)source;
      }
 else       if ((Boolean.class.isAssignableFrom(sourceClass)) || (boolean.class == clazz)) {
        return (T)source;
      }
 else       if (String.class.isAssignableFrom(sourceClass)) {
        return (T)source;
      }
 else       if (Map.class.isAssignableFrom(sourceClass)) {
        return (T)source;
      }
 else       if (List.class.isAssignableFrom(sourceClass)) {
        return (T)source;
      }
 else       if (sourceClass == QualifiedUid.class) {
        Map<String,Object> v=new HashMap<String,Object>(2);
        v.put(""String_Node_Str"",((QualifiedUid)source).getUid().getUidValue());
        v.put(""String_Node_Str"",((QualifiedUid)source).getObjectClass().getObjectClassValue());
        return (T)v;
      }
 else       if (sourceClass == Script.class) {
        Map<String,Object> v=new HashMap<String,Object>(2);
        v.put(""String_Node_Str"",((Script)source).getScriptLanguage());
        v.put(""String_Node_Str"",((Script)source).getScriptText());
        return (T)v;
      }
 else {
        targetClazz=(Class<T>)String.class;
      }
    }
    if (targetClazz.isAssignableFrom(sourceClass)) {
      return (T)source;
    }
 else     if (targetClazz == sourceClass) {
      return (T)source;
    }
 else     if (targetClazz.equals(java.math.BigDecimal.class)) {
      if (Double.class.isAssignableFrom(sourceClass) || sourceClass == double.class) {
        result=(T)BigDecimal.valueOf((Double)source);
        coerced=true;
      }
 else       if (Integer.class.isAssignableFrom(sourceClass) || sourceClass == int.class) {
        result=(T)BigDecimal.valueOf((Integer)source);
        coerced=true;
      }
 else       if (Long.class.isAssignableFrom(sourceClass) || sourceClass == long.class) {
        result=(T)BigDecimal.valueOf((Long)source);
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        java.math.BigDecimal v=new java.math.BigDecimal((String)source);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(java.math.BigInteger.class)) {
      if (Long.class.isAssignableFrom(sourceClass) || sourceClass == long.class) {
        result=(T)BigInteger.valueOf((Long)source);
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        java.math.BigInteger v=new java.math.BigInteger((String)source);
        result=targetClazz.cast(v);
        coerced=true;
      }
 else {
        result=(T)BigInteger.valueOf(coercedTypeCasting(source,Long.class));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(boolean.class) || targetClazz.equals(Boolean.class)) {
      if (sourceClass == Boolean.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        int val=((Integer)source).intValue();
        if (val == 0) {
          result=targetClazz.cast(Boolean.FALSE);
          coerced=true;
        }
 else         if (val == 1) {
          result=targetClazz.cast(Boolean.TRUE);
          coerced=true;
        }
      }
 else       if (sourceClass == String.class) {
        String s=(String)source;
        if (s.equalsIgnoreCase(""String_Node_Str"") || s.equalsIgnoreCase(""String_Node_Str"")) {
          result=(T)Boolean.valueOf((String)source);
          coerced=true;
        }
      }
    }
 else     if (targetClazz.equals(byte[].class)) {
      if (sourceClass == String.class) {
        result=targetClazz.cast(((String)source).getBytes());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Base64.decode((String)source));
        coerced=true;
      }
 else       if (sourceClass == GuardedByteArray.class) {
        GuardedByteArray gba=(GuardedByteArray)source;
        byte[] byteArray=decrypt(gba);
        result=targetClazz.cast(byteArray);
        coerced=true;
      }
    }
 else     if ((targetClazz.equals(Character.class)) || (targetClazz.equals(char.class))) {
      if (sourceClass == String.class) {
        Character v=((String)source).charAt(0);
        result=(T)v;
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Character[].class)) {
      if (sourceClass == String.class) {
        char[] charArray=((String)source).toCharArray();
        Character[] characterArray=new Character[charArray.length];
        for (int i=0; i < charArray.length; i++) {
          characterArray[i]=new Character(charArray[i]);
        }
        result=targetClazz.cast(characterArray);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(char[].class)) {
      if (sourceClass == String.class) {
        char[] charArray=((String)source).toCharArray();
        result=targetClazz.cast(charArray);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Date.class)) {
      if (sourceClass == String.class) {
      }
    }
 else     if (targetClazz.equals(double.class)) {
      if (sourceClass == Double.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == int.class) {
        result=(T)Double.valueOf((((Integer)source).doubleValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Double.valueOf(((Integer)source).doubleValue());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Double.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Double.class)) {
      if (sourceClass == double.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == int.class) {
        result=(T)Double.valueOf((((Integer)source).doubleValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Double.valueOf(((Integer)source).doubleValue());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Double.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(java.io.File.class)) {
      if (sourceClass == String.class) {
        result=(T)new File((String)source);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(float.class) || targetClazz.equals(Float.class)) {
      if (sourceClass == Float.class || sourceClass == float.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == Double.class || sourceClass == double.class) {
        result=(T)new Float((Double)source);
        coerced=true;
      }
 else       if (sourceClass == int.class) {
        result=(T)Float.valueOf((((Integer)source).floatValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Float.valueOf(((Integer)source).floatValue());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=(T)Float.valueOf((String)source);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(GuardedByteArray.class)) {
      if (sourceClass == String.class) {
        byte[] byteArray=((String)source).getBytes();
        GuardedByteArray v=new GuardedByteArray(byteArray);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(GuardedString.class)) {
      if (sourceClass == String.class) {
        char[] charArray=((String)source).toCharArray();
        GuardedString v=new GuardedString(charArray);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(int.class) || targetClazz.equals(Integer.class)) {
      if (sourceClass == Integer.class || sourceClass == int.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=(T)Integer.valueOf((String)source);
        coerced=true;
      }
 else       if (sourceClass == Float.class) {
        result=targetClazz.cast(((Float)source).intValue());
        coerced=true;
      }
 else       if (sourceClass == Long.class) {
        Long l=(Long)source;
        if (l.longValue() <= Integer.MAX_VALUE) {
          result=targetClazz.cast(l.intValue());
          coerced=true;
        }
      }
 else       if (sourceClass == Boolean.class) {
        boolean val=((Boolean)source).booleanValue();
        if (val) {
          result=targetClazz.cast(1);
        }
 else {
          result=targetClazz.cast(new Integer(0));
        }
        coerced=true;
      }
    }
 else     if (targetClazz.equals(long.class) || targetClazz.equals(Long.class)) {
      if (sourceClass == int.class) {
        result=(T)Long.valueOf((((Integer)source).longValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Long.valueOf(((Integer)source).longValue());
        coerced=true;
      }
 else       if (sourceClass == Long.class || sourceClass == long.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=(T)Long.valueOf((String)source);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Name.class)) {
      if (sourceClass == String.class) {
        result=targetClazz.cast(new Name((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(ObjectClass.class)) {
      if (sourceClass == String.class) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage(""String_Node_Str"");
        sb.setScriptText(""String_Node_Str"");
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
    }
 else     if (targetClazz.equals(QualifiedUid.class)) {
      if (sourceClass == String.class) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage(""String_Node_Str"");
        sb.setScriptText(""String_Node_Str"");
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Script.class)) {
      if (sourceClass == String.class) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage(""String_Node_Str"");
        sb.setScriptText(""String_Node_Str"");
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
 else       if (Map.class.isAssignableFrom(sourceClass)) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage((String)((Map)source).get(""String_Node_Str""));
        sb.setScriptText((String)((Map)source).get(""String_Node_Str""));
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
    }
 else     if (targetClazz.equals(String.class)) {
      if (sourceClass == byte[].class) {
        result=(T)new String((byte[])source);
        coerced=true;
      }
 else       if (sourceClass == char.class) {
        result=(T)new String((char[])source);
        coerced=true;
      }
 else       if (sourceClass == Character[].class) {
        Character[] characterArray=(Character[])source;
        char[] charArray=new char[characterArray.length];
        for (int i=0; i < characterArray.length; i++) {
          charArray[i]=characterArray[i];
        }
        result=(T)new String(charArray);
        coerced=true;
      }
 else       if (sourceClass == Double.class) {
        String s=((Double)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Float.class) {
        String s=((Float)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Boolean.class) {
        Boolean b=(Boolean)source;
        result=targetClazz.cast(Boolean.toString(b.booleanValue()));
        coerced=true;
      }
 else       if (sourceClass == Long.class) {
        String s=((Long)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        String s=((Integer)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.math.BigInteger.class) {
        String s=source.toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.math.BigDecimal.class) {
        String s=((java.math.BigDecimal)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.io.File.class) {
        File file=(File)source;
        String s=file.getPath();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.net.URI.class) {
        java.net.URI uri=(java.net.URI)source;
        String s=uri.toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Character.class) {
        Character c=(Character)source;
        char[] charArray=new char[1];
        charArray[0]=c.charValue();
        String s=new String(charArray);
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == GuardedString.class) {
        String s=decrypt((GuardedString)source);
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == GuardedByteArray.class) {
        byte[] s=decrypt((GuardedByteArray)source);
        result=targetClazz.cast(new String(s));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Uid.class)) {
      if (sourceClass == String.class) {
        Uid v=new Uid((String)source);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(java.net.URI.class)) {
      if (sourceClass == String.class) {
        try {
          java.net.URI v=new java.net.URI((String)source);
          result=targetClazz.cast(v);
          coerced=true;
        }
 catch (        URISyntaxException e) {
          throw new IOException(e);
        }
      }
    }
  }
 catch (  Exception e) {
    if (TRACE.isDebugEnabled()) {
      TRACE.error(""String_Node_Str"",new Object[]{source,sourceClass.getCanonicalName(),targetClazz.getCanonicalName()},e);
    }
 else {
      TRACE.error(""String_Node_Str"",new Object[]{sourceClass.getCanonicalName(),targetClazz.getCanonicalName()},e);
    }
    throw new IllegalArgumentException(source.getClass().getCanonicalName() + ""String_Node_Str"" + targetClazz.getCanonicalName(),e);
  }
  if (!coerced) {
    TRACE.error(""String_Node_Str"",sourceClass.getCanonicalName(),targetClazz.getCanonicalName());
    throw new IllegalArgumentException(source.getClass().getCanonicalName() + ""String_Node_Str"" + targetClazz.getCanonicalName());
  }
  return result;
}"
13324,"@Override public JsonValue handle(JsonValue request) throws JsonResourceException {
  try {
    ActivitiConstants.WorkflowPath path=getPath(request);
    String user=JsonResourceContext.getParentContext(request).get(new JsonPointer(""String_Node_Str"")).asString();
    Authentication.setAuthenticatedUserId(user);
    Method method=request.get(""String_Node_Str"").required().asEnum(SimpleJsonResource.Method.class);
switch (path) {
case processdefinition:
      return processDefinition(method,request);
case processdefinitionid:
    return processDefinitionId(method,request);
case processinstance:
  return processInstance(method,request);
case processinstanceid:
return processInstanceId(method,request);
case taskdefinition:
return taskDefinition(method,request);
case taskinstance:
return taskInstance(method,request);
case taskinstanceid:
return taskInstanceId(method,request);
default :
throw new JsonResourceException(JsonResourceException.FORBIDDEN,""String_Node_Str"");
}
}
 catch (JsonValueException jve) {
throw new JsonResourceException(JsonResourceException.BAD_REQUEST,jve);
}
}","@Override public JsonValue handle(JsonValue request) throws JsonResourceException {
  try {
    ActivitiConstants.WorkflowPath path=getPath(request);
    Method method=request.get(""String_Node_Str"").required().asEnum(SimpleJsonResource.Method.class);
switch (path) {
case processdefinition:
      return processDefinition(method,request);
case processdefinitionid:
    return processDefinitionId(method,request);
case processinstance:
  return processInstance(method,request);
case processinstanceid:
return processInstanceId(method,request);
case taskdefinition:
return taskDefinition(method,request);
case taskinstance:
return taskInstance(method,request);
case taskinstanceid:
return taskInstanceId(method,request);
default :
throw new JsonResourceException(JsonResourceException.FORBIDDEN,""String_Node_Str"");
}
}
 catch (JsonValueException jve) {
throw new JsonResourceException(JsonResourceException.BAD_REQUEST,jve);
}
}"
13325,"/** 
 * Initialize the DB pool.
 * @param dbURL the orientdb URL
 * @param user the orientdb user to connect
 * @param password the orientdb password to connect
 * @param minSize the orientdb pool minimum size
 * @param maxSize the orientdb pool maximum size
 * @param completeConfig
 * @return the initialized pool
 * @throws org.forgerock.openidm.config.InvalidException
 */
private static ODatabaseDocumentPool initPool(String dbURL,String user,String password,int minSize,int maxSize,JsonValue completeConfig) throws InvalidException {
  logger.trace(""String_Node_Str"",dbURL);
  OGlobalConfiguration.TX_USE_LOG.setValue(true);
  OGlobalConfiguration.TX_COMMIT_SYNCH.setValue(true);
  OGlobalConfiguration.STORAGE_KEEP_OPEN.setValue(false);
  boolean success=false;
  int maxRetry=10;
  int retryCount=0;
  ODatabaseDocumentPool pool=null;
  do {
    retryCount++;
    if (pool != null) {
      pool.close();
    }
    pool=new ODatabaseDocumentPool();
    pool.setup(minSize,maxSize);
    warmUpPool(pool,dbURL,user,password,minSize);
    boolean finalTry=(retryCount >= maxRetry);
    success=test(pool,dbURL,user,password,finalTry);
  }
 while (!success && retryCount < maxRetry);
  if (!success) {
    logger.warn(""String_Node_Str"");
  }
 else {
    logger.info(""String_Node_Str"",retryCount);
  }
  logger.debug(""String_Node_Str"",pool);
  return pool;
}","/** 
 * Initialize the DB pool.
 * @param dbURL the orientdb URL
 * @param user the orientdb user to connect
 * @param password the orientdb password to connect
 * @param minSize the orientdb pool minimum size
 * @param maxSize the orientdb pool maximum size
 * @param completeConfig
 * @return the initialized pool
 * @throws org.forgerock.openidm.config.InvalidException
 */
private static ODatabaseDocumentPool initPool(String dbURL,String user,String password,int minSize,int maxSize,JsonValue completeConfig) throws InvalidException {
  logger.trace(""String_Node_Str"",dbURL);
  OGlobalConfiguration.TX_USE_LOG.setValue(true);
  OGlobalConfiguration.TX_COMMIT_SYNCH.setValue(true);
  OGlobalConfiguration.STORAGE_KEEP_OPEN.setValue(false);
  boolean success=false;
  int maxRetry=10;
  int retryCount=0;
  ODatabaseDocumentPool pool=null;
  do {
    retryCount++;
    if (pool != null) {
      pool.close();
    }
    pool=ODatabaseDocumentPool.global();
    warmUpPool(pool,dbURL,user,password,1);
    boolean finalTry=(retryCount >= maxRetry);
    success=test(pool,dbURL,user,password,finalTry);
  }
 while (!success && retryCount < maxRetry);
  if (!success) {
    logger.warn(""String_Node_Str"");
  }
 else {
    logger.info(""String_Node_Str"",retryCount);
  }
  logger.debug(""String_Node_Str"",pool);
  return pool;
}"
13326,"@Override public JsonValue encrypt(JsonValue value,String cipher,String alias) throws JsonCryptoException, JsonException {
  JsonValue result=null;
  if (value != null) {
    result=getEncryptor(cipher,alias).encrypt(value);
  }
  return result;
}","@Override public JsonValue encrypt(JsonValue value,String cipher,String alias) throws JsonCryptoException, JsonException {
  JsonValue result=null;
  if (value != null) {
    JsonEncryptor encryptor=getEncryptor(cipher,alias);
    result=new JsonCrypto(encryptor.getType(),encryptor.encrypt(value)).toJsonValue();
  }
  return result;
}"
13327,"public AttributeInfoHelper(String name,boolean isOperationalOption,Map<String,Object> schema) throws SchemaException {
  this.name=name;
  Object typeString=schema.get(Constants.TYPE);
  if (typeString instanceof String) {
    type=ConnectorUtil.findClassForName((String)typeString);
  }
 else {
    throw new SchemaException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  Object nativeTypeString=schema.get(ConnectorUtil.OPENICF_NATIVE_TYPE);
  Class<?> nativeType=null;
  if (nativeTypeString instanceof String) {
    nativeType=ConnectorUtil.findClassForName((String)nativeTypeString);
  }
 else {
    nativeType=type;
  }
  Object nativeNameString=schema.get(ConnectorUtil.OPENICF_NATIVE_NAME);
  String nativeName=null;
  if (nativeNameString instanceof String) {
    nativeName=(String)nativeNameString;
  }
 else {
    nativeName=name;
  }
  Object def=schema.get(Constants.DEFAULT);
  if (null == def) {
    defaultValue=null;
  }
 else {
    defaultValue=def;
  }
  if (!isOperationalOption) {
    Object k=schema.get(""String_Node_Str"");
    if (k instanceof String) {
      key=(String)k;
    }
 else {
      key=null;
    }
    Object c=schema.get(""String_Node_Str"");
    if (c instanceof String) {
      cipher=(String)c;
    }
 else {
      cipher=ServerConstants.SECURITY_CRYPTOGRAPHY_DEFAULT_CIPHER;
    }
    AttributeInfoBuilder builder=new AttributeInfoBuilder(nativeName,nativeType);
    builder.setMultiValued(Collection.class.isAssignableFrom(type));
    Object flagsObject=schema.get(ConnectorUtil.OPENICF_FLAGS);
    if (flagsObject instanceof List) {
      flags=new HashSet<AttributeFlag>(((List)flagsObject).size());
      for (      String flagString : (List<String>)flagsObject) {
        AttributeFlag flag=AttributeFlag.findByKey(flagString);
        if (null != flag) {
          if (AttributeFlag.NOT_CREATABLE.equals(flag)) {
            builder.setCreateable(false);
          }
 else           if (AttributeFlag.NOT_UPDATEABLE.equals(flag)) {
            builder.setUpdateable(false);
          }
 else           if (AttributeFlag.NOT_READABLE.equals(flag)) {
            builder.setReadable(false);
          }
 else           if (AttributeFlag.NOT_RETURNED_BY_DEFAULT.equals(flag)) {
            builder.setReturnedByDefault(false);
          }
 else {
            flags.add(flag);
          }
        }
      }
    }
 else {
      flags=Collections.emptySet();
    }
    builder.setRequired((null != schema.get(Constants.REQUIRED)) ? (Boolean)schema.get(Constants.REQUIRED) : false);
    attributeInfo=builder.build();
  }
 else {
    flags=null;
    attributeInfo=null;
    key=null;
    cipher=null;
  }
}","public AttributeInfoHelper(String name,boolean isOperationalOption,Map<String,Object> schema) throws SchemaException {
  this.name=name;
  Object typeString=schema.get(Constants.TYPE);
  if (typeString instanceof String) {
    type=ConnectorUtil.findClassForName((String)typeString);
  }
 else {
    throw new SchemaException(new JsonNode(typeString,new JsonPointer(Constants.TYPE)),""String_Node_Str"" + name + ""String_Node_Str"");
  }
  Object nativeTypeString=schema.get(ConnectorUtil.OPENICF_NATIVE_TYPE);
  Class<?> nativeType=null;
  if (nativeTypeString instanceof String) {
    nativeType=ConnectorUtil.findClassForName((String)nativeTypeString);
  }
 else {
    nativeType=type;
  }
  Object nativeNameString=schema.get(ConnectorUtil.OPENICF_NATIVE_NAME);
  String nativeName=null;
  if (nativeNameString instanceof String) {
    nativeName=(String)nativeNameString;
  }
 else {
    nativeName=name;
  }
  Object def=schema.get(Constants.DEFAULT);
  if (null == def) {
    defaultValue=null;
  }
 else {
    defaultValue=def;
  }
  if (!isOperationalOption) {
    Object k=schema.get(""String_Node_Str"");
    if (k instanceof String) {
      key=(String)k;
    }
 else {
      key=null;
    }
    Object c=schema.get(""String_Node_Str"");
    if (c instanceof String) {
      cipher=(String)c;
    }
 else {
      cipher=ServerConstants.SECURITY_CRYPTOGRAPHY_DEFAULT_CIPHER;
    }
    AttributeInfoBuilder builder=new AttributeInfoBuilder(nativeName,nativeType);
    builder.setMultiValued(Collection.class.isAssignableFrom(type));
    Object flagsObject=schema.get(ConnectorUtil.OPENICF_FLAGS);
    if (flagsObject instanceof List) {
      flags=new HashSet<AttributeFlag>(((List)flagsObject).size());
      for (      String flagString : (List<String>)flagsObject) {
        AttributeFlag flag=AttributeFlag.findByKey(flagString);
        if (null != flag) {
          if (AttributeFlag.NOT_CREATABLE.equals(flag)) {
            builder.setCreateable(false);
          }
 else           if (AttributeFlag.NOT_UPDATEABLE.equals(flag)) {
            builder.setUpdateable(false);
          }
 else           if (AttributeFlag.NOT_READABLE.equals(flag)) {
            builder.setReadable(false);
          }
 else           if (AttributeFlag.NOT_RETURNED_BY_DEFAULT.equals(flag)) {
            builder.setReturnedByDefault(false);
          }
 else {
            flags.add(flag);
          }
        }
      }
    }
 else {
      flags=Collections.emptySet();
    }
    builder.setRequired((null != schema.get(Constants.REQUIRED)) ? (Boolean)schema.get(Constants.REQUIRED) : false);
    attributeInfo=builder.build();
  }
 else {
    flags=null;
    attributeInfo=null;
    key=null;
    cipher=null;
  }
}"
13328,"/** 
 * Creates a new object in the object set. <p> This method sets the   {@code _id} property to the assigned identifier for the object,and the  {@code _rev} property to the revised object version (For optimistic concurrency)
 * @param id the client-generated identifier to use, or {@code null} if server-generated identifier is requested.
 * @param object the contents of the object to create in the object set.
 * @throws NotFoundException if the specified id could not be resolved. 
 * @throws ForbiddenException if access to the object or object set is forbidden.
 * @throws PreconditionFailedException if an object with the same ID already exists.
 */
@Override public void create(String fullId,Map<String,Object> obj) throws ObjectSetException {
  String localId=getLocalId(fullId);
  String type=getObjectType(fullId);
  String orientClassName=typeToOrientClassName(type);
  if (fullId == null || localId == null) {
    throw new NotFoundException(""String_Node_Str"" + fullId + ""String_Node_Str""+ localId);
  }
 else   if (type == null) {
    throw new NotFoundException(""String_Node_Str"" + fullId);
  }
  obj.put(DocumentUtil.TAG_ID,localId);
  ODatabaseDocumentTx db=pool.acquire(dbURL,user,password);
  try {
    ODocument newDoc=DocumentUtil.toDocument(obj,null,db,orientClassName);
    logger.trace(""String_Node_Str"",fullId,newDoc);
    newDoc.save();
    newDoc.reload();
    obj.put(DocumentUtil.TAG_REV,Integer.toString(newDoc.getVersion()));
    logger.debug(""String_Node_Str"",fullId,newDoc);
  }
 catch (  OIndexException ex) {
    throw new PreconditionFailedException(""String_Node_Str"" + ex.getMessage(),ex);
  }
catch (  com.orientechnologies.orient.core.exception.ODatabaseException ex) {
    if (isCauseIndexException(ex,10)) {
      throw new PreconditionFailedException(""String_Node_Str"" + ex.getMessage(),ex);
    }
 else {
      throw ex;
    }
  }
catch (  RuntimeException e) {
    throw e;
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}","/** 
 * Creates a new object in the object set. <p> This method sets the   {@code _id} property to the assigned identifier for the object,and the  {@code _rev} property to the revised object version (For optimistic concurrency)
 * @param id the client-generated identifier to use, or {@code null} if server-generated identifier is requested.
 * @param object the contents of the object to create in the object set.
 * @throws NotFoundException if the specified id could not be resolved. 
 * @throws ForbiddenException if access to the object or object set is forbidden.
 * @throws PreconditionFailedException if an object with the same ID already exists.
 */
@Override public void create(String fullId,Map<String,Object> obj) throws ObjectSetException {
  String localId=getLocalId(fullId);
  String type=getObjectType(fullId);
  String orientClassName=typeToOrientClassName(type);
  if (fullId == null || localId == null) {
    throw new NotFoundException(""String_Node_Str"" + fullId + ""String_Node_Str""+ localId);
  }
 else   if (type == null) {
    throw new NotFoundException(""String_Node_Str"" + fullId);
  }
  obj.put(DocumentUtil.TAG_ID,localId);
  ODatabaseDocumentTx db=pool.acquire(dbURL,user,password);
  try {
    ODocument newDoc=DocumentUtil.toDocument(obj,null,db,orientClassName);
    logger.trace(""String_Node_Str"",fullId,newDoc);
    newDoc.save();
    obj.put(DocumentUtil.TAG_REV,Integer.toString(newDoc.getVersion()));
    logger.debug(""String_Node_Str"",fullId,newDoc);
  }
 catch (  OIndexException ex) {
    throw new PreconditionFailedException(""String_Node_Str"" + ex.getMessage(),ex);
  }
catch (  com.orientechnologies.orient.core.exception.ODatabaseException ex) {
    if (isCauseIndexException(ex,10)) {
      throw new PreconditionFailedException(""String_Node_Str"" + ex.getMessage(),ex);
    }
 else {
      throw ex;
    }
  }
catch (  RuntimeException e) {
    throw e;
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}"
13329,"/** 
 * Query by primary key, the OpenIDM identifier. This identifier is different from the OrientDB internal record id.
 * @param id the OpenIDM identifier for an object
 * @param type the OrientDB class
 * @param database a handle to the OrientDB database object. No other thread must operate on this concurrently.
 * @return The ODocument if found, null if not found.
 * @throws Bad if the passed identifier or type are invalid
 */
public ODocument getByID(final String id,final String type,ODatabaseDocumentTx database) throws BadRequestException {
  String orientClassName=OrientDBRepoService.typeToOrientClassName(type);
  if (id == null) {
    throw new BadRequestException(""String_Node_Str"");
  }
 else   if (type == null) {
    throw new BadRequestException(""String_Node_Str"");
  }
  OSQLSynchQuery<ODocument> query=new OSQLSynchQuery<ODocument>(""String_Node_Str"" + orientClassName + ""String_Node_Str""+ DocumentUtil.ORIENTDB_PRIMARY_KEY+ ""String_Node_Str""+ id+ ""String_Node_Str"");
  List<ODocument> result=database.query(query);
  logger.trace(""String_Node_Str"",query,result);
  ODocument first=null;
  if (result.size() > 0) {
    first=result.get(0);
    first.reload();
  }
  return first;
}","/** 
 * Query by primary key, the OpenIDM identifier. This identifier is different from the OrientDB internal record id.
 * @param id the OpenIDM identifier for an object
 * @param type the OrientDB class
 * @param database a handle to the OrientDB database object. No other thread must operate on this concurrently.
 * @return The ODocument if found, null if not found.
 * @throws Bad if the passed identifier or type are invalid
 */
public ODocument getByID(final String id,final String type,ODatabaseDocumentTx database) throws BadRequestException {
  String orientClassName=OrientDBRepoService.typeToOrientClassName(type);
  if (id == null) {
    throw new BadRequestException(""String_Node_Str"");
  }
 else   if (type == null) {
    throw new BadRequestException(""String_Node_Str"");
  }
  OSQLSynchQuery<ODocument> query=new OSQLSynchQuery<ODocument>(""String_Node_Str"" + orientClassName + ""String_Node_Str""+ DocumentUtil.ORIENTDB_PRIMARY_KEY+ ""String_Node_Str""+ id+ ""String_Node_Str"");
  List<ODocument> result=database.query(query);
  logger.trace(""String_Node_Str"",query,result);
  ODocument first=null;
  if (result.size() > 0) {
    first=result.get(0);
  }
  return first;
}"
13330,"/** 
 * TODO: Description.
 * @return TODO.
 * @throws SynchronizationException TODO.
 */
protected boolean isSourceValid() throws SynchronizationException {
  boolean result=false;
  if (sourceObject != null) {
    if (validSource != null) {
      HashMap<String,Object> scope=new HashMap<String,Object>();
      scope.put(""String_Node_Str"",sourceObject);
      try {
        Object o=validSource.exec(scope);
        if (o == null || !(o instanceof Boolean)) {
          throw new SynchronizationException(""String_Node_Str"");
        }
        result=(Boolean)o;
      }
 catch (      ScriptException se) {
        throw new SynchronizationException(se);
      }
    }
 else {
      result=true;
    }
  }
  return result;
}","/** 
 * TODO: Description.
 * @return TODO.
 * @throws SynchronizationException TODO.
 */
protected boolean isSourceValid() throws SynchronizationException {
  boolean result=false;
  if (sourceObject != null) {
    if (validSource != null) {
      HashMap<String,Object> scope=new HashMap<String,Object>();
      scope.put(""String_Node_Str"",sourceObject.asMap());
      try {
        Object o=validSource.exec(scope);
        if (o == null || !(o instanceof Boolean)) {
          throw new SynchronizationException(""String_Node_Str"");
        }
        result=(Boolean)o;
      }
 catch (      ScriptException se) {
        throw new SynchronizationException(se);
      }
    }
 else {
      result=true;
    }
  }
  return result;
}"
13331,"public void recon(String reconId) throws SynchronizationException {
  InvokeContext.getContext().pushActivityId(reconId);
  try {
    performRecon(reconId);
  }
  finally {
    InvokeContext.getContext().popActivityId();
  }
}","public void recon(String reconId) throws SynchronizationException {
  InvokeContext.getContext().pushActivityId(reconId);
  try {
    doRecon(reconId);
  }
  finally {
    InvokeContext.getContext().popActivityId();
  }
}"
13332,"/** 
 * TODO: Description.
 * @param source TODO.
 * @param target TODO.
 * @throws MappingException TODO.
 */
public void apply(JsonNode source,JsonNode target) throws SynchronizationException {
  try {
    Object result=this.source.get(source).getValue();
    if (script != null) {
      HashMap<String,Object> scope=new HashMap<String,Object>();
      scope.put(""String_Node_Str"",result);
      result=script.exec(scope);
    }
    this.target.put(target,result);
  }
 catch (  JsonNodeException jne) {
    throw new SynchronizationException(jne);
  }
catch (  ScriptException se) {
    throw new SynchronizationException(se);
  }
}","/** 
 * TODO: Description.
 * @param source TODO.
 * @param target TODO.
 * @throws MappingException TODO.
 */
public void apply(JsonNode sourceObject,JsonNode targetObject) throws SynchronizationException {
  try {
    JsonNode node=sourcePath.get(sourceObject);
    if (node == null) {
      throw new SynchronizationException(""String_Node_Str"" + sourcePath.toString() + ""String_Node_Str"");
    }
    Object result=node.getValue();
    if (script != null) {
      HashMap<String,Object> scope=new HashMap<String,Object>();
      scope.put(""String_Node_Str"",result);
      result=script.exec(scope);
    }
    targetPath.put(targetObject,result);
  }
 catch (  JsonNodeException jne) {
    throw new SynchronizationException(jne);
  }
catch (  ScriptException se) {
    throw new SynchronizationException(se);
  }
}"
13333,"/** 
 * TODO: Description.
 * @param config TODO.
 * @throws JsonNodeException TODO>
 */
public PropertyMapping(JsonNode config) throws JsonNodeException {
  source=asPath(config,""String_Node_Str"");
  target=asPath(config,""String_Node_Str"");
  script=Scripts.newInstance(config.get(""String_Node_Str""));
}","/** 
 * TODO: Description.
 * @param config TODO.
 * @throws JsonNodeException TODO>
 */
public PropertyMapping(JsonNode config) throws JsonNodeException {
  sourcePath=asPath(config,""String_Node_Str"");
  targetPath=asPath(config,""String_Node_Str"");
  script=Scripts.newInstance(config.get(""String_Node_Str""));
}"
13334,"/** 
 * Overrides the response to provide a JSON error structure in the entity if a  {@link ResourceException} is being thrown.
 */
@Override protected void doCatch(Throwable throwable){
  Throwable cause=throwable.getCause();
  if (throwable instanceof ResourceException && cause instanceof ObjectSetException) {
    Status status;
    if (cause instanceof NotFoundException) {
      status=Status.CLIENT_ERROR_NOT_FOUND;
    }
 else     if (cause instanceof PreconditionFailedException) {
      status=Status.CLIENT_ERROR_PRECONDITION_FAILED;
    }
 else     if (cause instanceof BadRequestException) {
      status=Status.CLIENT_ERROR_BAD_REQUEST;
    }
 else     if (cause instanceof ForbiddenException) {
      status=Status.CLIENT_ERROR_FORBIDDEN;
    }
 else     if (cause instanceof ConflictException) {
      status=Status.CLIENT_ERROR_CONFLICT;
    }
 else     if (cause instanceof MethodNotAllowedException) {
      status=Status.CLIENT_ERROR_METHOD_NOT_ALLOWED;
    }
 else     if (cause instanceof InternalServerErrorException) {
      status=Status.SERVER_ERROR_INTERNAL;
    }
 else     if (cause instanceof ServiceUnavailableException) {
      status=Status.SERVER_ERROR_SERVICE_UNAVAILABLE;
    }
 else {
      status=Status.SERVER_ERROR_INTERNAL;
    }
    String description=(cause != null ? cause.getMessage() : null);
    throwable=new ResourceException(status,description,cause);
  }
  if (throwable instanceof ResourceException) {
    ResourceException re=(ResourceException)throwable;
    Map<String,Object> entity=new HashMap<String,Object>();
    Status status=re.getStatus();
    entity.put(""String_Node_Str"",status != null ? status.getName() : ""String_Node_Str"");
    entity.put(""String_Node_Str"",status != null ? status.getDescription() : re.getMessage());
    getResponse().setEntity(jacksonRepresentation(entity));
  }
  super.doCatch(throwable);
}","/** 
 * Overrides the response to provide a JSON error structure in the entity if a  {@link ResourceException} is being thrown.
 */
@Override protected void doCatch(Throwable throwable){
  Throwable cause=throwable.getCause();
  if (throwable instanceof ResourceException && cause instanceof ObjectSetException) {
    Status status;
    if (cause instanceof NotFoundException) {
      status=Status.CLIENT_ERROR_NOT_FOUND;
    }
 else     if (cause instanceof PreconditionFailedException) {
      status=Status.CLIENT_ERROR_PRECONDITION_FAILED;
    }
 else     if (cause instanceof BadRequestException) {
      status=Status.CLIENT_ERROR_BAD_REQUEST;
    }
 else     if (cause instanceof ForbiddenException) {
      status=Status.CLIENT_ERROR_FORBIDDEN;
    }
 else     if (cause instanceof ConflictException) {
      status=Status.CLIENT_ERROR_CONFLICT;
    }
 else     if (cause instanceof MethodNotAllowedException) {
      status=Status.CLIENT_ERROR_METHOD_NOT_ALLOWED;
    }
 else     if (cause instanceof InternalServerErrorException) {
      status=Status.SERVER_ERROR_INTERNAL;
    }
 else     if (cause instanceof ServiceUnavailableException) {
      status=Status.SERVER_ERROR_SERVICE_UNAVAILABLE;
    }
 else {
      status=Status.SERVER_ERROR_INTERNAL;
    }
    String description=(cause != null ? cause.getMessage() : null);
    throwable=new ResourceException(status,description,cause);
  }
  if (throwable instanceof ResourceException) {
    ResourceException re=(ResourceException)throwable;
    Map<String,Object> entity=new HashMap<String,Object>();
    Status status=re.getStatus();
    entity.put(""String_Node_Str"",status != null ? status.getName() : ""String_Node_Str"");
    entity.put(""String_Node_Str"",status != null ? status.getDescription() : re.getMessage());
    setStatus(status);
    getResponse().setEntity(jacksonRepresentation(entity));
  }
}"
13335,"/** 
 * TODO: Description.
 * @param object TODO.
 * @return TODO.
 */
private Tag getTag(Map<String,Object> map){
  Object rev=(map != null ? map.get(""String_Node_Str"") : null);
  return (rev != null && rev instanceof String ? new Tag((String)rev) : null);
}","/** 
 * TODO: Description.
 * @param object TODO.
 * @return TODO.
 */
private Tag getTag(Map<String,Object> map){
  Object rev=(map != null ? map.get(""String_Node_Str"") : null);
  return (rev != null && rev instanceof String ? new Tag((String)rev,false) : null);
}"
13336,"/** 
 * TODO: Description.
 * @param object TODO.
 * @return TODO.
 * @throws InternalServerErrorException TODO.
 */
private Representation cuResponse(Map<String,Object> object) throws InternalServerErrorException {
  HashMap<String,Object> map=new HashMap<String,Object>();
  Object id=object.get(""String_Node_Str"");
  if (id == null || !(id instanceof String)) {
    throw new InternalServerErrorException(""String_Node_Str"");
  }
  map.put(""String_Node_Str"",(String)id);
  Object rev=object.get(""String_Node_Str"");
  if (rev != null && !(rev instanceof String)) {
    throw new InternalServerErrorException(""String_Node_Str"");
  }
  if (rev != null) {
    map.put(""String_Node_Str"",(String)rev);
  }
  Representation result=jacksonRepresentation(map);
  if (rev != null) {
    result.setTag(new Tag((String)rev));
  }
  return result;
}","/** 
 * TODO: Description.
 * @param object TODO.
 * @return TODO.
 * @throws InternalServerErrorException TODO.
 */
private Representation cuResponse(Map<String,Object> object) throws InternalServerErrorException {
  HashMap<String,Object> map=new HashMap<String,Object>();
  Object id=object.get(""String_Node_Str"");
  if (id != null && !(id instanceof String)) {
    throw new InternalServerErrorException(""String_Node_Str"");
  }
  map.put(""String_Node_Str"",(id != null ? (String)id : this.id));
  Object rev=object.get(""String_Node_Str"");
  if (rev != null && !(rev instanceof String)) {
    throw new InternalServerErrorException(""String_Node_Str"");
  }
  if (rev != null) {
    map.put(""String_Node_Str"",(String)rev);
  }
  Representation result=jacksonRepresentation(map);
  if (rev != null) {
    result.setTag(new Tag((String)rev,false));
  }
  return result;
}"
13337,"/** 
 * TODO: Description.
 * @returns TODO.
 * @throws ObjectSetException TODO.
 */
private Map<String,Object> readObject() throws ResourceException {
  try {
    Map<String,Object> object=objectSet.read(id);
    Status status=conditions.getStatus(getMethod(),true,getTag(object),null);
    if (status.isError()) {
      throw new ResourceException(status);
    }
    return object;
  }
 catch (  ObjectSetException ose) {
    throw new ResourceException(ose);
  }
}","/** 
 * TODO: Description.
 * @returns TODO.
 * @throws ObjectSetException TODO.
 */
private Map<String,Object> readObject() throws ResourceException {
  try {
    Map<String,Object> object=objectSet.read(id);
    Status status=conditions.getStatus(getMethod(),true,getTag(object),null);
    if (status != null && status.isError()) {
      throw new ResourceException(status);
    }
    return object;
  }
 catch (  ObjectSetException ose) {
    throw new ResourceException(ose);
  }
}"
13338,"@Override protected void service(HttpServletRequest req,HttpServletResponse res) throws ServletException, IOException {
  if (adapter == null) {
    throw new ServletException(""String_Node_Str"");
  }
  adapter.service(req,res);
}","@Override protected void service(HttpServletRequest req,HttpServletResponse res) throws ServletException, IOException {
  if (adapter == null) {
    throw new ServletException(""String_Node_Str"");
  }
  InvokeContext.getContext().pushActivityId(UUID.randomUUID().toString());
  try {
    adapter.service(req,res);
  }
  finally {
    InvokeContext.getContext().popActivityId();
  }
}"
13339,"@Deactivate protected void deactivate(ComponentContext context){
  this.context=null;
  mappings.clear();
}","@Deactivate protected void deactivate(ComponentContext context){
  mappings.clear();
  this.context=null;
}"
13340,"/** 
 * Returns a new script object for the provided script configuration object.
 * @param config configuration object for script.
 * @return a new script instance, or {@code null} if {@code config} is {@code null}.
 * @throws JsonNodeException if the script configuration object or source is malformed.
 */
public static Script newInstance(JsonNode config) throws JsonNodeException {
  if (config == null) {
    return null;
  }
  for (  ScriptFactory factory : FACTORIES) {
    Script script=factory.newInstance(config);
    if (script != null) {
      return script;
    }
  }
  JsonNode name=config.get(""String_Node_Str"");
  throw new JsonNodeException(name,""String_Node_Str"" + name.asString() + ""String_Node_Str"");
}","/** 
 * Returns a new script object for the provided script configuration object.
 * @param config configuration object for script.
 * @return a new script instance, or {@code null} if {@code config} is {@code null}.
 * @throws JsonNodeException if the script configuration object or source is malformed.
 */
public static Script newInstance(JsonNode config) throws JsonNodeException {
  if (config == null || config.isNull()) {
    return null;
  }
  for (  ScriptFactory factory : FACTORIES) {
    Script script=factory.newInstance(config);
    if (script != null) {
      return script;
    }
  }
  JsonNode type=config.get(""String_Node_Str"");
  throw new JsonNodeException(type,""String_Node_Str"" + type.asString() + ""String_Node_Str"");
}"
13341,"/** 
 * TODO: Description.
 * @param targetId TODO.
 * @throws SynchronizationException TODO.
 */
private void updateTargetObject(JsonNode target) throws SynchronizationException {
  try {
    service.getRouter().update(target.get(""String_Node_Str"").required().asString(),target.get(""String_Node_Str"").asString(),target.asMap());
  }
 catch (  JsonNodeException jne) {
    throw new SynchronizationException(jne);
  }
catch (  ObjectSetException ose) {
    throw new SynchronizationException(ose);
  }
}","/** 
 * TODO: Description.
 * @param targetId TODO.
 * @throws SynchronizationException TODO.
 */
private void updateTargetObject(JsonNode target) throws SynchronizationException {
  try {
    service.getRouter().update(targetObjectSet + '/' + target.get(""String_Node_Str"").required().asString(),target.get(""String_Node_Str"").asString(),target.asMap());
  }
 catch (  JsonNodeException jne) {
    throw new SynchronizationException(jne);
  }
catch (  ObjectSetException ose) {
    LOGGER.debug(""String_Node_Str"",ose);
    throw new SynchronizationException(ose);
  }
}"
13342,"/** 
 * TODO: Description.
 * @param targetId TODO.
 * @throws SynchronizationException TODO.
 */
private void createTargetObject(JsonNode target) throws SynchronizationException {
  StringBuilder sb=new StringBuilder();
  sb.append(targetObjectSet);
  if (target.get(""String_Node_Str"").isString()) {
    sb.append('/').append(target.get(""String_Node_Str"").asString());
  }
  try {
    service.getRouter().create(sb.toString(),target.asMap());
  }
 catch (  JsonNodeException jne) {
    throw new SynchronizationException(jne);
  }
catch (  ObjectSetException ose) {
    throw new SynchronizationException(ose);
  }
}","/** 
 * TODO: Description.
 * @param targetId TODO.
 * @throws SynchronizationException TODO.
 */
private void createTargetObject(JsonNode target) throws SynchronizationException {
  StringBuilder sb=new StringBuilder();
  sb.append(targetObjectSet);
  if (target.get(""String_Node_Str"").isString()) {
    sb.append('/').append(target.get(""String_Node_Str"").asString());
  }
  try {
    service.getRouter().create(sb.toString(),target.asMap());
  }
 catch (  JsonNodeException jne) {
    throw new SynchronizationException(jne);
  }
catch (  ObjectSetException ose) {
    LOGGER.debug(""String_Node_Str"",ose);
    throw new SynchronizationException(ose);
  }
}"
13343,"/** 
 * TODO: Description.
 * @param objectSet TODO.
 * @param id TODO.
 * @throws NullPointerException if {@code targetId} is {@code null}.
 * @throws SynchronizationException TODO.
 */
private JsonNode readObject(String objectSet,String id) throws SynchronizationException {
  if (id == null) {
    throw new NullPointerException();
  }
  try {
    return new JsonNode(service.getRouter().read(objectSet + '/' + id));
  }
 catch (  NotFoundException nfe) {
    return null;
  }
catch (  ObjectSetException ose) {
    throw new SynchronizationException(ose);
  }
}","/** 
 * TODO: Description.
 * @param objectSet TODO.
 * @param id TODO.
 * @throws NullPointerException if {@code targetId} is {@code null}.
 * @throws SynchronizationException TODO.
 */
private JsonNode readObject(String objectSet,String id) throws SynchronizationException {
  if (id == null) {
    throw new NullPointerException();
  }
  try {
    return new JsonNode(service.getRouter().read(objectSet + '/' + id));
  }
 catch (  NotFoundException nfe) {
    return null;
  }
catch (  ObjectSetException ose) {
    LOGGER.debug(""String_Node_Str"",ose);
    throw new SynchronizationException(ose);
  }
}"
13344,"/** 
 * TODO: Description.
 * @param target TODO.
 * @throws SynchronizationException TODO.
 */
private void deleteTargetObject(JsonNode target) throws SynchronizationException {
  if (target.get(""String_Node_Str"").isString()) {
    try {
      service.getRouter().delete(targetObjectSet + '/' + target.get(""String_Node_Str"").asString(),target.get(""String_Node_Str"").asString());
    }
 catch (    JsonNodeException jne) {
      throw new SynchronizationException(jne);
    }
catch (    NotFoundException nfe) {
    }
catch (    ObjectSetException ose) {
      throw new SynchronizationException(ose);
    }
  }
}","/** 
 * TODO: Description.
 * @param target TODO.
 * @throws SynchronizationException TODO.
 */
private void deleteTargetObject(JsonNode target) throws SynchronizationException {
  if (target.get(""String_Node_Str"").isString()) {
    try {
      service.getRouter().delete(targetObjectSet + '/' + target.get(""String_Node_Str"").asString(),target.get(""String_Node_Str"").asString());
    }
 catch (    JsonNodeException jne) {
      throw new SynchronizationException(jne);
    }
catch (    NotFoundException nfe) {
    }
catch (    ObjectSetException ose) {
      LOGGER.debug(""String_Node_Str"",ose);
      throw new SynchronizationException(ose);
    }
  }
}"
13345,"/** 
 * TODO: Description.
 * @throws SynchronizationException TODO.
 */
private void assessSituation() throws SynchronizationException {
  situation=null;
  if (!isTargetValid()) {
    return;
  }
  String targetId=(targetObject != null ? targetObject.get(""String_Node_Str"").asString() : null);
  if (targetId != null) {
    linkObject.getLinkForTarget(targetId);
  }
  if (reconId != null && reconId.equals(linkObject.reconId)) {
    situation=null;
  }
 else   if (linkObject._id == null || linkObject.sourceId == null) {
    situation=Situation.UNQUALIFIED;
  }
 else {
    sourceObject=readObject(sourceObjectSet,linkObject.sourceId);
    if (sourceObject == null || !isSourceValid()) {
      situation=Situation.UNQUALIFIED;
    }
 else {
      situation=Situation.CONFIRMED;
    }
  }
}","/** 
 * TODO: Description.
 * @throws SynchronizationException TODO.
 */
private void assessSituation() throws SynchronizationException {
  situation=null;
  if (!isTargetValid()) {
    return;
  }
  String targetId=(targetObject != null ? targetObject.get(""String_Node_Str"").asString() : null);
  if (targetId != null) {
    linkObject.getLinkForTarget(targetId);
  }
  if (reconId != null && reconId.equals(linkObject.reconId)) {
    return;
  }
 else   if (linkObject._id == null || linkObject.sourceId == null) {
    situation=Situation.UNQUALIFIED;
  }
 else {
    sourceObject=readObject(sourceObjectSet,linkObject.sourceId);
    if (sourceObject == null || !isSourceValid()) {
      situation=Situation.UNQUALIFIED;
    }
 else {
      situation=Situation.CONFIRMED;
    }
  }
}"
13346,"@Override public Map<String,Object> read(String id) throws ObjectSetException {
  Map<String,Object> object=service.getRepository().read(repoId(id));
  onRetrieve(object);
  execScript(onRead,object);
  return object;
}","@Override public Map<String,Object> read(String id) throws ObjectSetException {
  LOGGER.debug(""String_Node_Str"",name,id);
  Map<String,Object> object=service.getRepository().read(repoId(id));
  onRetrieve(object);
  execScript(onRead,object);
  return object;
}"
13347,"/** 
 * Constructs a new managed object set.
 * @param config configuration object to use to initialize managed object set.
 * @throws JsonNodeException if the configuration is malformed.
 */
public ManagedObjectSet(ManagedObjectService service,JsonNode config) throws JsonNodeException {
  this.service=service;
  name=config.get(""String_Node_Str"").required().asString();
  schema=config.get(""String_Node_Str"").expect(Map.class);
  onCreate=Scripts.newInstance(config.get(""String_Node_Str""));
  onRead=Scripts.newInstance(config.get(""String_Node_Str""));
  onUpdate=Scripts.newInstance(config.get(""String_Node_Str""));
  onDelete=Scripts.newInstance(config.get(""String_Node_Str""));
  onValidate=Scripts.newInstance(config.get(""String_Node_Str""));
  for (  JsonNode node : config.get(""String_Node_Str"").expect(List.class)) {
    properties.add(new ManagedObjectProperty(node));
  }
}","/** 
 * Constructs a new managed object set.
 * @param config configuration object to use to initialize managed object set.
 * @throws JsonNodeException if the configuration is malformed.
 */
public ManagedObjectSet(ManagedObjectService service,JsonNode config) throws JsonNodeException {
  this.service=service;
  name=config.get(""String_Node_Str"").required().asString();
  schema=config.get(""String_Node_Str"").expect(Map.class);
  onCreate=Scripts.newInstance(config.get(""String_Node_Str""));
  onRead=Scripts.newInstance(config.get(""String_Node_Str""));
  onUpdate=Scripts.newInstance(config.get(""String_Node_Str""));
  onDelete=Scripts.newInstance(config.get(""String_Node_Str""));
  onValidate=Scripts.newInstance(config.get(""String_Node_Str""));
  for (  JsonNode node : config.get(""String_Node_Str"").expect(List.class)) {
    properties.add(new ManagedObjectProperty(node));
  }
  LOGGER.debug(""String_Node_Str"",name);
}"
13348,"@Override public Map<String,Object> query(String id,Map<String,Object> params) throws ObjectSetException {
  return service.getRepository().query(repoId(id),params);
}","@Override public Map<String,Object> query(String id,Map<String,Object> params) throws ObjectSetException {
  LOGGER.debug(""String_Node_Str"",name,id);
  return service.getRepository().query(repoId(id),params);
}"
13349,"@Override public void update(String id,String rev,Map<String,Object> object) throws ObjectSetException {
  Map<String,Object> oldObject=service.getRepository().read(repoId(id));
  if (onUpdate != null) {
    HashMap<String,Object> scope=new HashMap<String,Object>();
    scope.put(""String_Node_Str"",oldObject);
    scope.put(""String_Node_Str"",object);
    try {
      onUpdate.exec(scope);
    }
 catch (    ScriptThrownException ste) {
      throw new ForbiddenException(ste.getValue().toString());
    }
catch (    ScriptException se) {
      throw new InternalServerErrorException(se.getMessage());
    }
  }
  onStore(object);
  service.getRepository().update(repoId(id),rev,object);
  try {
    for (    SynchronizationListener listener : listeners) {
      listener.onUpdate(routeId(id),oldObject,object);
    }
  }
 catch (  SynchronizationException se) {
    throw new InternalServerErrorException(se);
  }
}","@Override public void update(String id,String rev,Map<String,Object> object) throws ObjectSetException {
  LOGGER.debug(""String_Node_Str"",""String_Node_Str"" + name + ""String_Node_Str""+ id+ ""String_Node_Str""+ rev);
  Map<String,Object> oldObject=service.getRepository().read(repoId(id));
  if (onUpdate != null) {
    HashMap<String,Object> scope=new HashMap<String,Object>();
    scope.put(""String_Node_Str"",oldObject);
    scope.put(""String_Node_Str"",object);
    try {
      onUpdate.exec(scope);
    }
 catch (    ScriptThrownException ste) {
      throw new ForbiddenException(ste.getValue().toString());
    }
catch (    ScriptException se) {
      throw new InternalServerErrorException(se.getMessage());
    }
  }
  onStore(object);
  service.getRepository().update(repoId(id),rev,object);
  try {
    for (    SynchronizationListener listener : listeners) {
      listener.onUpdate(routeId(id),oldObject,object);
    }
  }
 catch (  SynchronizationException se) {
    throw new InternalServerErrorException(se);
  }
}"
13350,"@Override public void delete(String id,String rev) throws ObjectSetException {
  if (onDelete != null) {
    Map<String,Object> object=service.getRepository().read(repoId(id));
    execScript(onDelete,object);
  }
  service.getRepository().delete(repoId(id),rev);
  try {
    for (    SynchronizationListener listener : listeners) {
      listener.onDelete(routeId(id));
    }
  }
 catch (  SynchronizationException se) {
    throw new InternalServerErrorException(se);
  }
}","@Override public void delete(String id,String rev) throws ObjectSetException {
  LOGGER.debug(""String_Node_Str"",""String_Node_Str"" + name + ""String_Node_Str""+ id+ ""String_Node_Str""+ rev);
  if (onDelete != null) {
    Map<String,Object> object=service.getRepository().read(repoId(id));
    execScript(onDelete,object);
  }
  service.getRepository().delete(repoId(id),rev);
  try {
    for (    SynchronizationListener listener : listeners) {
      listener.onDelete(routeId(id));
    }
  }
 catch (  SynchronizationException se) {
    throw new InternalServerErrorException(se);
  }
}"
13351,"@Override public void create(String id,Map<String,Object> object) throws ObjectSetException {
  execScript(onCreate,object);
  onStore(object);
  if (object.containsKey(""String_Node_Str"")) {
    id=object.get(""String_Node_Str"").toString();
  }
  if (id == null) {
    id=UUID.randomUUID().toString();
    object.put(""String_Node_Str"",id);
  }
  service.getRepository().create(repoId(id),object);
  try {
    for (    SynchronizationListener listener : listeners) {
      listener.onCreate(routeId(id),object);
    }
  }
 catch (  SynchronizationException se) {
    throw new InternalServerErrorException(se);
  }
}","@Override public void create(String id,Map<String,Object> object) throws ObjectSetException {
  LOGGER.debug(""String_Node_Str"",name,id);
  execScript(onCreate,object);
  onStore(object);
  if (object.containsKey(""String_Node_Str"")) {
    id=object.get(""String_Node_Str"").toString();
  }
  if (id == null) {
    id=UUID.randomUUID().toString();
    object.put(""String_Node_Str"",id);
  }
  service.getRepository().create(repoId(id),object);
  try {
    for (    SynchronizationListener listener : listeners) {
      listener.onCreate(routeId(id),object);
    }
  }
 catch (  SynchronizationException se) {
    throw new InternalServerErrorException(se);
  }
}"
13352,"/** 
 * TODO: Description. <p> This method exects a   {@code ""sourceQuery""} defined with a parameter of{@code ""sourceId""}.
 * @param targetId TODO.
 * @throws SynchronizationException TODO.
 */
void getLinkForTarget(String targetId) throws SynchronizationException {
  clear();
  if (targetId != null) {
    JsonNode query=new JsonNode(new HashMap<String,Object>());
    query.put(QueryConstants.QUERY_ID,""String_Node_Str"");
    query.put(""String_Node_Str"",""String_Node_Str"");
    getLink(query);
  }
}","/** 
 * TODO: Description. <p> This method exects a   {@code ""sourceQuery""} defined with a parameter of{@code ""sourceId""}.
 * @param targetId TODO.
 * @throws SynchronizationException TODO.
 */
void getLinkForTarget(String targetId) throws SynchronizationException {
  clear();
  if (targetId != null) {
    JsonNode query=new JsonNode(new HashMap<String,Object>());
    query.put(QueryConstants.QUERY_ID,""String_Node_Str"");
    query.put(""String_Node_Str"",targetId);
    getLink(query);
  }
}"
13353,"/** 
 * Coerce the   {@code source} object to an object of {@code clazz} type.<p/>
 * @param < T >
 * @param source
 * @param clazz
 * @return
 * @throws NumberFormatException
 * @throws URISyntaxException
 * @throws UnsupportedOperationException
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T coercedTypeCasting(Object source,Class<T> clazz) throws IllegalArgumentException {
  if (null == clazz) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Class<T> targetClazz=clazz;
  Class sourceClass=(source == null ? null : source.getClass());
  boolean coerced=false;
  T result=null;
  try {
    if (source == null) {
      return null;
    }
    if (targetClazz.equals(Object.class)) {
      if ((Number.class.isAssignableFrom(sourceClass)) || (int.class == clazz) || (double.class == clazz)|| (float.class == clazz)|| (long.class == clazz)) {
        return (T)source;
      }
 else       if ((Boolean.class.isAssignableFrom(sourceClass)) || (boolean.class == clazz)) {
        return (T)source;
      }
 else       if (String.class.isAssignableFrom(sourceClass)) {
        return (T)source;
      }
 else       if (Map.class.isAssignableFrom(sourceClass)) {
        return (T)source;
      }
 else       if (List.class.isAssignableFrom(sourceClass)) {
        return (T)source;
      }
 else       if (sourceClass == QualifiedUid.class) {
        Map<String,Object> v=new HashMap<String,Object>(2);
        v.put(""String_Node_Str"",((QualifiedUid)source).getUid().getUidValue());
        v.put(""String_Node_Str"",((QualifiedUid)source).getObjectClass().getObjectClassValue());
        return (T)v;
      }
 else       if (sourceClass == Script.class) {
        Map<String,Object> v=new HashMap<String,Object>(2);
        v.put(""String_Node_Str"",((Script)source).getScriptLanguage());
        v.put(""String_Node_Str"",((Script)source).getScriptText());
        return (T)v;
      }
 else {
        targetClazz=(Class<T>)String.class;
      }
    }
    if (targetClazz.isAssignableFrom(sourceClass)) {
      return (T)source;
    }
 else     if (targetClazz == sourceClass) {
      return (T)source;
    }
 else     if (targetClazz.equals(java.math.BigDecimal.class)) {
      if (Double.class.isAssignableFrom(sourceClass) || sourceClass == double.class) {
        result=(T)BigDecimal.valueOf((Double)source);
        coerced=true;
      }
 else       if (Integer.class.isAssignableFrom(sourceClass) || sourceClass == int.class) {
        result=(T)BigDecimal.valueOf((Integer)source);
        coerced=true;
      }
 else       if (Long.class.isAssignableFrom(sourceClass) || sourceClass == long.class) {
        result=(T)BigDecimal.valueOf((Long)source);
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        java.math.BigDecimal v=new java.math.BigDecimal((String)source);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(java.math.BigInteger.class)) {
      if (Long.class.isAssignableFrom(sourceClass) || sourceClass == long.class) {
        result=(T)BigInteger.valueOf((Long)source);
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        java.math.BigInteger v=new java.math.BigInteger((String)source);
        result=targetClazz.cast(v);
        coerced=true;
      }
 else {
        result=(T)BigInteger.valueOf(coercedTypeCasting(source,Long.class));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(boolean.class) || targetClazz.equals(Boolean.class)) {
      if (sourceClass == Boolean.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        int val=((Integer)source).intValue();
        if (val == 0) {
          result=targetClazz.cast(Boolean.FALSE);
          coerced=true;
        }
 else         if (val == 1) {
          result=targetClazz.cast(Boolean.TRUE);
          coerced=true;
        }
      }
 else       if (sourceClass == String.class) {
        String s=(String)source;
        if (s.equalsIgnoreCase(""String_Node_Str"") || s.equalsIgnoreCase(""String_Node_Str"")) {
          result=targetClazz.cast(Boolean.valueOf((String)source));
          coerced=true;
        }
      }
    }
 else     if (targetClazz.equals(byte[].class)) {
      if (sourceClass == String.class) {
        result=targetClazz.cast(((String)source).getBytes());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Base64.decode((String)source));
        coerced=true;
      }
 else       if (sourceClass == GuardedByteArray.class) {
        GuardedByteArray gba=(GuardedByteArray)source;
        byte[] byteArray=decrypt(gba);
        result=targetClazz.cast(byteArray);
        coerced=true;
      }
    }
 else     if ((targetClazz.equals(Character.class)) || (targetClazz.equals(char.class))) {
      if (sourceClass == String.class) {
        Character v=((String)source).charAt(0);
        result=(T)v;
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Character[].class)) {
      if (sourceClass == String.class) {
        char[] charArray=((String)source).toCharArray();
        Character[] characterArray=new Character[charArray.length];
        for (int i=0; i < charArray.length; i++) {
          characterArray[i]=new Character(charArray[i]);
        }
        result=targetClazz.cast(characterArray);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(char[].class)) {
      if (sourceClass == String.class) {
        char[] charArray=((String)source).toCharArray();
        result=targetClazz.cast(charArray);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Date.class)) {
      if (sourceClass == String.class) {
      }
    }
 else     if (targetClazz.equals(double.class)) {
      if (sourceClass == Double.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == int.class) {
        result=(T)Double.valueOf((Integer.valueOf((Integer)source).doubleValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Double.valueOf(((Integer)source).doubleValue());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Double.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Double.class)) {
      if (sourceClass == double.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == int.class) {
        result=(T)Double.valueOf((Integer.valueOf((Integer)source).doubleValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Double.valueOf(((Integer)source).doubleValue());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Double.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(java.io.File.class)) {
      if (sourceClass == String.class) {
        File file=new File((String)source);
        result=targetClazz.cast(file);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(float.class) || targetClazz.equals(Float.class)) {
      if (sourceClass == Float.class || sourceClass == float.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == Double.class || sourceClass == double.class) {
        result=(T)new Float((Double)source);
        coerced=true;
      }
 else       if (sourceClass == int.class) {
        result=(T)Float.valueOf((Integer.valueOf((Integer)source).floatValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Float.valueOf(((Integer)source).floatValue());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Float.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(GuardedByteArray.class)) {
      if (sourceClass == String.class) {
        byte[] byteArray=((String)source).getBytes();
        GuardedByteArray v=new GuardedByteArray(byteArray);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(GuardedString.class)) {
      if (sourceClass == String.class) {
        char[] charArray=((String)source).toCharArray();
        GuardedString v=new GuardedString(charArray);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(int.class) || targetClazz.equals(Integer.class)) {
      if (sourceClass == Integer.class || sourceClass == int.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=(T)Integer.valueOf((String)source);
        coerced=true;
      }
 else       if (sourceClass == Float.class) {
        result=targetClazz.cast(new Integer(((Float)source).intValue()));
        coerced=true;
      }
 else       if (sourceClass == Long.class) {
        Long l=(Long)source;
        if (l.longValue() <= Integer.MAX_VALUE) {
          result=targetClazz.cast(new Integer(l.intValue()));
          coerced=true;
        }
      }
 else       if (sourceClass == Boolean.class) {
        boolean val=((Boolean)source).booleanValue();
        if (val) {
          result=targetClazz.cast(new Integer(1));
        }
 else {
          result=targetClazz.cast(new Integer(0));
        }
        coerced=true;
      }
    }
 else     if (targetClazz.equals(long.class) || targetClazz.equals(Long.class)) {
      if (sourceClass == int.class) {
        result=(T)Long.valueOf((Integer.valueOf((Integer)source).longValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Long.valueOf(((Integer)source).longValue());
        coerced=true;
      }
 else       if (sourceClass == Long.class || sourceClass == long.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Long.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Name.class)) {
      if (sourceClass == String.class) {
        result=targetClazz.cast(new Name((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(ObjectClass.class)) {
      if (sourceClass == String.class) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage(""String_Node_Str"");
        sb.setScriptText(""String_Node_Str"");
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
    }
 else     if (targetClazz.equals(QualifiedUid.class)) {
      if (sourceClass == String.class) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage(""String_Node_Str"");
        sb.setScriptText(""String_Node_Str"");
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Script.class)) {
      if (sourceClass == String.class) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage(""String_Node_Str"");
        sb.setScriptText(""String_Node_Str"");
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
 else       if (Map.class.isAssignableFrom(sourceClass)) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage((String)((Map)source).get(""String_Node_Str""));
        sb.setScriptText((String)((Map)source).get(""String_Node_Str""));
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
    }
 else     if (targetClazz.equals(String.class)) {
      if (sourceClass == byte[].class) {
        result=(T)new String((byte[])source);
        coerced=true;
      }
 else       if (sourceClass == char.class) {
        result=(T)new String((char[])source);
        coerced=true;
      }
 else       if (sourceClass == Character[].class) {
        Character[] characterArray=(Character[])source;
        char[] charArray=new char[characterArray.length];
        for (int i=0; i < characterArray.length; i++) {
          charArray[i]=characterArray[i];
        }
        result=(T)new String(charArray);
        coerced=true;
      }
 else       if (sourceClass == Double.class) {
        String s=((Double)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Float.class) {
        String s=((Float)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Boolean.class) {
        Boolean b=(Boolean)source;
        result=targetClazz.cast(Boolean.toString(b.booleanValue()));
        coerced=true;
      }
 else       if (sourceClass == Long.class) {
        String s=((Long)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        String s=((Integer)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.math.BigInteger.class) {
        String s=((java.math.BigInteger)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.math.BigDecimal.class) {
        String s=((java.math.BigDecimal)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.io.File.class) {
        File file=(File)source;
        String s=file.getPath();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.net.URI.class) {
        java.net.URI uri=(java.net.URI)source;
        String s=uri.toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Character.class) {
        Character c=(Character)source;
        char[] charArray=new char[1];
        charArray[0]=c.charValue();
        String s=new String(charArray);
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == GuardedString.class) {
        String s=decrypt((GuardedString)source);
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == GuardedByteArray.class) {
        byte[] s=decrypt((GuardedByteArray)source);
        result=targetClazz.cast(new String(s));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Uid.class)) {
      if (sourceClass == String.class) {
        Uid v=new Uid((String)source);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(java.net.URI.class)) {
      if (sourceClass == String.class) {
        try {
          java.net.URI v=new java.net.URI((String)source);
          result=targetClazz.cast(v);
          coerced=true;
        }
 catch (        URISyntaxException e) {
          throw new IOException(e);
        }
      }
    }
  }
 catch (  Exception e) {
    throw new IllegalArgumentException(source.getClass().getCanonicalName() + ""String_Node_Str"" + targetClazz.getCanonicalName(),e);
  }
  if (coerced == false) {
    throw new IllegalArgumentException(source.getClass().getCanonicalName() + ""String_Node_Str"" + targetClazz.getCanonicalName());
  }
  return result;
}","/** 
 * Coerce the   {@code source} object to an object of {@code clazz} type.<p/>
 * @param < T >
 * @param source
 * @param clazz
 * @return
 * @throws NumberFormatException
 * @throws URISyntaxException
 * @throws UnsupportedOperationException
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T coercedTypeCasting(Object source,Class<T> clazz) throws IllegalArgumentException {
  if (null == clazz) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Class<T> targetClazz=clazz;
  Class sourceClass=(source == null ? null : source.getClass());
  boolean coerced=false;
  T result=null;
  try {
    if (source == null) {
      return null;
    }
    if (targetClazz.equals(Object.class)) {
      if ((Number.class.isAssignableFrom(sourceClass)) || (int.class == clazz) || (double.class == clazz)|| (float.class == clazz)|| (long.class == clazz)) {
        return (T)source;
      }
 else       if ((Boolean.class.isAssignableFrom(sourceClass)) || (boolean.class == clazz)) {
        return (T)source;
      }
 else       if (String.class.isAssignableFrom(sourceClass)) {
        return (T)source;
      }
 else       if (Map.class.isAssignableFrom(sourceClass)) {
        return (T)source;
      }
 else       if (List.class.isAssignableFrom(sourceClass)) {
        return (T)source;
      }
 else       if (sourceClass == QualifiedUid.class) {
        Map<String,Object> v=new HashMap<String,Object>(2);
        v.put(""String_Node_Str"",((QualifiedUid)source).getUid().getUidValue());
        v.put(""String_Node_Str"",((QualifiedUid)source).getObjectClass().getObjectClassValue());
        return (T)v;
      }
 else       if (sourceClass == Script.class) {
        Map<String,Object> v=new HashMap<String,Object>(2);
        v.put(""String_Node_Str"",((Script)source).getScriptLanguage());
        v.put(""String_Node_Str"",((Script)source).getScriptText());
        return (T)v;
      }
 else {
        targetClazz=(Class<T>)String.class;
      }
    }
    if (targetClazz.isAssignableFrom(sourceClass)) {
      return (T)source;
    }
 else     if (targetClazz == sourceClass) {
      return (T)source;
    }
 else     if (targetClazz.equals(java.math.BigDecimal.class)) {
      if (Double.class.isAssignableFrom(sourceClass) || sourceClass == double.class) {
        result=(T)BigDecimal.valueOf((Double)source);
        coerced=true;
      }
 else       if (Integer.class.isAssignableFrom(sourceClass) || sourceClass == int.class) {
        result=(T)BigDecimal.valueOf((Integer)source);
        coerced=true;
      }
 else       if (Long.class.isAssignableFrom(sourceClass) || sourceClass == long.class) {
        result=(T)BigDecimal.valueOf((Long)source);
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        java.math.BigDecimal v=new java.math.BigDecimal((String)source);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(java.math.BigInteger.class)) {
      if (Long.class.isAssignableFrom(sourceClass) || sourceClass == long.class) {
        result=(T)BigInteger.valueOf((Long)source);
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        java.math.BigInteger v=new java.math.BigInteger((String)source);
        result=targetClazz.cast(v);
        coerced=true;
      }
 else {
        result=(T)BigInteger.valueOf(coercedTypeCasting(source,Long.class));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(boolean.class) || targetClazz.equals(Boolean.class)) {
      if (sourceClass == Boolean.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        int val=((Integer)source).intValue();
        if (val == 0) {
          result=targetClazz.cast(Boolean.FALSE);
          coerced=true;
        }
 else         if (val == 1) {
          result=targetClazz.cast(Boolean.TRUE);
          coerced=true;
        }
      }
 else       if (sourceClass == String.class) {
        String s=(String)source;
        if (s.equalsIgnoreCase(""String_Node_Str"") || s.equalsIgnoreCase(""String_Node_Str"")) {
          result=targetClazz.cast(Boolean.valueOf((String)source));
          coerced=true;
        }
      }
    }
 else     if (targetClazz.equals(byte[].class)) {
      if (sourceClass == String.class) {
        result=targetClazz.cast(((String)source).getBytes());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Base64.decode((String)source));
        coerced=true;
      }
 else       if (sourceClass == GuardedByteArray.class) {
        GuardedByteArray gba=(GuardedByteArray)source;
        byte[] byteArray=decrypt(gba);
        result=targetClazz.cast(byteArray);
        coerced=true;
      }
    }
 else     if ((targetClazz.equals(Character.class)) || (targetClazz.equals(char.class))) {
      if (sourceClass == String.class) {
        Character v=((String)source).charAt(0);
        result=(T)v;
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Character[].class)) {
      if (sourceClass == String.class) {
        char[] charArray=((String)source).toCharArray();
        Character[] characterArray=new Character[charArray.length];
        for (int i=0; i < charArray.length; i++) {
          characterArray[i]=new Character(charArray[i]);
        }
        result=targetClazz.cast(characterArray);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(char[].class)) {
      if (sourceClass == String.class) {
        char[] charArray=((String)source).toCharArray();
        result=targetClazz.cast(charArray);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Date.class)) {
      if (sourceClass == String.class) {
      }
    }
 else     if (targetClazz.equals(double.class)) {
      if (sourceClass == Double.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == int.class) {
        result=(T)Double.valueOf((Integer.valueOf((Integer)source).doubleValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Double.valueOf(((Integer)source).doubleValue());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Double.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Double.class)) {
      if (sourceClass == double.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == int.class) {
        result=(T)Double.valueOf((Integer.valueOf((Integer)source).doubleValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Double.valueOf(((Integer)source).doubleValue());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Double.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(java.io.File.class)) {
      if (sourceClass == String.class) {
        result=(T)new File((String)source);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(float.class) || targetClazz.equals(Float.class)) {
      if (sourceClass == Float.class || sourceClass == float.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == Double.class || sourceClass == double.class) {
        result=(T)new Float((Double)source);
        coerced=true;
      }
 else       if (sourceClass == int.class) {
        result=(T)Float.valueOf((Integer.valueOf((Integer)source).floatValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Float.valueOf(((Integer)source).floatValue());
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Float.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(GuardedByteArray.class)) {
      if (sourceClass == String.class) {
        byte[] byteArray=((String)source).getBytes();
        GuardedByteArray v=new GuardedByteArray(byteArray);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(GuardedString.class)) {
      if (sourceClass == String.class) {
        char[] charArray=((String)source).toCharArray();
        GuardedString v=new GuardedString(charArray);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(int.class) || targetClazz.equals(Integer.class)) {
      if (sourceClass == Integer.class || sourceClass == int.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=(T)Integer.valueOf((String)source);
        coerced=true;
      }
 else       if (sourceClass == Float.class) {
        result=targetClazz.cast(new Integer(((Float)source).intValue()));
        coerced=true;
      }
 else       if (sourceClass == Long.class) {
        Long l=(Long)source;
        if (l.longValue() <= Integer.MAX_VALUE) {
          result=targetClazz.cast(new Integer(l.intValue()));
          coerced=true;
        }
      }
 else       if (sourceClass == Boolean.class) {
        boolean val=((Boolean)source).booleanValue();
        if (val) {
          result=targetClazz.cast(new Integer(1));
        }
 else {
          result=targetClazz.cast(new Integer(0));
        }
        coerced=true;
      }
    }
 else     if (targetClazz.equals(long.class) || targetClazz.equals(Long.class)) {
      if (sourceClass == int.class) {
        result=(T)Long.valueOf((Integer.valueOf((Integer)source).longValue()));
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        result=(T)Long.valueOf(((Integer)source).longValue());
        coerced=true;
      }
 else       if (sourceClass == Long.class || sourceClass == long.class) {
        result=(T)source;
        coerced=true;
      }
 else       if (sourceClass == String.class) {
        result=targetClazz.cast(Long.valueOf((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Name.class)) {
      if (sourceClass == String.class) {
        result=targetClazz.cast(new Name((String)source));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(ObjectClass.class)) {
      if (sourceClass == String.class) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage(""String_Node_Str"");
        sb.setScriptText(""String_Node_Str"");
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
    }
 else     if (targetClazz.equals(QualifiedUid.class)) {
      if (sourceClass == String.class) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage(""String_Node_Str"");
        sb.setScriptText(""String_Node_Str"");
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Script.class)) {
      if (sourceClass == String.class) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage(""String_Node_Str"");
        sb.setScriptText(""String_Node_Str"");
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
 else       if (Map.class.isAssignableFrom(sourceClass)) {
        ScriptBuilder sb=new ScriptBuilder();
        sb.setScriptLanguage((String)((Map)source).get(""String_Node_Str""));
        sb.setScriptText((String)((Map)source).get(""String_Node_Str""));
        result=targetClazz.cast(sb.build());
        coerced=true;
      }
    }
 else     if (targetClazz.equals(String.class)) {
      if (sourceClass == byte[].class) {
        result=(T)new String((byte[])source);
        coerced=true;
      }
 else       if (sourceClass == char.class) {
        result=(T)new String((char[])source);
        coerced=true;
      }
 else       if (sourceClass == Character[].class) {
        Character[] characterArray=(Character[])source;
        char[] charArray=new char[characterArray.length];
        for (int i=0; i < characterArray.length; i++) {
          charArray[i]=characterArray[i];
        }
        result=(T)new String(charArray);
        coerced=true;
      }
 else       if (sourceClass == Double.class) {
        String s=((Double)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Float.class) {
        String s=((Float)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Boolean.class) {
        Boolean b=(Boolean)source;
        result=targetClazz.cast(Boolean.toString(b.booleanValue()));
        coerced=true;
      }
 else       if (sourceClass == Long.class) {
        String s=((Long)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Integer.class) {
        String s=((Integer)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.math.BigInteger.class) {
        String s=((java.math.BigInteger)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.math.BigDecimal.class) {
        String s=((java.math.BigDecimal)source).toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.io.File.class) {
        File file=(File)source;
        String s=file.getPath();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == java.net.URI.class) {
        java.net.URI uri=(java.net.URI)source;
        String s=uri.toString();
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == Character.class) {
        Character c=(Character)source;
        char[] charArray=new char[1];
        charArray[0]=c.charValue();
        String s=new String(charArray);
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == GuardedString.class) {
        String s=decrypt((GuardedString)source);
        result=targetClazz.cast(s);
        coerced=true;
      }
 else       if (sourceClass == GuardedByteArray.class) {
        byte[] s=decrypt((GuardedByteArray)source);
        result=targetClazz.cast(new String(s));
        coerced=true;
      }
    }
 else     if (targetClazz.equals(Uid.class)) {
      if (sourceClass == String.class) {
        Uid v=new Uid((String)source);
        result=targetClazz.cast(v);
        coerced=true;
      }
    }
 else     if (targetClazz.equals(java.net.URI.class)) {
      if (sourceClass == String.class) {
        try {
          java.net.URI v=new java.net.URI((String)source);
          result=targetClazz.cast(v);
          coerced=true;
        }
 catch (        URISyntaxException e) {
          throw new IOException(e);
        }
      }
    }
  }
 catch (  Exception e) {
    throw new IllegalArgumentException(source.getClass().getCanonicalName() + ""String_Node_Str"" + targetClazz.getCanonicalName(),e);
  }
  if (coerced == false) {
    throw new IllegalArgumentException(source.getClass().getCanonicalName() + ""String_Node_Str"" + targetClazz.getCanonicalName());
  }
  return result;
}"
13354,"protected void initialiseLocalManager(ConnectorInfoManagerFactory factory,String connectorsArea){
  System.out.println(""String_Node_Str"" + connectorsArea);
  if (null != connectorsArea) {
    TRACE.info(""String_Node_Str"" + connectorsArea + ""String_Node_Str"");
    File dir=new File(connectorsArea);
    if (!dir.exists()) {
      String absolutePath=dir.getAbsolutePath();
      System.out.println(""String_Node_Str"" + absolutePath);
      TRACE.error(""String_Node_Str"" + absolutePath + ""String_Node_Str"");
    }
 else {
      try {
        System.out.println(""String_Node_Str"" + dir.getAbsoluteFile().toURI().toURL());
        URL[] bundleUrls=getConnectorURLs(dir.getAbsoluteFile().toURI().toURL());
        factory.getLocalManager(bundleUrls);
      }
 catch (      MalformedURLException e) {
        TRACE.error(""String_Node_Str"",e);
      }
    }
  }
 else {
    throw new ComponentException(""String_Node_Str"");
  }
}","protected void initialiseLocalManager(ConnectorInfoManagerFactory factory,String connectorsArea){
  if (null != connectorsArea) {
    try {
      String connectorsDir=URLDecoder.decode(connectorsArea,""String_Node_Str"");
      TRACE.info(""String_Node_Str"" + connectorsDir + ""String_Node_Str"");
      File dir=new File(connectorsDir);
      if (!dir.exists()) {
        String absolutePath=dir.getAbsolutePath();
        TRACE.error(""String_Node_Str"" + absolutePath + ""String_Node_Str"");
      }
 else {
        try {
          URL[] bundleUrls=getConnectorURLs(dir.getAbsoluteFile().toURI().toURL());
          factory.getLocalManager(bundleUrls);
        }
 catch (        MalformedURLException e) {
          TRACE.error(""String_Node_Str"",e);
        }
      }
    }
 catch (    UnsupportedEncodingException e) {
      throw new UndeclaredThrowableException(e);
    }
  }
 else {
    throw new ComponentException(""String_Node_Str"");
  }
}"
13355,"private URL[] getConnectorURLs(URL... resourceURLs){
  if (null == connectorURLs) {
    Set<URL> _bundleURLs=new HashSet<URL>();
    for (int j=0; j < resourceURLs.length; j++) {
      try {
        URL bundleDirUrl=resourceURLs[j];
        System.out.println(""String_Node_Str"" + bundleDirUrl);
        TRACE.info(""String_Node_Str"",bundleDirUrl);
        Vector<URL> urls=null;
        if (""String_Node_Str"".equals(bundleDirUrl.getProtocol())) {
          File file=new File(bundleDirUrl.getFile());
          if (file.isDirectory()) {
            FileFilter filter=new FileFilter(){
              @Override public boolean accept(              File f){
                return (f.isDirectory()) || (f.getName().endsWith(""String_Node_Str""));
              }
            }
;
            File[] files=file.listFiles(filter);
            urls=new Vector<URL>(files.length);
            for (int i=0; i < files.length; ++i) {
              File subFile=files[i];
              String fname=subFile.getName();
              TRACE.info(""String_Node_Str"",fname);
              urls.add(new URL(bundleDirUrl,fname));
            }
          }
        }
 else         if ((""String_Node_Str"".equals(bundleDirUrl.getProtocol())) || (""String_Node_Str"".equals(bundleDirUrl.getProtocol()))) {
          urls=getJarFileListing(bundleDirUrl,""String_Node_Str"" + DEFAULT_CONNECTORS_LOCATION + ""String_Node_Str"");
        }
 else {
          TRACE.info(""String_Node_Str"",bundleDirUrl.getProtocol());
        }
        if ((urls == null) || (urls.size() == 0)) {
          TRACE.info(""String_Node_Str"",bundleDirUrl);
        }
        if (null != urls) {
          _bundleURLs.addAll(urls);
        }
      }
 catch (      IOException ex) {
        TRACE.error(""String_Node_Str"",ex);
      }
    }
    if (TRACE.isDebugEnabled()) {
      for (      URL u : _bundleURLs) {
        TRACE.debug(""String_Node_Str"",u);
      }
    }
    connectorURLs=_bundleURLs.toArray(new URL[0]);
  }
  return connectorURLs;
}","private URL[] getConnectorURLs(URL... resourceURLs){
  if (null == connectorURLs) {
    Set<URL> _bundleURLs=new HashSet<URL>();
    for (int j=0; j < resourceURLs.length; j++) {
      try {
        URL bundleDirUrl=resourceURLs[j];
        TRACE.info(""String_Node_Str"",bundleDirUrl);
        Vector<URL> urls=null;
        if (""String_Node_Str"".equals(bundleDirUrl.getProtocol())) {
          File file=new File(bundleDirUrl.toURI());
          if (file.isDirectory()) {
            FileFilter filter=new FileFilter(){
              @Override public boolean accept(              File f){
                return (f.isDirectory()) || (f.getName().endsWith(""String_Node_Str""));
              }
            }
;
            File[] files=file.listFiles(filter);
            urls=new Vector<URL>(files.length);
            for (int i=0; i < files.length; ++i) {
              File subFile=files[i];
              String fname=subFile.getName();
              TRACE.info(""String_Node_Str"",fname);
              urls.add(new URL(bundleDirUrl,fname));
            }
          }
        }
 else         if ((""String_Node_Str"".equals(bundleDirUrl.getProtocol())) || (""String_Node_Str"".equals(bundleDirUrl.getProtocol()))) {
          urls=getJarFileListing(bundleDirUrl,""String_Node_Str"" + DEFAULT_CONNECTORS_LOCATION + ""String_Node_Str"");
        }
 else {
          TRACE.info(""String_Node_Str"",bundleDirUrl.getProtocol());
        }
        if ((urls == null) || (urls.size() == 0)) {
          TRACE.info(""String_Node_Str"",bundleDirUrl);
        }
        if (null != urls) {
          _bundleURLs.addAll(urls);
        }
      }
 catch (      IOException ex) {
        TRACE.error(""String_Node_Str"",ex);
      }
catch (      URISyntaxException e) {
        TRACE.error(""String_Node_Str"",e);
      }
    }
    if (TRACE.isDebugEnabled()) {
      for (      URL u : _bundleURLs) {
        TRACE.debug(""String_Node_Str"",u);
      }
    }
    connectorURLs=_bundleURLs.toArray(new URL[0]);
  }
  return connectorURLs;
}"
13356,"protected void unbind(ConnectorInfoProvider connectorInfoProvider){
  connectorInfoProvider=null;
  TRACE.info(""String_Node_Str"");
}","protected void unbind(ConnectorInfoProvider connectorInfoProvider){
  this.connectorInfoProvider=null;
  TRACE.info(""String_Node_Str"");
}"
13357,"@Test public void testCreateSystemConfiguration() throws URISyntaxException {
  ConnectorInfo xmlConnectorInfo=null;
  ConnectorKey key=new ConnectorKey(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  for (  ConnectorInfo info : testableConnectorInfoProvider.getAllConnectorInfo()) {
    if (key.equals(info.getConnectorKey())) {
      xmlConnectorInfo=info;
      break;
    }
  }
  Assert.assertNotNull(xmlConnectorInfo);
  APIConfiguration configuration=xmlConnectorInfo.createDefaultAPIConfiguration();
  URL xmlRoot=OpenICFProvisionerServiceXMLConnectorTest.class.getResource(""String_Node_Str"");
  Assert.assertNotNull(xmlRoot);
  URI xsdIcfFilePath=xmlRoot.toURI().resolve(""String_Node_Str"");
  configuration.getConfigurationProperties().setPropertyValue(""String_Node_Str"",xsdIcfFilePath.getPath());
  URI xsdFilePath=xmlRoot.toURI().resolve(""String_Node_Str"");
  configuration.getConfigurationProperties().setPropertyValue(""String_Node_Str"",xsdFilePath.getPath());
  URI xmlFilePath=xmlRoot.toURI().resolve(""String_Node_Str"");
  configuration.getConfigurationProperties().setPropertyValue(""String_Node_Str"",xmlFilePath.getPath());
  try {
    ObjectMapper mapper=new ObjectMapper();
    URL root=ObjectClassInfoHelperTest.class.getResource(""String_Node_Str"");
    mapper.writeValue(new File((new URL(root,""String_Node_Str"")).toURI()),testableConnectorInfoProvider.createSystemConfiguration(configuration,true));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","@Test public void testCreateSystemConfiguration() throws URISyntaxException {
  ConnectorInfo xmlConnectorInfo=null;
  ConnectorKey key=new ConnectorKey(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  for (  ConnectorInfo info : testableConnectorInfoProvider.getAllConnectorInfo()) {
    if (key.equals(info.getConnectorKey())) {
      xmlConnectorInfo=info;
      break;
    }
  }
  Assert.assertNotNull(xmlConnectorInfo);
  APIConfiguration configuration=xmlConnectorInfo.createDefaultAPIConfiguration();
  URL xmlRoot=OpenICFProvisionerServiceXMLConnectorTest.class.getResource(""String_Node_Str"");
  Assert.assertNotNull(xmlRoot);
  URI xsdIcfFilePath=xmlRoot.toURI().resolve(""String_Node_Str"");
  configuration.getConfigurationProperties().setPropertyValue(""String_Node_Str"",new File(xsdIcfFilePath));
  URI xsdFilePath=xmlRoot.toURI().resolve(""String_Node_Str"");
  configuration.getConfigurationProperties().setPropertyValue(""String_Node_Str"",new File(xsdFilePath));
  URI xmlFilePath=xmlRoot.toURI().resolve(""String_Node_Str"");
  configuration.getConfigurationProperties().setPropertyValue(""String_Node_Str"",new File(xmlFilePath));
  try {
    ObjectMapper mapper=new ObjectMapper();
    URL root=ObjectClassInfoHelperTest.class.getResource(""String_Node_Str"");
    mapper.writeValue(new File((new URL(root,""String_Node_Str"")).toURI()),testableConnectorInfoProvider.createSystemConfiguration(configuration,true));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
13358,"@BeforeTest public void beforeTest() throws Exception {
  String configurationFile=""String_Node_Str"" + OpenICFProvisionerServiceXMLConnectorTest.class.getCanonicalName() + ""String_Node_Str"";
  InputStream inputStream=TestLocalConnectorInfoProviderStub.class.getResourceAsStream(configurationFile);
  Assert.assertNotNull(inputStream,""String_Node_Str"" + configurationFile);
  ObjectMapper mapper=new ObjectMapper();
  JsonNode jsonConfiguration=new JsonNode(mapper.readValue(inputStream,Map.class));
  APIConfiguration config=new APIConfigurationImpl();
  builder=new OperationHelperBuilder(""String_Node_Str"",jsonConfiguration,config);
}","@BeforeTest public void beforeTest() throws Exception {
  String configurationFile=""String_Node_Str"" + OpenICFProvisionerServiceXMLConnectorTest.class.getCanonicalName() + ""String_Node_Str"";
  InputStream inputStream=OperationHelperImplTest.class.getResourceAsStream(configurationFile);
  Assert.assertNotNull(inputStream,""String_Node_Str"" + configurationFile);
  ObjectMapper mapper=new ObjectMapper();
  JsonNode jsonConfiguration=new JsonNode(mapper.readValue(inputStream,Map.class));
  APIConfiguration config=new APIConfigurationImpl();
  builder=new OperationHelperBuilder(""String_Node_Str"",jsonConfiguration,config);
}"
13359,"public void setViewSize(int width,int height){
  viewSize.onNext(new PointD(width,height));
  lastViewSize=new PointD(width,height);
}","public void setViewSize(int width,int height){
  viewSize.onNext(new PointD(width,height));
}"
13360,"public MapTileDrawable(int zoom,int x,int y,double screenX,double screenY){
  super(zoom,x,y);
  this.screenX=screenX;
  this.screenY=screenY;
}","public MapTileDrawable(int zoom,int x,int y,double size,double screenX,double screenY){
  super(zoom,x,y);
  this.size=size;
  this.screenX=screenX;
  this.screenY=screenY;
}"
13361,"public LatLngCalculator(final CoordinateProjection coordinateProjection,final Observable<PointD> pixelDelta,final Observable<LatLng> latLng){
  final Subject<LatLng,LatLng> latLngSubject=BehaviorSubject.create();
  pixelDelta.subscribe(new Action1<PointD>(){
    @Override public void call(    PointD pointD){
      Log.v(TAG,""String_Node_Str"" + pointD + ""String_Node_Str"");
      final double cx=mapState.offset.x + mapState.viewSize.x / 2.0;
      final double cy=mapState.offset.y + mapState.viewSize.y / 2.0;
      final PointD newPoint=new PointD(cx - pointD.x,cy - pointD.y);
      final LatLng newLatLng=coordinateProjection.fromPointToLatLng(newPoint,mapState.zoomLevel);
      latLngSubject.onNext(newLatLng);
    }
  }
);
  latLng.subscribe(new Action1<LatLng>(){
    @Override public void call(    LatLng latLng){
      LatLngCalculator.this.lastLatLng=latLng;
      latLngSubject.onNext(latLng);
    }
  }
);
  observable=latLngSubject;
}","public LatLngCalculator(final CoordinateProjection coordinateProjection,final Observable<PointD> pixelDelta,final Observable<LatLng> latLng){
  final Subject<LatLng,LatLng> latLngSubject=BehaviorSubject.create();
  pixelDelta.subscribe(new Action1<PointD>(){
    @Override public void call(    final PointD pixedDelta){
      Log.v(TAG,""String_Node_Str"" + pixedDelta + ""String_Node_Str"");
      final double cx=mapState.viewSize.x / 2.0 - mapState.offset.x;
      final double cy=mapState.viewSize.y / 2.0 - mapState.offset.y;
      final PointD newPoint=new PointD(cx - pixedDelta.x,cy - pixedDelta.y);
      final LatLng newLatLng=coordinateProjection.fromPointToLatLng(newPoint,mapState.zoomLevel);
      latLngSubject.onNext(newLatLng);
    }
  }
);
  latLng.subscribe(new Action1<LatLng>(){
    @Override public void call(    LatLng latLng){
      LatLngCalculator.this.lastLatLng=latLng;
      latLngSubject.onNext(latLng);
    }
  }
);
  observable=latLngSubject;
}"
13362,"static private Collection<MapTileDrawable> calculateMapTiles(final double tileSizePx,final Integer zoomLevel,final PointD viewSize,final PointD offset){
  final int firstTileX=(int)Math.floor(-offset.x / tileSizePx);
  final int firstTileY=(int)Math.floor(-offset.y / tileSizePx);
  final int numX=(int)Math.ceil(viewSize.x / tileSizePx);
  final int numY=(int)Math.ceil(viewSize.y / tileSizePx);
  final List<MapTileDrawable> mapTileList=new ArrayList<MapTileDrawable>();
  for (int i=firstTileX; i <= firstTileX + numX; i++) {
    for (int n=firstTileY; n <= firstTileY + numY; n++) {
      final MapTileDrawable mapTile=new MapTileDrawable(zoomLevel,i,n,i * tileSizePx + offset.x,n * tileSizePx + offset.y);
      mapTileList.add(mapTile);
    }
  }
  return mapTileList;
}","static private Collection<MapTileDrawable> calculateMapTiles(final double tileSizePx,final Integer zoomLevel,final PointD viewSize,final PointD offset){
  final int firstTileX=(int)Math.floor(-offset.x / tileSizePx);
  final int firstTileY=(int)Math.floor(-offset.y / tileSizePx);
  final int numX=(int)Math.ceil(viewSize.x / tileSizePx);
  final int numY=(int)Math.ceil(viewSize.y / tileSizePx);
  final List<MapTileDrawable> mapTileList=new ArrayList<MapTileDrawable>();
  for (int i=firstTileX; i <= firstTileX + numX; i++) {
    for (int n=firstTileY; n <= firstTileY + numY; n++) {
      final MapTileDrawable mapTile=new MapTileDrawable(zoomLevel,i,n,tileSizePx,i * tileSizePx + offset.x,n * tileSizePx + offset.y);
      mapTileList.add(mapTile);
    }
  }
  return mapTileList;
}"
13363,"@Override public boolean onTouch(View v,MotionEvent event){
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    lastTouch=new PointD(event.getX(),event.getY());
  break;
case MotionEvent.ACTION_MOVE:
if (lastTouch != null) {
  deltaStream.onNext(new PointD(event.getX() - lastTouch.x,event.getY() - lastTouch.y));
  lastTouch=new PointD(event.getX(),event.getY());
}
break;
case MotionEvent.ACTION_UP:
lastTouch=null;
break;
}
return true;
}","@Override public boolean onTouch(View v,MotionEvent event){
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    lastTouch=new PointD(event.getX(),event.getY());
  break;
case MotionEvent.ACTION_MOVE:
if (lastTouch != null) {
  final PointD delta=new PointD(event.getX() - lastTouch.x,event.getY() - lastTouch.y);
  deltaStream.onNext(delta);
  lastTouch=new PointD(event.getX(),event.getY());
}
break;
case MotionEvent.ACTION_UP:
lastTouch=null;
break;
}
return true;
}"
13364,"private void init(){
  paint=new Paint(Paint.ANTI_ALIAS_FLAG);
  this.setBackgroundColor(Color.LTGRAY);
  rectPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  rectPaint.setColor(Color.RED);
  rectPaint.setStyle(Paint.Style.STROKE);
}","private void init(){
  paint=new Paint(Paint.ANTI_ALIAS_FLAG);
  this.setBackgroundColor(Color.LTGRAY);
  rectPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  rectPaint.setColor(Color.RED);
  rectPaint.setStyle(Paint.Style.STROKE);
  textPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  textPaint.setColor(Color.BLACK);
  textPaint.setTextSize(20);
  textPaint.setTextAlign(Paint.Align.LEFT);
}"
13365,"@Override protected void onDraw(Canvas canvas){
  if (mapTiles == null) {
    return;
  }
  for (  MapTileDrawable mapTile : mapTiles) {
    final int hash=mapTile.tileHashCode();
    if (mapTileBitmaps.containsKey(hash)) {
      final Bitmap bitmap=mapTileBitmaps.get(hash);
      if (bitmap != null) {
        final float x=(float)mapTile.getScreenX();
        final float y=(float)mapTile.getScreenY();
        canvas.drawBitmap(bitmap,x,y,paint);
        canvas.drawRect(x,y,x + bitmap.getWidth() - 1,y + bitmap.getHeight() - 1,rectPaint);
      }
 else {
        Log.d(TAG,""String_Node_Str"" + mapTile);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"" + mapTile);
    }
  }
}","@Override protected void onDraw(final Canvas canvas){
  if (mapTiles == null) {
    return;
  }
  for (  MapTileDrawable mapTile : mapTiles) {
    final int hash=mapTile.tileHashCode();
    final float x=(float)mapTile.getScreenX();
    final float y=(float)mapTile.getScreenY();
    final Bitmap bitmap=mapTileBitmaps.get(hash);
    if (bitmap != null) {
      canvas.drawBitmap(bitmap,x,y,paint);
    }
 else {
      Log.d(TAG,""String_Node_Str"" + mapTile);
    }
    canvas.drawRect(x,y,x + (float)mapTile.getSize() - 1,y + (float)mapTile.getSize() - 1,rectPaint);
    canvas.drawText(mapTile.getX() + ""String_Node_Str"" + mapTile.getY(),x + 3,y + 20,textPaint);
  }
}"
13366,"public MapViewModel(final MapNetworkAdapter mapNetworkAdapter){
  this.mapNetworkAdapter=mapNetworkAdapter;
  dragDelta=PublishSubject.create();
  zoomLevel=new ZoomLevel(3);
  viewSize=PublishSubject.create();
  centerCoordSubject=BehaviorSubject.create(new LatLng(51.507351,-0.127758));
  coordinateProjection=new CoordinateProjection(mapNetworkAdapter.getTileSizePx());
  final LatLngCalculator latLngCalculator=new LatLngCalculator(coordinateProjection,dragDelta,centerCoordSubject);
  centerCoord=latLngCalculator.getObservable();
  final Subject<Collection<MapTileDrawable>,Collection<MapTileDrawable>> mapTilesSubject=BehaviorSubject.create();
  final Subject<MapTileBitmap,MapTileBitmap> loadedMapTilesSubject=PublishSubject.create();
  Observable<MapState> mapStateObservable=Observable.combineLatest(zoomLevel.getObservable().doOnNext(MapTileUtils.logOnNext(""String_Node_Str"")),viewSize.doOnNext(MapTileUtils.logOnNext(""String_Node_Str"")),centerCoord.doOnNext(MapTileUtils.logOnNext(""String_Node_Str"")),MapTileUtils.combineToMapState(coordinateProjection)).cache();
  latLngCalculator.setMapStateObservable(mapStateObservable);
  final Observable<Collection<MapTileDrawable>> mapTiles=mapStateObservable.map(MapTileUtils.calculateMapTiles(mapNetworkAdapter.getTileSizePx()));
  mapTiles.observeOn(AndroidSchedulers.mainThread()).subscribe(mapTilesSubject);
  mapTiles.flatMap(MapTileUtils.expandCollection).flatMap(MapTileUtils.loadMapTile(mapNetworkAdapter)).observeOn(AndroidSchedulers.mainThread()).subscribe(loadedMapTilesSubject);
  loadedMapTiles=loadedMapTilesSubject;
  this.mapTiles=mapTilesSubject;
}","public MapViewModel(final MapNetworkAdapter mapNetworkAdapter){
  this.mapNetworkAdapter=mapNetworkAdapter;
  dragDelta=PublishSubject.create();
  zoomLevel=new ZoomLevel(0);
  viewSize=PublishSubject.create();
  centerCoordSubject=BehaviorSubject.create(new LatLng(51.507351,-0.127758));
  coordinateProjection=new CoordinateProjection(mapNetworkAdapter.getTileSizePx());
  final LatLngCalculator latLngCalculator=new LatLngCalculator(coordinateProjection,dragDelta,centerCoordSubject);
  centerCoord=Observable.merge(centerCoordSubject,latLngCalculator.getObservable()).distinctUntilChanged();
  final Subject<Collection<MapTileDrawable>,Collection<MapTileDrawable>> mapTilesSubject=BehaviorSubject.create();
  final Subject<MapTileBitmap,MapTileBitmap> loadedMapTilesSubject=PublishSubject.create();
  Observable<MapState> mapStateObservable=Observable.combineLatest(zoomLevel.getObservable().doOnNext(MapTileUtils.logOnNext(""String_Node_Str"")),viewSize.doOnNext(MapTileUtils.logOnNext(""String_Node_Str"")),centerCoord.doOnNext(MapTileUtils.logOnNext(""String_Node_Str"")),MapTileUtils.combineToMapState(coordinateProjection)).cache();
  latLngCalculator.setMapStateObservable(mapStateObservable);
  final Observable<Collection<MapTileDrawable>> mapTiles=mapStateObservable.map(MapTileUtils.calculateMapTiles(mapNetworkAdapter.getTileSizePx()));
  mapTiles.observeOn(AndroidSchedulers.mainThread()).subscribe(mapTilesSubject);
  mapTiles.flatMap(MapTileUtils.expandCollection).flatMap(MapTileUtils.loadMapTile(mapNetworkAdapter)).observeOn(AndroidSchedulers.mainThread()).subscribe(loadedMapTilesSubject);
  loadedMapTiles=loadedMapTilesSubject;
  this.mapTiles=mapTilesSubject;
}"
13367,"private void maskBitmap(Bitmap bitmap,float xRatio,float yRatio,float widthRatio,float heightRatio){
  Canvas canvas=new Canvas(bitmap);
  Paint blackFill=new Paint();
  blackFill.setColor(Color.BLACK);
  blackFill.setStyle(Paint.Style.FILL);
  float left=bitmap.getWidth() * xRatio;
  float top=bitmap.getHeight() * xRatio;
  float right=bitmap.getWidth() * (xRatio + widthRatio);
  float bottom=bitmap.getWidth() * (yRatio + heightRatio);
  canvas.drawRect(left,top,right,bottom,blackFill);
}","private void maskBitmap(Bitmap bitmap,float xRatio,float yRatio,float widthRatio,float heightRatio){
  Canvas canvas=new Canvas(bitmap);
  Paint blackFill=new Paint();
  blackFill.setColor(Color.BLACK);
  blackFill.setStyle(Paint.Style.FILL);
  float left=bitmap.getWidth() * xRatio;
  float top=bitmap.getHeight() * yRatio;
  float right=bitmap.getWidth() * (xRatio + widthRatio);
  float bottom=bitmap.getHeight() * (yRatio + heightRatio);
  canvas.drawRect(left,top,right,bottom,blackFill);
}"
13368,"public void onMaskButtonClick(View view){
  Log.d(DEBUG_TAG,""String_Node_Str"");
  FastBitmapDrawable drawable=(FastBitmapDrawable)destinationImageView.getDrawable();
  Bitmap bitmap=drawable.getBitmap();
  maskBitmap(bitmap,0.1f,0.1f,0.8f,0.2f);
  destinationImageView.setImageBitmap(bitmap);
}","public void onMaskButtonClick(View view){
  Log.d(DEBUG_TAG,""String_Node_Str"");
  FastBitmapDrawable drawable=(FastBitmapDrawable)destinationImageView.getDrawable();
  Bitmap bitmap=drawable.getBitmap();
  maskBitmap(bitmap,0.03f,0.02f,0.45f,0.32f);
  destinationImageView.setImageBitmap(bitmap);
}"
13369,"public Mat transform(Mat src,MatOfPoint2f corners){
  Size size=getRectangleSize(corners);
  Mat result=Mat.zeros(size,src.type());
  MatOfPoint2f sortedCorners=sortCorners(corners);
  MatOfPoint2f imageOutline=getOutline(result);
  Mat transformation=Imgproc.getPerspectiveTransform(sortedCorners,imageOutline);
  Imgproc.warpPerspective(src,result,transformation,size);
  return result;
}","public Mat transform(Mat src,MatOfPoint2f corners){
  MatOfPoint2f sortedCorners=sortCorners(corners);
  Size size=getRectangleSize(sortedCorners);
  Log.d(DEBUG_TAG,String.format(""String_Node_Str"",size.width,size.height));
  Mat result=Mat.zeros(size,src.type());
  MatOfPoint2f imageOutline=getOutline(result);
  Mat transformation=Imgproc.getPerspectiveTransform(sortedCorners,imageOutline);
  Imgproc.warpPerspective(src,result,transformation,size);
  return result;
}"
13370,"private MatOfPoint2f sortCorners(MatOfPoint2f corners){
  Point center=getMassCenter(corners);
  List<Point> points=corners.toList();
  List<Point> topPoints=new ArrayList<Point>();
  List<Point> bottomPoints=new ArrayList<Point>();
  for (  Point point : points) {
    if (point.y < center.y) {
      topPoints.add(point);
    }
 else {
      bottomPoints.add(point);
    }
  }
  Point topLeft=topPoints.get(0).x > topPoints.get(1).x ? topPoints.get(1) : topPoints.get(0);
  Point topRight=topPoints.get(0).x > topPoints.get(1).x ? topPoints.get(0) : topPoints.get(1);
  Point bottomLeft=bottomPoints.get(0).x > bottomPoints.get(1).x ? bottomPoints.get(1) : bottomPoints.get(0);
  Point bottomRight=bottomPoints.get(0).x > bottomPoints.get(1).x ? bottomPoints.get(0) : bottomPoints.get(1);
  MatOfPoint2f result=new MatOfPoint2f();
  Point[] sortedPoints={topLeft,topRight,bottomRight,bottomLeft};
  result.fromArray(sortedPoints);
  return result;
}","private MatOfPoint2f sortCorners(MatOfPoint2f corners){
  Point center=getMassCenter(corners);
  List<Point> points=corners.toList();
  List<Point> topPoints=new ArrayList<Point>();
  List<Point> bottomPoints=new ArrayList<Point>();
  for (  Point point : points) {
    if (point.y < center.y) {
      topPoints.add(point);
    }
 else {
      bottomPoints.add(point);
    }
  }
  Point topLeft=topPoints.get(0).x > topPoints.get(1).x ? topPoints.get(1) : topPoints.get(0);
  Point topRight=topPoints.get(0).x > topPoints.get(1).x ? topPoints.get(0) : topPoints.get(1);
  Point bottomLeft=bottomPoints.get(0).x > bottomPoints.get(1).x ? bottomPoints.get(1) : bottomPoints.get(0);
  Point bottomRight=bottomPoints.get(0).x > bottomPoints.get(1).x ? bottomPoints.get(0) : bottomPoints.get(1);
  Log.d(DEBUG_TAG,String.format(""String_Node_Str""));
  Log.d(DEBUG_TAG,String.format(""String_Node_Str"",topLeft.x,topLeft.y));
  Log.d(DEBUG_TAG,String.format(""String_Node_Str"",topRight.x,topRight.y));
  Log.d(DEBUG_TAG,String.format(""String_Node_Str"",bottomLeft.x,bottomLeft.y));
  Log.d(DEBUG_TAG,String.format(""String_Node_Str"",bottomRight.x,bottomRight.y));
  MatOfPoint2f result=new MatOfPoint2f();
  Point[] sortedPoints={topLeft,topRight,bottomRight,bottomLeft};
  result.fromArray(sortedPoints);
  return result;
}"
13371,"/** 
 * Execute request. Exception will be automatically catched and translated into an instance of {HttpClientException}.
 * @return Http response.
 * @throws Exception If an error occurred.
 */
protected abstract HttpResponse doExecute() throws Exception ;","/** 
 * Execute request. Exception will be automatically translated into an instance of   {@link HttpClientException}.
 * @return Http response.
 * @throws Exception If an error occurred.
 */
protected abstract HttpResponse doExecute() throws Exception ;"
13372,"/** 
 * Add request body: <ul> <li>Set request body if   {@link #body} is defined.</li><li>Add form parmeters ( {@link #formParams}) otherwise if it is not empty.</li> </ul>
 * @param builder The pending HTTP request.
 * @see RequestBuilder#addFormParam(String,String)
 * @see RequestBuilder#setBody(String)
 */
private void handleBody(RequestBuilder builder){
  if (!hasBody()) {
    return;
  }
  if (body != null) {
    handleRequestBody(builder);
  }
 else {
    handleFormParameters(builder);
  }
}","/** 
 * Add request body: <ul> <li>Set request body if   {@link #body} is defined.</li><li>Add form parameters ( {@link #formParams}) otherwise if it is not empty.</li> </ul>
 * @param builder The pending HTTP request.
 * @see RequestBuilder#addFormParam(String,String)
 * @see RequestBuilder#setBody(String)
 */
private void handleBody(RequestBuilder builder){
  if (!hasBody()) {
    return;
  }
  if (body != null) {
    handleRequestBody(builder);
  }
 else {
    handleFormParameters(builder);
  }
}"
13373,"/** 
 * Translates a string into   {@code application/x-www-form-urlencoded}format using UTF-8 encoding.
 * @param value The string value.
 * @return The encoded vallue.
 * @throws Utf8EncodingException If, for some weird reason, UTF-8 encoding is not supported.
 */
public static String urlEncode(String value){
  try {
    return URLEncoder.encode(value,StandardCharsets.UTF_8.displayName());
  }
 catch (  UnsupportedEncodingException ex) {
    throw new Utf8EncodingException(ex);
  }
}","/** 
 * Translates a string into   {@code application/x-www-form-urlencoded}format using UTF-8 encoding.
 * @param value The string value.
 * @return The encoded value.
 * @throws Utf8EncodingException If, for some weird reason, UTF-8 encoding is not supported.
 */
public static String urlEncode(String value){
  try {
    return URLEncoder.encode(value,StandardCharsets.UTF_8.displayName());
  }
 catch (  UnsupportedEncodingException ex) {
    throw new Utf8EncodingException(ex);
  }
}"
13374,"/** 
 * Get servlet context used within container. If container is not a servlet container, this method should return null.
 * @return Servlet Cntext from container.
 */
ServletContext getServletContext();","/** 
 * Get servlet context used within container. If container is not a servlet container, this method should return null.
 * @return Servlet Context from container.
 */
ServletContext getServletContext();"
13375,"private void HttpScheme(String protocol,int defaultPort){
  this.protocol=protocol;
  this.defaultPort=defaultPort;
}","void HttpScheme(String protocol,int defaultPort){
  this.protocol=protocol;
  this.defaultPort=defaultPort;
}"
13376,"/** 
 * Create exception with error message.
 * @param message Error message.
 */
HttpClientException(String message){
  super(message);
}","/** 
 * Create exception.
 * @param throwable Original exception.
 */
public HttpClientException(Throwable throwable){
  super(throwable);
}"
13377,"/** 
 * Create rule.
 * @param configuration Jetty Configuration.
 */
public JettyServerRule(EmbeddedJettyConfiguration configuration){
  super(new EmbeddedJetty(configuration));
}","/** 
 * Create rule.
 * @param configuration Jetty Configuration.
 */
public JettyServerRule(EmbeddedJettyConfiguration configuration){
  this(new EmbeddedJetty(configuration));
}"
13378,"/** 
 * Create rule.
 * @param configuration Tomcat Configuration.
 */
public TomcatServerRule(EmbeddedTomcatConfiguration configuration){
  super(new EmbeddedTomcat(configuration));
}","/** 
 * Create rule.
 * @param configuration Tomcat Configuration.
 */
public TomcatServerRule(EmbeddedTomcatConfiguration configuration){
  this(new EmbeddedTomcat(configuration));
}"
13379,"/** 
 * Map input values to output values.
 * @param inputs Input values.
 * @param < T > Type of input values.
 * @param < U > Type of output values.
 * @return Output values.
 */
public static <T,U>List<U> map(Collection<T> inputs,Mapper<T,U> mapper){
  if (inputs == null) {
    return null;
  }
  List<U> outputs=new ArrayList<>(inputs.size());
  for (  T input : inputs) {
    outputs.add(mapper.apply(input));
  }
  return outputs;
}","/** 
 * Map input values to output values.
 * @param inputs Input values.
 * @param mapper Mapper function.
 * @param < T > Type of input values.
 * @param < U > Type of output values.
 * @return Output values.
 */
public static <T,U>List<U> map(Collection<T> inputs,Mapper<T,U> mapper){
  if (inputs == null) {
    return null;
  }
  List<U> outputs=new ArrayList<>(inputs.size());
  for (  T input : inputs) {
    outputs.add(mapper.apply(input));
  }
  return outputs;
}"
13380,"/** 
 * Create the exception.
 * @param cause Original cause.
 */
public UrlException(String scheme,String host,int port,String path,Throwable cause){
  super(cause);
  this.scheme=scheme;
  this.host=host;
  this.port=port;
  this.path=path;
}","/** 
 * Create the exception.
 * @param scheme HTTP Url scheme.
 * @param host HTTP Url host.
 * @param port HTTP Url port.
 * @param path HTTP Url path.
 * @param cause Original cause.
 */
public UrlException(String scheme,String host,int port,String path,Throwable cause){
  super(cause);
  this.scheme=scheme;
  this.host=host;
  this.port=port;
  this.path=path;
}"
13381,"/** 
 * Create the exception with a default error message.
 */
public Utf8EncodingException(Throwable ex){
  super(""String_Node_Str"",ex);
}","/** 
 * Create the exception with original cause and a default error message.
 * @param ex Original cause.
 */
public Utf8EncodingException(Throwable ex){
  super(""String_Node_Str"",ex);
}"
13382,"/** 
 * Create new handler.
 * @param configuration Server configuration.
 * @return Handler.
 * @throws NullPointerException if configuration is null.
 */
public static <T extends AbstractConfiguration>ConfigurationAnnotationHandler newConfigurationAnnotationHandler(T configuration){
  return new ConfigurationAnnotationHandler(notNull(configuration,""String_Node_Str""));
}","/** 
 * Create new handler.
 * @param configuration Server configuration.
 * @param < T > Type of configuration instance.
 * @return Handler.
 * @throws NullPointerException if configuration is null.
 */
public static <T extends AbstractConfiguration>ConfigurationAnnotationHandler newConfigurationAnnotationHandler(T configuration){
  return new ConfigurationAnnotationHandler(notNull(configuration,""String_Node_Str""));
}"
13383,"/** 
 * Execute request. Exception will be automatically catched and translated into an instance of {HttpClientException}.
 * @return Http response.
 * @throws Exception
 */
protected abstract HttpResponse doExecute() throws Exception ;","/** 
 * Execute request. Exception will be automatically catched and translated into an instance of {HttpClientException}.
 * @return Http response.
 * @throws Exception If an error occurred.
 */
protected abstract HttpResponse doExecute() throws Exception ;"
13384,"/** 
 * Append new boolean value.
 * @param name The name of the field.
 * @param values The collection of values.
 * @return The current builder (for chaining).
 */
public <T>ToStringBuilder append(String name,Iterable<T> values){
  StringBuilder pending=new StringBuilder().append(OPEN_ARRAY);
  boolean firstItem=true;
  for (  T value : values) {
    if (!firstItem) {
      pending.append(SEPARATOR);
    }
    pending.append(formatValue(value));
    firstItem=false;
  }
  return appendFormattedValue(name,pending.append(CLOSE_ARRAY).toString());
}","/** 
 * Append new boolean value.
 * @param name The name of the field.
 * @param values The collection of values.
 * @param < T > Type of elements in collection.
 * @return The current builder (for chaining).
 */
public <T>ToStringBuilder append(String name,Iterable<T> values){
  StringBuilder pending=new StringBuilder().append(OPEN_ARRAY);
  boolean firstItem=true;
  for (  T value : values) {
    if (!firstItem) {
      pending.append(SEPARATOR);
    }
    pending.append(formatValue(value));
    firstItem=false;
  }
  return appendFormattedValue(name,pending.append(CLOSE_ARRAY).toString());
}"
13385,"/** 
 * Create new rules.
 * @param target Target class (i.e tested class).
 * @param handlers List of handlers.
 */
public HandlersRule(Object target,AnnotationHandler handler,AnnotationHandler... handlers){
  super(target);
  this.handlers=new LinkedList<>();
  this.handlers.add(notNull(handler,""String_Node_Str""));
  for (  AnnotationHandler h : handlers) {
    this.handlers.add(notNull(h,""String_Node_Str""));
  }
}","/** 
 * Create new rules.
 * @param target Target class (i.e tested class).
 * @param handler First handler (required).
 * @param handlers List of other (optional) handlers.
 */
public HandlersRule(Object target,AnnotationHandler handler,AnnotationHandler... handlers){
  super(target);
  this.handlers=new LinkedList<>();
  this.handlers.add(notNull(handler,""String_Node_Str""));
  for (  AnnotationHandler h : handlers) {
    this.handlers.add(notNull(h,""String_Node_Str""));
  }
}"
13386,"/** 
 * Create runner.
 * @param klass Running class.
 * @throws InitializationError
 */
public JunitServerRunner(Class<?> klass) throws InitializationError {
  super(klass);
  this.server=instantiate(klass);
  this.configuration=this.server.getConfiguration();
}","/** 
 * Create runner.
 * @param klass Running class.
 * @throws InitializationError If an error occurred while starting embedded server.
 */
public JunitServerRunner(Class<?> klass) throws InitializationError {
  super(klass);
  this.server=instantiate(klass);
  this.configuration=this.server.getConfiguration();
}"
13387,"/** 
 * Change parent classpath value.
 * @param classpath New webapp value.
 * @return this
 */
public T withParentClasspath(URL classpath,URL... others){
  Set<URL> classpathUrls=new HashSet<>();
  classpathUrls.add(classpath);
  Collections.addAll(classpathUrls,others);
  return withParentClasspath(classpathUrls);
}","/** 
 * Change parent classpath value.
 * @param classpath New webapp value.
 * @param others Other (optional) urls.
 * @return this
 */
public T withParentClasspath(URL classpath,URL... others){
  Set<URL> classpathUrls=new HashSet<>();
  classpathUrls.add(classpath);
  Collections.addAll(classpathUrls,others);
  return withParentClasspath(classpathUrls);
}"
13388,"@SubscribeEvent @SideOnly(Side.CLIENT) public void registerModels(ModelRegistryEvent event){
  ZettaIndustries.proxy.registermodel(wire,0);
}","@SubscribeEvent @SideOnly(Side.CLIENT) public void registerModels(ModelRegistryEvent event){
  ZettaIndustries.proxy.registermodel(wire,0);
  ZettaIndustries.proxy.registermodel(connectorItem,0);
}"
13389,"@SideOnly(Side.CLIENT) @Override public void clientSide(){
  ConnLoader.baseModels.put(""String_Node_Str"",new ResourceLocation(""String_Node_Str""));
  ConnLoader.textureReplacements.put(""String_Node_Str"",ImmutableMap.of(""String_Node_Str"",ZettaIndustries.MODID + ""String_Node_Str""));
  ZettaIndustries.proxy.registermodel(connectorItem,0);
}","@SideOnly(Side.CLIENT) @Override public void clientSide(){
  ConnLoader.baseModels.put(""String_Node_Str"",new ResourceLocation(""String_Node_Str""));
  ConnLoader.textureReplacements.put(""String_Node_Str"",ImmutableMap.of(""String_Node_Str"",ZettaIndustries.MODID + ""String_Node_Str""));
}"
13390,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override @SideOnly(Side.CLIENT) public void addInformation(ItemStack stack,World world,List list,ITooltipFlag flag){
  list.add(I18n.translateToLocal(""String_Node_Str""));
  list.add(I18n.translateToLocal(""String_Node_Str""));
  if (stack.getTagCompound() != null && stack.getTagCompound().hasKey(""String_Node_Str"")) {
    int[] link=stack.getTagCompound().getIntArray(""String_Node_Str"");
    if (link != null && link.length > 3)     list.add(I18n.translateToLocalFormatted(""String_Node_Str"",link[1],link[2],link[3],link[0]));
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override @SideOnly(Side.CLIENT) public void addInformation(ItemStack stack,World world,List list,ITooltipFlag flag){
  list.add(I18n.translateToLocal(""String_Node_Str""));
  list.add(I18n.translateToLocal(""String_Node_Str""));
  if (stack.getTagCompound() != null && stack.getTagCompound().hasKey(""String_Node_Str"")) {
    int[] link=stack.getTagCompound().getIntArray(""String_Node_Str"");
    if (link != null && link.length > 3) {
      list.add(I18n.translateToLocalFormatted(""String_Node_Str"",link[1],link[2],link[3],link[0]));
    }
  }
}"
13391,"@Override public EnumActionResult onItemUse(EntityPlayer player,World world,BlockPos pos,EnumHand hand,EnumFacing side,float hitX,float hitY,float hitZ){
  return IEContent.itemWireCoil.onItemUse(player,world,pos,hand,side,hitX,hitY,hitZ);
}","@Override public EnumActionResult onItemUse(EntityPlayer player,World world,BlockPos pos,EnumHand hand,EnumFacing side,float hitX,float hitY,float hitZ){
  TileEntity tileEntity=world.getTileEntity(pos);
  if (tileEntity instanceof IImmersiveConnectable && ((IImmersiveConnectable)tileEntity).canConnect()) {
    ItemStack stack=player.getHeldItem(hand);
    TargetingInfo target=new TargetingInfo(side,hitX,hitY,hitZ);
    WireType wire=getWireType(stack);
    BlockPos masterPos=((IImmersiveConnectable)tileEntity).getConnectionMaster(wire,target);
    tileEntity=world.getTileEntity(masterPos);
    if (!(tileEntity instanceof IImmersiveConnectable) || !((IImmersiveConnectable)tileEntity).canConnect()) {
      return EnumActionResult.PASS;
    }
    if (!((IImmersiveConnectable)tileEntity).canConnectCable(wire,target)) {
      if (!world.isRemote) {
        player.sendMessage(new TextComponentTranslation(Lib.CHAT_WARN + ""String_Node_Str""));
      }
      return EnumActionResult.FAIL;
    }
    if (!world.isRemote) {
      if (!ItemNBTHelper.hasKey(stack,""String_Node_Str"")) {
        ItemNBTHelper.setIntArray(stack,""String_Node_Str"",new int[]{world.provider.getDimension(),masterPos.getX(),masterPos.getY(),masterPos.getZ()});
        NBTTagCompound targetNbt=new NBTTagCompound();
        target.writeToNBT(targetNbt);
        ItemNBTHelper.setTagCompound(stack,""String_Node_Str"",targetNbt);
      }
 else {
        WireType type=getWireType(stack);
        int[] array=ItemNBTHelper.getIntArray(stack,""String_Node_Str"");
        BlockPos linkPos=new BlockPos(array[1],array[2],array[3]);
        TileEntity tileEntityLinkingPos=world.getTileEntity(linkPos);
        int distanceSq=(int)Math.ceil(linkPos.distanceSq(masterPos));
        if (array[0] != world.provider.getDimension()) {
          player.sendMessage(new TextComponentTranslation(Lib.CHAT_WARN + ""String_Node_Str""));
        }
 else         if (linkPos.equals(masterPos)) {
          player.sendMessage(new TextComponentTranslation(Lib.CHAT_WARN + ""String_Node_Str""));
        }
 else         if (distanceSq > (type.getMaxLength() * type.getMaxLength())) {
          player.sendMessage(new TextComponentTranslation(Lib.CHAT_WARN + ""String_Node_Str""));
        }
 else {
          TargetingInfo targetLink=TargetingInfo.readFromNBT(ItemNBTHelper.getTagCompound(stack,""String_Node_Str""));
          if (!(tileEntityLinkingPos instanceof IImmersiveConnectable) || !((IImmersiveConnectable)tileEntityLinkingPos).canConnectCable(wire,targetLink)) {
            player.sendMessage(new TextComponentTranslation(Lib.CHAT_WARN + ""String_Node_Str""));
          }
 else {
            IImmersiveConnectable nodeHere=(IImmersiveConnectable)tileEntity;
            IImmersiveConnectable nodeLink=(IImmersiveConnectable)tileEntityLinkingPos;
            boolean connectionExists=false;
            Set<Connection> outputs=ImmersiveNetHandler.INSTANCE.getConnections(world,Utils.toCC(nodeHere));
            if (outputs != null) {
              for (              Connection con : outputs) {
                if (con.end.equals(Utils.toCC(nodeLink))) {
                  connectionExists=true;
                }
              }
            }
            if (connectionExists) {
              player.sendMessage(new TextComponentTranslation(Lib.CHAT_WARN + ""String_Node_Str""));
            }
 else {
              Vec3d rtOff0=nodeHere.getRaytraceOffset(nodeLink).addVector(masterPos.getX(),masterPos.getY(),masterPos.getZ());
              Vec3d rtOff1=nodeLink.getRaytraceOffset(nodeHere).addVector(linkPos.getX(),linkPos.getY(),linkPos.getZ());
              Set<BlockPos> ignore=new HashSet<>();
              ignore.addAll(nodeHere.getIgnored(nodeLink));
              ignore.addAll(nodeLink.getIgnored(nodeHere));
              boolean canSee=Utils.rayTraceForFirst(rtOff0,rtOff1,world,ignore) == null;
              if (canSee) {
                ImmersiveNetHandler.INSTANCE.addConnection(world,Utils.toCC(nodeHere),Utils.toCC(nodeLink),(int)Math.sqrt(distanceSq),type);
                nodeHere.connectCable(type,target,nodeLink);
                nodeLink.connectCable(type,targetLink,nodeHere);
                IESaveData.setDirty(world.provider.getDimension());
                Utils.unlockIEAdvancement(player,""String_Node_Str"");
                if (!player.capabilities.isCreativeMode) {
                  stack.shrink(1);
                }
                ((TileEntity)nodeHere).markDirty();
                world.addBlockEvent(masterPos,((TileEntity)nodeHere).getBlockType(),-1,0);
                IBlockState state=world.getBlockState(masterPos);
                world.notifyBlockUpdate(masterPos,state,state,3);
                ((TileEntity)nodeLink).markDirty();
                world.addBlockEvent(linkPos,((TileEntity)nodeLink).getBlockType(),-1,0);
                state=world.getBlockState(linkPos);
                world.notifyBlockUpdate(linkPos,state,state,3);
              }
 else {
                player.sendMessage(new TextComponentTranslation(Lib.CHAT_WARN + ""String_Node_Str""));
              }
            }
          }
        }
        ItemNBTHelper.remove(stack,""String_Node_Str"");
        ItemNBTHelper.remove(stack,""String_Node_Str"");
      }
    }
    return EnumActionResult.SUCCESS;
  }
  return EnumActionResult.PASS;
}"
13392,"private void addRecipe(Item backpackT1,Item backpackT2,ItemStack crafting){
  RecipeManagers.carpenterManager.addRecipe(200,Fluids.WATER.getFluid(1000),null,new ItemStack(backpackT2),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'X',Items.DIAMOND,'W',PluginCore.items.craftingMaterial.getSilkWisp(),'T',backpackT1);
  GameRegistry.addShapedRecipe(new ItemStack(backpackT1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'#',Blocks.WOOL,'X',Items.STRING,'V',crafting,'Y',Blocks.CHEST);
}","private void addRecipe(Item backpackT1,Item backpackT2,ItemStack crafting){
  RecipeManagers.carpenterManager.addRecipe(200,FluidRegistry.getFluidStack(""String_Node_Str"",1000),null,new ItemStack(backpackT2),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'X',Items.DIAMOND,'W',PluginCore.items.craftingMaterial.getSilkWisp(),'T',backpackT1);
  GameRegistry.addShapedRecipe(new ItemStack(backpackT1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'#',Blocks.WOOL,'X',Items.STRING,'V',crafting,'Y',Blocks.CHEST);
}"
13393,"private Item addBackpack(BasicBackpack backpack,EnumBackpackType type){
  Item backpakItem=BackpackManager.backpackInterface.createBackpack(backpack,type);
  backpakItem.setCreativeTab(ZettaIndustries.instance.tabZettaIndustries);
  backpakItem.setRegistryName(backpack.getKey());
  ZettaIndustries.proxy.registermodel(GameRegistry.register(backpakItem),0);
  return backpakItem;
}","private Item addBackpack(BasicBackpack backpack,EnumBackpackType type){
  Item backpakItem=BackpackManager.backpackInterface.createBackpack(backpack.getUniqueName(),type);
  backpakItem.setCreativeTab(ZettaIndustries.instance.tabZettaIndustries);
  backpakItem.setRegistryName(backpack.getKey());
  ZettaIndustries.proxy.registermodel(GameRegistry.register(backpakItem),0);
  return backpakItem;
}"
13394,"@Override public boolean test(ItemStack itemstack){
  if (itemstack != null && itemstack.getItem() != null) {
    ResourceLocation rl=itemstack.getItem().getRegistryName();
    String name=null;
    System.out.println(rl.getResourceDomain());
    System.out.println(rl.getResourcePath());
    if (rl != null) {
      name=rl.getResourcePath();
    }
    if (name == null || name.isEmpty())     return false;
    for (    String names : this.names) {
      if (name.startsWith(names)) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean test(ItemStack itemstack){
  if (itemstack != null && itemstack.getItem() != null) {
    ResourceLocation rl=itemstack.getItem().getRegistryName();
    String name=null;
    System.out.println(rl.getResourceDomain());
    System.out.println(rl.getResourcePath());
    if (rl != null) {
      name=rl.getResourcePath();
    }
    if (name == null || name.isEmpty())     return false;
    for (    String names : getNames()) {
      if (name.startsWith(names)) {
        return true;
      }
    }
  }
  return false;
}"
13395,"@Override public boolean test(ItemStack itemstack){
  return true;
}","@Override public boolean test(ItemStack itemStack){
  return true;
}"
13396,"@Override protected void onImpact(MovingObjectPosition mop){
  if (!this.worldObj.isRemote && this.shootingEntity != null && this.shootingEntity instanceof EntityPlayer) {
    if (alredyHit) {
      return;
    }
 else {
      alredyHit=true;
    }
    EntityPlayer ep=(EntityPlayer)this.shootingEntity;
    int next=(ep.inventory.currentItem + 1) % 10;
    ItemStack toUse=ep.inventory.getStackInSlot(next);
    if (toUse != null && toUse.getItem() instanceof IWireCoil) {
      if (mop.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK) {
        if (toUse.getItem().onItemUseFirst(toUse,ep,this.worldObj,mop.blockX,mop.blockY,mop.blockZ,mop.sideHit,(float)mop.hitVec.xCoord % 1,(float)mop.hitVec.yCoord % 1,(float)mop.hitVec.zCoord % 1)) {
          this.worldObj.playSoundAtEntity(ep,""String_Node_Str"",.8F,1.2F / (this.rand.nextFloat() * .2F + .9F));
        }
      }
    }
    if (mop.typeOfHit == MovingObjectPosition.MovingObjectType.ENTITY) {
      mop.entityHit.attackEntityFrom(IEDamageSources.causeCasullDamage(this,shootingEntity),.5F);
    }
  }
}","@Override protected void onImpact(RayTraceResult mop){
  if (!this.worldObj.isRemote && this.shootingEntity != null && this.shootingEntity instanceof EntityPlayer) {
    if (alredyHit) {
      return;
    }
 else {
      alredyHit=true;
    }
    EntityPlayer ep=(EntityPlayer)this.shootingEntity;
    int next=(ep.inventory.currentItem + 1) % 10;
    ItemStack toUse=ep.inventory.getStackInSlot(next);
    if (toUse != null && toUse.getItem() instanceof IWireCoil) {
      if (mop.typeOfHit == RayTraceResult.Type.BLOCK) {
        if (toUse.getItem().onItemUseFirst(toUse,ep,this.worldObj,mop.getBlockPos(),mop.sideHit,(float)mop.hitVec.xCoord % 1,(float)mop.hitVec.yCoord % 1,(float)mop.hitVec.zCoord % 1)) {
          this.worldObj.playSoundAtEntity(ep,""String_Node_Str"",.8F,1.2F / (this.rand.nextFloat() * .2F + .9F));
        }
      }
    }
    if (mop.typeOfHit == RayTraceResult.Type.ENTITY) {
      mop.entityHit.attackEntityFrom(IEDamageSources.causeCasullDamage(this,shootingEntity),.5F);
    }
  }
}"
13397,"@Override public void init(){
  ItemStack microChip1=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack microChip2=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack microChip3=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack cpu1=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack interweb=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack wifi=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack circuitBoard=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack paper=new ItemStack(net.minecraft.init.Items.PAPER,1);
  ItemStack iron=new ItemStack(net.minecraft.init.Items.IRON_INGOT,1);
  ItemStack obsidian=new ItemStack(Blocks.OBSIDIAN,1);
  ItemStack pressurePlate=new ItemStack(Blocks.STONE_PRESSURE_PLATE);
  ItemStack dataCard2=Items.get(""String_Node_Str"").createItemStack(1);
  GameRegistry.addRecipe(new ItemStack(blockNFCReader,1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',iron,'c',microChip2,'n',interweb,'w',wifi,'b',circuitBoard);
  GameRegistry.addRecipe(new ItemStack(blockNFCProgrammer,1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',iron,'c',cpu1,'n',interweb,'w',wifi,'b',circuitBoard);
  GameRegistry.addRecipe(new ItemStack(itemCardNFC,1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',paper,'c',microChip1);
  GameRegistry.addRecipe(new ItemStack(itemPrivateCardNFC,1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',paper,'c',microChip2);
}","@Override public void init(){
  ItemStack microChip1=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack microChip2=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack microChip3=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack cpu1=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack interweb=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack wifi=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack circuitBoard=Items.get(""String_Node_Str"").createItemStack(1);
  ItemStack paper=new ItemStack(net.minecraft.init.Items.PAPER,1);
  ItemStack iron=new ItemStack(net.minecraft.init.Items.IRON_INGOT,1);
  ItemStack obsidian=new ItemStack(Blocks.OBSIDIAN,1);
  ItemStack pressurePlate=new ItemStack(Blocks.STONE_PRESSURE_PLATE);
  ItemStack dataCard2=Items.get(""String_Node_Str"").createItemStack(1);
  GameRegistry.addRecipe(new ItemStack(blockNFCReader,1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',iron,'c',microChip2,'n',interweb,'w',wifi,'b',circuitBoard);
  GameRegistry.addRecipe(new ItemStack(blockNFCProgrammer,1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',iron,'c',cpu1,'n',interweb,'w',wifi,'b',circuitBoard);
  GameRegistry.addRecipe(new ItemStack(itemCardNFC,1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',paper,'c',microChip1);
  GameRegistry.addRecipe(new ItemStack(itemPrivateCardNFC,1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',paper,'c',microChip2);
  GameRegistry.addRecipe(new ItemStack(smartCardItem,1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',paper,'c',microChip3);
  GameRegistry.addRecipe(new ItemStack(smartCardItem,1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',paper,'c',smartCardItem);
  GameRegistry.addRecipe(new ItemStack(smartCardTerminalBlock,1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',pressurePlate,'c',microChip2,'i',iron,'d',dataCard2,'b',circuitBoard);
  GameRegistry.addRecipe(new ItemStack(smartCardTerminalItem,1),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',pressurePlate,'c',microChip2,'i',obsidian,'d',dataCard2,'b',circuitBoard);
}"
13398,"@Override public void preInit(){
  blockNFCProgrammer=new BlockNFCProgrammer();
  blockNFCReader=new BlockNFCReader();
  itemCardNFC=new ItemCardNFC();
  itemPrivateCardNFC=new ItemPrivateCardNFC();
  GameRegistry.register(blockNFCReader);
  ZettaIndustries.proxy.registermodel(GameRegistry.register(new ItemBlock(blockNFCReader).setRegistryName(blockNFCReader.getRegistryName())),0);
  GameRegistry.register(blockNFCProgrammer);
  ZettaIndustries.proxy.registermodel(GameRegistry.register(new ItemBlock(blockNFCProgrammer).setRegistryName(blockNFCProgrammer.getRegistryName())),0);
  GameRegistry.registerTileEntity(TileEntityNFCReader.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityNFCProgrammer.class,""String_Node_Str"");
  ZettaIndustries.proxy.registermodel(GameRegistry.register(itemPrivateCardNFC),0);
  ZettaIndustries.proxy.registermodel(GameRegistry.register(itemCardNFC),0);
  ZIRegistry.registerProxy(this);
}","@Override public void preInit(){
  blockNFCProgrammer=new BlockNFCProgrammer();
  blockNFCReader=new BlockNFCReader();
  itemCardNFC=new ItemCardNFC();
  itemPrivateCardNFC=new ItemPrivateCardNFC();
  GameRegistry.register(blockNFCReader);
  ZettaIndustries.proxy.registermodel(GameRegistry.register(new ItemBlock(blockNFCReader).setRegistryName(blockNFCReader.getRegistryName())),0);
  GameRegistry.register(blockNFCProgrammer);
  ZettaIndustries.proxy.registermodel(GameRegistry.register(new ItemBlock(blockNFCProgrammer).setRegistryName(blockNFCProgrammer.getRegistryName())),0);
  GameRegistry.registerTileEntity(TileEntityNFCReader.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityNFCProgrammer.class,""String_Node_Str"");
  Item tempItem=GameRegistry.register(itemPrivateCardNFC);
  ZettaIndustries.proxy.registermodel(tempItem,0);
  ZettaIndustries.proxy.registermodel(tempItem,1,new ModelResourceLocation(ZettaIndustries.MODID + ""String_Node_Str"",""String_Node_Str""));
  ZettaIndustries.proxy.registermodel(GameRegistry.register(itemCardNFC),0);
  smartCardItem=new SmartCardItem();
  smartCardTerminalItem=new SmartCardTerminalItem();
  smartCardTerminalBlock=new SmartCardTerminalBlock();
  ZettaIndustries.proxy.registermodel(GameRegistry.register(smartCardTerminalItem),0);
  ZettaIndustries.proxy.registermodel(GameRegistry.register(smartCardItem),0);
  Block temp=GameRegistry.register(smartCardTerminalBlock);
  ZettaIndustries.proxy.registermodel(GameRegistry.register(new ItemBlock(temp).setRegistryName(temp.getRegistryName())),0);
  GameRegistry.registerTileEntity(SmartCardTerminalTileEntity.class,""String_Node_Str"");
  Driver.add((li.cil.oc.api.driver.Item)smartCardItem);
  Driver.add((li.cil.oc.api.driver.Item)smartCardTerminalItem);
  ZIRegistry.registerProxy(this);
}"
13399,"@SideOnly(Side.CLIENT) @Override public void clientSide(){
}","@SideOnly(Side.CLIENT) @Override public void clientSide(){
  ClientRegistry.bindTileEntitySpecialRenderer(SmartCardTerminalTileEntity.class,new SmartCardBlockTerminalRenderer());
  MinecraftForge.EVENT_BUS.register(new SmartCardRackRenderer());
}"
13400,"@Override public ActionResult<ItemStack> onItemRightClick(ItemStack itemStack,World world,EntityPlayer player,EnumHand hand){
  if (itemStack.getItem() instanceof ItemPrivateCardNFC && player.isSneaking() && getOwner(itemStack) == null) {
    setOwner(player.getName(),itemStack);
  }
  return ActionResult.newResult(EnumActionResult.SUCCESS,itemStack);
}","@Override public ActionResult<ItemStack> onItemRightClick(ItemStack itemStack,World world,EntityPlayer player,EnumHand hand){
  if (itemStack.getItem() instanceof ItemPrivateCardNFC && player.isSneaking() && getOwner(itemStack) == null) {
    setOwner(player.getName(),itemStack);
    itemStack.setItemDamage(1);
  }
  return ActionResult.newResult(EnumActionResult.SUCCESS,itemStack);
}"
13401,"@Override public void renderTileEntityAt(TileEntity te,double x,double y,double z,float f){
  SmartCardTerminalTileEntity terminal=(SmartCardTerminalTileEntity)te;
  if (terminal.renderInfo == null)   return;
  if (!terminal.renderInfo.getBoolean(""String_Node_Str""))   return;
  if (!(terminal.getBlockMetadata() < 4))   return;
  ForgeDirection facing=ForgeDirection.VALID_DIRECTIONS[SmartCardTerminalBlock.sides[terminal.getBlockMetadata()]];
  GL11.glPushAttrib(GL11.GL_ALL_ATTRIB_BITS);
  GL11.glPushMatrix();
  GL11.glTranslated(x + 0.5,y + 0.5,z + 0.5);
switch (facing) {
case WEST:
    GL11.glRotatef(-90,0,1,0);
  break;
case NORTH:
GL11.glRotatef(180,0,1,0);
break;
case EAST:
GL11.glRotatef(90,0,1,0);
break;
default :
;
}
GL11.glPushMatrix();
GL11.glTranslatef(0,4.5f / 16,10 / 16f);
GL11.glRotatef(90,-1,0,0);
int brightness=terminal.getWorldObj().getLightBrightnessForSkyBlocks(terminal.xCoord + facing.offsetX,terminal.yCoord + facing.offsetY,terminal.zCoord + facing.offsetZ,0);
OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit,brightness % 65536,brightness / 65536);
EntityItem entity=new EntityItem(terminal.getWorldObj(),0,0,0,new ItemStack(NFC.smartCardItem));
entity.hoverStart=0;
RenderItem.renderInFrame=true;
RenderManager.instance.renderEntityWithPosYaw(entity,0,0,0,0,0);
RenderItem.renderInFrame=false;
GL11.glPopMatrix();
GL11.glColor3d(0,1,0);
GL11.glTranslated(-0.5,0.5,0.5005);
GL11.glScalef(1,-1,1);
bindTexture(rl);
Tessellator t=Tessellator.instance;
t.startDrawingQuads();
t.addVertexWithUV(0,1,0,0,1);
t.addVertexWithUV(5 / 16f,1,0,5 / 16f,1);
t.addVertexWithUV(5 / 16f,0,0,5 / 16f,0);
t.addVertexWithUV(0,0,0,0,0);
t.draw();
if (terminal.renderInfo.getBoolean(""String_Node_Str"")) {
if (terminal.renderInfo.getBoolean(""String_Node_Str"")) {
GL11.glColor3d(0,1,0);
}
 else {
GL11.glColor3d(254 / 255f,196 / 255f,54 / 255f);
}
}
 else {
GL11.glColor3d(1,0,0);
}
t.startDrawingQuads();
t.addVertexWithUV(5 / 16f,1,0,5 / 16f,1);
t.addVertexWithUV(1,1,0,1,1);
t.addVertexWithUV(1,0,0,1,0);
t.addVertexWithUV(5 / 16f,0,0,5 / 16f,0);
t.draw();
GL11.glColor3d(1,1,1);
GL11.glPopMatrix();
GL11.glPopAttrib();
}","@Override public void renderTileEntityAt(SmartCardTerminalTileEntity terminal,double x,double y,double z,float partialTicks,int destroyStage){
  System.out.println(""String_Node_Str"");
  if (terminal.renderInfo == null)   return;
  if (!(terminal.getBlockMetadata() < 4))   return;
  EnumFacing facing=EnumFacing.values()[sides[terminal.getBlockMetadata()]];
  GlStateManager.pushMatrix();
  GlStateManager.translate(x + 0.5,y + 0.5,z + 0.5);
switch (facing) {
case WEST:
    GlStateManager.rotate(-90,0,1,0);
  break;
case NORTH:
GlStateManager.rotate(180,0,1,0);
break;
case EAST:
GlStateManager.rotate(90,0,1,0);
break;
default :
;
}
GlStateManager.pushMatrix();
GlStateManager.translate(0,4.5f / 16,5 / 16f);
GlStateManager.rotate(90,-1,0,0);
int brightness=terminal.getWorld().getCombinedLight(new BlockPos(terminal.getPos().getX() + facing.getFrontOffsetX(),terminal.getPos().getY() + facing.getFrontOffsetY(),terminal.getPos().getZ() + facing.getFrontOffsetZ()),0);
OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit,brightness % 65536,brightness / 65536);
EntityItem entity=new EntityItem(terminal.getWorld(),0,0,0,new ItemStack(NFC.smartCardItem));
entity.hoverStart=0;
Minecraft.getMinecraft().getRenderItem().renderItem(entity.getEntityItem(),ItemCameraTransforms.TransformType.FIXED);
GlStateManager.popMatrix();
GlStateManager.color(0f,1f,0f);
GlStateManager.translate(-0.5,0.5,0.5005);
GlStateManager.scale(1,-1,1);
bindTexture(rl);
VertexBuffer t=Tessellator.getInstance().getBuffer();
t.begin(GL11.GL_QUADS,DefaultVertexFormats.POSITION_TEX);
t.pos(0,1,0).tex(0,1).endVertex();
t.pos(5 / 16f,1,0).tex(5 / 16f,1).endVertex();
t.pos(5 / 16f,0,0).tex(5 / 16f,0).endVertex();
t.pos(0,0,0).tex(0,0).endVertex();
Tessellator.getInstance().draw();
if (terminal.renderInfo.getBoolean(""String_Node_Str"")) {
if (terminal.renderInfo.getBoolean(""String_Node_Str"")) {
GlStateManager.color(0f,1f,0f);
}
 else {
GlStateManager.color(254 / 255f,196 / 255f,54 / 255f);
}
}
 else {
GlStateManager.color(1f,0f,0f);
}
t.begin(GL11.GL_QUADS,DefaultVertexFormats.POSITION_TEX);
t.pos(5 / 16f,1,0).tex(5 / 16f,1).endVertex();
t.pos(1,1,0).tex(1,1).endVertex();
t.pos(1,0,0).tex(1,0).endVertex();
t.pos(5 / 16f,0,0).tex(5 / 16f,0).endVertex();
Tessellator.getInstance().draw();
GlStateManager.color(1,1,1);
GlStateManager.popMatrix();
}"
13402,"@Override public Object getServerGuiElement(int id,TileEntity blockEntity,EntityPlayer player,World world,int x,int y,int z){
  if (blockEntity instanceof TileEntitySimpleDHD) {
    return new ContainerSimpleDHD((TileEntitySimpleDHD)blockEntity);
  }
  return null;
}","@Override public Object getServerGuiElement(int id,TileEntity blockEntity,EntityPlayer player,World world,int x,int y,int z){
  return null;
}"
13403,"@Override public void updateScreen(){
  address.updateCursorCounter();
}","@Override public void updateScreen(){
  super.updateScreen();
  address.updateCursorCounter();
}"
13404,"@SuppressWarnings(""String_Node_Str"") @Override public void initGui(){
  int centerh=width / 2;
  int centerv=height / 2;
  Keyboard.enableRepeatEvents(true);
  address=new GuiTextField(this.fontRendererObj,centerh - 75,centerv - 7,150,14);
  connect=new GuiButton(1,centerh - 75,centerv + 10,70,20,""String_Node_Str"");
  disconnect=new GuiButton(2,centerh + 5,centerv + 10,70,20,""String_Node_Str"");
  buttonList.add(connect);
  buttonList.add(disconnect);
  if (te != null && !te.getAddress().isEmpty()) {
    address.setText(te.getAddress());
  }
  super.initGui();
}","@SuppressWarnings(""String_Node_Str"") @Override public void initGui(){
  int centerh=width / 2;
  int centerv=height / 2;
  Keyboard.enableRepeatEvents(true);
  address=new GuiTextField(this.fontRendererObj,centerh - 75,centerv - 7,150,14);
  connect=new GuiButton(1,centerh - 75,centerv + 10,70,20,""String_Node_Str"");
  disconnect=new GuiButton(2,centerh + 5,centerv + 10,70,20,""String_Node_Str"");
  buttonList.add(connect);
  buttonList.add(disconnect);
  super.initGui();
}"
13405,"@Override public void drawScreen(int p_73863_1_,int p_73863_2_,float p_73863_3_){
  if (addressFocus != address.isFocused()) {
    updateText();
  }
  addressFocus=address.isFocused();
  address.drawTextBox();
  super.drawScreen(p_73863_1_,p_73863_2_,p_73863_3_);
}","@Override public void drawScreen(int p_73863_1_,int p_73863_2_,float p_73863_3_){
  address.drawTextBox();
  super.drawScreen(p_73863_1_,p_73863_2_,p_73863_3_);
}"
13406,"@Override protected void keyTyped(char eventCharacter,int eventKey){
  if (this.address.isFocused()) {
    if (eventKey == Keyboard.KEY_RETURN) {
      this.address.setFocused(false);
    }
 else {
      this.address.textboxKeyTyped(eventCharacter,eventKey);
    }
    return;
  }
  super.keyTyped(eventCharacter,eventKey);
}","@Override protected void keyTyped(char eventCharacter,int eventKey){
  if (!address.textboxKeyTyped(eventCharacter,eventKey)) {
    super.keyTyped(eventCharacter,eventKey);
  }
}"
13407,"@Override public void readFromNBT(NBTTagCompound nbt){
  super.readFromNBT(nbt);
  if (nbt.hasKey(""String_Node_Str""))   address=nbt.getString(""String_Node_Str"");
}","@Override public void readFromNBT(NBTTagCompound nbt){
  super.readFromNBT(nbt);
  if (nbt.hasKey(""String_Node_Str""))   address=nbt.getString(""String_Node_Str"");
  businterface.readFromNBT(nbt,""String_Node_Str"");
}"
13408,"@Override public short getInterfaceAddress(){
  return 0x0000;
}","@Override public short getInterfaceAddress(){
  return 0x00;
}"
13409,"public void disconnect(){
  BusPacketLIP packet=new BusPacketLIP((short)0,(short)255);
  packet.set(""String_Node_Str"",""String_Node_Str"");
  packet.setMetadata(new BusPacketLIP.LIPMetadata(ZettaIndustries.MODID,network.getShortName(),null));
  packet.finish();
  network.handlePacket(packet);
  businterface.sendAllPackets();
}","public void disconnect(){
  BusPacketLIP packet=new BusPacketLIP((short)0,(short)255);
  packet.set(""String_Node_Str"",""String_Node_Str"");
  packet.setMetadata(new BusPacketLIP.LIPMetadata(ZettaIndustries.MODID,getShortName(),null));
  packet.finish();
  handlePacket(packet);
  businterface.sendAllPackets();
}"
13410,"@Override public void writeToNBT(NBTTagCompound nbt){
  super.writeToNBT(nbt);
  nbt.setString(""String_Node_Str"",address);
}","@Override public void writeToNBT(NBTTagCompound nbt){
  super.writeToNBT(nbt);
  nbt.setString(""String_Node_Str"",address);
  businterface.writeToNBT(nbt,""String_Node_Str"");
}"
13411,"public void dial(){
  BusPacketLIP packet=new BusPacketLIP((short)0,(short)255);
  packet.set(""String_Node_Str"",""String_Node_Str"");
  packet.set(""String_Node_Str"",getAddress());
  packet.setMetadata(new BusPacketLIP.LIPMetadata(ZettaIndustries.MODID,network.getShortName(),null));
  packet.finish();
  network.handlePacket(packet);
  businterface.sendAllPackets();
}","public void dial(){
  BusPacketLIP packet=new BusPacketLIP((short)0,(short)255);
  packet.set(""String_Node_Str"",""String_Node_Str"");
  packet.set(""String_Node_Str"",getAddress());
  packet.setMetadata(new BusPacketLIP.LIPMetadata(ZettaIndustries.MODID,getShortName(),null));
  packet.finish();
  handlePacket(packet);
  businterface.sendAllPackets();
}"
13412,"@Callback public Object[] writeNFCData(Context contex,Arguments args){
  if (args.count() == 1 && args.checkString(0).length() <= 1024) {
    NFCData=args.checkString(0);
    worldObj.setBlockMetadataWithNotify(this.xCoord,this.yCoord,this.zCoord,1,2);
  }
 else {
    new Exception(""String_Node_Str"");
  }
  return null;
}","@Callback public Object[] writeNFCData(Context contex,Arguments args){
  if (args.count() == 1 && args.checkString(0).length() <= 2048) {
    NFCData=args.checkString(0);
    worldObj.setBlockMetadataWithNotify(this.xCoord,this.yCoord,this.zCoord,1,2);
  }
 else {
    return new Object[]{false,""String_Node_Str""};
  }
  return new Object[]{true};
}"
13413,"@Override protected void onImpact(MovingObjectPosition mop){
  if (!this.worldObj.isRemote && this.shootingEntity != null && this.shootingEntity instanceof EntityPlayer) {
    EntityPlayer ep=(EntityPlayer)this.shootingEntity;
    int next=(ep.inventory.currentItem + 1) % 10;
    ItemStack toUse=ep.inventory.getStackInSlot(next);
    if (toUse.getItem() instanceof ItemWireCoil) {
      if (mop.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK) {
        if (toUse.getItem().onItemUseFirst(toUse,ep,this.worldObj,mop.blockX,mop.blockY,mop.blockZ,mop.sideHit,(float)mop.hitVec.xCoord % 1,(float)mop.hitVec.yCoord % 1,(float)mop.hitVec.zCoord % 1)) {
          this.worldObj.playSoundAtEntity(ep,""String_Node_Str"",.8F,1.2F / (this.rand.nextFloat() * .2F + .9F));
        }
      }
    }
    if (mop.typeOfHit == MovingObjectPosition.MovingObjectType.ENTITY) {
      mop.entityHit.attackEntityFrom(IEDamageSources.causeCasullDamage(this,shootingEntity),.5F);
    }
  }
}","@Override protected void onImpact(MovingObjectPosition mop){
  if (!this.worldObj.isRemote && this.shootingEntity != null && this.shootingEntity instanceof EntityPlayer) {
    if (alredyHit) {
      return;
    }
 else {
      alredyHit=true;
    }
    EntityPlayer ep=(EntityPlayer)this.shootingEntity;
    int next=(ep.inventory.currentItem + 1) % 10;
    ItemStack toUse=ep.inventory.getStackInSlot(next);
    if (toUse != null && toUse.getItem() instanceof ItemWireCoil) {
      if (mop.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK) {
        if (toUse.getItem().onItemUseFirst(toUse,ep,this.worldObj,mop.blockX,mop.blockY,mop.blockZ,mop.sideHit,(float)mop.hitVec.xCoord % 1,(float)mop.hitVec.yCoord % 1,(float)mop.hitVec.zCoord % 1)) {
          this.worldObj.playSoundAtEntity(ep,""String_Node_Str"",.8F,1.2F / (this.rand.nextFloat() * .2F + .9F));
        }
      }
    }
    if (mop.typeOfHit == MovingObjectPosition.MovingObjectType.ENTITY) {
      mop.entityHit.attackEntityFrom(IEDamageSources.causeCasullDamage(this,shootingEntity),.5F);
    }
  }
}"
13414,"public static Map<String,LogInstance> summarize(String[] args) throws FileNotFoundException, IOException {
  PrintStream out=System.out;
  Properties props=new Properties();
  FileInputStream fis=new FileInputStream(new File(""String_Node_Str""));
  try {
    props.load(fis);
  }
  finally {
    fis.close();
  }
  List<String> tsPatterns=new ArrayList<String>();
  List<String> dfPatterns=new ArrayList<String>();
  List<String> propKeys=new ArrayList<String>();
  Enumeration<String> keys=(Enumeration<String>)props.propertyNames();
  while (keys.hasMoreElements()) {
    String key=keys.nextElement();
    propKeys.add(key);
  }
  Collections.sort(propKeys,new DigitComparator(END_DIGITS,false));
  for (  String key : propKeys) {
    if (key.startsWith(""String_Node_Str"") && !key.endsWith(""String_Node_Str"")) {
      tsPatterns.add(props.getProperty(key));
      String df=props.getProperty(key + ""String_Node_Str"");
      dfPatterns.add(df);
    }
  }
  out.println(""String_Node_Str"" + tsPatterns);
  out.println(""String_Node_Str"" + dfPatterns);
  out.println();
  Pattern[] patterns=new Pattern[tsPatterns.size()];
  for (int i=0; i < patterns.length; i++) {
    patterns[i]=Pattern.compile(tsPatterns.get(i),Pattern.DOTALL);
  }
  List<String> textAspects=new ArrayList<String>();
  for (int i=1; i < args.length; i++) {
    if (args[i].equals(""String_Node_Str"")) {
      outputDir=args[++i];
      out.println(""String_Node_Str"" + outputDir);
    }
 else {
      out.println(""String_Node_Str"" + args[i]);
      textAspects.add(args[i]);
    }
  }
  long timeStart=new Date().getTime();
  List<File> files=new ArrayList<File>();
  File file=new File(args[0]);
  String matchText=null;
  File srcDir;
  if (file.getName().contains(""String_Node_Str"") || file.isFile()) {
    matchText=file.getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
    srcDir=file.getParentFile();
  }
 else {
    srcDir=file;
  }
  out.println(""String_Node_Str"" + srcDir);
  if (matchText != null) {
    out.println(""String_Node_Str"" + matchText);
  }
  out.println();
  getFiles(files,srcDir,matchText);
  Pattern pattern=DIGITS;
  for (  File f : files) {
    Matcher m=END_DIGITS.matcher(f.getName());
    if (m.matches()) {
      pattern=END_DIGITS;
      break;
    }
  }
  final Pattern digitPattern=pattern;
  Collections.sort(files,new DigitComparator(digitPattern,true));
  Map<String,LogInstance> logInstances=new HashMap<String,LogInstance>();
  if (outputDir != null) {
    createDir(outputDir);
  }
  long totalBytes=0;
  Map<String,LogInstance> hostToLogInstance=new LinkedHashMap<>();
  for (  File f : files) {
    String k;
    Matcher m=END_DIGITS2.matcher(f.getName());
    if (m.matches()) {
      k=m.group(1);
    }
 else {
      k=f.getName();
    }
    LogInstance logInstance=logInstances.get(k);
    if (logInstance == null) {
      String intanceOutputDir=null;
      if (outputDir != null) {
        intanceOutputDir=outputDir + File.separator + k;
        createDir(intanceOutputDir);
      }
      List<Aspect> aspects=new ArrayList<Aspect>();
      for (      String aspect : textAspects) {
        aspects.add(new TextMatchAspect(aspect,intanceOutputDir));
      }
      aspects.add(new OpenSearcherAspect());
      aspects.add(new CommitAspect());
      aspects.add(new QueryAspect(intanceOutputDir));
      aspects.add(new ErrorAspect(intanceOutputDir));
      logInstance=new LogInstance(aspects);
      hostToLogInstance.put(k,logInstance);
      logInstances.put(k,logInstance);
    }
    logInstance.track(f);
    totalBytes+=f.length();
    processFile(f,logInstance.getAspects(),patterns,dfPatterns.toArray(new String[0]),out);
  }
  long timeEnd=new Date().getTime();
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  out.println();
  out.println(""String_Node_Str"" + df.format((timeEnd - timeStart) / 1000.0 / 60.0) + ""String_Node_Str""+ df.format(totalBytes / 1024.0 / 1024.0)+ ""String_Node_Str""+ df.format(totalBytes / (float)files.size() / 1024.0/ 1024.0)+ ""String_Node_Str"");
  out.println();
  StringBuilder summary=new StringBuilder();
  summary.append(""String_Node_Str"");
  for (  Entry<String,LogInstance> liEntry : logInstances.entrySet()) {
    summary.append(""String_Node_Str"" + liEntry.getKey() + ""String_Node_Str"");
    for (    Aspect aspect : liEntry.getValue().getAspects()) {
      summary.append(""String_Node_Str"" + aspect.getSummaryLine());
    }
    summary.append(""String_Node_Str"");
  }
  out.print(summary + ""String_Node_Str"");
  if (outputDir != null) {
    PrintStream summaryOut=new PrintStream(new BufferedOutputStream(new FileOutputStream(outputDir + File.separator + ""String_Node_Str"")));
    summaryOut.print(summary);
    summaryOut.close();
  }
  for (  Entry<String,LogInstance> liEntry : logInstances.entrySet()) {
    PrintStream entryOut=out;
    if (outputDir != null) {
      entryOut=new PrintStream(new BufferedOutputStream(new FileOutputStream(outputDir + File.separator + liEntry.getKey()+ File.separator+ REPORT_FILENAME)));
    }
    entryOut.println(""String_Node_Str"" + liEntry.getKey());
    for (    Aspect aspect : liEntry.getValue().getAspects()) {
      entryOut.print(""String_Node_Str"" + aspect.getSummaryLine());
    }
    liEntry.getValue().printResults(entryOut);
    if (outputDir != null) {
      entryOut.close();
    }
    liEntry.getValue().close();
  }
  return hostToLogInstance;
}","public static Map<String,LogInstance> summarize(String[] args) throws FileNotFoundException, IOException {
  PrintStream out=System.out;
  Properties props=new Properties();
  FileInputStream fis=new FileInputStream(new File(""String_Node_Str""));
  try {
    props.load(fis);
  }
  finally {
    fis.close();
  }
  List<String> tsPatterns=new ArrayList<String>();
  List<String> dfPatterns=new ArrayList<String>();
  List<String> propKeys=new ArrayList<String>();
  Enumeration<String> keys=(Enumeration<String>)props.propertyNames();
  while (keys.hasMoreElements()) {
    String key=keys.nextElement();
    propKeys.add(key);
  }
  Collections.sort(propKeys,new DigitComparator(END_DIGITS,false));
  for (  String key : propKeys) {
    if (key.startsWith(""String_Node_Str"") && !key.endsWith(""String_Node_Str"")) {
      tsPatterns.add(props.getProperty(key));
      String df=props.getProperty(key + ""String_Node_Str"");
      dfPatterns.add(df);
    }
  }
  out.println(""String_Node_Str"" + tsPatterns);
  out.println(""String_Node_Str"" + dfPatterns);
  out.println();
  Pattern[] patterns=new Pattern[tsPatterns.size()];
  for (int i=0; i < patterns.length; i++) {
    patterns[i]=Pattern.compile(tsPatterns.get(i),Pattern.DOTALL);
  }
  List<String> textAspects=new ArrayList<String>();
  for (int i=1; i < args.length; i++) {
    if (args[i].equals(""String_Node_Str"")) {
      outputDir=args[++i];
      out.println(""String_Node_Str"" + outputDir);
    }
 else {
      out.println(""String_Node_Str"" + args[i]);
      textAspects.add(args[i]);
    }
  }
  long timeStart=new Date().getTime();
  List<File> files=new ArrayList<File>();
  File file=new File(args[0]);
  String matchText=null;
  File srcDir;
  if (file.getName().contains(""String_Node_Str"") || file.isFile()) {
    matchText=file.getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
    srcDir=file.getParentFile();
  }
 else {
    srcDir=file;
  }
  out.println(""String_Node_Str"" + srcDir);
  if (matchText != null) {
    out.println(""String_Node_Str"" + matchText);
  }
  out.println();
  getFiles(files,srcDir,matchText);
  Pattern pattern=DIGITS;
  for (  File f : files) {
    Matcher m=END_DIGITS.matcher(f.getName());
    if (m.matches()) {
      pattern=END_DIGITS;
      break;
    }
  }
  final Pattern digitPattern=pattern;
  Collections.sort(files,new DigitComparator(digitPattern,true));
  Map<String,LogInstance> logInstances=new HashMap<String,LogInstance>();
  if (outputDir != null) {
    createDir(outputDir);
  }
  long totalBytes=0;
  Map<String,LogInstance> hostToLogInstance=new LinkedHashMap<>();
  for (  File f : files) {
    String k;
    Matcher m=END_DIGITS2.matcher(f.getName());
    if (m.matches()) {
      k=m.group(1);
    }
 else {
      k=f.getName();
    }
    LogInstance logInstance=logInstances.get(k);
    if (logInstance == null) {
      String intanceOutputDir=null;
      if (outputDir != null) {
        intanceOutputDir=outputDir + File.separator + k;
        createDir(intanceOutputDir);
      }
      List<Aspect> aspects=new ArrayList<Aspect>();
      aspects.add(new OpenSearcherAspect());
      aspects.add(new CommitAspect());
      aspects.add(new QueryAspect(intanceOutputDir));
      aspects.add(new ErrorAspect(intanceOutputDir));
      for (      String aspect : textAspects) {
        aspects.add(new TextMatchAspect(aspect,intanceOutputDir));
      }
      logInstance=new LogInstance(aspects);
      hostToLogInstance.put(k,logInstance);
      logInstances.put(k,logInstance);
    }
    logInstance.track(f);
    totalBytes+=f.length();
    processFile(f,logInstance.getAspects(),patterns,dfPatterns.toArray(new String[0]),out);
  }
  long timeEnd=new Date().getTime();
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  out.println();
  out.println(""String_Node_Str"" + df.format((timeEnd - timeStart) / 1000.0 / 60.0) + ""String_Node_Str""+ df.format(totalBytes / 1024.0 / 1024.0)+ ""String_Node_Str""+ df.format(totalBytes / (float)files.size() / 1024.0/ 1024.0)+ ""String_Node_Str"");
  out.println();
  StringBuilder summary=new StringBuilder();
  summary.append(""String_Node_Str"");
  for (  Entry<String,LogInstance> liEntry : logInstances.entrySet()) {
    summary.append(""String_Node_Str"" + liEntry.getKey() + ""String_Node_Str"");
    for (    Aspect aspect : liEntry.getValue().getAspects()) {
      summary.append(""String_Node_Str"" + aspect.getSummaryLine());
    }
    summary.append(""String_Node_Str"");
  }
  out.print(summary + ""String_Node_Str"");
  if (outputDir != null) {
    PrintStream summaryOut=new PrintStream(new BufferedOutputStream(new FileOutputStream(outputDir + File.separator + ""String_Node_Str"")));
    summaryOut.print(summary);
    summaryOut.close();
  }
  for (  Entry<String,LogInstance> liEntry : logInstances.entrySet()) {
    PrintStream entryOut=out;
    if (outputDir != null) {
      entryOut=new PrintStream(new BufferedOutputStream(new FileOutputStream(outputDir + File.separator + liEntry.getKey()+ File.separator+ REPORT_FILENAME)));
    }
    entryOut.println(""String_Node_Str"" + liEntry.getKey());
    for (    Aspect aspect : liEntry.getValue().getAspects()) {
      entryOut.print(""String_Node_Str"" + aspect.getSummaryLine());
    }
    liEntry.getValue().printResults(entryOut);
    if (outputDir != null) {
      entryOut.close();
    }
    liEntry.getValue().close();
  }
  return hostToLogInstance;
}"
13415,"@Override public boolean process(String filename,String timestamp,Date dateTs,String headLine,String entry){
  if (dateTs == null) {
    dateTs=new Date(0);
  }
  if (headLine.contains(text) || entry.contains(text)) {
    Text text=new Text();
    text.text=headLine + (entry != null && entry.length() > 0 ? ""String_Node_Str"" + entry : ""String_Node_Str"");
    text.date=dateTs;
    text.filename=filename;
    texts.add(text);
  }
  return false;
}","@Override public boolean process(String filename,String timestamp,Date dateTs,String headLine,String entry){
  if (dateTs == null) {
    dateTs=new Date(0);
  }
  if (headLine.contains(text) || entry.contains(text)) {
    Text text=new Text();
    text.text=headLine + (entry != null && entry.length() > 0 ? ""String_Node_Str"" + entry : ""String_Node_Str"");
    text.date=dateTs;
    text.timestamp=timestamp;
    text.filename=filename;
    texts.add(text);
  }
  return false;
}"
13416,"@Override public void printReport(PrintStream out){
synchronized (texts) {
    Collections.sort(texts);
    out.println(""String_Node_Str"" + text);
    out.println(""String_Node_Str"");
    for (    Text t : texts) {
      out.println(""String_Node_Str"" + t.filename + ""String_Node_Str"");
      out.println(""String_Node_Str"" + t.text);
    }
  }
}","@Override public void printReport(PrintStream out){
synchronized (texts) {
    Collections.sort(texts);
    out.println(""String_Node_Str"" + text);
    out.println(""String_Node_Str"");
    for (    Text t : texts) {
      out.println(""String_Node_Str"" + t.timestamp + ""String_Node_Str""+ t.filename+ ""String_Node_Str"");
      out.println(""String_Node_Str"" + t.text + ""String_Node_Str"");
    }
  }
}"
13417,"public void fileReport(String outputDir){
  String filename=text.replaceAll(""String_Node_Str"",""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + text);
  sb.append(""String_Node_Str"");
  try {
    Files.write(Paths.get(outputDir,filename),sb.toString().getBytes(""String_Node_Str""),StandardOpenOption.APPEND);
  }
 catch (  UnsupportedEncodingException e) {
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
synchronized (texts) {
    for (    Text t : texts) {
      sb=new StringBuilder();
      sb.append(""String_Node_Str"" + t.filename + ""String_Node_Str"");
      sb.append(""String_Node_Str"" + t.text);
      try {
        Files.write(Paths.get(outputDir,filename),sb.toString().getBytes(""String_Node_Str""),StandardOpenOption.APPEND);
      }
 catch (      UnsupportedEncodingException e) {
      }
catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
}","public void fileReport(String outputDir){
  String filename=text.replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + text + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  try {
    Files.write(Paths.get(outputDir,filename),sb.toString().getBytes(""String_Node_Str""),StandardOpenOption.CREATE);
  }
 catch (  UnsupportedEncodingException e) {
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
synchronized (texts) {
    for (    Text t : texts) {
      sb=new StringBuilder();
      sb.append(""String_Node_Str"" + t.timestamp + ""String_Node_Str""+ t.filename+ ""String_Node_Str"");
      sb.append(""String_Node_Str"" + t.text + ""String_Node_Str"");
      try {
        Files.write(Paths.get(outputDir,filename),sb.toString().getBytes(""String_Node_Str""),StandardOpenOption.APPEND);
      }
 catch (      UnsupportedEncodingException e) {
      }
catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
}"
13418,"/** 
 * @param masterSpreadName
 * @return
 * @throws Exception 
 */
public Spread addSpread(String masterSpreadName) throws Exception {
  Spread spread=new Spread();
  assignIdAndRegister(spread);
  spread.setParent(this);
  MasterSpread masterSpread=this.getMasterSpread(masterSpreadName);
  spread.setTransformationMatrix(this.spreads.size());
  this.spreads.add(spread);
  spread.setMasterSpread(masterSpread);
  this.addChild(spread);
  return spread;
}","/** 
 * @param masterSpreadName
 * @return
 * @throws Exception 
 */
public Spread addSpread(String masterSpreadName) throws Exception {
  Spread spread=newSpread(masterSpreadName);
  assignIdAndRegister(spread);
  spread.setParent(this);
  MasterSpread masterSpread=this.getMasterSpread(masterSpreadName);
  spread.setTransformationMatrix(this.spreads.size());
  this.spreads.add(spread);
  spread.setMasterSpread(masterSpread);
  this.addChild(spread);
  return spread;
}"
13419,"/** 
 * @param masterSpreadName
 * @return
 * @throws Exception 
 */
public Spread newSpread(String masterSpreadName) throws Exception {
  Spread newSpread=new Spread();
  assignIdAndRegister(newSpread);
  newSpread.setParent(this);
  this.spreads.add(newSpread);
  MasterSpread masterSpread=this.getMasterSpread(masterSpreadName);
  if (masterSpread == null) {
    logger.info(""String_Node_Str"" + masterSpreadName + ""String_Node_Str"");
    for (    String key : this.masterSpreads.keySet()) {
      logger.info(""String_Node_Str"" + key + ""String_Node_Str"");
    }
    throw new Exception(""String_Node_Str"" + masterSpreadName + ""String_Node_Str"");
  }
  newSpread.setMasterSpread(masterSpread);
  newSpread.setTransformationMatrix(this.spreads.size());
  this.addChild(newSpread);
  return newSpread;
}","/** 
 * @param masterSpreadName
 * @return
 * @throws Exception 
 */
public Spread newSpread(String masterSpreadName) throws Exception {
  Spread newSpread=new Spread();
  assignIdAndRegister(newSpread);
  newSpread.setParent(this);
  newSpread.setSpreadIndex(this.spreads.size());
  this.spreads.add(newSpread);
  MasterSpread masterSpread=this.getMasterSpread(masterSpreadName);
  if (masterSpread == null) {
    logger.info(""String_Node_Str"" + masterSpreadName + ""String_Node_Str"");
    for (    String key : this.masterSpreads.keySet()) {
      logger.info(""String_Node_Str"" + key + ""String_Node_Str"");
    }
    throw new Exception(""String_Node_Str"" + masterSpreadName + ""String_Node_Str"");
  }
  newSpread.setMasterSpread(masterSpread);
  newSpread.setTransformationMatrix(this.spreads.size());
  this.addChild(newSpread);
  return newSpread;
}"
13420,"@Override public void updatePropertyMap() throws Exception {
  super.updatePropertyMap();
  setProperty(InDesignDocument.PROP_PAGC,new InxLong32(pages.size()));
  if (pages.size() == 1) {
    setProperty(""String_Node_Str"",new InxLong32(0));
  }
 else {
    setProperty(""String_Node_Str"",new InxLong32(1));
  }
}","@Override public void updatePropertyMap() throws Exception {
  super.updatePropertyMap();
  setProperty(InDesignDocument.PROP_PAGC,new InxLong32(pages.size()));
  if (pages.size() == 1) {
    setProperty(""String_Node_Str"",new InxLong32(0));
  }
 else {
    setProperty(""String_Node_Str"",new InxLong32(1));
  }
  if (pages.size() > 0) {
    setProperty(""String_Node_Str"",new InxInteger(pages.size()));
  }
  if (!hasProperty(""String_Node_Str"")) {
    setProperty(""String_Node_Str"",new InxBoolean(true));
  }
}"
13421,"/** 
 * Set the spread index (the sequence number of the spread within the list of spreads for a document. Must be called after initial object load or on object creation.
 * @param spreadIndex
 * @throws Exception
 */
public void setSpreadIndex(int spreadIndex) throws Exception {
  setTransformationMatrix(spreadIndex);
  logger.debug(""String_Node_Str"");
  assignRectanglesToPages();
}","/** 
 * Set the spread index (the sequence number of the spread within the list of spreads for a document. Must be called after initial object load or on object creation.
 * @param spreadIndex
 * @throws Exception
 */
public void setSpreadIndex(int spreadIndex) throws Exception {
  setTransformationMatrix(spreadIndex);
  this.spreadIndex=spreadIndex;
  logger.debug(""String_Node_Str"");
  assignRectanglesToPages();
}"
13422,"/** 
 * Set the next frame in the thread. Automatically sets this frame as the previous frame on  the specified text frame.
 * @param nextTextFrame The frame to which this frameis to be threaded.
 */
public void setNextInThread(TextFrame nextTextFrame){
  this.nextInThread=nextTextFrame;
  if (nextTextFrame != null) {
    nextTextFrame.setPreviousInThread(this);
  }
}","/** 
 * Set the next frame in the thread. Automatically sets this frame as the previous frame on  the specified text frame.
 * @param nextTextFrame The frame to which this frameis to be threaded.
 */
public void setNextInThread(TextFrame nextTextFrame){
  if (nextTextFrame == null) {
    if (this.nextInThread != null) {
      this.nextInThread.setPreviousInThread(null);
    }
  }
 else {
    nextTextFrame.setPreviousInThread(this);
  }
  this.nextInThread=nextTextFrame;
}"
13423,"private Element processInDesignComponent(InDesignComponent comp) throws Exception {
  String tagName=comp.getInxTagName();
  if (tagName == null) {
    throw new Exception(""String_Node_Str"" + comp);
  }
  Element myElement=this.currentParentNode.getOwnerDocument().createElement(tagName);
  this.currentParentNode.appendChild(myElement);
  for (  String propName : comp.getPropertyMap().keySet()) {
    InxValue value=comp.getValueObject(propName);
    myElement.setAttribute(propName,value.toEncodedString());
  }
  Node origParent=currentParentNode;
  currentParentNode=myElement;
  for (  InDesignComponent childComp : comp.getChildren()) {
    childComp.accept(this);
  }
  currentParentNode=origParent;
  return myElement;
}","private Element processInDesignComponent(InDesignComponent comp) throws Exception {
  comp.updatePropertyMap();
  String tagName=comp.getInxTagName();
  if (tagName == null) {
    throw new Exception(""String_Node_Str"" + comp);
  }
  Element myElement=this.currentParentNode.getOwnerDocument().createElement(tagName);
  this.currentParentNode.appendChild(myElement);
  for (  String propName : comp.getPropertyMap().keySet()) {
    InxValue value=comp.getValueObject(propName);
    myElement.setAttribute(propName,value.toEncodedString());
  }
  Node origParent=currentParentNode;
  currentParentNode=myElement;
  for (  InDesignComponent childComp : comp.getChildren()) {
    childComp.accept(this);
  }
  currentParentNode=origParent;
  return myElement;
}"
13424,"public void testCreateNewComplexPage() throws Exception {
  String masterSpreadName=""String_Node_Str"";
  String INITIAL_FRAME_LABEL=""String_Node_Str"";
  MasterSpread masterSpread=inDesignDoc.getMasterSpread(masterSpreadName);
  assertNotNull(""String_Node_Str"",masterSpread);
  int overrideableFrameCount=0;
  for (  TextFrame frame : masterSpread.getAllFrames()) {
    if (frame.isOverrideable())     overrideableFrameCount++;
  }
  Spread spread=null;
  Page page=null;
  spread=inDesignDoc.getSpread(0);
  spread.setMasterSpread(masterSpread);
  page=spread.getOddPage();
  assertNotNull(""String_Node_Str"",page);
  int spreadChildCount=spread.getChildren().size();
  spread.overrideMasterSpreadObjects();
  assertEquals(""String_Node_Str"",overrideableFrameCount,spread.getAllFrames().size());
  assertEquals(""String_Node_Str"",overrideableFrameCount + spreadChildCount,spread.getChildren().size());
  int originalChildCountAfterOverride=spread.getChildren().size();
  String targetLabel=INITIAL_FRAME_LABEL + (page.getPageSide().equals(PageSideOption.LEFT_HAND) ? ""String_Node_Str"" : ""String_Node_Str"");
  TextFrame frame=InxHelper.getFrameForLabel(spread,targetLabel);
  assertNotNull(""String_Node_Str"" + INITIAL_FRAME_LABEL + ""String_Node_Str"",frame);
  assertTrue(""String_Node_Str"",frame.getChildren().size() > 0);
  InDesignComponent wrapPrefs=null;
  for (  InDesignComponent child : frame.getChildren()) {
    if (""String_Node_Str"".equals(child.getInxTagName())) {
      wrapPrefs=child;
      break;
    }
  }
  assertNotNull(""String_Node_Str"",wrapPrefs);
  assertNotNull(""String_Node_Str"",incopyArticle01);
  Story incxStory=InxHelper.getStoryForIncxDoc(inDesignDoc,incopyArticle01);
  int txsrCnt=0;
  Iterator<TextStyleRange> iter=incxStory.getTextStyleRangeIterator();
  while (iter.hasNext()) {
    iter.next();
    txsrCnt++;
  }
  assertTrue(""String_Node_Str"",txsrCnt > 0);
  assertNotNull(""String_Node_Str"",incxStory);
  frame.setParentStory(incxStory);
  assertEquals(""String_Node_Str"",incxStory,frame.getParentStory());
  File inxFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  System.err.println(""String_Node_Str"" + inxFile.getAbsolutePath());
  InxWriter writer=new InxWriter(inxFile);
  writer.write(inDesignDoc);
  assertTrue(""String_Node_Str"",inxFile.exists());
  assertTrue(""String_Node_Str"",inxFile.length() > 0);
  assertTrue(""String_Node_Str"",inxFile.length() > 1000);
  Document inxDom=DataUtil.constructNonValidatingDocumentBuilder().parse(inxFile);
  assertNotNull(""String_Node_Str"",inxDom);
  Element docElem=inxDom.getDocumentElement();
  assertNotNull(""String_Node_Str"",docElem);
  assertEquals(""String_Node_Str"",""String_Node_Str"",docElem.getNodeName());
  InDesignDocument newDoc=new InDesignDocument();
  newDoc.load(docElem);
  assertEquals(""String_Node_Str"",1,newDoc.getSpreads().size());
  spread=newDoc.getSpread(0);
  assertNotNull(""String_Node_Str"",spread);
  assertEquals(""String_Node_Str"",originalChildCountAfterOverride,spread.getChildren().size());
  assertEquals(""String_Node_Str"",overrideableFrameCount,spread.getAllFrames().size());
  page=spread.getOddPage();
  assertNotNull(""String_Node_Str"",page);
}","public void testCreateNewComplexPage() throws Exception {
  String masterSpreadName=""String_Node_Str"";
  String INITIAL_FRAME_LABEL=""String_Node_Str"";
  MasterSpread masterSpread=inDesignDoc.getMasterSpread(masterSpreadName);
  assertNotNull(""String_Node_Str"",masterSpread);
  int overrideableFrameCount=0;
  for (  TextFrame frame : masterSpread.getAllFrames()) {
    if (frame.isOverrideable())     overrideableFrameCount++;
  }
  Spread spread=null;
  Page page=null;
  spread=inDesignDoc.getSpread(0);
  spread.setMasterSpread(masterSpread);
  assertEquals(0,spread.getSpreadIndex());
  page=spread.getOddPage();
  assertNotNull(""String_Node_Str"",page);
  assertEquals(""String_Node_Str"",1,spread.getPages().size());
  spread.addPage(2);
  assertEquals(""String_Node_Str"",2,spread.getPages().size());
  page=spread.getEvenPage();
  assertNotNull(""String_Node_Str"",page);
  spread.removePage(page);
  assertEquals(""String_Node_Str"",1,spread.getPages().size());
  page=spread.getEvenPage();
  assertNull(""String_Node_Str"",page);
  page=spread.getOddPage();
  assertNotNull(""String_Node_Str"");
  int spreadChildCount=spread.getChildren().size();
  spread.overrideMasterSpreadObjects();
  assertEquals(""String_Node_Str"",overrideableFrameCount,spread.getAllFrames().size());
  assertEquals(""String_Node_Str"",overrideableFrameCount + spreadChildCount,spread.getChildren().size());
  int originalChildCountAfterOverride=spread.getChildren().size();
  String targetLabel=INITIAL_FRAME_LABEL + (page.getPageSide().equals(PageSideOption.LEFT_HAND) ? ""String_Node_Str"" : ""String_Node_Str"");
  TextFrame frame=InxHelper.getFrameForLabel(spread,targetLabel);
  assertNotNull(""String_Node_Str"" + INITIAL_FRAME_LABEL + ""String_Node_Str"",frame);
  assertTrue(""String_Node_Str"",frame.getChildren().size() > 0);
  InDesignComponent wrapPrefs=null;
  for (  InDesignComponent child : frame.getChildren()) {
    if (""String_Node_Str"".equals(child.getInxTagName())) {
      wrapPrefs=child;
      break;
    }
  }
  assertNotNull(""String_Node_Str"",wrapPrefs);
  assertNotNull(""String_Node_Str"",incopyArticle01);
  Story incxStory=InxHelper.getStoryForIncxDoc(inDesignDoc,incopyArticle01);
  int txsrCnt=0;
  Iterator<TextStyleRange> iter=incxStory.getTextStyleRangeIterator();
  while (iter.hasNext()) {
    iter.next();
    txsrCnt++;
  }
  assertTrue(""String_Node_Str"",txsrCnt > 0);
  assertNotNull(""String_Node_Str"",incxStory);
  frame.setParentStory(incxStory);
  assertEquals(""String_Node_Str"",incxStory,frame.getParentStory());
  File inxFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  System.err.println(""String_Node_Str"" + inxFile.getAbsolutePath());
  InxWriter writer=new InxWriter(inxFile);
  writer.write(inDesignDoc);
  assertTrue(""String_Node_Str"",inxFile.exists());
  assertTrue(""String_Node_Str"",inxFile.length() > 0);
  assertTrue(""String_Node_Str"",inxFile.length() > 1000);
  Document inxDom=DataUtil.constructNonValidatingDocumentBuilder().parse(inxFile);
  assertNotNull(""String_Node_Str"",inxDom);
  Element docElem=inxDom.getDocumentElement();
  assertNotNull(""String_Node_Str"",docElem);
  assertEquals(""String_Node_Str"",""String_Node_Str"",docElem.getNodeName());
  InDesignDocument newDoc=new InDesignDocument();
  newDoc.load(docElem);
  assertEquals(""String_Node_Str"",1,newDoc.getSpreads().size());
  spread=newDoc.getSpread(0);
  assertNotNull(""String_Node_Str"",spread);
  assertEquals(""String_Node_Str"",originalChildCountAfterOverride,spread.getChildren().size());
  assertEquals(""String_Node_Str"",overrideableFrameCount,spread.getAllFrames().size());
  page=spread.getOddPage();
  assertNotNull(""String_Node_Str"",page);
}"
13425,"/** 
 * Tests the ability to access the page masters and frames within those page masters.
 * @throws Throwable
 */
public void testPageProperities() throws Throwable {
  InDesignDocument doc=new InDesignDocument();
  MasterSpread master;
  Spread spread;
  Collection<Page> pages;
  Page page;
  List<TextFrame> frames;
  String masterName;
  masterName=""String_Node_Str"";
  doc.load(inxData);
  master=doc.getMasterSpread(masterName);
  assertNotNull(master);
  pages=master.getPages();
  page=master.getEvenPage();
  assertNotNull(page);
  assertEquals(""String_Node_Str"",PageSideOption.LEFT_HAND,page.getPageSide());
  page=master.getOddPage();
  assertNotNull(page);
  assertEquals(""String_Node_Str"",PageSideOption.RIGHT_HAND,page.getPageSide());
  doc=new InDesignDocument();
  doc.load(geoTest);
  spread=doc.getSpreads().get(0);
  assertNotNull(""String_Node_Str"",spread);
  frames=spread.getAllFrames();
  assertNotNull(""String_Node_Str"",frames);
  assertTrue(""String_Node_Str"",frames.size() > 0);
  page=spread.getOddPage();
  assertNotNull(""String_Node_Str"",page);
  assertEquals(""String_Node_Str"",spread,page.getParent());
  frames=page.getAllFrames();
  assertNotNull(""String_Node_Str"",frames);
  assertTrue(""String_Node_Str"",frames.size() > 0);
  assertEquals(""String_Node_Str"" + frames.size(),5,frames.size());
}","/** 
 * Tests the ability to access the page masters and frames within those page masters.
 * @throws Throwable
 */
public void testPageProperities() throws Throwable {
  InDesignDocument doc=new InDesignDocument();
  MasterSpread master;
  Spread spread;
  Collection<Page> pages;
  Page page;
  List<TextFrame> frames;
  String masterName;
  masterName=""String_Node_Str"";
  doc.load(inxData);
  master=doc.getMasterSpread(masterName);
  assertNotNull(master);
  pages=master.getPages();
  page=master.getEvenPage();
  assertNotNull(page);
  assertEquals(""String_Node_Str"",PageSideOption.LEFT_HAND,page.getPageSide());
  page=master.getOddPage();
  assertNotNull(page);
  assertEquals(""String_Node_Str"",PageSideOption.RIGHT_HAND,page.getPageSide());
  doc=new InDesignDocument();
  doc.load(geoTest);
  spread=doc.getSpreads().get(0);
  return;
}"
13426,"@Override public void updatePropertyMap() throws Exception {
  super.updatePropertyMap();
  this.setObjectReferenceProperty(InDesignDocument.PROP_FTXF,this.getFirstFrameInThread());
  this.setObjectReferenceProperty(InDesignDocument.PROP_PTXF,this.previousInThread);
  this.setObjectReferenceProperty(InDesignDocument.PROP_NTXF,this.nextInThread);
  this.setObjectReferenceProperty(InDesignDocument.PROP_LTXF,this.getLastFrameInThread());
  this.setObjectReferenceProperty(InDesignDocument.PROP_STRP,this.parentStory);
}","@Override public void updatePropertyMap() throws Exception {
  super.updatePropertyMap();
  this.setObjectReferenceProperty(InDesignDocument.PROP_FTXF,this.getFirstFrameInThread());
  this.setObjectReferenceProperty(InDesignDocument.PROP_PTXF,this.getPreviousInThread());
  this.setObjectReferenceProperty(InDesignDocument.PROP_NTXF,this.getNextInThread());
  this.setObjectReferenceProperty(InDesignDocument.PROP_LTXF,this.getLastFrameInThread());
  this.setObjectReferenceProperty(InDesignDocument.PROP_STRP,this.getParentStory());
}"
13427,"/** 
 * Adds a new member, if the key is not already in the BOS. If the key is in the BOS, updates the existing member with the specified parent and returns the resulting member.
 * @param parentMember
 * @param member 
 * @return 
 */
public abstract BosMember addMember(BosMember parentMember,BosMember member) throws BosException ;","/** 
 * Adds a new member.
 * @param member Member to add if it is not already a member, based on member key matching.
 * @return The BosMember added or the pre-existing member instance.
 */
public abstract BosMember addMember(BosMember member);"
13428,"/** 
 * @param bos
 * @param dataSourceUri
 */
public BosMemberBase(DitaBoundedObjectSetImpl bos,URI dataSourceUri){
  this.bos=bos;
  this.setDataSourceUri(dataSourceUri);
  this.setEffectiveUri(dataSourceUri);
  this.key=dataSourceUri.toString();
}","/** 
 * @param bos
 * @param dataSourceUri
 */
public BosMemberBase(DitaBoundedObjectSet bos,URI dataSourceUri){
  this.bos=bos;
  this.setDataSourceUri(dataSourceUri);
  this.setEffectiveUri(dataSourceUri);
  this.key=dataSourceUri.toString();
}"
13429,"public BosMember addMember(BosMember parentMember,BosMember member){
  String memberKey=member.getKey();
  if (!this.members.containsKey(memberKey)) {
    this.members.put(memberKey,member);
  }
 else {
    member=getMember(member.getKey());
  }
  if (parentMember != null)   parentMember.addChild(member);
  return member;
}","@Override public BosMember addMember(BosMember member){
  String memberKey=member.getKey();
  if (!this.members.containsKey(memberKey)) {
    this.members.put(memberKey,member);
  }
 else {
    member=getMember(member.getKey());
  }
  return member;
}"
13430,"/** 
 * @param key
 * @return
 */
private BosMember getMember(String key){
  return this.members.get(key);
}","/** 
 * @param key
 * @return
 */
protected BosMember getMember(String key){
  return this.members.get(key);
}"
13431,"/** 
 * @param bos
 * @param member
 * @param newMembers
 * @throws Exception 
 */
protected void findLinkDependencies(BoundedObjectSet bos,XmlBosMember member,Set<BosMember> newMembers) throws Exception {
  NodeList links;
  try {
    links=(NodeList)DitaUtil.allHrefsAndKeyrefs.evaluate(member.getElement(),XPathConstants.NODESET);
  }
 catch (  XPathExpressionException e) {
    throw new BosException(""String_Node_Str"" + DitaUtil.allTopicrefs);
  }
  log.debug(""String_Node_Str"" + links.getLength() + ""String_Node_Str"");
  for (int i=0; i < links.getLength(); i++) {
    Element link=(Element)links.item(i);
    Document targetDoc=null;
    URI targetUri=null;
    String dependencyKey=null;
    String href=null;
    DependencyType depType=Constants.LINK_DEPENDENCY;
    if (DitaUtil.isDitaType(link,""String_Node_Str"")) {
      depType=Constants.IMAGE_DEPENDENCY;
    }
 else     if (DitaUtil.isDitaType(link,""String_Node_Str"")) {
      depType=Constants.XREF_DEPENDENCY;
    }
    try {
      if (link.hasAttribute(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + link.getAttribute(""String_Node_Str"") + ""String_Node_Str"");
        if (!DitaUtil.targetIsADitaFormat(link) || DitaUtil.isDitaType(link,""String_Node_Str"")) {
          targetUri=resolveKeyrefToUri(link.getAttribute(""String_Node_Str""));
        }
 else {
          targetDoc=resolveKeyrefToDoc(link.getAttribute(""String_Node_Str""));
        }
      }
      if (targetUri == null && targetDoc == null && link.hasAttribute(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + link.getAttribute(""String_Node_Str"") + ""String_Node_Str"");
        href=link.getAttribute(""String_Node_Str"");
        dependencyKey=href;
        if (DitaUtil.isDitaType(link,""String_Node_Str"")) {
          targetUri=AddressingUtil.resolveHrefToUri(link,link.getAttribute(""String_Node_Str""),this.failOnAddressResolutionFailure);
        }
 else         if (!DitaUtil.targetIsADitaFormat(link) && DitaUtil.isLocalOrPeerScope(link)) {
          targetUri=AddressingUtil.resolveHrefToUri(link,link.getAttribute(""String_Node_Str""),this.failOnAddressResolutionFailure);
        }
 else {
          if (!href.startsWith(""String_Node_Str"") && DitaUtil.isLocalOrPeerScope(link)) {
            targetDoc=AddressingUtil.resolveHrefToDoc(link,link.getAttribute(""String_Node_Str""),bosConstructionOptions,this.failOnAddressResolutionFailure);
          }
        }
      }
 else {
        dependencyKey=AddressingUtil.getKeyNameFromKeyref(link);
      }
    }
 catch (    AddressingException e) {
      if (this.failOnAddressResolutionFailure) {
        throw new BosException(""String_Node_Str"" + link.getAttribute(""String_Node_Str"") + ""String_Node_Str"",e);
      }
    }
    if (targetDoc == null && targetUri == null || targetDoc == member.getDocument())     continue;
    BosMember childMember=null;
    if (targetDoc != null) {
      log.debug(""String_Node_Str"" + targetDoc.getDocumentURI() + ""String_Node_Str"");
      childMember=bos.constructBosMember(member,targetDoc);
    }
 else     if (targetUri != null) {
      log.debug(""String_Node_Str"" + targetUri.toString() + ""String_Node_Str"");
      childMember=bos.constructBosMember((BosMember)member,targetUri);
    }
    newMembers.add(childMember);
    member.registerDependency(dependencyKey,childMember,depType);
  }
}","/** 
 * @param bos
 * @param member
 * @param newMembers
 * @throws Exception 
 */
protected void findLinkDependencies(BoundedObjectSet bos,XmlBosMember member,Set<BosMember> newMembers) throws Exception {
  NodeList links;
  try {
    links=(NodeList)DitaUtil.allHrefsAndKeyrefs.evaluate(member.getElement(),XPathConstants.NODESET);
  }
 catch (  XPathExpressionException e) {
    throw new BosException(""String_Node_Str"" + DitaUtil.allTopicrefs);
  }
  log.debug(""String_Node_Str"" + links.getLength() + ""String_Node_Str"");
  for (int i=0; i < links.getLength(); i++) {
    Element link=(Element)links.item(i);
    Document targetDoc=null;
    URI targetUri=null;
    String dependencyKey=null;
    String href=null;
    DependencyType depType=Constants.LINK_DEPENDENCY;
    if (DitaUtil.isDitaType(link,""String_Node_Str"")) {
      depType=Constants.IMAGE_DEPENDENCY;
    }
 else     if (DitaUtil.isDitaType(link,""String_Node_Str"")) {
      depType=Constants.XREF_DEPENDENCY;
    }
    try {
      if (link.hasAttribute(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + link.getAttribute(""String_Node_Str"") + ""String_Node_Str"");
        if (!DitaUtil.targetIsADitaFormat(link) || DitaUtil.isDitaType(link,""String_Node_Str"")) {
          targetUri=resolveKeyrefToUri(link.getAttribute(""String_Node_Str""));
        }
 else {
          targetDoc=resolveKeyrefToDoc(link.getAttribute(""String_Node_Str""));
        }
      }
      if (targetUri == null && targetDoc == null && link.hasAttribute(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + link.getAttribute(""String_Node_Str"") + ""String_Node_Str"");
        href=link.getAttribute(""String_Node_Str"");
        dependencyKey=href;
        if (DitaUtil.isDitaType(link,""String_Node_Str"")) {
          targetUri=AddressingUtil.resolveHrefToUri(link,link.getAttribute(""String_Node_Str""),this.failOnAddressResolutionFailure);
        }
 else         if (!DitaUtil.targetIsADitaFormat(link) && DitaUtil.isLocalOrPeerScope(link)) {
          targetUri=AddressingUtil.resolveHrefToUri(link,link.getAttribute(""String_Node_Str""),this.failOnAddressResolutionFailure);
        }
 else {
          if (!href.startsWith(""String_Node_Str"") && DitaUtil.isLocalOrPeerScope(link)) {
            targetDoc=AddressingUtil.resolveHrefToDoc(link,link.getAttribute(""String_Node_Str""),bosConstructionOptions,this.failOnAddressResolutionFailure);
          }
        }
      }
 else {
        dependencyKey=AddressingUtil.getKeyNameFromKeyref(link);
      }
    }
 catch (    AddressingException e) {
      if (this.failOnAddressResolutionFailure) {
        throw new BosException(""String_Node_Str"" + link.getAttribute(""String_Node_Str"") + ""String_Node_Str"",e);
      }
    }
    if (targetDoc == null && targetUri == null || targetDoc == member.getDocument())     continue;
    BosMember depMember=null;
    if (targetDoc != null) {
      log.debug(""String_Node_Str"" + targetDoc.getDocumentURI() + ""String_Node_Str"");
      depMember=bos.constructBosMember(member,targetDoc);
    }
 else     if (targetUri != null) {
      log.debug(""String_Node_Str"" + targetUri.toString() + ""String_Node_Str"");
      depMember=bos.constructBosMember((BosMember)member,targetUri);
    }
    newMembers.add(depMember);
    bos.addMemberAsDependency(dependencyKey,depType,member,depMember);
  }
}"
13432,"private void findConrefDependencies(BoundedObjectSet bos,XmlBosMember member,Set<BosMember> newMembers) throws Exception {
  NodeList conrefs;
  try {
    conrefs=(NodeList)DitaUtil.allConrefs.evaluate(member.getElement(),XPathConstants.NODESET);
  }
 catch (  XPathExpressionException e) {
    throw new BosException(""String_Node_Str"" + DitaUtil.allTopicrefs);
  }
  for (int i=0; i < conrefs.getLength(); i++) {
    Element conref=(Element)conrefs.item(i);
    Document targetDoc=null;
    String href=null;
    try {
      if (conref.hasAttribute(""String_Node_Str"")) {
        targetDoc=resolveKeyrefToDoc(conref.getAttribute(""String_Node_Str""));
      }
      if (targetDoc == null && conref.hasAttribute(""String_Node_Str"")) {
        href=conref.getAttribute(""String_Node_Str"");
        if (!href.startsWith(""String_Node_Str""))         targetDoc=AddressingUtil.resolveHrefToDoc(conref,href,bosConstructionOptions,this.failOnAddressResolutionFailure);
      }
    }
 catch (    AddressingException e) {
      if (this.failOnAddressResolutionFailure) {
        throw new BosException(""String_Node_Str"" + conref.getAttribute(""String_Node_Str"") + ""String_Node_Str"",e);
      }
    }
    if (targetDoc != null && targetDoc != member.getDocument()) {
      BosMember childMember=bos.constructBosMember(member,targetDoc);
      newMembers.add(childMember);
      if (href != null) {
        member.registerDependency(href,childMember,Constants.CONREF_DEPENDENCY);
      }
    }
  }
}","private void findConrefDependencies(BoundedObjectSet bos,XmlBosMember member,Set<BosMember> newMembers) throws Exception {
  NodeList conrefs;
  try {
    conrefs=(NodeList)DitaUtil.allConrefs.evaluate(member.getElement(),XPathConstants.NODESET);
  }
 catch (  XPathExpressionException e) {
    throw new BosException(""String_Node_Str"" + DitaUtil.allTopicrefs);
  }
  for (int i=0; i < conrefs.getLength(); i++) {
    Element conref=(Element)conrefs.item(i);
    Document targetDoc=null;
    String href=null;
    try {
      if (conref.hasAttribute(""String_Node_Str"")) {
        targetDoc=resolveKeyrefToDoc(conref.getAttribute(""String_Node_Str""));
      }
      if (targetDoc == null && conref.hasAttribute(""String_Node_Str"")) {
        href=conref.getAttribute(""String_Node_Str"");
        if (!href.startsWith(""String_Node_Str""))         targetDoc=AddressingUtil.resolveHrefToDoc(conref,href,bosConstructionOptions,this.failOnAddressResolutionFailure);
      }
    }
 catch (    AddressingException e) {
      if (this.failOnAddressResolutionFailure) {
        throw new BosException(""String_Node_Str"" + conref.getAttribute(""String_Node_Str"") + ""String_Node_Str"",e);
      }
    }
    if (targetDoc != null && targetDoc != member.getDocument()) {
      BosMember childMember=bos.constructBosMember(member,targetDoc);
      newMembers.add(childMember);
      if (href != null) {
        bos.addMemberAsDependency(href,Constants.CONREF_DEPENDENCY,member,childMember);
      }
 else {
        bos.addMember(childMember);
      }
    }
  }
}"
13433,"/** 
 * @param bos
 * @param member
 * @throws Exception 
 */
protected void walkMapGetDependencies(BoundedObjectSet bos,DitaMapBosMemberImpl member) throws Exception {
  NodeList topicrefs;
  try {
    topicrefs=(NodeList)DitaUtil.allTopicrefs.evaluate(member.getElement(),XPathConstants.NODESET);
  }
 catch (  XPathExpressionException e) {
    throw new BosException(""String_Node_Str"" + DitaUtil.allTopicrefs);
  }
  Set<BosMember> newMembers=new HashSet<BosMember>();
  for (int i=0; i < topicrefs.getLength(); i++) {
    Element topicref=(Element)topicrefs.item(i);
    Document targetDoc=null;
    URI targetUri=null;
    if (!DitaUtil.isLocalScope(topicref))     continue;
    String href=null;
    try {
      if (bosConstructionOptions.isMapTreeOnly()) {
        if (DitaUtil.targetIsADitaMap(topicref) && topicref.hasAttribute(""String_Node_Str"")) {
          href=topicref.getAttribute(""String_Node_Str"");
          if (!href.startsWith(""String_Node_Str""))           targetDoc=AddressingUtil.resolveHrefToDoc(topicref,href,bosConstructionOptions,this.failOnAddressResolutionFailure);
        }
      }
 else       if (DitaUtil.targetIsADitaFormat(topicref)) {
        if (topicref.hasAttribute(""String_Node_Str"")) {
          targetDoc=resolveKeyrefToDoc(topicref.getAttribute(""String_Node_Str""));
        }
        if (targetDoc == null && topicref.hasAttribute(""String_Node_Str"")) {
          href=topicref.getAttribute(""String_Node_Str"");
          if (!href.startsWith(""String_Node_Str""))           targetDoc=AddressingUtil.resolveHrefToDoc(topicref,href,bosConstructionOptions,this.failOnAddressResolutionFailure);
        }
      }
 else {
        if (topicref.hasAttribute(""String_Node_Str"")) {
          targetUri=resolveKeyrefToUri(topicref.getAttribute(""String_Node_Str""));
        }
        if (targetUri == null && topicref.hasAttribute(""String_Node_Str"")) {
          href=topicref.getAttribute(""String_Node_Str"");
          if (!href.startsWith(""String_Node_Str""))           targetUri=AddressingUtil.resolveHrefToUri(topicref,href,this.failOnAddressResolutionFailure);
        }
      }
    }
 catch (    AddressingException e) {
      if (this.failOnAddressResolutionFailure) {
        throw new BosException(""String_Node_Str"" + topicref.getAttribute(""String_Node_Str"") + ""String_Node_Str"",e);
      }
    }
    BosMember childMember=null;
    if (targetDoc != null) {
      childMember=bos.constructBosMember(member,targetDoc);
    }
    if (targetUri != null) {
      childMember=bos.constructBosMember(member,targetUri);
    }
    if (childMember != null) {
      bos.addMember(member,childMember);
      newMembers.add((BosMember)childMember);
      if (href != null)       member.registerDependency(href,childMember,Constants.TOPICREF_DEPENDENCY);
    }
  }
  for (  BosMember newMember : newMembers) {
    if (!walkedMembers.contains(newMember))     walkMemberGetDependencies(bos,newMember);
  }
}","/** 
 * @param bos
 * @param member
 * @throws Exception 
 */
protected void walkMapGetDependencies(BoundedObjectSet bos,DitaMapBosMember member) throws Exception {
  NodeList topicrefs;
  try {
    topicrefs=(NodeList)DitaUtil.allTopicrefs.evaluate(member.getElement(),XPathConstants.NODESET);
  }
 catch (  XPathExpressionException e) {
    throw new BosException(""String_Node_Str"" + DitaUtil.allTopicrefs);
  }
  Set<BosMember> newMembers=new HashSet<BosMember>();
  for (int i=0; i < topicrefs.getLength(); i++) {
    Element topicref=(Element)topicrefs.item(i);
    Document targetDoc=null;
    URI targetUri=null;
    if (!DitaUtil.isLocalScope(topicref))     continue;
    String href=null;
    try {
      if (bosConstructionOptions.isMapTreeOnly()) {
        if (DitaUtil.targetIsADitaMap(topicref) && topicref.hasAttribute(""String_Node_Str"")) {
          href=topicref.getAttribute(""String_Node_Str"");
          if (!href.startsWith(""String_Node_Str""))           targetDoc=AddressingUtil.resolveHrefToDoc(topicref,href,bosConstructionOptions,this.failOnAddressResolutionFailure);
        }
      }
 else       if (DitaUtil.targetIsADitaFormat(topicref)) {
        if (topicref.hasAttribute(""String_Node_Str"")) {
          targetDoc=resolveKeyrefToDoc(topicref.getAttribute(""String_Node_Str""));
        }
        if (targetDoc == null && topicref.hasAttribute(""String_Node_Str"")) {
          href=topicref.getAttribute(""String_Node_Str"");
          if (!href.startsWith(""String_Node_Str""))           targetDoc=AddressingUtil.resolveHrefToDoc(topicref,href,bosConstructionOptions,this.failOnAddressResolutionFailure);
        }
      }
 else {
        if (topicref.hasAttribute(""String_Node_Str"")) {
          targetUri=resolveKeyrefToUri(topicref.getAttribute(""String_Node_Str""));
        }
        if (targetUri == null && topicref.hasAttribute(""String_Node_Str"")) {
          href=topicref.getAttribute(""String_Node_Str"");
          if (!href.startsWith(""String_Node_Str""))           targetUri=AddressingUtil.resolveHrefToUri(topicref,href,this.failOnAddressResolutionFailure);
        }
      }
    }
 catch (    AddressingException e) {
      if (this.failOnAddressResolutionFailure) {
        throw new BosException(""String_Node_Str"" + topicref.getAttribute(""String_Node_Str"") + ""String_Node_Str"",e);
      }
    }
    BosMember childMember=null;
    if (targetDoc != null) {
      childMember=bos.constructBosMember(member,targetDoc);
    }
    if (targetUri != null) {
      childMember=bos.constructBosMember(member,targetUri);
    }
    if (childMember != null) {
      bos.addMember(member,childMember);
      newMembers.add((BosMember)childMember);
      if (href != null)       member.registerDependency(href,childMember,Constants.TOPICREF_DEPENDENCY);
    }
  }
  for (  BosMember newMember : newMembers) {
    if (!walkedMembers.contains(newMember))     walkMemberGetDependencies(bos,newMember);
  }
}"
13434,"/** 
 * @param bos
 * @param member
 * @throws Exception 
 */
protected void walkMemberGetDependencies(BoundedObjectSet bos,BosMember member) throws Exception {
  if (!(member instanceof XmlBosMember)) {
  }
 else {
    Element elem=((XmlBosMember)member).getElement();
    this.walkedMembers.add(member);
    if (DitaUtil.isDitaMap(elem)) {
      walkMapGetDependencies(bos,(DitaMapBosMemberImpl)member);
    }
 else     if (DitaUtil.isDitaTopic(elem) || DitaUtil.isDitaBase(elem)) {
      walkTopicGetDependencies(bos,(DitaTopicBosMemberImpl)member);
    }
 else {
      log.warn(""String_Node_Str"" + elem.getTagName() + ""String_Node_Str"");
    }
  }
}","/** 
 * @param bos
 * @param member
 * @throws Exception 
 */
protected void walkMemberGetDependencies(BoundedObjectSet bos,BosMember member) throws Exception {
  if (!(member instanceof XmlBosMember)) {
  }
 else {
    Element elem=((XmlBosMember)member).getElement();
    this.walkedMembers.add(member);
    if (DitaUtil.isDitaMap(elem)) {
      walkMapGetDependencies(bos,(DitaMapBosMember)member);
    }
 else     if (DitaUtil.isDitaTopic(elem) || DitaUtil.isDitaBase(elem)) {
      walkTopicGetDependencies(bos,(DitaTopicBosMember)member);
    }
 else {
      log.warn(""String_Node_Str"" + elem.getTagName() + ""String_Node_Str"");
    }
  }
}"
13435,"/** 
 * Handles DITA BOS members in order to do pointer rewriting. By default calls rewriteLocalUris(), which must be implemented by subclasses. Can override this method to add different business logic (such as handling pointers to external or peer resources, rewriting key references, updating content in a CMS, etc.).
 */
public void visit(DitaBosMemberImpl bosMember) throws BosException {
  try {
    if (rewriteLocalUris(bosMember)) {
    }
  }
 catch (  AddressingException e) {
    throw new BosException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Handles DITA BOS members in order to do pointer rewriting. By default calls rewriteLocalUris(), which must be implemented by subclasses. Can override this method to add different business logic (such as handling pointers to external or peer resources, rewriting key references, updating content in a CMS, etc.).
 */
public void visit(DitaBosMember bosMember) throws BosException {
  try {
    if (rewriteLocalUris(bosMember)) {
    }
  }
 catch (  AddressingException e) {
    throw new BosException(""String_Node_Str"" + e.getMessage(),e);
  }
}"
13436,"public boolean rewriteLocalUris(DitaBosMemberImpl member) throws BosException, AddressingException {
  log.debug(""String_Node_Str"" + member + ""String_Node_Str"");
  NodeList nl;
  try {
    nl=(NodeList)DitaUtil.allHrefsAndConrefs.evaluate(member.getElement(),XPathConstants.NODESET);
  }
 catch (  XPathExpressionException e) {
    throw new BosException(""String_Node_Str"" + DitaUtil.allHrefsAndConrefs,e);
  }
  boolean contentModified=false;
  if (nl.getLength() > 0) {
    for (int i=0; i < nl.getLength(); i++) {
      Element ref=(Element)nl.item(i);
      if (ref.hasAttribute(""String_Node_Str"") && DitaUtil.isLocalScope(ref))       ;
      String href=ref.getAttribute(""String_Node_Str"");
      BosMember depMember=member.getDependency(href);
      if (depMember == null) {
        log.warn(""String_Node_Str"" + href + ""String_Node_Str"");
        continue;
      }
      String newHref=constructNewHref(member,depMember,ref);
      ref.setAttribute(""String_Node_Str"",newHref);
      contentModified=true;
      log.debug(""String_Node_Str"" + href + ""String_Node_Str""+ newHref+ ""String_Node_Str"");
    }
  }
  return contentModified;
}","public boolean rewriteLocalUris(DitaBosMember member) throws BosException, AddressingException {
  log.debug(""String_Node_Str"" + member + ""String_Node_Str"");
  NodeList nl;
  try {
    nl=(NodeList)DitaUtil.allHrefsAndConrefs.evaluate(member.getElement(),XPathConstants.NODESET);
  }
 catch (  XPathExpressionException e) {
    throw new BosException(""String_Node_Str"" + DitaUtil.allHrefsAndConrefs,e);
  }
  boolean contentModified=false;
  if (nl.getLength() > 0) {
    for (int i=0; i < nl.getLength(); i++) {
      Element ref=(Element)nl.item(i);
      if (ref.hasAttribute(""String_Node_Str"") && DitaUtil.isLocalScope(ref))       ;
      String href=ref.getAttribute(""String_Node_Str"");
      BosMember depMember=member.getDependency(href);
      if (depMember == null) {
        log.warn(""String_Node_Str"" + href + ""String_Node_Str"");
        continue;
      }
      String newHref=constructNewHref(member,depMember,ref);
      ref.setAttribute(""String_Node_Str"",newHref);
      contentModified=true;
      log.debug(""String_Node_Str"" + href + ""String_Node_Str""+ newHref+ ""String_Node_Str"");
    }
  }
  return contentModified;
}"
13437,"/** 
 * @param member 
 * @param depMember 
 * @param ref
 * @return
 * @throws AddressingException 
 */
protected abstract String constructNewHref(DitaBosMemberImpl member,BosMember depMember,Element ref) throws BosException, AddressingException ;","/** 
 * @param member 
 * @param depMember 
 * @param ref
 * @return
 * @throws AddressingException 
 */
protected abstract String constructNewHref(DitaBosMember member,BosMember depMember,Element ref) throws BosException, AddressingException ;"
13438,"@Override protected String constructNewHref(DitaBosMemberImpl member,BosMember depMember,Element ref) throws BosException, AddressingException {
  URI baseUri;
  try {
    baseUri=AddressingUtil.getParent(member.getEffectiveUri());
  }
 catch (  URISyntaxException e) {
    throw new AddressingException(""String_Node_Str"" + member.getEffectiveUri() + ""String_Node_Str""+ e.getMessage());
  }
catch (  MalformedURLException e) {
    throw new AddressingException(""String_Node_Str"" + member.getEffectiveUri() + ""String_Node_Str""+ e.getMessage());
  }
catch (  IOException e) {
    throw new AddressingException(""String_Node_Str"" + member.getEffectiveUri() + ""String_Node_Str""+ e.getMessage());
  }
  URI depUri=depMember.getEffectiveUri();
  String newHref=AddressingUtil.getRelativePath(depUri,baseUri);
  log.debug(""String_Node_Str"" + newHref + ""String_Node_Str"");
  return newHref;
}","@Override protected String constructNewHref(DitaBosMember member,BosMember depMember,Element ref) throws BosException, AddressingException {
  URI baseUri;
  try {
    baseUri=AddressingUtil.getParent(member.getEffectiveUri());
  }
 catch (  URISyntaxException e) {
    throw new AddressingException(""String_Node_Str"" + member.getEffectiveUri() + ""String_Node_Str""+ e.getMessage());
  }
catch (  MalformedURLException e) {
    throw new AddressingException(""String_Node_Str"" + member.getEffectiveUri() + ""String_Node_Str""+ e.getMessage());
  }
catch (  IOException e) {
    throw new AddressingException(""String_Node_Str"" + member.getEffectiveUri() + ""String_Node_Str""+ e.getMessage());
  }
  URI depUri=depMember.getEffectiveUri();
  String newHref=AddressingUtil.getRelativePath(depUri,baseUri);
  log.debug(""String_Node_Str"" + newHref + ""String_Node_Str"");
  return newHref;
}"
13439,"private static File getFileForUrlString(File baseFile,String fileUrlStr) throws AddressingException {
  File resultFile=null;
  try {
    URL baseUrl=baseFile.toURL();
    URL targetUrl=new URL(baseUrl,fileUrlStr);
    resultFile=new File(targetUrl.getFile());
  }
 catch (  Throwable e) {
    throw new AddressingException(""String_Node_Str"" + fileUrlStr + ""String_Node_Str"",e);
  }
  return resultFile;
}","private static File getFileForUrlString(File baseFile,String fileUrlStr) throws AddressingException {
  File resultFile=null;
  try {
    URL baseUrl=baseFile.toURI().toURL();
    ;
    URL targetUrl=new URL(baseUrl,fileUrlStr);
    resultFile=new File(targetUrl.getFile());
  }
 catch (  Throwable e) {
    throw new AddressingException(""String_Node_Str"" + fileUrlStr + ""String_Node_Str"",e);
  }
  return resultFile;
}"
13440,"/** 
 * @throws Exception 
 */
private void run() throws Exception {
  String mapFilepath=commandLine.getOptionValue(""String_Node_Str"");
  File mapFile=new File(mapFilepath).getAbsoluteFile();
  checkExistsAndCanReadSystemExit(mapFile);
  DitaDxpOptions dxpOptions=new DitaDxpOptions();
  handleCommonDxpOptions(dxpOptions);
  if (!dxpOptions.isQuiet())   System.err.println(""String_Node_Str"" + mapFile.getAbsolutePath() + ""String_Node_Str"");
  File outputZipFile=null;
  String outputFilepath=null;
  if (commandLine.hasOption(OUTPUT_OPTION_ONE_CHAR)) {
    outputFilepath=commandLine.getOptionValue(OUTPUT_OPTION_ONE_CHAR);
    outputZipFile=new File(outputFilepath).getAbsoluteFile();
  }
 else {
    File parentDir=mapFile.getParentFile();
    String nameBase=FilenameUtils.getBaseName(mapFile.getName());
    outputZipFile=new File(parentDir,nameBase + DXP_EXTENSION);
  }
  File parentFile=outputZipFile.getParentFile();
  parentFile.mkdirs();
  if (!outputZipFile.getParentFile().canWrite()) {
    throw new RuntimeException(""String_Node_Str"" + outputZipFile.getAbsolutePath() + ""String_Node_Str"");
  }
  Document rootMap=null;
  BosConstructionOptions bosOptions=new BosConstructionOptions(log,new HashMap<URI,Document>());
  bosOptions.setQuiet(dxpOptions.isQuiet());
  boolean failOnAddressingFailure=false;
  if (commandLine.hasOption(ADDRESSING_FAILURE_OPTION_ONE_CHAR))   failOnAddressingFailure=true;
  bosOptions.setFailOnAddressResolutionFailure(failOnAddressingFailure);
  setupCatalogs(bosOptions);
  try {
    URL rootMapUrl=mapFile.toURL();
    rootMap=DomUtil.getDomForUri(new URI(rootMapUrl.toExternalForm()),bosOptions);
    Date startTime=TimingUtils.getNowTime();
    DitaBoundedObjectSet mapBos=DitaBosHelper.calculateMapBos(bosOptions,log,rootMap);
    if (!dxpOptions.isQuiet())     System.err.println(""String_Node_Str"" + TimingUtils.reportElapsedTime(startTime));
    DitaDxpHelper.zipMapBos(mapBos,outputZipFile,dxpOptions);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
  }
}","/** 
 * @throws Exception 
 */
private void run() throws Exception {
  String mapFilepath=commandLine.getOptionValue(""String_Node_Str"");
  File mapFile=new File(mapFilepath).getAbsoluteFile();
  checkExistsAndCanReadSystemExit(mapFile);
  DitaDxpOptions dxpOptions=new DitaDxpOptions();
  handleCommonBosProcessorOptions(dxpOptions);
  if (!dxpOptions.isQuiet())   System.err.println(""String_Node_Str"" + mapFile.getAbsolutePath() + ""String_Node_Str"");
  File outputZipFile=null;
  String outputFilepath=null;
  if (commandLine.hasOption(OUTPUT_OPTION_ONE_CHAR)) {
    outputFilepath=commandLine.getOptionValue(OUTPUT_OPTION_ONE_CHAR);
    outputZipFile=new File(outputFilepath).getAbsoluteFile();
  }
 else {
    File parentDir=mapFile.getParentFile();
    String nameBase=FilenameUtils.getBaseName(mapFile.getName());
    outputZipFile=new File(parentDir,nameBase + DXP_EXTENSION);
  }
  File parentFile=outputZipFile.getParentFile();
  parentFile.mkdirs();
  if (!outputZipFile.getParentFile().canWrite()) {
    throw new RuntimeException(""String_Node_Str"" + outputZipFile.getAbsolutePath() + ""String_Node_Str"");
  }
  Document rootMap=null;
  BosConstructionOptions bosOptions=new BosConstructionOptions(log,new HashMap<URI,Document>());
  bosOptions.setQuiet(dxpOptions.isQuiet());
  boolean failOnAddressingFailure=false;
  if (commandLine.hasOption(ADDRESSING_FAILURE_OPTION_ONE_CHAR))   failOnAddressingFailure=true;
  bosOptions.setFailOnAddressResolutionFailure(failOnAddressingFailure);
  setupCatalogs(bosOptions);
  try {
    URL rootMapUrl=mapFile.toURI().toURL();
    rootMap=DomUtil.getDomForUri(new URI(rootMapUrl.toExternalForm()),bosOptions);
    Date startTime=TimingUtils.getNowTime();
    DitaBoundedObjectSet mapBos=DitaBosHelper.calculateMapBos(bosOptions,log,rootMap);
    if (!dxpOptions.isQuiet())     System.err.println(""String_Node_Str"" + TimingUtils.reportElapsedTime(startTime));
    DitaDxpHelper.zipMapBos(mapBos,outputZipFile,dxpOptions);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
  }
}"
13441,"/** 
 * @throws Exception 
 */
private void run() throws Exception {
  DitaDxpOptions dxpOptions=new DitaDxpOptions();
  handleCommonDxpOptions(dxpOptions);
  String dxpFilepath=commandLine.getOptionValue(INPUT_OPTION_ONE_CHAR);
  File dxpFile=new File(dxpFilepath);
  checkExistsAndCanReadSystemExit(dxpFile);
  if (!dxpOptions.isQuiet())   log.info(""String_Node_Str"" + dxpFile.getAbsolutePath() + ""String_Node_Str"");
  String outputDirpath=commandLine.getOptionValue(OUTPUT_OPTION_ONE_CHAR);
  File outputDir=new File(outputDirpath);
  if (outputDir.exists() && !outputDir.isDirectory()) {
    System.err.println(""String_Node_Str"" + outputDirpath + ""String_Node_Str"");
    System.exit(1);
  }
  outputDir.mkdirs();
  if (!outputDir.exists()) {
    System.err.println(""String_Node_Str"" + outputDirpath + ""String_Node_Str"");
    System.exit(1);
  }
  if (!outputDir.canWrite()) {
    System.err.println(""String_Node_Str"" + outputDirpath + ""String_Node_Str"");
    System.exit(1);
  }
  String[] mapIds=commandLine.getOptionValues(MAPS_ID_OPTION_ONE_CHAR);
  if (mapIds != null && mapIds.length > 0) {
    for (    String mapId : mapIds) {
      dxpOptions.addMapId(mapId);
    }
  }
  try {
    DitaDxpHelper.unpackDxpPackage(dxpFile,outputDir,dxpOptions,log);
  }
 catch (  DitaDxpException e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * @throws Exception 
 */
private void run() throws Exception {
  DitaDxpOptions dxpOptions=new DitaDxpOptions();
  handleCommonBosProcessorOptions(dxpOptions);
  String dxpFilepath=commandLine.getOptionValue(INPUT_OPTION_ONE_CHAR);
  File dxpFile=new File(dxpFilepath);
  checkExistsAndCanReadSystemExit(dxpFile);
  if (!dxpOptions.isQuiet())   log.info(""String_Node_Str"" + dxpFile.getAbsolutePath() + ""String_Node_Str"");
  String outputDirpath=commandLine.getOptionValue(OUTPUT_OPTION_ONE_CHAR);
  File outputDir=new File(outputDirpath);
  if (outputDir.exists() && !outputDir.isDirectory()) {
    System.err.println(""String_Node_Str"" + outputDirpath + ""String_Node_Str"");
    System.exit(1);
  }
  outputDir.mkdirs();
  if (!outputDir.exists()) {
    System.err.println(""String_Node_Str"" + outputDirpath + ""String_Node_Str"");
    System.exit(1);
  }
  if (!outputDir.canWrite()) {
    System.err.println(""String_Node_Str"" + outputDirpath + ""String_Node_Str"");
    System.exit(1);
  }
  String[] mapIds=commandLine.getOptionValues(MAPS_ID_OPTION_ONE_CHAR);
  if (mapIds != null && mapIds.length > 0) {
    for (    String mapId : mapIds) {
      dxpOptions.addMapId(mapId);
    }
  }
  try {
    DitaDxpHelper.unpackDxpPackage(dxpFile,outputDir,dxpOptions,log);
  }
 catch (  DitaDxpException e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
  }
}"
13442,"/** 
 * @param zipFile
 * @param dxpOptions 
 * @return
 * @throws DitaDxpException 
 */
public static ZipEntry getDxpPackageRootMap(ZipFile zipFile,DitaDxpOptions dxpOptions) throws DitaDxpException {
  List<ZipEntry> candidateRootEntries=new ArrayList<ZipEntry>();
  List<ZipEntry> candidateDirs=new ArrayList<ZipEntry>();
  Enumeration<? extends ZipEntry> entries=zipFile.entries();
  while (entries.hasMoreElements()) {
    ZipEntry entry=entries.nextElement();
    File temp=new File(entry.getName());
    String parentPath=temp.getParent();
    if (entry.isDirectory()) {
      if (parentPath == null || ""String_Node_Str"".equals(parentPath)) {
        candidateDirs.add(entry);
      }
    }
 else {
      if (entry.getName().equals(""String_Node_Str"")) {
        return entry;
      }
      if (entry.getName().endsWith(""String_Node_Str"")) {
        if (parentPath == null || ""String_Node_Str"".equals(parentPath)) {
          candidateRootEntries.add(entry);
        }
      }
    }
  }
  if (candidateRootEntries.size() == 1) {
    if (!dxpOptions.isQuiet())     log.info(""String_Node_Str"" + candidateRootEntries.get(0).getName());
    return candidateRootEntries.get(0);
  }
  if (candidateRootEntries.size() == 0 & candidateDirs.size() > 1) {
    throw new DitaDxpException(""String_Node_Str"");
  }
  if (candidateDirs.size() == 1) {
    String parentPath=candidateDirs.get(0).getName();
    entries=zipFile.entries();
    while (entries.hasMoreElements()) {
      ZipEntry entry=entries.nextElement();
      File temp=new File(entry.getName());
      String entryParent=temp.getParent();
      if (entryParent == null)       entryParent=""String_Node_Str"";
 else       entryParent+=""String_Node_Str"";
      if (parentPath.equals(entryParent) && entry.getName().endsWith(""String_Node_Str"")) {
        candidateRootEntries.add(entry);
      }
    }
    if (candidateRootEntries.size() == 1) {
      if (!dxpOptions.isQuiet())       log.info(""String_Node_Str"" + candidateRootEntries.get(0).getName());
      return candidateRootEntries.get(0);
    }
    if (candidateRootEntries.size() > 1) {
      throw new DitaDxpException(""String_Node_Str"");
    }
  }
  throw new DitaDxpException(""String_Node_Str"");
}","/** 
 * @param zipFile
 * @param dxpOptions 
 * @return
 * @throws DitaDxpException 
 */
public static ZipEntry getDxpPackageRootMap(ZipFile zipFile,MapBosProcessorOptions dxpOptions) throws DitaDxpException {
  List<ZipEntry> candidateRootEntries=new ArrayList<ZipEntry>();
  List<ZipEntry> candidateDirs=new ArrayList<ZipEntry>();
  Enumeration<? extends ZipEntry> entries=zipFile.entries();
  while (entries.hasMoreElements()) {
    ZipEntry entry=entries.nextElement();
    File temp=new File(entry.getName());
    String parentPath=temp.getParent();
    if (entry.isDirectory()) {
      if (parentPath == null || ""String_Node_Str"".equals(parentPath)) {
        candidateDirs.add(entry);
      }
    }
 else {
      if (entry.getName().equals(""String_Node_Str"")) {
        return entry;
      }
      if (entry.getName().endsWith(""String_Node_Str"")) {
        if (parentPath == null || ""String_Node_Str"".equals(parentPath)) {
          candidateRootEntries.add(entry);
        }
      }
    }
  }
  if (candidateRootEntries.size() == 1) {
    if (!dxpOptions.isQuiet())     log.info(""String_Node_Str"" + candidateRootEntries.get(0).getName());
    return candidateRootEntries.get(0);
  }
  if (candidateRootEntries.size() == 0 & candidateDirs.size() > 1) {
    throw new DitaDxpException(""String_Node_Str"");
  }
  if (candidateDirs.size() == 1) {
    String parentPath=candidateDirs.get(0).getName();
    entries=zipFile.entries();
    while (entries.hasMoreElements()) {
      ZipEntry entry=entries.nextElement();
      File temp=new File(entry.getName());
      String entryParent=temp.getParent();
      if (entryParent == null)       entryParent=""String_Node_Str"";
 else       entryParent+=""String_Node_Str"";
      if (parentPath.equals(entryParent) && entry.getName().endsWith(""String_Node_Str"")) {
        candidateRootEntries.add(entry);
      }
    }
    if (candidateRootEntries.size() == 1) {
      if (!dxpOptions.isQuiet())       log.info(""String_Node_Str"" + candidateRootEntries.get(0).getName());
      return candidateRootEntries.get(0);
    }
    if (candidateRootEntries.size() > 1) {
      throw new DitaDxpException(""String_Node_Str"");
    }
  }
  throw new DitaDxpException(""String_Node_Str"");
}"
13443,"/** 
 * Extracts only the local dependencies used from a map from a DXP package.
 * @param zipFile
 * @param mapEntry
 * @param outputDir
 * @param dxpOptions
 * @throws IOException 
 * @throws DomException 
 * @throws DitaBosHelperException 
 * @throws BosException 
 */
private static void extractMap(ZipFile zipFile,ZipEntry mapEntry,File outputDir,DitaDxpOptions dxpOptions) throws IOException, DomException, BosException, DitaBosHelperException {
  Map<URI,Document> domCache=new HashMap<URI,Document>();
  if (!dxpOptions.isQuiet())   log.info(""String_Node_Str"" + mapEntry.getName() + ""String_Node_Str"");
  BosConstructionOptions bosOptions=new BosConstructionOptions(log,domCache);
  InputSource source=new InputSource(zipFile.getInputStream(mapEntry));
  File dxpFile=new File(zipFile.getName());
  URL baseUri=new URL(""String_Node_Str"" + dxpFile.toURL().toExternalForm() + ""String_Node_Str"");
  URL mapUrl=new URL(baseUri,mapEntry.getName());
  source.setSystemId(mapUrl.toExternalForm());
  Document rootMap=DomUtil.getDomForSource(source,bosOptions,false);
  DitaBoundedObjectSet mapBos=DitaBosHelper.calculateMapBos(bosOptions,log,rootMap);
  MapCopyingBosVisitor visitor=new MapCopyingBosVisitor(outputDir);
  visitor.visit(mapBos);
  if (!dxpOptions.isQuiet())   log.info(""String_Node_Str"");
}","/** 
 * Extracts only the local dependencies used from a map from a DXP package.
 * @param zipFile
 * @param mapEntry
 * @param outputDir
 * @param dxpOptions
 * @throws IOException 
 * @throws DomException 
 * @throws DitaBosHelperException 
 * @throws BosException 
 */
private static void extractMap(ZipFile zipFile,ZipEntry mapEntry,File outputDir,MapBosProcessorOptions dxpOptions) throws IOException, DomException, BosException, DitaBosHelperException {
  Map<URI,Document> domCache=new HashMap<URI,Document>();
  if (!dxpOptions.isQuiet())   log.info(""String_Node_Str"" + mapEntry.getName() + ""String_Node_Str"");
  BosConstructionOptions bosOptions=new BosConstructionOptions(log,domCache);
  InputSource source=new InputSource(zipFile.getInputStream(mapEntry));
  File dxpFile=new File(zipFile.getName());
  URL baseUri=new URL(""String_Node_Str"" + dxpFile.toURI().toURL().toExternalForm() + ""String_Node_Str"");
  URL mapUrl=new URL(baseUri,mapEntry.getName());
  source.setSystemId(mapUrl.toExternalForm());
  Document rootMap=DomUtil.getDomForSource(source,bosOptions,false);
  DitaBoundedObjectSet mapBos=DitaBosHelper.calculateMapBos(bosOptions,log,rootMap);
  MapCopyingBosVisitor visitor=new MapCopyingBosVisitor(outputDir);
  visitor.visit(mapBos);
  if (!dxpOptions.isQuiet())   log.info(""String_Node_Str"");
}"
13444,"/** 
 * Given a DITA map bounded object set, zips it up into a DXP Zip package.
 * @param mapBos
 * @param outputZipFile
 * @throws IOException 
 * @throws BosException 
 */
public static void zipMapBos(DitaBoundedObjectSet mapBos,File outputZipFile,DitaDxpOptions options) throws BosException, IOException {
  log.debug(""String_Node_Str"");
  BosVisitor visitor=new DxpFileOrganizingBosVisitor();
  visitor.visit(mapBos);
  if (!options.isQuiet())   log.info(""String_Node_Str"" + outputZipFile.getAbsolutePath() + ""String_Node_Str"");
  OutputStream outStream=new FileOutputStream(outputZipFile);
  ZipOutputStream zipOutStream=new ZipOutputStream(outStream);
  ZipEntry entry=null;
  URI rootMapUri=mapBos.getRoot().getEffectiveUri();
  URI baseUri=null;
  try {
    baseUri=AddressingUtil.getParent(rootMapUri);
  }
 catch (  URISyntaxException e) {
    throw new BosException(""String_Node_Str"" + e.getMessage());
  }
  Set<String> dirs=new HashSet<String>();
  if (!options.isQuiet())   log.info(""String_Node_Str"");
  for (  BosMember member : mapBos.getMembers()) {
    if (!options.isQuiet())     log.info(""String_Node_Str"" + member + ""String_Node_Str"");
    URI relativeUri=baseUri.relativize(member.getEffectiveUri());
    File temp=new File(relativeUri.getPath());
    String parentPath=temp.getParent();
    if (parentPath != null && !""String_Node_Str"".equals(parentPath) && !parentPath.endsWith(""String_Node_Str"")) {
      parentPath+=""String_Node_Str"";
    }
    log.debug(""String_Node_Str"" + parentPath + ""String_Node_Str"");
    if (!""String_Node_Str"".equals(parentPath) && parentPath != null && !dirs.contains(parentPath)) {
      entry=new ZipEntry(parentPath);
      zipOutStream.putNextEntry(entry);
      zipOutStream.closeEntry();
      dirs.add(parentPath);
    }
    entry=new ZipEntry(relativeUri.getPath());
    zipOutStream.putNextEntry(entry);
    IOUtils.copy(member.getInputStream(),zipOutStream);
    zipOutStream.closeEntry();
  }
  zipOutStream.close();
  if (!options.isQuiet())   log.info(""String_Node_Str"" + outputZipFile.getAbsolutePath() + ""String_Node_Str"");
}","/** 
 * Given a DITA map bounded object set, zips it up into a DXP Zip package.
 * @param mapBos
 * @param outputZipFile
 * @throws IOException 
 * @throws BosException 
 */
public static void zipMapBos(DitaBoundedObjectSet mapBos,File outputZipFile,MapBosProcessorOptions options) throws BosException, IOException {
  log.debug(""String_Node_Str"");
  BosVisitor visitor=new DxpFileOrganizingBosVisitor();
  visitor.visit(mapBos);
  if (!options.isQuiet())   log.info(""String_Node_Str"" + outputZipFile.getAbsolutePath() + ""String_Node_Str"");
  OutputStream outStream=new FileOutputStream(outputZipFile);
  ZipOutputStream zipOutStream=new ZipOutputStream(outStream);
  ZipEntry entry=null;
  URI rootMapUri=mapBos.getRoot().getEffectiveUri();
  URI baseUri=null;
  try {
    baseUri=AddressingUtil.getParent(rootMapUri);
  }
 catch (  URISyntaxException e) {
    throw new BosException(""String_Node_Str"" + e.getMessage());
  }
  Set<String> dirs=new HashSet<String>();
  if (!options.isQuiet())   log.info(""String_Node_Str"");
  for (  BosMember member : mapBos.getMembers()) {
    if (!options.isQuiet())     log.info(""String_Node_Str"" + member + ""String_Node_Str"");
    URI relativeUri=baseUri.relativize(member.getEffectiveUri());
    File temp=new File(relativeUri.getPath());
    String parentPath=temp.getParent();
    if (parentPath != null && !""String_Node_Str"".equals(parentPath) && !parentPath.endsWith(""String_Node_Str"")) {
      parentPath+=""String_Node_Str"";
    }
    log.debug(""String_Node_Str"" + parentPath + ""String_Node_Str"");
    if (!""String_Node_Str"".equals(parentPath) && parentPath != null && !dirs.contains(parentPath)) {
      entry=new ZipEntry(parentPath);
      zipOutStream.putNextEntry(entry);
      zipOutStream.closeEntry();
      dirs.add(parentPath);
    }
    entry=new ZipEntry(relativeUri.getPath());
    zipOutStream.putNextEntry(entry);
    IOUtils.copy(member.getInputStream(),zipOutStream);
    zipOutStream.closeEntry();
  }
  zipOutStream.close();
  if (!options.isQuiet())   log.info(""String_Node_Str"" + outputZipFile.getAbsolutePath() + ""String_Node_Str"");
}"
13445,"/** 
 * @param rootUrl URL of the root map 
 * @param outputDir
 * @throws MalformedURLException 
 */
public MapCopyingBosVisitor(File outputDir) throws MalformedURLException {
  super(log);
  this.outputUrl=outputDir.toURL();
}","/** 
 * @param rootUrl URL of the root map 
 * @param outputDir
 * @throws MalformedURLException 
 */
public MapCopyingBosVisitor(File outputDir) throws MalformedURLException {
  super(log);
  this.outputUrl=outputDir.toURI().toURL();
}"
13446,"/** 
 * @throws Exception 
 */
private void run() throws Exception {
  String mapFilepath=commandLine.getOptionValue(""String_Node_Str"");
  File mapFile=new File(mapFilepath);
  checkExistsAndCanReadSystemExit(mapFile);
  System.err.println(""String_Node_Str"" + mapFile.getAbsolutePath() + ""String_Node_Str"");
  PrintStream outStream=System.out;
  if (commandLine.hasOption(OUTPUT_OPTION_ONE_CHAR)) {
    String outputFilepath=commandLine.getOptionValue(""String_Node_Str"");
    File outputFile=new File(outputFilepath);
    if (!outputFile.getParentFile().canWrite()) {
      throw new RuntimeException(""String_Node_Str"" + outputFile.getAbsolutePath() + ""String_Node_Str"");
    }
    outStream=new PrintStream(outputFile);
  }
  DitaBosReporter bosReporter=getBosReporter(outStream);
  KeySpaceReporter keyreporter=getKeyspaceReporter(outStream);
  Document rootMap=null;
  BosConstructionOptions bosOptions=new BosConstructionOptions(log,new HashMap<URI,Document>());
  if (commandLine.hasOption(MAPTREE_OPTION_ONE_CHAR)) {
    bosOptions.setMapTreeOnly(true);
    System.err.println(""String_Node_Str"");
  }
 else {
    System.err.println(""String_Node_Str"");
  }
  setupCatalogs(bosOptions);
  try {
    URL rootMapUrl=mapFile.toURL();
    rootMap=DomUtil.getDomForUri(new URI(rootMapUrl.toExternalForm()),bosOptions);
    Date startTime=TimingUtils.getNowTime();
    DitaBoundedObjectSet mapBos=DitaBosHelper.calculateMapBos(bosOptions,log,rootMap);
    System.err.println(""String_Node_Str"" + TimingUtils.reportElapsedTime(startTime));
    BosReportOptions bosReportOptions=new BosReportOptions();
    bosReporter.report(mapBos,bosReportOptions);
    DitaKeySpace keySpace=mapBos.getKeySpace();
    KeyReportOptions reportOptions=new KeyReportOptions();
    reportOptions.setAllKeys(true);
    keyreporter.report(new KeyAccessOptions(),keySpace,reportOptions);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    outStream.close();
  }
}","/** 
 * @throws Exception 
 */
private void run() throws Exception {
  String mapFilepath=commandLine.getOptionValue(""String_Node_Str"");
  File mapFile=new File(mapFilepath);
  checkExistsAndCanReadSystemExit(mapFile);
  System.err.println(""String_Node_Str"" + mapFile.getAbsolutePath() + ""String_Node_Str"");
  PrintStream outStream=System.out;
  if (commandLine.hasOption(OUTPUT_OPTION_ONE_CHAR)) {
    String outputFilepath=commandLine.getOptionValue(""String_Node_Str"");
    File outputFile=new File(outputFilepath);
    if (!outputFile.getParentFile().canWrite()) {
      throw new RuntimeException(""String_Node_Str"" + outputFile.getAbsolutePath() + ""String_Node_Str"");
    }
    outStream=new PrintStream(outputFile);
  }
  DitaBosReporter bosReporter=getBosReporter(outStream);
  KeySpaceReporter keyreporter=getKeyspaceReporter(outStream);
  Document rootMap=null;
  BosConstructionOptions bosOptions=new BosConstructionOptions(log,new HashMap<URI,Document>());
  if (commandLine.hasOption(MAPTREE_OPTION_ONE_CHAR)) {
    bosOptions.setMapTreeOnly(true);
    System.err.println(""String_Node_Str"");
  }
 else {
    System.err.println(""String_Node_Str"");
  }
  setupCatalogs(bosOptions);
  try {
    URL rootMapUrl=mapFile.toURI().toURL();
    rootMap=DomUtil.getDomForUri(new URI(rootMapUrl.toExternalForm()),bosOptions);
    Date startTime=TimingUtils.getNowTime();
    DitaBoundedObjectSet mapBos=DitaBosHelper.calculateMapBos(bosOptions,log,rootMap);
    System.err.println(""String_Node_Str"" + TimingUtils.reportElapsedTime(startTime));
    BosReportOptions bosReportOptions=new BosReportOptions();
    bosReporter.report(mapBos,bosReportOptions);
    DitaKeySpace keySpace=mapBos.getKeySpace();
    KeyReportOptions reportOptions=new KeyReportOptions();
    reportOptions.setAllKeys(true);
    keyreporter.report(new KeyAccessOptions(),keySpace,reportOptions);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    outStream.close();
  }
}"
13447,"/** 
 * @param mapFile
 * @param resultInxFile
 * @param options
 * @throws Exception 
 */
private void generateInDesign(File mapFile,File resultInxFile,Map2InDesignOptions options) throws Exception {
  InDesignFromDitaMapBuilder builder=new InDesignFromDitaMapBuilder();
  InDesignDocument doc=builder.buildMapDocument(mapFile.toURL(),options);
  InxWriter writer=new InxWriter(resultInxFile);
  writer.write(doc);
}","/** 
 * @param mapFile
 * @param resultInxFile
 * @param options
 * @throws Exception 
 */
private void generateInDesign(File mapFile,File resultInxFile,Map2InDesignOptions options) throws Exception {
  InDesignFromDitaMapBuilder builder=new InDesignFromDitaMapBuilder();
  InDesignDocument doc=builder.buildMapDocument(mapFile.toURI().toURL(),options);
  InxWriter writer=new InxWriter(resultInxFile);
  writer.write(doc);
}"
13448,"/** 
 * @return the pageBinding
 */
public Enum<PageBindingOption> getPageBinding() throws Exception {
  return getEnumProperty(""String_Node_Str"");
}","/** 
 * @return the pageBinding
 */
public Enum<PageBindingOption> getPageBinding() throws Exception {
  return (PageBindingOption)getEnumProperty(""String_Node_Str"");
}"
13449,"/** 
 * @param link Link to the external object for the image (e.g., EPS file, etc.).
 */
public void setItemLink(Link link){
  this.addChild(link);
  this.itemLink=link;
}","/** 
 * @param link Link to the external object for the image (e.g., EPS file, etc.).
 * @throws Exception 
 */
public void setItemLink(Link link) throws Exception {
  this.addChild(link);
  this.itemLink=link;
}"
13450,"/** 
 * @param sourceObj
 * @throws Exception 
 */
protected void loadComponent(InDesignComponent sourceObj) throws Exception {
  this.inxTagname=sourceObj.getInxTagName();
  if (sourceObj != null) {
    for (    String propName : sourceObj.getPropertyMap().keySet()) {
      this.setProperty(propName,sourceObj.getPropertyValue(propName));
    }
  }
  setTagsFromPtagProperty();
  for (  InDesignComponent child : sourceObj.getChildren()) {
    InDesignComponent newChild=this.getDocument().clone(child);
    this.childObjects.add(newChild);
  }
}","/** 
 * @param sourceObj
 * @throws Exception 
 */
protected void loadComponent(InDesignComponent sourceObj) throws Exception {
  this.inxTagname=sourceObj.getInxTagName();
  if (sourceObj != null) {
    for (    String propName : sourceObj.getPropertyMap().keySet()) {
      this.setProperty(propName,sourceObj.getPropertyValue(propName));
    }
  }
  setTagsFromPtagProperty();
  for (  InDesignComponent child : sourceObj.getChildren()) {
    InDesignComponent newChild=this.getDocument().clone(child);
    addChild(newChild);
  }
}"
13451,"/** 
 * @param run
 */
public void addChild(InDesignComponent child){
  this.childObjects.add(child);
  child.setParent(this);
}","/** 
 * @param run
 * @throws Exception 
 */
public void addChild(InDesignComponent child) throws Exception {
  this.childObjects.add(child);
  child.setParent(this);
}"
13452,"/** 
 * @param class1
 * @param dataSource
 * @return
 * @throws Exception 
 * @throws InstantiationException 
 */
private InDesignComponent newObject(Class<? extends InDesignObject> clazz,Element dataSource) throws Exception {
  logger.debug(""String_Node_Str"" + clazz.getSimpleName() + ""String_Node_Str"");
  InDesignObject obj=(InDesignObject)clazz.newInstance();
  obj.setDocument(this);
  if (dataSource != null) {
    logger.debug(""String_Node_Str"" + dataSource.getNodeName() + ""String_Node_Str"");
    obj.loadObject(dataSource);
    String selfValue=dataSource.getAttribute(PROP_SELF);
    if (selfValue != null && !""String_Node_Str"".equals(selfValue.trim())) {
      String id=InxHelper.decodeRawValueToSingleString(selfValue);
      obj.setId(id);
      this.registerObject(obj);
    }
 else {
      assignIdAndRegister(obj);
    }
  }
  logger.debug(""String_Node_Str"" + obj.getId() + ""String_Node_Str"");
  return obj;
}","/** 
 * @param class1
 * @param dataSource
 * @return
 * @throws Exception 
 * @throws InstantiationException 
 */
private InDesignComponent newObject(Class<? extends InDesignObject> clazz,Element dataSource) throws Exception {
  logger.debug(""String_Node_Str"" + clazz.getSimpleName() + ""String_Node_Str"");
  InDesignObject obj=(InDesignObject)clazz.newInstance();
  obj.setDocument(this);
  if (dataSource != null) {
    logger.debug(""String_Node_Str"" + dataSource.getNodeName() + ""String_Node_Str"");
    obj.loadObject(dataSource);
    String selfValue=dataSource.getAttribute(PROP_SELF);
    if (selfValue != null && !""String_Node_Str"".equals(selfValue.trim())) {
      String id=InxHelper.decodeRawValueToSingleString(selfValue);
      obj.setId(id);
      this.registerObject(obj);
    }
 else {
      assignIdAndRegister(obj);
    }
  }
 else {
    assignIdAndRegister(obj);
  }
  logger.debug(""String_Node_Str"" + obj.getId() + ""String_Node_Str"");
  return obj;
}"
13453,"/** 
 * Construct a new Story that is associated with the specified text frame,
 * @param frame Text frame to which the story is associated.
 * @return
 * @throws Exception 
 */
private Story newStory(TextFrame frame) throws Exception {
  Story story=new Story();
  assignIdAndRegister(story);
  this.addChild(story);
  this.stories.add(story);
  frame.setParentStory(story);
  return story;
}","/** 
 * Construct a new Story that is associated with the specified text frame,
 * @param frame Text frame to which the story is associated.
 * @return
 * @throws Exception 
 */
private Story newStory(TextFrame frame) throws Exception {
  Story story=new Story();
  assignIdAndRegister(story);
  this.addChild(story);
  frame.setParentStory(story);
  return story;
}"
13454,"/** 
 * @param masterSpreadName
 * @return
 * @throws Exception 
 */
public Spread addSpread(String masterSpreadName) throws Exception {
  Spread spread=new Spread();
  assignIdAndRegister(spread);
  spread.setParent(this);
  MasterSpread masterSpread=this.getMasterSpread(masterSpreadName);
  this.spreads.add(spread);
  spread.setTransformationMatrix(this.spreads.size() - 1);
  spread.setMasterSpread(masterSpread);
  this.addChild(spread);
  return spread;
}","/** 
 * @param masterSpreadName
 * @return
 * @throws Exception 
 */
public Spread addSpread(String masterSpreadName) throws Exception {
  Spread spread=new Spread();
  assignIdAndRegister(spread);
  spread.setParent(this);
  MasterSpread masterSpread=this.getMasterSpread(masterSpreadName);
  spread.setTransformationMatrix(this.spreads.size());
  this.spreads.add(spread);
  spread.setMasterSpread(masterSpread);
  this.addChild(spread);
  return spread;
}"
13455,"/** 
 * @param string
 * @return
 */
public InDesignComponent getObject(String id){
  return this.objectsById.get(id);
}","/** 
 * @param string
 * @return
 */
public InDesignObject getObject(String id){
  return this.objectsById.get(id);
}"
13456,"/** 
 * @param masterSpreadName
 * @return
 * @throws Exception 
 */
public Spread newSpread(String masterSpreadName) throws Exception {
  Spread newSpread=new Spread();
  assignIdAndRegister(newSpread);
  newSpread.setParent(this);
  MasterSpread masterSpread=this.getMasterSpread(masterSpreadName);
  if (masterSpread == null) {
    logger.info(""String_Node_Str"" + masterSpreadName + ""String_Node_Str"");
    for (    String key : this.masterSpreads.keySet()) {
      logger.info(""String_Node_Str"" + key + ""String_Node_Str"");
    }
    throw new Exception(""String_Node_Str"" + masterSpreadName + ""String_Node_Str"");
  }
  newSpread.setMasterSpread(masterSpread);
  newSpread.setTransformationMatrix(this.spreads.size());
  this.spreads.add(newSpread);
  this.addChild(newSpread);
  return newSpread;
}","/** 
 * @param masterSpreadName
 * @return
 * @throws Exception 
 */
public Spread newSpread(String masterSpreadName) throws Exception {
  Spread newSpread=new Spread();
  assignIdAndRegister(newSpread);
  newSpread.setParent(this);
  this.spreads.add(newSpread);
  MasterSpread masterSpread=this.getMasterSpread(masterSpreadName);
  if (masterSpread == null) {
    logger.info(""String_Node_Str"" + masterSpreadName + ""String_Node_Str"");
    for (    String key : this.masterSpreads.keySet()) {
      logger.info(""String_Node_Str"" + key + ""String_Node_Str"");
    }
    throw new Exception(""String_Node_Str"" + masterSpreadName + ""String_Node_Str"");
  }
  newSpread.setMasterSpread(masterSpread);
  newSpread.setTransformationMatrix(this.spreads.size());
  this.addChild(newSpread);
  return newSpread;
}"
13457,"/** 
 * @param child
 * @throws Exception 
 */
private DocumentPreferences newDocumentPreferences(Element child) throws Exception {
  DocumentPreferences prefs=(DocumentPreferences)newComponent(DocumentPreferences.class,child);
  this.addChild(prefs);
  this.docPrefs=prefs;
  return prefs;
}","/** 
 * @param child
 * @throws Exception 
 */
private DocumentPreferences newDocumentPreferences(Element child) throws Exception {
  DocumentPreferences prefs=(DocumentPreferences)newComponent(DocumentPreferences.class,child);
  this.addChild(prefs);
  return prefs;
}"
13458,"/** 
 * @param rect
 */
public void addRectangle(Rectangle rect){
  logger.debug(""String_Node_Str"" + rect);
  this.rectangles.put(rect.getId(),rect);
  if (rect instanceof TextFrame)   this.frames.put(rect.getId(),(TextFrame)rect);
  this.addChild(rect);
}","/** 
 * @param rect
 * @throws Exception 
 */
public void addRectangle(Rectangle rect) throws Exception {
  logger.debug(""String_Node_Str"" + rect);
  this.rectangles.put(rect.getId(),rect);
  if (rect instanceof TextFrame)   this.frames.put(rect.getId(),(TextFrame)rect);
  this.addChild(rect);
}"
13459,"/** 
 * Given the URI of an INCX (InCopy) article, parses it and returns the first story in the document.
 * @param inDesignDoc
 * @param incxFile
 * @return
 * @throws ParserConfigurationException
 * @throws SAXException
 * @throws IOException
 * @throws Exception
 */
public static Story getStoryForIncxDoc(InDesignDocument inDesignDoc,URI incxResource) throws ParserConfigurationException, SAXException, IOException, Exception {
  InputSource inputSource=new InputSource(incxResource.toURL().openStream());
  inputSource.setSystemId(incxResource.toString());
  DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
  DocumentBuilder db=dbf.newDocumentBuilder();
  Document doc=db.parse(inputSource);
  NodeList cflos=doc.getElementsByTagName(""String_Node_Str"");
  Element cfloElem=(Element)cflos.item(0);
  cfloElem.removeAttribute(InDesignDocument.PROP_SELF);
  Story incxStory=inDesignDoc.newStory(cfloElem);
  return incxStory;
}","/** 
 * Given the URI of an INCX (InCopy) article, parses it and returns the first story in the document.
 * @param inDesignDoc
 * @param incxFile
 * @return
 * @throws ParserConfigurationException
 * @throws SAXException
 * @throws IOException
 * @throws Exception
 */
public static Story getStoryForIncxDoc(InDesignDocument inDesignDoc,URI incxResource) throws ParserConfigurationException, SAXException, IOException, Exception {
  InputSource incxSource=new InputSource(incxResource.toURL().openStream());
  incxSource.setSystemId(incxResource.toString());
  InDesignDocument articleDoc=new InDesignDocument(incxSource);
  Story incxStory=articleDoc.getStoryIterator().next();
  Story importedStory=inDesignDoc.importStory(incxStory);
  return importedStory;
}"
13460,"/** 
 * @param valueStr
 */
public InxLong32(String rawValue){
  if (rawValue.startsWith(""String_Node_Str""))   rawValue=rawValue.substring(2);
  if (rawValue.startsWith(""String_Node_Str""))   rawValue=rawValue.substring(3);
  this.value=Long.parseLong(rawValue,16);
}","/** 
 * @param value
 */
public InxLong32(int value){
  this.value=value;
}"
13461,"/** 
 * @param sourceObj
 * @throws Exception 
 */
protected void loadComponent(InDesignComponent sourceObj) throws Exception {
  if (sourceObj != null) {
    for (    String propName : sourceObj.getPropertyMap().keySet()) {
      this.setProperty(propName,sourceObj.getPropertyValue(propName));
    }
  }
  setTagsFromPtagProperty();
  for (  InDesignComponent child : sourceObj.getChildren()) {
    InDesignComponent newChild=this.getDocument().clone(child);
  }
}","/** 
 * @param sourceObj
 * @throws Exception 
 */
protected void loadComponent(InDesignComponent sourceObj) throws Exception {
  this.inxTagname=sourceObj.getInxTagName();
  if (sourceObj != null) {
    for (    String propName : sourceObj.getPropertyMap().keySet()) {
      this.setProperty(propName,sourceObj.getPropertyValue(propName));
    }
  }
  setTagsFromPtagProperty();
  for (  InDesignComponent child : sourceObj.getChildren()) {
    InDesignComponent newChild=this.getDocument().clone(child);
    this.childObjects.add(newChild);
  }
}"
13462,"/** 
 * @throws Exception
 */
public Group() throws Exception {
  super();
}","/** 
 * @throws Exception
 */
public Group() throws Exception {
  super();
  this.setInxTagName(""String_Node_Str"");
}"
13463,"/** 
 * @throws Exception
 */
public Image() throws Exception {
  super();
}","/** 
 * @throws Exception
 */
public Image() throws Exception {
  super();
  setInxTagName(""String_Node_Str"");
}"
13464,"/** 
 * @param sourceObj
 */
protected void loadComponent(InDesignComponent sourceObj){
  if (sourceObj != null) {
    for (    String propName : sourceObj.getPropertyMap().keySet()) {
      this.setProperty(propName,sourceObj.getPropertyValue(propName));
    }
  }
}","/** 
 * @param sourceObj
 * @throws Exception 
 */
protected void loadComponent(InDesignComponent sourceObj) throws Exception {
  if (sourceObj != null) {
    for (    String propName : sourceObj.getPropertyMap().keySet()) {
      this.setProperty(propName,sourceObj.getPropertyValue(propName));
    }
  }
  setTagsFromPtagProperty();
  for (  InDesignComponent child : sourceObj.getChildren()) {
    InDesignComponent newChild=this.getDocument().clone(child);
  }
}"
13465,"/** 
 * @param dataSource
 * @throws Exception 
 */
private void loadPropertiesFromDataSource(Element dataSource) throws Exception {
  this.inxTagname=dataSource.getLocalName();
  NamedNodeMap atts=dataSource.getAttributes();
  for (int i=0; i < atts.getLength(); i++) {
    Attr att=(Attr)atts.item(i);
    String rawValue=att.getNodeValue();
    InxValue value=null;
    try {
      value=InxHelper.newValue(rawValue);
    }
 catch (    Exception e) {
      e.printStackTrace();
      throw e;
    }
    this.properties.put(att.getNodeName(),value);
  }
}","/** 
 * @param dataSource
 * @throws Exception 
 */
private void loadPropertiesFromDataSource(Element dataSource) throws Exception {
  this.inxTagname=dataSource.getNodeName();
  NamedNodeMap atts=dataSource.getAttributes();
  for (int i=0; i < atts.getLength(); i++) {
    Attr att=(Attr)atts.item(i);
    String rawValue=att.getNodeValue();
    InxValue value=null;
    try {
      value=InxHelper.newValue(rawValue);
    }
 catch (    Exception e) {
      e.printStackTrace();
      throw e;
    }
    this.properties.put(att.getNodeName(),value);
  }
}"
13466,"/** 
 * @param run
 */
protected void addChild(InDesignObject child){
  addChild((InDesignComponent)child);
  child.setParent(this);
}","/** 
 * @param run
 */
public void addChild(InDesignComponent child){
  this.childObjects.add(child);
  child.setParent(this);
}"
13467,"/** 
 * @param object
 * @param dataSource 
 * @return
 * @throws Exception 
 */
protected InDesignObject newObject(InDesignObject object,Element dataSource) throws Exception {
  addChild(object);
  object.loadObject(dataSource);
  return object;
}","/** 
 * @param object
 * @param dataSource 
 * @return
 * @throws Exception 
 */
protected InDesignComponent newObject(InDesignObject object,Element dataSource) throws Exception {
  addChild(object);
  object.loadObject(dataSource);
  return object;
}"
13468,"/** 
 * @param dataSource
 * @throws InDesignDocumentException 
 * @throws Exception 
 */
public void setDataSource(Element dataSource) throws Exception {
  this.dataSourceElement=dataSource;
  this.componentLoad();
}","/** 
 * @param dataSource
 * @throws InDesignDocumentException 
 * @throws Exception 
 */
public void setDataSource(Element dataSource) throws Exception {
  this.dataSourceElement=dataSource;
  if (dataSourceElement != null) {
    this.componentLoad();
  }
}"
13469,"/** 
 * Clones an object only if it hasn't been already cloned. Returns the clone.
 * @param sourceObj
 * @return The clone of the source object.
 * @throws Exception 
 */
public InDesignObject cloneIfNew(InDesignObject sourceObj,InDesignComponent targetParent) throws Exception {
  Map<String,InDesignObject> cloneMap=getCloneMapForDoc(sourceObj.getDocument());
  if (cloneMap.containsKey(sourceObj.getId()))   return cloneMap.get(sourceObj.getId());
  InDesignObject clone=this.clone(sourceObj);
  if (targetParent != null)   targetParent.addChild(clone);
  return clone;
}","/** 
 * Clones an object only if it hasn't been already cloned. Returns the clone.
 * @param sourceObj
 * @return The clone of the source object.
 * @throws Exception 
 */
public InDesignComponent cloneIfNew(InDesignObject sourceObj,InDesignComponent targetParent) throws Exception {
  Map<String,InDesignObject> cloneMap=getCloneMapForDoc(sourceObj.getDocument());
  if (cloneMap.containsKey(sourceObj.getId()))   return cloneMap.get(sourceObj.getId());
  InDesignComponent clone=this.clone(sourceObj);
  if (targetParent != null)   targetParent.addChild(clone);
  return clone;
}"
13470,"/** 
 * @param class1
 * @param dataSource
 * @return
 * @throws Exception 
 * @throws InstantiationException 
 */
private InDesignObject newObject(Class<? extends AbstractInDesignObject> clazz,Element dataSource) throws Exception {
  InDesignObject obj=(InDesignObject)clazz.newInstance();
  obj.setDocument(this);
  obj.loadObject(dataSource);
  this.registerObject(obj);
  return obj;
}","/** 
 * @param class1
 * @param dataSource
 * @return
 * @throws Exception 
 * @throws InstantiationException 
 */
private InDesignComponent newObject(Class<? extends AbstractInDesignObject> clazz,Element dataSource) throws Exception {
  InDesignObject obj=(InDesignObject)clazz.newInstance();
  obj.setDocument(this);
  obj.loadObject(dataSource);
  this.registerObject(obj);
  return obj;
}"
13471,"/** 
 * Construct a new Story that is associated with the specified text frame,
 * @param frame Text frame to which the story is associated.
 * @return
 */
private Story newStory(TextFrame frame){
  Story story=new Story();
  assignIdAndRegister(story);
  this.addChild(story);
  this.stories.add(story);
  frame.setParentStory(story);
  return story;
}","/** 
 * Construct a new Story that is associated with the specified text frame,
 * @param frame Text frame to which the story is associated.
 * @return
 * @throws Exception 
 */
private Story newStory(TextFrame frame) throws Exception {
  Story story=new Story();
  assignIdAndRegister(story);
  this.addChild(story);
  this.stories.add(story);
  frame.setParentStory(story);
  return story;
}"
13472,"/** 
 * @param masterSpreadName
 * @return
 * @throws Exception 
 */
public Spread addSpread(String masterSpreadName) throws Exception {
  Spread spread=new Spread();
  assignIdAndRegister(spread);
  spread.setParent(this);
  MasterSpread masterSpread=this.getMasterSpread(masterSpreadName);
  Element spreadDataSource=this.dataSource.createElement(""String_Node_Str"");
  spreadDataSource.setAttribute(""String_Node_Str"",""String_Node_Str"" + spread.getId());
  spreadDataSource.setAttribute(""String_Node_Str"",""String_Node_Str"" + masterSpread.getId());
  spreadDataSource.setAttribute(""String_Node_Str"",""String_Node_Str"" + masterSpread.getLongProperty(""String_Node_Str""));
  this.spreads.add(spread);
  spread.setDataSource(spreadDataSource);
  spread.setTransformationMatrix(this.spreads.size() - 1);
  spread.setMasterSpread(masterSpread);
  this.addChild(spread);
  return spread;
}","/** 
 * @param masterSpreadName
 * @return
 * @throws Exception 
 */
public Spread addSpread(String masterSpreadName) throws Exception {
  Spread spread=new Spread();
  assignIdAndRegister(spread);
  spread.setParent(this);
  MasterSpread masterSpread=this.getMasterSpread(masterSpreadName);
  this.spreads.add(spread);
  spread.setTransformationMatrix(this.spreads.size() - 1);
  spread.setMasterSpread(masterSpread);
  this.addChild(spread);
  return spread;
}"
13473,"/** 
 * Create a new text frame. This results in a new story, which  the text frame is associated.
 * @return
 * @throws Exception 
 */
public TextFrame newTextFrame() throws Exception {
  TextFrame frame=new TextFrame();
  assignIdAndRegister(frame);
  this.newStory(frame);
  return frame;
}","/** 
 * Create a new text frame. This results in a new story, which  the text frame is associated.
 * @return
 * @throws Exception 
 */
public InDesignComponent newTextFrame() throws Exception {
  TextFrame frame=new TextFrame();
  assignIdAndRegister(frame);
  this.newStory(frame);
  return frame;
}"
13474,"/** 
 * Unconditionally clone an InDesign Object.
 * @param sourceObj
 * @return The clone of the object.
 * @throws Exception 
 */
public InDesignObject clone(InDesignObject sourceObj) throws Exception {
  logger.debug(""String_Node_Str"" + sourceObj.getClass().getSimpleName() + ""String_Node_Str""+ sourceObj.getId()+ ""String_Node_Str"");
  InDesignObject clone=sourceObj.getClass().newInstance();
  assignIdAndRegister(clone);
  Map<String,InDesignObject> cloneMap=getCloneMapForDoc(sourceObj.getDocument());
  cloneMap.put(sourceObj.getId(),clone);
  clone.loadObject(sourceObj);
  return clone;
}","/** 
 * Unconditionally clone an InDesign Object.
 * @param sourceObj
 * @return The clone of the object.
 * @throws Exception 
 */
public InDesignComponent clone(InDesignObject sourceObj) throws Exception {
  logger.debug(""String_Node_Str"" + sourceObj.getClass().getSimpleName() + ""String_Node_Str""+ sourceObj.getId()+ ""String_Node_Str"");
  InDesignObject clone=sourceObj.getClass().newInstance();
  assignIdAndRegister(clone);
  Map<String,InDesignObject> cloneMap=getCloneMapForDoc(sourceObj.getDocument());
  cloneMap.put(sourceObj.getId(),clone);
  clone.loadObject(sourceObj);
  clone.markAsModified();
  return clone;
}"
13475,"/** 
 * @param dataSource
 * @throws Exception 
 */
public InDesignObject newFrame(Element dataSource) throws Exception {
  TextFrame frame=this.getDocument().newFrame(dataSource);
  this.frames.put(frame.getId(),frame);
  this.rectangles.put(frame.getId(),frame);
  this.addChild(frame);
  return frame;
}","/** 
 * @param dataSource
 * @throws Exception 
 */
public InDesignComponent newFrame(Element dataSource) throws Exception {
  TextFrame frame=this.getDocument().newFrame(dataSource);
  this.frames.put(frame.getId(),frame);
  this.rectangles.put(frame.getId(),frame);
  this.addChild(frame);
  return frame;
}"
13476,"/** 
 * Override any overrideable objects in the spread's master spread.
 * @throws Exception 
 */
public void overrideMasterSpreadObjects() throws Exception {
  InDesignDocument doc=(InDesignDocument)getParent();
  Map<TextFrame,TextFrame> masterToOverride=new HashMap<TextFrame,TextFrame>();
  for (  InDesignComponent comp : this.masterSpread.getChildren()) {
    if (comp.getBooleanProperty(""String_Node_Str"")) {
      if (comp instanceof InDesignObject) {
        InDesignObject idObj=(InDesignObject)comp;
        if (idObj instanceof TextFrame) {
          TextFrame masterFrame=(TextFrame)idObj;
          TextFrame overrideFrame=(TextFrame)doc.clone(masterFrame);
          overrideFrame.setMasterFrame(masterFrame);
          masterToOverride.put(masterFrame,overrideFrame);
          this.addRectangle(overrideFrame);
        }
 else         if (idObj instanceof Rectangle) {
          this.addRectangle((Rectangle)(doc.clone(idObj)));
        }
 else {
          this.addChild(idObj);
        }
      }
 else {
        this.addChild(comp);
      }
    }
  }
  for (  TextFrame masterFrame : masterToOverride.keySet()) {
    if (masterFrame.getNextInThread() == null)     continue;
    TextFrame override=masterToOverride.get(masterFrame);
    TextFrame nextMaster=masterFrame.getNextInThread();
    TextFrame nextOverride=masterToOverride.get(nextMaster);
    if (this.frames.containsKey(nextOverride.getId())) {
      override.setNextInThread(nextOverride);
    }
 else {
      override.setNextInThread((TextFrame)null);
    }
  }
  logger.debug(""String_Node_Str"");
  assignRectanglesToPages();
}","/** 
 * Override any overrideable objects in the spread's master spread.
 * @throws Exception 
 */
public void overrideMasterSpreadObjects() throws Exception {
  InDesignDocument doc=(InDesignDocument)getParent();
  Map<TextFrame,TextFrame> masterToOverride=new HashMap<TextFrame,TextFrame>();
  for (  InDesignComponent comp : this.masterSpread.getChildren()) {
    if (comp.getBooleanProperty(""String_Node_Str"")) {
      if (comp instanceof InDesignObject) {
        InDesignObject idObj=(InDesignObject)comp;
        if (idObj instanceof TextFrame) {
          TextFrame masterFrame=(TextFrame)idObj;
          TextFrame overrideFrame=(TextFrame)doc.clone(masterFrame);
          overrideFrame.setMasterFrame(masterFrame);
          masterToOverride.put(masterFrame,overrideFrame);
          this.addRectangle(overrideFrame);
        }
 else         if (idObj instanceof Rectangle) {
          this.addRectangle((Rectangle)(doc.clone(idObj)));
        }
 else {
          this.addChild(idObj);
        }
      }
 else {
        this.addChild(comp);
      }
    }
  }
  for (  TextFrame masterFrame : masterToOverride.keySet()) {
    if (masterFrame.getNextInThread() == null)     continue;
    TextFrame override=masterToOverride.get(masterFrame);
    InDesignComponent nextMaster=masterFrame.getNextInThread();
    TextFrame nextOverride=masterToOverride.get(nextMaster);
    if (this.frames.containsKey(nextOverride.getId())) {
      override.setNextInThread(nextOverride);
    }
 else {
      override.setNextInThread((TextFrame)null);
    }
  }
  logger.debug(""String_Node_Str"");
  assignRectanglesToPages();
}"
13477,"/** 
 * @param pageNumber
 * @return
 * @throws Exception 
 */
public Page addPage(int pageNumber) throws Exception {
  String pageNumberStr=String.valueOf(pageNumber);
  if (this.pagesByName.containsKey(pageNumberStr))   throw new RuntimeException(""String_Node_Str"" + pageNumber + ""String_Node_Str"");
  InDesignDocument doc=(InDesignDocument)this.getParent();
  Page page=this.getDocument().newPage();
  page.setPName(pageNumberStr);
  Page masterPage;
  if (doc.isFacingPages()) {
    if (pageNumber % 2 == 0) {
      masterPage=getMasterSpread().getEvenPage();
      page.setPageSide(PageSideOption.LEFT_HAND);
    }
 else {
      masterPage=getMasterSpread().getOddPage();
      page.setPageSide(PageSideOption.RIGHT_HAND);
    }
  }
 else {
    masterPage=getMasterSpread().getFirstPage();
    page.setPageSide(PageSideOption.SINGLE_SIDED);
  }
  this.pagesById.put(page.getId(),page);
  this.pagesByName.put(page.getPName(),page);
  this.pages.add(page);
  this.pageCount=this.pages.size();
  return page;
}","/** 
 * @param pageNumber
 * @return
 * @throws Exception 
 */
public Page addPage(int pageNumber) throws Exception {
  String pageNumberStr=String.valueOf(pageNumber);
  if (this.pagesByName.containsKey(pageNumberStr))   throw new RuntimeException(""String_Node_Str"" + pageNumber + ""String_Node_Str"");
  InDesignDocument doc=(InDesignDocument)this.getParent();
  Page page=this.getDocument().newPage();
  page.setParent(this);
  page.setPName(pageNumberStr);
  if (doc.isFacingPages()) {
    if (pageNumber % 2 == 0) {
      page.setPageSide(PageSideOption.LEFT_HAND);
    }
 else {
      page.setPageSide(PageSideOption.RIGHT_HAND);
    }
  }
 else {
    page.setPageSide(PageSideOption.SINGLE_SIDED);
  }
  this.pagesById.put(page.getId(),page);
  this.pagesByName.put(page.getPName(),page);
  this.pages.add(page);
  this.pageCount=this.pages.size();
  return page;
}"
13478,"public Story setParentStory(Story parentStory){
  this.parentStory=parentStory;
  this.parentStoryId=parentStory.getId();
  return parentStory;
}","public Story setParentStory(Story parentStory) throws Exception {
  this.parentStory=parentStory;
  this.parentStoryId=parentStory.getId();
  TextFrame nextInThread=this.getNextInThread();
  if (nextInThread != null) {
    nextInThread.setParentStory(parentStory);
  }
  return parentStory;
}"
13479,"public void testWriteInxFile() throws Exception {
  Spread newSpread;
  String masterSpreadName=""String_Node_Str"";
  newSpread=cloned.newSpread(masterSpreadName);
  MasterSpread master=cloned.getMasterSpread(masterSpreadName);
  Page newPage=newSpread.addPage(10);
  Rectangle rect;
  rect=(Rectangle)doc.getObject(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rect);
  InDesignObject clonedObj=cloned.clone(rect);
  Rectangle clonedRect=(Rectangle)clonedObj;
  newSpread.addRectangle(clonedRect);
  File inxFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  InxWriter writer=new InxWriter(inxFile);
  writer.write(cloned);
  assertTrue(""String_Node_Str"",inxFile.exists());
  assertTrue(""String_Node_Str"",inxFile.length() > 0);
  String inxXml=readFileToString(inxFile);
  logger.info(""String_Node_Str"" + inxXml);
  assertTrue(""String_Node_Str"",inxFile.length() > 1000);
  Document inxDom=DataUtil.constructNonValidatingDocumentBuilder().parse(inxFile);
  assertNotNull(""String_Node_Str"",inxDom);
  Element docElem=inxDom.getDocumentElement();
  assertNotNull(""String_Node_Str"",docElem);
  assertEquals(""String_Node_Str"",""String_Node_Str"",docElem.getNodeName());
  InDesignDocument newDoc=new InDesignDocument();
  newDoc.load(docElem);
  Spread spread=newDoc.getSpread(1);
  assertNotNull(""String_Node_Str"",spread);
  Page page=spread.getPages().get(0);
  assertNotNull(""String_Node_Str"",page);
}","public void testWriteInxFile() throws Exception {
  Spread newSpread;
  String masterSpreadName=""String_Node_Str"";
  newSpread=cloned.newSpread(masterSpreadName);
  MasterSpread master=cloned.getMasterSpread(masterSpreadName);
  Page newPage=newSpread.addPage(10);
  Rectangle rect;
  rect=(Rectangle)doc.getObject(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rect);
  InDesignComponent clonedObj=cloned.clone(rect);
  Rectangle clonedRect=(Rectangle)clonedObj;
  newSpread.addRectangle(clonedRect);
  File inxFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  InxWriter writer=new InxWriter(inxFile);
  writer.write(cloned);
  assertTrue(""String_Node_Str"",inxFile.exists());
  assertTrue(""String_Node_Str"",inxFile.length() > 0);
  String inxXml=readFileToString(inxFile);
  logger.info(""String_Node_Str"" + inxXml);
  assertTrue(""String_Node_Str"",inxFile.length() > 1000);
  Document inxDom=DataUtil.constructNonValidatingDocumentBuilder().parse(inxFile);
  assertNotNull(""String_Node_Str"",inxDom);
  Element docElem=inxDom.getDocumentElement();
  assertNotNull(""String_Node_Str"",docElem);
  assertEquals(""String_Node_Str"",""String_Node_Str"",docElem.getNodeName());
  InDesignDocument newDoc=new InDesignDocument();
  newDoc.load(docElem);
  Spread spread=newDoc.getSpread(1);
  assertNotNull(""String_Node_Str"",spread);
  Page page=spread.getPages().get(0);
  assertNotNull(""String_Node_Str"",page);
}"
13480,"public void testOverrideMasterSpreadObjects() throws Exception {
  Spread newSpread;
  String masterSpreadName=""String_Node_Str"";
  newSpread=cloned.newSpread(masterSpreadName);
  newSpread.setTransformationMatrix(0);
  MasterSpread master=cloned.getMasterSpread(masterSpreadName);
  assertNotNull(""String_Node_Str"",master);
  Page newPage=newSpread.addPage(10);
  assertNotNull(""String_Node_Str"",newPage);
  assertEquals(""String_Node_Str"",0,newSpread.getAllFrames().size());
  newSpread.overrideMasterSpreadObjects();
  assertTrue(""String_Node_Str"",newSpread.getAllFrames().size() > 0);
  boolean foundThread=false;
  for (  TextFrame frame : newSpread.getAllFrames()) {
    if (""String_Node_Str"".equals(frame.getLabel().trim())) {
      foundThread=true;
      TextFrame nextInThread=frame.getNextInThread();
      assertNotNull(nextInThread);
      TextFrame nextInThreadMaster=nextInThread.getMasterFrame();
      assertNotNull(nextInThreadMaster);
      assertNotSame(nextInThreadMaster,frame.getNextInThread());
      assertNotSame(nextInThread.getPreviousInThread(),frame.getMasterFrame());
      assertEquals(""String_Node_Str"",frame,nextInThread.getPreviousInThread());
    }
  }
  assertTrue(""String_Node_Str"",foundThread);
  assertTrue(""String_Node_Str"",newPage.getAllFrames().size() > 0);
}","public void testOverrideMasterSpreadObjects() throws Exception {
  Spread newSpread;
  String masterSpreadName=""String_Node_Str"";
  newSpread=cloned.newSpread(masterSpreadName);
  newSpread.setTransformationMatrix(0);
  MasterSpread master=cloned.getMasterSpread(masterSpreadName);
  assertNotNull(""String_Node_Str"",master);
  Page newPage=newSpread.addPage(10);
  assertNotNull(""String_Node_Str"",newPage);
  assertEquals(""String_Node_Str"",0,newSpread.getAllFrames().size());
  newSpread.overrideMasterSpreadObjects();
  assertTrue(""String_Node_Str"",newSpread.getAllFrames().size() > 0);
  boolean foundThread=false;
  for (  TextFrame frame : newSpread.getAllFrames()) {
    if (""String_Node_Str"".equals(frame.getLabel().trim())) {
      foundThread=true;
      TextFrame nextInThread=frame.getNextInThread();
      assertNotNull(nextInThread);
      InDesignComponent nextInThreadMaster=nextInThread.getMasterFrame();
      assertNotNull(nextInThreadMaster);
      assertNotSame(nextInThreadMaster,frame.getNextInThread());
      assertNotSame(nextInThread.getPreviousInThread(),frame.getMasterFrame());
      assertEquals(""String_Node_Str"",frame,nextInThread.getPreviousInThread());
    }
  }
  assertTrue(""String_Node_Str"",foundThread);
  assertTrue(""String_Node_Str"",newPage.getAllFrames().size() > 0);
}"
13481,"public void testCreateSpreads() throws Exception {
  Spread newSpread;
  String masterSpreadName=""String_Node_Str"";
  newSpread=cloned.newSpread(masterSpreadName);
  assertNotNull(""String_Node_Str"",newSpread);
  assertNotNull(""String_Node_Str"",newSpread.getTransformationMatrix());
  assertEquals(""String_Node_Str"",cloned,newSpread.getParent());
  newSpread=cloned.newSpread(masterSpreadName);
  assertNotNull(""String_Node_Str"",newSpread);
  assertNotNull(""String_Node_Str"",newSpread.getTransformationMatrix());
  newSpread=cloned.newSpread(masterSpreadName);
  assertNotNull(""String_Node_Str"",newSpread);
  assertNotNull(""String_Node_Str"",newSpread.getTransformationMatrix());
  MasterSpread master=cloned.getMasterSpread(masterSpreadName);
  assertNotNull(""String_Node_Str"",master);
  assertEquals(""String_Node_Str"",master,newSpread.getMasterSpread());
  assertEquals(""String_Node_Str"",1,master.getPages().size());
  assertEquals(""String_Node_Str"",0,newSpread.getPages().size());
  Page newPage=newSpread.addPage(10);
  assertNotNull(""String_Node_Str"",newPage);
  Rectangle rect;
  System.err.println(""String_Node_Str"" + doc.reportObjectsById());
  rect=(Rectangle)doc.getObject(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rect);
  InDesignObject clonedObj=cloned.clone(rect);
  assertNotNull(""String_Node_Str"",clonedObj);
  Rectangle clonedRect=(Rectangle)clonedObj;
  assertTrue(""String_Node_Str"",!rect.getId().equals(clonedRect.getId()));
  newSpread.addRectangle(clonedRect);
  assertTrue(""String_Node_Str"",newPage.contains(clonedRect));
}","public void testCreateSpreads() throws Exception {
  Spread newSpread;
  String masterSpreadName=""String_Node_Str"";
  newSpread=cloned.newSpread(masterSpreadName);
  assertNotNull(""String_Node_Str"",newSpread);
  assertNotNull(""String_Node_Str"",newSpread.getTransformationMatrix());
  assertEquals(""String_Node_Str"",cloned,newSpread.getParent());
  newSpread=cloned.newSpread(masterSpreadName);
  assertNotNull(""String_Node_Str"",newSpread);
  assertNotNull(""String_Node_Str"",newSpread.getTransformationMatrix());
  newSpread=cloned.newSpread(masterSpreadName);
  assertNotNull(""String_Node_Str"",newSpread);
  assertNotNull(""String_Node_Str"",newSpread.getTransformationMatrix());
  MasterSpread master=cloned.getMasterSpread(masterSpreadName);
  assertNotNull(""String_Node_Str"",master);
  assertEquals(""String_Node_Str"",master,newSpread.getMasterSpread());
  assertEquals(""String_Node_Str"",1,master.getPages().size());
  assertEquals(""String_Node_Str"",0,newSpread.getPages().size());
  Page newPage=newSpread.addPage(10);
  assertNotNull(""String_Node_Str"",newPage);
  Rectangle rect;
  System.err.println(""String_Node_Str"" + doc.reportObjectsById());
  rect=(Rectangle)doc.getObject(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rect);
  InDesignComponent clonedObj=cloned.clone(rect);
  assertNotNull(""String_Node_Str"",clonedObj);
  Rectangle clonedRect=(Rectangle)clonedObj;
  assertTrue(""String_Node_Str"",!rect.getId().equals(clonedRect.getId()));
  newSpread.addRectangle(clonedRect);
  assertTrue(""String_Node_Str"",newPage.contains(clonedRect));
}"
13482,"/** 
 * @return
 */
public String reportChildObjects(){
  StringBuilder report=new StringBuilder(""String_Node_Str"");
  for (  InDesignComponent comp : this.getChildren()) {
    InDesignObject obj=(InDesignObject)comp;
    Element dataSource=obj.getDataSourceElement();
    String dsName=""String_Node_Str"";
    if (dataSource != null)     dsName=dataSource.getNodeName();
    report.append(""String_Node_Str"").append(obj.getId()).append(""String_Node_Str"").append(obj.getClass().getSimpleName()).append(""String_Node_Str"").append(dsName).append(""String_Node_Str"").append(""String_Node_Str"");
  }
  return report.toString();
}","/** 
 * @return
 */
public String reportChildObjects(){
  StringBuilder report=new StringBuilder(""String_Node_Str"");
  for (  InDesignComponent comp : this.getChildren()) {
    Element dataSource=comp.getDataSourceElement();
    String dsName=""String_Node_Str"";
    if (dataSource != null)     dsName=dataSource.getNodeName();
    if (comp instanceof InDesignObject) {
      InDesignObject obj=(InDesignObject)comp;
      report.append(""String_Node_Str"").append(obj.getId()).append(""String_Node_Str"");
    }
    report.append(comp.getClass().getSimpleName()).append(""String_Node_Str"").append(dsName).append(""String_Node_Str"").append(""String_Node_Str"");
  }
  return report.toString();
}"
13483,"/** 
 * @param rawValue
 * @return
 * @throws Exception 
 */
public static String decodeRawValueToSingleObjectId(String rawValue) throws Exception {
  String[] values=getSingleValue(rawValue);
  if (values[0].equals(""String_Node_Str"") && values[1].equals(""String_Node_Str""))   return null;
  String typeCode=""String_Node_Str"";
  if (values[0].startsWith(""String_Node_Str""))   typeCode=values[0].substring(1);
  if (""String_Node_Str"".equals(typeCode) | ""String_Node_Str"".equals(typeCode))   return values[1];
  throw new Exception(""String_Node_Str"" + values[0] + ""String_Node_Str"");
}","/** 
 * @param rawValue
 * @return
 * @throws Exception 
 */
public static String decodeRawValueToSingleObjectId(String rawValue) throws Exception {
  String[] values=getSingleValue(rawValue);
  if (values[0].equals(""String_Node_Str"") && values[1].equals(""String_Node_Str""))   return null;
  String typeCode=values[0].substring(0);
  if (values[0].startsWith(""String_Node_Str""))   typeCode=values[0].substring(1);
  if (""String_Node_Str"".equals(typeCode) | ""String_Node_Str"".equals(typeCode))   return values[1];
  throw new Exception(""String_Node_Str"" + values[0] + ""String_Node_Str"");
}"
13484,"/** 
 * Decodes a value that is a list of lists of string pairs representing a map of name/value pairs.
 * @param rawValue
 * @return
 * @throws Exception 
 */
public static Map<String,String> decodeRawValueToStringMap(String rawValue) throws Exception {
  String[] parts=rawValue.split(""String_Node_Str"");
  String typeCode=parts[0];
  if (typeCode.startsWith(""String_Node_Str""))   typeCode=typeCode.substring(1);
  if (!""String_Node_Str"".equals(typeCode))   throw new InDesignDocumentException(""String_Node_Str"" + typeCode + ""String_Node_Str"");
  Map<String,String> resultMap=new HashMap<String,String>();
  int i=5;
  while (i < (parts.length - 2)) {
    String key=parts[i++];
    String value=parts[i++];
    resultMap.put(key,value);
    i+=2;
  }
  return resultMap;
}","/** 
 * Decodes a value that is a list of lists of string pairs representing a map of name/value pairs.
 * @param rawValue
 * @return
 * @throws Exception 
 */
public static Map<String,String> decodeRawValueToStringMap(String rawValue) throws Exception {
  String[] parts=rawValue.split(""String_Node_Str"");
  String typeCode=parts[0];
  if (typeCode.startsWith(""String_Node_Str""))   typeCode=typeCode.substring(1);
  if (!""String_Node_Str"".equals(typeCode))   throw new InDesignDocumentException(""String_Node_Str"" + typeCode + ""String_Node_Str"");
  Map<String,String> resultMap=new HashMap<String,String>();
  int i=4;
  while (i < (parts.length - 3)) {
    String tcKey=parts[i++];
    String key=parts[i++];
    String tcValue=parts[i++];
    String value=parts[i++];
    resultMap.put(key,value);
    i+=2;
  }
  return resultMap;
}"
13485,"/** 
 * Override any overrideable objects in the spread's master spread.
 * @throws Exception 
 */
public void overrideMasterSpreadObjects() throws Exception {
  InDesignDocument doc=(InDesignDocument)getParent();
  Map<TextFrame,TextFrame> masterToOverride=new HashMap<TextFrame,TextFrame>();
  for (  InDesignComponent comp : this.masterSpread.getChildren()) {
    if (comp.getBooleanProperty(""String_Node_Str"")) {
      if (comp instanceof InDesignObject) {
        InDesignObject idObj=(InDesignObject)comp;
        if (idObj instanceof TextFrame) {
          TextFrame masterFrame=(TextFrame)idObj;
          TextFrame overrideFrame=(TextFrame)doc.clone(masterFrame);
          overrideFrame.setMasterFrame(masterFrame);
          masterToOverride.put(masterFrame,overrideFrame);
        }
 else         if (idObj instanceof Rectangle) {
          this.addRectangle((Rectangle)(doc.clone(idObj)));
        }
 else {
          this.addChild(idObj);
        }
      }
 else {
        this.addChild(comp);
      }
    }
  }
  for (  TextFrame masterFrame : masterToOverride.keySet()) {
    if (masterFrame.getNextInThread() == null)     continue;
    TextFrame override=masterToOverride.get(masterFrame);
    TextFrame nextMaster=masterFrame.getNextInThread();
    TextFrame nextOverride=masterToOverride.get(nextMaster);
    if (this.frames.containsKey(nextOverride)) {
      override.setNextInThread(nextOverride);
    }
 else {
      override.setNextInThread((TextFrame)null);
    }
  }
  logger.debug(""String_Node_Str"");
  assignRectanglesToPages();
}","/** 
 * Override any overrideable objects in the spread's master spread.
 * @throws Exception 
 */
public void overrideMasterSpreadObjects() throws Exception {
  InDesignDocument doc=(InDesignDocument)getParent();
  Map<TextFrame,TextFrame> masterToOverride=new HashMap<TextFrame,TextFrame>();
  for (  InDesignComponent comp : this.masterSpread.getChildren()) {
    if (comp.getBooleanProperty(""String_Node_Str"")) {
      if (comp instanceof InDesignObject) {
        InDesignObject idObj=(InDesignObject)comp;
        if (idObj instanceof TextFrame) {
          TextFrame masterFrame=(TextFrame)idObj;
          TextFrame overrideFrame=(TextFrame)doc.clone(masterFrame);
          overrideFrame.setMasterFrame(masterFrame);
          masterToOverride.put(masterFrame,overrideFrame);
          this.addRectangle(overrideFrame);
        }
 else         if (idObj instanceof Rectangle) {
          this.addRectangle((Rectangle)(doc.clone(idObj)));
        }
 else {
          this.addChild(idObj);
        }
      }
 else {
        this.addChild(comp);
      }
    }
  }
  for (  TextFrame masterFrame : masterToOverride.keySet()) {
    if (masterFrame.getNextInThread() == null)     continue;
    TextFrame override=masterToOverride.get(masterFrame);
    TextFrame nextMaster=masterFrame.getNextInThread();
    TextFrame nextOverride=masterToOverride.get(nextMaster);
    if (this.frames.containsKey(nextOverride.getId())) {
      override.setNextInThread(nextOverride);
    }
 else {
      override.setNextInThread((TextFrame)null);
    }
  }
  logger.debug(""String_Node_Str"");
  assignRectanglesToPages();
}"
13486,"/** 
 * Get the frame to which this frame threads, if any.
 * @return Frame or null if there is no next thread.
 * @throws Exception 
 */
public TextFrame getNextInThread() throws Exception {
  if (nextFrameInThread == null && hasProperty(InDesignDocument.PROP_NTXF)) {
    String objectId=getObjectReferenceProperty(InDesignDocument.PROP_NTXF);
    if (objectId != null) {
      this.nextFrameInThread=(TextFrame)this.getDocument().getObject(objectId);
    }
  }
  return this.nextFrameInThread;
}","/** 
 * Get the frame to which this frame threads, if any.
 * @return Frame or null if there is no next thread.
 * @throws Exception 
 */
public TextFrame getNextInThread() throws Exception {
  if (nextInThread == null && hasProperty(InDesignDocument.PROP_NTXF)) {
    String objectId=getObjectReferenceProperty(InDesignDocument.PROP_NTXF);
    if (objectId != null) {
      this.nextInThread=(TextFrame)this.getDocument().getObject(objectId);
    }
  }
  return this.nextInThread;
}"
13487,"/** 
 * @param nextTextFrame
 */
public void setNextInThread(TextFrame nextTextFrame){
  this.nextFrameInThread=nextTextFrame;
}","/** 
 * Set the next frame in the thread. Automatically sets this frame as the previous frame on  the specified text frame.
 * @param nextTextFrame The frame to which this frameis to be threaded.
 */
public void setNextInThread(TextFrame nextTextFrame){
  this.nextInThread=nextTextFrame;
  if (nextTextFrame != null) {
    nextTextFrame.setPreviousInThread(this);
  }
}"
13488,"/** 
 * @param propSelf
 * @return
 * @throws Exception 
 */
protected String getStringProperty(String attName) throws Exception {
  if (this.getDataSourceElement().hasAttribute(attName)) {
    return InxHelper.decodeRawValueToSingleString(this.getDataSourceElement().getAttribute(attName));
  }
  return null;
}","/** 
 * @param attName
 * @return
 * @throws Exception 
 */
protected String getStringProperty(String attName) throws Exception {
  if (this.getDataSourceElement().hasAttribute(attName)) {
    return InxHelper.decodeRawValueToSingleString(this.getDataSourceElement().getAttribute(attName));
  }
  return null;
}"
13489,"/** 
 * @param rawValue
 * @return
 * @throws Exception 
 */
public static String decodeRawValueToSingleObjectId(String rawValue) throws Exception {
  String[] values=getSingleValue(rawValue);
  String typeCode=""String_Node_Str"";
  if (values[0].startsWith(""String_Node_Str""))   typeCode=values[0].substring(1);
  if (""String_Node_Str"".equals(typeCode) | ""String_Node_Str"".equals(typeCode))   return values[1];
  throw new Exception(""String_Node_Str"" + values[0] + ""String_Node_Str"");
}","/** 
 * @param rawValue
 * @return
 * @throws Exception 
 */
public static String decodeRawValueToSingleObjectId(String rawValue) throws Exception {
  String[] values=getSingleValue(rawValue);
  if (values[0].equals(""String_Node_Str"") && values[1].equals(""String_Node_Str""))   return null;
  String typeCode=""String_Node_Str"";
  if (values[0].startsWith(""String_Node_Str""))   typeCode=values[0].substring(1);
  if (""String_Node_Str"".equals(typeCode) | ""String_Node_Str"".equals(typeCode))   return values[1];
  throw new Exception(""String_Node_Str"" + values[0] + ""String_Node_Str"");
}"
13490,"/** 
 * Override any overrideable objects in the spread's master spread.
 * @throws Exception 
 */
public void overrideMasterSpreadObjects() throws Exception {
  for (  InDesignComponent comp : this.masterSpread.getChildren()) {
    if (comp.getBooleanProperty(""String_Node_Str"")) {
      if (comp instanceof Rectangle) {
        this.addRectangle((Rectangle)comp);
      }
 else {
        this.addChild(comp);
      }
    }
  }
  logger.debug(""String_Node_Str"");
  assignRectanglesToPages();
}","/** 
 * Override any overrideable objects in the spread's master spread.
 * @throws Exception 
 */
public void overrideMasterSpreadObjects() throws Exception {
  InDesignDocument doc=(InDesignDocument)getParent();
  Map<TextFrame,TextFrame> masterToOverride=new HashMap<TextFrame,TextFrame>();
  for (  InDesignComponent comp : this.masterSpread.getChildren()) {
    if (comp.getBooleanProperty(""String_Node_Str"")) {
      if (comp instanceof InDesignObject) {
        InDesignObject idObj=(InDesignObject)comp;
        if (idObj instanceof TextFrame) {
          TextFrame masterFrame=(TextFrame)idObj;
          TextFrame overrideFrame=(TextFrame)doc.clone(masterFrame);
          overrideFrame.setMasterFrame(masterFrame);
          masterToOverride.put(masterFrame,overrideFrame);
        }
 else         if (idObj instanceof Rectangle) {
          this.addRectangle((Rectangle)(doc.clone(idObj)));
        }
 else {
          this.addChild(idObj);
        }
      }
 else {
        this.addChild(comp);
      }
    }
  }
  for (  TextFrame masterFrame : masterToOverride.keySet()) {
    if (masterFrame.getNextInThread() == null)     continue;
    TextFrame override=masterToOverride.get(masterFrame);
    TextFrame nextMaster=masterFrame.getNextInThread();
    TextFrame nextOverride=masterToOverride.get(nextMaster);
    if (this.frames.containsKey(nextOverride)) {
      override.setNextInThread(nextOverride);
    }
 else {
      override.setNextInThread((TextFrame)null);
    }
  }
  logger.debug(""String_Node_Str"");
  assignRectanglesToPages();
}"
13491,"/** 
 * Decodes a value that is a list of lists of string pairs representing a map of name/value pairs.
 * @param rawValue
 * @return
 * @throws Exception 
 */
public static Map<String,String> decodeRawValueToStringMap(String rawValue) throws Exception {
  String[] parts=rawValue.split(""String_Node_Str"");
  String typeCode=parts[0];
  if (typeCode.startsWith(""String_Node_Str""))   typeCode=typeCode.substring(1);
  if (!""String_Node_Str"".equals(typeCode))   throw new InDesignDocumentException(""String_Node_Str"" + typeCode + ""String_Node_Str"");
  int i=4;
  Map<String,String> resultMap=new HashMap<String,String>();
  while (i < (parts.length - 3)) {
    String key=parts[i++];
    String value=parts[i++];
    resultMap.put(key,value);
    i+=2;
  }
  return resultMap;
}","/** 
 * Decodes a value that is a list of lists of string pairs representing a map of name/value pairs.
 * @param rawValue
 * @return
 * @throws Exception 
 */
public static Map<String,String> decodeRawValueToStringMap(String rawValue) throws Exception {
  String[] parts=rawValue.split(""String_Node_Str"");
  String typeCode=parts[0];
  if (typeCode.startsWith(""String_Node_Str""))   typeCode=typeCode.substring(1);
  if (!""String_Node_Str"".equals(typeCode))   throw new InDesignDocumentException(""String_Node_Str"" + typeCode + ""String_Node_Str"");
  Map<String,String> resultMap=new HashMap<String,String>();
  int i=5;
  while (i < (parts.length - 2)) {
    String key=parts[i++];
    String value=parts[i++];
    resultMap.put(key,value);
    i+=2;
  }
  return resultMap;
}"
13492,"/** 
 * Given a Geometry object, encodes it as an IGeo string value.
 * @param geometry
 * @return
 */
public static String encodeGeometry(Geometry geometry){
  List<InxValue> values=new ArrayList<InxValue>();
  values.add(new InxLong64(geometry.getPaths().size()));
  for (  Path path : geometry.getPaths()) {
    values.add(new InxLong64(path.getPoints().size()));
    for (    Point point : path.getPoints()) {
      values.add(new InxLong64(2));
      values.add(new InxDouble(point.getX()));
      values.add(new InxDouble(point.getY()));
    }
    values.add(new InxBoolean(false));
  }
  values.add(new InxDouble(geometry.getBoundingBox().getLeft()));
  values.add(new InxDouble(geometry.getBoundingBox().getTop()));
  values.add(new InxDouble(geometry.getBoundingBox().getRight()));
  values.add(new InxDouble(geometry.getBoundingBox().getBottom()));
  values.addAll(geometry.getTransformationMatrix().getMatrixValues());
  if (geometry.getGraphicBoundingBox() != null) {
    values.add(new InxDouble(geometry.getGraphicBoundingBox().getLeft()));
    values.add(new InxDouble(geometry.getGraphicBoundingBox().getTop()));
    values.add(new InxDouble(geometry.getGraphicBoundingBox().getRight()));
    values.add(new InxDouble(geometry.getGraphicBoundingBox().getBottom()));
  }
  return encodeValueList(values);
}","/** 
 * Given a Geometry object, encodes it as an IGeo string value.
 * @param geometry
 * @return
 */
public static String encodeGeometry(Geometry geometry){
  List<InxValue> values=new ArrayList<InxValue>();
  values.add(new InxLong64(geometry.getPaths().size()));
  for (  Path path : geometry.getPaths()) {
    values.add(new InxLong64(path.getPoints().size()));
    for (    PathPoint point : path.getPoints()) {
      values.add(new InxLong64(2));
      values.add(new InxDouble(point.getX()));
      values.add(new InxDouble(point.getY()));
    }
    values.add(new InxBoolean(false));
  }
  values.add(new InxDouble(geometry.getBoundingBox().getLeft()));
  values.add(new InxDouble(geometry.getBoundingBox().getTop()));
  values.add(new InxDouble(geometry.getBoundingBox().getRight()));
  values.add(new InxDouble(geometry.getBoundingBox().getBottom()));
  values.addAll(geometry.getTransformationMatrix().getMatrixValues());
  if (geometry.getGraphicBoundingBox() != null) {
    values.add(new InxDouble(geometry.getGraphicBoundingBox().getLeft()));
    values.add(new InxDouble(geometry.getGraphicBoundingBox().getTop()));
    values.add(new InxDouble(geometry.getGraphicBoundingBox().getRight()));
    values.add(new InxDouble(geometry.getGraphicBoundingBox().getBottom()));
  }
  return encodeValueList(values);
}"
13493,"/** 
 * Registers a BOS member on which the member is dependent, specifing a key by  which the member can be later looked up, such as the original referencing element, the fully-qualified URI of the target, a database key, or whatever. Intended to enable mapping from original references in member data to the target managed object in order to rewrite pointers. <p>Note that while a given member is never added to dependencies multiple times, it be registered under any number of dependency types.
 * @param key
 * @param targetMember
 */
public void registerDependency(String key,BosMember targetMember,DependencyType type){
  dependencies.put(key,targetMember);
  if (!dependenciesByType.containsKey(type)) {
    this.dependenciesByType.put(type,new HashSet<BosMember>());
  }
  this.dependenciesByType.get(type).add(targetMember);
  if (!dependencyTypesByKey.containsKey(targetMember.getKey())) {
    this.dependencyTypesByKey.put(targetMember.getKey(),new HashSet<DependencyType>());
  }
  this.dependencyTypesByKey.get(targetMember.getKey()).add(type);
}","/** 
 * Registers a BOS member on which the member is dependent, specifing a key by  which the member can be later looked up, such as the original referencing element, the fully-qualified URI of the target, a database key, or whatever. Intended to enable mapping from original references in member data to the target managed object in order to rewrite pointers. <p>Note that while a given member is never added to dependencies multiple times, it may be registered under any number of dependency types.
 * @param key
 * @param targetMember
 */
public void registerDependency(String key,BosMember targetMember,DependencyType type){
  dependencies.put(key,targetMember);
  if (!dependenciesByType.containsKey(type)) {
    this.dependenciesByType.put(type,new HashSet<BosMember>());
  }
  this.dependenciesByType.get(type).add(targetMember);
  if (!dependencyTypesByKey.containsKey(targetMember.getKey())) {
    this.dependencyTypesByKey.put(targetMember.getKey(),new HashSet<DependencyType>());
  }
  this.dependencyTypesByKey.get(targetMember.getKey()).add(type);
}"
13494,"/** 
 * @param bos
 * @param member
 * @param newMembers
 * @throws BosException 
 * @throws DitaApiException 
 */
protected void findLinkDependencies(BoundedObjectSet bos,XmlBosMember member,Set<BosMember> newMembers) throws BosException, DitaApiException {
  NodeList links;
  try {
    links=(NodeList)DitaUtil.allHrefsAndKeyrefs.evaluate(member.getElement(),XPathConstants.NODESET);
  }
 catch (  XPathExpressionException e) {
    throw new BosException(""String_Node_Str"" + DitaUtil.allTopicrefs);
  }
  log.debug(""String_Node_Str"" + links.getLength() + ""String_Node_Str"");
  for (int i=0; i < links.getLength(); i++) {
    Element link=(Element)links.item(i);
    Document targetDoc=null;
    URI targetUri=null;
    String href=null;
    DependencyType depType=Constants.LINK_DEPENDENCY;
    try {
      if (link.hasAttribute(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + link.getAttribute(""String_Node_Str"") + ""String_Node_Str"");
        if (!DitaUtil.targetIsADitaFormat(link) || DitaUtil.isDitaType(link,""String_Node_Str"")) {
          targetUri=resolveKeyrefToUri(link.getAttribute(""String_Node_Str""));
        }
 else {
          targetDoc=resolveKeyrefToDoc(link.getAttribute(""String_Node_Str""));
        }
      }
      if (targetUri == null && targetDoc == null && link.hasAttribute(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + link.getAttribute(""String_Node_Str"") + ""String_Node_Str"");
        href=link.getAttribute(""String_Node_Str"");
        if (DitaUtil.isDitaType(link,""String_Node_Str"")) {
          targetUri=AddressingUtil.resolveHrefToUri(link,link.getAttribute(""String_Node_Str""),this.failOnAddressResolutionFailure);
          depType=Constants.IMAGE_DEPENDENCY;
        }
 else         if (!DitaUtil.targetIsADitaFormat(link) && DitaUtil.isLocalOrPeerScope(link)) {
          targetUri=AddressingUtil.resolveHrefToUri(link,link.getAttribute(""String_Node_Str""),this.failOnAddressResolutionFailure);
        }
 else {
          if (!href.startsWith(""String_Node_Str"") && DitaUtil.isLocalOrPeerScope(link)) {
            targetDoc=AddressingUtil.resolveHrefToDoc(link,link.getAttribute(""String_Node_Str""),bosConstructionOptions,this.failOnAddressResolutionFailure);
          }
          if (DitaUtil.isDitaType(link,""String_Node_Str"")) {
            depType=Constants.XREF_DEPENDENCY;
          }
 else           if (DitaUtil.isDitaType(link,""String_Node_Str"")) {
            depType=Constants.LINK_DEPENDENCY;
          }
        }
      }
    }
 catch (    AddressingException e) {
      if (this.failOnAddressResolutionFailure) {
        throw new BosException(""String_Node_Str"" + link.getAttribute(""String_Node_Str"") + ""String_Node_Str"",e);
      }
    }
    if (targetDoc == null && targetUri == null || targetDoc == member.getDocument())     continue;
    BosMember childMember=null;
    if (targetDoc != null) {
      log.debug(""String_Node_Str"" + targetDoc.getDocumentURI() + ""String_Node_Str"");
      childMember=bos.constructBosMember(member,targetDoc);
    }
 else     if (targetUri != null) {
      log.debug(""String_Node_Str"" + targetUri.toString() + ""String_Node_Str"");
      childMember=bos.constructBosMember((BosMember)member,targetUri);
    }
    newMembers.add(childMember);
    member.registerDependency(href,childMember,depType);
  }
}","/** 
 * @param bos
 * @param member
 * @param newMembers
 * @throws BosException 
 * @throws DitaApiException 
 */
protected void findLinkDependencies(BoundedObjectSet bos,XmlBosMember member,Set<BosMember> newMembers) throws BosException, DitaApiException {
  NodeList links;
  try {
    links=(NodeList)DitaUtil.allHrefsAndKeyrefs.evaluate(member.getElement(),XPathConstants.NODESET);
  }
 catch (  XPathExpressionException e) {
    throw new BosException(""String_Node_Str"" + DitaUtil.allTopicrefs);
  }
  log.debug(""String_Node_Str"" + links.getLength() + ""String_Node_Str"");
  for (int i=0; i < links.getLength(); i++) {
    Element link=(Element)links.item(i);
    Document targetDoc=null;
    URI targetUri=null;
    String dependencyKey=null;
    String href=null;
    DependencyType depType=Constants.LINK_DEPENDENCY;
    if (DitaUtil.isDitaType(link,""String_Node_Str"")) {
      depType=Constants.IMAGE_DEPENDENCY;
    }
 else     if (DitaUtil.isDitaType(link,""String_Node_Str"")) {
      depType=Constants.XREF_DEPENDENCY;
    }
    try {
      if (link.hasAttribute(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + link.getAttribute(""String_Node_Str"") + ""String_Node_Str"");
        if (!DitaUtil.targetIsADitaFormat(link) || DitaUtil.isDitaType(link,""String_Node_Str"")) {
          targetUri=resolveKeyrefToUri(link.getAttribute(""String_Node_Str""));
        }
 else {
          targetDoc=resolveKeyrefToDoc(link.getAttribute(""String_Node_Str""));
        }
      }
      if (targetUri == null && targetDoc == null && link.hasAttribute(""String_Node_Str"")) {
        log.debug(""String_Node_Str"" + link.getAttribute(""String_Node_Str"") + ""String_Node_Str"");
        href=link.getAttribute(""String_Node_Str"");
        dependencyKey=href;
        if (DitaUtil.isDitaType(link,""String_Node_Str"")) {
          targetUri=AddressingUtil.resolveHrefToUri(link,link.getAttribute(""String_Node_Str""),this.failOnAddressResolutionFailure);
        }
 else         if (!DitaUtil.targetIsADitaFormat(link) && DitaUtil.isLocalOrPeerScope(link)) {
          targetUri=AddressingUtil.resolveHrefToUri(link,link.getAttribute(""String_Node_Str""),this.failOnAddressResolutionFailure);
        }
 else {
          if (!href.startsWith(""String_Node_Str"") && DitaUtil.isLocalOrPeerScope(link)) {
            targetDoc=AddressingUtil.resolveHrefToDoc(link,link.getAttribute(""String_Node_Str""),bosConstructionOptions,this.failOnAddressResolutionFailure);
          }
        }
      }
 else {
        dependencyKey=AddressingUtil.getKeyNameFromKeyref(link);
      }
    }
 catch (    AddressingException e) {
      if (this.failOnAddressResolutionFailure) {
        throw new BosException(""String_Node_Str"" + link.getAttribute(""String_Node_Str"") + ""String_Node_Str"",e);
      }
    }
    if (targetDoc == null && targetUri == null || targetDoc == member.getDocument())     continue;
    BosMember childMember=null;
    if (targetDoc != null) {
      log.debug(""String_Node_Str"" + targetDoc.getDocumentURI() + ""String_Node_Str"");
      childMember=bos.constructBosMember(member,targetDoc);
    }
 else     if (targetUri != null) {
      log.debug(""String_Node_Str"" + targetUri.toString() + ""String_Node_Str"");
      childMember=bos.constructBosMember((BosMember)member,targetUri);
    }
    newMembers.add(childMember);
    member.registerDependency(dependencyKey,childMember,depType);
  }
}"
13495,"/** 
 * @param bos
 * @param member
 * @throws BosException 
 * @throws DitaApiException 
 */
protected void walkMapGetDependencies(BoundedObjectSet bos,DitaMapBosMemberImpl member) throws BosException, DitaApiException {
  NodeList topicrefs;
  try {
    topicrefs=(NodeList)DitaUtil.allTopicrefs.evaluate(member.getElement(),XPathConstants.NODESET);
  }
 catch (  XPathExpressionException e) {
    throw new BosException(""String_Node_Str"" + DitaUtil.allTopicrefs);
  }
  Set<BosMember> newMembers=new HashSet<BosMember>();
  for (int i=0; i < topicrefs.getLength(); i++) {
    Element topicref=(Element)topicrefs.item(i);
    Document targetDoc=null;
    URI targetUri=null;
    if (!DitaUtil.isLocalScope(topicref))     continue;
    String href=null;
    try {
      if (bosConstructionOptions.isMapTreeOnly()) {
        if (DitaUtil.targetIsADitaMap(topicref) && topicref.hasAttribute(""String_Node_Str"")) {
          href=topicref.getAttribute(""String_Node_Str"");
          if (!href.startsWith(""String_Node_Str""))           targetDoc=AddressingUtil.resolveHrefToDoc(topicref,href,bosConstructionOptions,this.failOnAddressResolutionFailure);
        }
      }
 else       if (DitaUtil.targetIsADitaFormat(topicref)) {
        if (topicref.hasAttribute(""String_Node_Str"")) {
          targetDoc=resolveKeyrefToDoc(topicref.getAttribute(""String_Node_Str""));
        }
        if (targetDoc == null && topicref.hasAttribute(""String_Node_Str"")) {
          href=topicref.getAttribute(""String_Node_Str"");
          if (!href.startsWith(""String_Node_Str""))           targetDoc=AddressingUtil.resolveHrefToDoc(topicref,href,bosConstructionOptions,this.failOnAddressResolutionFailure);
        }
      }
 else {
        if (topicref.hasAttribute(""String_Node_Str"")) {
          targetUri=resolveKeyrefToUri(topicref.getAttribute(""String_Node_Str""));
        }
        if (targetUri == null && topicref.hasAttribute(""String_Node_Str"")) {
          href=topicref.getAttribute(""String_Node_Str"");
          if (!href.startsWith(""String_Node_Str""))           targetUri=AddressingUtil.resolveHrefToUri(topicref,href,this.failOnAddressResolutionFailure);
        }
      }
    }
 catch (    AddressingException e) {
      if (this.failOnAddressResolutionFailure) {
        throw new BosException(""String_Node_Str"" + topicref.getAttribute(""String_Node_Str"") + ""String_Node_Str"",e);
      }
    }
    BosMember childMember=null;
    if (targetDoc != null) {
      childMember=bos.constructBosMember(member,targetDoc);
    }
    if (targetUri != null) {
      childMember=bos.constructBosMember(member,targetUri);
    }
    if (childMember != null) {
      bos.addMember(member,childMember);
      newMembers.add((BosMember)childMember);
      if (href != null)       member.registerDependency(href,childMember,Constants.TOPTCREF_DEPENDENCY);
    }
  }
  for (  BosMember newMember : newMembers) {
    if (!walkedMembers.contains(newMember))     walkMemberGetDependencies(bos,newMember);
  }
}","/** 
 * @param bos
 * @param member
 * @throws BosException 
 * @throws DitaApiException 
 */
protected void walkMapGetDependencies(BoundedObjectSet bos,DitaMapBosMemberImpl member) throws BosException, DitaApiException {
  NodeList topicrefs;
  try {
    topicrefs=(NodeList)DitaUtil.allTopicrefs.evaluate(member.getElement(),XPathConstants.NODESET);
  }
 catch (  XPathExpressionException e) {
    throw new BosException(""String_Node_Str"" + DitaUtil.allTopicrefs);
  }
  Set<BosMember> newMembers=new HashSet<BosMember>();
  for (int i=0; i < topicrefs.getLength(); i++) {
    Element topicref=(Element)topicrefs.item(i);
    Document targetDoc=null;
    URI targetUri=null;
    if (!DitaUtil.isLocalScope(topicref))     continue;
    String href=null;
    try {
      if (bosConstructionOptions.isMapTreeOnly()) {
        if (DitaUtil.targetIsADitaMap(topicref) && topicref.hasAttribute(""String_Node_Str"")) {
          href=topicref.getAttribute(""String_Node_Str"");
          if (!href.startsWith(""String_Node_Str""))           targetDoc=AddressingUtil.resolveHrefToDoc(topicref,href,bosConstructionOptions,this.failOnAddressResolutionFailure);
        }
      }
 else       if (DitaUtil.targetIsADitaFormat(topicref)) {
        if (topicref.hasAttribute(""String_Node_Str"")) {
          targetDoc=resolveKeyrefToDoc(topicref.getAttribute(""String_Node_Str""));
        }
        if (targetDoc == null && topicref.hasAttribute(""String_Node_Str"")) {
          href=topicref.getAttribute(""String_Node_Str"");
          if (!href.startsWith(""String_Node_Str""))           targetDoc=AddressingUtil.resolveHrefToDoc(topicref,href,bosConstructionOptions,this.failOnAddressResolutionFailure);
        }
      }
 else {
        if (topicref.hasAttribute(""String_Node_Str"")) {
          targetUri=resolveKeyrefToUri(topicref.getAttribute(""String_Node_Str""));
        }
        if (targetUri == null && topicref.hasAttribute(""String_Node_Str"")) {
          href=topicref.getAttribute(""String_Node_Str"");
          if (!href.startsWith(""String_Node_Str""))           targetUri=AddressingUtil.resolveHrefToUri(topicref,href,this.failOnAddressResolutionFailure);
        }
      }
    }
 catch (    AddressingException e) {
      if (this.failOnAddressResolutionFailure) {
        throw new BosException(""String_Node_Str"" + topicref.getAttribute(""String_Node_Str"") + ""String_Node_Str"",e);
      }
    }
    BosMember childMember=null;
    if (targetDoc != null) {
      childMember=bos.constructBosMember(member,targetDoc);
    }
    if (targetUri != null) {
      childMember=bos.constructBosMember(member,targetUri);
    }
    if (childMember != null) {
      bos.addMember(member,childMember);
      newMembers.add((BosMember)childMember);
      if (href != null)       member.registerDependency(href,childMember,Constants.TOPICREF_DEPENDENCY);
    }
  }
  for (  BosMember newMember : newMembers) {
    if (!walkedMembers.contains(newMember))     walkMemberGetDependencies(bos,newMember);
  }
}"
13496,"public void testDitaBosConstruction() throws Exception {
  DitaBoundedObjectSet mapBos=DitaBosHelper.calculateMapBos(bosOptions,log,rootMap);
  assertNotNull(mapBos);
  assertEquals(9,mapBos.size());
  BosMember member=null;
  for (  BosMember cand : mapBos.getMembers()) {
    if (cand.getFileName().equals(""String_Node_Str"")) {
      member=cand;
      break;
    }
  }
  assertNotNull(member);
  Set<BosMember> deps=member.getDependenciesOfType(Constants.IMAGE_DEPENDENCY);
  assertNotNull(deps);
  assertEquals(1,deps.size());
  BosMember dep=deps.iterator().next();
  assertEquals(""String_Node_Str"",dep.getKey());
  Set<DependencyType> depTypes=member.getDependencyTypes();
  assertNotNull(depTypes);
  assertEquals(1,depTypes.size());
  assertTrue(depTypes.contains(Constants.IMAGE_DEPENDENCY));
  depTypes=member.getDependencyTypes(dep.getKey());
  assertNotNull(depTypes);
  assertTrue(depTypes.contains(Constants.IMAGE_DEPENDENCY));
  DitaBosReporter reporter=new TextDitaBosReporter();
  reporter.setPrintStream(System.out);
  reporter.report(mapBos,new BosReportOptions());
}","public void testDitaBosConstruction() throws Exception {
  DitaBoundedObjectSet mapBos=DitaBosHelper.calculateMapBos(bosOptions,log,rootMap);
  assertNotNull(mapBos);
  assertEquals(9,mapBos.size());
  BosMember memberTopic03=null;
  BosMember memberTopic04=null;
  for (  BosMember cand : mapBos.getMembers()) {
    if (cand.getFileName().equals(""String_Node_Str"")) {
      memberTopic03=cand;
    }
    if (cand.getFileName().equals(""String_Node_Str"")) {
      memberTopic04=cand;
    }
  }
  assertNotNull(memberTopic03);
  assertNotNull(memberTopic04);
  Set<BosMember> deps=memberTopic03.getDependenciesOfType(Constants.IMAGE_DEPENDENCY);
  assertNotNull(deps);
  assertEquals(1,deps.size());
  BosMember dep=deps.iterator().next();
  assertEquals(""String_Node_Str"",dep.getKey());
  Set<DependencyType> depTypes=memberTopic03.getDependencyTypes();
  assertNotNull(depTypes);
  assertEquals(1,depTypes.size());
  assertTrue(depTypes.contains(Constants.IMAGE_DEPENDENCY));
  depTypes=memberTopic03.getDependencyTypes(dep.getKey());
  assertNotNull(depTypes);
  assertTrue(depTypes.contains(Constants.IMAGE_DEPENDENCY));
  Map<String,? extends BosMember> depMap=memberTopic04.getDependencies();
  assertEquals(""String_Node_Str"",2,depMap.size());
  depTypes=memberTopic04.getDependencyTypes();
  assertEquals(""String_Node_Str"",2,depTypes.size());
  assertTrue(""String_Node_Str"",depTypes.contains(Constants.XREF_DEPENDENCY));
  assertTrue(""String_Node_Str"",depTypes.contains(Constants.IMAGE_DEPENDENCY));
  DitaBosReporter reporter=new TextDitaBosReporter();
  reporter.setPrintStream(System.out);
  reporter.report(mapBos,new BosReportOptions());
}"
13497,"/** 
 * @param mapBos
 * @param outputZipFile
 * @throws IOException 
 * @throws BosException 
 */
private void zipMapBos(DitaBoundedObjectSet mapBos,File outputZipFile) throws BosException, IOException {
  log.info(""String_Node_Str"");
  BosVisitor visitor=new DxpFileOrganizingBosVisitor();
  visitor.visit(mapBos);
  log.info(""String_Node_Str"" + outputZipFile.getAbsolutePath() + ""String_Node_Str"");
  OutputStream outStream=new FileOutputStream(outputZipFile);
  ZipOutputStream zipOutStream=new ZipOutputStream(outStream);
  ZipEntry entry=null;
  URI rootMapUri=mapBos.getRoot().getEffectiveUri();
  URI baseUri=null;
  try {
    baseUri=AddressingUtil.getParent(rootMapUri);
  }
 catch (  URISyntaxException e) {
    throw new BosException(""String_Node_Str"" + e.getMessage());
  }
  Set<String> dirs=new HashSet<String>();
  log.info(""String_Node_Str"");
  for (  BosMember member : mapBos.getMembers()) {
    log.info(""String_Node_Str"" + member + ""String_Node_Str"");
    URI relativeUri=baseUri.relativize(member.getEffectiveUri());
    File temp=new File(relativeUri.getPath());
    String parentPath=temp.getParent();
    if (!""String_Node_Str"".equals(parentPath) && parentPath != null && !dirs.contains(parentPath)) {
      entry=new ZipEntry(parentPath);
      zipOutStream.putNextEntry(entry);
      zipOutStream.closeEntry();
      dirs.add(parentPath);
    }
    entry=new ZipEntry(relativeUri.getPath());
    zipOutStream.putNextEntry(entry);
    IOUtils.copy(member.getInputStream(),zipOutStream);
    zipOutStream.closeEntry();
  }
  zipOutStream.close();
  log.info(""String_Node_Str"");
}","/** 
 * @param mapBos
 * @param outputZipFile
 * @throws IOException 
 * @throws BosException 
 */
private void zipMapBos(DitaBoundedObjectSet mapBos,File outputZipFile) throws BosException, IOException {
  log.info(""String_Node_Str"");
  BosVisitor visitor=new DxpFileOrganizingBosVisitor();
  visitor.visit(mapBos);
  log.info(""String_Node_Str"" + outputZipFile.getAbsolutePath() + ""String_Node_Str"");
  OutputStream outStream=new FileOutputStream(outputZipFile);
  ZipOutputStream zipOutStream=new ZipOutputStream(outStream);
  ZipEntry entry=null;
  URI rootMapUri=mapBos.getRoot().getEffectiveUri();
  URI baseUri=null;
  try {
    baseUri=AddressingUtil.getParent(rootMapUri);
  }
 catch (  URISyntaxException e) {
    throw new BosException(""String_Node_Str"" + e.getMessage());
  }
  Set<String> dirs=new HashSet<String>();
  log.info(""String_Node_Str"");
  for (  BosMember member : mapBos.getMembers()) {
    log.info(""String_Node_Str"" + member + ""String_Node_Str"");
    URI relativeUri=baseUri.relativize(member.getEffectiveUri());
    File temp=new File(relativeUri.getPath());
    String parentPath=temp.getParent();
    if (parentPath != null && !""String_Node_Str"".equals(parentPath) && !parentPath.endsWith(""String_Node_Str"")) {
      parentPath+=""String_Node_Str"";
    }
    log.debug(""String_Node_Str"" + parentPath + ""String_Node_Str"");
    if (!""String_Node_Str"".equals(parentPath) && parentPath != null && !dirs.contains(parentPath)) {
      entry=new ZipEntry(parentPath);
      zipOutStream.putNextEntry(entry);
      zipOutStream.closeEntry();
      dirs.add(parentPath);
    }
    entry=new ZipEntry(relativeUri.getPath());
    zipOutStream.putNextEntry(entry);
    IOUtils.copy(member.getInputStream(),zipOutStream);
    zipOutStream.closeEntry();
  }
  zipOutStream.close();
  log.info(""String_Node_Str"");
}"
13498,"/** 
 * @param args
 */
public static void main(String[] args){
  Options cmdlineOptions=configureOptions();
  CommandLineParser parser=new PosixParser();
  CommandLine cmdline=null;
  try {
    cmdline=parser.parse(cmdlineOptions,args);
  }
 catch (  ParseException exp) {
    HelpFormatter formatter=new HelpFormatter();
    formatter.printHelp(DitaDxpMapPackager.class.getSimpleName(),cmdlineOptions);
    System.exit(-1);
  }
  if (!cmdline.hasOption(INPUT_OPTION_ONE_CHAR) || !cmdline.hasOption(OUTPUT_OPTION_ONE_CHAR)) {
    HelpFormatter formatter=new HelpFormatter();
    formatter.printHelp(DitaDxpMapPackager.class.getSimpleName(),cmdlineOptions);
    System.exit(-1);
  }
  DitaDxpMapPackager app=new DitaDxpMapPackager(cmdline);
  try {
    app.run();
  }
 catch (  Exception e) {
    e.printStackTrace();
    System.exit(1);
  }
}","/** 
 * @param args
 */
public static void main(String[] args){
  Options cmdlineOptions=configureOptions();
  CommandLineParser parser=new PosixParser();
  CommandLine cmdline=null;
  try {
    cmdline=parser.parse(cmdlineOptions,args);
  }
 catch (  ParseException exp) {
    HelpFormatter formatter=new HelpFormatter();
    formatter.printHelp(DitaDxpMapPackager.class.getSimpleName(),cmdlineOptions);
    System.exit(-1);
  }
  if (!cmdline.hasOption(INPUT_OPTION_ONE_CHAR)) {
    HelpFormatter formatter=new HelpFormatter();
    formatter.printHelp(DitaDxpMapPackager.class.getSimpleName(),cmdlineOptions);
    System.exit(-1);
  }
  DitaDxpMapPackager app=new DitaDxpMapPackager(cmdline);
  try {
    app.run();
  }
 catch (  Exception e) {
    e.printStackTrace();
    System.exit(1);
  }
}"
13499,"/** 
 * @throws Exception 
 */
private void run() throws Exception {
  String mapFilepath=commandLine.getOptionValue(""String_Node_Str"");
  File mapFile=new File(mapFilepath);
  checkExistsAndCanReadSystemExit(mapFile);
  System.err.println(""String_Node_Str"" + mapFile.getAbsolutePath() + ""String_Node_Str"");
  String outputFilepath=commandLine.getOptionValue(""String_Node_Str"");
  File outputZipFile=new File(outputFilepath);
  outputZipFile.getParentFile().mkdirs();
  if (!outputZipFile.getParentFile().canWrite()) {
    throw new RuntimeException(""String_Node_Str"" + outputZipFile.getAbsolutePath() + ""String_Node_Str"");
  }
  Document rootMap=null;
  BosConstructionOptions bosOptions=new BosConstructionOptions(log,new HashMap<URI,Document>());
  setupCatalogs(bosOptions);
  try {
    URL rootMapUrl=mapFile.toURL();
    rootMap=DomUtil.getDomForUri(new URI(rootMapUrl.toExternalForm()),bosOptions);
    Date startTime=TimingUtils.getNowTime();
    DitaBoundedObjectSet mapBos=DitaBosHelper.calculateMapBos(bosOptions,log,rootMap);
    System.err.println(""String_Node_Str"" + TimingUtils.reportElapsedTime(startTime));
    zipMapBos(mapBos,outputZipFile);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
  }
}","/** 
 * @throws Exception 
 */
private void run() throws Exception {
  String mapFilepath=commandLine.getOptionValue(""String_Node_Str"");
  File mapFile=new File(mapFilepath);
  checkExistsAndCanReadSystemExit(mapFile);
  System.err.println(""String_Node_Str"" + mapFile.getAbsolutePath() + ""String_Node_Str"");
  File outputZipFile=null;
  String outputFilepath=null;
  if (commandLine.hasOption(OUTPUT_OPTION_ONE_CHAR)) {
    outputFilepath=commandLine.getOptionValue(OUTPUT_OPTION_ONE_CHAR);
    outputZipFile=new File(outputFilepath);
  }
 else {
    File parentDir=mapFile.getParentFile();
    String nameBase=FilenameUtils.getBaseName(mapFile.getName());
    outputZipFile=new File(parentDir,nameBase + DXP_EXTENSION);
  }
  outputZipFile.getParentFile().mkdirs();
  if (!outputZipFile.getParentFile().canWrite()) {
    throw new RuntimeException(""String_Node_Str"" + outputZipFile.getAbsolutePath() + ""String_Node_Str"");
  }
  Document rootMap=null;
  BosConstructionOptions bosOptions=new BosConstructionOptions(log,new HashMap<URI,Document>());
  setupCatalogs(bosOptions);
  try {
    URL rootMapUrl=mapFile.toURL();
    rootMap=DomUtil.getDomForUri(new URI(rootMapUrl.toExternalForm()),bosOptions);
    Date startTime=TimingUtils.getNowTime();
    DitaBoundedObjectSet mapBos=DitaBosHelper.calculateMapBos(bosOptions,log,rootMap);
    System.err.println(""String_Node_Str"" + TimingUtils.reportElapsedTime(startTime));
    zipMapBos(mapBos,outputZipFile);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
  }
}"
13500,"public void testDitaKeyspaceConstruction() throws Exception {
  Element resourceElement=null;
  URI resourceUri=null;
  DitaKeySpace keySpace;
  KeyAccessOptions keyAccessOptions=new KeyAccessOptions();
  DitaKeyDefinitionContext keydefContext=dlmService.registerRootMap(rootMap);
  assertNotNull(keydefContext);
  DitaKeyDefinitionContext candKeydefContext=dlmService.getKeyDefinitionContext(rootMap);
  assertEquals(keydefContext,candKeydefContext);
  keySpace=dlmService.getKeySpace(keyAccessOptions,keydefContext);
  assertNotNull(keySpace);
  assertEquals(rootMap.getDocumentURI(),keySpace.getRootMap(keyAccessOptions).getDocumentURI());
  dlmService.unRegisterKeySpace(keydefContext);
  keySpace=dlmService.getKeySpace(keyAccessOptions,keydefContext);
  assertNull(""String_Node_Str"",keySpace);
  keydefContext=dlmService.registerRootMap(rootMap);
  assertNotNull(keydefContext);
  dlmService.markKeySpaceOutOfDate(keydefContext);
  assertNotNull(keydefContext);
  assertTrue(keydefContext.isOutOfDate());
  KeyReportOptions reportOptions=new KeyReportOptions();
  KeySpaceReporter reporter=new TextKeySpaceReporter(System.out);
  reporter.report(keyAccessOptions,dlmService.getKeySpace(keyAccessOptions,keydefContext),reportOptions);
  reportOptions.setSortByMap(true);
  reporter.report(keyAccessOptions,dlmService.getKeySpace(keyAccessOptions,keydefContext),reportOptions);
  reportOptions.setSortByMap(false);
  reportOptions.setAllKeys(true);
  reporter.report(keyAccessOptions,dlmService.getKeySpace(keyAccessOptions,keydefContext),reportOptions);
  Set<String> keys=dlmService.getKeys(keyAccessOptions,keydefContext);
  assertNotNull(keys);
  assertEquals(keyCount,keys.size());
  keySpace=dlmService.getKeySpace(keyAccessOptions,keydefContext);
  assertNotNull(keySpace);
  assertEquals(keyCount,keySpace.size());
  Document candDoc=keySpace.getRootMap(keyAccessOptions);
  assertEquals(candDoc.getDocumentURI(),rootMap.getDocumentURI());
  Set<DitaKeyDefinition> keyDefSet=dlmService.getEffectiveKeyDefinitions(keyAccessOptions,keydefContext);
  List<DitaKeyDefinition> keyDefList=null;
  assertNotNull(""String_Node_Str"",keyDefSet);
  assertEquals(keyCount,keyDefSet.size());
  DitaKeyDefinition keyDef=dlmService.getKeyDefinition(keyAccessOptions,keydefContext,key01);
  assertNotNull(""String_Node_Str"",keyDef);
  String rootMapId=keyDef.getBaseUri().toURL().toExternalForm();
  assertNotNull(rootMapId);
  assertEquals(rootMap.getDocumentURI(),rootMapId);
  keyDefSet=dlmService.getEffectiveKeyDefinitionsForKey(keyAccessOptions,key01);
  assertNotNull(""String_Node_Str"",keyDefSet);
  assertEquals(1,keyDefSet.size());
  keyDefList=dlmService.getAllKeyDefinitionsForKey(keyAccessOptions,key01);
  assertNotNull(""String_Node_Str"",keyDefList);
  assertEquals(5,keyDefList.size());
  keyDef=dlmService.getKeyDefinition(keyAccessOptions,keydefContext,key01);
  assertNotNull(keyDef);
  assertEquals(key01,keyDef.getKey());
  KeyAccessOptions kaoNotWindows=new KeyAccessOptions();
  kaoNotWindows.addExclusion(""String_Node_Str"",""String_Node_Str"");
  KeyAccessOptions kaoNotOsx=new KeyAccessOptions();
  kaoNotOsx.addExclusion(""String_Node_Str"",""String_Node_Str"");
  KeyAccessOptions kaoNotOsxOrWin=new KeyAccessOptions();
  kaoNotOsxOrWin.addExclusion(""String_Node_Str"",""String_Node_Str"");
  kaoNotOsxOrWin.addExclusion(""String_Node_Str"",""String_Node_Str"");
  DitaKeyDefinition keyDefOsx=dlmService.getKeyDefinition(kaoNotWindows,keydefContext,key01);
  assertNotNull(keyDefOsx);
  assertEquals(keyDefOsx,keyDef);
  assertTrue(keyDefOsx.getDitaPropsSpec().equals(keyDef.getDitaPropsSpec()));
  DitaKeyDefinition keyDefWindows=dlmService.getKeyDefinition(kaoNotOsx,keydefContext,key01);
  assertFalse(keyDefOsx.equals(keyDefWindows));
  assertFalse(keyDefOsx.getDitaPropsSpec().equals(keyDefWindows.getDitaPropsSpec()));
  keyDefList=dlmService.getAllKeyDefinitionsForKey(keyAccessOptions,keydefContext,key01);
  assertNotNull(keyDefList);
  assertEquals(5,keyDefList.size());
  DitaResource res;
  DitaElementResource elemRes;
  URL resUrl;
  res=dlmService.getResource(keyAccessOptions,keydefContext,key01);
  assertNotNull(res);
  assertTrue(""String_Node_Str"",res instanceof DitaElementResource);
  elemRes=(DitaElementResource)res;
  Element resElem=elemRes.getElement();
  assertNotNull(""String_Node_Str"",resElem);
  resUrl=res.getUrl();
  assertNotNull(""String_Node_Str"",resUrl);
  res=dlmService.getResource(keyAccessOptions,keydefContext,key02);
  assertNotNull(res);
  assertFalse(""String_Node_Str"",res instanceof DitaElementResource);
  resUrl=res.getUrl();
  assertNotNull(resUrl);
  assertTrue(dlmService.isKeyDefined(key01));
  assertTrue(dlmService.isKeyDefined(key01,keydefContext));
  assertFalse(dlmService.isKeyDefined(""String_Node_Str""));
  assertFalse(dlmService.isKeyDefined(""String_Node_Str"",keydefContext));
}","public void testDitaKeyspaceConstruction() throws Exception {
  Element resourceElement=null;
  URI resourceUri=null;
  DitaKeySpace keySpace;
  KeyAccessOptions keyAccessOptions=new KeyAccessOptions();
  DitaKeyDefinitionContext keydefContext=dlmService.registerRootMap(rootMap);
  assertNotNull(keydefContext);
  DitaKeyDefinitionContext candKeydefContext=dlmService.getKeyDefinitionContext(rootMap);
  assertEquals(keydefContext,candKeydefContext);
  keySpace=dlmService.getKeySpace(keyAccessOptions,keydefContext);
  assertNotNull(keySpace);
  assertEquals(rootMap.getDocumentURI(),keySpace.getRootMap(keyAccessOptions).getDocumentURI());
  dlmService.unRegisterKeySpace(keydefContext);
  keySpace=dlmService.getKeySpace(keyAccessOptions,keydefContext);
  assertNull(""String_Node_Str"",keySpace);
  keydefContext=dlmService.registerRootMap(rootMap);
  assertNotNull(keydefContext);
  dlmService.markKeySpaceOutOfDate(keydefContext);
  assertNotNull(keydefContext);
  assertTrue(keydefContext.isOutOfDate());
  KeyReportOptions reportOptions=new KeyReportOptions();
  KeySpaceReporter reporter=new TextKeySpaceReporter();
  reporter.setPrintStream(System.out);
  reporter.report(keyAccessOptions,dlmService.getKeySpace(keyAccessOptions,keydefContext),reportOptions);
  reportOptions.setSortByMap(true);
  reporter.report(keyAccessOptions,dlmService.getKeySpace(keyAccessOptions,keydefContext),reportOptions);
  reportOptions.setSortByMap(false);
  reportOptions.setAllKeys(true);
  reporter.report(keyAccessOptions,dlmService.getKeySpace(keyAccessOptions,keydefContext),reportOptions);
  Set<String> keys=dlmService.getKeys(keyAccessOptions,keydefContext);
  assertNotNull(keys);
  assertEquals(keyCount,keys.size());
  keySpace=dlmService.getKeySpace(keyAccessOptions,keydefContext);
  assertNotNull(keySpace);
  assertEquals(keyCount,keySpace.size());
  Document candDoc=keySpace.getRootMap(keyAccessOptions);
  assertEquals(candDoc.getDocumentURI(),rootMap.getDocumentURI());
  Set<DitaKeyDefinition> keyDefSet=dlmService.getEffectiveKeyDefinitions(keyAccessOptions,keydefContext);
  List<DitaKeyDefinition> keyDefList=null;
  assertNotNull(""String_Node_Str"",keyDefSet);
  assertEquals(keyCount,keyDefSet.size());
  DitaKeyDefinition keyDef=dlmService.getKeyDefinition(keyAccessOptions,keydefContext,key01);
  assertNotNull(""String_Node_Str"",keyDef);
  String rootMapId=keyDef.getBaseUri().toURL().toExternalForm();
  assertNotNull(rootMapId);
  assertEquals(rootMap.getDocumentURI(),rootMapId);
  keyDefSet=dlmService.getEffectiveKeyDefinitionsForKey(keyAccessOptions,key01);
  assertNotNull(""String_Node_Str"",keyDefSet);
  assertEquals(1,keyDefSet.size());
  keyDefList=dlmService.getAllKeyDefinitionsForKey(keyAccessOptions,key01);
  assertNotNull(""String_Node_Str"",keyDefList);
  assertEquals(5,keyDefList.size());
  keyDef=dlmService.getKeyDefinition(keyAccessOptions,keydefContext,key01);
  assertNotNull(keyDef);
  assertEquals(key01,keyDef.getKey());
  KeyAccessOptions kaoNotWindows=new KeyAccessOptions();
  kaoNotWindows.addExclusion(""String_Node_Str"",""String_Node_Str"");
  KeyAccessOptions kaoNotOsx=new KeyAccessOptions();
  kaoNotOsx.addExclusion(""String_Node_Str"",""String_Node_Str"");
  KeyAccessOptions kaoNotOsxOrWin=new KeyAccessOptions();
  kaoNotOsxOrWin.addExclusion(""String_Node_Str"",""String_Node_Str"");
  kaoNotOsxOrWin.addExclusion(""String_Node_Str"",""String_Node_Str"");
  DitaKeyDefinition keyDefOsx=dlmService.getKeyDefinition(kaoNotWindows,keydefContext,key01);
  assertNotNull(keyDefOsx);
  assertEquals(keyDefOsx,keyDef);
  assertTrue(keyDefOsx.getDitaPropsSpec().equals(keyDef.getDitaPropsSpec()));
  DitaKeyDefinition keyDefWindows=dlmService.getKeyDefinition(kaoNotOsx,keydefContext,key01);
  assertFalse(keyDefOsx.equals(keyDefWindows));
  assertFalse(keyDefOsx.getDitaPropsSpec().equals(keyDefWindows.getDitaPropsSpec()));
  keyDefList=dlmService.getAllKeyDefinitionsForKey(keyAccessOptions,keydefContext,key01);
  assertNotNull(keyDefList);
  assertEquals(5,keyDefList.size());
  DitaResource res;
  DitaElementResource elemRes;
  URL resUrl;
  res=dlmService.getResource(keyAccessOptions,keydefContext,key01);
  assertNotNull(res);
  assertTrue(""String_Node_Str"",res instanceof DitaElementResource);
  elemRes=(DitaElementResource)res;
  Element resElem=elemRes.getElement();
  assertNotNull(""String_Node_Str"",resElem);
  resUrl=res.getUrl();
  assertNotNull(""String_Node_Str"",resUrl);
  res=dlmService.getResource(keyAccessOptions,keydefContext,key02);
  assertNotNull(res);
  assertFalse(""String_Node_Str"",res instanceof DitaElementResource);
  resUrl=res.getUrl();
  assertNotNull(resUrl);
  assertTrue(dlmService.isKeyDefined(key01));
  assertTrue(dlmService.isKeyDefined(key01,keydefContext));
  assertFalse(dlmService.isKeyDefined(""String_Node_Str""));
  assertFalse(dlmService.isKeyDefined(""String_Node_Str"",keydefContext));
}"
13501,"public static void destroyAudio(AudioClip mAudio){
  try {
    if (mAudio != null) {
      mAudio.stop();
      mAudio.release();
    }
  }
 catch (  Exception e) {
    Logger.e(TAG,""String_Node_Str"",e);
  }
 finally {
    mAudio=null;
  }
}","public static void destroyAudio(AudioClip mAudio){
  try {
    if (mAudio != null) {
      mAudio.stop();
      mAudio.release();
    }
  }
 catch (  Exception e) {
    Logger.e(TAG,""String_Node_Str"",e);
  }
}"
13502,"public void onStart(Intent intent,int value){
  if (intent == null)   return;
  String filePath=intent.getStringExtra(EXTRA_FILEPATHS);
  playAsNotification=intent.getBooleanExtra(EXTRA_PLAY_AS_NOTIFICATION,true);
  deleteFile=intent.getBooleanExtra(EXTRA_DELETE_FILE,false);
  StringTokenizer token=new StringTokenizer(filePath,""String_Node_Str"");
  filePaths=new ArrayList<String>();
  while (token.hasMoreTokens()) {
    String file=token.nextToken().trim();
    if (file.length() > 0 && (new File(file).exists()))     filePaths.add(file);
  }
  if (filePath == null || filePaths.size() == 0)   return;
  if (mediaPlayer == null && playAsNotification) {
    AudioManager am=(AudioManager)getSystemService(Context.AUDIO_SERVICE);
    originalVolumeMedia=am.getStreamVolume(AudioManager.STREAM_MUSIC);
    am.setStreamVolume(AudioManager.STREAM_MUSIC,originalVolumeMedia / 4,AudioManager.FLAG_VIBRATE);
  }
  playNextMedia();
}","public void onStart(Intent intent,int value){
  if (intent == null)   return;
  String filePath=intent.getStringExtra(EXTRA_FILEPATHS);
  playAsNotification=intent.getBooleanExtra(EXTRA_PLAY_AS_NOTIFICATION,true);
  deleteFile=intent.getBooleanExtra(EXTRA_DELETE_FILE,false);
  StringTokenizer token=new StringTokenizer(filePath,""String_Node_Str"");
  filePaths=new ArrayList<>();
  while (token.hasMoreTokens()) {
    String file=token.nextToken().trim();
    if (file.length() > 0 && (new File(file).exists()))     filePaths.add(file);
  }
  if (filePath == null || filePaths.size() == 0)   return;
  if (mediaPlayer == null && playAsNotification) {
    AudioManager am=(AudioManager)getSystemService(Context.AUDIO_SERVICE);
    originalVolumeMedia=am.getStreamVolume(AudioManager.STREAM_MUSIC);
    am.setStreamVolume(AudioManager.STREAM_MUSIC,originalVolumeMedia / 4,AudioManager.FLAG_VIBRATE);
  }
  playNextMedia();
}"
13503,"public ManagerAudio(){
  soundPool=new SoundPool(10,AudioManager.STREAM_MUSIC,0);
  soundPoolMap=new Hashtable<Integer,Integer>();
  soundPoolMap.put(SOUND_POOL_BEEP,soundPool.load(A.getApp(),R.raw.sound_beep_01,1));
}","public ManagerAudio(){
  soundPool=new SoundPool(10,AudioManager.STREAM_MUSIC,0);
  soundPoolMap=new Hashtable<>();
  soundPoolMap.put(SOUND_POOL_BEEP,soundPool.load(A.getApp(),R.raw.sound_beep_01,1));
}"
13504,"public GpsConnection(Context context){
  Logger.w(TAG,""String_Node_Str"");
  llGPS=new MyLocationListener();
  llNetwork=new MyLocationListener();
  gpsListener=new MyGpsListener();
  isFixed=false;
  locationManager=(LocationManager)context.getSystemService(Context.LOCATION_SERVICE);
  providers=locationManager.getAllProviders();
  try {
    locationManager.removeUpdates(llGPS);
  }
 catch (  Exception e) {
    Logger.w(TAG,""String_Node_Str"" + e);
  }
  try {
    locationManager.removeUpdates(llNetwork);
  }
 catch (  Exception e) {
    Logger.w(TAG,""String_Node_Str"" + e);
  }
  if (providers.contains(LocationManager.NETWORK_PROVIDER)) {
    try {
      locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER,Preferences.GPS_MIN_TIME * 1000,0,llNetwork);
      networkProviderEnabled=true;
    }
 catch (    Exception e) {
      Logger.w(TAG,""String_Node_Str"" + e);
      networkProviderEnabled=false;
    }
  }
  if (providers.contains(LocationManager.GPS_PROVIDER)) {
    try {
      locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,Preferences.GPS_MIN_TIME * 1000,0,llGPS);
      gpsProviderEnabled=true;
    }
 catch (    Exception e) {
      Logger.w(TAG,""String_Node_Str"" + e);
      gpsProviderEnabled=false;
    }
  }
  try {
    locationManager.addGpsStatusListener(gpsListener);
  }
 catch (  Exception e) {
    Logger.w(TAG,""String_Node_Str"" + e);
  }
  if (networkProviderEnabled || gpsProviderEnabled) {
    ManagerNotify.toastShortMessage(context,context.getString(R.string.gps_enabled));
  }
 else {
    if (PreferenceValues.getCurrentActivity() != null) {
      UtilsGUI.showDialogInfo(PreferenceValues.getCurrentActivity(),R.string.no_location_providers_available);
    }
    LocationState.setGpsOff(context);
    destroy();
  }
}","public GpsConnection(Context context){
  Logger.w(TAG,""String_Node_Str"");
  llGPS=new MyLocationListener();
  llNetwork=new MyLocationListener();
  gpsListener=new MyGpsListener();
  isFixed=false;
  locationManager=(LocationManager)context.getSystemService(Context.LOCATION_SERVICE);
  List<String> providers=locationManager.getAllProviders();
  try {
    locationManager.removeUpdates(llGPS);
  }
 catch (  Exception e) {
    Logger.w(TAG,""String_Node_Str"" + e);
  }
  try {
    locationManager.removeUpdates(llNetwork);
  }
 catch (  Exception e) {
    Logger.w(TAG,""String_Node_Str"" + e);
  }
  if (providers.contains(LocationManager.NETWORK_PROVIDER)) {
    try {
      locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER,Preferences.GPS_MIN_TIME * 1000,0,llNetwork);
      networkProviderEnabled=true;
    }
 catch (    Exception e) {
      Logger.w(TAG,""String_Node_Str"" + e);
      networkProviderEnabled=false;
    }
  }
  if (providers.contains(LocationManager.GPS_PROVIDER)) {
    try {
      locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,Preferences.GPS_MIN_TIME * 1000,0,llGPS);
      gpsProviderEnabled=true;
    }
 catch (    Exception e) {
      Logger.w(TAG,""String_Node_Str"" + e);
      gpsProviderEnabled=false;
    }
  }
  try {
    locationManager.addGpsStatusListener(gpsListener);
  }
 catch (  Exception e) {
    Logger.w(TAG,""String_Node_Str"" + e);
  }
  if (networkProviderEnabled || gpsProviderEnabled) {
    ManagerNotify.toastShortMessage(context,context.getString(R.string.gps_enabled));
  }
 else {
    if (PreferenceValues.getCurrentActivity() != null) {
      UtilsGUI.showDialogInfo(PreferenceValues.getCurrentActivity(),R.string.no_location_providers_available);
    }
    LocationState.setGpsOff(context);
    destroy();
  }
}"
13505,"protected static void onStatusChanged(String provider,int status,Bundle extras){
  Logger.w(TAG,""String_Node_Str"" + provider + ""String_Node_Str""+ status+ ""String_Node_Str""+ extras+ ""String_Node_Str"");
  for (int i=0; i < mListeners.size(); i++) {
    mListeners.get(i).onStatusChanged(provider,status,extras);
  }
  if (provider.equals(LocationManager.GPS_PROVIDER) && status == 1) {
    if (LocationState.location != null) {
      LocationState.location.setProvider(LocationManager.NETWORK_PROVIDER);
      onLocationChanged(LocationState.location);
    }
  }
}","static void onStatusChanged(String provider,int status,Bundle extras){
  Logger.w(TAG,""String_Node_Str"" + provider + ""String_Node_Str""+ status+ ""String_Node_Str""+ extras+ ""String_Node_Str"");
  for (int i=0; i < mListeners.size(); i++) {
    mListeners.get(i).onStatusChanged(provider,status,extras);
  }
  if (provider.equals(LocationManager.GPS_PROVIDER) && status == 1) {
    if (LocationState.location != null) {
      LocationState.location.setProvider(LocationManager.NETWORK_PROVIDER);
      onLocationChanged(LocationState.location);
    }
  }
}"
13506,"protected static void onProviderEnabled(String provider){
  Logger.w(TAG,""String_Node_Str"" + provider + ""String_Node_Str"");
}","static void onProviderEnabled(String provider){
  Logger.w(TAG,""String_Node_Str"" + provider + ""String_Node_Str"");
}"
13507,"public static void init(Context c){
  if (LocationState.location == null) {
    LocationState.location=PreferenceValues.getLastKnownLocation(c);
    mListeners=new ArrayList<ILocationEventListener>();
    lastSource=-1;
  }
}","public static void init(Context c){
  if (LocationState.location == null) {
    LocationState.location=PreferenceValues.getLastKnownLocation();
    mListeners=new ArrayList<>();
    lastSource=-1;
  }
}"
13508,"protected static void onLocationChanged(Location location){
  try {
    if (location == null)     return;
    if (LocationState.location != null) {
      if (LocationState.location.getProvider().equals(LocationManager.NETWORK_PROVIDER) && location.getProvider().equals(LocationManager.GPS_PROVIDER) && (LocationState.location.getAccuracy() * 3) < location.getAccuracy()) {
        return;
      }
      if (!speedCorrection && (location.getTime() - LocationState.location.getTime()) < 5000 && location.getSpeed() > 100.0f && location.getSpeed() / LocationState.location.getSpeed() > 2) {
        location.setSpeed(LocationState.location.getSpeed());
        speedCorrection=true;
      }
 else {
        speedCorrection=false;
      }
      if (LocationState.location.getProvider().equals(LocationManager.GPS_PROVIDER)) {
        mLastGpsFixTime=System.currentTimeMillis();
      }
      if (location.getSpeed() < 0.5f) {
        if (Math.abs(location.getBearing() - LocationState.location.getBearing()) > 25.0) {
          location.setBearing(LocationState.location.getBearing());
        }
      }
    }
    if (location.getProvider().equals(LocationManager.GPS_PROVIDER)) {
      location.setAltitude(location.getAltitude() + Preferences.GPS_ALTITUDE_CORRECTION);
    }
    LocationState.location=location;
    for (int i=0; i < mListeners.size(); i++) {
      ILocationEventListener list=mListeners.get(i);
      list.onLocationChanged(location);
    }
  }
 catch (  Exception e) {
    Logger.e(TAG,""String_Node_Str"" + location + ""String_Node_Str"",e);
  }
}","static void onLocationChanged(Location location){
  try {
    if (location == null)     return;
    if (LocationState.location != null) {
      if (LocationState.location.getProvider().equals(LocationManager.NETWORK_PROVIDER) && location.getProvider().equals(LocationManager.GPS_PROVIDER) && (LocationState.location.getAccuracy() * 3) < location.getAccuracy()) {
        return;
      }
      if (!speedCorrection && (location.getTime() - LocationState.location.getTime()) < 5000 && location.getSpeed() > 100.0f && location.getSpeed() / LocationState.location.getSpeed() > 2) {
        location.setSpeed(LocationState.location.getSpeed());
        speedCorrection=true;
      }
 else {
        speedCorrection=false;
      }
      if (LocationState.location.getProvider().equals(LocationManager.GPS_PROVIDER)) {
        mLastGpsFixTime=System.currentTimeMillis();
      }
      if (location.getSpeed() < 0.5f) {
        if (Math.abs(location.getBearing() - LocationState.location.getBearing()) > 25.0) {
          location.setBearing(LocationState.location.getBearing());
        }
      }
    }
    if (location.getProvider().equals(LocationManager.GPS_PROVIDER)) {
      location.setAltitude(location.getAltitude() + Preferences.GPS_ALTITUDE_CORRECTION);
    }
    LocationState.location=location;
    for (int i=0; i < mListeners.size(); i++) {
      ILocationEventListener list=mListeners.get(i);
      list.onLocationChanged(location);
    }
  }
 catch (  Exception e) {
    Logger.e(TAG,""String_Node_Str"" + location + ""String_Node_Str"",e);
  }
}"
13509,"protected static void onProviderDisabled(String provider){
}","static void onProviderDisabled(String provider){
}"
13510,"protected static void onGpsStatusChanged(int event,GpsStatus gpsStatus){
  if (mListeners == null || mListeners.size() == 0)   return;
  if (event == GpsStatus.GPS_EVENT_STARTED || event == GpsStatus.GPS_EVENT_STOPPED) {
    for (int i=0; i < mListeners.size(); i++) {
      mListeners.get(i).onStatusChanged(LocationManager.GPS_PROVIDER,event == GpsStatus.GPS_EVENT_STARTED ? 2 : 1,null);
    }
  }
 else   if (event == GpsStatus.GPS_EVENT_SATELLITE_STATUS) {
    ArrayList<SatellitePosition> pos=null;
    if (gpsStatus != null) {
      pos=new ArrayList<SatellitePosition>();
      Iterator<GpsSatellite> enuSat=gpsStatus.getSatellites().iterator();
      mSatsCount.x=0;
      mSatsCount.y=0;
      while (enuSat.hasNext()) {
        GpsSatellite sat=enuSat.next();
        SatellitePosition satPos=new SatellitePosition();
        satPos.azimuth=sat.getAzimuth();
        satPos.elevation=sat.getElevation();
        satPos.prn=sat.getPrn();
        satPos.snr=(int)sat.getSnr();
        satPos.fixed=sat.usedInFix();
        if (satPos.fixed)         mSatsCount.x++;
        mSatsCount.y++;
        pos.add(satPos);
      }
    }
    postGpsSatelliteChange(pos);
  }
}","static void onGpsStatusChanged(int event,GpsStatus gpsStatus){
  if (mListeners == null || mListeners.size() == 0)   return;
  if (event == GpsStatus.GPS_EVENT_STARTED || event == GpsStatus.GPS_EVENT_STOPPED) {
    for (int i=0; i < mListeners.size(); i++) {
      mListeners.get(i).onStatusChanged(LocationManager.GPS_PROVIDER,event == GpsStatus.GPS_EVENT_STARTED ? 2 : 1,null);
    }
  }
 else   if (event == GpsStatus.GPS_EVENT_SATELLITE_STATUS) {
    ArrayList<SatellitePosition> pos=null;
    if (gpsStatus != null) {
      pos=new ArrayList<>();
      Iterator<GpsSatellite> enuSat=gpsStatus.getSatellites().iterator();
      mSatsCount.x=0;
      mSatsCount.y=0;
      while (enuSat.hasNext()) {
        GpsSatellite sat=enuSat.next();
        SatellitePosition satPos=new SatellitePosition();
        satPos.azimuth=sat.getAzimuth();
        satPos.elevation=sat.getElevation();
        satPos.prn=sat.getPrn();
        satPos.snr=(int)sat.getSnr();
        satPos.fixed=sat.usedInFix();
        if (satPos.fixed)         mSatsCount.x++;
        mSatsCount.y++;
        pos.add(satPos);
      }
    }
    postGpsSatelliteChange(pos);
  }
}"
13511,"/** 
 * The default constructor.
 * @see Point2D.Float
 * @see Point2D.Double
 */
protected Point2D(){
}","/** 
 * The default constructor.
 */
Point2D(){
}"
13512,"public Orientation(){
  this.listeners=new Vector<IOrientationEventListener>();
}","public Orientation(){
  this.listeners=new Vector<>();
}"
13513,"public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (A.getMain() == null || MainActivity.selectedFile == null || MainActivity.cartridgeFile == null) {
    finish();
    return;
  }
  setContentView(R.layout.layout_details);
  TextView tvName=(TextView)findViewById(R.id.layoutDetailsTextViewName);
  tvName.setText(MainActivity.cartridgeFile.name);
  TextView tvState=(TextView)findViewById(R.id.layoutDetailsTextViewState);
  tvState.setText(getString(R.string.author) + ""String_Node_Str"" + MainActivity.cartridgeFile.author);
  TextView tvDescription=(TextView)findViewById(R.id.layoutDetailsTextViewDescription);
  tvDescription.setText(UtilsGUI.simpleHtml(MainActivity.cartridgeFile.description));
  ImageView ivImage=(ImageView)findViewById(R.id.layoutDetailsImageViewImage);
  try {
    byte[] is=MainActivity.cartridgeFile.getFile(MainActivity.cartridgeFile.splashId);
    Bitmap i=BitmapFactory.decodeByteArray(is,0,is.length);
    MainActivity.setBitmapToImageView(i,ivImage);
  }
 catch (  Exception e) {
  }
  TextView tvText=(TextView)findViewById(R.id.layoutDetailsTextViewImageText);
  tvText.setVisibility(View.GONE);
  TextView tvDistance=(TextView)findViewById(R.id.layoutDetailsTextViewDistance);
  Location loc=new Location(TAG);
  loc.setLatitude(MainActivity.cartridgeFile.latitude);
  loc.setLongitude(MainActivity.cartridgeFile.longitude);
  StringBuilder buff=new StringBuilder();
  buff.append(getString(R.string.distance)).append(""String_Node_Str"").append(""String_Node_Str"").append(UtilsFormat.formatDistance(LocationState.getLocation().distanceTo(loc),false)).append(""String_Node_Str"").append(""String_Node_Str"").append(getString(R.string.latitude)).append(""String_Node_Str"").append(UtilsFormat.formatLatitude(MainActivity.cartridgeFile.latitude)).append(""String_Node_Str"").append(getString(R.string.longitude)).append(""String_Node_Str"").append(UtilsFormat.formatLatitude(MainActivity.cartridgeFile.longitude));
  tvDistance.setText(Html.fromHtml(buff.toString()));
  CustomDialog.setBottom(this,getString(R.string.start),new CustomDialog.OnClickListener(){
    @Override public boolean onClick(    CustomDialog dialog,    View v,    int btn){
      CartridgeDetailsActivity.this.finish();
      MainActivity.startSelectedCartridge(false);
      return true;
    }
  }
,null,null,getString(R.string.navigate),new CustomDialog.OnClickListener(){
    @Override public boolean onClick(    CustomDialog dialog,    View v,    int btn){
      Location loc=new Location(TAG);
      loc.setLatitude(MainActivity.cartridgeFile.latitude);
      loc.setLongitude(MainActivity.cartridgeFile.longitude);
      Guide guide=new Guide(MainActivity.cartridgeFile.name,loc);
      A.getGuidingContent().guideStart(guide);
      MainActivity.callGudingScreen(CartridgeDetailsActivity.this);
      CartridgeDetailsActivity.this.finish();
      return true;
    }
  }
);
}","public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (A.getMain() == null || MainActivity.selectedFile == null || MainActivity.cartridgeFile == null) {
    finish();
    return;
  }
  setContentView(R.layout.layout_details);
  TextView tvName=(TextView)findViewById(R.id.layoutDetailsTextViewName);
  tvName.setText(MainActivity.cartridgeFile.name);
  TextView tvState=(TextView)findViewById(R.id.layoutDetailsTextViewState);
  tvState.setText(getString(R.string.author) + ""String_Node_Str"" + MainActivity.cartridgeFile.author);
  TextView tvDescription=(TextView)findViewById(R.id.layoutDetailsTextViewDescription);
  tvDescription.setText(UtilsGUI.simpleHtml(MainActivity.cartridgeFile.description));
  ImageView ivImage=(ImageView)findViewById(R.id.layoutDetailsImageViewImage);
  try {
    byte[] is=MainActivity.cartridgeFile.getFile(MainActivity.cartridgeFile.splashId);
    Bitmap i=BitmapFactory.decodeByteArray(is,0,is.length);
    MainActivity.setBitmapToImageView(i,ivImage);
  }
 catch (  Exception e) {
  }
  TextView tvText=(TextView)findViewById(R.id.layoutDetailsTextViewImageText);
  tvText.setVisibility(View.GONE);
  TextView tvDistance=(TextView)findViewById(R.id.layoutDetailsTextViewDistance);
  Location loc=new Location(TAG);
  loc.setLatitude(MainActivity.cartridgeFile.latitude);
  loc.setLongitude(MainActivity.cartridgeFile.longitude);
  String buff=getString(R.string.distance) + ""String_Node_Str"" + ""String_Node_Str""+ UtilsFormat.formatDistance(LocationState.getLocation().distanceTo(loc),false)+ ""String_Node_Str""+ ""String_Node_Str""+ getString(R.string.latitude)+ ""String_Node_Str""+ UtilsFormat.formatLatitude(MainActivity.cartridgeFile.latitude)+ ""String_Node_Str""+ getString(R.string.longitude)+ ""String_Node_Str""+ UtilsFormat.formatLatitude(MainActivity.cartridgeFile.longitude);
  tvDistance.setText(Html.fromHtml(buff));
  CustomDialog.setBottom(this,getString(R.string.start),new CustomDialog.OnClickListener(){
    @Override public boolean onClick(    CustomDialog dialog,    View v,    int btn){
      CartridgeDetailsActivity.this.finish();
      MainActivity.startSelectedCartridge(false);
      return true;
    }
  }
,null,null,getString(R.string.navigate),new CustomDialog.OnClickListener(){
    @Override public boolean onClick(    CustomDialog dialog,    View v,    int btn){
      Location loc=new Location(TAG);
      loc.setLatitude(MainActivity.cartridgeFile.latitude);
      loc.setLongitude(MainActivity.cartridgeFile.longitude);
      Guide guide=new Guide(MainActivity.cartridgeFile.name,loc);
      A.getGuidingContent().guideStart(guide);
      MainActivity.callGudingScreen(CartridgeDetailsActivity.this);
      CartridgeDetailsActivity.this.finish();
      return true;
    }
  }
);
}"
13514,"@Override public void onOrientationChanged(float azimuth,float pitch,float roll){
  Location loc=LocationState.getLocation();
  mAzimuth=azimuth;
  mPitch=pitch;
  mRoll=roll;
  String provider=loc.getProvider();
  if (provider.equals(LocationManager.GPS_PROVIDER)) {
    provider=getString(R.string.provider_gps);
  }
 else   if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
    provider=getString(R.string.provider_network);
  }
 else {
    provider=getString(R.string.provider_passive);
  }
  viewProvider.setText(provider);
  viewLat.setText(UtilsFormat.formatLatitude(loc.getLatitude()));
  viewLon.setText(UtilsFormat.formatLongitude(loc.getLongitude()));
  viewAlt.setText(UtilsFormat.formatAltitude(loc.getAltitude(),true));
  viewAcc.setText(UtilsFormat.formatDistance((double)loc.getAccuracy(),false));
  viewSpeed.setText(UtilsFormat.formatSpeed(loc.getSpeed(),false));
  repaint();
}","@Override public void onOrientationChanged(float azimuth,float pitch,float roll){
  Location loc=LocationState.getLocation();
  mAzimuth=azimuth;
  mPitch=pitch;
  mRoll=roll;
  String provider=loc.getProvider();
switch (provider) {
case LocationManager.GPS_PROVIDER:
    provider=getString(R.string.provider_gps);
  break;
case LocationManager.NETWORK_PROVIDER:
provider=getString(R.string.provider_network);
break;
default :
provider=getString(R.string.provider_passive);
break;
}
viewProvider.setText(provider);
viewLat.setText(UtilsFormat.formatLatitude(loc.getLatitude()));
viewLon.setText(UtilsFormat.formatLongitude(loc.getLongitude()));
viewAlt.setText(UtilsFormat.formatAltitude(loc.getAltitude(),true));
viewAcc.setText(UtilsFormat.formatDistance((double)loc.getAccuracy(),false));
viewSpeed.setText(UtilsFormat.formatSpeed(loc.getSpeed(),false));
repaint();
}"
13515,"public static void refreshCartridges(){
  Logger.w(TAG,""String_Node_Str"" + (MainActivity.selectedFile == null));
  File[] files=FileSystem.getFiles(FileSystem.ROOT,""String_Node_Str"");
  cartridgeFiles=new Vector<CartridgeFile>();
  ArrayList<Waypoint> wpts=new ArrayList<Waypoint>();
  File actualFile=null;
  if (files != null) {
    for (    File file : files) {
      try {
        actualFile=file;
        CartridgeFile cart=CartridgeFile.read(new WSeekableFile(file),new WSaveFile(file));
        if (cart != null) {
          cart.filename=file.getAbsolutePath();
          Location loc=new Location(TAG);
          loc.setLatitude(cart.latitude);
          loc.setLongitude(cart.longitude);
          Waypoint waypoint=new Waypoint(cart.name,loc);
          cartridgeFiles.add(cart);
          wpts.add(waypoint);
        }
      }
 catch (      Exception e) {
        Logger.w(TAG,""String_Node_Str"" + actualFile + ""String_Node_Str""+ e.toString());
        ManagerNotify.toastShortMessage(Locale.getString(R.string.invalid_cartridge,actualFile.getName()));
      }
    }
  }
  if (wpts.size() > 0) {
  }
}","public static void refreshCartridges(){
  Logger.w(TAG,""String_Node_Str"" + (MainActivity.selectedFile == null));
  File[] files=FileSystem.getFiles(FileSystem.ROOT,""String_Node_Str"");
  cartridgeFiles=new Vector<>();
  ArrayList<Waypoint> wpts=new ArrayList<>();
  File actualFile=null;
  if (files != null) {
    for (    File file : files) {
      try {
        actualFile=file;
        CartridgeFile cart=CartridgeFile.read(new WSeekableFile(file),new WSaveFile(file));
        if (cart != null) {
          cart.filename=file.getAbsolutePath();
          Location loc=new Location(TAG);
          loc.setLatitude(cart.latitude);
          loc.setLongitude(cart.longitude);
          Waypoint waypoint=new Waypoint(cart.name,loc);
          cartridgeFiles.add(cart);
          wpts.add(waypoint);
        }
      }
 catch (      Exception e) {
        Logger.w(TAG,""String_Node_Str"" + actualFile + ""String_Node_Str""+ e.toString());
        ManagerNotify.toastShortMessage(Locale.getString(R.string.invalid_cartridge,actualFile.getName()));
      }
    }
  }
  if (wpts.size() > 0) {
  }
}"
13516,"public static File getSaveFile() throws IOException {
  try {
    File file=new File(selectedFile.substring(0,selectedFile.length() - 3) + ""String_Node_Str"");
    return file;
  }
 catch (  SecurityException e) {
    Logger.e(TAG,""String_Node_Str"",e);
    return null;
  }
}","public static File getSaveFile() throws IOException {
  try {
    return new File(selectedFile.substring(0,selectedFile.length() - 3) + ""String_Node_Str"");
  }
 catch (  SecurityException e) {
    Logger.e(TAG,""String_Node_Str"",e);
    return null;
  }
}"
13517,"public static File getLogFile() throws IOException {
  try {
    File file=new File(selectedFile.substring(0,selectedFile.length() - 3) + ""String_Node_Str"");
    return file;
  }
 catch (  SecurityException e) {
    Logger.e(TAG,""String_Node_Str"",e);
    return null;
  }
}","public static File getLogFile() throws IOException {
  try {
    return new File(selectedFile.substring(0,selectedFile.length() - 3) + ""String_Node_Str"");
  }
 catch (  SecurityException e) {
    Logger.e(TAG,""String_Node_Str"",e);
    return null;
  }
}"
13518,"public static void restoreCartridge(OutputStream log){
  try {
    WUI.startProgressDialog();
    Engine.newInstance(cartridgeFile,log,wui,wLocationService).restore();
  }
 catch (  Throwable t) {
  }
}","private static void restoreCartridge(OutputStream log){
  try {
    WUI.startProgressDialog();
    Engine.newInstance(cartridgeFile,log,wui,wLocationService).restore();
  }
 catch (  Throwable t) {
  }
}"
13519,"public static void loadCartridge(OutputStream log){
  try {
    WUI.startProgressDialog();
    Engine.newInstance(cartridgeFile,log,wui,wLocationService).start();
  }
 catch (  Throwable t) {
  }
}","private static void loadCartridge(OutputStream log){
  try {
    WUI.startProgressDialog();
    Engine.newInstance(cartridgeFile,log,wui,wLocationService).start();
  }
 catch (  Throwable t) {
  }
}"
13520,"@Override public void run(){
  String provider=location.getProvider();
  if (provider.equals(LocationManager.GPS_PROVIDER)) {
    provider=getString(R.string.provider_gps);
  }
 else   if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
    provider=getString(R.string.provider_network);
  }
 else {
    provider=getString(R.string.provider_passive);
  }
  ((TextView)findViewById(R.id.text_view_provider)).setText(provider);
  ((TextView)findViewById(R.id.text_view_latitude)).setText(UtilsFormat.formatLatitude(location.getLatitude()));
  ((TextView)findViewById(R.id.text_view_longitude)).setText(UtilsFormat.formatLongitude(location.getLongitude()));
  ((TextView)findViewById(R.id.text_view_altitude)).setText(UtilsFormat.formatAltitude(location.getAltitude(),true));
  ((TextView)findViewById(R.id.text_view_accuracy)).setText(UtilsFormat.formatDistance(location.getAccuracy(),false));
  ((TextView)findViewById(R.id.text_view_speed)).setText(UtilsFormat.formatSpeed(location.getSpeed(),false));
  ((TextView)findViewById(R.id.text_view_declination)).setText(UtilsFormat.formatAngle(Orientation.getDeclination()));
  long lastFix=LocationState.getLastFixTime();
  if (lastFix > 0) {
    ((TextView)findViewById(R.id.text_view_time_gps)).setText(UtilsFormat.formatTime(lastFix));
  }
 else {
    ((TextView)findViewById(R.id.text_view_time_gps)).setText(""String_Node_Str"");
  }
}","@Override public void run(){
  String provider=location.getProvider();
switch (provider) {
case LocationManager.GPS_PROVIDER:
    provider=getString(R.string.provider_gps);
  break;
case LocationManager.NETWORK_PROVIDER:
provider=getString(R.string.provider_network);
break;
default :
provider=getString(R.string.provider_passive);
break;
}
((TextView)findViewById(R.id.text_view_provider)).setText(provider);
((TextView)findViewById(R.id.text_view_latitude)).setText(UtilsFormat.formatLatitude(location.getLatitude()));
((TextView)findViewById(R.id.text_view_longitude)).setText(UtilsFormat.formatLongitude(location.getLongitude()));
((TextView)findViewById(R.id.text_view_altitude)).setText(UtilsFormat.formatAltitude(location.getAltitude(),true));
((TextView)findViewById(R.id.text_view_accuracy)).setText(UtilsFormat.formatDistance(location.getAccuracy(),false));
((TextView)findViewById(R.id.text_view_speed)).setText(UtilsFormat.formatSpeed(location.getSpeed(),false));
((TextView)findViewById(R.id.text_view_declination)).setText(UtilsFormat.formatAngle(Orientation.getDeclination()));
long lastFix=LocationState.getLastFixTime();
if (lastFix > 0) {
((TextView)findViewById(R.id.text_view_time_gps)).setText(UtilsFormat.formatTime(lastFix));
}
 else {
((TextView)findViewById(R.id.text_view_time_gps)).setText(""String_Node_Str"");
}
}"
13521,"public void onLocationChanged(final Location location){
  runOnUiThread(new Runnable(){
    @Override public void run(){
      String provider=location.getProvider();
      if (provider.equals(LocationManager.GPS_PROVIDER)) {
        provider=getString(R.string.provider_gps);
      }
 else       if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
        provider=getString(R.string.provider_network);
      }
 else {
        provider=getString(R.string.provider_passive);
      }
      ((TextView)findViewById(R.id.text_view_provider)).setText(provider);
      ((TextView)findViewById(R.id.text_view_latitude)).setText(UtilsFormat.formatLatitude(location.getLatitude()));
      ((TextView)findViewById(R.id.text_view_longitude)).setText(UtilsFormat.formatLongitude(location.getLongitude()));
      ((TextView)findViewById(R.id.text_view_altitude)).setText(UtilsFormat.formatAltitude(location.getAltitude(),true));
      ((TextView)findViewById(R.id.text_view_accuracy)).setText(UtilsFormat.formatDistance(location.getAccuracy(),false));
      ((TextView)findViewById(R.id.text_view_speed)).setText(UtilsFormat.formatSpeed(location.getSpeed(),false));
      ((TextView)findViewById(R.id.text_view_declination)).setText(UtilsFormat.formatAngle(Orientation.getDeclination()));
      long lastFix=LocationState.getLastFixTime();
      if (lastFix > 0) {
        ((TextView)findViewById(R.id.text_view_time_gps)).setText(UtilsFormat.formatTime(lastFix));
      }
 else {
        ((TextView)findViewById(R.id.text_view_time_gps)).setText(""String_Node_Str"");
      }
    }
  }
);
}","public void onLocationChanged(final Location location){
  runOnUiThread(new Runnable(){
    @Override public void run(){
      String provider=location.getProvider();
switch (provider) {
case LocationManager.GPS_PROVIDER:
        provider=getString(R.string.provider_gps);
      break;
case LocationManager.NETWORK_PROVIDER:
    provider=getString(R.string.provider_network);
  break;
default :
provider=getString(R.string.provider_passive);
break;
}
((TextView)findViewById(R.id.text_view_provider)).setText(provider);
((TextView)findViewById(R.id.text_view_latitude)).setText(UtilsFormat.formatLatitude(location.getLatitude()));
((TextView)findViewById(R.id.text_view_longitude)).setText(UtilsFormat.formatLongitude(location.getLongitude()));
((TextView)findViewById(R.id.text_view_altitude)).setText(UtilsFormat.formatAltitude(location.getAltitude(),true));
((TextView)findViewById(R.id.text_view_accuracy)).setText(UtilsFormat.formatDistance(location.getAccuracy(),false));
((TextView)findViewById(R.id.text_view_speed)).setText(UtilsFormat.formatSpeed(location.getSpeed(),false));
((TextView)findViewById(R.id.text_view_declination)).setText(UtilsFormat.formatAngle(Orientation.getDeclination()));
long lastFix=LocationState.getLastFixTime();
if (lastFix > 0) {
((TextView)findViewById(R.id.text_view_time_gps)).setText(UtilsFormat.formatTime(lastFix));
}
 else {
((TextView)findViewById(R.id.text_view_time_gps)).setText(""String_Node_Str"");
}
}
}
);
}"
13522,"public void onResume(){
  super.onResume();
  try {
    ImageView ivImage=(ImageView)findViewById(R.id.layoutInputImageView01);
    TextView tvImageDesc=(TextView)findViewById(R.id.layoutInputTextView01);
    Media m=(Media)input.table.rawget(""String_Node_Str"");
    if (m != null) {
      tvImageDesc.setText(UtilsGUI.simpleHtml(m.altText));
      try {
        byte[] is=Engine.mediaFile(m);
        Bitmap i=BitmapFactory.decodeByteArray(is,0,is.length);
        MainActivity.setBitmapToImageView(i,ivImage);
      }
 catch (      Exception e) {
      }
    }
 else {
      ivImage.setImageBitmap(Images.IMAGE_EMPTY_B);
    }
    TextView tvQuestion=(TextView)findViewById(R.id.layoutInputTextView02);
    String text=(String)input.table.rawget(""String_Node_Str"");
    tvQuestion.setText(UtilsGUI.simpleHtml(text));
    final EditText editText=(EditText)findViewById(R.id.layoutInputEditText);
    editText.setVisibility(View.GONE);
    final Spinner spinner=(Spinner)findViewById(R.id.layoutInputSpinner);
    spinner.setVisibility(View.GONE);
    String type=(String)input.table.rawget(""String_Node_Str"");
    mode=-1;
    if (""String_Node_Str"".equals(type)) {
      editText.setText(""String_Node_Str"");
      editText.setVisibility(View.VISIBLE);
      mode=TEXT;
    }
 else     if (""String_Node_Str"".equals(type)) {
      LuaTable choices=(LuaTable)input.table.rawget(""String_Node_Str"");
      String[] data=new String[choices.len()];
      for (int i=0; i < choices.len(); i++) {
        data[i]=(String)choices.rawget((double)(i + 1));
        if (data[i] == null)         data[i]=""String_Node_Str"";
      }
      ArrayAdapter<String> adapter=new ArrayAdapter<String>(this,android.R.layout.simple_spinner_item,data);
      adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
      spinner.setAdapter(adapter);
      spinner.setVisibility(View.VISIBLE);
      mode=MULTI;
    }
    CustomDialog.setBottom(this,Locale.getString(R.string.answer),new CustomDialog.OnClickListener(){
      @Override public boolean onClick(      CustomDialog dialog,      View v,      int btn){
        if (mode == TEXT) {
          Engine.callEvent(input,""String_Node_Str"",editText.getText().toString());
        }
 else         if (mode == MULTI) {
          String item=String.valueOf(spinner.getSelectedItem());
          Engine.callEvent(input,""String_Node_Str"",item);
        }
 else {
          Engine.callEvent(input,""String_Node_Str"",null);
        }
        InputScreenActivity.this.finish();
        return true;
      }
    }
,null,null,null,null);
  }
 catch (  Exception e) {
    Logger.e(TAG,""String_Node_Str"",e);
  }
}","public void onResume(){
  super.onResume();
  try {
    ImageView ivImage=(ImageView)findViewById(R.id.layoutInputImageView01);
    TextView tvImageDesc=(TextView)findViewById(R.id.layoutInputTextView01);
    Media m=(Media)input.table.rawget(""String_Node_Str"");
    if (m != null) {
      tvImageDesc.setText(UtilsGUI.simpleHtml(m.altText));
      try {
        byte[] is=Engine.mediaFile(m);
        Bitmap i=BitmapFactory.decodeByteArray(is,0,is.length);
        MainActivity.setBitmapToImageView(i,ivImage);
      }
 catch (      Exception e) {
      }
    }
 else {
      ivImage.setImageBitmap(Images.IMAGE_EMPTY_B);
    }
    TextView tvQuestion=(TextView)findViewById(R.id.layoutInputTextView02);
    String text=(String)input.table.rawget(""String_Node_Str"");
    tvQuestion.setText(UtilsGUI.simpleHtml(text));
    final EditText editText=(EditText)findViewById(R.id.layoutInputEditText);
    editText.setVisibility(View.GONE);
    final Spinner spinner=(Spinner)findViewById(R.id.layoutInputSpinner);
    spinner.setVisibility(View.GONE);
    String type=(String)input.table.rawget(""String_Node_Str"");
    mode=-1;
    if (""String_Node_Str"".equals(type)) {
      editText.setText(""String_Node_Str"");
      editText.setVisibility(View.VISIBLE);
      mode=TEXT;
    }
 else     if (""String_Node_Str"".equals(type)) {
      LuaTable choices=(LuaTable)input.table.rawget(""String_Node_Str"");
      String[] data=new String[choices.len()];
      for (int i=0; i < choices.len(); i++) {
        data[i]=(String)choices.rawget((double)(i + 1));
        if (data[i] == null)         data[i]=""String_Node_Str"";
      }
      ArrayAdapter<String> adapter=new ArrayAdapter<>(this,android.R.layout.simple_spinner_item,data);
      adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
      spinner.setAdapter(adapter);
      spinner.setVisibility(View.VISIBLE);
      mode=MULTI;
    }
    CustomDialog.setBottom(this,Locale.getString(R.string.answer),new CustomDialog.OnClickListener(){
      @Override public boolean onClick(      CustomDialog dialog,      View v,      int btn){
        if (mode == TEXT) {
          Engine.callEvent(input,""String_Node_Str"",editText.getText().toString());
        }
 else         if (mode == MULTI) {
          String item=String.valueOf(spinner.getSelectedItem());
          Engine.callEvent(input,""String_Node_Str"",item);
        }
 else {
          Engine.callEvent(input,""String_Node_Str"",null);
        }
        InputScreenActivity.this.finish();
        return true;
      }
    }
,null,null,null,null);
  }
 catch (  Exception e) {
    Logger.e(TAG,""String_Node_Str"",e);
  }
}"
13523,"public static Vector<Object> getValidActions(Thing thing){
  Vector<Object> newActions=new Vector<Object>();
  for (int i=0; i < thing.actions.size(); i++)   newActions.add(thing.actions.get(i));
  for (int i=0; i < newActions.size(); i++) {
    Action a=(Action)newActions.elementAt(i);
    if (!a.isEnabled() || !a.getActor().visibleToPlayer()) {
      newActions.removeElementAt(i--);
    }
  }
  return newActions;
}","public static Vector<Object> getValidActions(Thing thing){
  Vector<Object> newActions=new Vector<>();
  for (int i=0; i < thing.actions.size(); i++)   newActions.add(thing.actions.get(i));
  for (int i=0; i < newActions.size(); i++) {
    Action a=(Action)newActions.elementAt(i);
    if (!a.isEnabled() || !a.getActor().visibleToPlayer()) {
      newActions.removeElementAt(i--);
    }
  }
  return newActions;
}"
13524,"private static void makeValidStuff(){
  LuaTable current=Engine.instance.cartridge.currentThings();
  validStuff=new Vector<Object>();
  Object key=null;
  while ((key=current.next(key)) != null)   validStuff.addElement(current.rawget(key));
  while ((key=Engine.instance.player.inventory.next(key)) != null)   validStuff.addElement(Engine.instance.player.inventory.rawget(key));
  for (int i=0; i < validStuff.size(); i++) {
    Thing t=(Thing)validStuff.elementAt(i);
    if (!t.isVisible() || !action.isTarget(t)) {
      validStuff.removeElementAt(i--);
    }
  }
}","private static void makeValidStuff(){
  LuaTable current=Engine.instance.cartridge.currentThings();
  validStuff=new Vector<>();
  Object key=null;
  while ((key=current.next(key)) != null)   validStuff.addElement(current.rawget(key));
  while ((key=Engine.instance.player.inventory.next(key)) != null)   validStuff.addElement(Engine.instance.player.inventory.rawget(key));
  for (int i=0; i < validStuff.size(); i++) {
    Thing t=(Thing)validStuff.elementAt(i);
    if (!t.isVisible() || !action.isTarget(t)) {
      validStuff.removeElementAt(i--);
    }
  }
}"
13525,"@Override protected Vector<Object> getValidStuff(){
  Vector<Object> newtasks=new Vector<Object>();
  for (int i=0; i < Engine.instance.cartridge.tasks.size(); i++) {
    Task t=(Task)Engine.instance.cartridge.tasks.get(i);
    if (t.isVisible())     newtasks.add(t);
  }
  return newtasks;
}","@Override protected Vector<Object> getValidStuff(){
  Vector<Object> newtasks=new Vector<>();
  for (int i=0; i < Engine.instance.cartridge.tasks.size(); i++) {
    Task t=(Task)Engine.instance.cartridge.tasks.get(i);
    if (t.isVisible())     newtasks.add(t);
  }
  return newtasks;
}"
13526,"public static void refreshCartridges(){
  Logger.w(TAG,""String_Node_Str"" + (MainActivity.selectedFile == null));
  if (MainActivity.selectedFile != null)   return;
  File[] files=FileSystem.getFiles(FileSystem.ROOT,""String_Node_Str"");
  cartridgeFiles=new Vector<CartridgeFile>();
  ArrayList<Waypoint> wpts=new ArrayList<Waypoint>();
  File actualFile=null;
  if (files != null) {
    for (    File file : files) {
      try {
        actualFile=file;
        CartridgeFile cart=CartridgeFile.read(new WSeekableFile(file),new WSaveFile(file));
        if (cart != null) {
          cart.filename=file.getAbsolutePath();
          Location loc=new Location(TAG);
          loc.setLatitude(cart.latitude);
          loc.setLongitude(cart.longitude);
          Waypoint waypoint=new Waypoint(cart.name,loc);
          cartridgeFiles.add(cart);
          wpts.add(waypoint);
        }
      }
 catch (      Exception e) {
        Logger.w(TAG,""String_Node_Str"" + actualFile + ""String_Node_Str""+ e.toString());
        ManagerNotify.toastShortMessage(Locale.getString(R.string.invalid_cartridge,actualFile.getName()));
      }
    }
  }
  if (wpts.size() > 0) {
  }
}","public static void refreshCartridges(){
  Logger.w(TAG,""String_Node_Str"" + (MainActivity.selectedFile == null));
  File[] files=FileSystem.getFiles(FileSystem.ROOT,""String_Node_Str"");
  cartridgeFiles=new Vector<CartridgeFile>();
  ArrayList<Waypoint> wpts=new ArrayList<Waypoint>();
  File actualFile=null;
  if (files != null) {
    for (    File file : files) {
      try {
        actualFile=file;
        CartridgeFile cart=CartridgeFile.read(new WSeekableFile(file),new WSaveFile(file));
        if (cart != null) {
          cart.filename=file.getAbsolutePath();
          Location loc=new Location(TAG);
          loc.setLatitude(cart.latitude);
          loc.setLongitude(cart.longitude);
          Waypoint waypoint=new Waypoint(cart.name,loc);
          cartridgeFiles.add(cart);
          wpts.add(waypoint);
        }
      }
 catch (      Exception e) {
        Logger.w(TAG,""String_Node_Str"" + actualFile + ""String_Node_Str""+ e.toString());
        ManagerNotify.toastShortMessage(Locale.getString(R.string.invalid_cartridge,actualFile.getName()));
      }
    }
  }
  if (wpts.size() > 0) {
  }
}"
13527,"@Override public void writeToParcel(Parcel p,int arg1){
  p.writeString(name);
  p.writeString(description);
  p.writeDouble(latitude);
  p.writeDouble(longitude);
  p.writeByte((byte)(target ? 1 : 0));
}","@Override public void writeToParcel(Parcel p,int arg1){
  p.writeString(name);
  p.writeString(description);
  p.writeDouble(latitude);
  p.writeDouble(longitude);
  p.writeByte((byte)(target ? 1 : 0));
  p.writeString(data);
}"
13528,"@Override public void onTap(final PointOverlay pointOverlay){
  if (pointOverlay.getPoint() == null)   return;
  new AlertDialog.Builder(MapsforgeActivity.this).setTitle(pointOverlay.getLabel()).setMessage(UtilsFormat.formatGeoPoint(pointOverlay.getGeoPoint()) + ""String_Node_Str"" + Html.fromHtml(pointOverlay.getDescription(),null,null)).setNegativeButton(getString(R.string.close),new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dialog.dismiss();
    }
  }
).show();
}","@Override public void onTap(final PointOverlay pointOverlay){
  if (pointOverlay.getPoint() == null)   return;
  AlertDialog.Builder builder=new AlertDialog.Builder(MapsforgeActivity.this).setTitle(pointOverlay.getLabel()).setMessage(UtilsFormat.formatGeoPoint(pointOverlay.getGeoPoint()) + ""String_Node_Str"" + Html.fromHtml(pointOverlay.getDescription(),null,null)).setNegativeButton(R.string.close,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dialog.dismiss();
    }
  }
);
  final String cguid=pointOverlay.getPoint().getData();
  if (cguid != null)   builder.setPositiveButton(R.string.start,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      Intent intent=new Intent(MapsforgeActivity.this,MainActivity.class);
      intent.putExtra(""String_Node_Str"",cguid);
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
      startActivity(intent);
      dialog.dismiss();
      MapsforgeActivity.this.finish();
    }
  }
);
  builder.show();
}"
13529,"public void addCartridges(Vector<CartridgeFile> cartridges){
  if (cartridges == null)   return;
  MapPointPack pack=new MapPointPack(false,R.drawable.marker_wherigo);
  for (  CartridgeFile cartridge : cartridges) {
    if (cartridge.latitude % 360.0 == 0 && cartridge.longitude % 360.0 == 0) {
      continue;
    }
    MapPoint pt=new MapPoint(cartridge.name,cartridge.description,cartridge.latitude,cartridge.longitude);
    try {
      byte[] iconData=cartridge.getFile(cartridge.iconId);
      Bitmap icon=BitmapFactory.decodeByteArray(iconData,0,iconData.length);
      MapPointPack iconPack=new MapPointPack(false,icon);
      iconPack.getPoints().add(pt);
      items.add(iconPack);
    }
 catch (    Exception e) {
      pack.getPoints().add(pt);
    }
  }
  items.add(pack);
}","public void addCartridges(Vector<CartridgeFile> cartridges){
  if (cartridges == null)   return;
  MapPointPack pack=new MapPointPack(false,R.drawable.marker_wherigo);
  for (  CartridgeFile cartridge : cartridges) {
    if (cartridge.latitude % 360.0 == 0 && cartridge.longitude % 360.0 == 0) {
      continue;
    }
    MapPoint pt=new MapPoint(cartridge.name,cartridge.description,cartridge.latitude,cartridge.longitude);
    if (MainActivity.cartridgeFile == null && Engine.instance == null)     pt.setData(new File(cartridge.filename).getName());
    try {
      byte[] iconData=cartridge.getFile(cartridge.iconId);
      Bitmap icon=BitmapFactory.decodeByteArray(iconData,0,iconData.length);
      MapPointPack iconPack=new MapPointPack(false,icon);
      iconPack.getPoints().add(pt);
      items.add(iconPack);
    }
 catch (    Exception e) {
      pack.getPoints().add(pt);
    }
  }
  items.add(pack);
}"
13530,"private boolean restoreInstance(Bundle bundle){
  if (bundle == null) {
    return false;
  }
  String saveFileName=getArguments().getString(SAVE_FILE);
  if (saveFileName == null) {
    return false;
  }
  saveFile=new File(saveFileName);
  return true;
}","private boolean restoreInstance(Bundle bundle){
  if (bundle == null) {
    return false;
  }
  String saveFileName=bundle.getString(SAVE_FILE);
  if (saveFileName == null) {
    return false;
  }
  saveFile=new File(saveFileName);
  return true;
}"
13531,"@Override public void onCreate(){
  super.onCreate();
  Log.d(TAG,""String_Node_Str"");
  Thread.setDefaultUncaughtExceptionHandler(new ExceptionHandler());
  PreferenceManager.setDefaultValues(this,R.xml.whereyougo_preferences,false);
  Preferences.init(this);
  Configuration config=getBaseContext().getResources().getConfiguration();
  String lang=PreferenceValues.getPrefString(R.string.pref_KEY_S_LANGUAGE,R.string.pref_DEFAULT_LANGUAGE);
  if (lang.equals(""String_Node_Str"")) {
    lang=this.getString(R.string.pref_language_id_cz);
    PreferenceValues.setPrefString(R.string.pref_KEY_S_LANGUAGE,lang);
  }
  if (!lang.equals(getString(R.string.pref_language_id_default)) && !config.locale.getLanguage().equals(lang)) {
    ArrayList<String> loc=StringToken.parse(lang,""String_Node_Str"");
    if (loc.size() == 1) {
      locale=new Locale(lang);
    }
 else {
      locale=new Locale(loc.get(0),loc.get(1));
    }
    Locale.setDefault(locale);
    config.locale=locale;
    getBaseContext().getResources().updateConfiguration(config,getBaseContext().getResources().getDisplayMetrics());
  }
  initCore();
}","@Override public void onCreate(){
  super.onCreate();
  Log.d(TAG,""String_Node_Str"");
  Thread.setDefaultUncaughtExceptionHandler(new ExceptionHandler());
  PreferenceManager.setDefaultValues(this,R.xml.whereyougo_preferences,false);
  Preferences.init(this);
  Configuration config=getBaseContext().getResources().getConfiguration();
  String lang=PreferenceValues.getPrefString(this,R.string.pref_KEY_S_LANGUAGE,R.string.pref_DEFAULT_LANGUAGE);
  if (lang.equals(""String_Node_Str"")) {
    lang=this.getString(R.string.pref_language_id_cz);
    PreferenceValues.setPrefString(R.string.pref_KEY_S_LANGUAGE,lang);
  }
  if (!lang.equals(getString(R.string.pref_language_id_default)) && !config.locale.getLanguage().equals(lang)) {
    ArrayList<String> loc=StringToken.parse(lang,""String_Node_Str"");
    if (loc.size() == 1) {
      locale=new Locale(lang);
    }
 else {
      locale=new Locale(loc.get(0),loc.get(1));
    }
    Locale.setDefault(locale);
    config.locale=locale;
    getBaseContext().getResources().updateConfiguration(config,getBaseContext().getResources().getDisplayMetrics());
  }
  initCore();
}"
13532,"public static Model LoadGlbFile(File file) throws IOException {
  DataInputStream stream=new DataInputStream(new FileInputStream(file));
  int magic=readUnsignedInt(stream);
  int version=readUnsignedInt(stream);
  int length=readUnsignedInt(stream);
  if (magic != 0x46546C67)   throw new IllegalArgumentException(""String_Node_Str"");
  if (version != 2)   throw new IllegalArgumentException(""String_Node_Str"");
  int chunkLength=readUnsignedInt(stream);
  int chunkType=readUnsignedInt(stream);
  byte[] data=new byte[chunkLength];
  if (stream.read(data,0,chunkLength) != chunkLength) {
    throw new IOException(""String_Node_Str"");
  }
  if (chunkType != JSON_CHUNK) {
    throw new IOException(""String_Node_Str"");
  }
  JsonParser parser=new JsonParser();
  JsonObject root=parser.parse(new String(data)).getAsJsonObject();
  chunkLength=readUnsignedInt(stream);
  chunkType=readUnsignedInt(stream);
  data=new byte[chunkLength];
  if (stream.read(data,0,chunkLength) != chunkLength) {
    throw new IOException(""String_Node_Str"");
  }
  if (chunkType != BIN_CHUNK) {
    throw new IOException(""String_Node_Str"");
  }
  ByteBuffer binData=ByteBuffer.wrap(data);
  if (!root.has(""String_Node_Str"")) {
    throw new GltfException(""String_Node_Str"");
  }
  if (root.has(""String_Node_Str"") && root.get(""String_Node_Str"").getAsInt() >= root.get(""String_Node_Str"").getAsJsonArray().size()) {
    throw new GltfException(""String_Node_Str"");
  }
  JsonObject scene=root.getAsJsonArray(""String_Node_Str"").get(root.has(""String_Node_Str"") ? root.get(""String_Node_Str"").getAsInt() : 0).getAsJsonObject();
  for (  JsonElement element : root.get(""String_Node_Str"").getAsJsonArray()) {
    BufferView bufferView=gson.fromJson(element,BufferView.class);
    bufferView.setData((ByteBuffer)binData.slice().position(bufferView.byteOffset).limit(bufferView.byteLength));
    bufferViews.add(bufferView);
  }
  for (  JsonElement element : root.get(""String_Node_Str"").getAsJsonArray()) {
    accessors.add(gson.fromJson(element,Accessor.class));
  }
  JsonArray meshJsonArray=root.get(""String_Node_Str"").getAsJsonArray();
  for (int i=0; i < meshJsonArray.size(); i++) {
    ArrayList<Geometry> geometries=new ArrayList<>();
    for (    JsonElement primitive : meshJsonArray.get(i).getAsJsonObject().get(""String_Node_Str"").getAsJsonArray()) {
      geometries.add(LoadPrimitive(gson.fromJson(primitive,MeshPrimitive.class)));
    }
    meshCache.put(i,new Mesh(geometries));
  }
  int[] sceneNodes=gson.fromJson(scene.get(""String_Node_Str""),int[].class);
  JsonArray nodeJsonArray=root.get(""String_Node_Str"").getAsJsonArray();
  ArrayList<Node> rootNodes=new ArrayList<>();
  for (  int index : sceneNodes) {
    rootNodes.add(LoadNode(nodeJsonArray,index));
  }
  return new Model(new ArrayList<>(nodeCache.values()),rootNodes,null);
}","public static Model LoadGlbFile(File file) throws IOException {
  DataInputStream stream=new DataInputStream(new FileInputStream(file));
  int magic=readUnsignedInt(stream);
  int version=readUnsignedInt(stream);
  int length=readUnsignedInt(stream);
  if (magic != 0x46546C67)   throw new IllegalArgumentException(""String_Node_Str"");
  if (version != 2)   throw new IllegalArgumentException(""String_Node_Str"");
  int chunkLength=readUnsignedInt(stream);
  int chunkType=readUnsignedInt(stream);
  byte[] data=new byte[chunkLength];
  if (stream.read(data,0,chunkLength) != chunkLength) {
    throw new IOException(""String_Node_Str"");
  }
  if (chunkType != JSON_CHUNK) {
    throw new IOException(""String_Node_Str"");
  }
  JsonParser parser=new JsonParser();
  JsonObject root=parser.parse(new String(data)).getAsJsonObject();
  chunkLength=readUnsignedInt(stream);
  chunkType=readUnsignedInt(stream);
  data=new byte[chunkLength];
  if (stream.read(data,0,chunkLength) != chunkLength) {
    throw new IOException(""String_Node_Str"");
  }
  if (chunkType != BIN_CHUNK) {
    throw new IOException(""String_Node_Str"");
  }
  ByteBuffer binData=BufferUtils.createByteBuffer(data.length);
  binData.put(data);
  binData.rewind();
  if (!root.has(""String_Node_Str"")) {
    throw new GltfException(""String_Node_Str"");
  }
  if (root.has(""String_Node_Str"") && root.get(""String_Node_Str"").getAsInt() >= root.get(""String_Node_Str"").getAsJsonArray().size()) {
    throw new GltfException(""String_Node_Str"");
  }
  JsonObject scene=root.getAsJsonArray(""String_Node_Str"").get(root.has(""String_Node_Str"") ? root.get(""String_Node_Str"").getAsInt() : 0).getAsJsonObject();
  for (  JsonElement element : root.get(""String_Node_Str"").getAsJsonArray()) {
    BufferView bufferView=gson.fromJson(element,BufferView.class);
    bufferView.setData((ByteBuffer)binData.slice().position(bufferView.byteOffset).limit(bufferView.byteLength));
    bufferViews.add(bufferView);
  }
  for (  JsonElement element : root.get(""String_Node_Str"").getAsJsonArray()) {
    accessors.add(gson.fromJson(element,Accessor.class));
  }
  JsonArray meshJsonArray=root.get(""String_Node_Str"").getAsJsonArray();
  for (int i=0; i < meshJsonArray.size(); i++) {
    ArrayList<Geometry> geometries=new ArrayList<>();
    for (    JsonElement primitive : meshJsonArray.get(i).getAsJsonObject().get(""String_Node_Str"").getAsJsonArray()) {
      geometries.add(LoadPrimitive(gson.fromJson(primitive,MeshPrimitive.class)));
    }
    meshCache.put(i,new Mesh(geometries));
  }
  int[] sceneNodes=gson.fromJson(scene.get(""String_Node_Str""),int[].class);
  JsonArray nodeJsonArray=root.get(""String_Node_Str"").getAsJsonArray();
  ArrayList<Node> rootNodes=new ArrayList<>();
  for (  int index : sceneNodes) {
    rootNodes.add(LoadNode(nodeJsonArray,index));
  }
  return new Model(new ArrayList<>(nodeCache.values()),rootNodes,null);
}"
13533,"public void render(){
  if (!isStatic) {
    matrix.setIdentity();
    matrix.translate(translation);
    Matrix4f.mul(matrix,rotate(rotation),matrix);
    matrix.scale(scale);
    matrix.store(fb);
  }
  GlStateManager.pushMatrix();
  GlStateManager.multMatrix(fb);
  if (mesh != null) {
    mesh.render();
  }
  for (  Node node : children) {
    node.render();
  }
  GlStateManager.popMatrix();
}","public void render(){
  if (!isStatic) {
    matrix.setIdentity();
    matrix.translate(translation);
    Matrix4f.mul(matrix,rotate(rotation),matrix);
    matrix.scale(scale);
    matrix.store(fb);
    fb.rewind();
  }
  GlStateManager.pushMatrix();
  GlStateManager.multMatrix(fb);
  if (mesh != null) {
    mesh.render();
  }
  for (  Node node : children) {
    node.render();
  }
  GlStateManager.popMatrix();
}"
13534,"/** 
 * Renders the entire queue of parts
 */
public void doRender(){
  GL11.glGetFloat(GL11.GL_MODELVIEW_MATRIX,modelViewMatrixWorld);
  shader.use();
  for (  HashMap.Entry<OutfitPart,FloatBuffer> entry : renders.entrySet()) {
    Model model=PartRegistry.getModel(entry.getKey().basePart);
    GL11.glLoadMatrix(entry.getValue());
    if (model != null) {
      model.render();
    }
  }
  renders.clear();
  GL11.glLoadMatrix(modelViewMatrixWorld);
  OpenGlHelper.glUseProgram(0);
  checkError();
}","/** 
 * Renders the entire queue of parts
 */
public void doRender(){
  GlStateManager.getFloat(GL11.GL_MODELVIEW_MATRIX,modelViewMatrixWorld);
  shader.use();
  for (  HashMap.Entry<OutfitPart,FloatBuffer> entry : renders.entrySet()) {
    Part part=entry.getKey().getPart();
    if (part == null)     continue;
    Model model=part.getModel();
    if (model == null)     continue;
    GL11.glLoadMatrix(entry.getValue());
    model.render();
  }
  renders.clear();
  GL11.glLoadMatrix(modelViewMatrixWorld);
  OpenGlHelper.glUseProgram(0);
  checkError();
}"
13535,"private void renderPart(int x,int y,int z,int scale,OutfitPart part){
  Model model=PartRegistry.getModel(part.basePart);
  GlStateManager.pushMatrix();
  GlStateManager.translate(x,y,z);
  GlStateManager.scale(-scale,scale,1F);
  RenderHelper.enableStandardItemLighting();
  Minecraft.getMinecraft().getRenderManager().playerViewY=180.0F;
  if (model != null) {
    model.render();
  }
 else {
  }
  RenderHelper.disableStandardItemLighting();
  OpenGlHelper.setActiveTexture(OpenGlHelper.lightmapTexUnit);
  OpenGlHelper.setActiveTexture(OpenGlHelper.defaultTexUnit);
  GlStateManager.popMatrix();
}","private void renderPart(int x,int y,int z,int scale,OutfitPart part){
  Part basePart=part.getPart();
  if (basePart == null)   return;
  Model model=basePart.getModel();
  GlStateManager.pushMatrix();
  GlStateManager.translate(x,y,z);
  GlStateManager.scale(-scale,scale,1F);
  RenderHelper.enableStandardItemLighting();
  Minecraft.getMinecraft().getRenderManager().playerViewY=180.0F;
  if (model != null) {
    model.render();
  }
 else {
  }
  RenderHelper.disableStandardItemLighting();
  OpenGlHelper.setActiveTexture(OpenGlHelper.lightmapTexUnit);
  OpenGlHelper.setActiveTexture(OpenGlHelper.defaultTexUnit);
  GlStateManager.popMatrix();
}"
13536,"public Shader(String vertShader,String fragShader){
  Minecraft mc=Minecraft.getMinecraft();
  ResourceLocation vertRes=new ResourceLocation(Tails.MOD_ID,""String_Node_Str"" + vertShader + ""String_Node_Str"");
  ResourceLocation fragRes=new ResourceLocation(Tails.MOD_ID,""String_Node_Str"" + fragShader + ""String_Node_Str"");
  ByteBuffer vertSrc, fragSrc;
  try (InputStream is=mc.getResourceManager().getResource(vertRes).getInputStream()){
    byte[] bytes=IOUtils.toByteArray(is);
    vertSrc=ByteBuffer.wrap(bytes);
  }
 catch (  IOException e) {
    Tails.logger.error(""String_Node_Str"" + vertShader,e);
    return;
  }
  try (InputStream is=mc.getResourceManager().getResource(fragRes).getInputStream()){
    byte[] bytes=IOUtils.toByteArray(is);
    fragSrc=ByteBuffer.wrap(bytes);
  }
 catch (  IOException e) {
    Tails.logger.error(""String_Node_Str"" + vertShader,e);
    return;
  }
  int vert, frag;
  vert=GL20.glCreateShader(GL20.GL_VERTEX_SHADER);
  GL20.glShaderSource(vert,vertSrc);
  GL20.glCompileShader(vert);
  checkShaderCompile(vert);
  frag=GL20.glCreateShader(GL20.GL_FRAGMENT_SHADER);
  GL20.glShaderSource(frag,fragSrc);
  GL20.glCompileShader(frag);
  checkShaderCompile(frag);
  program=GL20.glCreateProgram();
  GL20.glAttachShader(program,vert);
  GL20.glAttachShader(program,frag);
  GL20.glLinkProgram(program);
  GL20.glDeleteShader(vert);
  GL20.glDeleteShader(frag);
}","public Shader(String vertShader,String fragShader){
  Minecraft mc=Minecraft.getMinecraft();
  ResourceLocation vertRes=new ResourceLocation(Tails.MOD_ID,""String_Node_Str"" + vertShader + ""String_Node_Str"");
  ResourceLocation fragRes=new ResourceLocation(Tails.MOD_ID,""String_Node_Str"" + fragShader + ""String_Node_Str"");
  uniforms=new HashMap<>();
  ByteBuffer vertSrc, fragSrc;
  try (InputStream is=mc.getResourceManager().getResource(vertRes).getInputStream()){
    byte[] bytes=IOUtils.toByteArray(is);
    vertSrc=ByteBuffer.allocateDirect(bytes.length);
    vertSrc.put(bytes);
  }
 catch (  IOException e) {
    Tails.logger.error(""String_Node_Str"" + vertShader,e);
    return;
  }
  try (InputStream is=mc.getResourceManager().getResource(fragRes).getInputStream()){
    byte[] bytes=IOUtils.toByteArray(is);
    fragSrc=ByteBuffer.allocateDirect(bytes.length);
    fragSrc.put(bytes);
  }
 catch (  IOException e) {
    Tails.logger.error(""String_Node_Str"" + vertShader,e);
    return;
  }
  int vert, frag;
  vert=GL20.glCreateShader(GL20.GL_VERTEX_SHADER);
  GL20.glShaderSource(vert,vertSrc);
  GL20.glCompileShader(vert);
  checkShaderCompile(vert);
  frag=GL20.glCreateShader(GL20.GL_FRAGMENT_SHADER);
  GL20.glShaderSource(frag,fragSrc);
  GL20.glCompileShader(frag);
  checkShaderCompile(frag);
  program=GL20.glCreateProgram();
  GL20.glAttachShader(program,vert);
  GL20.glAttachShader(program,frag);
  GL20.glLinkProgram(program);
  GL20.glDeleteShader(vert);
  GL20.glDeleteShader(frag);
}"
13537,"@Override public void doRenderLayer(@Nonnull AbstractClientPlayer entity,float limbSwing,float limbSwingAmount,float partialTicks,float ageInTicks,float netHeadYaw,float headPitch,float scale){
  if (entity.isInvisible())   return;
  UUID uuid=EntityPlayer.getUUID(entity.getGameProfile());
  if (Tails.proxy.hasPartsData(uuid)) {
    PartsData partsData=Tails.proxy.getPartsData(uuid);
    if (partsData.hasPartInfo(partType)) {
      PartInfo tailInfo=partsData.getPartInfo(partType);
      GlStateManager.pushMatrix();
      modelRenderer.postRender(0.0625F);
      if (partType == PartsData.PartType.EARS || partType == PartsData.PartType.MUZZLE) {
        if (entity.isSneaking()) {
          GlStateManager.translate(0f,0.2F,0f);
        }
        if (mpmCompat) {
          GlStateManager.rotate(netHeadYaw,0f,1f,0f);
          GlStateManager.rotate(headPitch,1f,0f,0f);
        }
 else {
          GlStateManager.rotate(headPitch * 0.017453292F,1f,0f,0f);
          GlStateManager.rotate(netHeadYaw * 0.017453292F,0f,1f,0f);
        }
      }
      PartRegistry.getRenderPart(tailInfo.partType,tailInfo.typeid).render(entity,tailInfo,0,0,0,partialTicks);
      GlStateManager.popMatrix();
    }
  }
}","@Override public void doRenderLayer(@Nonnull AbstractClientPlayer entity,float limbSwing,float limbSwingAmount,float partialTicks,float ageInTicks,float netHeadYaw,float headPitch,float scale){
  if (entity.isInvisible())   return;
  UUID uuid=EntityPlayer.getUUID(entity.getGameProfile());
  if (Tails.proxy.hasPartsData(uuid)) {
    PartsData partsData=Tails.proxy.getPartsData(uuid);
    if (partsData.hasPartInfo(partType)) {
      PartInfo tailInfo=partsData.getPartInfo(partType);
      GlStateManager.pushMatrix();
      if (partType == PartsData.PartType.EARS || partType == PartsData.PartType.MUZZLE) {
        if (entity.isSneaking()) {
          GlStateManager.translate(0f,0.2F,0f);
        }
        if (mpmCompat) {
          GlStateManager.rotate(netHeadYaw,0f,1f,0f);
          GlStateManager.rotate(headPitch,1f,0f,0f);
        }
 else {
          GlStateManager.rotate(headPitch * 0.017453292F,1f,0f,0f);
          GlStateManager.rotate(netHeadYaw * 0.017453292F,0f,1f,0f);
        }
      }
      modelRenderer.postRender(0.0625F);
      PartRegistry.getRenderPart(tailInfo.partType,tailInfo.typeid).render(entity,tailInfo,0,0,0,partialTicks);
      GlStateManager.popMatrix();
    }
  }
}"
13538,"@Override protected void actionPerformed(GuiButton button){
  Outfit outfit=parent.getOutfit();
  if (button.id == 0) {
    boolean libraryMode=button.displayString.equals(I18n.format(""String_Node_Str""));
    parent.partsPanel.enabled=!libraryMode;
    parent.tintPanel.enabled=!libraryMode;
    parent.libraryInfoPanel.enabled=libraryMode;
    parent.libraryPanel.enabled=libraryMode;
    parent.libraryImportPanel.enabled=libraryMode;
    parent.partsPanel.selectDefaultListEntry();
    parent.libraryPanel.initList();
    parent.libraryInfoPanel.setEntry(null);
    parent.clearCurrTintEdit();
    parent.refreshTintPane();
    if (!libraryMode) {
      Tails.setLocalOutfit(outfit);
    }
    parent.setOutfit(Tails.localOutfit);
    button.displayString=(libraryMode ? I18n.format(""String_Node_Str"") : I18n.format(""String_Node_Str""));
  }
 else   if (button.id == 1) {
    parent.partsPanel.selectDefaultListEntry();
    parent.libraryPanel.initList();
    parent.libraryInfoPanel.setEntry(null);
    parent.clearCurrTintEdit();
    parent.refreshTintPane();
    parent.setOutfitPart(null);
  }
 else   if (button.id == 2) {
    Tails.setLocalOutfit(outfit);
    Tails.proxy.setActiveOutfit(mc.player.getPersistentID(),outfit);
    Tails.networkWrapper.sendToServer(new PlayerDataMessage(mc.getSession().getProfile().getId(),outfit,false));
    ToastManager.INSTANCE.createCenteredToast(parent.width / 2,parent.height - 40,100,TextFormatting.GREEN + ""String_Node_Str"");
    this.mc.displayGuiScreen(null);
  }
}","@Override protected void actionPerformed(GuiButton button){
  Outfit outfit=parent.getOutfit();
  if (button.id == 0) {
    boolean libraryMode=button.displayString.equals(I18n.format(""String_Node_Str""));
    parent.partsPanel.enabled=!libraryMode;
    parent.tintPanel.enabled=!libraryMode;
    parent.libraryInfoPanel.enabled=libraryMode;
    parent.libraryPanel.enabled=libraryMode;
    parent.libraryImportPanel.enabled=libraryMode;
    parent.partsPanel.selectDefaultListEntry();
    parent.libraryPanel.initList();
    parent.libraryInfoPanel.setEntry(null);
    parent.clearCurrTintEdit();
    parent.refreshTintPane();
    if (!libraryMode) {
      Tails.setLocalOutfit(outfit);
    }
    parent.setOutfit(Tails.localOutfit);
    button.displayString=(libraryMode ? I18n.format(""String_Node_Str"") : I18n.format(""String_Node_Str""));
  }
 else   if (button.id == 1) {
    parent.partsPanel.selectDefaultListEntry();
    parent.libraryPanel.initList();
    parent.libraryInfoPanel.setEntry(null);
    parent.clearCurrTintEdit();
    parent.refreshTintPane();
    parent.setActiveOutfitPart(null);
  }
 else   if (button.id == 2) {
    Tails.setLocalOutfit(outfit);
    Tails.proxy.setActiveOutfit(mc.player.getPersistentID(),outfit);
    Tails.networkWrapper.sendToServer(new PlayerDataMessage(mc.getSession().getProfile().getId(),outfit,false));
    ToastManager.INSTANCE.createCenteredToast(parent.width / 2,parent.height - 40,100,TextFormatting.GREEN + ""String_Node_Str"");
    this.mc.displayGuiScreen(null);
  }
}"
13539,"void addOutfitPart(OutfitPart outfitPart){
  outfit.parts.add(outfitPart);
  setOutfitPart(outfitPart);
}","/** 
 * Adds a new OutfitPart to the Outfit and sets it to the current edited one
 * @param outfitPart
 */
void addOutfitPart(OutfitPart outfitPart){
  outfit.parts.add(outfitPart);
  setActiveOutfitPart(outfitPart);
}"
13540,"void refreshTintPane(){
  hexText.setTextColor(currTintColour);
  Color c=new Color(currTintColour);
  rgbSliders[0].setValue(c.getRed() / 255F);
  rgbSliders[1].setValue(c.getGreen() / 255F);
  rgbSliders[2].setValue(c.getBlue() / 255F);
  float[] hsbvals=Color.RGBtoHSB(c.getRed(),c.getGreen(),c.getBlue(),null);
  hsbSliders[0].setValue(hsbvals[0]);
  hsbSliders[1].setValue(hsbvals[1]);
  hsbSliders[2].setValue(hsbvals[2]);
  hsbSliders[1].setHue((float)hsbSliders[0].getValue());
  hsbSliders[1].setBrightness((float)hsbSliders[2].getValue());
  if (this.currTintEdit > 0) {
    rgbSliders[0].visible=rgbSliders[1].visible=rgbSliders[2].visible=true;
    hsbSliders[0].visible=hsbSliders[1].visible=hsbSliders[2].visible=true;
    tintReset.visible=true;
    colourPicker.visible=true;
  }
 else {
    rgbSliders[0].visible=rgbSliders[1].visible=rgbSliders[2].visible=false;
    hsbSliders[0].visible=hsbSliders[1].visible=hsbSliders[2].visible=false;
    tintReset.visible=false;
    colourPicker.visible=false;
  }
  tintReset.enabled=true;
  if (currTintEdit > 0)   parent.getCurrentOutfitPart().tints[currTintEdit - 1]=currTintColour | 0xFF << 24;
  parent.setOutfitPart(parent.getCurrentOutfitPart());
}","void refreshTintPane(){
  hexText.setTextColor(currTintColour);
  Color c=new Color(currTintColour);
  rgbSliders[0].setValue(c.getRed() / 255F);
  rgbSliders[1].setValue(c.getGreen() / 255F);
  rgbSliders[2].setValue(c.getBlue() / 255F);
  float[] hsbvals=Color.RGBtoHSB(c.getRed(),c.getGreen(),c.getBlue(),null);
  hsbSliders[0].setValue(hsbvals[0]);
  hsbSliders[1].setValue(hsbvals[1]);
  hsbSliders[2].setValue(hsbvals[2]);
  hsbSliders[1].setHue((float)hsbSliders[0].getValue());
  hsbSliders[1].setBrightness((float)hsbSliders[2].getValue());
  if (this.currTintEdit > 0) {
    rgbSliders[0].visible=rgbSliders[1].visible=rgbSliders[2].visible=true;
    hsbSliders[0].visible=hsbSliders[1].visible=hsbSliders[2].visible=true;
    tintReset.visible=true;
    colourPicker.visible=true;
  }
 else {
    rgbSliders[0].visible=rgbSliders[1].visible=rgbSliders[2].visible=false;
    hsbSliders[0].visible=hsbSliders[1].visible=hsbSliders[2].visible=false;
    tintReset.visible=false;
    colourPicker.visible=false;
  }
  tintReset.enabled=true;
  if (currTintEdit > 0)   parent.getCurrentOutfitPart().tints[currTintEdit - 1]=currTintColour | 0xFF << 24;
  parent.setActiveOutfitPart(parent.getCurrentOutfitPart());
}"
13541,"public static ResourceLocation generateTexture(OutfitPart part){
  String texturePath=""String_Node_Str"" + part.basePart + ""String_Node_Str"";
  ResourceLocation texture=new ResourceLocation(""String_Node_Str"" + part.basePart + ""String_Node_Str""+ part.tints[0]+ ""String_Node_Str""+ part.tints[1]+ ""String_Node_Str""+ part.tints[2]);
  Minecraft.getMinecraft().getTextureManager().loadTexture(texture,new TripleTintTexture(""String_Node_Str"",texturePath,part.tints[0],part.tints[1],part.tints[2]));
  return texture;
}","public static ResourceLocation generateTexture(OutfitPart part){
  String texturePath=""String_Node_Str"" + part.basePart + ""String_Node_Str"";
  ResourceLocation texture=new ResourceLocation(Tails.MOD_ID,""String_Node_Str"" + part.basePart + ""String_Node_Str""+ part.tints[0]+ ""String_Node_Str""+ part.tints[1]+ ""String_Node_Str""+ part.tints[2]+ ""String_Node_Str""+ UUID.randomUUID());
  Minecraft.getMinecraft().getTextureManager().loadTexture(texture,new TripleTintTexture(Tails.MOD_ID,texturePath,part.tints[0],part.tints[1],part.tints[2]));
  return texture;
}"
13542,"@Override public void loadTexture(IResourceManager p_110551_1_) throws IOException {
  this.deleteGlTexture();
  BufferedImage texture;
  try {
    if (texturename != null) {
      InputStream inputstream=p_110551_1_.getResource(new ResourceLocation(namespace,texturename)).getInputStream();
      texture=ImageIO.read(inputstream);
      int w=texture.getWidth();
      int h=texture.getHeight();
      int length=w * h;
      int[] pixeldata=new int[w * h];
      texture.getRGB(0,0,w,h,pixeldata,0,w);
      int c, r, g, b, a;
      for (int i=0; i < length; i++) {
        c=pixeldata[i];
        a=alpha(c);
        r=red(c);
        g=green(c);
        b=blue(c);
        pixeldata[i]=colourise(r,this.tint1,g,this.tint2,b,this.tint3,a);
      }
      texture.setRGB(0,0,w,h,pixeldata,0,w);
      TextureUtil.uploadTextureImage(this.getGlTextureId(),texture);
    }
  }
 catch (  IOException ioexception) {
    LogManager.getLogger().error(""String_Node_Str"",ioexception);
  }
}","@Override public void loadTexture(IResourceManager resourceManager) throws IOException {
  this.deleteGlTexture();
  BufferedImage texture;
  try {
    InputStream inputstream=resourceManager.getResource(new ResourceLocation(namespace,texturename)).getInputStream();
    texture=ImageIO.read(inputstream);
    int w=texture.getWidth();
    int h=texture.getHeight();
    int length=w * h;
    int[] pixeldata=new int[w * h];
    texture.getRGB(0,0,w,h,pixeldata,0,w);
    int c, r, g, b, a;
    for (int i=0; i < length; i++) {
      c=pixeldata[i];
      a=alpha(c);
      r=red(c);
      g=green(c);
      b=blue(c);
      pixeldata[i]=colourise(r,this.tint1,g,this.tint2,b,this.tint3,a);
    }
    texture.setRGB(0,0,w,h,pixeldata,0,w);
    TextureUtil.uploadTextureImage(getGlTextureId(),texture);
  }
 catch (  IOException ioexception) {
    Tails.logger.error(""String_Node_Str"",ioexception);
  }
}"
13543,"@NetworkCheckHandler public boolean checkRemoteVersions(Map<String,String> versions,Side side){
  if (versions.containsKey(MOD_ID)) {
    String clientVer=Loader.instance().getReversedModObjectList().get(this).getVersion();
    if (VersionParser.parseRange(""String_Node_Str"" + clientVer + ""String_Node_Str"").containsVersion(new DefaultArtifactVersion(versions.get(MOD_ID)))) {
      logger.warn(String.format(""String_Node_Str"",side.toString(),clientVer,versions.get(MOD_ID)));
    }
 else {
      logger.debug(String.format(""String_Node_Str"",side.toString(),clientVer,versions.get(MOD_ID)));
      hasRemote=true;
    }
  }
  return true;
}","@NetworkCheckHandler public boolean checkRemoteVersions(Map<String,String> versions,Side side){
  if (versions.containsKey(MOD_ID)) {
    String clientVer=Loader.instance().getReversedModObjectList().get(this).getVersion();
    if (!VersionParser.parseRange(""String_Node_Str"" + clientVer + ""String_Node_Str"").containsVersion(new DefaultArtifactVersion(versions.get(MOD_ID)))) {
      logger.warn(String.format(""String_Node_Str"",clientVer,side.toString(),versions.get(MOD_ID)));
    }
 else {
      logger.debug(String.format(""String_Node_Str"",clientVer,side.toString(),versions.get(MOD_ID)));
      hasRemote=true;
    }
  }
  return true;
}"
13544,"public void setPartsInfo(PartInfo newPartInfo){
  editingPartInfo.setTexture(null);
  editingPartInfo=newPartInfo;
  if (editingPartInfo.hasPart)   editingPartInfo.setTexture(TextureHelper.generateTexture(editingPartInfo));
  partsData.setPartInfo(partType,editingPartInfo);
  setPartsData(partsData);
}","public void setPartsInfo(PartInfo newPartInfo){
  editingPartInfo=newPartInfo;
  if (editingPartInfo.hasPart)   editingPartInfo.setTexture(TextureHelper.generateTexture(editingPartInfo));
  partsData.setPartInfo(partType,editingPartInfo);
  setPartsData(partsData);
}"
13545,"@Override public void setRotationAngles(float par1,float par2,float par3,float par4,float subtype,float partialTicks,Entity entity){
  double xAngleOffset=0;
  double yAngleMultiplier=1;
  if (!entity.isRiding()) {
    if (entity instanceof EntityPlayer) {
      double[] angles=getMotionAngles((EntityPlayer)entity,partialTicks);
      xAngleOffset=MathHelper.clamp_double(angles[0] / 5F,-1D,0.45D);
      yAngleMultiplier=(1 - (xAngleOffset * 2F));
    }
  }
 else {
    xAngleOffset=Math.toRadians(12F);
    yAngleMultiplier=0.25F;
  }
  float timestep=this.getAnimationTime(4000D,entity);
  setRotationRadians(tailBase,Math.toRadians(-40F) + xAngleOffset * 2F,((float)Math.cos(timestep - 1) / 5F) * yAngleMultiplier,0F);
  setRotationRadians(tail1,Math.toRadians(-8F) + xAngleOffset * 2F,((float)Math.cos(timestep - 2) / 5F) * yAngleMultiplier,0F);
  setRotationRadians(tail2,Math.toRadians(10F) - xAngleOffset / 4F,((float)Math.cos(timestep - 3) / 5F) * yAngleMultiplier,0F);
  setRotationRadians(tail3,Math.toRadians(20F) - xAngleOffset,((float)Math.cos(timestep - 4) / 5F) * yAngleMultiplier,0F);
  if (subtype == 1) {
    setRotationRadians(tailSubBase,Math.toRadians(-40F) + xAngleOffset * 2F,((float)Math.cos(timestep - 1) / 5F) * yAngleMultiplier,0F);
    setRotationRadians(tailSub1,Math.toRadians(-8F) + xAngleOffset * 2F,((float)Math.cos(timestep - 2) / 5F) * yAngleMultiplier,0F);
    setRotationRadians(tailSub2,Math.toRadians(10F) - xAngleOffset / 4F,((float)Math.cos(timestep - 3) / 5F) * yAngleMultiplier,0F);
    setRotationRadians(tailSub3,Math.toRadians(20F) - xAngleOffset,((float)Math.cos(timestep - 4) / 5F) * yAngleMultiplier,0F);
  }
}","@Override public void setRotationAngles(float par1,float par2,float par3,float par4,float subtype,float partialTicks,Entity entity){
  double xAngleOffset=0;
  double yAngleMultiplier=1;
  if (!entity.isRiding()) {
    if (entity instanceof EntityPlayer) {
      double[] angles=getMotionAngles((EntityPlayer)entity,partialTicks);
      xAngleOffset=MathHelper.clamp_double(angles[0] / 5F,-1D,0.45D);
      yAngleMultiplier=(1 - (xAngleOffset * 2F));
    }
  }
 else {
    xAngleOffset=Math.toRadians(12F);
    yAngleMultiplier=0.25F;
  }
  float timestep=getAnimationTime(4000D,entity);
  setRotationRadians(tailBase,Math.toRadians(-40F) + xAngleOffset * 2F,((float)Math.cos(timestep - 1) / 5F) * yAngleMultiplier,0F);
  setRotationRadians(tail1,Math.toRadians(-8F) + xAngleOffset * 2F,((float)Math.cos(timestep - 2) / 5F) * yAngleMultiplier,0F);
  setRotationRadians(tail2,Math.toRadians(10F) - xAngleOffset / 4F,((float)Math.cos(timestep - 3) / 5F) * yAngleMultiplier,0F);
  setRotationRadians(tail3,Math.toRadians(20F) - xAngleOffset,((float)Math.cos(timestep - 4) / 5F) * yAngleMultiplier,0F);
  if (subtype == 1) {
    setRotationRadians(tailSubBase,Math.toRadians(-40F) + xAngleOffset * 2F,((float)Math.cos(timestep - 1) / 5F) * yAngleMultiplier,0F);
    setRotationRadians(tailSub1,Math.toRadians(-8F) + xAngleOffset * 2F,((float)Math.cos(timestep - 2) / 5F) * yAngleMultiplier,0F);
    setRotationRadians(tailSub2,Math.toRadians(10F) - xAngleOffset / 4F,((float)Math.cos(timestep - 3) / 5F) * yAngleMultiplier,0F);
    setRotationRadians(tailSub3,Math.toRadians(20F) - xAngleOffset,((float)Math.cos(timestep - 4) / 5F) * yAngleMultiplier,0F);
  }
}"
13546,"@Override public void render(EntityLivingBase theEntity,int subtype,float partialTicks){
  this.setRotationAngles(0,0,0,0,subtype,partialTicks,theEntity);
  this.tailBase.render(0.0625F);
  if (subtype == 1) {
    GL11.glDisable(GL11.GL_CULL_FACE);
    this.tailSubBase.render(0.0625F);
    GL11.glEnable(GL11.GL_CULL_FACE);
  }
}","@Override public void render(EntityLivingBase theEntity,int subtype,float partialTicks){
  this.setRotationAngles(0,0,0,0,subtype,partialTicks,theEntity);
  this.tailBase.render(0.0625F);
  if (subtype == 1) {
    this.tailSubBase.render(0.0625F);
  }
}"
13547,"public void setTexture(ResourceLocation texture){
  if (this.texture == null || !this.texture.equals(texture)) {
    try {
      Minecraft.getMinecraft().renderEngine.deleteTexture(this.texture);
    }
 catch (    Exception ignored) {
    }
    this.needsTextureCompile=true;
  }
  this.texture=texture;
}","public void setTexture(ResourceLocation texture){
  if (texture == null || (this.texture != null && !this.texture.equals(texture))) {
    try {
      Minecraft.getMinecraft().renderEngine.deleteTexture(this.texture);
    }
 catch (    Exception ignored) {
    }
    this.needsTextureCompile=true;
  }
 else {
    this.needsTextureCompile=false;
  }
  this.texture=texture;
}"
13548,"public void setPartsData(PartsData newPartsData){
  partsData=newPartsData;
  Tails.proxy.addPartsData(mc.thePlayer.getPersistentID(),partsData);
}","public void setPartsData(PartsData newPartsData){
  partsData=newPartsData;
  Tails.proxy.addPartsData(Minecraft.getMinecraft().thePlayer.getGameProfile().getId(),partsData);
}"
13549,"public GuiEditor(){
  PartInfo partInfo;
  if (Tails.localPartsData == null) {
    Tails.setLocalPartsData(new PartsData());
  }
  partType=PartsData.PartType.TAIL;
  for (  PartsData.PartType partType : PartsData.PartType.values()) {
    if (!Tails.localPartsData.hasPartInfo(partType)) {
      Tails.localPartsData.setPartInfo(partType,new PartInfo(false,0,0,0,0xFFFF0000,0xFF00FF00,0xFF0000FF,null,partType));
    }
  }
  partInfo=Tails.localPartsData.getPartInfo(partType);
  originalPartInfo=partInfo.deepCopy();
  partsData=Tails.localPartsData.deepCopy();
  this.partInfo=originalPartInfo.deepCopy();
}","public GuiEditor(){
  PartInfo partInfo;
  if (Tails.localPartsData == null) {
    Tails.setLocalPartsData(new PartsData());
  }
  partType=PartsData.PartType.TAIL;
  for (  PartsData.PartType partType : PartsData.PartType.values()) {
    if (!Tails.localPartsData.hasPartInfo(partType)) {
      Tails.localPartsData.setPartInfo(partType,new PartInfo(false,0,0,0,0xFFFF0000,0xFF00FF00,0xFF0000FF,null,partType));
    }
  }
  partInfo=Tails.localPartsData.getPartInfo(partType);
  originalPartInfo=partInfo.deepCopy();
  setPartsData(Tails.localPartsData.deepCopy());
  this.partInfo=originalPartInfo.deepCopy();
}"
13550,"@Override public void fromBytes(ByteBuf buf){
  String dataJson=ByteBufUtils.readUTF8String(buf);
  System.out.println(dataJson);
  try {
    entries=Tails.gson.fromJson(dataJson,new TypeToken<List<LibraryEntryData>>(){
    }
.getType());
  }
 catch (  JsonParseException e) {
    e.printStackTrace();
  }
  delete=buf.readBoolean();
}","@Override public void fromBytes(ByteBuf buf){
  String dataJson=ByteBufUtils.readUTF8String(buf);
  try {
    entries=Tails.gson.fromJson(dataJson,new TypeToken<List<LibraryEntryData>>(){
    }
.getType());
  }
 catch (  JsonParseException e) {
    e.printStackTrace();
  }
  delete=buf.readBoolean();
}"
13551,"public PlayerDataMessage(UUID uuid,PartsData partsData,boolean shouldRemove){
  System.out.println(uuid + ""String_Node_Str"" + FMLCommonHandler.instance().getSide());
  this.uuid=uuid;
  this.partsData=partsData;
  this.shouldRemove=shouldRemove;
}","public PlayerDataMessage(UUID uuid,PartsData partsData,boolean shouldRemove){
  this.uuid=uuid;
  this.partsData=partsData;
  this.shouldRemove=shouldRemove;
}"
13552,"@SubscribeEvent(priority=EventPriority.LOWEST) public void onPlayerRenderTick(RenderPlayerEvent.Pre e){
  UUID uuid=e.entityPlayer.getGameProfile().getId();
  if (Tails.proxy.hasPartsData(uuid) && !e.entityPlayer.isInvisible()) {
    PartsData data=Tails.proxy.getPartsData(uuid);
    if (!flag) {
      e.renderer.modelBipedMain.bipedBody.addChild(new ModelRenderer2(e.renderer.modelBipedMain,PartsData.PartType.TAIL));
      e.renderer.modelBipedMain.bipedBody.addChild(new ModelRenderer2(e.renderer.modelBipedMain,PartsData.PartType.WINGS));
      e.renderer.modelBipedMain.bipedHead.addChild(new ModelRenderer2(e.renderer.modelBipedMain,PartsData.PartType.EARS));
      flag=true;
    }
    currentPartsData=data;
    currentPlayerTexture=((AbstractClientPlayer)e.entityPlayer).getLocationSkin();
    currentEvent=e;
  }
}","@SubscribeEvent(priority=EventPriority.LOWEST) public void onPlayerRenderTick(RenderPlayerEvent.Pre e){
  UUID uuid=e.entityPlayer.getGameProfile().getId();
  if (Tails.proxy.hasPartsData(uuid) && !e.entityPlayer.isInvisible()) {
    PartsData data=Tails.proxy.getPartsData(uuid);
    if (!flag) {
      e.renderer.modelBipedMain.bipedBody.addChild(new ModelRendererWrapper(e.renderer.modelBipedMain,PartsData.PartType.TAIL));
      e.renderer.modelBipedMain.bipedBody.addChild(new ModelRendererWrapper(e.renderer.modelBipedMain,PartsData.PartType.WINGS));
      e.renderer.modelBipedMain.bipedHead.addChild(new ModelRendererWrapper(e.renderer.modelBipedMain,PartsData.PartType.EARS));
      flag=true;
    }
    currentPartsData=data;
    currentPlayerTexture=((AbstractClientPlayer)e.entityPlayer).getLocationSkin();
    currentEvent=e;
  }
}"
13553,"void updatePartsData(){
  UUID uuid=this.mc.thePlayer.getPersistentID();
  PartEntry tailEntry=(PartEntry)partList.getListEntry(partList.getCurrrentIndex());
  partInfo.setTexture(null);
  if (currTintEdit > 0)   partInfo.tints[currTintEdit - 1]=currTintColour | 0xFF << 24;
  partInfo=new PartInfo(uuid,tailEntry.partInfo.hasPart,tailEntry.partInfo.typeid,tailEntry.partInfo.subid,textureID,partInfo.tints,partType,null);
  partInfo.setTexture(TextureHelper.generateTexture(partInfo));
  partsData.setPartInfo(partType,partInfo);
  Tails.proxy.addPartsData(uuid,partsData);
}","void updatePartsData(){
  UUID uuid=this.mc.thePlayer.getPersistentID();
  PartEntry tailEntry=(PartEntry)partList.getListEntry(partList.getCurrrentIndex());
  partInfo.setTexture(null);
  if (currTintEdit > 0)   partInfo.tints[currTintEdit - 1]=currTintColour | 0xFF << 24;
  partInfo=new PartInfo(uuid,tailEntry.partInfo.hasPart,tailEntry.partInfo.typeid,tailEntry.partInfo.subid,textureID,partInfo.tints,partType,null);
  if (partInfo.hasPart)   partInfo.setTexture(TextureHelper.generateTexture(partInfo));
  partsData.setPartInfo(partType,partInfo);
  Tails.proxy.addPartsData(uuid,partsData);
}"
13554,"private void selectDefaultListEntry(){
  for (  GuiListExtended.IGuiListEntry entry : this.partList.getEntries()) {
    PartEntry partEntry=(PartEntry)entry;
    if ((!partEntry.partInfo.hasPart && !originalPartInfo.hasPart) || (partEntry.partInfo.typeid == originalPartInfo.typeid && partEntry.partInfo.subid == originalPartInfo.subid)) {
      this.partList.setCurrrentIndex(this.partList.getEntries().indexOf(partEntry));
    }
  }
}","private void selectDefaultListEntry(){
  for (  GuiListExtended.IGuiListEntry entry : this.partList.getEntries()) {
    PartEntry partEntry=(PartEntry)entry;
    if ((!partEntry.partInfo.hasPart && !partInfo.hasPart) || (partInfo.hasPart && partEntry.partInfo.hasPart && partEntry.partInfo.typeid == partInfo.typeid && partEntry.partInfo.subid == partInfo.subid)) {
      this.partList.setCurrrentIndex(this.partList.getEntries().indexOf(partEntry));
      break;
    }
  }
}"
13555,"@Override protected void actionPerformed(GuiButton button){
  RenderPart part=partType.renderParts[partInfo.typeid];
  if (button.id >= 2 && button.id <= 4) {
    this.currTintEdit=button.id - 1;
    this.currTintColour=this.partInfo.tints[this.currTintEdit - 1] & 0xFFFFFF;
    this.hexText.setText(Integer.toHexString(this.currTintColour));
    this.refreshTintPane();
    this.tintReset.enabled=false;
  }
 else   if (button.id == 8) {
    this.currTintColour=this.originalPartInfo.tints[this.currTintEdit - 1] & 0xFFFFFF;
    this.hexText.setText(Integer.toHexString(this.currTintColour));
    this.refreshTintPane();
    tintReset.enabled=false;
  }
 else   if (button.id == 12) {
    this.partInfo=this.originalPartInfo.deepCopy();
    this.selectDefaultListEntry();
    this.currTintEdit=0;
    this.refreshTintPane();
    this.updatePartsData();
  }
 else   if (button.id == 13) {
    this.updatePartsData();
    Tails.setLocalPartsData(partsData);
    Tails.proxy.addPartsData(partsData.uuid,partsData);
    Tails.networkWrapper.sendToServer(new PlayerDataMessage(partsData,false));
    this.mc.displayGuiScreen(null);
  }
 else   if (button.id == 14) {
    this.updatePartsData();
    this.mc.displayGuiScreen(new GuiExport(this,this.partInfo));
  }
 else   if (button.id == 18) {
    if (textureID - 1 >= 0) {
      textureID--;
    }
 else {
      textureID=part.getTextureNames(partInfo.subid).length - 1;
    }
    updatePartsData();
  }
 else   if (button.id == 19) {
    if (part.getTextureNames(partInfo.subid).length > textureID + 1) {
      textureID++;
    }
 else {
      textureID=0;
    }
    updatePartsData();
  }
 else   if (button.id == 20) {
    if (partType.ordinal() + 1 >= PartsData.PartType.values().length) {
      partType=PartsData.PartType.values()[0];
    }
 else {
      partType=PartsData.PartType.values()[partType.ordinal() + 1];
    }
    PartInfo newPartInfo=partsData.getPartInfo(partType);
    if (newPartInfo == null) {
      newPartInfo=new PartInfo(partsData.uuid,false,0,0,0,0xFFFF0000,0xFF00FF00,0xFF0000FF,null,partType);
    }
    partInfo=newPartInfo.deepCopy();
    partTypeButton.displayString=partType.name();
    initPartList();
    refreshTintPane();
  }
}","@Override protected void actionPerformed(GuiButton button){
  RenderPart part=partType.renderParts[partInfo.typeid];
  if (button.id >= 2 && button.id <= 4) {
    this.currTintEdit=button.id - 1;
    this.currTintColour=this.partInfo.tints[this.currTintEdit - 1] & 0xFFFFFF;
    this.hexText.setText(Integer.toHexString(this.currTintColour));
    this.refreshTintPane();
    this.tintReset.enabled=false;
  }
 else   if (button.id == 8) {
    this.currTintColour=this.originalPartInfo.tints[this.currTintEdit - 1] & 0xFFFFFF;
    this.hexText.setText(Integer.toHexString(this.currTintColour));
    this.refreshTintPane();
    tintReset.enabled=false;
  }
 else   if (button.id == 12) {
    this.partInfo=this.originalPartInfo.deepCopy();
    this.selectDefaultListEntry();
    this.currTintEdit=0;
    this.refreshTintPane();
    this.updatePartsData();
  }
 else   if (button.id == 13) {
    this.updatePartsData();
    Tails.setLocalPartsData(partsData);
    Tails.proxy.addPartsData(partsData.uuid,partsData);
    Tails.networkWrapper.sendToServer(new PlayerDataMessage(partsData,false));
    this.mc.displayGuiScreen(null);
  }
 else   if (button.id == 14) {
    this.updatePartsData();
    this.mc.displayGuiScreen(new GuiExport(this,this.partInfo));
  }
 else   if (button.id == 18) {
    if (textureID - 1 >= 0) {
      textureID--;
    }
 else {
      textureID=part.getTextureNames(partInfo.subid).length - 1;
    }
    updatePartsData();
  }
 else   if (button.id == 19) {
    if (part.getTextureNames(partInfo.subid).length > textureID + 1) {
      textureID++;
    }
 else {
      textureID=0;
    }
    updatePartsData();
  }
 else   if (button.id == 20) {
    if (partType.ordinal() + 1 >= PartsData.PartType.values().length) {
      partType=PartsData.PartType.values()[0];
    }
 else {
      partType=PartsData.PartType.values()[partType.ordinal() + 1];
    }
    PartInfo newPartInfo=partsData.getPartInfo(partType);
    if (newPartInfo == null) {
      newPartInfo=new PartInfo(partsData.uuid,false,0,0,0,0xFFFF0000,0xFF00FF00,0xFF0000FF,null,partType);
    }
    originalPartInfo=newPartInfo.deepCopy();
    partInfo=originalPartInfo.deepCopy();
    partTypeButton.displayString=partType.name();
    initPartList();
    refreshTintPane();
  }
}"
13556,"@Override public void onPreRenderTail(EntityLivingBase entity,RenderPart tail,PartInfo info,double x,double y,double z){
  if (tail.modelPart instanceof ModelFoxEars)   return;
  if (tail.modelPart instanceof ModelDragonTail) {
    if (!entity.isSneaking())     GL11.glTranslatef(0F,0.68F,0.1F);
 else     GL11.glTranslatef(0F,0.6F,0.35F);
    GL11.glScalef(0.8F,0.8F,0.8F);
  }
 else   if (tail.modelPart instanceof ModelCatTail || tail.modelPart instanceof ModelDevilTail) {
    if (!entity.isSneaking())     GL11.glTranslatef(0F,0.65F,0.1F);
 else     GL11.glTranslatef(0F,0.55F,0.4F);
    GL11.glScalef(0.9F,0.9F,0.9F);
  }
 else {
    if (!entity.isSneaking())     GL11.glTranslatef(0F,0.65F,0.1F);
 else     GL11.glTranslatef(0F,0.55F,0.4F);
    GL11.glScalef(0.8F,0.8F,0.8F);
  }
}","@Override public void onPreRenderTail(EntityLivingBase entity,RenderPart tail,PartInfo info,double x,double y,double z){
  if (info.partType == PartsData.PartType.EARS)   return;
  if (tail.modelPart instanceof ModelDragonTail) {
    if (!entity.isSneaking())     GL11.glTranslatef(0F,0.68F,0.1F);
 else     GL11.glTranslatef(0F,0.6F,0.35F);
    GL11.glScalef(0.8F,0.8F,0.8F);
  }
 else   if (tail.modelPart instanceof ModelCatTail || tail.modelPart instanceof ModelDevilTail) {
    if (!entity.isSneaking())     GL11.glTranslatef(0F,0.65F,0.1F);
 else     GL11.glTranslatef(0F,0.55F,0.4F);
    GL11.glScalef(0.9F,0.9F,0.9F);
  }
 else {
    if (!entity.isSneaking())     GL11.glTranslatef(0F,0.65F,0.1F);
 else     GL11.glTranslatef(0F,0.55F,0.4F);
    GL11.glScalef(0.8F,0.8F,0.8F);
  }
}"
13557,"@Override public void execute(OperationRequest operation,OperationContext context,ParticipantId participant) throws InvalidRequestException {
  String capabilitiesHash=OperationUtil.getRequiredParameter(operation,ParamsProperty.CAPABILITIES_HASH);
  RobotName robotName=RobotName.fromAddress(participant.getAddress());
  ParticipantId robotAccountId=ParticipantId.ofUnsafe(robotName.toEmailAddress());
  AccountData account;
  try {
    account=accountStore.getAccount(robotAccountId);
  }
 catch (  PersistenceException e) {
    LOG.severe(""String_Node_Str"" + robotAccountId,e);
    context.constructErrorResponse(operation,""String_Node_Str"");
    return;
  }
  if (account == null || !account.isRobot()) {
    throw new InvalidRequestException(""String_Node_Str"" + robotAccountId);
  }
  RobotAccountData robotAccountData=account.asRobot();
  RobotCapabilities capabilities=robotAccountData.getCapabilities();
  if (capabilities != null && capabilitiesHash.equals(capabilities.getCapabilitiesHash())) {
    context.constructResponse(operation,Maps.<ParamsProperty,Object>newHashMap());
    return;
  }
  try {
    robotAccountData=connector.fetchCapabilities(robotAccountData,""String_Node_Str"");
  }
 catch (  CapabilityFetchException e) {
    LOG.fine(""String_Node_Str"" + account.getId(),e);
    context.constructErrorResponse(operation,""String_Node_Str"");
    return;
  }
  try {
    accountStore.putAccount(robotAccountData);
  }
 catch (  PersistenceException e) {
    LOG.severe(""String_Node_Str"" + robotAccountId,e);
    context.constructErrorResponse(operation,""String_Node_Str"");
    return;
  }
  context.constructResponse(operation,Maps.<ParamsProperty,Object>newHashMap());
}","@Override public void execute(OperationRequest operation,OperationContext context,ParticipantId participant) throws InvalidRequestException {
  String capabilitiesHash=OperationUtil.getRequiredParameter(operation,ParamsProperty.CAPABILITIES_HASH);
  ParticipantId robotAccountId=participant;
  AccountData account;
  try {
    account=accountStore.getAccount(robotAccountId);
  }
 catch (  PersistenceException e) {
    LOG.severe(""String_Node_Str"" + robotAccountId,e);
    context.constructErrorResponse(operation,""String_Node_Str"");
    return;
  }
  if (account == null || !account.isRobot()) {
    throw new InvalidRequestException(""String_Node_Str"" + robotAccountId);
  }
  RobotAccountData robotAccountData=account.asRobot();
  RobotCapabilities capabilities=robotAccountData.getCapabilities();
  if (capabilities != null && capabilitiesHash.equals(capabilities.getCapabilitiesHash())) {
    context.constructResponse(operation,Maps.<ParamsProperty,Object>newHashMap());
    return;
  }
  try {
    robotAccountData=connector.fetchCapabilities(robotAccountData,""String_Node_Str"");
  }
 catch (  CapabilityFetchException e) {
    LOG.fine(""String_Node_Str"" + account.getId(),e);
    context.constructErrorResponse(operation,""String_Node_Str"");
    return;
  }
  try {
    accountStore.putAccount(robotAccountData);
  }
 catch (  PersistenceException e) {
    LOG.severe(""String_Node_Str"" + robotAccountId,e);
    context.constructErrorResponse(operation,""String_Node_Str"");
    return;
  }
  context.constructResponse(operation,Maps.<ParamsProperty,Object>newHashMap());
}"
13558,"@Override public void openRequest(ParticipantId loggedInUser,WaveId waveId,IdFilter waveletIdFilter,Collection<WaveClientRpc.WaveletVersion> knownWavelets,OpenListener openListener){
  LOG.info(""String_Node_Str"" + loggedInUser + ""String_Node_Str""+ waveId+ ""String_Node_Str""+ waveletIdFilter+ ""String_Node_Str""+ knownWavelets);
  if (loggedInUser == null) {
    openListener.onFailure(""String_Node_Str"");
    return;
  }
  if (!knownWavelets.isEmpty()) {
    openListener.onFailure(""String_Node_Str"");
    return;
  }
  try {
    waveletInfo.initialiseWave(waveId);
  }
 catch (  WaveServerException e) {
    LOG.severe(""String_Node_Str"" + waveId,e);
    openListener.onFailure(""String_Node_Str"");
    return;
  }
  String channelId=generateChannelID();
  UserManager userManager=waveletInfo.getUserManager(loggedInUser);
synchronized (userManager) {
    WaveViewSubscription subscription=userManager.subscribe(waveId,waveletIdFilter,channelId,openListener);
    LOG.info(""String_Node_Str"" + loggedInUser + ""String_Node_Str""+ waveId+ ""String_Node_Str""+ channelId);
    Set<WaveletId> waveletIds;
    try {
      waveletIds=waveletInfo.visibleWaveletsFor(subscription,loggedInUser);
    }
 catch (    WaveServerException e1) {
      waveletIds=Sets.newHashSet();
      LOG.warning(""String_Node_Str"" + loggedInUser,e1);
    }
    for (    WaveletId waveletId : waveletIds) {
      WaveletName waveletName=WaveletName.of(waveId,waveletId);
      waveletInfo.notifyAddedImplcitParticipant(waveletName,loggedInUser);
      CommittedWaveletSnapshot snapshotToSend;
      try {
        snapshotToSend=waveletProvider.getSnapshot(waveletName);
      }
 catch (      WaveServerException e) {
        LOG.warning(""String_Node_Str"" + waveletName,e);
        openListener.onFailure(""String_Node_Str"");
        return;
      }
      LOG.info(""String_Node_Str"" + (snapshotToSend != null));
      if (snapshotToSend == null) {
        openListener.onUpdate(waveletName,snapshotToSend,DeltaSequence.empty(),null,null,channelId);
      }
 else {
        openListener.onUpdate(waveletName,snapshotToSend,DeltaSequence.empty(),snapshotToSend.committedVersion,null,channelId);
      }
    }
    WaveletName dummyWaveletName=createDummyWaveletName(waveId);
    if (waveletIds.size() == 0) {
      LOG.info(""String_Node_Str"" + dummyWaveletName);
      openListener.onUpdate(dummyWaveletName,null,DeltaSequence.empty(),null,null,channelId);
    }
    LOG.info(""String_Node_Str"" + dummyWaveletName);
    openListener.onUpdate(dummyWaveletName,null,DeltaSequence.empty(),null,true,null);
  }
}","@Override public void openRequest(ParticipantId loggedInUser,WaveId waveId,IdFilter waveletIdFilter,Collection<WaveClientRpc.WaveletVersion> knownWavelets,OpenListener openListener){
  LOG.info(""String_Node_Str"" + loggedInUser + ""String_Node_Str""+ waveId+ ""String_Node_Str""+ waveletIdFilter+ ""String_Node_Str""+ knownWavelets);
  if (loggedInUser == null) {
    openListener.onFailure(""String_Node_Str"");
    return;
  }
  if (!knownWavelets.isEmpty()) {
    openListener.onFailure(""String_Node_Str"");
    return;
  }
  try {
    waveletInfo.initialiseWave(waveId);
  }
 catch (  WaveServerException e) {
    LOG.severe(""String_Node_Str"" + waveId,e);
    openListener.onFailure(""String_Node_Str"");
    return;
  }
  String channelId=generateChannelID();
  UserManager userManager=waveletInfo.getUserManager(loggedInUser);
  WaveViewSubscription subscription=userManager.subscribe(waveId,waveletIdFilter,channelId,openListener);
  LOG.info(""String_Node_Str"" + loggedInUser + ""String_Node_Str""+ waveId+ ""String_Node_Str""+ channelId);
  Set<WaveletId> waveletIds;
  try {
    waveletIds=waveletInfo.visibleWaveletsFor(subscription,loggedInUser);
  }
 catch (  WaveServerException e1) {
    waveletIds=Sets.newHashSet();
    LOG.warning(""String_Node_Str"" + loggedInUser,e1);
  }
  for (  WaveletId waveletId : waveletIds) {
    WaveletName waveletName=WaveletName.of(waveId,waveletId);
    waveletInfo.notifyAddedImplcitParticipant(waveletName,loggedInUser);
    CommittedWaveletSnapshot snapshotToSend;
    try {
      snapshotToSend=waveletProvider.getSnapshot(waveletName);
    }
 catch (    WaveServerException e) {
      LOG.warning(""String_Node_Str"" + waveletName,e);
      openListener.onFailure(""String_Node_Str"");
      return;
    }
    LOG.info(""String_Node_Str"" + (snapshotToSend != null));
    if (snapshotToSend == null) {
      openListener.onUpdate(waveletName,snapshotToSend,DeltaSequence.empty(),null,null,channelId);
    }
 else {
      openListener.onUpdate(waveletName,snapshotToSend,DeltaSequence.empty(),snapshotToSend.committedVersion,null,channelId);
    }
  }
  WaveletName dummyWaveletName=createDummyWaveletName(waveId);
  if (waveletIds.size() == 0) {
    LOG.info(""String_Node_Str"" + dummyWaveletName);
    openListener.onUpdate(dummyWaveletName,null,DeltaSequence.empty(),null,null,channelId);
  }
  LOG.info(""String_Node_Str"" + dummyWaveletName);
  openListener.onUpdate(dummyWaveletName,null,DeltaSequence.empty(),null,true,null);
}"
13559,"/** 
 * Factory constructor, creates and attaches the buffer to the DOM.
 * @return Browser specific implementation of a paste buffer.
 */
static PasteBufferImpl create(){
  PasteBufferImpl pasteBuffer;
  if (UserAgent.isSafari()) {
    pasteBuffer=new PasteBufferImplSafari();
  }
 else   if (UserAgent.isFirefox() && !QuirksConstants.SANITIZES_PASTED_CONTENT) {
    pasteBuffer=new PasteBufferImplFirefox();
  }
 else {
    pasteBuffer=new PasteBufferImpl();
  }
  pasteBuffer.setupDom();
  return pasteBuffer;
}","/** 
 * Factory constructor, creates and attaches the buffer to the DOM.
 * @return Browser specific implementation of a paste buffer.
 */
static PasteBufferImpl create(){
  PasteBufferImpl pasteBuffer;
  if (UserAgent.isSafari() || QuirksConstants.FIREFOX_GREATER_THAN_VER_15) {
    pasteBuffer=new PasteBufferImplSafariAndNewFirefox();
  }
 else   if (UserAgent.isFirefox() && !QuirksConstants.SANITIZES_PASTED_CONTENT) {
    pasteBuffer=new PasteBufferImplOldFirefox();
  }
 else {
    pasteBuffer=new PasteBufferImpl();
  }
  pasteBuffer.setupDom();
  return pasteBuffer;
}"
13560,"private static UserAgentRuntimeProperties createInstance(){
  return GWT.isScript() ? new UserAgentRuntimeProperties(getNativeUserAgent()) : new UserAgentRuntimeProperties(""String_Node_Str"");
}","private static UserAgentRuntimeProperties createInstance(){
  return GWT.isClient() ? new UserAgentRuntimeProperties(getNativeUserAgent()) : new UserAgentRuntimeProperties(""String_Node_Str"");
}"
13561,"@Override public void onOpened(WaveContext wave){
  Document document=wave.getConversations().getRoot().getRootThread().getFirstBlip().getContent();
  String waveTitle=TitleHelper.extractTitle(document);
  String windowTitle=formatTitle(waveTitle);
  if (waveTitle == null || waveTitle.isEmpty()) {
    windowTitle=DEFAULT_TITLE;
  }
  Window.setTitle(windowTitle);
  waveFrame.setTitle(waveTitle);
  waveFrame.setTitleText(waveTitle);
}","@Override public void onOpened(WaveContext wave){
  Document document=wave.getConversations().getRoot().getRootThread().getFirstBlip().getContent();
  String waveTitle=TitleHelper.extractTitle(document);
  String windowTitle=formatTitle(waveTitle);
  if (waveTitle == null || waveTitle.isEmpty()) {
    windowTitle=DEFAULT_TITLE;
  }
  Window.setTitle(windowTitle);
  waveFrame.setTitleText(waveTitle);
}"
13562,"/** 
 * @param waveId the id of the wave to open, or null to create a new wave
 * @param channel communication channel
 * @param idGenerator
 * @param unsavedIndicatorElement
 */
public StageTwoProvider(StageOne stageOne,WaveRef waveRef,RemoteViewServiceMultiplexer channel,boolean isNewWave,IdGenerator idGenerator,ProfileManager profiles,Element unsavedIndicatorElement){
  super(stageOne,unsavedIndicatorElement);
  Preconditions.checkArgument(stageOne != null);
  Preconditions.checkArgument(waveRef != null);
  Preconditions.checkArgument(waveRef.getWaveId() != null);
  this.waveRef=waveRef;
  this.channel=channel;
  this.isNewWave=isNewWave;
  this.idGenerator=idGenerator;
  this.profiles=profiles;
}","/** 
 * @param waveId the id of the wave to open, or null to create a new wave
 * @param channel communication channel
 * @param idGenerator
 * @param unsavedIndicatorElement
 */
public StageTwoProvider(StageOne stageOne,WaveRef waveRef,RemoteViewServiceMultiplexer channel,boolean isNewWave,IdGenerator idGenerator,ProfileManager profiles,UnsavedDataListener unsavedDataListener){
  super(stageOne,unsavedDataListener);
  Preconditions.checkArgument(stageOne != null);
  Preconditions.checkArgument(waveRef != null);
  Preconditions.checkArgument(waveRef.getWaveId() != null);
  this.waveRef=waveRef;
  this.channel=channel;
  this.isNewWave=isNewWave;
  this.idGenerator=idGenerator;
  this.profiles=profiles;
}"
13563,"@Override protected AsyncHolder<StageTwo> createStageTwoLoader(StageOne one){
  return haltIfClosed(new StageTwoProvider(this.one=one,waveRef,channel,isNewWave,idGenerator,profiles,unsavedIndicatorElement));
}","@Override protected AsyncHolder<StageTwo> createStageTwoLoader(StageOne one){
  return haltIfClosed(new StageTwoProvider(this.one=one,waveRef,channel,isNewWave,idGenerator,profiles,new SavedStateIndicator(unsavedIndicatorElement)));
}"
13564,"/** 
 * @return upgrader for activating stacklets. Subclasses may override. 
 */
protected MuxConnector createConnector(){
  LoggerBundle logger=LoggerBundle.NOP_IMPL;
  LoggerContext loggers=new LoggerContext(logger,logger,logger,logger);
  IdURIEncoderDecoder uriCodec=new IdURIEncoderDecoder(new ClientPercentEncoderDecoder());
  HashedVersionFactory hashFactory=new HashedVersionZeroFactoryImpl(uriCodec);
  Scheduler scheduler=new FuzzingBackOffScheduler.Builder(getRpcScheduler()).setInitialBackOffMs(ClientFlags.get().initialRpcBackoffMs()).setMaxBackOffMs(ClientFlags.get().maxRpcBackoffMs()).setRandomisationFactor(0.5).build();
  ViewChannelFactory viewFactory=ViewChannelImpl.factory(createWaveViewService(),logger);
  UnsavedDataListenerFactory unsyncedListeners=new UnsavedDataListenerFactory(){
    private final UnsavedDataListener listener=new SavedStateIndicator(unsavedIndicatorElement);
    @Override public UnsavedDataListener create(    WaveletId waveletId){
      return listener;
    }
    @Override public void destroy(    WaveletId waveletId){
    }
  }
;
  WaveletId udwId=getIdGenerator().newUserDataWaveletId(getSignedInUser().getAddress());
  final IdFilter filter=IdFilter.of(Collections.singleton(udwId),Collections.singleton(IdConstants.CONVERSATION_WAVELET_PREFIX));
  WaveletDataImpl.Factory snapshotFactory=WaveletDataImpl.Factory.create(getDocumentRegistry());
  final OperationChannelMultiplexer mux=new OperationChannelMultiplexerImpl(getWave().getWaveId(),viewFactory,snapshotFactory,loggers,unsyncedListeners,scheduler,hashFactory);
  final WaveViewImpl<OpBasedWavelet> wave=getWave();
  return new MuxConnector(){
    @Override public void connect(    Command onOpened){
      LiveChannelBinder.openAndBind(getWavelets(),wave,getDocumentRegistry(),mux,filter,onOpened);
    }
    @Override public void close(){
      mux.close();
    }
  }
;
}","/** 
 * @return upgrader for activating stacklets. Subclasses may override. 
 */
protected MuxConnector createConnector(){
  LoggerBundle logger=LoggerBundle.NOP_IMPL;
  LoggerContext loggers=new LoggerContext(logger,logger,logger,logger);
  IdURIEncoderDecoder uriCodec=new IdURIEncoderDecoder(new ClientPercentEncoderDecoder());
  HashedVersionFactory hashFactory=new HashedVersionZeroFactoryImpl(uriCodec);
  Scheduler scheduler=new FuzzingBackOffScheduler.Builder(getRpcScheduler()).setInitialBackOffMs(ClientFlags.get().initialRpcBackoffMs()).setMaxBackOffMs(ClientFlags.get().maxRpcBackoffMs()).setRandomisationFactor(0.5).build();
  ViewChannelFactory viewFactory=ViewChannelImpl.factory(createWaveViewService(),logger);
  UnsavedDataListenerFactory unsyncedListeners=new UnsavedDataListenerFactory(){
    private final UnsavedDataListener listener=unsavedDataListener;
    @Override public UnsavedDataListener create(    WaveletId waveletId){
      return listener;
    }
    @Override public void destroy(    WaveletId waveletId){
    }
  }
;
  WaveletId udwId=getIdGenerator().newUserDataWaveletId(getSignedInUser().getAddress());
  final IdFilter filter=IdFilter.of(Collections.singleton(udwId),Collections.singleton(IdConstants.CONVERSATION_WAVELET_PREFIX));
  WaveletDataImpl.Factory snapshotFactory=WaveletDataImpl.Factory.create(getDocumentRegistry());
  final OperationChannelMultiplexer mux=new OperationChannelMultiplexerImpl(getWave().getWaveId(),viewFactory,snapshotFactory,loggers,unsyncedListeners,scheduler,hashFactory);
  final WaveViewImpl<OpBasedWavelet> wave=getWave();
  return new MuxConnector(){
    @Override public void connect(    Command onOpened){
      LiveChannelBinder.openAndBind(getWavelets(),wave,getDocumentRegistry(),mux,filter,onOpened);
    }
    @Override public void close(){
      mux.close();
    }
  }
;
}"
13565,"public DefaultProvider(StageOne stageOne,Element unsavedIndicatorElement){
  this.stageOne=stageOne;
  this.unsavedIndicatorElement=unsavedIndicatorElement;
}","public DefaultProvider(StageOne stageOne,UnsavedDataListener unsavedDataListener){
  this.stageOne=stageOne;
  this.unsavedDataListener=unsavedDataListener;
}"
13566,"@Override public void flush(HashedVersion version){
  transformedDeltas.remove(version);
  appliedDeltas.remove(version);
  if (LOG.isFineLoggable()) {
    LOG.fine(""String_Node_Str"" + version);
  }
}","@Override public void flush(HashedVersion version){
  transformedDeltas.remove(transformedDeltas.lowerKey(version));
  appliedDeltas.remove(appliedDeltas.lowerKey(version));
  if (LOG.isFineLoggable()) {
    LOG.fine(""String_Node_Str"" + version);
  }
}"
13567,"@Override public void run(){
  acquireWriteLock();
  try {
    waveletState.flush(version);
    notifyOfCommit(version,domainsToNotify);
  }
  finally {
    releaseWriteLock();
  }
}","@Override public void run(){
  try {
    result.get();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
catch (  ExecutionException e) {
    LOG.severe(""String_Node_Str"" + version,e);
  }
  acquireWriteLock();
  try {
    waveletState.flush(version);
    notifyOfCommit(version,domainsToNotify);
  }
  finally {
    releaseWriteLock();
  }
}"
13568,"protected void persist(final HashedVersion version,final ImmutableSet<String> domainsToNotify){
  Preconditions.checkState(writeLock.isHeldByCurrentThread(),""String_Node_Str"");
  final ListenableFuture<Void> result=waveletState.persist(version);
  result.addListener(new Runnable(){
    @Override public void run(){
      acquireWriteLock();
      try {
        waveletState.flush(version);
        notifyOfCommit(version,domainsToNotify);
      }
  finally {
        releaseWriteLock();
      }
    }
  }
,storageContinuationExecutor);
}","protected void persist(final HashedVersion version,final ImmutableSet<String> domainsToNotify){
  Preconditions.checkState(writeLock.isHeldByCurrentThread(),""String_Node_Str"");
  final ListenableFuture<Void> result=waveletState.persist(version);
  result.addListener(new Runnable(){
    @Override public void run(){
      try {
        result.get();
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
catch (      ExecutionException e) {
        LOG.severe(""String_Node_Str"" + version,e);
      }
      acquireWriteLock();
      try {
        waveletState.flush(version);
        notifyOfCommit(version,domainsToNotify);
      }
  finally {
        releaseWriteLock();
      }
    }
  }
,storageContinuationExecutor);
}"
13569,"/** 
 * Commonly we start to listen history changes when webclient starts calling this method. If you are using wave client integrated with other different GWT application and with a different History management, you can avoid to use this and just call to the   {@link WaveSelectionEvent} events (for example) or other uses.
 */
public static void init(){
  History.addValueChangeHandler(new ValueChangeHandler<String>(){
    @Override public void onValueChange(    ValueChangeEvent<String> event){
      String encodedToken=event.getValue();
      if (encodedToken == null || encodedToken.length() == 0) {
        return;
      }
      WaveRef waveRef=HistorySupport.waveRefFromHistoryToken(encodedToken);
      if (waveRef == null) {
        LOG.info(""String_Node_Str"" + encodedToken);
        return;
      }
      LOG.info(""String_Node_Str"" + waveRef.toString());
      ClientEvents.get().fireEvent(new WaveSelectionEvent(waveRef));
    }
  }
);
}","/** 
 * Commonly we start to listen history changes when webclient starts calling this method. If you are using wave client integrated with other different GWT application and with a different History management, you can avoid to use this and just call to the   {@link WaveSelectionEvent} events (for example) or other uses.
 */
public static void init(){
  History.addValueChangeHandler(new ValueChangeHandler<String>(){
    @Override public void onValueChange(    ValueChangeEvent<String> event){
      String encodedToken=event.getValue();
      if (encodedToken == null || encodedToken.length() == 0) {
        return;
      }
      WaveRef waveRef;
      try {
        waveRef=GwtWaverefEncoder.decodeWaveRefFromPath(encodedToken);
      }
 catch (      InvalidWaveRefException e) {
        LOG.info(""String_Node_Str"" + encodedToken);
        return;
      }
      LOG.info(""String_Node_Str"" + waveRef.toString());
      ClientEvents.get().fireEvent(new WaveSelectionEvent(waveRef));
    }
  }
);
}"
13570,"@Override public void onValueChange(ValueChangeEvent<String> event){
  String encodedToken=event.getValue();
  if (encodedToken == null || encodedToken.length() == 0) {
    return;
  }
  WaveRef waveRef=HistorySupport.waveRefFromHistoryToken(encodedToken);
  if (waveRef == null) {
    LOG.info(""String_Node_Str"" + encodedToken);
    return;
  }
  LOG.info(""String_Node_Str"" + waveRef.toString());
  ClientEvents.get().fireEvent(new WaveSelectionEvent(waveRef));
}","@Override public void onValueChange(ValueChangeEvent<String> event){
  String encodedToken=event.getValue();
  if (encodedToken == null || encodedToken.length() == 0) {
    return;
  }
  WaveRef waveRef;
  try {
    waveRef=GwtWaverefEncoder.decodeWaveRefFromPath(encodedToken);
  }
 catch (  InvalidWaveRefException e) {
    LOG.info(""String_Node_Str"" + encodedToken);
    return;
  }
  LOG.info(""String_Node_Str"" + waveRef.toString());
  ClientEvents.get().fireEvent(new WaveSelectionEvent(waveRef));
}"
13571,"/** 
 * Shows a wave in a wave panel.
 * @param waveRef wave id to open
 * @param isNewWave whether the wave is being created by this client session.
 */
private void openWave(WaveRef waveRef,boolean isNewWave){
  LOG.info(""String_Node_Str"");
  if (wave != null) {
    wave.destroy();
    wave=null;
  }
  UIObject.setVisible(waveFrame.getElement(),true);
  waveHolder.getElement().appendChild(loading);
  Element holder=waveHolder.getElement().appendChild(Document.get().createDivElement());
  StagesProvider wave=new StagesProvider(holder,waveHolder,waveRef,channel,idGenerator,profiles,waveStore,isNewWave,Session.get().getDomain());
  this.wave=wave;
  wave.load(new Command(){
    @Override public void execute(){
      loading.removeFromParent();
    }
  }
);
  String encodedToken=History.getToken();
  if (encodedToken != null && !encodedToken.isEmpty()) {
    WaveRef fromWaveRef=HistorySupport.waveRefFromHistoryToken(encodedToken);
    if (waveRef == null) {
      LOG.info(""String_Node_Str"" + encodedToken);
      return;
    }
    if (fromWaveRef.getWaveId().equals(waveRef.getWaveId())) {
      return;
    }
  }
  History.newItem(HistorySupport.historyTokenFromWaveref(waveRef),false);
}","/** 
 * Shows a wave in a wave panel.
 * @param waveRef wave id to open
 * @param isNewWave whether the wave is being created by this client session.
 */
private void openWave(WaveRef waveRef,boolean isNewWave){
  LOG.info(""String_Node_Str"");
  if (wave != null) {
    wave.destroy();
    wave=null;
  }
  UIObject.setVisible(waveFrame.getElement(),true);
  waveHolder.getElement().appendChild(loading);
  Element holder=waveHolder.getElement().appendChild(Document.get().createDivElement());
  StagesProvider wave=new StagesProvider(holder,waveHolder,waveRef,channel,idGenerator,profiles,waveStore,isNewWave,Session.get().getDomain());
  this.wave=wave;
  wave.load(new Command(){
    @Override public void execute(){
      loading.removeFromParent();
    }
  }
);
  String encodedToken=History.getToken();
  if (encodedToken != null && !encodedToken.isEmpty()) {
    WaveRef fromWaveRef;
    try {
      fromWaveRef=GwtWaverefEncoder.decodeWaveRefFromPath(encodedToken);
    }
 catch (    InvalidWaveRefException e) {
      LOG.info(""String_Node_Str"" + encodedToken);
      return;
    }
    if (fromWaveRef.getWaveId().equals(waveRef.getWaveId())) {
      return;
    }
  }
  History.newItem(GwtWaverefEncoder.encodeToUriPathSegment(waveRef),false);
}"
13572,"protected EditToolbar createEditToolbar(){
  return EditToolbar.create(getStageTwo().getSignedInUser(),stageTwo.getIdGenerator());
}","protected EditToolbar createEditToolbar(){
  return EditToolbar.create(getStageTwo().getSignedInUser(),stageTwo.getIdGenerator(),stageTwo.getWave().getWaveId());
}"
13573,"private EditToolbar(EditorToolbarResources.Css css,ToplevelToolbarWidget toolbarUi,ParticipantId user,IdGenerator idGenerator){
  this.css=css;
  this.toolbarUi=toolbarUi;
  this.user=user;
  attachmentIdGenerator=new AttachmentIdGeneratorImpl(idGenerator);
}","private EditToolbar(EditorToolbarResources.Css css,ToplevelToolbarWidget toolbarUi,ParticipantId user,IdGenerator idGenerator,WaveId waveId){
  this.css=css;
  this.toolbarUi=toolbarUi;
  this.user=user;
  this.waveId=waveId;
  attachmentIdGenerator=new AttachmentIdGeneratorImpl(idGenerator);
}"
13574,"/** 
 * Attaches editor behaviour to a toolbar, adding all the edit buttons.
 */
public static EditToolbar create(ParticipantId user,IdGenerator idGenerator){
  ToplevelToolbarWidget toolbarUi=new ToplevelToolbarWidget();
  EditorToolbarResources.Css css=EditorToolbarResources.Loader.res.css();
  return new EditToolbar(css,toolbarUi,user,idGenerator);
}","/** 
 * Attaches editor behaviour to a toolbar, adding all the edit buttons.
 */
public static EditToolbar create(ParticipantId user,IdGenerator idGenerator,WaveId waveId){
  ToplevelToolbarWidget toolbarUi=new ToplevelToolbarWidget();
  EditorToolbarResources.Css css=EditorToolbarResources.Loader.res.css();
  return new EditToolbar(css,toolbarUi,user,idGenerator,waveId);
}"
13575,"private void createInsertAttachmentButton(ToolbarView toolbar,final ParticipantId user){
  String encodedToken=HistorySupport.getToken();
  WaveRef waveRef=null;
  if (encodedToken != null && !encodedToken.isEmpty()) {
    waveRef=HistorySupport.waveRefFromHistoryToken(encodedToken);
  }
  Preconditions.checkState(waveRef != null);
  final String waveRefToken=URL.encode(GwtWaverefEncoder.encodeToUriQueryString(waveRef));
  new ToolbarButtonViewBuilder().setIcon(css.insertAttachment()).setTooltip(""String_Node_Str"").applyTo(toolbar.addClickButton(),new ToolbarClickButton.Listener(){
    @Override public void onClicked(){
      int tmpCursor=-1;
      FocusedRange focusedRange=editor.getSelectionHelper().getSelectionRange();
      if (focusedRange != null) {
        tmpCursor=focusedRange.getFocus();
      }
      final int cursorLoc=tmpCursor;
      AttachmentPopupView attachmentView=new AttachmentPopupWidget();
      attachmentView.init(new Listener(){
        @Override public void onShow(){
        }
        @Override public void onHide(){
        }
        @Override public void onDone(        String encodedWaveRef,        String attachmentId,        String fullFileName){
          int lastSlashPos=fullFileName.lastIndexOf(""String_Node_Str"");
          int lastBackSlashPos=fullFileName.lastIndexOf(""String_Node_Str"");
          String fileName=fullFileName;
          if (lastSlashPos != -1) {
            fileName=fullFileName.substring(lastSlashPos + 1,fullFileName.length());
          }
 else           if (lastBackSlashPos != -1) {
            fileName=fullFileName.substring(lastBackSlashPos + 1,fullFileName.length());
          }
          XmlStringBuilder xml=XmlStringBuilder.createFromXmlString(fileName);
          int to=-1;
          int docSize=editor.getDocument().size();
          if (cursorLoc != -1) {
            CMutableDocument doc=editor.getDocument();
            Point<ContentNode> point=doc.locate(cursorLoc);
            doc.insertXml(point,xml);
          }
 else {
            LineContainers.appendLine(editor.getDocument(),xml);
          }
          to=cursorLoc + editor.getDocument().size() - docSize;
          String linkValue=GWT.getHostPageBaseURL() + ""String_Node_Str"" + attachmentId+ ""String_Node_Str""+ fileName+ ""String_Node_Str""+ encodedWaveRef;
          EditorAnnotationUtil.setAnnotationOverRange(editor.getDocument(),editor.getCaretAnnotations(),Link.KEY,linkValue,cursorLoc,to);
          EditorAnnotationUtil.setAnnotationOverRange(editor.getDocument(),editor.getCaretAnnotations(),""String_Node_Str"",attachmentId,cursorLoc,to);
          EditorAnnotationUtil.setAnnotationOverRange(editor.getDocument(),editor.getCaretAnnotations(),""String_Node_Str"",fileName,cursorLoc,to);
        }
      }
);
      attachmentView.setAttachmentId(attachmentIdGenerator.newAttachmentId());
      attachmentView.setWaveRef(waveRefToken);
      attachmentView.show();
    }
  }
);
}","private void createInsertAttachmentButton(ToolbarView toolbar,final ParticipantId user){
  WaveRef waveRef=WaveRef.of(waveId);
  Preconditions.checkState(waveRef != null);
  final String waveRefToken=URL.encode(GwtWaverefEncoder.encodeToUriQueryString(waveRef));
  new ToolbarButtonViewBuilder().setIcon(css.insertAttachment()).setTooltip(""String_Node_Str"").applyTo(toolbar.addClickButton(),new ToolbarClickButton.Listener(){
    @Override public void onClicked(){
      int tmpCursor=-1;
      FocusedRange focusedRange=editor.getSelectionHelper().getSelectionRange();
      if (focusedRange != null) {
        tmpCursor=focusedRange.getFocus();
      }
      final int cursorLoc=tmpCursor;
      AttachmentPopupView attachmentView=new AttachmentPopupWidget();
      attachmentView.init(new Listener(){
        @Override public void onShow(){
        }
        @Override public void onHide(){
        }
        @Override public void onDone(        String encodedWaveRef,        String attachmentId,        String fullFileName){
          int lastSlashPos=fullFileName.lastIndexOf(""String_Node_Str"");
          int lastBackSlashPos=fullFileName.lastIndexOf(""String_Node_Str"");
          String fileName=fullFileName;
          if (lastSlashPos != -1) {
            fileName=fullFileName.substring(lastSlashPos + 1,fullFileName.length());
          }
 else           if (lastBackSlashPos != -1) {
            fileName=fullFileName.substring(lastBackSlashPos + 1,fullFileName.length());
          }
          XmlStringBuilder xml=XmlStringBuilder.createFromXmlString(fileName);
          int to=-1;
          int docSize=editor.getDocument().size();
          if (cursorLoc != -1) {
            CMutableDocument doc=editor.getDocument();
            Point<ContentNode> point=doc.locate(cursorLoc);
            doc.insertXml(point,xml);
          }
 else {
            LineContainers.appendLine(editor.getDocument(),xml);
          }
          to=cursorLoc + editor.getDocument().size() - docSize;
          String linkValue=GWT.getHostPageBaseURL() + ""String_Node_Str"" + attachmentId+ ""String_Node_Str""+ fileName+ ""String_Node_Str""+ encodedWaveRef;
          EditorAnnotationUtil.setAnnotationOverRange(editor.getDocument(),editor.getCaretAnnotations(),Link.KEY,linkValue,cursorLoc,to);
          EditorAnnotationUtil.setAnnotationOverRange(editor.getDocument(),editor.getCaretAnnotations(),""String_Node_Str"",attachmentId,cursorLoc,to);
          EditorAnnotationUtil.setAnnotationOverRange(editor.getDocument(),editor.getCaretAnnotations(),""String_Node_Str"",fileName,cursorLoc,to);
        }
      }
);
      attachmentView.setAttachmentId(attachmentIdGenerator.newAttachmentId());
      attachmentView.setWaveRef(waveRefToken);
      attachmentView.show();
    }
  }
);
}"
13576,"@Override public Multimap<WaveId,WaveletId> apply(final ParticipantId user){
  Multimap<WaveId,WaveletId> userView=HashMultimap.create();
  ExceptionalIterator<WaveId,WaveServerException> waveIds=waveMap.getWaveIds();
  try {
    while (waveIds.hasNext()) {
      WaveId waveId=waveIds.next();
      ImmutableSet<WaveletId> waveletIds=waveMap.lookupWavelets(waveId);
      for (      WaveletId waveletId : waveletIds) {
        WaveletContainer c=waveMap.getLocalWavelet(WaveletName.of(waveId,waveletId));
        try {
          if (!c.hasParticipant(user)) {
            continue;
          }
          userView.put(waveId,waveletId);
        }
 catch (        WaveletStateException e) {
          LOG.warning(""String_Node_Str"" + c.getWaveletName(),e);
        }
      }
    }
  }
 catch (  WaveletStateException e) {
    LOG.severe(String.format(""String_Node_Str"",user.getAddress()),e);
  }
catch (  WaveServerException e) {
    LOG.severe(String.format(""String_Node_Str"",user.getAddress()),e);
  }
  LOG.info(""String_Node_Str"" + user.getAddress() + ""String_Node_Str""+ userView.size());
  return userView;
}","@Override public Multimap<WaveId,WaveletId> apply(final ParticipantId user){
  Multimap<WaveId,WaveletId> userView=HashMultimap.create();
  Map<WaveId,Wave> waves=waveMap.getWaves();
  for (  Map.Entry<WaveId,Wave> entry : waves.entrySet()) {
    Wave wave=entry.getValue();
    for (    WaveletContainer c : wave) {
      WaveletId waveletId=c.getWaveletName().waveletId;
      try {
        if (!c.hasParticipant(user)) {
          continue;
        }
        userView.put(entry.getKey(),waveletId);
      }
 catch (      WaveletStateException e) {
        LOG.warning(""String_Node_Str"" + c.getWaveletName(),e);
      }
    }
  }
  LOG.info(""String_Node_Str"" + user.getAddress() + ""String_Node_Str""+ userView.size());
  return userView;
}"
13577,"@Inject public PerUserWaveViewSubscriber(final WaveMap waveMap){
  explicitPerUserWaveViews=new MapMaker().expireAfterAccess(PER_USER_WAVES_VIEW_CACHE_MINUTES,TimeUnit.MINUTES).makeComputingMap(new Function<ParticipantId,Multimap<WaveId,WaveletId>>(){
    @Override public Multimap<WaveId,WaveletId> apply(    final ParticipantId user){
      Multimap<WaveId,WaveletId> userView=HashMultimap.create();
      ExceptionalIterator<WaveId,WaveServerException> waveIds=waveMap.getWaveIds();
      try {
        while (waveIds.hasNext()) {
          WaveId waveId=waveIds.next();
          ImmutableSet<WaveletId> waveletIds=waveMap.lookupWavelets(waveId);
          for (          WaveletId waveletId : waveletIds) {
            WaveletContainer c=waveMap.getLocalWavelet(WaveletName.of(waveId,waveletId));
            try {
              if (!c.hasParticipant(user)) {
                continue;
              }
              userView.put(waveId,waveletId);
            }
 catch (            WaveletStateException e) {
              LOG.warning(""String_Node_Str"" + c.getWaveletName(),e);
            }
          }
        }
      }
 catch (      WaveletStateException e) {
        LOG.severe(String.format(""String_Node_Str"",user.getAddress()),e);
      }
catch (      WaveServerException e) {
        LOG.severe(String.format(""String_Node_Str"",user.getAddress()),e);
      }
      LOG.info(""String_Node_Str"" + user.getAddress() + ""String_Node_Str""+ userView.size());
      return userView;
    }
  }
);
}","@Inject public PerUserWaveViewSubscriber(final WaveMap waveMap){
  explicitPerUserWaveViews=new MapMaker().expireAfterAccess(PER_USER_WAVES_VIEW_CACHE_MINUTES,TimeUnit.MINUTES).makeComputingMap(new Function<ParticipantId,Multimap<WaveId,WaveletId>>(){
    @Override public Multimap<WaveId,WaveletId> apply(    final ParticipantId user){
      Multimap<WaveId,WaveletId> userView=HashMultimap.create();
      Map<WaveId,Wave> waves=waveMap.getWaves();
      for (      Map.Entry<WaveId,Wave> entry : waves.entrySet()) {
        Wave wave=entry.getValue();
        for (        WaveletContainer c : wave) {
          WaveletId waveletId=c.getWaveletName().waveletId;
          try {
            if (!c.hasParticipant(user)) {
              continue;
            }
            userView.put(entry.getKey(),waveletId);
          }
 catch (          WaveletStateException e) {
            LOG.warning(""String_Node_Str"" + c.getWaveletName(),e);
          }
        }
      }
      LOG.info(""String_Node_Str"" + user.getAddress() + ""String_Node_Str""+ userView.size());
      return userView;
    }
  }
);
}"
13578,"private <T extends WaveletContainer>T getWavelet(WaveletId waveletId,ConcurrentMap<WaveletId,T> waveletsMap) throws WaveletStateException {
  ImmutableSet<WaveletId> storedWavelets;
  try {
    storedWavelets=FutureUtil.getResultOrPropagateException(getLookedupWavelets(),PersistenceException.class);
  }
 catch (  PersistenceException e) {
    throw new WaveletStateException(""String_Node_Str"" + WaveletName.of(waveId,waveletId),e);
  }
catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    throw new WaveletStateException(""String_Node_Str"" + WaveletName.of(waveId,waveletId),e);
  }
  if (storedWavelets != null && !storedWavelets.contains(waveletId) && !waveletsMap.containsKey(waveletId)) {
    return null;
  }
 else {
    T wavelet=waveletsMap.get(waveletId);
    Preconditions.checkNotNull(wavelet,""String_Node_Str"");
    return wavelet;
  }
}","private <T extends WaveletContainer>T getWavelet(WaveletId waveletId,ConcurrentMap<WaveletId,T> waveletsMap) throws WaveletStateException {
  ImmutableSet<WaveletId> storedWavelets;
  try {
    storedWavelets=FutureUtil.getResultOrPropagateException(lookedupWavelets,PersistenceException.class);
  }
 catch (  PersistenceException e) {
    throw new WaveletStateException(""String_Node_Str"" + WaveletName.of(waveId,waveletId),e);
  }
catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    throw new WaveletStateException(""String_Node_Str"" + WaveletName.of(waveId,waveletId),e);
  }
  if (storedWavelets != null && !storedWavelets.contains(waveletId) && !waveletsMap.containsKey(waveletId)) {
    return null;
  }
 else {
    T wavelet=waveletsMap.get(waveletId);
    Preconditions.checkNotNull(wavelet,""String_Node_Str"");
    return wavelet;
  }
}"
13579,"private void createClearFormattingButton(ToolbarView toolbar){
  new ToolbarButtonViewBuilder().setIcon(css.clearFormatting()).applyTo(toolbar.addClickButton(),new ToolbarClickButton.Listener(){
    @Override public void onClicked(){
      EditorAnnotationUtil.clearAnnotationsOverSelection(editor,asArray(StyleAnnotationHandler.key(""String_Node_Str""),StyleAnnotationHandler.key(""String_Node_Str""),StyleAnnotationHandler.key(""String_Node_Str""),StyleAnnotationHandler.key(""String_Node_Str""),StyleAnnotationHandler.key(""String_Node_Str""),StyleAnnotationHandler.key(""String_Node_Str""),StyleAnnotationHandler.key(""String_Node_Str"")));
      createClearHeadingsListener().onClicked();
    }
  }
);
}","private void createClearFormattingButton(ToolbarView toolbar){
  new ToolbarButtonViewBuilder().setIcon(css.clearFormatting()).applyTo(toolbar.addClickButton(),new ToolbarClickButton.Listener(){
    @Override public void onClicked(){
      EditorAnnotationUtil.clearAnnotationsOverSelection(editor,asArray(StyleAnnotationHandler.key(""String_Node_Str""),StyleAnnotationHandler.key(""String_Node_Str""),StyleAnnotationHandler.key(""String_Node_Str""),StyleAnnotationHandler.key(""String_Node_Str""),StyleAnnotationHandler.key(""String_Node_Str""),StyleAnnotationHandler.key(""String_Node_Str""),StyleAnnotationHandler.key(""String_Node_Str""),StyleAnnotationHandler.key(""String_Node_Str"")));
      createClearHeadingsListener().onClicked();
    }
  }
);
}"
13580,"public void testDoPostExecutesAndWritesResponse() throws Exception {
  when(req.getHeaders(""String_Node_Str"")).thenReturn(generateOAuthHeader(ROBOT.getAddress()));
  String operationId=""String_Node_Str"";
  OperationRequest operation=new OperationRequest(""String_Node_Str"",operationId);
  List<OperationRequest> operations=Collections.singletonList(operation);
  when(robotSerializer.deserializeOperations(anyString())).thenReturn(operations);
  String responseValue=""String_Node_Str"";
  when(robotSerializer.serialize(any(),any(Type.class),any(ProtocolVersion.class))).thenReturn(responseValue);
  OperationService service=mock(OperationService.class);
  when(operationRegistry.getServiceFor(any(OperationType.class))).thenReturn(service);
  servlet.doPost(req,resp);
  verify(operationRegistry).getServiceFor(any(OperationType.class));
  verify(service).execute(eq(operation),any(OperationContext.class),eq(ROBOT));
  verify(resp).setStatus(HttpServletResponse.SC_OK);
  assertEquals(""String_Node_Str"",responseValue,outputWriter.toString());
}","public void testDoPostExecutesAndWritesResponse() throws Exception {
  when(req.getHeaders(""String_Node_Str"")).thenReturn(convertRawEnumerationToGeneric(generateOAuthHeader(ROBOT.getAddress())));
  String operationId=""String_Node_Str"";
  OperationRequest operation=new OperationRequest(""String_Node_Str"",operationId);
  List<OperationRequest> operations=Collections.singletonList(operation);
  when(robotSerializer.deserializeOperations(anyString())).thenReturn(operations);
  String responseValue=""String_Node_Str"";
  when(robotSerializer.serialize(any(),any(Type.class),any(ProtocolVersion.class))).thenReturn(responseValue);
  OperationService service=mock(OperationService.class);
  when(operationRegistry.getServiceFor(any(OperationType.class))).thenReturn(service);
  servlet.doPost(req,resp);
  verify(operationRegistry).getServiceFor(any(OperationType.class));
  verify(service).execute(eq(operation),any(OperationContext.class),eq(ROBOT));
  verify(resp).setStatus(HttpServletResponse.SC_OK);
  assertEquals(""String_Node_Str"",responseValue,outputWriter.toString());
}"
13581,"public void testDoPostUnauthorizedWhenParticipantInvalid() throws Exception {
  when(req.getHeaders(""String_Node_Str"")).thenReturn(generateOAuthHeader(""String_Node_Str""));
  servlet.doPost(req,resp);
  verify(resp).setStatus(HttpServletResponse.SC_UNAUTHORIZED);
}","public void testDoPostUnauthorizedWhenParticipantInvalid() throws Exception {
  when(req.getHeaders(""String_Node_Str"")).thenReturn(convertRawEnumerationToGeneric(generateOAuthHeader(""String_Node_Str"")));
  servlet.doPost(req,resp);
  verify(resp).setStatus(HttpServletResponse.SC_UNAUTHORIZED);
}"
13582,"public void testDoPostUnauthorizedWhenValidationFails() throws Exception {
  when(req.getHeaders(""String_Node_Str"")).thenReturn(generateOAuthHeader(ROBOT.getAddress()));
  doThrow(new OAuthException(""String_Node_Str"")).when(validator).validateMessage(any(OAuthMessage.class),any(OAuthAccessor.class));
  servlet.doPost(req,resp);
  verify(resp).setStatus(HttpServletResponse.SC_UNAUTHORIZED);
}","public void testDoPostUnauthorizedWhenValidationFails() throws Exception {
  when(req.getHeaders(""String_Node_Str"")).thenReturn(convertRawEnumerationToGeneric(generateOAuthHeader(ROBOT.getAddress())));
  doThrow(new OAuthException(""String_Node_Str"")).when(validator).validateMessage(any(OAuthMessage.class),any(OAuthAccessor.class));
  servlet.doPost(req,resp);
  verify(resp).setStatus(HttpServletResponse.SC_UNAUTHORIZED);
}"
13583,"public void testDoPostUnauthorizedWhenParticipantUnknown() throws Exception {
  when(req.getHeaders(""String_Node_Str"")).thenReturn(generateOAuthHeader(UNKNOWN.getAddress()));
  servlet.doPost(req,resp);
  verify(resp).setStatus(HttpServletResponse.SC_UNAUTHORIZED);
}","public void testDoPostUnauthorizedWhenParticipantUnknown() throws Exception {
  when(req.getHeaders(""String_Node_Str"")).thenReturn(convertRawEnumerationToGeneric(generateOAuthHeader(UNKNOWN.getAddress())));
  servlet.doPost(req,resp);
  verify(resp).setStatus(HttpServletResponse.SC_UNAUTHORIZED);
}"
13584,"@Override protected void setUp() throws Exception {
  robotSerializer=mock(RobotSerializer.class);
  operationRegistry=mock(OperationServiceRegistry.class);
  validator=mock(OAuthValidator.class);
  EventDataConverterManager converterManager=mock(EventDataConverterManager.class);
  WaveletProvider waveletProvider=mock(WaveletProvider.class);
  ConversationUtil conversationUtil=mock(ConversationUtil.class);
  OAuthServiceProvider oAuthServiceProvider=mock(OAuthServiceProvider.class);
  AccountStore accountStore=mock(AccountStore.class);
  when(accountStore.getAccount(ROBOT)).thenReturn(new RobotAccountDataImpl(ROBOT,""String_Node_Str"",""String_Node_Str"",null,true));
  req=mock(HttpServletRequest.class);
  when(req.getRequestURL()).thenReturn(new StringBuffer(""String_Node_Str""));
  when(req.getHeaderNames()).thenReturn(new StringTokenizer(""String_Node_Str""));
  when(req.getReader()).thenReturn(new BufferedReader(new StringReader(""String_Node_Str"")));
  resp=mock(HttpServletResponse.class);
  outputWriter=new StringWriter();
  when(resp.getWriter()).thenReturn(new PrintWriter(outputWriter));
  servlet=new ActiveApiServlet(robotSerializer,converterManager,waveletProvider,operationRegistry,conversationUtil,oAuthServiceProvider,validator,accountStore);
}","@Override protected void setUp() throws Exception {
  robotSerializer=mock(RobotSerializer.class);
  operationRegistry=mock(OperationServiceRegistry.class);
  validator=mock(OAuthValidator.class);
  EventDataConverterManager converterManager=mock(EventDataConverterManager.class);
  WaveletProvider waveletProvider=mock(WaveletProvider.class);
  ConversationUtil conversationUtil=mock(ConversationUtil.class);
  OAuthServiceProvider oAuthServiceProvider=mock(OAuthServiceProvider.class);
  AccountStore accountStore=mock(AccountStore.class);
  when(accountStore.getAccount(ROBOT)).thenReturn(new RobotAccountDataImpl(ROBOT,""String_Node_Str"",""String_Node_Str"",null,true));
  req=mock(HttpServletRequest.class);
  when(req.getRequestURL()).thenReturn(new StringBuffer(""String_Node_Str""));
  when(req.getHeaderNames()).thenReturn(convertRawEnumerationToGeneric(new StringTokenizer(""String_Node_Str"")));
  when(req.getReader()).thenReturn(new BufferedReader(new StringReader(""String_Node_Str"")));
  resp=mock(HttpServletResponse.class);
  outputWriter=new StringWriter();
  when(resp.getWriter()).thenReturn(new PrintWriter(outputWriter));
  servlet=new ActiveApiServlet(robotSerializer,converterManager,waveletProvider,operationRegistry,conversationUtil,oAuthServiceProvider,validator,accountStore);
}"
13585,"public void testDoPostUnauthorizedWhenMissingToken() throws Exception {
  servlet.doPost(req,resp);
  when(req.getParameterMap()).thenReturn(ImmutableMap.of());
  verify(resp).sendError(eq(HttpServletResponse.SC_UNAUTHORIZED),anyString());
}","public void testDoPostUnauthorizedWhenMissingToken() throws Exception {
  servlet.doPost(req,resp);
  Map<String,String[]> emptyMap=Collections.emptyMap();
  when(req.getParameterMap()).thenReturn(emptyMap);
  verify(resp).sendError(eq(HttpServletResponse.SC_UNAUTHORIZED),anyString());
}"
13586,"@Test public void shouldPersistAttributesForTargeting(){
  HashMap<String,String> map=new HashMap<>();
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  tested.setAttributes(map);
  tested=null;
  tested=new InternalApplicationBootstrapper(new DumbSucessTransport(),testServiceScheduler,testHandlerManager,testHandlerManager.getCustomClock(),bluetoothPlatform,new ResolverConfiguration());
  Assertions.assertThat(tested.attributes.get(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
  Assertions.assertThat(tested.attributes.get(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
}","@Test public void shouldPersistAttributesForTargeting(){
  HashMap<String,String> map=new HashMap<>();
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  InternalApplicationBootstrapper.saveAttributes(map,gson,sharedPreferences);
  tested=null;
  tested=new InternalApplicationBootstrapper(new DumbSucessTransport(),testServiceScheduler,testHandlerManager,testHandlerManager.getCustomClock(),bluetoothPlatform,new ResolverConfiguration());
  Assertions.assertThat(tested.attributes.get(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
  Assertions.assertThat(tested.attributes.get(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
}"
13587,"private void saveAttributes(Map<String,String> attributes){
  String attrs=gson.toJson(attributes);
  Logger.log.logAttributes(""String_Node_Str"" + attributes.size() + ""String_Node_Str"");
  preferences.edit().putString(Constants.SharedPreferencesKeys.Data.TARGETING_ATTRIBUTES,attrs).apply();
}","static void saveAttributes(Map<String,String> incoming,Gson gson,SharedPreferences preferences){
  SortedMap<String,String> attributes=new TreeMap<>();
  attributes.putAll(incoming);
  String json=gson.toJson(attributes);
  Logger.log.logAttributes(""String_Node_Str"" + attributes.size() + ""String_Node_Str"");
  preferences.edit().putString(Constants.SharedPreferencesKeys.Data.TARGETING_ATTRIBUTES,json).apply();
}"
13588,"protected int handleIntentMessage(Intent intent){
  int what=intent.getIntExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,-1);
  Logger.log.serviceHandlesMessage(SensorbergServiceMessage.stringFrom(what));
  if (!isBootstrapperInitialized()) {
    logError(""String_Node_Str"");
    return stopSensorbergService();
  }
switch (what) {
case SensorbergServiceMessage.MSG_BEACON_LAYOUT_UPDATE:
    bootstrapper.updateBeaconLayout();
  break;
case SensorbergServiceMessage.MSG_SDK_SCANNER_MESSAGE:
Bundle message=intent.getParcelableExtra(SensorbergServiceMessage.EXTRA_GENERIC_WHAT);
bootstrapper.scanner.handlePlatformMessage(message);
break;
case SensorbergServiceMessage.MSG_SETTINGS_UPDATE:
bootstrapper.updateSettings();
break;
case SensorbergServiceMessage.MSG_UPLOAD_HISTORY:
bootstrapper.uploadHistory();
break;
case SensorbergServiceMessage.GENERIC_TYPE_BEACON_ACTION:
{
presentBeaconEvent(intent);
break;
}
case SensorbergServiceMessage.MSG_APPLICATION_IN_FOREGROUND:
{
bootstrapper.hostApplicationInForeground();
break;
}
case SensorbergServiceMessage.MSG_APPLICATION_IN_BACKGROUND:
{
bootstrapper.hostApplicationInBackground();
break;
}
case SensorbergServiceMessage.MSG_CONVERSION:
updateActionConversion(intent);
break;
case SensorbergServiceMessage.MSG_ATTRIBUTES:
updateAttributes(intent);
break;
case SensorbergServiceMessage.MSG_SET_API_TOKEN:
{
setApiToken(intent);
break;
}
case SensorbergServiceMessage.MSG_REGISTER_PRESENTATION_DELEGATE:
{
registerPresentationDelegate(intent);
break;
}
case SensorbergServiceMessage.MSG_UNREGISTER_PRESENTATION_DELEGATE:
{
unregisterPresentationDelegate(intent);
break;
}
case SensorbergServiceMessage.MSG_PING:
{
bootstrapper.startScanning();
break;
}
case SensorbergServiceMessage.MSG_BLUETOOTH:
{
processBluetoothStateMessage(intent);
break;
}
case SensorbergServiceMessage.MSG_SET_API_ADVERTISING_IDENTIFIER:
{
setAdvertisingIdentifier(intent);
break;
}
case SensorbergServiceMessage.MSG_LOCATION_SERVICES_IS_SET:
{
if (intent.getBooleanExtra(SensorbergServiceMessage.EXTRA_LOCATION_PERMISSION,false)) {
Logger.log.debug(""String_Node_Str"");
bootstrapper.stopScanning();
}
 else {
bootstrapper.startScanning();
bootstrapper.startGeofences();
Logger.log.debug(""String_Node_Str"");
}
}
case SensorbergServiceMessage.MSG_LOCATION_UPDATED:
{
onLocationChanged(intent);
break;
}
case SensorbergServiceMessage.MSG_LOCATION_ENABLED:
{
if (bootstrapper.geofenceAvailable) {
bootstrapper.geofenceManager.ping();
}
break;
}
case SensorbergServiceMessage.MSG_GEOFENCE_EVENT:
{
onGeofenceEvent(intent);
break;
}
case SensorbergServiceMessage.MSG_GEOFENCE_NOT_AVAILABLE:
{
onGeofenceNotAvailable(intent);
break;
}
}
return START_STICKY;
}","protected int handleIntentMessage(Intent intent){
  int what=intent.getIntExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,-1);
  Logger.log.serviceHandlesMessage(SensorbergServiceMessage.stringFrom(what));
  if (!isBootstrapperInitialized()) {
    logError(""String_Node_Str"");
    return stopSensorbergService();
  }
switch (what) {
case SensorbergServiceMessage.MSG_BEACON_LAYOUT_UPDATE:
    bootstrapper.updateBeaconLayout();
  break;
case SensorbergServiceMessage.MSG_SDK_SCANNER_MESSAGE:
Bundle message=intent.getParcelableExtra(SensorbergServiceMessage.EXTRA_GENERIC_WHAT);
bootstrapper.scanner.handlePlatformMessage(message);
break;
case SensorbergServiceMessage.MSG_SETTINGS_UPDATE:
bootstrapper.updateSettings();
break;
case SensorbergServiceMessage.MSG_UPLOAD_HISTORY:
bootstrapper.uploadHistory();
break;
case SensorbergServiceMessage.GENERIC_TYPE_BEACON_ACTION:
{
presentBeaconEvent(intent);
break;
}
case SensorbergServiceMessage.MSG_APPLICATION_IN_FOREGROUND:
{
bootstrapper.hostApplicationInForeground();
break;
}
case SensorbergServiceMessage.MSG_APPLICATION_IN_BACKGROUND:
{
bootstrapper.hostApplicationInBackground();
break;
}
case SensorbergServiceMessage.MSG_CONVERSION:
updateActionConversion(intent);
break;
case MSG_ATTRIBUTES:
bootstrapper.reloadAttributes();
break;
case SensorbergServiceMessage.MSG_SET_API_TOKEN:
{
setApiToken(intent);
break;
}
case SensorbergServiceMessage.MSG_REGISTER_PRESENTATION_DELEGATE:
{
registerPresentationDelegate(intent);
break;
}
case SensorbergServiceMessage.MSG_UNREGISTER_PRESENTATION_DELEGATE:
{
unregisterPresentationDelegate(intent);
break;
}
case SensorbergServiceMessage.MSG_PING:
{
bootstrapper.startScanning();
break;
}
case SensorbergServiceMessage.MSG_BLUETOOTH:
{
processBluetoothStateMessage(intent);
break;
}
case SensorbergServiceMessage.MSG_SET_API_ADVERTISING_IDENTIFIER:
{
setAdvertisingIdentifier(intent);
break;
}
case SensorbergServiceMessage.MSG_LOCATION_SERVICES_IS_SET:
{
if (intent.getBooleanExtra(SensorbergServiceMessage.EXTRA_LOCATION_PERMISSION,false)) {
Logger.log.debug(""String_Node_Str"");
bootstrapper.stopScanning();
}
 else {
bootstrapper.startScanning();
bootstrapper.startGeofences();
Logger.log.debug(""String_Node_Str"");
}
}
case SensorbergServiceMessage.MSG_LOCATION_UPDATED:
{
onLocationChanged(intent);
break;
}
case SensorbergServiceMessage.MSG_LOCATION_ENABLED:
{
if (bootstrapper.geofenceAvailable) {
bootstrapper.geofenceManager.ping();
}
break;
}
case SensorbergServiceMessage.MSG_GEOFENCE_EVENT:
{
onGeofenceEvent(intent);
break;
}
case SensorbergServiceMessage.MSG_GEOFENCE_NOT_AVAILABLE:
{
onGeofenceNotAvailable(intent);
break;
}
}
return START_STICKY;
}"
13589,"@SuppressWarnings(""String_Node_Str"") @Override public int onStartCommand(Intent intent,int flags,int startId){
  Logger.log.logServiceState(""String_Node_Str"");
  if (!bluetoothPlatform.isBluetoothLowEnergySupported()) {
    logError(""String_Node_Str"");
    return stopSensorbergService();
  }
  if (!platform.registerBroadcastReceiver()) {
    logError(""String_Node_Str"");
    return stopSensorbergService();
  }
  if (!new PermissionChecker(this).hasScanPermissionCheckAndroid6()) {
    logError(""String_Node_Str"");
    if (intent != null) {
      String apikey=intent.getStringExtra(SensorbergServiceMessage.EXTRA_API_KEY);
      if (apikey != null && !apikey.isEmpty()) {
        ResolverConfiguration configuration=new ResolverConfiguration();
        configuration.setApiToken(apikey);
        persistConfiguration(configuration);
      }
    }
    return stopSensorbergService();
  }
  SensorbergSdk.init(getBaseContext());
  if (intent == null) {
    return restartSensorbergService();
  }
 else {
    return handleIntent(intent);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public int onStartCommand(Intent intent,int flags,int startId){
  Logger.log.logServiceState(""String_Node_Str"");
  if (intent != null && intent.getIntExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,0) == MSG_ATTRIBUTES) {
    saveAttributes(intent);
  }
  if (!bluetoothPlatform.isBluetoothLowEnergySupported()) {
    logError(""String_Node_Str"");
    return stopSensorbergService();
  }
  if (!platform.registerBroadcastReceiver()) {
    logError(""String_Node_Str"");
    return stopSensorbergService();
  }
  if (!new PermissionChecker(this).hasScanPermissionCheckAndroid6()) {
    logError(""String_Node_Str"");
    if (intent != null) {
      String apikey=intent.getStringExtra(SensorbergServiceMessage.EXTRA_API_KEY);
      if (apikey != null && !apikey.isEmpty()) {
        ResolverConfiguration configuration=new ResolverConfiguration();
        configuration.setApiToken(apikey);
        persistConfiguration(configuration);
      }
    }
    return stopSensorbergService();
  }
  SensorbergSdk.init(getBaseContext());
  if (intent == null) {
    return restartSensorbergService();
  }
 else {
    return handleIntent(intent);
  }
}"
13590,"@Test public void still_sees_exit_events_when_bluetooth_is_restarted_in_a_short_interval(){
  ScannerListener mockScannerListener=mock(ScannerListener.class);
  tested.addScannerListener(mockScannerListener);
  bluetoothPlatform.fakeIBeaconSighting();
  verify(mockScannerListener).onScanEventDetected(isEntryEvent());
  tested.stop();
  reset(mockScannerListener);
  testHandlerManager.getCustomClock().increaseTimeInMillis(RANDOM_VALUE_THAT_IS_SHORTER_THAN_CLEAN_BEACONMAP_ON_RESTART_TIMEOUT_BUT_LONGER_THAN_EXIT_EVENT_DELAY);
  tested.start();
  verify(mockScannerListener,never()).onScanEventDetected(isEntryEvent());
  verify(mockScannerListener,never()).onScanEventDetected(isExitEvent());
  long start=testHandlerManager.getCustomClock().now();
  while (testHandlerManager.getCustomClock().now() < start + Utils.EXIT_TIME) {
    testHandlerManager.getCustomClock().increaseTimeInMillis(Utils.ONE_ADVERTISEMENT_INTERVAL);
  }
  verify(mockScannerListener,never()).onScanEventDetected(isExitEvent());
  testHandlerManager.getCustomClock().increaseTimeInMillis(1);
  verify(mockScannerListener).onScanEventDetected(isExitEvent());
  verify(mockScannerListener,never()).onScanEventDetected(isEntryEvent());
}","@Test public void still_sees_exit_events_when_bluetooth_is_restarted_in_a_short_interval(){
  ScannerListener mockScannerListener=mock(ScannerListener.class);
  tested.addScannerListener(mockScannerListener);
  bluetoothPlatform.fakeIBeaconSighting();
  verify(mockScannerListener).onScanEventDetected(isEntryEvent());
  tested.stop();
  reset(mockScannerListener);
  testHandlerManager.getCustomClock().increaseTimeInMillis(RANDOM_VALUE_THAT_IS_SHORTER_THAN_CLEAN_BEACONMAP_ON_RESTART_TIMEOUT_BUT_LONGER_THAN_EXIT_EVENT_DELAY);
  tested.start();
  verify(mockScannerListener,never()).onScanEventDetected(isEntryEvent());
  verify(mockScannerListener,never()).onScanEventDetected(isExitEvent());
  long start=testHandlerManager.getCustomClock().now();
  while (testHandlerManager.getCustomClock().now() < start + Utils.GRACE_TIME - Utils.ONE_ADVERTISEMENT_INTERVAL) {
    testHandlerManager.getCustomClock().increaseTimeInMillis(Utils.ONE_ADVERTISEMENT_INTERVAL);
  }
  verify(mockScannerListener).onScanEventDetected(isExitEvent());
}"
13591,"@Override public void scheduleAtFixedRate(TimerTask timerTask,int when,long interval){
  this.timerTask=timerTask;
}","@Override public void scheduleAtFixedRate(TimerTask timerTask,long when,long interval){
  this.timerTask=timerTask;
}"
13592,"@Override public void scheduleAtFixedRate(TimerTask timerTask,int when,long interval){
  if (timer != null) {
    timer.cancel();
    timer=null;
    Logger.log.logError(""String_Node_Str"");
  }
  timer=new Timer();
  timer.scheduleAtFixedRate(timerTask,when,interval);
}","@Override public void scheduleAtFixedRate(TimerTask timerTask,long when,long interval){
  if (timer != null) {
    timer.cancel();
    timer=null;
    Logger.log.logError(""String_Node_Str"");
  }
  timer=new Timer();
  timer.scheduleAtFixedRate(timerTask,when,interval);
}"
13593,"void scheduleAtFixedRate(TimerTask timerTask,int when,long interval);","void scheduleAtFixedRate(TimerTask timerTask,long when,long interval);"
13594,"@Override public void handleMessage(Message message){
  ScannerEvent queueEvent=new ScannerEvent(message.what,message.obj);
switch (queueEvent.getType()) {
case ScannerEvent.LOGICAL_SCAN_START_REQUESTED:
{
      if (!scanning) {
        lastExitCheckTimestamp=clock.now();
        if (lastStopTimestamp != NEVER_STOPPED && lastExitCheckTimestamp - lastStopTimestamp > settingsManager.getCleanBeaconMapRestartTimeout()) {
          clearCache();
          Logger.log.scannerStateChange(""String_Node_Str"");
        }
        started=clock.now();
        scanning=true;
        runLoop.sendMessage(ScannerEvent.UN_PAUSE_SCAN);
      }
      break;
    }
case ScannerEvent.PAUSE_SCAN:
{
    bluetoothPlatform.stopLeScan();
    Logger.log.scannerStateChange(""String_Node_Str"" + waitTime + ""String_Node_Str"");
    scheduleExecution(ScannerEvent.UN_PAUSE_SCAN,waitTime);
    runLoop.cancelFixedRateExecution();
    break;
  }
case ScannerEvent.UN_PAUSE_SCAN:
{
  lastScanStart=clock.now();
  lastBreakLength=clock.now() - lastExitCheckTimestamp;
  Logger.log.scannerStateChange(""String_Node_Str"" + lastBreakLength + ""String_Node_Str"");
  if (scanning) {
    Logger.log.debug(""String_Node_Str"" + Boolean.toString(scanning));
    Logger.log.scannerStateChange(""String_Node_Str"" + scanTime + ""String_Node_Str"");
    bluetoothPlatform.startLeScan(scanCallback);
    scheduleExecution(ScannerEvent.PAUSE_SCAN,scanTime);
    runLoop.scheduleAtFixedRate(new TimerTask(){
      @Override public void run(){
        loop();
      }
    }
,0,TimeConstants.ONE_SECOND);
  }
  break;
}
case ScannerEvent.SCAN_STOP_REQUESTED:
{
started=0;
scanning=false;
clearScheduledExecutions();
bluetoothPlatform.stopLeScan();
lastStopTimestamp=clock.now();
runLoop.cancelFixedRateExecution();
Logger.log.scannerStateChange(""String_Node_Str"");
break;
}
case ScannerEvent.EVENT_DETECTED:
{
ScanEvent scanEvent=(ScanEvent)queueEvent.getData();
synchronized (listenersMonitor) {
for (ScannerListener listener : listeners) {
  listener.onScanEventDetected(scanEvent);
}
}
break;
}
case ScannerEvent.RSSI_UPDATED:
{
Pair<BeaconId,Integer> value=(Pair<BeaconId,Integer>)queueEvent.getData();
this.rssiListener.onRssiUpdated(value.first,value.second);
break;
}
default :
{
throw new IllegalArgumentException(""String_Node_Str"" + queueEvent.getData());
}
}
}","@Override public void handleMessage(Message message){
  ScannerEvent queueEvent=new ScannerEvent(message.what,message.obj);
switch (queueEvent.getType()) {
case ScannerEvent.LOGICAL_SCAN_START_REQUESTED:
{
      if (!scanning) {
        lastExitCheckTimestamp=clock.now();
        if (lastStopTimestamp != NEVER_STOPPED && lastExitCheckTimestamp - lastStopTimestamp > settingsManager.getCleanBeaconMapRestartTimeout()) {
          clearCache();
          Logger.log.scannerStateChange(""String_Node_Str"");
        }
        started=clock.now();
        scanning=true;
        runLoop.sendMessage(ScannerEvent.UN_PAUSE_SCAN);
      }
      break;
    }
case ScannerEvent.PAUSE_SCAN:
{
    bluetoothPlatform.stopLeScan();
    Logger.log.scannerStateChange(""String_Node_Str"" + waitTime + ""String_Node_Str"");
    scheduleExecution(ScannerEvent.UN_PAUSE_SCAN,waitTime);
    runLoop.cancelFixedRateExecution();
    break;
  }
case ScannerEvent.UN_PAUSE_SCAN:
{
  lastScanStart=clock.now();
  lastBreakLength=clock.now() - lastExitCheckTimestamp;
  Logger.log.scannerStateChange(""String_Node_Str"" + lastBreakLength + ""String_Node_Str"");
  if (scanning) {
    Logger.log.debug(""String_Node_Str"" + Boolean.toString(scanning));
    Logger.log.scannerStateChange(""String_Node_Str"" + scanTime + ""String_Node_Str""+ exitGraceTime+ ""String_Node_Str"");
    bluetoothPlatform.startLeScan(scanCallback);
    scheduleExecution(ScannerEvent.PAUSE_SCAN,scanTime);
    runLoop.scheduleAtFixedRate(new TimerTask(){
      @Override public void run(){
        loop();
      }
    }
,exitGraceTime,TimeConstants.ONE_SECOND);
  }
  break;
}
case ScannerEvent.SCAN_STOP_REQUESTED:
{
started=0;
scanning=false;
clearScheduledExecutions();
bluetoothPlatform.stopLeScan();
lastStopTimestamp=clock.now();
runLoop.cancelFixedRateExecution();
Logger.log.scannerStateChange(""String_Node_Str"");
break;
}
case ScannerEvent.EVENT_DETECTED:
{
ScanEvent scanEvent=(ScanEvent)queueEvent.getData();
synchronized (listenersMonitor) {
for (ScannerListener listener : listeners) {
  listener.onScanEventDetected(scanEvent);
}
}
break;
}
case ScannerEvent.RSSI_UPDATED:
{
Pair<BeaconId,Integer> value=(Pair<BeaconId,Integer>)queueEvent.getData();
this.rssiListener.onRssiUpdated(value.first,value.second);
break;
}
default :
{
throw new IllegalArgumentException(""String_Node_Str"" + queueEvent.getData());
}
}
}"
13595,"private void checkAndExitEnteredBeacons(){
  final long now=clock.now();
  lastExitCheckTimestamp=now;
synchronized (enteredBeaconsMonitor) {
    if (enteredBeacons.size() > 0) {
      enteredBeacons.filter(new BeaconMap.Filter(){
        public boolean filter(        EventEntry beaconEntry,        BeaconId beaconId){
          long timeSinceWeSawTheBeacon=now - lastBreakLength - beaconEntry.getLastBeaconTime();
          if (timeSinceWeSawTheBeacon > settingsManager.getExitTimeoutMillis()) {
            ScanEvent scanEvent=new ScanEvent(beaconId,now,false,locationHelper.getGeohash(),beaconEntry.getPairingId());
            runLoop.sendMessage(ScannerEvent.EVENT_DETECTED,scanEvent);
            Logger.log.beaconResolveState(scanEvent,""String_Node_Str"" + (int)(timeSinceWeSawTheBeacon / 1000) + ""String_Node_Str"");
            return true;
          }
          return false;
        }
      }
);
    }
  }
}","private void checkAndExitEnteredBeacons(){
  final long now=clock.now();
  lastExitCheckTimestamp=now;
synchronized (enteredBeaconsMonitor) {
    if (enteredBeacons.size() > 0) {
      enteredBeacons.filter(new BeaconMap.Filter(){
        public boolean filter(        EventEntry beaconEntry,        BeaconId beaconId){
          long timeSinceWeSawTheBeacon=now - beaconEntry.getLastBeaconTime();
          if (timeSinceWeSawTheBeacon > settingsManager.getExitTimeoutMillis()) {
            ScanEvent scanEvent=new ScanEvent(beaconId,now,false,locationHelper.getGeohash(),beaconEntry.getPairingId());
            runLoop.sendMessage(ScannerEvent.EVENT_DETECTED,scanEvent);
            Logger.log.beaconResolveState(scanEvent,""String_Node_Str"" + (int)(timeSinceWeSawTheBeacon / 1000) + ""String_Node_Str"");
            return true;
          }
          return false;
        }
      }
);
    }
  }
}"
13596,"@Override public void hostApplicationInForeground(){
  if (isNotSetupForForegroundScanning()) {
    waitTime=settingsManager.getForeGroundWaitTime();
    scanTime=settingsManager.getForeGroundScanTime();
    if (scanning) {
      long lastWaitTime=clock.now() - lastExitCheckTimestamp;
      clearScheduledExecutions();
      if (lastWaitTime > waitTime) {
        Logger.log.scannerStateChange(""String_Node_Str"");
        runLoop.sendMessage(ScannerEvent.UN_PAUSE_SCAN);
      }
 else {
        long timeRemainingToWait=waitTime - lastWaitTime;
        Logger.log.scannerStateChange(""String_Node_Str"" + timeRemainingToWait + ""String_Node_Str"");
        scheduleExecution(ScannerEvent.UN_PAUSE_SCAN,waitTime - lastWaitTime);
      }
    }
  }
}","@Override public void hostApplicationInForeground(){
  if (isNotSetupForForegroundScanning()) {
    waitTime=settingsManager.getForeGroundWaitTime();
    scanTime=settingsManager.getForeGroundScanTime();
    exitGraceTime=settingsManager.getExitForegroundGraceMillis();
    if (exitGraceTime >= scanTime) {
      exitGraceTime=scanTime / 2;
    }
    if (scanning) {
      long lastWaitTime=clock.now() - lastExitCheckTimestamp;
      clearScheduledExecutions();
      if (lastWaitTime > waitTime) {
        Logger.log.scannerStateChange(""String_Node_Str"");
        runLoop.sendMessage(ScannerEvent.UN_PAUSE_SCAN);
      }
 else {
        long timeRemainingToWait=waitTime - lastWaitTime;
        Logger.log.scannerStateChange(""String_Node_Str"" + timeRemainingToWait + ""String_Node_Str"");
        scheduleExecution(ScannerEvent.UN_PAUSE_SCAN,waitTime - lastWaitTime);
      }
    }
  }
}"
13597,"public boolean filter(EventEntry beaconEntry,BeaconId beaconId){
  long timeSinceWeSawTheBeacon=now - lastBreakLength - beaconEntry.getLastBeaconTime();
  if (timeSinceWeSawTheBeacon > settingsManager.getExitTimeoutMillis()) {
    ScanEvent scanEvent=new ScanEvent(beaconId,now,false,locationHelper.getGeohash(),beaconEntry.getPairingId());
    runLoop.sendMessage(ScannerEvent.EVENT_DETECTED,scanEvent);
    Logger.log.beaconResolveState(scanEvent,""String_Node_Str"" + (int)(timeSinceWeSawTheBeacon / 1000) + ""String_Node_Str"");
    return true;
  }
  return false;
}","public boolean filter(EventEntry beaconEntry,BeaconId beaconId){
  long timeSinceWeSawTheBeacon=now - beaconEntry.getLastBeaconTime();
  if (timeSinceWeSawTheBeacon > settingsManager.getExitTimeoutMillis()) {
    ScanEvent scanEvent=new ScanEvent(beaconId,now,false,locationHelper.getGeohash(),beaconEntry.getPairingId());
    runLoop.sendMessage(ScannerEvent.EVENT_DETECTED,scanEvent);
    Logger.log.beaconResolveState(scanEvent,""String_Node_Str"" + (int)(timeSinceWeSawTheBeacon / 1000) + ""String_Node_Str"");
    return true;
  }
  return false;
}"
13598,"@Override public void hostApplicationInBackground(){
  waitTime=settingsManager.getBackgroundWaitTime();
  scanTime=settingsManager.getBackgroundScanTime();
  if ((clock.now() - lastScanStart) > scanTime) {
    Logger.log.scannerStateChange(""String_Node_Str"");
    clearScheduledExecutions();
    runLoop.sendMessage(ScannerEvent.PAUSE_SCAN);
  }
}","@Override public void hostApplicationInBackground(){
  waitTime=settingsManager.getBackgroundWaitTime();
  scanTime=settingsManager.getBackgroundScanTime();
  exitGraceTime=settingsManager.getExitBackgroundGraceMillis();
  if (exitGraceTime >= scanTime) {
    exitGraceTime=scanTime / 2;
  }
  if ((clock.now() - lastScanStart) > scanTime) {
    Logger.log.scannerStateChange(""String_Node_Str"");
    clearScheduledExecutions();
    runLoop.sendMessage(ScannerEvent.PAUSE_SCAN);
  }
}"
13599,"private void loop(){
  if (clock.now() > (started + settingsManager.getExitTimeoutMillis())) {
    if (bluetoothPlatform.isLeScanRunning()) {
      checkAndExitEnteredBeacons();
    }
  }
}","private void loop(){
  if (bluetoothPlatform.isLeScanRunning()) {
    checkAndExitEnteredBeacons();
  }
}"
13600,"AbstractScanner(SettingsManager stgMgr,boolean shouldRestoreBeaconStates,Clock clk,FileManager fileManager,ServiceScheduler scheduler,HandlerManager handlerManager,BluetoothPlatform btPlatform){
  settingsManager=stgMgr;
  clock=clk;
  serviceScheduler=scheduler;
  scanning=false;
  runLoop=handlerManager.getScannerRunLoop(this);
  bluetoothPlatform=btPlatform;
  File beaconFile=shouldRestoreBeaconStates ? fileManager.getFile(""String_Node_Str"") : null;
  enteredBeacons=new BeaconMap(fileManager,beaconFile);
  waitTime=settingsManager.getBackgroundWaitTime();
  scanTime=settingsManager.getBackgroundScanTime();
  SensorbergSdk.getComponent().inject(this);
}","AbstractScanner(SettingsManager stgMgr,boolean shouldRestoreBeaconStates,Clock clk,FileManager fileManager,ServiceScheduler scheduler,HandlerManager handlerManager,BluetoothPlatform btPlatform){
  settingsManager=stgMgr;
  clock=clk;
  serviceScheduler=scheduler;
  scanning=false;
  runLoop=handlerManager.getScannerRunLoop(this);
  bluetoothPlatform=btPlatform;
  File beaconFile=shouldRestoreBeaconStates ? fileManager.getFile(""String_Node_Str"") : null;
  enteredBeacons=new BeaconMap(fileManager,beaconFile);
  waitTime=settingsManager.getBackgroundWaitTime();
  scanTime=settingsManager.getBackgroundScanTime();
  exitGraceTime=settingsManager.getExitBackgroundGraceMillis();
  if (exitGraceTime >= scanTime) {
    exitGraceTime=scanTime / 2;
  }
  SensorbergSdk.getComponent().inject(this);
}"
13601,"/** 
 * Sends a flag for indicating whether to show a permissions dialogue or not.
 * @param context
 * @param toShow
 */
private void shouldDisplayPermission(Context context,boolean toShow){
  Intent service=new Intent(context,SensorbergServiceMessage.class);
  service.putExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,SensorbergServiceMessage.MSG_LOCATION_SERVICES_IS_SET);
  service.putExtra(SensorbergServiceMessage.EXTRA_LOCATION_PERMISSION,toShow);
  context.startService(service);
}","/** 
 * Sends a flag for indicating whether to show a permissions dialogue or not.
 * @param context
 * @param toShow
 */
private void shouldDisplayPermission(Context context,boolean toShow){
  Intent service=new Intent(context,SensorbergService.class);
  service.putExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,SensorbergServiceMessage.MSG_LOCATION_SERVICES_IS_SET);
  service.putExtra(SensorbergServiceMessage.EXTRA_LOCATION_PERMISSION,toShow);
  context.startService(service);
}"
13602,"@SuppressWarnings(""String_Node_Str"") @Override public int onStartCommand(Intent intent,int flags,int startId){
  Logger.log.logServiceState(""String_Node_Str"");
  if (!bluetoothPlatform.isBluetoothLowEnergySupported()) {
    logError(""String_Node_Str"");
    return stopSensorbergService();
  }
  if (!platform.registerBroadcastReceiver()) {
    logError(""String_Node_Str"");
    return stopSensorbergService();
  }
  SensorbergSdk.init(getBaseContext());
  if (intent == null) {
    return restartSensorbergService();
  }
 else {
    return handleIntent(intent);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public int onStartCommand(Intent intent,int flags,int startId){
  Logger.log.logServiceState(""String_Node_Str"");
  if (!bluetoothPlatform.isBluetoothLowEnergySupported()) {
    logError(""String_Node_Str"");
    return stopSensorbergService();
  }
  if (!platform.registerBroadcastReceiver()) {
    logError(""String_Node_Str"");
    return stopSensorbergService();
  }
  if (!new PermissionChecker(this).hasScanPermissionCheckAndroid6()) {
    logError(""String_Node_Str"");
    if (intent != null) {
      String apikey=intent.getStringExtra(SensorbergServiceMessage.EXTRA_API_KEY);
      if (apikey != null && !apikey.isEmpty()) {
        ResolverConfiguration configuration=new ResolverConfiguration();
        configuration.setApiToken(apikey);
        persistConfiguration(configuration);
      }
    }
    return stopSensorbergService();
  }
  SensorbergSdk.init(getBaseContext());
  if (intent == null) {
    return restartSensorbergService();
  }
 else {
    return handleIntent(intent);
  }
}"
13603,"/** 
 * Call this to let SDK know you've attempted to show the   {@link com.sensorberg.sdk.action.Action} to the user.This is for situations when you are not certain if user have seen the Action, like showing notification on the status bar.
 * @param actionUUID UUID of the {@link com.sensorberg.sdk.action.Action} that was attempted to be shown.
 * @param context Caller's context.
 */
public static void notifyActionShowAttempt(UUID actionUUID,Context context){
  Intent intent=SensorbergServiceIntents.getConversionIntent(context,actionUUID,ActionConversion.TYPE_IGNORED);
  context.startService(intent);
}","/** 
 * Call this to let SDK know you've attempted to show the   {@link com.sensorberg.sdk.action.Action} to the user.This is for situations when you are not certain if user have seen the Action, like showing notification on the status bar.
 * @param actionUUID UUID of the {@link com.sensorberg.sdk.action.Action} that was attempted to be shown.
 * @param context    Caller's context.
 */
public static void notifyActionShowAttempt(UUID actionUUID,Context context){
  Intent intent=SensorbergServiceIntents.getConversionIntent(context,actionUUID,ActionConversion.TYPE_IGNORED);
  context.startService(intent);
}"
13604,"/** 
 * Call this to let SDK know the user haven't seen and will not be able to see the   {@link com.sensorberg.sdk.action.Action} in future.This is for situations where e.g. the notification with action is dismissed by the user and you won't show this action to the user again. Calling this after  {@link #notifyActionSuccess(UUID,Context) notifyActionSuccess} has no effect.
 * @param actionUUID UUID of the {@link com.sensorberg.sdk.action.Action} that user haven't seen and will not see in the future.
 * @param context Caller's context.
 */
protected static void notifyActionRejected(UUID actionUUID,Context context){
}","/** 
 * Call this to let SDK know the user haven't seen and will not be able to see the   {@link com.sensorberg.sdk.action.Action} in future.This is for situations where e.g. the notification with action is dismissed by the user and you won't show this action to the user again. Calling this after  {@link #notifyActionSuccess(UUID,Context) notifyActionSuccess} has no effect.
 * @param actionUUID UUID of the {@link com.sensorberg.sdk.action.Action} that user haven't seen and will not see in the future.
 * @param context    Caller's context.
 */
protected static void notifyActionRejected(UUID actionUUID,Context context){
}"
13605,"public void changeAPIToken(String newApiToken){
  context.startService(SensorbergServiceIntents.getApiTokenIntent(context,newApiToken));
}","public void changeAPIToken(String newApiToken){
  if (TextUtils.isEmpty(newApiToken)) {
    context.startService(SensorbergServiceIntents.getApiTokenIntent(context,newApiToken));
  }
 else {
    Logger.log.logError(""String_Node_Str"");
  }
}"
13606,"/** 
 * Constructor to be used for starting the SDK.
 * @param ctx {@code Context} Context used for starting the service.
 * @param apiKey {@code String} Your API key that you can get from your Sensorberg dashboard.
 */
public SensorbergSdk(Context ctx,String apiKey){
  init(ctx);
  getComponent().inject(this);
  activateService(apiKey);
}","/** 
 * Constructor to be used for starting the SDK.
 * @param ctx    {@code Context} Context used for starting the service.
 * @param apiKey {@code String} Your API key that you can get from your Sensorberg dashboard.
 */
public SensorbergSdk(Context ctx,String apiKey){
  init(ctx);
  getComponent().inject(this);
  activateService(apiKey);
}"
13607,"/** 
 * Call this to let SDK know you've confirmed that user has seen the   {@link com.sensorberg.sdk.action.Action} and acted on it.This is for situation where e.g. user tapped the notification and was redirected to website.
 * @param actionUUID UUID of the {@link com.sensorberg.sdk.action.Action} that user has seen and acted on.
 * @param context Caller's context.
 */
public static void notifyActionSuccess(UUID actionUUID,Context context){
  Intent intent=SensorbergServiceIntents.getConversionIntent(context,actionUUID,ActionConversion.TYPE_SUCCESS);
  context.startService(intent);
}","/** 
 * Call this to let SDK know you've confirmed that user has seen the   {@link com.sensorberg.sdk.action.Action} and acted on it.This is for situation where e.g. user tapped the notification and was redirected to website.
 * @param actionUUID UUID of the {@link com.sensorberg.sdk.action.Action} that user has seen and acted on.
 * @param context    Caller's context.
 */
public static void notifyActionSuccess(UUID actionUUID,Context context){
  Intent intent=SensorbergServiceIntents.getConversionIntent(context,actionUUID,ActionConversion.TYPE_SUCCESS);
  context.startService(intent);
}"
13608,"public void setApiToken(String apiToken){
  transport.setApiToken(apiToken);
  beaconActionHistoryPublisher.publishHistory();
  if (resolver.configuration.setApiToken(apiToken)) {
    unscheduleAllPendingActions();
    beaconActionHistoryPublisher.deleteAllObjects();
  }
}","public void setApiToken(String apiToken){
  if (resolver.configuration.setApiToken(apiToken)) {
    Logger.log.applicationStateChanged(""String_Node_Str"");
    scanner.stop();
    unscheduleAllPendingActions();
    beaconActionHistoryPublisher.deleteAllObjects();
    transport.setApiToken(apiToken);
    updateSettings();
    updateBeaconLayout();
    scanner.clearCache();
    scanner.start();
  }
}"
13609,"@SuppressWarnings(""String_Node_Str"") public static List<BroadcastReceiver> findBroadcastReceiver(Context context){
  List<BroadcastReceiver> result=new ArrayList<>();
  List<ResolveInfo> infos=context.getPackageManager().queryBroadcastReceivers(actionIntent,PackageManager.SIGNATURE_MATCH);
  for (  ResolveInfo resolveInfo : infos) {
    try {
      if (!resolveInfo.activityInfo.processName.endsWith(""String_Node_Str"")) {
        continue;
      }
      BroadcastReceiver broadcastReceiver=(BroadcastReceiver)Class.forName(resolveInfo.activityInfo.name).newInstance();
      result.add(broadcastReceiver);
    }
 catch (    Exception e) {
      Logger.log.logError(""String_Node_Str"",e);
    }
  }
  return result;
}","@SuppressWarnings(""String_Node_Str"") public static List<BroadcastReceiver> findBroadcastReceiver(Context context){
  List<BroadcastReceiver> result=new ArrayList<>();
  Intent actionIntent=new Intent();
  actionIntent.setPackage(context.getPackageName());
  actionIntent.setAction(actionString);
  List<ResolveInfo> infos=context.getPackageManager().queryBroadcastReceivers(actionIntent,0);
  for (  ResolveInfo resolveInfo : infos) {
    try {
      if (!resolveInfo.activityInfo.processName.endsWith(""String_Node_Str"")) {
        continue;
      }
      if (!resolveInfo.activityInfo.packageName.equals(context.getPackageName())) {
        continue;
      }
      BroadcastReceiver broadcastReceiver=(BroadcastReceiver)Class.forName(resolveInfo.activityInfo.name).newInstance();
      result.add(broadcastReceiver);
    }
 catch (    Exception e) {
      Logger.log.logError(""String_Node_Str"",e);
    }
  }
  return result;
}"
13610,"@Override public int compare(Location t1,Location t2){
  if (t1.getTime() > t2.getTime()) {
    return 1;
  }
  if (t2.getTime() > t1.getTime()) {
    return -1;
  }
  return 0;
}","@Override public int compare(Location t1,Location t2){
  if (t1.getTime() > t2.getTime()) {
    return -1;
  }
  if (t2.getTime() > t1.getTime()) {
    return 1;
  }
  return 0;
}"
13611,"@Test public void should_handle_intent_with_generic_noop_message(){
  Intent sensorbergServiceStartIntent=new Intent(InstrumentationRegistry.getContext(),SensorbergService.class);
  sensorbergServiceStartIntent.putExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,-1);
  int handleIntentResult=tested.handleIntent(sensorbergServiceStartIntent);
  Assertions.assertThat(handleIntentResult).isEqualTo(SensorbergService.START_STICKY);
  Assertions.assertThat(tested.bootstrapper).isNotNull();
  Mockito.verify(tested,Mockito.times(1)).handleDebuggingIntent(sensorbergServiceStartIntent,tested,true);
  Mockito.verify(tested,Mockito.times(1)).handleIntentEvenIfNoBootstrapperPresent(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(1)).updateDiskConfiguration(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(1)).handleIntentMessage(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(0)).startSensorbergService(anyString());
  Mockito.verify(tested,Mockito.times(0)).stopSensorbergService();
}","@Test public void should_handle_intent_with_generic_noop_message(){
  Intent sensorbergServiceStartIntent=new Intent(InstrumentationRegistry.getContext(),SensorbergService.class);
  sensorbergServiceStartIntent.putExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,-1);
  int handleIntentResult=tested.handleIntent(sensorbergServiceStartIntent);
  Assertions.assertThat(handleIntentResult).isEqualTo(SensorbergService.START_STICKY);
  Assertions.assertThat(tested.bootstrapper).isNotNull();
  Mockito.verify(tested,Mockito.times(1)).handleDebuggingIntent(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(1)).handleIntentEvenIfNoBootstrapperPresent(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(1)).updateDiskConfiguration(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(1)).handleIntentMessage(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(0)).startSensorbergService(anyString());
  Mockito.verify(tested,Mockito.times(0)).stopSensorbergService();
}"
13612,"@Test public void should_handle_empty_intent(){
  Intent sensorbergServiceStartIntent=new Intent(InstrumentationRegistry.getContext(),SensorbergService.class);
  int handleIntentResult=tested.handleIntent(sensorbergServiceStartIntent);
  Assertions.assertThat(handleIntentResult).isEqualTo(SensorbergService.START_STICKY);
  Assertions.assertThat(tested.bootstrapper).isNull();
  Mockito.verify(tested,Mockito.times(1)).handleDebuggingIntent(sensorbergServiceStartIntent,tested,true);
  Mockito.verify(tested,Mockito.times(1)).handleIntentEvenIfNoBootstrapperPresent(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(1)).updateDiskConfiguration(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(0)).startSensorbergService(anyString());
  Mockito.verify(tested,Mockito.times(0)).stopSensorbergService();
  Mockito.verify(tested,Mockito.times(0)).handleIntentMessage(sensorbergServiceStartIntent);
}","@Test public void should_handle_empty_intent(){
  Intent sensorbergServiceStartIntent=new Intent(InstrumentationRegistry.getContext(),SensorbergService.class);
  int handleIntentResult=tested.handleIntent(sensorbergServiceStartIntent);
  Assertions.assertThat(handleIntentResult).isEqualTo(SensorbergService.START_STICKY);
  Assertions.assertThat(tested.bootstrapper).isNull();
  Mockito.verify(tested,Mockito.times(1)).handleDebuggingIntent(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(1)).handleIntentEvenIfNoBootstrapperPresent(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(1)).updateDiskConfiguration(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(0)).startSensorbergService(anyString());
  Mockito.verify(tested,Mockito.times(0)).stopSensorbergService();
  Mockito.verify(tested,Mockito.times(0)).handleIntentMessage(sensorbergServiceStartIntent);
}"
13613,"@Test public void should_handle_intent_with_shutdown_message(){
  Intent sensorbergServiceShutdownIntent=SensorbergServiceIntents.getShutdownServiceIntent(InstrumentationRegistry.getContext());
  int handleIntentResult=tested.handleIntent(sensorbergServiceShutdownIntent);
  Assertions.assertThat(handleIntentResult).isEqualTo(SensorbergService.START_NOT_STICKY);
  Mockito.verify(tested,Mockito.times(1)).handleDebuggingIntent(sensorbergServiceShutdownIntent,tested,true);
  Mockito.verify(tested,Mockito.times(1)).handleIntentEvenIfNoBootstrapperPresent(sensorbergServiceShutdownIntent);
  Mockito.verify(tested,Mockito.times(1)).stopSensorbergService();
  Mockito.verify(tested,Mockito.times(0)).updateDiskConfiguration(sensorbergServiceShutdownIntent);
  Mockito.verify(tested,Mockito.times(0)).startSensorbergService(anyString());
  Mockito.verify(tested,Mockito.times(0)).handleIntentMessage(sensorbergServiceShutdownIntent);
}","@Test public void should_handle_intent_with_shutdown_message(){
  Intent sensorbergServiceShutdownIntent=SensorbergServiceIntents.getShutdownServiceIntent(InstrumentationRegistry.getContext());
  int handleIntentResult=tested.handleIntent(sensorbergServiceShutdownIntent);
  Assertions.assertThat(handleIntentResult).isEqualTo(SensorbergService.START_NOT_STICKY);
  Mockito.verify(tested,Mockito.times(1)).handleDebuggingIntent(sensorbergServiceShutdownIntent);
  Mockito.verify(tested,Mockito.times(1)).handleIntentEvenIfNoBootstrapperPresent(sensorbergServiceShutdownIntent);
  Mockito.verify(tested,Mockito.times(1)).stopSensorbergService();
  Mockito.verify(tested,Mockito.times(0)).updateDiskConfiguration(sensorbergServiceShutdownIntent);
  Mockito.verify(tested,Mockito.times(0)).startSensorbergService(anyString());
  Mockito.verify(tested,Mockito.times(0)).handleIntentMessage(sensorbergServiceShutdownIntent);
}"
13614,"@Test public void should_handle_intent_with_start_message_and_api_key(){
  Intent sensorbergServiceStartIntent=SensorbergServiceIntents.getStartServiceIntent(InstrumentationRegistry.getContext(),TestConstants.API_TOKEN_DEFAULT);
  int handleIntentResult=tested.handleIntent(sensorbergServiceStartIntent);
  Assertions.assertThat(handleIntentResult).isEqualTo(SensorbergService.START_STICKY);
  Mockito.verify(tested,Mockito.times(1)).handleDebuggingIntent(sensorbergServiceStartIntent,tested,true);
  Mockito.verify(tested,Mockito.times(1)).handleIntentEvenIfNoBootstrapperPresent(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(1)).updateDiskConfiguration(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(1)).startSensorbergService(TestConstants.API_TOKEN_DEFAULT);
  Mockito.verify(tested,Mockito.times(0)).stopSensorbergService();
  Mockito.verify(tested,Mockito.times(0)).handleIntentMessage(sensorbergServiceStartIntent);
}","@Test public void should_handle_intent_with_start_message_and_api_key(){
  Intent sensorbergServiceStartIntent=SensorbergServiceIntents.getStartServiceIntent(InstrumentationRegistry.getContext(),TestConstants.API_TOKEN_DEFAULT);
  int handleIntentResult=tested.handleIntent(sensorbergServiceStartIntent);
  Assertions.assertThat(handleIntentResult).isEqualTo(SensorbergService.START_STICKY);
  Mockito.verify(tested,Mockito.times(1)).handleDebuggingIntent(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(1)).handleIntentEvenIfNoBootstrapperPresent(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(1)).updateDiskConfiguration(sensorbergServiceStartIntent);
  Mockito.verify(tested,Mockito.times(1)).startSensorbergService(TestConstants.API_TOKEN_DEFAULT);
  Mockito.verify(tested,Mockito.times(0)).stopSensorbergService();
  Mockito.verify(tested,Mockito.times(0)).handleIntentMessage(sensorbergServiceStartIntent);
}"
13615,"@Test public void should_turn_debugging_off_in_transport_from_intent(){
  Intent serviceDebuggingOffIntent=SensorbergServiceIntents.getServiceLoggingIntent(InstrumentationRegistry.getContext(),false);
  tested.handleDebuggingIntent(serviceDebuggingOffIntent,InstrumentationRegistry.getContext(),false);
  Mockito.verify(tested.transport,times(1)).setLoggingEnabled(false);
  Assertions.assertThat(Logger.log).isEqualTo(Logger.QUIET_LOG);
}","@Test public void should_turn_debugging_off_in_transport_from_intent(){
  Intent serviceDebuggingOffIntent=SensorbergServiceIntents.getServiceLoggingIntent(InstrumentationRegistry.getContext(),false);
  tested.handleDebuggingIntent(serviceDebuggingOffIntent);
  Mockito.verify(tested.transport,times(1)).setLoggingEnabled(false);
  Assertions.assertThat(Logger.log).isEqualTo(Logger.QUIET_LOG);
}"
13616,"@Test public void should_turn_debugging_on_in_transport_from_intent(){
  Intent serviceDebuggingOnIntent=SensorbergServiceIntents.getServiceLoggingIntent(InstrumentationRegistry.getContext(),true);
  tested.handleDebuggingIntent(serviceDebuggingOnIntent,InstrumentationRegistry.getContext(),false);
  Mockito.verify(tested.transport,times(1)).setLoggingEnabled(true);
  Assertions.assertThat(Logger.log).isInstanceOf(Logger.VerboseLogger.class);
}","@Test public void should_turn_debugging_on_in_transport_from_intent(){
  Intent serviceDebuggingOnIntent=SensorbergServiceIntents.getServiceLoggingIntent(InstrumentationRegistry.getContext(),true);
  tested.handleDebuggingIntent(serviceDebuggingOnIntent);
  Mockito.verify(tested.transport,times(1)).setLoggingEnabled(true);
  Assertions.assertThat(Logger.log).isInstanceOf(Logger.VerboseLogger.class);
}"
13617,"public void setLogging(boolean enableLogging){
  context.startService(SensorbergServiceIntents.getServiceLoggingIntent(context,enableLogging));
}","/** 
 * To set the logging and whether to show a message notifying the user logging is enabled or not.
 * @param enableLogging - true|false if to enable logging or not.
 */
public void setLogging(boolean enableLogging){
  context.startService(SensorbergServiceIntents.getServiceLoggingIntent(context,enableLogging));
}"
13618,"protected int handleIntent(Intent intent){
  Logger.log.serviceHandlesMessage(SensorbergServiceMessage.stringFrom(intent.getIntExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,-1)));
  handleDebuggingIntent(intent,this,true);
  if (handleIntentEvenIfNoBootstrapperPresent(intent)) {
    return stopSensorbergService();
  }
  if (bootstrapper == null) {
    updateDiskConfiguration(intent);
  }
  if (intent.hasExtra(SensorbergServiceMessage.EXTRA_START_SERVICE)) {
    return startSensorbergService(intent.getStringExtra(SensorbergServiceMessage.EXTRA_API_KEY));
  }
  if (intent.hasExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE)) {
    return handleIntentMessage(intent);
  }
  return START_STICKY;
}","protected int handleIntent(Intent intent){
  Logger.log.serviceHandlesMessage(SensorbergServiceMessage.stringFrom(intent.getIntExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,-1)));
  handleDebuggingIntent(intent);
  if (handleIntentEvenIfNoBootstrapperPresent(intent)) {
    return stopSensorbergService();
  }
  if (bootstrapper == null) {
    updateDiskConfiguration(intent);
  }
  if (intent.hasExtra(SensorbergServiceMessage.EXTRA_START_SERVICE)) {
    return startSensorbergService(intent.getStringExtra(SensorbergServiceMessage.EXTRA_API_KEY));
  }
  if (intent.hasExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE)) {
    return handleIntentMessage(intent);
  }
  return START_STICKY;
}"
13619,"protected void handleDebuggingIntent(Intent intent,Context context,boolean showMessage){
switch (intent.getIntExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,-1)) {
case SensorbergServiceMessage.MSG_TYPE_DISABLE_LOGGING:
{
      Logger.log=Logger.QUIET_LOG;
      transport.setLoggingEnabled(false);
      if (showMessage) {
        Toast.makeText(context,""String_Node_Str"" + context.getPackageName(),Toast.LENGTH_SHORT).show();
      }
      break;
    }
case SensorbergServiceMessage.MSG_TYPE_ENABLE_LOGGING:
{
    Logger.enableVerboseLogging();
    transport.setLoggingEnabled(true);
    if (showMessage) {
      Toast.makeText(context,""String_Node_Str"" + context.getPackageName(),Toast.LENGTH_SHORT).show();
    }
    break;
  }
}
}","protected void handleDebuggingIntent(Intent intent){
switch (intent.getIntExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,-1)) {
case SensorbergServiceMessage.MSG_TYPE_DISABLE_LOGGING:
{
      Logger.log.verbose(""String_Node_Str"");
      Logger.log=Logger.QUIET_LOG;
      transport.setLoggingEnabled(false);
      break;
    }
case SensorbergServiceMessage.MSG_TYPE_ENABLE_LOGGING:
{
    Logger.log.verbose(""String_Node_Str"");
    Logger.enableVerboseLogging();
    transport.setLoggingEnabled(true);
    break;
  }
}
}"
13620,"@Override public void onActivityResumed(Activity activity){
  handler.removeCallbacksAndMessages(null);
  this.isInForeground=true;
  handler.postDelayed(FOREGROUND,500);
}","@Override public void onActivityResumed(Activity activity){
  handler.removeCallbacksAndMessages(null);
  this.isInForeground=true;
  handler.postDelayed(FOREGROUND,500);
  if (!hasPermission && permissionChecker.hasScanPermissionCheckAndroid6()) {
    hasPermission=true;
    activity.startService(SensorbergServiceIntents.getPingIntent(activity));
  }
}"
13621,"@Override public void onActivityCreated(Activity activity,Bundle savedInstanceState){
}","@Override public void onActivityCreated(Activity activity,Bundle savedInstanceState){
  if (permissionChecker == null) {
    permissionChecker=new PermissionChecker(activity.getApplicationContext());
    hasPermission=permissionChecker.hasScanPermissionCheckAndroid6();
  }
}"
13622,"private boolean checkForPermission(String permissionIdentifier){
  if (permissionCache.get(permissionIdentifier) != null) {
    return permissionCache.get(permissionIdentifier);
  }
  int res=context.checkCallingOrSelfPermission(permissionIdentifier);
  boolean value=(res == PackageManager.PERMISSION_GRANTED);
  permissionCache.put(permissionIdentifier,value);
  return value;
}","private boolean checkForPermission(String permissionIdentifier){
  return context.checkCallingOrSelfPermission(permissionIdentifier) == PackageManager.PERMISSION_GRANTED;
}"
13623,"@Override public void onActivityResumed(Activity activity){
  handler.removeCallbacksAndMessages(null);
  this.isInForeground=true;
  handler.postDelayed(FOREGROUND,500);
}","@Override public void onActivityResumed(Activity activity){
  handler.removeCallbacksAndMessages(null);
  this.isInForeground=true;
  handler.postDelayed(FOREGROUND,500);
  if (!hasPermission && permissionChecker.hasScanPermissionCheckAndroid6()) {
    hasPermission=true;
    activity.startService(SensorbergServiceIntents.getPingIntent(activity));
  }
}"
13624,"@Override public void onActivityCreated(Activity activity,Bundle savedInstanceState){
}","@Override public void onActivityCreated(Activity activity,Bundle savedInstanceState){
  if (permissionChecker == null) {
    permissionChecker=new PermissionChecker(activity.getApplicationContext());
    hasPermission=permissionChecker.hasScanPermissionCheckAndroid6();
  }
}"
13625,"private boolean checkForPermission(String permissionIdentifier){
  if (permissionCache.get(permissionIdentifier) != null) {
    return permissionCache.get(permissionIdentifier);
  }
  int res=context.checkCallingOrSelfPermission(permissionIdentifier);
  boolean value=(res == PackageManager.PERMISSION_GRANTED);
  permissionCache.put(permissionIdentifier,value);
  return value;
}","private boolean checkForPermission(String permissionIdentifier){
  return context.checkCallingOrSelfPermission(permissionIdentifier) == PackageManager.PERMISSION_GRANTED;
}"
13626,"protected int startSensorbergService(String apiKey){
  if (bootstrapper == null && (!TextUtils.isEmpty(apiKey))) {
    bootstrapper=createBootstrapper(apiKey);
    persistConfiguration(bootstrapper.resolver.configuration);
    bootstrapper.startScanning();
    return START_STICKY;
  }
 else   if (bootstrapper != null) {
    bootstrapper.startScanning();
    logError(""String_Node_Str"");
    return START_STICKY;
  }
 else {
    logError(""String_Node_Str"");
    return stopSensorbergService();
  }
}","protected int startSensorbergService(String apiKey){
  if (bootstrapper == null && (!TextUtils.isEmpty(apiKey))) {
    ResolverConfiguration configuration=new ResolverConfiguration();
    configuration.setApiToken(apiKey);
    bootstrapper=createBootstrapper(configuration);
    persistConfiguration(bootstrapper.resolver.configuration);
    bootstrapper.startScanning();
    return START_STICKY;
  }
 else   if (bootstrapper != null) {
    bootstrapper.startScanning();
    logError(""String_Node_Str"");
    return START_STICKY;
  }
 else {
    logError(""String_Node_Str"");
    return stopSensorbergService();
  }
}"
13627,"public void setLogging(boolean enableLogging){
  context.startService(SensorbergServiceIntents.getServiceLoggingIntent(context,enableLogging));
}","/** 
 * To set the logging and whether to show a message notifying the user logging is enabled or not.
 * @param enableLogging - true|false if to enable logging or not.
 * @param showMessage - true|false if to show a message to display the message.
 */
public void setLogging(boolean enableLogging,boolean showMessage){
  context.startService(SensorbergServiceIntents.getServiceLoggingIntent(context,enableLogging,showMessage));
}"
13628,"protected int handleIntent(Intent intent){
  Logger.log.serviceHandlesMessage(SensorbergServiceMessage.stringFrom(intent.getIntExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,-1)));
  handleDebuggingIntent(intent,this,true);
  if (handleIntentEvenIfNoBootstrapperPresent(intent)) {
    return stopSensorbergService();
  }
  if (bootstrapper == null) {
    updateDiskConfiguration(intent);
  }
  if (intent.hasExtra(SensorbergServiceMessage.EXTRA_START_SERVICE)) {
    return startSensorbergService(intent.getStringExtra(SensorbergServiceMessage.EXTRA_API_KEY));
  }
  if (intent.hasExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE)) {
    return handleIntentMessage(intent);
  }
  return START_STICKY;
}","protected int handleIntent(Intent intent){
  Logger.log.serviceHandlesMessage(SensorbergServiceMessage.stringFrom(intent.getIntExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,-1)));
  handleDebuggingIntent(intent,this);
  if (handleIntentEvenIfNoBootstrapperPresent(intent)) {
    return stopSensorbergService();
  }
  if (bootstrapper == null) {
    updateDiskConfiguration(intent);
  }
  if (intent.hasExtra(SensorbergServiceMessage.EXTRA_START_SERVICE)) {
    return startSensorbergService(intent.getStringExtra(SensorbergServiceMessage.EXTRA_API_KEY));
  }
  if (intent.hasExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE)) {
    return handleIntentMessage(intent);
  }
  return START_STICKY;
}"
13629,"protected void handleDebuggingIntent(Intent intent,Context context,boolean showMessage){
switch (intent.getIntExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,-1)) {
case SensorbergServiceMessage.MSG_TYPE_DISABLE_LOGGING:
{
      Logger.log=Logger.QUIET_LOG;
      transport.setLoggingEnabled(false);
      if (showMessage) {
        Toast.makeText(context,""String_Node_Str"" + context.getPackageName(),Toast.LENGTH_SHORT).show();
      }
      break;
    }
case SensorbergServiceMessage.MSG_TYPE_ENABLE_LOGGING:
{
    Logger.enableVerboseLogging();
    transport.setLoggingEnabled(true);
    if (showMessage) {
      Toast.makeText(context,""String_Node_Str"" + context.getPackageName(),Toast.LENGTH_SHORT).show();
    }
    break;
  }
}
}","protected void handleDebuggingIntent(Intent intent,Context context){
switch (intent.getIntExtra(SensorbergServiceMessage.EXTRA_GENERIC_TYPE,-1)) {
case SensorbergServiceMessage.MSG_TYPE_DISABLE_LOGGING:
{
      Logger.log=Logger.QUIET_LOG;
      transport.setLoggingEnabled(false);
      if (intent.getBooleanExtra(SensorbergServiceMessage.EXTRA_SHOW_MESSAGE,false)) {
        Toast.makeText(context,""String_Node_Str"" + context.getPackageName(),Toast.LENGTH_SHORT).show();
      }
      break;
    }
case SensorbergServiceMessage.MSG_TYPE_ENABLE_LOGGING:
{
    Logger.enableVerboseLogging();
    transport.setLoggingEnabled(true);
    if (intent.getBooleanExtra(SensorbergServiceMessage.EXTRA_SHOW_MESSAGE,true)) {
      Toast.makeText(context,""String_Node_Str"" + context.getPackageName(),Toast.LENGTH_SHORT).show();
    }
    break;
  }
}
}"
13630,"public static Intent getServiceLoggingIntent(Context ctx,boolean enableLogging){
  int message=enableLogging ? SensorbergServiceMessage.MSG_TYPE_ENABLE_LOGGING : SensorbergServiceMessage.MSG_TYPE_DISABLE_LOGGING;
  return getServiceIntentWithMessage(ctx,message);
}","public static Intent getServiceLoggingIntent(Context ctx,boolean enableLogging,boolean showMessage){
  int message=enableLogging ? SensorbergServiceMessage.MSG_TYPE_ENABLE_LOGGING : SensorbergServiceMessage.MSG_TYPE_DISABLE_LOGGING;
  return getServiceIntentLoggingMessage(ctx,message,showMessage);
}"
13631,"@Override public void onReceive(Context context,Intent intent){
  Intent loggingIntent=new Intent(context,SensorbergService.class);
  if (intent.getData().getAuthority().endsWith(""String_Node_Str"")) {
    loggingIntent=SensorbergServiceIntents.getServiceLoggingIntent(context,true);
  }
 else   if (intent.getData().getAuthority().endsWith(""String_Node_Str"")) {
    loggingIntent=SensorbergServiceIntents.getServiceLoggingIntent(context,false);
  }
  context.startService(loggingIntent);
}","@Override public void onReceive(Context context,Intent intent){
  Intent loggingIntent=new Intent(context,SensorbergService.class);
  if (intent.getData().getAuthority().endsWith(""String_Node_Str"")) {
    loggingIntent=SensorbergServiceIntents.getServiceLoggingIntent(context,true,true);
  }
 else   if (intent.getData().getAuthority().endsWith(""String_Node_Str"")) {
    loggingIntent=SensorbergServiceIntents.getServiceLoggingIntent(context,false,true);
  }
  context.startService(loggingIntent);
}"
13632,"@Override public void onCreate(){
  super.onCreate();
  Log.d(TAG,""String_Node_Str"");
  boot=new SensorbergSdk(this,API_KEY);
  boot.setLogging(true);
  boot.registerEventListener(new SensorbergSdkEventListener(){
    @Override public void presentBeaconEvent(    BeaconEvent beaconEvent){
      Log.d(DemoApplication.TAG,""String_Node_Str"" + beaconEvent.toString());
      showAlert(beaconEvent.getAction(),beaconEvent.getTrigger());
    }
  }
);
  detector=new BackgroundDetector(boot);
  if (Build.VERSION.SDK_INT >= 14) {
    registerActivityLifecycleCallbacks(detector);
  }
  new Thread(new Runnable(){
    @Override public void run(){
      long timeBefore=System.currentTimeMillis();
      try {
        AdvertisingIdClient.Info info=AdvertisingIdClient.getAdvertisingIdInfo(getApplicationContext());
        if (info == null || info.getId() == null) {
          Logger.log.logError(""String_Node_Str"");
          return;
        }
        boot.setAdvertisingIdentifier(info.getId());
      }
 catch (      IOException e) {
        Logger.log.logError(""String_Node_Str"",e.getCause());
      }
catch (      GooglePlayServicesNotAvailableException e) {
        Logger.log.logError(""String_Node_Str"");
      }
catch (      GooglePlayServicesRepairableException e) {
        Logger.log.logError(""String_Node_Str"",e.getCause());
      }
catch (      Exception e) {
        Logger.log.logError(""String_Node_Str"",e.getCause());
      }
      Logger.log.verbose(""String_Node_Str"" + (System.currentTimeMillis() - timeBefore) + ""String_Node_Str"");
    }
  }
).start();
}","@Override public void onCreate(){
  super.onCreate();
  Log.d(TAG,""String_Node_Str"");
  boot=new SensorbergSdk(this,API_KEY);
  boot.setLogging(true);
  boot.setLogging(true,true);
  boot.registerEventListener(new SensorbergSdkEventListener(){
    @Override public void presentBeaconEvent(    BeaconEvent beaconEvent){
      Log.d(DemoApplication.TAG,""String_Node_Str"" + beaconEvent.toString());
      showAlert(beaconEvent.getAction(),beaconEvent.getTrigger());
    }
  }
);
  detector=new BackgroundDetector(boot);
  if (Build.VERSION.SDK_INT >= 14) {
    registerActivityLifecycleCallbacks(detector);
  }
  new Thread(new Runnable(){
    @Override public void run(){
      long timeBefore=System.currentTimeMillis();
      try {
        AdvertisingIdClient.Info info=AdvertisingIdClient.getAdvertisingIdInfo(getApplicationContext());
        if (info == null || info.getId() == null) {
          Logger.log.logError(""String_Node_Str"");
          return;
        }
        boot.setAdvertisingIdentifier(info.getId());
      }
 catch (      IOException e) {
        Logger.log.logError(""String_Node_Str"",e.getCause());
      }
catch (      GooglePlayServicesNotAvailableException e) {
        Logger.log.logError(""String_Node_Str"");
      }
catch (      GooglePlayServicesRepairableException e) {
        Logger.log.logError(""String_Node_Str"",e.getCause());
      }
catch (      Exception e) {
        Logger.log.logError(""String_Node_Str"",e.getCause());
      }
      Logger.log.verbose(""String_Node_Str"" + (System.currentTimeMillis() - timeBefore) + ""String_Node_Str"");
    }
  }
).start();
}"
13633,"@Provides @Named(""String_Node_Str"") @Singleton public BluetoothPlatform provideAndroidBluetoothPlatform(BluetoothAdapter adapter,CrashCallBackWrapper wrapper,Context context){
  return new AndroidBluetoothPlatform(adapter,wrapper,context);
}","@Provides @Named(""String_Node_Str"") @Singleton public BluetoothPlatform provideAndroidBluetoothPlatform(BluetoothAdapter adapter,Context context){
  return new AndroidBluetoothPlatform(adapter,context);
}"
13634,"@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2) public AndroidBluetoothPlatform(BluetoothAdapter adapter,CrashCallBackWrapper wrapper,Context ctx){
  context=ctx;
  crashCallBackWrapper=wrapper;
  bluetoothAdapter=adapter;
  permissionChecker=new PermissionChecker(ctx);
}","public AndroidBluetoothPlatform(BluetoothAdapter adapter,Context ctx){
  context=ctx;
  bluetoothAdapter=adapter;
  permissionChecker=new PermissionChecker(ctx);
  if (Build.VERSION.SDK_INT >= 18) {
    crashCallBackWrapper=new CrashCallBackWrapper(ctx);
  }
 else {
    crashCallBackWrapper=null;
  }
}"
13635,"/** 
 * Returns a flag indicating whether Bluetooth is supported.
 * @return a flag indicating whether Bluetooth is supported
 */
@Override public boolean isBluetoothLowEnergySupported(){
  return bluetoothAdapter != null && Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2 && context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE);
}","/** 
 * Returns a flag indicating whether Bluetooth is supported.
 * @return a flag indicating whether Bluetooth is supported
 */
@Override public boolean isBluetoothLowEnergySupported(){
  return bluetoothAdapter != null && crashCallBackWrapper != null && Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2 && context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE);
}"
13636,"@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2) @Override public void startLeScan(BluetoothAdapter.LeScanCallback scanCallback){
  if (isBluetoothLowEnergySupported()) {
    if (bluetoothAdapter.getState() == BluetoothAdapter.STATE_ON && permissionChecker.hasScanPermissionCheckAndroid6()) {
      Log.i(""String_Node_Str"",Integer.toString(bluetoothAdapter.getState()));
      bluetoothAdapter.startLeScan(crashCallBackWrapper);
      crashCallBackWrapper.setCallback(scanCallback);
      leScanRunning=true;
    }
  }
}","@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2) @Override public void startLeScan(BluetoothAdapter.LeScanCallback scanCallback){
  if (isBluetoothLowEnergySupported() && crashCallBackWrapper != null) {
    if (bluetoothAdapter.getState() == BluetoothAdapter.STATE_ON && permissionChecker.hasScanPermissionCheckAndroid6()) {
      Log.i(""String_Node_Str"",Integer.toString(bluetoothAdapter.getState()));
      bluetoothAdapter.startLeScan(crashCallBackWrapper);
      crashCallBackWrapper.setCallback(scanCallback);
      leScanRunning=true;
    }
  }
}"
13637,"@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2) @Override public void stopLeScan(){
  if (isBluetoothLowEnergySupported()) {
    try {
      bluetoothAdapter.stopLeScan(crashCallBackWrapper);
    }
 catch (    NullPointerException sentBySysteminternally) {
      Logger.log.logError(""String_Node_Str"",sentBySysteminternally);
    }
 finally {
      leScanRunning=false;
      crashCallBackWrapper.setCallback(null);
    }
  }
}","@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2) @Override public void stopLeScan(){
  if (isBluetoothLowEnergySupported() && crashCallBackWrapper != null) {
    try {
      bluetoothAdapter.stopLeScan(crashCallBackWrapper);
    }
 catch (    NullPointerException sentBySysteminternally) {
      Logger.log.logError(""String_Node_Str"",sentBySysteminternally);
    }
 finally {
      leScanRunning=false;
      crashCallBackWrapper.setCallback(null);
    }
  }
}"
13638,"@Test public void should_parse_action_type_url_message(){
  try {
    JsonObject URI_JSON_OBJECT=Utils.getRawResourceAsJSON(com.sensorberg.sdk.test.R.raw.action_factory_001,InstrumentationRegistry.getContext());
    Action result=ActionFactory.actionFromJSONObject(URI_JSON_OBJECT);
    Assertions.assertThat(result).isNotNull();
    Assertions.assertThat(result).isInstanceOf(UriMessageAction.class);
    Assertions.assertThat(((UriMessageAction)result).getContent()).isNotEmpty();
    Assertions.assertThat(((UriMessageAction)result).getTitle()).isNotEmpty();
    Assertions.assertThat(((UriMessageAction)result).getUri()).isNotEmpty();
  }
 catch (  Exception e) {
    Assertions.fail(e.getMessage());
  }
}","@Test public void should_parse_action_type_url_message(){
  try {
    JsonObject URI_JSON_OBJECT=Utils.getRawResourceAsJSON(com.sensorberg.sdk.test.R.raw.action_factory_001,InstrumentationRegistry.getContext());
    Action result=ActionFactory.actionFromJSONObject(URI_JSON_OBJECT);
    Assertions.assertThat(result).isNotNull();
    Assertions.assertThat(result).isInstanceOf(UriMessageAction.class);
    Assertions.assertThat(((UriMessageAction)result).getContent()).isNotEmpty();
    Assertions.assertThat(((UriMessageAction)result).getTitle()).isNotEmpty();
    Assertions.assertThat(((UriMessageAction)result).getUri()).isEmpty();
  }
 catch (  Exception e) {
    Assertions.fail(e.getMessage());
  }
}"
13639,"@Before public void setUp() throws Exception {
  ((TestComponent)SensorbergTestApplication.getComponent()).inject(this);
  Transport testTransportWithMockService=new RetrofitApiTransport(mockRetrofitApiService,clock);
  tested=new BeaconActionHistoryPublisher(InstrumentationRegistry.getContext(),testTransportWithMockService,testSettingsManager,clock,testHandlerManager,sharedPreferences,gson);
}","@Before public void setUp() throws Exception {
  ((TestComponent)SensorbergTestApplication.getComponent()).inject(this);
  testTransportWithMockService=new RetrofitApiTransport(mockRetrofitApiService,clock);
  tested=new BeaconActionHistoryPublisher(InstrumentationRegistry.getContext(),testTransportWithMockService,testSettingsManager,clock,testHandlerManager,sharedPreferences,gson);
}"
13640,"public void saveAllData(){
  if (beaconActions.size() > 0) {
    deleteSavedBeaconActions();
    String actionsJson=gson.toJson(beaconActions);
    sharedPreferences.edit().putString(BeaconAction.SHARED_PREFS_TAG,actionsJson).apply();
    beaconActions=Collections.synchronizedSet(new HashSet<BeaconAction>());
  }
  if (beaconScans.size() > 0) {
    deleteSavedBeaconScans();
    String actionsJson=gson.toJson(beaconScans);
    sharedPreferences.edit().putString(BeaconScan.SHARED_PREFS_TAG,actionsJson).apply();
    beaconScans=Collections.synchronizedSet(new HashSet<BeaconScan>());
  }
}","public void saveAllData(){
  if (beaconActions.size() > 0) {
    deleteSavedBeaconActions();
    String actionsJson=gson.toJson(beaconActions);
    sharedPreferences.edit().putString(BeaconAction.SHARED_PREFS_TAG,actionsJson).apply();
    beaconActions=Collections.synchronizedSet(new HashSet<BeaconAction>());
  }
  if (beaconScans.size() > 0) {
    deleteSavedBeaconScans();
    String scansJson=gson.toJson(beaconScans);
    sharedPreferences.edit().putString(BeaconScan.SHARED_PREFS_TAG,scansJson).apply();
    beaconScans=Collections.synchronizedSet(new HashSet<BeaconScan>());
  }
}"
13641,"private void loadAllData(){
  String actionJson=sharedPreferences.getString(BeaconAction.SHARED_PREFS_TAG,""String_Node_Str"");
  if (!actionJson.isEmpty()) {
    Type listType=new TypeToken<Set<BeaconAction>>(){
    }
.getType();
synchronized (beaconActionsLock) {
      beaconActions=Collections.synchronizedSet((Set<BeaconAction>)gson.fromJson(actionJson,listType));
    }
  }
  String scanJson=sharedPreferences.getString(BeaconScan.SHARED_PREFS_TAG,""String_Node_Str"");
  if (!scanJson.isEmpty()) {
    Type listType=new TypeToken<Set<BeaconScan>>(){
    }
.getType();
synchronized (beaconScansLock) {
      beaconScans=Collections.synchronizedSet((Set<BeaconScan>)gson.fromJson(actionJson,listType));
    }
  }
}","private void loadAllData(){
  String actionJson=sharedPreferences.getString(BeaconAction.SHARED_PREFS_TAG,""String_Node_Str"");
  if (!actionJson.isEmpty()) {
    Type listType=new TypeToken<Set<BeaconAction>>(){
    }
.getType();
synchronized (beaconActionsLock) {
      beaconActions=Collections.synchronizedSet((Set<BeaconAction>)gson.fromJson(actionJson,listType));
    }
  }
  String scanJson=sharedPreferences.getString(BeaconScan.SHARED_PREFS_TAG,""String_Node_Str"");
  if (!scanJson.isEmpty()) {
    Type listType=new TypeToken<Set<BeaconScan>>(){
    }
.getType();
synchronized (beaconScansLock) {
      beaconScans=Collections.synchronizedSet((Set<BeaconScan>)gson.fromJson(scanJson,listType));
    }
  }
}"
13642,"@Override public Object getContentsOfFileOrNull(File file){
  FileInputStream fis=null;
  ObjectInputStream ois=null;
  try {
    fis=new FileInputStream(file);
    ois=new ObjectInputStream(fis);
    return ois.readObject();
  }
 catch (  Exception e) {
    return null;
    Logger.log.logError(""String_Node_Str"",e);
  }
 finally {
    Closeables.close(fis);
    Closeables.close(ois);
  }
}","@Override public Object getContentsOfFileOrNull(File file){
  FileInputStream fis=null;
  ObjectInputStream ois=null;
  try {
    fis=new FileInputStream(file);
    ois=new ObjectInputStream(fis);
    return ois.readObject();
  }
 catch (  Exception e) {
    Logger.log.logError(""String_Node_Str"",e);
  }
 finally {
    Closeables.close(fis);
    Closeables.close(ois);
  }
  return null;
}"
13643,"public void setResolverBaseURL(URL resolverBaseURL){
  Intent service=new Intent(context,SensorbergService.class);
  service.putExtra(SensorbergService.EXTRA_GENERIC_WHAT,SensorbergService.MSG_TYPE_SET_RESOLVER_ENDPOINT);
  if (resolverBaseURL != null) {
    service.putExtra(SensorbergService.MSG_SET_RESOLVER_ENDPOINT_ENDPOINT_URL,resolverBaseURL);
  }
  context.startService(service);
}","public void setResolverBaseURL(URL resolverBaseURL){
  Intent service=new Intent(context,SensorbergService.class);
  service.putExtra(SensorbergService.EXTRA_GENERIC_TYPE,SensorbergService.MSG_TYPE_SET_RESOLVER_ENDPOINT);
  if (resolverBaseURL != null) {
    service.putExtra(SensorbergService.MSG_SET_RESOLVER_ENDPOINT_ENDPOINT_URL,resolverBaseURL);
  }
  context.startService(service);
}"
13644,"@Override public void setUp() throws Exception {
  super.setUp();
  plattform=spy(new AndroidPlatform(getContext()));
  when(plattform.useSyncClient()).thenReturn(true);
  transport=new OkHttpClientTransport(plattform,null);
  startWebserver();
}","@Override public void setUp() throws Exception {
  super.setUp();
  plattform=spy(new TestPlatform());
  plattform.setContext(getContext());
  when(plattform.useSyncClient()).thenReturn(true);
  transport=new OkHttpClientTransport(plattform,null);
  startWebserver();
}"
13645,"/** 
 * account falko@sensorberg.com https://manage.sensorberg.com/#/applications/edit/38eda3c5-649e-4178-9682-314d14abf1fe https://manage.sensorberg.com/#/campaign/edit/bd67e5ec-4426-4f51-b962-6beea2c82695 https://manage.sensorberg.com/#/beacon/view/14053e1f-567b-43e5-818f-811c700b7ae4
 */
public void test_enter_exit_action(){
  URLFactory.Conf env=URLFactory.switchToProductionEnvironment();
  androidPlattform.getTransport().setApiToken(""String_Node_Str"");
  ResolverListener mockListener=new ResolverListener(){
    @Override public void onResolutionFailed(    Resolution resolution,    Throwable cause){
      fail(cause.getMessage());
    }
    @Override public void onResolutionsFinished(    List<BeaconEvent> events){
      Assertions.assertThat(events).hasSize(1);
    }
  }
;
  tested.addResolverListener(mockListener);
  ResolutionConfiguration conf=new ResolutionConfiguration();
  conf.setScanEvent(new ScanEvent.Builder().withBeaconId(new BeaconId(UUID.fromString(""String_Node_Str""),40122,43878)).withEventMask(ScanEventType.ENTRY.getMask()).build());
  Resolution resolution=tested.createResolution(conf);
  resolution.start();
  URLFactory.restorePreviousConf(env);
}","/** 
 * account falko@sensorberg.com https://manage.sensorberg.com/#/applications/edit/38eda3c5-649e-4178-9682-314d14abf1fe https://manage.sensorberg.com/#/campaign/edit/bd67e5ec-4426-4f51-b962-6beea2c82695 https://manage.sensorberg.com/#/beacon/view/14053e1f-567b-43e5-818f-811c700b7ae4
 */
public void test_enter_exit_action(){
  URLFactory.Conf env=URLFactory.switchToProductionEnvironment();
  androidPlattform.getTransport().setApiToken(""String_Node_Str"");
  ResolverListener mockListener=new ResolverListener(){
    @Override public void onResolutionFailed(    Resolution resolution,    Throwable cause){
      fail(cause.getMessage());
    }
    @Override public void onResolutionsFinished(    List<BeaconEvent> events){
      Assertions.assertThat(events).hasSize(0);
    }
  }
;
  tested.addResolverListener(mockListener);
  ResolutionConfiguration conf=new ResolutionConfiguration();
  conf.setScanEvent(new ScanEvent.Builder().withBeaconId(new BeaconId(UUID.fromString(""String_Node_Str""),40122,43878)).withEventMask(ScanEventType.ENTRY.getMask()).build());
  Resolution resolution=tested.createResolution(conf);
  resolution.start();
  URLFactory.restorePreviousConf(env);
}"
13646,"private static String getAppVersionString(Context context){
  try {
    PackageInfo myInfo=context.getPackageManager().getPackageInfo(context.getPackageName(),0);
    return URLEncoder.encode(myInfo.versionName) + ""String_Node_Str"" + myInfo.versionCode;
  }
 catch (  PackageManager.NameNotFoundException e) {
    return ""String_Node_Str"";
  }
}","private static String getAppVersionString(Context context){
  try {
    PackageInfo myInfo=context.getPackageManager().getPackageInfo(context.getPackageName(),0);
    return URLEncoder.encode(myInfo.versionName) + ""String_Node_Str"" + myInfo.versionCode;
  }
 catch (  PackageManager.NameNotFoundException e) {
    return ""String_Node_Str"";
  }
catch (  NullPointerException e) {
    return ""String_Node_Str"";
  }
}"
13647,"/** 
 * Reads the contents of an InputStream into a byte[].
 */
private static byte[] streamToBytes(InputStream in,int length) throws IOException {
  byte[] bytes=new byte[length];
  int count;
  int pos=0;
  while (pos < length && ((count=in.read(bytes,pos,length - pos)) != -1)) {
    pos+=count;
  }
  if (pos != length) {
    throw new IOException(""String_Node_Str"" + length + ""String_Node_Str""+ pos+ ""String_Node_Str"");
  }
  return bytes;
}","/** 
 * Reads the contents of an InputStream into a byte[].
 */
private static byte[] streamToBytes(InputStream in,int length) throws IOException {
  if (length < 0) {
    throw new IOException(""String_Node_Str"");
  }
  byte[] bytes=new byte[length];
  int count;
  int pos=0;
  while (pos < length && ((count=in.read(bytes,pos,length - pos)) != -1)) {
    pos+=count;
  }
  if (pos != length) {
    throw new IOException(""String_Node_Str"" + length + ""String_Node_Str""+ pos+ ""String_Node_Str"");
  }
  return bytes;
}"
13648,"public BeaconEvent map(ResolveAction resolveAction){
  try {
    Action action=ActionFactory.getAction(resolveAction.type,resolveAction.content,UUID.fromString(UUIDUtils.addUuidDashes(resolveAction.eid)),resolveAction.delay * Constants.Time.ONE_SECOND);
    if (action == null) {
      return null;
    }
    return new BeaconEvent.Builder().withAction(action).withSuppressionTime(resolveAction.suppressionTime).withSendOnlyOnce(resolveAction.sendOnlyOnce).withDeliverAtDate(resolveAction.deliverAt).withTrigger(resolveAction.trigger).build();
  }
 catch (  JSONException e) {
    return null;
  }
}","public BeaconEvent map(ResolveAction resolveAction){
  try {
    Action action=ActionFactory.getAction(resolveAction.type,resolveAction.content,UUID.fromString(UUIDUtils.addUuidDashes(resolveAction.eid)),resolveAction.delay * Constants.Time.ONE_SECOND);
    if (action == null) {
      return null;
    }
    return new BeaconEvent.Builder().withAction(action).withSuppressionTime(resolveAction.suppressionTime * Constants.Time.ONE_SECOND).withSendOnlyOnce(resolveAction.sendOnlyOnce).withDeliverAtDate(resolveAction.deliverAt).withTrigger(resolveAction.trigger).build();
  }
 catch (  JSONException e) {
    return null;
  }
}"
13649,"/** 
 * Call this method from your BluetoothAdapter.LeScanCallback method. Doing so is optional, but if you do, this class will be able to count the number of disctinct bluetooth devices scanned, and prevent crashes before they happen. This works very well if the app containing this class is the only one running bluetooth LE scans on the device, or it is constantly doing scans (e.g. is in the foreground for extended periods of time.) This will not work well if the application using this class is only scanning periodically (e.g. when in the background to save battery) and another application is also scanning on the same device, because this class will only get the counts from this application. Future augmentation of this class may improve this by somehow centralizing the list of unique scanned devices.
 * @param device
 */
@TargetApi(18) public void notifyScannedDevice(BluetoothDevice device,BluetoothAdapter.LeScanCallback scanner){
  int oldSize=0, newSize=0;
  if (isDebugEnabled())   oldSize=distinctBluetoothAddresses.size();
  distinctBluetoothAddresses.add(device.getAddress());
  if (isDebugEnabled()) {
    newSize=distinctBluetoothAddresses.size();
    if (oldSize != newSize && newSize % 100 == 0) {
      if (isDebugEnabled())       Log.d(TAG,""String_Node_Str"" + distinctBluetoothAddresses.size());
    }
  }
  if (distinctBluetoothAddresses.size() > getCrashRiskDeviceCount()) {
    if (PREEMPTIVE_ACTION_ENABLED && !recoveryInProgress) {
      Logger.log.verbose(""String_Node_Str"" + distinctBluetoothAddresses.size() + ""String_Node_Str"");
      Logger.log.verbose(TAG,""String_Node_Str"");
      BluetoothAdapter.getDefaultAdapter().stopLeScan(scanner);
      startRecovery();
      processStateChange();
    }
  }
}","/** 
 * Call this method from your BluetoothAdapter.LeScanCallback method. Doing so is optional, but if you do, this class will be able to count the number of disctinct bluetooth devices scanned, and prevent crashes before they happen. This works very well if the app containing this class is the only one running bluetooth LE scans on the device, or it is constantly doing scans (e.g. is in the foreground for extended periods of time.) This will not work well if the application using this class is only scanning periodically (e.g. when in the background to save battery) and another application is also scanning on the same device, because this class will only get the counts from this application. Future augmentation of this class may improve this by somehow centralizing the list of unique scanned devices.
 * @param device
 */
@TargetApi(18) public void notifyScannedDevice(BluetoothDevice device,BluetoothAdapter.LeScanCallback scanner){
  int oldSize=0, newSize=0;
  if (isDebugEnabled())   oldSize=distinctBluetoothAddresses.size();
  distinctBluetoothAddresses.add(device.getAddress());
  if (isDebugEnabled()) {
    newSize=distinctBluetoothAddresses.size();
    if (oldSize != newSize && newSize % 100 == 0) {
      if (isDebugEnabled())       Log.d(TAG,""String_Node_Str"" + distinctBluetoothAddresses.size());
    }
  }
  if (distinctBluetoothAddresses.size() > getCrashRiskDeviceCount()) {
    if (PREEMPTIVE_ACTION_ENABLED && !recoveryInProgress) {
      Logger.log.verbose(""String_Node_Str"" + distinctBluetoothAddresses.size() + ""String_Node_Str"");
      Logger.log.verbose(""String_Node_Str"");
      BluetoothAdapter.getDefaultAdapter().stopLeScan(scanner);
      startRecovery();
      processStateChange();
    }
  }
}"
13650,"@Override public int onStartCommand(Intent intent,int flags,int startId){
  Logger.log.logServiceState(""String_Node_Str"");
  if (!platform.isBluetoothLowEnergySupported() || !platform.hasMinimumAndroidRequirements()) {
    Logger.log.logError(""String_Node_Str"");
    stopSelf();
    return START_NOT_STICKY;
  }
  List<BroadcastReceiver> broadcastReceiver=platform.getBroadcastReceiver();
  if (broadcastReceiver.isEmpty()) {
    Logger.log.logError(""String_Node_Str"");
    stopSelf();
    return START_NOT_STICKY;
  }
 else {
    platform.registerBroadcastReceiver(broadcastReceiver);
  }
  if (intent != null) {
    Logger.log.serviceHandlesMessage(MSG.stringFrom(intent.getIntExtra(SensorbergService.EXTRA_GENERIC_TYPE,-1)));
    handleDebuggingIntent(intent,this);
    if (handleIntentEvenIfNoBootstrapperPresent(intent)) {
      stopSelf();
      return START_NOT_STICKY;
    }
    if (bootstrapper == null) {
      updateDiskConfiguration(intent);
    }
    if (intent.hasExtra(EXTRA_START_SERVICE)) {
      if (bootstrapper == null) {
        String apiKey=intent.getStringExtra(EXTRA_API_KEY);
        if (isEmpty(apiKey)) {
          apiKey=ManifestParser.get(META_DATA_API_KEY,this);
        }
        if (!isEmpty(apiKey)) {
          bootstrapper=new InternalApplicationBootstrapper(platform);
          bootstrapper.setApiToken(apiKey);
          persistConfiguration(bootstrapper);
          bootstrapper.startScanning();
          return START_STICKY;
        }
      }
 else {
        bootstrapper.startScanning();
        Logger.log.logError(""String_Node_Str"");
        return START_STICKY;
      }
      Logger.log.logError(""String_Node_Str"");
      stopSelf();
      return START_NOT_STICKY;
    }
    if (intent.hasExtra(SensorbergService.EXTRA_GENERIC_TYPE)) {
      if (bootstrapper == null) {
        createBootstrapperFromDiskConfiguration();
        if (bootstrapper == null) {
          Logger.log.logError(""String_Node_Str"");
          stopSelf();
          return START_NOT_STICKY;
        }
      }
      int what=intent.getIntExtra(SensorbergService.EXTRA_GENERIC_TYPE,-1);
      Logger.log.serviceHandlesMessage(MSG.stringFrom(what));
switch (what) {
case MSG_BEACON_LAYOUT_UPDATE:
        bootstrapper.updateBeaconLayout();
      break;
case MSG_SDK_SCANNER_MESSAGE:
    Bundle message=intent.getParcelableExtra(EXTRA_GENERIC_WHAT);
  bootstrapper.scanner.handlePlatformMessage(message);
break;
case MSG_SETTINGS_UPDATE:
bootstrapper.updateSettings();
break;
case MSG_UPLOAD_HISTORY:
bootstrapper.uploadHistory();
break;
case GENERIC_TYPE_BEACON_ACTION:
{
try {
BeaconEvent beaconEvent=intent.getParcelableExtra(EXTRA_GENERIC_WHAT);
int index=intent.getIntExtra(EXTRA_GENERIC_INDEX,0);
Logger.log.beaconResolveState(beaconEvent,""String_Node_Str"");
bootstrapper.presentEventDirectly(beaconEvent,index);
}
 catch (Exception e) {
e.printStackTrace();
}
break;
}
case GENERIC_TYPE_RETRY_RESOLVE_SCANEVENT:
{
ResolutionConfiguration configuration=intent.getParcelableExtra(EXTRA_GENERIC_WHAT);
bootstrapper.retryScanEventResolve(configuration);
break;
}
case MSG_APPLICATION_IN_FOREGROUND:
{
bootstrapper.hostApplicationInForeground();
break;
}
case MSG_APPLICATION_IN_BACKGROUND:
{
bootstrapper.hostApplicationInBackground();
break;
}
case MSG_SET_API_TOKEN:
{
if (intent.hasExtra(MSG_SET_API_TOKEN_TOKEN)) {
String apiToken=intent.getStringExtra(MSG_SET_API_TOKEN_TOKEN);
bootstrapper.setApiToken(apiToken);
persistConfiguration(bootstrapper);
}
break;
}
case MSG_TYPE_SET_RESOLVER_ENDPOINT:
{
if (intent.hasExtra(MSG_SET_RESOLVER_ENDPOINT_ENDPOINT_URL)) {
try {
URL resolverURL=(URL)intent.getSerializableExtra(MSG_SET_RESOLVER_ENDPOINT_ENDPOINT_URL);
URLFactory.setLayoutURL(resolverURL.toString());
}
 catch (Exception e) {
Logger.log.logError(""String_Node_Str"" + MSG_SET_RESOLVER_ENDPOINT_ENDPOINT_URL,e);
}
}
break;
}
case MSG_UNREGISTER_PRESENTATION_DELEGATE:
{
if (intent.hasExtra(EXTRA_MESSENGER)) {
Messenger messenger=intent.getParcelableExtra(EXTRA_MESSENGER);
presentationDelegates.remove(messenger);
}
break;
}
case MSG_PING:
{
bootstrapper.startScanning();
break;
}
case MSG_BLUETOOTH:
{
if (intent.hasExtra(EXTRA_BLUETOOTH_STATE)) {
boolean bluetoothOn=intent.getBooleanExtra(EXTRA_BLUETOOTH_STATE,true);
if (bluetoothOn) {
bootstrapper.startScanning();
}
 else {
bootstrapper.stopScanning();
}
}
break;
}
}
}
}
 else {
Logger.log.logError(""String_Node_Str"");
createBootstrapperFromDiskConfiguration();
if (bootstrapper != null) {
bootstrapper.startScanning();
}
}
return START_STICKY;
}","@Override public int onStartCommand(Intent intent,int flags,int startId){
  Logger.log.logServiceState(""String_Node_Str"");
  if (!platform.isBluetoothLowEnergySupported() || !platform.hasMinimumAndroidRequirements()) {
    Logger.log.logError(""String_Node_Str"");
    stopSelf();
    return START_NOT_STICKY;
  }
  List<BroadcastReceiver> broadcastReceiver=platform.getBroadcastReceiver();
  if (broadcastReceiver.isEmpty()) {
    Logger.log.logError(""String_Node_Str"");
    stopSelf();
    return START_NOT_STICKY;
  }
 else {
    platform.registerBroadcastReceiver(broadcastReceiver);
  }
  if (intent != null) {
    Logger.log.serviceHandlesMessage(MSG.stringFrom(intent.getIntExtra(SensorbergService.EXTRA_GENERIC_TYPE,-1)));
    handleDebuggingIntent(intent,this);
    if (handleIntentEvenIfNoBootstrapperPresent(intent)) {
      stopSelf();
      return START_NOT_STICKY;
    }
    if (bootstrapper == null) {
      updateDiskConfiguration(intent);
    }
    if (intent.hasExtra(EXTRA_START_SERVICE)) {
      if (bootstrapper == null) {
        String apiKey=intent.getStringExtra(EXTRA_API_KEY);
        if (isEmpty(apiKey)) {
          apiKey=ManifestParser.get(META_DATA_API_KEY,this);
        }
        if (!isEmpty(apiKey)) {
          bootstrapper=new InternalApplicationBootstrapper(platform);
          bootstrapper.setApiToken(apiKey);
          persistConfiguration(bootstrapper);
          bootstrapper.startScanning();
          return START_STICKY;
        }
      }
 else {
        bootstrapper.startScanning();
        Logger.log.logError(""String_Node_Str"");
        return START_STICKY;
      }
      Logger.log.logError(""String_Node_Str"");
      stopSelf();
      return START_NOT_STICKY;
    }
    if (intent.hasExtra(SensorbergService.EXTRA_GENERIC_TYPE)) {
      if (bootstrapper == null) {
        createBootstrapperFromDiskConfiguration();
        if (bootstrapper == null) {
          Logger.log.logError(""String_Node_Str"");
          stopSelf();
          return START_NOT_STICKY;
        }
      }
      int what=intent.getIntExtra(SensorbergService.EXTRA_GENERIC_TYPE,-1);
      Logger.log.serviceHandlesMessage(MSG.stringFrom(what));
switch (what) {
case MSG_BEACON_LAYOUT_UPDATE:
        bootstrapper.updateBeaconLayout();
      break;
case MSG_SDK_SCANNER_MESSAGE:
    Bundle message=intent.getParcelableExtra(EXTRA_GENERIC_WHAT);
  bootstrapper.scanner.handlePlatformMessage(message);
break;
case MSG_SETTINGS_UPDATE:
bootstrapper.updateSettings();
break;
case MSG_UPLOAD_HISTORY:
bootstrapper.uploadHistory();
break;
case GENERIC_TYPE_BEACON_ACTION:
{
try {
BeaconEvent beaconEvent=intent.getParcelableExtra(EXTRA_GENERIC_WHAT);
int index=intent.getIntExtra(EXTRA_GENERIC_INDEX,0);
Logger.log.beaconResolveState(beaconEvent,""String_Node_Str"");
bootstrapper.presentEventDirectly(beaconEvent,index);
}
 catch (Exception e) {
e.printStackTrace();
}
break;
}
case GENERIC_TYPE_RETRY_RESOLVE_SCANEVENT:
{
ResolutionConfiguration configuration=intent.getParcelableExtra(EXTRA_GENERIC_WHAT);
bootstrapper.retryScanEventResolve(configuration);
break;
}
case MSG_APPLICATION_IN_FOREGROUND:
{
bootstrapper.hostApplicationInForeground();
break;
}
case MSG_APPLICATION_IN_BACKGROUND:
{
bootstrapper.hostApplicationInBackground();
break;
}
case MSG_SET_API_TOKEN:
{
if (intent.hasExtra(MSG_SET_API_TOKEN_TOKEN)) {
String apiToken=intent.getStringExtra(MSG_SET_API_TOKEN_TOKEN);
bootstrapper.setApiToken(apiToken);
persistConfiguration(bootstrapper);
}
break;
}
case MSG_TYPE_SET_RESOLVER_ENDPOINT:
{
if (intent.hasExtra(MSG_SET_RESOLVER_ENDPOINT_ENDPOINT_URL)) {
try {
URL resolverURL=(URL)intent.getSerializableExtra(MSG_SET_RESOLVER_ENDPOINT_ENDPOINT_URL);
URLFactory.setLayoutURL(resolverURL.toString());
}
 catch (Exception e) {
Logger.log.logError(""String_Node_Str"" + MSG_SET_RESOLVER_ENDPOINT_ENDPOINT_URL,e);
}
}
break;
}
case MSG_REGISTER_PRESENTATION_DELEGATE:
{
if (intent.hasExtra(EXTRA_MESSENGER)) {
Messenger messenger=intent.getParcelableExtra(EXTRA_MESSENGER);
presentationDelegates.add(messenger);
}
break;
}
case MSG_UNREGISTER_PRESENTATION_DELEGATE:
{
if (intent.hasExtra(EXTRA_MESSENGER)) {
Messenger messenger=intent.getParcelableExtra(EXTRA_MESSENGER);
presentationDelegates.remove(messenger);
}
break;
}
case MSG_PING:
{
bootstrapper.startScanning();
break;
}
case MSG_BLUETOOTH:
{
if (intent.hasExtra(EXTRA_BLUETOOTH_STATE)) {
boolean bluetoothOn=intent.getBooleanExtra(EXTRA_BLUETOOTH_STATE,true);
if (bluetoothOn) {
bootstrapper.startScanning();
}
 else {
bootstrapper.stopScanning();
}
}
break;
}
}
}
}
 else {
Logger.log.logError(""String_Node_Str"");
createBootstrapperFromDiskConfiguration();
if (bootstrapper != null) {
bootstrapper.startScanning();
}
}
return START_STICKY;
}"
13651,"private void createBootstrapperFromDiskConfiguration(){
  try {
    ServiceConfiguration diskConf=(ServiceConfiguration)FileHelper.getContentsOfFileOrNull(platform.getFile(SERVICE_CONFIGURATION));
    URLFactory.setLayoutURL(diskConf.resolverConfiguration.getResolverLayoutURL().toString());
    if (diskConf.isComplete()) {
      platform.getTransport().setApiToken(diskConf.resolverConfiguration.apiToken);
      bootstrapper=new InternalApplicationBootstrapper(platform);
    }
 else {
      Logger.log.logError(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Logger.log.logError(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}","private void createBootstrapperFromDiskConfiguration(){
  try {
    ServiceConfiguration diskConf=(ServiceConfiguration)FileHelper.getContentsOfFileOrNull(platform.getFile(SERVICE_CONFIGURATION));
    if (diskConf.resolverConfiguration.getResolverLayoutURL() != null) {
      URLFactory.setLayoutURL(diskConf.resolverConfiguration.getResolverLayoutURL().toString());
    }
    if (diskConf.isComplete()) {
      platform.getTransport().setApiToken(diskConf.resolverConfiguration.apiToken);
      bootstrapper=new InternalApplicationBootstrapper(platform);
    }
 else {
      Logger.log.logError(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Logger.log.logError(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}"
13652,"public void runMappedFiles(String[] bamfiles){
  Vector<File> files=new Vector<File>();
  if (bamfiles.length == 1 && bamfiles[0].equals(""String_Node_Str"")) {
    files.add(new File(""String_Node_Str""));
  }
 else {
    for (int i=0; i < bamfiles.length; i++) {
      File file=new File(bamfiles[i]);
      if (!file.exists() || !file.canRead()) {
        log.warn(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
        continue;
      }
      if (file.isDirectory()) {
        File[] subdirFiles=file.listFiles();
        for (int j=0; j < subdirFiles.length; j++) {
          if (!isMappedFile(subdirFiles[j].getName())) {
            log.warn(""String_Node_Str"" + subdirFiles[j].getAbsolutePath() + ""String_Node_Str"");
            continue;
          }
          files.add(subdirFiles[j]);
        }
      }
 else {
        if (!isMappedFile(file.getName())) {
          log.warn(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
          continue;
        }
        files.add(file);
      }
    }
  }
  filesRemaining=new AtomicInteger(files.size());
  for (int i=0; i < files.size(); i++) {
    try {
      processFile(files.elementAt(i));
    }
 catch (    SequenceFormatException e) {
      log.error(""String_Node_Str"" + files.elementAt(i) + ""String_Node_Str""+ e.getLocalizedMessage(),e);
      filesRemaining.decrementAndGet();
    }
catch (    IOException e) {
      log.error(""String_Node_Str"" + files.elementAt(i) + ""String_Node_Str""+ e.getLocalizedMessage(),e);
      filesRemaining.decrementAndGet();
    }
  }
  while (filesRemaining.intValue() > 0) {
    try {
      Thread.sleep(1500);
    }
 catch (    InterruptedException e) {
    }
  }
  System.exit(0);
}","public void runMappedFiles(String[] bamfiles){
  Vector<File> files=new Vector<File>();
  if (bamfiles.length == 1 && bamfiles[0].equals(""String_Node_Str"")) {
    files.add(new File(""String_Node_Str""));
  }
 else {
    for (int i=0; i < bamfiles.length; i++) {
      File file=new File(bamfiles[i]);
      if (!file.exists() || !file.canRead()) {
        log.warn(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
        continue;
      }
      if (file.isDirectory()) {
        File[] subdirFiles=file.listFiles();
        for (int j=0; j < subdirFiles.length; j++) {
          if (!isMappedFile(subdirFiles[j].getName())) {
            log.warn(""String_Node_Str"" + subdirFiles[j].getAbsolutePath() + ""String_Node_Str"");
            continue;
          }
          files.add(subdirFiles[j]);
        }
      }
 else {
        if (!isMappedFile(file.getName())) {
          log.warn(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
          continue;
        }
        files.add(file);
      }
    }
  }
  filesRemaining=new AtomicInteger(files.size());
  for (int i=0; i < files.size(); i++) {
    try {
      processFile(files.elementAt(i));
    }
 catch (    SequenceFormatException e) {
      log.error(""String_Node_Str"" + files.elementAt(i) + ""String_Node_Str""+ e.getLocalizedMessage(),e);
      filesRemaining.decrementAndGet();
    }
catch (    IOException e) {
      log.error(""String_Node_Str"" + files.elementAt(i) + ""String_Node_Str""+ e.getLocalizedMessage(),e);
      filesRemaining.decrementAndGet();
    }
catch (    Exception e) {
      log.error(""String_Node_Str"" + files.elementAt(i),e);
      filesRemaining.decrementAndGet();
    }
  }
  while (filesRemaining.intValue() > 0) {
    try {
      Thread.sleep(1500);
    }
 catch (    InterruptedException e) {
    }
  }
  System.exit(0);
}"
13653,"public boolean openFile(){
  statusPanel.progressUpdated(""String_Node_Str"",0,100);
  JFileChooser chooser;
  if (lastUsedDir == null) {
    chooser=new JFileChooser();
  }
 else {
    chooser=new JFileChooser(lastUsedDir);
  }
  chooser.setMultiSelectionEnabled(true);
  BAMFileFilter bff=new BAMFileFilter();
  chooser.removeChoosableFileFilter(chooser.getFileFilter());
  chooser.addChoosableFileFilter(bff);
  chooser.setFileFilter(bff);
  int result=chooser.showOpenDialog(this);
  if (result == JFileChooser.CANCEL_OPTION)   return false;
  FileFilter chosenFilter=chooser.getFileFilter();
  if (chosenFilter instanceof BAMFileFilter) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  if (fileTabs.getTabCount() == 0) {
    getContentPane().remove(welcomePanel);
    getContentPane().add(fileTabs,BorderLayout.CENTER);
    validate();
    repaint();
  }
  File[] files=chooser.getSelectedFiles();
  for (int i=0; i < files.length; i++) {
    lastUsedDir=files[i].getParentFile();
    SequenceFile sequenceFile;
    try {
      sequenceFile=SequenceFactory.getSequenceFile(files[i]);
    }
 catch (    SequenceFormatException e) {
      JPanel errorPanel=new JPanel();
      errorPanel.setLayout(new BorderLayout());
      errorPanel.add(new JLabel(""String_Node_Str"" + e.getLocalizedMessage(),JLabel.CENTER),BorderLayout.CENTER);
      fileTabs.addTab(files[i].getName(),errorPanel);
      log.error(e,e);
      continue;
    }
catch (    IOException e) {
      log.error(""String_Node_Str"",e);
      JOptionPane.showMessageDialog(this,""String_Node_Str"" + e.getLocalizedMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      continue;
    }
    AnalysisRunner runner=new AnalysisRunner(sequenceFile);
    ResultsPanel rp=new ResultsPanel(sequenceFile);
    runner.addProgressListener(rp);
    runner.addAnalysisListener(rp);
    fileTabs.addTab(sequenceFile.name(),rp);
    QCModule[] moduleList=ModuleFactory.getStandardModuleList();
    runner.startAnalysis(moduleList);
  }
  return true;
}","public boolean openFile(){
  statusPanel.progressUpdated(""String_Node_Str"",0,100);
  JFileChooser chooser;
  if (lastUsedDir == null) {
    chooser=new JFileChooser();
  }
 else {
    chooser=new JFileChooser(lastUsedDir);
  }
  chooser.setMultiSelectionEnabled(true);
  BAMFileFilter bff=new BAMFileFilter();
  chooser.removeChoosableFileFilter(chooser.getFileFilter());
  chooser.addChoosableFileFilter(bff);
  chooser.setFileFilter(bff);
  int result=chooser.showOpenDialog(this);
  if (result == JFileChooser.CANCEL_OPTION)   return false;
  FileFilter chosenFilter=chooser.getFileFilter();
  if (chosenFilter instanceof BAMFileFilter) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  if (fileTabs.getTabCount() == 0) {
    getContentPane().remove(welcomePanel);
    getContentPane().add(fileTabs,BorderLayout.CENTER);
    validate();
    repaint();
  }
  File[] files=chooser.getSelectedFiles();
  for (int i=0; i < files.length; i++) {
    lastUsedDir=files[i].getParentFile();
    SequenceFile sequenceFile;
    try {
      sequenceFile=SequenceFactory.getSequenceFile(files[i]);
      AnalysisRunner runner=new AnalysisRunner(sequenceFile);
      ResultsPanel rp=new ResultsPanel(sequenceFile);
      runner.addProgressListener(rp);
      runner.addAnalysisListener(rp);
      fileTabs.addTab(sequenceFile.name(),rp);
      QCModule[] moduleList=ModuleFactory.getStandardModuleList();
      runner.startAnalysis(moduleList);
    }
 catch (    SequenceFormatException e) {
      JPanel errorPanel=new JPanel();
      errorPanel.setLayout(new BorderLayout());
      errorPanel.add(new JLabel(""String_Node_Str"" + e.getLocalizedMessage(),JLabel.CENTER),BorderLayout.CENTER);
      fileTabs.addTab(files[i].getName(),errorPanel);
      log.error(e,e);
      continue;
    }
catch (    IOException e) {
      log.error(""String_Node_Str"" + files[i].getAbsolutePath() + ""String_Node_Str"",e);
      JOptionPane.showMessageDialog(this,""String_Node_Str"" + e.getLocalizedMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      continue;
    }
catch (    Exception e) {
      log.error(""String_Node_Str"" + files[i].getAbsolutePath(),e);
      JOptionPane.showMessageDialog(this,""String_Node_Str"" + e.getLocalizedMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      continue;
    }
  }
  return true;
}"
13654,"@Override protected void paintComponent(Graphics g){
  g.setColor(Color.WHITE);
  g.fillRect(0,0,getWidth(),getHeight());
  g.setColor(Color.BLACK);
  if (g instanceof Graphics2D) {
    ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
  double yStart, xStart;
  if (minY % yInterval == 0) {
    yStart=minY;
  }
 else {
    yStart=yInterval * (((int)minY / yInterval) + 1);
  }
  if (minX % xInterval == 0) {
    xStart=minX;
  }
 else {
    xStart=xInterval * (((int)minX / xInterval) + 1);
  }
  int xOffset=0;
  int yLabelRightShift=12;
  if (yLabel == null || yLabel.isEmpty()) {
    yLabelRightShift=0;
  }
 else {
    if (g instanceof Graphics2D) {
      Graphics2D g2=(Graphics2D)g;
      AffineTransform orig=g2.getTransform();
      g2.rotate(-Math.PI / 2);
      g2.setColor(Color.BLACK);
      g2.drawString(yLabel,-getY(-yInterval) / 2 - (g.getFontMetrics().stringWidth(yLabel) / 2),yLabelRightShift);
      g2.setTransform(orig);
    }
  }
  int lastYLabelEnd=Integer.MAX_VALUE;
  for (double i=yStart; i <= maxY; i+=yInterval) {
    String label=""String_Node_Str"" + i;
    label=label.replaceAll(""String_Node_Str"",""String_Node_Str"");
    int width=g.getFontMetrics().stringWidth(label);
    if (width > xOffset) {
      xOffset=width;
    }
    int baseNumberHeight=g.getFontMetrics().getHeight();
    int baseNumberPosition=getY(i) + (baseNumberHeight / 2);
    if (baseNumberPosition + baseNumberHeight < lastYLabelEnd) {
      g.drawString(label,yLabelRightShift + 6,baseNumberPosition);
      lastYLabelEnd=baseNumberPosition + 2;
    }
  }
  xOffset=xOffset + yLabelRightShift + 8;
  g.setColor(new Color(180,180,180));
  for (double i=yStart; i <= maxY; i+=yInterval) {
    g.drawLine(xOffset,getY(i),getWidth() - 10,getY(i));
  }
  g.setColor(Color.BLACK);
  int titleWidth=g.getFontMetrics().stringWidth(graphTitle);
  g.drawString(graphTitle,(xOffset + ((getWidth() - (xOffset + 10)) / 2)) - (titleWidth / 2),30);
  g.drawString(xLabel,(getWidth() / 2) - (g.getFontMetrics().stringWidth(xLabel) / 2),getHeight() - 5);
  double baseWidth=(getWidth() - (xOffset + 10)) / (maxX - minX);
  int lastXLabelEnd=0;
  for (double i=xStart; i <= maxX; i+=xInterval) {
    g.setColor(Color.BLACK);
    String baseNumber=""String_Node_Str"" + i;
    baseNumber=baseNumber.replaceAll(""String_Node_Str"",""String_Node_Str"");
    int baseNumberWidth=g.getFontMetrics().stringWidth(baseNumber);
    int baseNumberPosition=(int)(xOffset + (baseWidth * i) - (baseNumberWidth / 2));
    if (baseNumberPosition > lastXLabelEnd) {
      g.drawString(baseNumber,baseNumberPosition,getHeight() - 25);
      lastXLabelEnd=baseNumberPosition + baseNumberWidth + 5;
    }
    g.setColor(new Color(180,180,180));
    g.drawLine((int)(xOffset + (baseWidth * i)),getHeight() - 40,(int)(xOffset + (baseWidth * i)),40);
    g.setColor(Color.BLACK);
  }
  g.drawLine(xOffset,getHeight() - 40,getWidth() - 10,getHeight() - 40);
  g.drawLine(xOffset,getHeight() - 40,xOffset,40);
  rectangles=new ArrayList<Rectangle>();
  tips=new ArrayList<String>();
  g.setColor(Color.BLUE);
  double ovalSize=5;
  double[] inputVar=new double[data.length];
  double[] responseVar=new double[data.length];
  for (int d=0; d < data.length; d++) {
    double x=getX(xCategories[d],xOffset) - ovalSize / 2;
    double y=getY(data[d]) - ovalSize / 2;
    g.fillOval((int)x,(int)y,(int)(ovalSize),(int)(ovalSize));
    inputVar[d]=Double.valueOf(xCategories[d]);
    responseVar[d]=data[d];
    Rectangle r=new Rectangle((int)x,(int)y,(int)(ovalSize),(int)(ovalSize));
    rectangles.add(r);
    tips.add(toolTipLabels[d]);
  }
  g.setColor(Color.BLACK);
  if (data.length > 1) {
    LinearRegression linReg=new LinearRegression(inputVar,responseVar);
    double intercept=linReg.intercept();
    double slope=linReg.slope();
    double rSquare=linReg.R2();
    double x1=minX;
    double y1=slope * minX + intercept;
    if (y1 < minY) {
      x1=(minY - intercept) / slope;
      y1=minY;
    }
 else     if (y1 > maxY) {
      x1=(maxY - intercept) / slope;
      y1=maxY;
    }
    double xn=maxX;
    double yn=slope * maxX + intercept;
    if (g instanceof Graphics2D) {
      ((Graphics2D)g).setStroke(new BasicStroke(1.5f));
    }
    g.setColor(Color.RED);
    g.drawLine(getX(x1,xOffset),getY(y1),getX(xn,xOffset),getY(yn));
    g.setColor(Color.BLACK);
    if (g instanceof Graphics2D) {
      ((Graphics2D)g).setStroke(new BasicStroke(1));
    }
    String legendString=""String_Node_Str"" + Precision.round(slope,3) + ""String_Node_Str"";
    if (intercept < 0)     legendString+=""String_Node_Str"" + Precision.round(-intercept,3);
 else     legendString+=""String_Node_Str"" + Precision.round(intercept,3);
    int width=g.getFontMetrics().stringWidth(legendString);
    g.setColor(Color.WHITE);
    g.fillRect(xOffset + 10,45,width + 8,35);
    g.setColor(Color.LIGHT_GRAY);
    g.drawRect(xOffset + 10,45,width + 8,35);
    g.setColor(Color.RED);
    g.drawString(legendString,xOffset + 13,60);
    g.drawString(""String_Node_Str"" + Precision.round(rSquare,3),xOffset + 13,76);
    g.setColor(Color.BLACK);
  }
}","@Override protected void paintComponent(Graphics g){
  g.setColor(Color.WHITE);
  g.fillRect(0,0,getWidth(),getHeight());
  g.setColor(Color.BLACK);
  if (g instanceof Graphics2D) {
    ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
  double yStart, xStart;
  if (minY % yInterval == 0) {
    yStart=minY;
  }
 else {
    yStart=yInterval * (((int)minY / yInterval) + 1);
  }
  if (minX % xInterval == 0) {
    xStart=minX;
  }
 else {
    xStart=xInterval * (((int)minX / xInterval) + 1);
  }
  int xOffset=0;
  int yLabelRightShift=12;
  if (yLabel == null || yLabel.isEmpty()) {
    yLabelRightShift=0;
  }
 else {
    if (g instanceof Graphics2D) {
      Graphics2D g2=(Graphics2D)g;
      AffineTransform orig=g2.getTransform();
      g2.rotate(-Math.PI / 2);
      g2.setColor(Color.BLACK);
      g2.drawString(yLabel,-getY(-yInterval) / 2 - (g.getFontMetrics().stringWidth(yLabel) / 2),yLabelRightShift);
      g2.setTransform(orig);
    }
  }
  int lastYLabelEnd=Integer.MAX_VALUE;
  for (double i=yStart; i <= maxY; i+=yInterval) {
    String label=""String_Node_Str"" + i;
    label=label.replaceAll(""String_Node_Str"",""String_Node_Str"");
    int width=g.getFontMetrics().stringWidth(label);
    if (width > xOffset) {
      xOffset=width;
    }
    int baseNumberHeight=g.getFontMetrics().getHeight();
    int baseNumberPosition=getY(i) + (baseNumberHeight / 2);
    if (baseNumberPosition + baseNumberHeight < lastYLabelEnd) {
      g.drawString(label,yLabelRightShift + 6,baseNumberPosition);
      lastYLabelEnd=baseNumberPosition + 2;
    }
  }
  xOffset=xOffset + yLabelRightShift + 8;
  g.setColor(new Color(180,180,180));
  for (double i=yStart; i <= maxY; i+=yInterval) {
    g.drawLine(xOffset,getY(i),getWidth() - 10,getY(i));
  }
  g.setColor(Color.BLACK);
  int titleWidth=g.getFontMetrics().stringWidth(graphTitle);
  g.drawString(graphTitle,(xOffset + ((getWidth() - (xOffset + 10)) / 2)) - (titleWidth / 2),30);
  g.drawString(xLabel,(getWidth() / 2) - (g.getFontMetrics().stringWidth(xLabel) / 2),getHeight() - 5);
  double baseWidth=(getWidth() - (xOffset + 10)) / (maxX - minX);
  int lastXLabelEnd=0;
  for (double i=xStart; i <= maxX; i+=xInterval) {
    g.setColor(Color.BLACK);
    String baseNumber=""String_Node_Str"" + i;
    baseNumber=baseNumber.replaceAll(""String_Node_Str"",""String_Node_Str"");
    int baseNumberWidth=g.getFontMetrics().stringWidth(baseNumber);
    int baseNumberPosition=(int)(xOffset + (baseWidth * i) - (baseNumberWidth / 2));
    if (baseNumberPosition > lastXLabelEnd) {
      g.drawString(baseNumber,baseNumberPosition,getHeight() - 25);
      lastXLabelEnd=baseNumberPosition + baseNumberWidth + 5;
    }
    g.setColor(new Color(180,180,180));
    g.drawLine((int)(xOffset + (baseWidth * i)),getHeight() - 40,(int)(xOffset + (baseWidth * i)),40);
    g.setColor(Color.BLACK);
  }
  g.drawLine(xOffset,getHeight() - 40,getWidth() - 10,getHeight() - 40);
  g.drawLine(xOffset,getHeight() - 40,xOffset,40);
  rectangles=new ArrayList<Rectangle>();
  tips=new ArrayList<String>();
  g.setColor(Color.BLUE);
  double ovalSize=5;
  double[] inputVar=new double[data.length];
  double[] responseVar=new double[data.length];
  for (int d=0; d < data.length; d++) {
    double x=getX(xCategories[d],xOffset) - ovalSize / 2;
    double y=getY(data[d]) - ovalSize / 2;
    g.fillOval((int)x,(int)y,(int)(ovalSize),(int)(ovalSize));
    g.drawString(toolTipLabels[d],(int)x + 2,(int)y + 16);
    inputVar[d]=Double.valueOf(xCategories[d]);
    responseVar[d]=data[d];
    Rectangle r=new Rectangle((int)x,(int)y,(int)(ovalSize),(int)(ovalSize));
    rectangles.add(r);
    tips.add(toolTipLabels[d]);
  }
  g.setColor(Color.BLACK);
  if (data.length > 1) {
    LinearRegression linReg=new LinearRegression(inputVar,responseVar);
    double intercept=linReg.intercept();
    double slope=linReg.slope();
    double rSquare=linReg.R2();
    double x1=minX;
    double y1=slope * minX + intercept;
    if (y1 < minY) {
      x1=(minY - intercept) / slope;
      y1=minY;
    }
 else     if (y1 > maxY) {
      x1=(maxY - intercept) / slope;
      y1=maxY;
    }
    double xn=maxX;
    double yn=slope * maxX + intercept;
    if (g instanceof Graphics2D) {
      ((Graphics2D)g).setStroke(new BasicStroke(1.5f));
    }
    g.setColor(Color.RED);
    g.drawLine(getX(x1,xOffset),getY(y1),getX(xn,xOffset),getY(yn));
    g.setColor(Color.BLACK);
    if (g instanceof Graphics2D) {
      ((Graphics2D)g).setStroke(new BasicStroke(1));
    }
    String legendString=""String_Node_Str"" + Precision.round(slope,3) + ""String_Node_Str"";
    if (intercept < 0)     legendString+=""String_Node_Str"" + Precision.round(-intercept,3);
 else     legendString+=""String_Node_Str"" + Precision.round(intercept,3);
    int width=g.getFontMetrics().stringWidth(legendString);
    g.setColor(Color.WHITE);
    g.fillRect(xOffset + 10,45,width + 8,35);
    g.setColor(Color.LIGHT_GRAY);
    g.drawRect(xOffset + 10,45,width + 8,35);
    g.setColor(Color.RED);
    g.drawString(legendString,xOffset + 13,60);
    g.drawString(""String_Node_Str"" + Precision.round(rSquare,3),xOffset + 13,76);
    g.setColor(Color.BLACK);
  }
}"
13655,"public void runMappedFiles(String[] bamfiles){
  Vector<File> files=new Vector<File>();
  if (bamfiles.length == 1 && bamfiles[0].equals(""String_Node_Str"")) {
    files.add(new File(""String_Node_Str""));
  }
 else {
    for (int i=0; i < bamfiles.length; i++) {
      File file=new File(bamfiles[i]);
      if (!file.exists() || !file.canRead()) {
        log.warn(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
        continue;
      }
      if (file.isDirectory()) {
        File[] subdirFiles=file.listFiles();
        for (int j=0; j < subdirFiles.length; j++) {
          if (!isMappedFile(subdirFiles[j].getName())) {
            log.warn(""String_Node_Str"" + subdirFiles[j].getAbsolutePath() + ""String_Node_Str"");
            continue;
          }
          files.add(subdirFiles[j]);
        }
      }
 else {
        if (!isMappedFile(file.getName())) {
          log.warn(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
          continue;
        }
        files.add(file);
      }
    }
  }
  filesRemaining=new AtomicInteger(files.size());
  for (int i=0; i < files.size(); i++) {
    try {
      processFile(files.elementAt(i));
    }
 catch (    SequenceFormatException e) {
      log.error(""String_Node_Str"" + files.elementAt(i) + ""String_Node_Str""+ e.getLocalizedMessage(),e);
      filesRemaining.decrementAndGet();
    }
catch (    IOException e) {
      log.error(""String_Node_Str"" + files.elementAt(i) + ""String_Node_Str""+ e.getLocalizedMessage(),e);
      filesRemaining.decrementAndGet();
    }
  }
  while (filesRemaining.intValue() > 0) {
    try {
      Thread.sleep(1500);
    }
 catch (    InterruptedException e) {
    }
  }
  System.exit(0);
}","public void runMappedFiles(String[] bamfiles){
  Vector<File> files=new Vector<File>();
  if (bamfiles.length == 1 && bamfiles[0].equals(""String_Node_Str"")) {
    files.add(new File(""String_Node_Str""));
  }
 else {
    for (int i=0; i < bamfiles.length; i++) {
      File file=new File(bamfiles[i]);
      if (!file.exists() || !file.canRead()) {
        log.warn(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
        continue;
      }
      if (file.isDirectory()) {
        File[] subdirFiles=file.listFiles();
        for (int j=0; j < subdirFiles.length; j++) {
          if (!isMappedFile(subdirFiles[j].getName())) {
            log.warn(""String_Node_Str"" + subdirFiles[j].getAbsolutePath() + ""String_Node_Str"");
            continue;
          }
          files.add(subdirFiles[j]);
        }
      }
 else {
        if (!isMappedFile(file.getName())) {
          log.warn(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
          continue;
        }
        files.add(file);
      }
    }
  }
  filesRemaining=new AtomicInteger(files.size());
  for (int i=0; i < files.size(); i++) {
    try {
      processFile(files.elementAt(i));
    }
 catch (    SequenceFormatException e) {
      log.error(""String_Node_Str"" + files.elementAt(i) + ""String_Node_Str""+ e.getLocalizedMessage(),e);
      filesRemaining.decrementAndGet();
    }
catch (    IOException e) {
      log.error(""String_Node_Str"" + files.elementAt(i) + ""String_Node_Str""+ e.getLocalizedMessage(),e);
      filesRemaining.decrementAndGet();
    }
catch (    Exception e) {
      log.error(""String_Node_Str"" + files.elementAt(i),e);
      filesRemaining.decrementAndGet();
    }
  }
  while (filesRemaining.intValue() > 0) {
    try {
      Thread.sleep(1500);
    }
 catch (    InterruptedException e) {
    }
  }
  System.exit(0);
}"
13656,"public boolean openFile(){
  statusPanel.progressUpdated(""String_Node_Str"",0,100);
  JFileChooser chooser;
  if (lastUsedDir == null) {
    chooser=new JFileChooser();
  }
 else {
    chooser=new JFileChooser(lastUsedDir);
  }
  chooser.setMultiSelectionEnabled(true);
  BAMFileFilter bff=new BAMFileFilter();
  chooser.removeChoosableFileFilter(chooser.getFileFilter());
  chooser.addChoosableFileFilter(bff);
  chooser.setFileFilter(bff);
  int result=chooser.showOpenDialog(this);
  if (result == JFileChooser.CANCEL_OPTION)   return false;
  FileFilter chosenFilter=chooser.getFileFilter();
  if (chosenFilter instanceof BAMFileFilter) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  if (fileTabs.getTabCount() == 0) {
    getContentPane().remove(welcomePanel);
    getContentPane().add(fileTabs,BorderLayout.CENTER);
    validate();
    repaint();
  }
  File[] files=chooser.getSelectedFiles();
  for (int i=0; i < files.length; i++) {
    lastUsedDir=files[i].getParentFile();
    SequenceFile sequenceFile;
    try {
      sequenceFile=SequenceFactory.getSequenceFile(files[i]);
    }
 catch (    SequenceFormatException e) {
      JPanel errorPanel=new JPanel();
      errorPanel.setLayout(new BorderLayout());
      errorPanel.add(new JLabel(""String_Node_Str"" + e.getLocalizedMessage(),JLabel.CENTER),BorderLayout.CENTER);
      fileTabs.addTab(files[i].getName(),errorPanel);
      log.error(e,e);
      continue;
    }
catch (    IOException e) {
      log.error(""String_Node_Str"",e);
      JOptionPane.showMessageDialog(this,""String_Node_Str"" + e.getLocalizedMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      continue;
    }
    AnalysisRunner runner=new AnalysisRunner(sequenceFile);
    ResultsPanel rp=new ResultsPanel(sequenceFile);
    runner.addProgressListener(rp);
    runner.addAnalysisListener(rp);
    fileTabs.addTab(sequenceFile.name(),rp);
    QCModule[] moduleList=ModuleFactory.getStandardModuleList();
    runner.startAnalysis(moduleList);
  }
  return true;
}","public boolean openFile(){
  statusPanel.progressUpdated(""String_Node_Str"",0,100);
  JFileChooser chooser;
  if (lastUsedDir == null) {
    chooser=new JFileChooser();
  }
 else {
    chooser=new JFileChooser(lastUsedDir);
  }
  chooser.setMultiSelectionEnabled(true);
  BAMFileFilter bff=new BAMFileFilter();
  chooser.removeChoosableFileFilter(chooser.getFileFilter());
  chooser.addChoosableFileFilter(bff);
  chooser.setFileFilter(bff);
  int result=chooser.showOpenDialog(this);
  if (result == JFileChooser.CANCEL_OPTION)   return false;
  FileFilter chosenFilter=chooser.getFileFilter();
  if (chosenFilter instanceof BAMFileFilter) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  if (fileTabs.getTabCount() == 0) {
    getContentPane().remove(welcomePanel);
    getContentPane().add(fileTabs,BorderLayout.CENTER);
    validate();
    repaint();
  }
  File[] files=chooser.getSelectedFiles();
  for (int i=0; i < files.length; i++) {
    lastUsedDir=files[i].getParentFile();
    SequenceFile sequenceFile;
    try {
      sequenceFile=SequenceFactory.getSequenceFile(files[i]);
      AnalysisRunner runner=new AnalysisRunner(sequenceFile);
      ResultsPanel rp=new ResultsPanel(sequenceFile);
      runner.addProgressListener(rp);
      runner.addAnalysisListener(rp);
      fileTabs.addTab(sequenceFile.name(),rp);
      QCModule[] moduleList=ModuleFactory.getStandardModuleList();
      runner.startAnalysis(moduleList);
    }
 catch (    SequenceFormatException e) {
      JPanel errorPanel=new JPanel();
      errorPanel.setLayout(new BorderLayout());
      errorPanel.add(new JLabel(""String_Node_Str"" + e.getLocalizedMessage(),JLabel.CENTER),BorderLayout.CENTER);
      fileTabs.addTab(files[i].getName(),errorPanel);
      log.error(e,e);
      continue;
    }
catch (    IOException e) {
      log.error(""String_Node_Str"" + files[i].getAbsolutePath() + ""String_Node_Str"",e);
      JOptionPane.showMessageDialog(this,""String_Node_Str"" + e.getLocalizedMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      continue;
    }
catch (    Exception e) {
      log.error(""String_Node_Str"" + files[i].getAbsolutePath(),e);
      JOptionPane.showMessageDialog(this,""String_Node_Str"" + e.getLocalizedMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      continue;
    }
  }
  return true;
}"
13657,"public AnalysisRunner(SequenceFile file,File genomeBaseLocation){
  this.file=file;
  this.annotationSet=annotationSet;
  this.genomeBaseLocation=genomeBaseLocation;
  annotationFromNetwork=true;
}","public AnalysisRunner(SequenceFile file,File genomeBaseLocation){
  this.file=file;
  this.genomeBaseLocation=genomeBaseLocation;
  annotationFromNetwork=true;
}"
13658,"@Override public void run(){
  Iterator<AnalysisListener> i=listeners.iterator();
  while (i.hasNext()) {
    i.next().analysisStarted(file);
  }
  if (annotationFromNetwork) {
    GenomeParser parser=new GenomeParser();
    ProgressTextDialog ptd=new ProgressTextDialog(""String_Node_Str"");
    parser.addProgressListener(ptd);
    parser.parseGenome(genomeBaseLocation);
    annotationSet=parser.genome().annotationSet();
  }
 else {
    if (BamQCConfig.getInstance().gff_file != null) {
      annotationSet=new AnnotationSet();
      AnnotationParser parser;
      if (BamQCConfig.getInstance().gff_file.getName().toLowerCase().endsWith(""String_Node_Str"")) {
        parser=new GTFAnnotationParser();
      }
 else {
        parser=new GFF3AnnotationParser();
      }
      try {
        parser.parseAnnotation(annotationSet,BamQCConfig.getInstance().gff_file);
      }
 catch (      Exception e) {
        Iterator<AnalysisListener> i2=listeners.iterator();
        while (i2.hasNext()) {
          i2.next().analysisExceptionReceived(file,e);
          return;
        }
      }
    }
 else {
      annotationSet=new AnnotationSet();
    }
  }
  for (int m=0; m < modules.length; m++) {
    modules[m].processFile(file);
  }
  int seqCount=0;
  while (file.hasNext()) {
    ++seqCount;
    SAMRecord seq;
    try {
      seq=file.next();
    }
 catch (    SequenceFormatException e) {
      i=listeners.iterator();
      while (i.hasNext()) {
        i.next().analysisExceptionReceived(file,e);
      }
      return;
    }
    annotationSet.processSequence(seq);
    for (int m=0; m < modules.length; m++) {
      if (modules[m].needsToSeeSequences()) {
        modules[m].processSequence(seq);
      }
    }
    if (seqCount % 1000 == 0) {
      if (file.getPercentComplete() >= percentComplete + 5) {
        percentComplete=file.getPercentComplete();
        i=listeners.iterator();
        while (i.hasNext()) {
          i.next().analysisUpdated(file,seqCount,percentComplete);
        }
        try {
          Thread.sleep(10);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
  for (int m=0; m < modules.length; m++) {
    if (modules[m].needsToSeeAnnotation()) {
      modules[m].processAnnotationSet(annotationSet);
    }
  }
  i=listeners.iterator();
  while (i.hasNext()) {
    i.next().analysisComplete(file,modules);
  }
}","@Override public void run(){
  Iterator<AnalysisListener> i=listeners.iterator();
  while (i.hasNext()) {
    i.next().analysisStarted(file);
  }
  AnnotationSet annotationSet=null;
  if (annotationFromNetwork) {
    GenomeParser parser=new GenomeParser();
    ProgressTextDialog ptd=new ProgressTextDialog(""String_Node_Str"");
    parser.addProgressListener(ptd);
    parser.parseGenome(genomeBaseLocation);
    annotationSet=parser.genome().annotationSet();
  }
 else   if (BamQCConfig.getInstance().gff_file != null) {
    annotationSet=new AnnotationSet();
    AnnotationParser parser;
    if (BamQCConfig.getInstance().gff_file.getName().toLowerCase().endsWith(""String_Node_Str"")) {
      parser=new GTFAnnotationParser();
    }
 else {
      parser=new GFF3AnnotationParser();
    }
    try {
      parser.parseAnnotation(annotationSet,BamQCConfig.getInstance().gff_file);
    }
 catch (    Exception e) {
      Iterator<AnalysisListener> i2=listeners.iterator();
      while (i2.hasNext()) {
        i2.next().analysisExceptionReceived(file,e);
        return;
      }
    }
  }
 else {
    annotationSet=new AnnotationSet();
  }
  for (int m=0; m < modules.length; m++) {
    modules[m].processFile(file);
  }
  int seqCount=0;
  while (file.hasNext()) {
    ++seqCount;
    SAMRecord seq;
    try {
      seq=file.next();
    }
 catch (    SequenceFormatException e) {
      i=listeners.iterator();
      while (i.hasNext()) {
        i.next().analysisExceptionReceived(file,e);
      }
      return;
    }
    annotationSet.processSequence(seq);
    for (int m=0; m < modules.length; m++) {
      if (modules[m].needsToSeeSequences()) {
        modules[m].processSequence(seq);
      }
    }
    if (seqCount % 1000 == 0) {
      if (file.getPercentComplete() >= percentComplete + 5) {
        percentComplete=file.getPercentComplete();
        i=listeners.iterator();
        while (i.hasNext()) {
          i.next().analysisUpdated(file,seqCount,percentComplete);
        }
        try {
          Thread.sleep(10);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
  for (int m=0; m < modules.length; m++) {
    if (modules[m].needsToSeeAnnotation()) {
      modules[m].processAnnotationSet(annotationSet);
    }
  }
  i=listeners.iterator();
  while (i.hasNext()) {
    i.next().analysisComplete(file,modules);
  }
}"
13659,"/** 
 * Process EMBL file.
 * @param f the f
 * @param annotation the annotation
 * @throws Exception the exception
 */
private void processEMBLFile(File f,AnnotationSet annotation) throws Exception {
  int processedLines=0;
  int processedFeatures=0;
  BufferedReader br=new BufferedReader(new FileReader(f));
  Chromosome c=null;
  while ((c=parseChromosome(br)) != null) {
    processedLines++;
    String line;
    while ((line=br.readLine()) != null) {
      processedLines++;
      if (line.startsWith(""String_Node_Str"") || line.startsWith(""String_Node_Str"")) {
        break;
      }
    }
    StringBuffer currentAttribute=new StringBuffer();
    boolean skipping=true;
    Feature feature=null;
    while ((line=br.readLine()) != null) {
      if (processedLines % 100000 == 0) {
        System.err.println(""String_Node_Str"" + processedLines + ""String_Node_Str""+ processedFeatures+ ""String_Node_Str"");
      }
      processedLines++;
      if (line.startsWith(""String_Node_Str"") || line.startsWith(""String_Node_Str"") || line.startsWith(""String_Node_Str"")) {
        skipToEntryEnd(br);
        break;
      }
      if (line.length() < 18)       continue;
      String type=line.substring(5,18).trim();
      if (type.length() > 0) {
        if (skipping) {
          skipping=false;
        }
 else {
          processAttributeReturnSkip(currentAttribute.toString(),feature);
          annotation.addFeature(feature);
          processedFeatures++;
        }
        if (prefs.loadAnnotation(type)) {
          feature=new Feature(type,c);
          currentAttribute=new StringBuffer(""String_Node_Str"");
          currentAttribute.append(line.substring(21).trim());
          continue;
        }
        skipping=true;
      }
      if (skipping)       continue;
      String data=line.substring(21).trim();
      if (data.startsWith(""String_Node_Str"")) {
        skipping=processAttributeReturnSkip(currentAttribute.toString(),feature);
        currentAttribute=new StringBuffer();
      }
      if (currentAttribute.indexOf(""String_Node_Str"") >= 0)       currentAttribute.append(""String_Node_Str"");
      currentAttribute.append(data);
    }
    if (!skipping) {
      processAttributeReturnSkip(currentAttribute.toString(),feature);
      annotation.addFeature(feature);
      processedFeatures++;
    }
  }
  br.close();
  System.err.println(""String_Node_Str"" + processedFeatures);
}","/** 
 * Process EMBL file.
 * @param f the f
 * @param annotation the annotation
 * @throws Exception the exception
 */
private void processEMBLFile(File f) throws Exception {
  int processedLines=0;
  int processedFeatures=0;
  BufferedReader br=new BufferedReader(new FileReader(f));
  Chromosome c=null;
  while ((c=parseChromosome(br)) != null) {
    processedLines++;
    String line;
    while ((line=br.readLine()) != null) {
      processedLines++;
      if (line.startsWith(""String_Node_Str"") || line.startsWith(""String_Node_Str"")) {
        break;
      }
    }
    StringBuffer currentAttribute=new StringBuffer();
    boolean skipping=true;
    Feature feature=null;
    while ((line=br.readLine()) != null) {
      if (processedLines % 100000 == 0) {
        System.err.println(""String_Node_Str"" + processedLines + ""String_Node_Str""+ processedFeatures+ ""String_Node_Str"");
      }
      processedLines++;
      if (line.startsWith(""String_Node_Str"") || line.startsWith(""String_Node_Str"") || line.startsWith(""String_Node_Str"")) {
        skipToEntryEnd(br);
        break;
      }
      if (line.length() < 18)       continue;
      String type=line.substring(5,18).trim();
      if (type.length() > 0) {
        if (skipping) {
          skipping=false;
        }
 else {
          processAttributeReturnSkip(currentAttribute.toString(),feature);
          genome.annotationSet().addFeature(feature);
          processedFeatures++;
        }
        if (prefs.loadAnnotation(type)) {
          feature=new Feature(type,c);
          currentAttribute=new StringBuffer(""String_Node_Str"");
          currentAttribute.append(line.substring(21).trim());
          continue;
        }
        skipping=true;
      }
      if (skipping)       continue;
      String data=line.substring(21).trim();
      if (data.startsWith(""String_Node_Str"")) {
        skipping=processAttributeReturnSkip(currentAttribute.toString(),feature);
        currentAttribute=new StringBuffer();
      }
      if (currentAttribute.indexOf(""String_Node_Str"") >= 0)       currentAttribute.append(""String_Node_Str"");
      currentAttribute.append(data);
    }
    if (!skipping) {
      processAttributeReturnSkip(currentAttribute.toString(),feature);
      genome.annotationSet().addFeature(feature);
      processedFeatures++;
    }
  }
  br.close();
  System.err.println(""String_Node_Str"" + processedFeatures);
}"
13660,"private void parseGenomeFiles(Genome genome){
  File[] files=baseLocation.listFiles(new DatSimpleFileFilter());
  AnnotationSet annotationSet=new AnnotationSet();
  for (int i=0; i < files.length; i++) {
    Enumeration<ProgressListener> e=listeners.elements();
    while (e.hasMoreElements()) {
      e.nextElement().progressUpdated(""String_Node_Str"" + files[i].getName(),i,files.length);
    }
    try {
      processEMBLFile(files[i],annotationSet);
    }
 catch (    Exception ex) {
      Enumeration<ProgressListener> en=listeners.elements();
      while (en.hasMoreElements()) {
        en.nextElement().progressExceptionReceived(ex);
      }
      return;
    }
  }
  Enumeration<ProgressListener> e=listeners.elements();
  if (files.length > 0) {
    while (e.hasMoreElements()) {
      e.nextElement().progressUpdated(""String_Node_Str"",1,1);
    }
  }
  files=baseLocation.listFiles(new GFFSimpleFileFilter());
  GFF3AnnotationParser gffParser=new GFF3AnnotationParser();
  for (int i=0; i < files.length; i++) {
    e=listeners.elements();
    while (e.hasMoreElements()) {
      e.nextElement().progressUpdated(""String_Node_Str"" + files[i].getName(),i,files.length);
    }
    try {
      AnnotationSet newSet=new AnnotationSet();
      gffParser.parseAnnotation(newSet,files[i]);
      Feature[] features=newSet.getAllFeatures();
      for (int f=0; f < features.length; f++) {
        annotationSet.addFeature(features[f]);
      }
    }
 catch (    Exception ex) {
      Enumeration<ProgressListener> en=listeners.elements();
      while (en.hasMoreElements()) {
        en.nextElement().progressExceptionReceived(ex);
      }
      return;
    }
  }
  e=listeners.elements();
  if (files.length > 0) {
    while (e.hasMoreElements()) {
      e.nextElement().progressUpdated(""String_Node_Str"",1,1);
    }
  }
  genome.setAnnotationSet(annotationSet);
}","private void parseGenomeFiles(Genome genome){
  File[] files=baseLocation.listFiles(new DatSimpleFileFilter());
  for (int i=0; i < files.length; i++) {
    Enumeration<ProgressListener> e=listeners.elements();
    while (e.hasMoreElements()) {
      e.nextElement().progressUpdated(""String_Node_Str"" + files[i].getName(),i,files.length);
    }
    try {
      processEMBLFile(files[i]);
    }
 catch (    Exception ex) {
      Enumeration<ProgressListener> en=listeners.elements();
      while (en.hasMoreElements()) {
        en.nextElement().progressExceptionReceived(ex);
      }
      return;
    }
  }
  Enumeration<ProgressListener> e=listeners.elements();
  if (files.length > 0) {
    while (e.hasMoreElements()) {
      e.nextElement().progressUpdated(""String_Node_Str"",1,1);
    }
  }
  files=baseLocation.listFiles(new GFFSimpleFileFilter());
  GFF3AnnotationParser gffParser=new GFF3AnnotationParser();
  for (int i=0; i < files.length; i++) {
    e=listeners.elements();
    while (e.hasMoreElements()) {
      e.nextElement().progressUpdated(""String_Node_Str"" + files[i].getName(),i,files.length);
    }
    try {
      AnnotationSet newSet=new AnnotationSet();
      gffParser.parseAnnotation(newSet,files[i]);
      Feature[] features=newSet.getAllFeatures();
      for (int f=0; f < features.length; f++) {
        genome.annotationSet().addFeature(features[f]);
      }
    }
 catch (    Exception ex) {
      Enumeration<ProgressListener> en=listeners.elements();
      while (en.hasMoreElements()) {
        en.nextElement().progressExceptionReceived(ex);
      }
      return;
    }
  }
  e=listeners.elements();
  if (files.length > 0) {
    while (e.hasMoreElements()) {
      e.nextElement().progressUpdated(""String_Node_Str"",1,1);
    }
  }
}"
13661,"public Chromosome chr(){
  return chr;
}","/** 
 * Chromosome.
 * @return the chromosome
 */
public Chromosome chr(){
  return chr;
}"
13662,"private int getY(double y){
  return (getHeight() - 40) - (int)(((getHeight() - 80) / (maxY - minY)) * y);
}","private int getY(double y){
  return (getHeight() - 40) - (int)(((getHeight() - 80) / (maxY - minY)) * (y - minY));
}"
13663,"public void paint(Graphics g){
  super.paint(g);
  g.setColor(Color.WHITE);
  g.fillRect(0,0,getWidth(),getHeight());
  g.setColor(Color.BLACK);
  int lastY=0;
  double yStart;
  if (minY % yInterval == 0) {
    yStart=minY;
  }
 else {
    yStart=yInterval * (((int)minY / yInterval) + 1);
  }
  int xOffset=0;
  for (double i=yStart; i <= maxY; i+=yInterval) {
    String label=""String_Node_Str"" + i;
    label=label.replaceAll(""String_Node_Str"",""String_Node_Str"");
    int width=g.getFontMetrics().stringWidth(label);
    if (width > xOffset) {
      xOffset=width;
    }
    g.drawString(label,2,getY(i) + (g.getFontMetrics().getAscent() / 2));
  }
  xOffset+=5;
  int titleWidth=g.getFontMetrics().stringWidth(graphTitle);
  g.drawString(graphTitle,(xOffset + ((getWidth() - (xOffset + 10)) / 2)) - (titleWidth / 2),30);
  g.drawLine(xOffset,getHeight() - 40,getWidth() - 10,getHeight() - 40);
  g.drawLine(xOffset,getHeight() - 40,xOffset,40);
  g.drawString(xLabel,(getWidth() / 2) - (g.getFontMetrics().stringWidth(xLabel) / 2),getHeight() - 5);
  int baseWidth=(getWidth() - (xOffset + 10)) / data[0].length;
  if (baseWidth < 1)   baseWidth=1;
  int lastXLabelEnd=0;
  for (int i=0; i < data[0].length; i++) {
    if (i % 2 != 0) {
      g.setColor(new Color(230,230,230));
      g.fillRect(xOffset + (baseWidth * i),40,baseWidth,getHeight() - 80);
    }
    g.setColor(Color.BLACK);
    String baseNumber=""String_Node_Str"" + xCategories[i];
    int baseNumberWidth=g.getFontMetrics().stringWidth(baseNumber);
    int baseNumberPosition=(baseWidth / 2) + xOffset + (baseWidth * i) - (baseNumberWidth / 2);
    if (baseNumberPosition > lastXLabelEnd) {
      g.drawString(baseNumber,baseNumberPosition,getHeight() - 25);
      lastXLabelEnd=baseNumberPosition + baseNumberWidth + 5;
    }
  }
  g.setColor(new Color(180,180,180));
  for (double i=yStart; i <= maxY; i+=yInterval) {
    g.drawLine(xOffset,getY(i),getWidth() - 10,getY(i));
  }
  g.setColor(Color.BLACK);
  if (g instanceof Graphics2D) {
    ((Graphics2D)g).setStroke(new BasicStroke(2));
    ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
  for (int d=0; d < data.length; d++) {
    g.setColor(COLOURS[d % COLOURS.length]);
    lastY=getY(data[d][0]);
    for (int i=1; i < data[d].length; i++) {
      int thisY=getY(data[d][i]);
      g.drawLine((baseWidth / 2) + xOffset + (baseWidth * (i - 1)),lastY,(baseWidth / 2) + xOffset + (baseWidth * i),thisY);
      lastY=thisY;
    }
  }
  if (g instanceof Graphics2D) {
    ((Graphics2D)g).setStroke(new BasicStroke(1));
    ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  }
  int widestLabel=0;
  for (int t=0; t < xTitles.length; t++) {
    int width=g.getFontMetrics().stringWidth(xTitles[t]);
    if (width > widestLabel)     widestLabel=width;
  }
  widestLabel+=6;
  g.setColor(Color.WHITE);
  g.fillRect((getWidth() - 10) - widestLabel,40,widestLabel,3 + (20 * xTitles.length));
  g.setColor(Color.LIGHT_GRAY);
  g.drawRect((getWidth() - 10) - widestLabel,40,widestLabel,3 + (20 * xTitles.length));
  for (int t=0; t < xTitles.length; t++) {
    g.setColor(COLOURS[t % COLOURS.length]);
    g.drawString(xTitles[t],((getWidth() - 10) - widestLabel) + 3,40 + (20 * (t + 1)));
  }
}","public void paint(Graphics g){
  super.paint(g);
  g.setColor(Color.WHITE);
  g.fillRect(0,0,getWidth(),getHeight());
  g.setColor(Color.BLACK);
  int lastY=0;
  double yStart;
  if (minY % yInterval == 0) {
    yStart=minY;
  }
 else {
    yStart=yInterval * (((int)minY / yInterval) + 1);
  }
  int xOffset=0;
  for (double i=yStart; i <= maxY; i+=yInterval) {
    String label=""String_Node_Str"" + i;
    label=label.replaceAll(""String_Node_Str"",""String_Node_Str"");
    int width=g.getFontMetrics().stringWidth(label);
    if (width > xOffset) {
      xOffset=width;
    }
    g.drawString(label,2,getY(i) + (g.getFontMetrics().getAscent() / 2));
  }
  xOffset+=5;
  int titleWidth=g.getFontMetrics().stringWidth(graphTitle);
  g.drawString(graphTitle,(xOffset + ((getWidth() - (xOffset + 10)) / 2)) - (titleWidth / 2),30);
  g.drawLine(xOffset,getHeight() - 40,getWidth() - 10,getHeight() - 40);
  g.drawLine(xOffset,getHeight() - 40,xOffset,40);
  g.drawString(xLabel,(getWidth() / 2) - (g.getFontMetrics().stringWidth(xLabel) / 2),getHeight() - 5);
  int baseWidth=(getWidth() - (xOffset + 10)) / data[0].length;
  if (baseWidth < 1)   baseWidth=1;
  int lastXLabelEnd=0;
  for (int i=0; i < data[0].length; i++) {
    if (i % 2 != 0) {
      g.setColor(new Color(230,230,230));
      g.fillRect(xOffset + (baseWidth * i),40,baseWidth,getHeight() - 80);
    }
    g.setColor(Color.BLACK);
    String baseNumber=""String_Node_Str"" + xCategories[i];
    int baseNumberWidth=g.getFontMetrics().stringWidth(baseNumber);
    int baseNumberPosition=(baseWidth / 2) + xOffset + (baseWidth * i) - (baseNumberWidth / 2);
    if (baseNumberPosition > lastXLabelEnd) {
      g.drawString(baseNumber,baseNumberPosition,getHeight() - 25);
      lastXLabelEnd=baseNumberPosition + baseNumberWidth + 5;
    }
  }
  g.setColor(new Color(180,180,180));
  for (double i=yStart; i <= maxY; i+=yInterval) {
    g.drawLine(xOffset,getY(i),getWidth() - 10,getY(i));
  }
  g.setColor(Color.BLACK);
  if (g instanceof Graphics2D) {
    ((Graphics2D)g).setStroke(new BasicStroke(2));
    ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
  for (int d=0; d < data.length; d++) {
    g.setColor(COLOURS[d % COLOURS.length]);
    lastY=getY(data[d][0]);
    for (int i=1; i < data[d].length; i++) {
      if (Double.isNaN(data[d][i]))       break;
      int thisY=getY(data[d][i]);
      g.drawLine((baseWidth / 2) + xOffset + (baseWidth * (i - 1)),lastY,(baseWidth / 2) + xOffset + (baseWidth * i),thisY);
      lastY=thisY;
    }
  }
  if (g instanceof Graphics2D) {
    ((Graphics2D)g).setStroke(new BasicStroke(1));
    ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  }
  int widestLabel=0;
  for (int t=0; t < xTitles.length; t++) {
    int width=g.getFontMetrics().stringWidth(xTitles[t]);
    if (width > widestLabel)     widestLabel=width;
  }
  widestLabel+=6;
  g.setColor(Color.WHITE);
  g.fillRect((getWidth() - 10) - widestLabel,40,widestLabel,3 + (20 * xTitles.length));
  g.setColor(Color.LIGHT_GRAY);
  g.drawRect((getWidth() - 10) - widestLabel,40,widestLabel,3 + (20 * xTitles.length));
  for (int t=0; t < xTitles.length; t++) {
    g.setColor(COLOURS[t % COLOURS.length]);
    g.drawString(xTitles[t],((getWidth() - 10) - widestLabel) + 3,40 + (20 * (t + 1)));
  }
}"
13664,"@Override public void makeReport(HTMLReportArchive report) throws XMLStreamException, IOException {
}","@Override public void makeReport(HTMLReportArchive report) throws XMLStreamException, IOException {
  super.writeTable(report,new ResultsTable());
}"
13665,"private String sendRequest(String httpMethod,String action,Request request) throws QingCloudClientException, QingCloudServiceException, IOException {
  Map<String,String> parameters=request.toMap();
  addCommonParams(httpMethod,action,parameters);
  for (  Map.Entry<String,String> entry : parameters.entrySet()) {
    String key=entry.getKey();
    String value=entry.getValue();
    if (DEBUG)     System.out.println(String.format(""String_Node_Str"",key,value));
  }
  InputStream content=null;
  HttpURLConnection connection=null;
  try {
    String query=paramsToQueryString(parameters);
    URL url=new URL(ENDPOINT + ""String_Node_Str"" + query);
    if (DEBUG)     System.out.println(""String_Node_Str"" + url);
    connection=(HttpURLConnection)url.openConnection();
    connection.connect();
    int code=connection.getResponseCode();
    if (DEBUG)     System.out.println(""String_Node_Str"" + code);
    if (code >= 400) {
      content=connection.getErrorStream();
      String message=readContent(content);
      QingCloudServiceException exception=new QingCloudServiceException(message);
      exception.setServiceName(action);
      exception.setStatusCode(code);
      throw exception;
    }
 else {
      content=connection.getInputStream();
      String message=readContent(content);
      if (DEBUG)       System.out.println(""String_Node_Str"" + message);
      Response response=Response.fromJson(message);
      int retCode=response.getRet_code();
      if (retCode != 0) {
        String errorMessage=response.getMessage();
        if (retCode >= 5000) {
          QingCloudServiceException exception=new QingCloudServiceException(errorMessage);
          exception.setServiceName(action);
          exception.setStatusCode(code);
          exception.setErrorCode(retCode);
          exception.setErrorMessage(errorMessage);
          throw exception;
        }
 else {
          QingCloudClientException exception=new QingCloudClientException(errorMessage);
          exception.setServiceName(action);
          exception.setErrorCode(retCode);
          exception.setErrorMessage(errorMessage);
          throw exception;
        }
      }
      return message;
    }
  }
 catch (  IOException e) {
    throw e;
  }
 finally {
    safeClose(content);
    connection.disconnect();
  }
}","private String sendRequest(String httpMethod,String action,Request request) throws QingCloudClientException, QingCloudServiceException, IOException {
  Map<String,String> parameters=request.toMap();
  addCommonParams(httpMethod,action,parameters);
  for (  Map.Entry<String,String> entry : parameters.entrySet()) {
    String key=entry.getKey();
    String value=entry.getValue();
    if (DEBUG)     System.out.println(String.format(""String_Node_Str"",key,value));
  }
  InputStream content=null;
  HttpURLConnection connection=null;
  try {
    String query=paramsToQueryString(parameters);
    URL url=new URL(ENDPOINT + ""String_Node_Str"" + query);
    if (DEBUG)     System.out.println(""String_Node_Str"" + url);
    connection=(HttpURLConnection)url.openConnection();
    connection.connect();
    int code=connection.getResponseCode();
    if (DEBUG)     System.out.println(""String_Node_Str"" + code);
    if (code >= 400) {
      content=connection.getErrorStream();
      String message=readContent(content);
      QingCloudServiceException exception=new QingCloudServiceException(message);
      exception.setServiceName(action);
      exception.setStatusCode(code);
      throw exception;
    }
 else {
      content=connection.getInputStream();
      String message=readContent(content);
      if (DEBUG)       System.out.println(""String_Node_Str"" + message);
      Response response=Response.fromJson(message);
      int retCode=response.getRet_code();
      if (retCode != 0) {
        String errorMessage=response.getMessage();
        if (retCode >= 5000) {
          QingCloudServiceException exception=new QingCloudServiceException(errorMessage);
          exception.setServiceName(action);
          exception.setStatusCode(code);
          exception.setErrorCode(retCode);
          exception.setErrorMessage(errorMessage);
          throw exception;
        }
 else {
          QingCloudClientException exception=new QingCloudClientException(errorMessage);
          exception.setServiceName(action);
          exception.setErrorCode(retCode);
          exception.setErrorMessage(errorMessage);
          throw exception;
        }
      }
      return message;
    }
  }
 catch (  IOException e) {
    throw e;
  }
 finally {
    safeClose(content);
  }
}"
13666,"private String sendRequest(String httpMethod,String action,Request request) throws QingCloudClientException, QingCloudServiceException, IOException {
  Map<String,String> parameters=request.toMap();
  addCommonParams(httpMethod,action,parameters);
  for (  Map.Entry<String,String> entry : parameters.entrySet()) {
    String key=entry.getKey();
    String value=entry.getValue();
    if (DEBUG)     System.out.println(String.format(""String_Node_Str"",key,value));
  }
  InputStream content=null;
  HttpURLConnection connection=null;
  try {
    String query=paramsToQueryString(parameters);
    URL url=new URL(endpoint + ""String_Node_Str"" + query);
    if (DEBUG)     System.out.println(""String_Node_Str"" + url);
    connection=(HttpURLConnection)url.openConnection();
    connection.connect();
    int code=connection.getResponseCode();
    if (DEBUG)     System.out.println(""String_Node_Str"" + code);
    if (code >= 400) {
      content=connection.getErrorStream();
      String message=readContent(content);
      QingCloudServiceException exception=new QingCloudServiceException(message);
      exception.setServiceName(action);
      exception.setStatusCode(code);
      throw exception;
    }
 else {
      content=connection.getInputStream();
      String message=readContent(content);
      if (DEBUG)       System.out.println(""String_Node_Str"" + message);
      Response response=Response.fromJson(message);
      int retCode=response.getRet_code();
      if (retCode != 0) {
        String errorMessage=response.getMessage();
        if (retCode >= 5000) {
          QingCloudServiceException exception=new QingCloudServiceException(errorMessage);
          exception.setServiceName(action);
          exception.setStatusCode(code);
          exception.setErrorCode(retCode);
          exception.setErrorMessage(errorMessage);
          throw exception;
        }
 else {
          QingCloudClientException exception=new QingCloudClientException(errorMessage);
          exception.setServiceName(action);
          exception.setErrorCode(retCode);
          exception.setErrorMessage(errorMessage);
          throw exception;
        }
      }
      return message;
    }
  }
 catch (  IOException e) {
    throw e;
  }
 finally {
    safeClose(content);
    connection.disconnect();
  }
}","private String sendRequest(String httpMethod,String action,Request request) throws QingCloudClientException, QingCloudServiceException, IOException {
  Map<String,String> parameters=request.toMap();
  addCommonParams(httpMethod,action,parameters);
  for (  Map.Entry<String,String> entry : parameters.entrySet()) {
    String key=entry.getKey();
    String value=entry.getValue();
    if (DEBUG)     System.out.println(String.format(""String_Node_Str"",key,value));
  }
  InputStream content=null;
  HttpURLConnection connection=null;
  try {
    String query=paramsToQueryString(parameters);
    URL url=new URL(endpoint + ""String_Node_Str"" + query);
    if (DEBUG)     System.out.println(""String_Node_Str"" + url);
    connection=(HttpURLConnection)url.openConnection();
    connection.connect();
    int code=connection.getResponseCode();
    if (DEBUG)     System.out.println(""String_Node_Str"" + code);
    if (code >= 400) {
      content=connection.getErrorStream();
      String message=readContent(content);
      QingCloudServiceException exception=new QingCloudServiceException(message);
      exception.setServiceName(action);
      exception.setStatusCode(code);
      throw exception;
    }
 else {
      content=connection.getInputStream();
      String message=readContent(content);
      if (DEBUG)       System.out.println(""String_Node_Str"" + message);
      Response response=Response.fromJson(message);
      int retCode=response.getRet_code();
      if (retCode != 0) {
        String errorMessage=response.getMessage();
        if (retCode >= 5000) {
          QingCloudServiceException exception=new QingCloudServiceException(errorMessage);
          exception.setServiceName(action);
          exception.setStatusCode(code);
          exception.setErrorCode(retCode);
          exception.setErrorMessage(errorMessage);
          throw exception;
        }
 else {
          QingCloudClientException exception=new QingCloudClientException(errorMessage);
          exception.setServiceName(action);
          exception.setErrorCode(retCode);
          exception.setErrorMessage(errorMessage);
          throw exception;
        }
      }
      return message;
    }
  }
 catch (  IOException e) {
    throw e;
  }
 finally {
    safeClose(content);
  }
}"
13667,"public QingCloudWSClient(String accessKeyId,String secretKey,String endPoint){
  this.accessKeyId=accessKeyId;
  this.secretKey=secretKey;
  if (endPoint != null && endPoint.trim().length() > 0) {
    this.endpoint=endPoint.trim();
  }
}","public QingCloudWSClient(String accessKeyId,String secretKey,String endPoint){
  this.accessKeyId=accessKeyId;
  this.secretKey=secretKey;
  if (endPoint != null && endPoint.trim().length() > 0) {
    this.endpoint=endPoint.trim();
    if (!this.endpoint.endsWith(""String_Node_Str"")) {
      this.endpoint+=""String_Node_Str"";
    }
  }
}"
13668,"public void setPublic_key(Integer public_key){
  this.public_key=public_key;
}","public void setPublic_key(String public_key){
  this.public_key=public_key;
}"
13669,"public Integer getPublic_key(){
  return public_key;
}","public String getPublic_key(){
  return public_key;
}"
13670,"public String post(String urlStr,Map<String,String> para) throws Exception {
  urlStr=preProcessUrl(urlStr);
  HttpURLConnection getCon=(HttpURLConnection)new URL(urlStr).openConnection();
  getCon.connect();
  String cookie=getCon.getHeaderField(""String_Node_Str"");
  cookie=cookie.substring(0,cookie.indexOf(""String_Node_Str""));
  HttpURLConnection postCon=(HttpURLConnection)new URL(urlStr).openConnection();
  postCon.setRequestMethod(""String_Node_Str"");
  postCon.setDoOutput(true);
  postCon.setDoInput(true);
  postCon.setRequestProperty(""String_Node_Str"",cookie);
  OutputStream os=postCon.getOutputStream();
  OutputStreamWriter out=new OutputStreamWriter(os);
  Iterator<String> keys=para.keySet().iterator();
  while (keys.hasNext()) {
    String key=keys.next();
    String value=para.get(key);
    key=URLEncoder.encode(key,""String_Node_Str"");
    value=URLEncoder.encode(value,""String_Node_Str"");
    out.write(key + ""String_Node_Str"" + value);
  }
  out.close();
  InputStream is=postCon.getInputStream();
  StringBuffer sb=readStream(is);
  String resultFlag=""String_Node_Str"";
  int start=sb.indexOf(resultFlag);
  String result=sb.substring(start + resultFlag.length());
  return ResultConverter.convert2Xml(result);
}","public String post(String urlStr,Map<String,String> para) throws Exception {
  urlStr=preProcessUrl(urlStr);
  HttpURLConnection getCon=(HttpURLConnection)new URL(urlStr).openConnection();
  getCon.connect();
  String cookie=getCon.getHeaderField(""String_Node_Str"");
  cookie=cookie.substring(0,cookie.indexOf(""String_Node_Str""));
  String nonceStr=findVMwareSessionNonce(getCon.getInputStream());
  HttpURLConnection postCon=(HttpURLConnection)new URL(urlStr).openConnection();
  postCon.setRequestMethod(""String_Node_Str"");
  postCon.setDoOutput(true);
  postCon.setDoInput(true);
  postCon.setRequestProperty(""String_Node_Str"",cookie);
  OutputStream os=postCon.getOutputStream();
  OutputStreamWriter out=new OutputStreamWriter(os);
  if (nonceStr != null) {
    out.write(NONCE + ""String_Node_Str"" + nonceStr);
  }
  Iterator<String> keys=para.keySet().iterator();
  while (keys.hasNext()) {
    String key=keys.next();
    String value=para.get(key);
    key=URLEncoder.encode(key,""String_Node_Str"");
    value=URLEncoder.encode(value,""String_Node_Str"");
    out.write(key + ""String_Node_Str"" + value);
  }
  out.close();
  InputStream is=postCon.getInputStream();
  StringBuffer sb=readStream(is);
  String resultFlag=""String_Node_Str"";
  int start=sb.indexOf(resultFlag);
  String result=sb.substring(start + resultFlag.length());
  return ResultConverter.convert2Xml(result);
}"
13671,"public InputStream post(String soapMsg) throws IOException {
  HttpURLConnection postCon=(HttpURLConnection)baseUrl.openConnection();
  if (connectTimeout > 0)   postCon.setConnectTimeout(connectTimeout);
  if (readTimeout > 0)   postCon.setReadTimeout(readTimeout);
  try {
    postCon.setRequestMethod(""String_Node_Str"");
  }
 catch (  ProtocolException e) {
    e.printStackTrace();
  }
  postCon.setDoOutput(true);
  postCon.setDoInput(true);
  postCon.setRequestProperty(SOAP_ACTION_HEADER,soapAction);
  if (cookie != null) {
    postCon.setRequestProperty(""String_Node_Str"",cookie);
  }
  OutputStream os=postCon.getOutputStream();
  OutputStreamWriter out=new OutputStreamWriter(os);
  out.write(soapMsg);
  out.close();
  InputStream is;
  try {
    is=postCon.getInputStream();
  }
 catch (  IOException ioe) {
    is=postCon.getErrorStream();
  }
  if (cookie == null) {
    cookie=postCon.getHeaderField(""String_Node_Str"");
  }
  return is;
}","public InputStream post(String soapMsg) throws IOException {
  HttpURLConnection postCon=(HttpURLConnection)baseUrl.openConnection();
  if (connectTimeout > 0)   postCon.setConnectTimeout(connectTimeout);
  if (readTimeout > 0)   postCon.setReadTimeout(readTimeout);
  try {
    postCon.setRequestMethod(""String_Node_Str"");
  }
 catch (  ProtocolException e) {
    e.printStackTrace();
  }
  postCon.setDoOutput(true);
  postCon.setDoInput(true);
  postCon.setRequestProperty(SOAP_ACTION_HEADER,soapAction);
  postCon.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  if (cookie != null) {
    postCon.setRequestProperty(""String_Node_Str"",cookie);
  }
  OutputStream os=postCon.getOutputStream();
  OutputStreamWriter out=new OutputStreamWriter(os,""String_Node_Str"");
  out.write(soapMsg);
  out.close();
  InputStream is;
  try {
    is=postCon.getInputStream();
  }
 catch (  IOException ioe) {
    is=postCon.getErrorStream();
  }
  if (cookie == null) {
    cookie=postCon.getHeaderField(""String_Node_Str"");
  }
  return is;
}"
13672,"/** 
 * Copyright 2009 NetApp, contribution by Eric Forgette Modified by Steve Jin (sjin@vmware.com) This constructor builds a new ServiceInstance based on a ServiceInstance. The new ServiceInstance is effectively a clone of the first.  This clone will NOT become invalid when the first is logged out.
 * @author Eric Forgette (forgette@netapp.com)
 * @throws RemoteException 
 * @throws RuntimeFault 
 * @throws InvalidLogin 
 * @throws MalformedURLException 
 */
public ServiceInstance cloneSession(boolean ignoreCert) throws InvalidLogin, RuntimeFault, RemoteException, MalformedURLException {
  ServiceInstance oldsi=getServerConnection().getServiceInstance();
  ServerConnection oldsc=oldsi.getServerConnection();
  String ticket=oldsi.getSessionManager().acquireCloneTicket();
  VimPortType vimService=new VimPortType(oldsc.getUrl().toString(),ignoreCert);
  vimService.getWsc().setVimNameSpace(oldsc.getVimService().getWsc().getVimNameSpace());
  ServerConnection newsc=new ServerConnection(oldsc.getUrl(),vimService,null);
  ServiceInstance newsi=new ServiceInstance(newsc);
  newsc.setServiceInstance(newsi);
  UserSession userSession=newsi.getSessionManager().cloneSession(ticket);
  newsc.setUserSession(userSession);
  return newsi;
}","/** 
 * Copyright 2009 NetApp, contribution by Eric Forgette Modified by Steve Jin (sjin@vmware.com) This constructor builds a new ServiceInstance based on a ServiceInstance. The new ServiceInstance is effectively a clone of the first.  This clone will NOT become invalid when the first is logged out.
 * @author Eric Forgette (forgette@netapp.com)
 * @throws RemoteException 
 * @throws RuntimeFault 
 * @throws InvalidLogin 
 * @throws MalformedURLException 
 */
public ServiceInstance cloneSession(boolean ignoreCert) throws InvalidLogin, RuntimeFault, RemoteException, MalformedURLException {
  ServiceInstance oldsi=getServerConnection().getServiceInstance();
  ServerConnection oldsc=oldsi.getServerConnection();
  String ticket=oldsi.getSessionManager().acquireCloneTicket();
  VimPortType vimService=new VimPortType(oldsc.getUrl().toString(),ignoreCert);
  vimService.getWsc().setVimNameSpace(oldsc.getVimService().getWsc().getVimNameSpace());
  vimService.getWsc().setSoapActionOnApiVersion(oldsi.getAboutInfo().getApiVersion());
  ServerConnection newsc=new ServerConnection(oldsc.getUrl(),vimService,null);
  ServiceInstance newsi=new ServiceInstance(newsc);
  newsc.setServiceInstance(newsi);
  UserSession userSession=newsi.getSessionManager().cloneSession(ticket);
  newsc.setUserSession(userSession);
  return newsi;
}"
13673,"private static void toXML(StringBuffer sb,String tagName,Class type,Object obj){
  Class<?> clazz=obj.getClass();
  if (clazz.isArray()) {
    if (obj.getClass() == INT_ARRAY_CLASS) {
      int[] objs=(int[])obj;
      for (int i=0; i < objs.length; i++) {
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
        sb.append(objs[i]);
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
      }
    }
 else     if (obj.getClass() == BYTE_ARRAY_CLASS) {
      byte[] objs=(byte[])obj;
      for (int i=0; i < objs.length; i++) {
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
        sb.append(objs[i]);
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
      }
    }
 else {
      Object[] objs=(Object[])obj;
      for (int i=0; i < objs.length; i++) {
        toXML(sb,tagName,type.getComponentType(),objs[i]);
      }
    }
  }
 else   if (clazz == ManagedObjectReference.class) {
    ManagedObjectReference mor=(ManagedObjectReference)obj;
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ mor.type+ ""String_Node_Str"");
    sb.append(mor.val);
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
  }
 else   if (clazz.getCanonicalName().startsWith(""String_Node_Str"")) {
    if (clazz != type) {
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ getXSIType(obj)+ ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
    }
    sb.append(obj);
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
  }
 else   if (clazz.isEnum()) {
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ obj+ ""String_Node_Str""+ tagName+ ""String_Node_Str"");
  }
 else   if (obj instanceof Calendar) {
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ DatatypeConverter.printDateTime((Calendar)obj)+ ""String_Node_Str""+ tagName+ ""String_Node_Str"");
  }
 else {
    if (clazz == type) {
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
    }
 else {
      String nameSpaceType=clazz.getSimpleName();
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ nameSpaceType+ ""String_Node_Str"");
    }
    Field[] fields=getAllFields(clazz);
    for (int i=0; i < fields.length; i++) {
      Field f=fields[i];
      String fName=f.getName();
      Object value=null;
      try {
        value=f.get(obj);
      }
 catch (      IllegalAccessException iae) {
        iae.printStackTrace();
      }
      if (value == null) {
        continue;
      }
      Class<?> fType=f.getType();
      toXML(sb,fName,fType,value);
    }
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
  }
}","private static void toXML(StringBuffer sb,String tagName,Class type,Object obj){
  Class<?> clazz=obj.getClass();
  if (clazz.isArray()) {
    if (obj.getClass() == INT_ARRAY_CLASS) {
      int[] objs=(int[])obj;
      for (int i=0; i < objs.length; i++) {
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
        sb.append(objs[i]);
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
      }
    }
 else     if (obj.getClass() == BYTE_ARRAY_CLASS) {
      byte[] objs=(byte[])obj;
      for (int i=0; i < objs.length; i++) {
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
        sb.append(objs[i]);
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
      }
    }
 else {
      Object[] objs=(Object[])obj;
      for (int i=0; i < objs.length; i++) {
        toXML(sb,tagName,type.getComponentType(),objs[i]);
      }
    }
  }
 else   if (clazz == ManagedObjectReference.class) {
    ManagedObjectReference mor=(ManagedObjectReference)obj;
    sb.append(""String_Node_Str"" + tagName);
    if (clazz != type) {
      sb.append(""String_Node_Str"" + mor.type + ""String_Node_Str"");
    }
    sb.append(""String_Node_Str"" + mor.type + ""String_Node_Str"");
    sb.append(mor.val);
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
  }
 else   if (clazz.getCanonicalName().startsWith(""String_Node_Str"")) {
    if (clazz != type) {
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ getXSIType(obj)+ ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
    }
    sb.append(obj);
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
  }
 else   if (clazz.isEnum()) {
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ obj+ ""String_Node_Str""+ tagName+ ""String_Node_Str"");
  }
 else   if (obj instanceof Calendar) {
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ DatatypeConverter.printDateTime((Calendar)obj)+ ""String_Node_Str""+ tagName+ ""String_Node_Str"");
  }
 else {
    if (clazz == type) {
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
    }
 else {
      String nameSpaceType=clazz.getSimpleName();
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ nameSpaceType+ ""String_Node_Str"");
    }
    Field[] fields=getAllFields(clazz);
    for (int i=0; i < fields.length; i++) {
      Field f=fields[i];
      String fName=f.getName();
      Object value=null;
      try {
        value=f.get(obj);
      }
 catch (      IllegalAccessException iae) {
        iae.printStackTrace();
      }
      if (value == null) {
        continue;
      }
      Class<?> fType=f.getType();
      toXML(sb,fName,fType,value);
    }
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
  }
}"
13674,"private static void toXML(StringBuffer sb,String tagName,Class type,Object obj){
  Class<?> clazz=obj.getClass();
  if (clazz.isArray()) {
    if (obj.getClass() == INT_ARRAY_CLASS) {
      int[] objs=(int[])obj;
      for (int i=0; i < objs.length; i++) {
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
        sb.append(objs[i]);
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
      }
    }
 else     if (obj.getClass() == BYTE_ARRAY_CLASS) {
      byte[] objs=(byte[])obj;
      for (int i=0; i < objs.length; i++) {
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
        sb.append(objs[i]);
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
      }
    }
 else {
      Object[] objs=(Object[])obj;
      for (int i=0; i < objs.length; i++) {
        toXML(sb,tagName,type.getComponentType(),objs[i]);
      }
    }
  }
 else   if (clazz == ManagedObjectReference.class) {
    ManagedObjectReference mor=(ManagedObjectReference)obj;
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ mor.type+ ""String_Node_Str"");
    sb.append(mor.val);
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
  }
 else   if (clazz.getCanonicalName().startsWith(""String_Node_Str"")) {
    if (clazz != type) {
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ getXSIType(obj)+ ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
    }
    sb.append(obj);
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
  }
 else   if (clazz.isEnum()) {
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ obj+ ""String_Node_Str""+ tagName+ ""String_Node_Str"");
  }
 else   if (obj instanceof Calendar) {
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ DatatypeConverter.printDateTime((Calendar)obj)+ ""String_Node_Str""+ tagName+ ""String_Node_Str"");
  }
 else {
    if (clazz == type) {
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
    }
 else {
      String nameSpaceType=clazz.getSimpleName();
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ nameSpaceType+ ""String_Node_Str"");
    }
    Field[] fields=getAllFields(clazz);
    for (int i=0; i < fields.length; i++) {
      Field f=fields[i];
      String fName=f.getName();
      Object value=null;
      try {
        value=f.get(obj);
      }
 catch (      IllegalAccessException iae) {
        iae.printStackTrace();
      }
      if (value == null) {
        continue;
      }
      Class<?> fType=f.getType();
      toXML(sb,fName,fType,value);
    }
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
  }
}","private static void toXML(StringBuffer sb,String tagName,Class type,Object obj){
  Class<?> clazz=obj.getClass();
  if (clazz.isArray()) {
    if (obj.getClass() == INT_ARRAY_CLASS) {
      int[] objs=(int[])obj;
      for (int i=0; i < objs.length; i++) {
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
        sb.append(objs[i]);
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
      }
    }
 else     if (obj.getClass() == BYTE_ARRAY_CLASS) {
      byte[] objs=(byte[])obj;
      for (int i=0; i < objs.length; i++) {
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
        sb.append(objs[i]);
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
      }
    }
 else     if (obj.getClass() == LONG_ARRAY_CLASS) {
      long[] objs=(long[])obj;
      for (int i=0; i < objs.length; i++) {
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
        sb.append(objs[i]);
        sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
      }
    }
 else {
      Object[] objs=(Object[])obj;
      for (int i=0; i < objs.length; i++) {
        toXML(sb,tagName,type.getComponentType(),objs[i]);
      }
    }
  }
 else   if (clazz == ManagedObjectReference.class) {
    ManagedObjectReference mor=(ManagedObjectReference)obj;
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ mor.type+ ""String_Node_Str"");
    sb.append(mor.val);
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
  }
 else   if (clazz.getCanonicalName().startsWith(""String_Node_Str"")) {
    if (clazz != type) {
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ getXSIType(obj)+ ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
    }
    sb.append(obj);
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
  }
 else   if (clazz.isEnum()) {
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ obj+ ""String_Node_Str""+ tagName+ ""String_Node_Str"");
  }
 else   if (obj instanceof Calendar) {
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ DatatypeConverter.printDateTime((Calendar)obj)+ ""String_Node_Str""+ tagName+ ""String_Node_Str"");
  }
 else {
    if (clazz == type) {
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
    }
 else {
      String nameSpaceType=clazz.getSimpleName();
      sb.append(""String_Node_Str"" + tagName + ""String_Node_Str""+ nameSpaceType+ ""String_Node_Str"");
    }
    Field[] fields=getAllFields(clazz);
    for (int i=0; i < fields.length; i++) {
      Field f=fields[i];
      String fName=f.getName();
      Object value=null;
      try {
        value=f.get(obj);
      }
 catch (      IllegalAccessException iae) {
        iae.printStackTrace();
      }
      if (value == null) {
        continue;
      }
      Class<?> fType=f.getType();
      toXML(sb,fName,fType,value);
    }
    sb.append(""String_Node_Str"" + tagName + ""String_Node_Str"");
  }
}"
13675,"public Profile[] findAssociatedProfile(ManagedEntity entity) throws RuntimeFault, RemoteException {
  ManagedObjectReference[] mors=getVimService().findAssociatedProfile(getMOR(),entity.getMOR());
  Profile[] pfs=new Profile[mors.length];
  for (int i=0; i < mors.length; i++) {
    pfs[i]=new Profile(getServerConnection(),mors[i]);
  }
  return pfs;
}","public Profile[] findAssociatedProfile(ManagedEntity entity) throws RuntimeFault, RemoteException {
  ManagedObjectReference[] mors=getVimService().findAssociatedProfile(getMOR(),entity.getMOR());
  return convert2Profiles(mors);
}"
13676,"public Profile[] getProfile(){
  return (Profile[])getCurrentProperty(""String_Node_Str"");
}","public Profile[] getProfile(){
  ManagedObjectReference[] mors=(ManagedObjectReference[])getCurrentProperty(""String_Node_Str"");
  return convert2Profiles(mors);
}"
13677,"public static Object fromXML(String type,Element root) throws Exception {
  List<Element> subNodes=root.elements();
  if (subNodes.size() == 0) {
    return null;
  }
  if (type.startsWith(""String_Node_Str"")) {
    if (!type.endsWith(""String_Node_Str"")) {
      Element e=subNodes.get(0);
      return createMOR(e.attributeValue(""String_Node_Str""),e.getText());
    }
 else {
      ManagedObjectReference[] mos=new ManagedObjectReference[subNodes.size()];
      for (int i=0; i < subNodes.size(); i++) {
        Element elem=(Element)subNodes.get(i);
        mos[i]=XmlGen.createMOR(elem.attributeValue(""String_Node_Str""),elem.getText());
      }
      return mos;
    }
  }
 else   if (isBasicType(type)) {
    String[] vals=new String[subNodes.size()];
    for (int i=0; i < vals.length; i++) {
      vals[i]=subNodes.get(i).getText();
    }
    return parseValue(type,vals);
  }
 else   if (type.endsWith(""String_Node_Str"")) {
    String singleTypeName=type.substring(0,type.length() - 2);
    Element e=subNodes.get(0);
    String xsiType=e.attributeValue(XSI_TYPE);
    if (xsiType != null) {
      singleTypeName=xsiType;
    }
    Class clazz=getVimClass(singleTypeName);
    Object ao=Array.newInstance(clazz,subNodes.size());
    for (int i=0; i < subNodes.size(); i++) {
      Object o=fromXml(getVimClass(singleTypeName),subNodes.get(i));
      Array.set(ao,i,o);
    }
    return ao;
  }
 else {
    return fromXml(getVimClass(type),subNodes.get(0));
  }
}","public static Object fromXML(String type,Element root) throws Exception {
  List<Element> subNodes=root.elements();
  if (subNodes.size() == 0) {
    return null;
  }
  if (type.startsWith(""String_Node_Str"")) {
    if (!type.endsWith(""String_Node_Str"")) {
      Element e=subNodes.get(0);
      return createMOR(e.attributeValue(""String_Node_Str""),e.getText());
    }
 else {
      ManagedObjectReference[] mos=new ManagedObjectReference[subNodes.size()];
      for (int i=0; i < subNodes.size(); i++) {
        Element elem=(Element)subNodes.get(i);
        mos[i]=XmlGen.createMOR(elem.attributeValue(""String_Node_Str""),elem.getText());
      }
      return mos;
    }
  }
 else   if (isBasicType(type)) {
    String[] vals=new String[subNodes.size()];
    for (int i=0; i < vals.length; i++) {
      vals[i]=subNodes.get(i).getText();
    }
    return parseValue(type,vals);
  }
 else   if (type.endsWith(""String_Node_Str"")) {
    String arrayItemTypeName=type.substring(0,type.length() - 2);
    Class clazz=getVimClass(arrayItemTypeName);
    Object ao=Array.newInstance(clazz,subNodes.size());
    for (int i=0; i < subNodes.size(); i++) {
      Element e=subNodes.get(i);
      String xsiType=e.attributeValue(XSI_TYPE);
      Object o=fromXml(getVimClass(xsiType == null ? arrayItemTypeName : xsiType),subNodes.get(i));
      Array.set(ao,i,o);
    }
    return ao;
  }
 else {
    return fromXml(getVimClass(type),subNodes.get(0));
  }
}"
13678,"public OptionManager getOvfManager(){
  return (OptionManager)createMO(getServiceContent().getOvfManager());
}","public OvfManager getOvfManager(){
  return (OvfManager)createMO(getServiceContent().getOvfManager());
}"
13679,"public void watch(PropertyFilterSpec pfs){
  mom.watch(pfs);
}","/** 
 * Add PropertyFilterSpec for advanced settings
 * @param pfs the property filter spec which specifiesthe managed objects and properties to watch.
 */
public void watch(PropertyFilterSpec pfs){
  mom.watch(pfs);
}"
13680,"public Object getCopy(ManagedObjectReference mor,String propName){
  return getCopy(mor,propName);
}","/** 
 * Get a copy of the cached property. You can change the returned object as you like
 * @param mor Managed object reference
 * @param propName property name
 * @return the data object identified by the propName.NullObject.NULL if the data object is really null
 */
public Object getCopy(ManagedObjectReference mor,String propName){
  return getCopy(mor,propName);
}"
13681,"public Object get(ManagedObjectReference mor,String propName){
  Map<ManagedObjectReference,Map<String,Object>> items=cache.getCachedItems();
  Map<String,Object> moMap=items.get(mor);
  if (moMap != null) {
    return moMap.get(propName);
  }
  return null;
}","/** 
 * Get the value of cached property whose name is propName. You should NEVER change the returned data object.
 * @param mor Managed object reference pointing to the managed object
 * @param propName Property name
 * @return the data object identified by the propName.NullObject.NULL if the data object is really null
 */
public Object get(ManagedObjectReference mor,String propName){
  Map<ManagedObjectReference,Map<String,Object>> items=cache.getCachedItems();
  Map<String,Object> moMap=items.get(mor);
  if (moMap != null) {
    return moMap.get(propName);
  }
  return null;
}"
13682,"public ServiceInstance getServiceInstance(){
  return si;
}","/** 
 * Get the corresponding ServiceInstance
 * @return ServiceInstance object
 */
public ServiceInstance getServiceInstance(){
  return si;
}"
13683,"public boolean isReady(){
  return cache.isReady();
}","/** 
 * Check if the CacheInstance is ready for retrieval
 * @return true if ready; false otherwise
 */
public boolean isReady(){
  return cache.isReady();
}"
13684,"public void start(){
  mThread=new Thread(mom);
  mThread.setName(""String_Node_Str"" + si.getServerConnection().getUrl());
  mThread.start();
}","/** 
 * Start the caching service. Called after specifying the managed objects and their properties to watch.
 */
public void start(){
  mThread=new Thread(mom);
  mThread.setName(""String_Node_Str"" + si.getServerConnection().getUrl());
  mThread.start();
}"
13685,"public void destroy(){
  mom.cleanUp();
  mThread.stop();
  si=null;
  mom=null;
  cache=null;
  mThread=null;
}","/** 
 * Destrory the caching service when no longer needed.
 */
public void destroy(){
  mom.cleanUp();
  mThread.stop();
  si=null;
  mom=null;
  cache=null;
  mThread=null;
}"
13686,"public void update(Observable obj,Object arg){
  if (arg instanceof PropertyFilterUpdate[]) {
    PropertyFilterUpdate[] pfus=(PropertyFilterUpdate[])arg;
    for (int i=0; pfus != null && i < pfus.length; i++) {
      ObjectUpdate[] ous=pfus[i].getObjectSet();
      for (int j=0; j < ous.length; j++) {
        ManagedObjectReference mor=ous[j].getObj();
        if (!items.containsKey(mor)) {
          items.put(mor,new ConcurrentHashMap<String,Object>());
        }
        Map<String,Object> moMap=items.get(mor);
        PropertyChange[] pcs=ous[j].getChangeSet();
        for (int k=0; k < pcs.length; k++) {
          moMap.put(pcs[k].getName(),pcs[k].getVal());
        }
      }
    }
  }
  isReady=true;
}","public void update(Observable obj,Object arg){
  if (arg instanceof PropertyFilterUpdate[]) {
    PropertyFilterUpdate[] pfus=(PropertyFilterUpdate[])arg;
    for (int i=0; pfus != null && i < pfus.length; i++) {
      ObjectUpdate[] ous=pfus[i].getObjectSet();
      for (int j=0; j < ous.length; j++) {
        ManagedObjectReference mor=ous[j].getObj();
        if (!items.containsKey(mor)) {
          items.put(mor,new ConcurrentHashMap<String,Object>());
        }
        Map<String,Object> moMap=items.get(mor);
        PropertyChange[] pcs=ous[j].getChangeSet();
        for (int k=0; k < pcs.length; k++) {
          Object value=pcs[k].getVal();
          value=value == null ? NULL : value;
          moMap.put(pcs[k].getName(),value);
        }
      }
    }
  }
  isReady=true;
}"
13687,"private static void fieldToXML(StringBuffer sb,String fName,String typeName,Object obj){
  if (typeName.endsWith(""String_Node_Str"")) {
    ManagedObjectReference mor=(ManagedObjectReference)obj;
    sb.append(""String_Node_Str"" + fName + ""String_Node_Str""+ mor.type+ ""String_Node_Str"");
    sb.append(mor.val);
    sb.append(""String_Node_Str"" + fName + ""String_Node_Str"");
    return;
  }
  boolean isComplexType=typeName.startsWith(PACKAGE_NAME);
  if (!isComplexType) {
    sb.append(""String_Node_Str"" + fName + ""String_Node_Str"");
    sb.append(obj);
    sb.append(""String_Node_Str"" + fName + ""String_Node_Str"");
  }
 else {
    String realFieldType=obj.getClass().getCanonicalName();
    if (realFieldType.equals(typeName)) {
      sb.append(toXML(fName,obj,null));
    }
 else {
      int lastDot=realFieldType.lastIndexOf(""String_Node_Str"");
      String nameSpaceType=realFieldType.substring(lastDot + 1);
      sb.append(toXML(fName,obj,nameSpaceType));
    }
  }
}","private static void fieldToXML(StringBuffer sb,String fName,String typeName,Object obj){
  if (typeName.endsWith(""String_Node_Str"")) {
    ManagedObjectReference mor=(ManagedObjectReference)obj;
    sb.append(""String_Node_Str"" + fName + ""String_Node_Str""+ mor.type+ ""String_Node_Str"");
    sb.append(mor.val);
    sb.append(""String_Node_Str"" + fName + ""String_Node_Str"");
    return;
  }
  boolean isComplexType=typeName.startsWith(PACKAGE_NAME);
  if (!isComplexType) {
    sb.append(""String_Node_Str"" + fName + ""String_Node_Str"");
    if (typeName.endsWith(""String_Node_Str"")) {
      sb.append(DatatypeConverter.printDateTime((Calendar)obj));
    }
 else {
      sb.append(obj);
    }
    sb.append(""String_Node_Str"" + fName + ""String_Node_Str"");
  }
 else {
    String realFieldType=obj.getClass().getCanonicalName();
    if (realFieldType.equals(typeName)) {
      sb.append(toXML(fName,obj,null));
    }
 else {
      int lastDot=realFieldType.lastIndexOf(""String_Node_Str"");
      String nameSpaceType=realFieldType.substring(lastDot + 1);
      sb.append(toXML(fName,obj,nameSpaceType));
    }
  }
}"
13688,"public static String toXML(String tag,Object obj,String nameSpaceType){
  if (obj == null) {
    return ""String_Node_Str"";
  }
  Class<?> c=obj.getClass();
  if (c.isArray()) {
    StringBuffer sb=new StringBuffer();
    Object[] objs=(Object[])obj;
    for (int i=0; i < objs.length; i++) {
      sb.append(toXML(tag,objs[i],nameSpaceType));
    }
    return sb.toString();
  }
  if (c.getSimpleName().equals(""String_Node_Str"")) {
    ManagedObjectReference mor=(ManagedObjectReference)obj;
    StringBuffer sb=new StringBuffer(""String_Node_Str"" + tag + ""String_Node_Str""+ mor.type+ ""String_Node_Str"");
    sb.append(mor.val);
    sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    return sb.toString();
  }
 else   if (c.getCanonicalName().startsWith(""String_Node_Str"")) {
    return ""String_Node_Str"" + tag + ""String_Node_Str""+ obj+ ""String_Node_Str""+ tag+ ""String_Node_Str"";
  }
 else   if (c.getSimpleName().equals(""String_Node_Str"")) {
    String dateStr=DatatypeConverter.printTime((Calendar)obj);
    return ""String_Node_Str"" + tag + ""String_Node_Str""+ dateStr+ ""String_Node_Str""+ tag+ ""String_Node_Str"";
  }
 else {
    StringBuffer sb=new StringBuffer();
    if (nameSpaceType == null) {
      sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"" + tag + ""String_Node_Str""+ nameSpaceType+ ""String_Node_Str"");
    }
    Field[] fields=getAllFields(c);
    for (int i=0; i < fields.length; i++) {
      Field f=fields[i];
      String fName=f.getName();
      Object value=null;
      try {
        value=f.get(obj);
      }
 catch (      IllegalAccessException iae) {
        iae.printStackTrace();
      }
      if (value == null) {
        continue;
      }
      String typeName=f.getType().getCanonicalName();
      Class<?> clazz=f.getType();
      if (clazz.isArray()) {
        Object[] values=(Object[])value;
        for (int j=0; values != null && j < values.length; j++) {
          fieldToXML(sb,fName,typeName,values[j]);
        }
      }
 else {
        fieldToXML(sb,fName,typeName,value);
      }
    }
    sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    return sb.toString();
  }
}","public static String toXML(String tag,Object obj,String nameSpaceType){
  if (obj == null) {
    return ""String_Node_Str"";
  }
  Class<?> c=obj.getClass();
  if (c.isArray()) {
    StringBuffer sb=new StringBuffer();
    Object[] objs=(Object[])obj;
    for (int i=0; i < objs.length; i++) {
      sb.append(toXML(tag,objs[i],nameSpaceType));
    }
    return sb.toString();
  }
  if (c.getSimpleName().equals(""String_Node_Str"")) {
    ManagedObjectReference mor=(ManagedObjectReference)obj;
    StringBuffer sb=new StringBuffer(""String_Node_Str"" + tag + ""String_Node_Str""+ mor.type+ ""String_Node_Str"");
    sb.append(mor.val);
    sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    return sb.toString();
  }
 else   if (c.getCanonicalName().startsWith(""String_Node_Str"")) {
    return ""String_Node_Str"" + tag + ""String_Node_Str""+ obj+ ""String_Node_Str""+ tag+ ""String_Node_Str"";
  }
 else {
    StringBuffer sb=new StringBuffer();
    if (nameSpaceType == null) {
      sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"" + tag + ""String_Node_Str""+ nameSpaceType+ ""String_Node_Str"");
    }
    Field[] fields=getAllFields(c);
    for (int i=0; i < fields.length; i++) {
      Field f=fields[i];
      String fName=f.getName();
      Object value=null;
      try {
        value=f.get(obj);
      }
 catch (      IllegalAccessException iae) {
        iae.printStackTrace();
      }
      if (value == null) {
        continue;
      }
      String typeName=f.getType().getCanonicalName();
      Class<?> clazz=f.getType();
      if (clazz.isArray()) {
        Object[] values=(Object[])value;
        for (int j=0; values != null && j < values.length; j++) {
          fieldToXML(sb,fName,typeName,values[j]);
        }
      }
 else {
        fieldToXML(sb,fName,typeName,value);
      }
    }
    sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    return sb.toString();
  }
}"
13689,"private static void setFieldValue(Field f,Object obj,String type,String[] values) throws IllegalArgumentException, IllegalAccessException {
  String fType=type == null ? f.getType().getSimpleName() : type;
  if (""String_Node_Str"".equals(fType) || ""String_Node_Str"".equals(fType)) {
    f.set(obj,values[0]);
  }
 else   if (""String_Node_Str"".equals(fType) || ""String_Node_Str"".equals(fType)) {
    f.set(obj,values);
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,Integer.parseInt(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,new Integer(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    int[] is=new int[values.length];
    for (int i=0; i < is.length; i++) {
      is[i]=Integer.parseInt(values[i]);
    }
    f.set(obj,is);
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,Short.parseShort(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,new Short(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    short[] ss=new short[values.length];
    for (int i=0; i < ss.length; i++) {
      ss[i]=Short.parseShort(values[i]);
    }
    f.set(obj,ss);
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,Byte.parseByte(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,new Byte(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    byte[] bs=new byte[values.length];
    for (int i=0; i < bs.length; i++) {
      bs[i]=Byte.parseByte(values[i]);
    }
    f.set(obj,bs);
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,Long.parseLong(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,new Long(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    long[] ls=new long[values.length];
    for (int i=0; i < ls.length; i++) {
      ls[i]=Long.parseLong(values[i]);
    }
    f.set(obj,ls);
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,Boolean.parseBoolean(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,new Boolean(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    boolean[] bs=new boolean[values.length];
    for (int i=0; i < bs.length; i++) {
      bs[i]=Boolean.parseBoolean(values[i]);
    }
    f.set(obj,bs);
  }
 else   if (""String_Node_Str"".equals(fType)) {
    DatatypeConverter.setDatatypeConverter(DatatypeConverterImpl.theInstance);
    Calendar cal=DatatypeConverter.parseTime(values[0]);
    f.set(obj,cal);
  }
 else {
    System.out.println(""String_Node_Str"" + f.getType().getCanonicalName() + type+ fType);
    throw new RuntimeException(""String_Node_Str"" + f.getType().getCanonicalName() + f.getName());
  }
}","private static void setFieldValue(Field f,Object obj,String type,String[] values) throws IllegalArgumentException, IllegalAccessException {
  String fType=type == null ? f.getType().getSimpleName() : type;
  if (""String_Node_Str"".equals(fType) || ""String_Node_Str"".equals(fType)) {
    f.set(obj,values[0]);
  }
 else   if (""String_Node_Str"".equals(fType) || ""String_Node_Str"".equals(fType)) {
    f.set(obj,values);
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,Integer.parseInt(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,new Integer(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    int[] is=new int[values.length];
    for (int i=0; i < is.length; i++) {
      is[i]=Integer.parseInt(values[i]);
    }
    f.set(obj,is);
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,Short.parseShort(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,new Short(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    short[] ss=new short[values.length];
    for (int i=0; i < ss.length; i++) {
      ss[i]=Short.parseShort(values[i]);
    }
    f.set(obj,ss);
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,Byte.parseByte(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,new Byte(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    byte[] bs=new byte[values.length];
    for (int i=0; i < bs.length; i++) {
      bs[i]=Byte.parseByte(values[i]);
    }
    f.set(obj,bs);
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,Long.parseLong(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,new Long(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    long[] ls=new long[values.length];
    for (int i=0; i < ls.length; i++) {
      ls[i]=Long.parseLong(values[i]);
    }
    f.set(obj,ls);
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,Boolean.parseBoolean(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    f.set(obj,new Boolean(values[0]));
  }
 else   if (""String_Node_Str"".equals(fType)) {
    boolean[] bs=new boolean[values.length];
    for (int i=0; i < bs.length; i++) {
      bs[i]=Boolean.parseBoolean(values[i]);
    }
    f.set(obj,bs);
  }
 else   if (""String_Node_Str"".equals(fType)) {
    Calendar cal=DatatypeConverter.parseTime(values[0]);
    f.set(obj,cal);
  }
 else {
    System.out.println(""String_Node_Str"" + f.getType().getCanonicalName() + type+ fType);
    throw new RuntimeException(""String_Node_Str"" + f.getType().getCanonicalName() + f.getName());
  }
}"
13690,"public static String toXML(String tag,Object obj,String nameSpaceType){
  if (obj == null) {
    return ""String_Node_Str"";
  }
  Class<?> c=obj.getClass();
  if (c.isArray()) {
    StringBuffer sb=new StringBuffer();
    Object[] objs=(Object[])obj;
    for (int i=0; i < objs.length; i++) {
      sb.append(toXML(tag,objs[i],nameSpaceType));
    }
    return sb.toString();
  }
  if (c.getSimpleName().equals(""String_Node_Str"")) {
    ManagedObjectReference mor=(ManagedObjectReference)obj;
    StringBuffer sb=new StringBuffer(""String_Node_Str"" + tag + ""String_Node_Str""+ mor.type+ ""String_Node_Str"");
    sb.append(mor.val);
    sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    return sb.toString();
  }
 else   if (c.getCanonicalName().startsWith(""String_Node_Str"")) {
    return ""String_Node_Str"" + tag + ""String_Node_Str""+ obj+ ""String_Node_Str""+ tag+ ""String_Node_Str"";
  }
 else {
    StringBuffer sb=new StringBuffer();
    if (nameSpaceType == null) {
      sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"" + tag + ""String_Node_Str""+ nameSpaceType+ ""String_Node_Str"");
    }
    Field[] fields=getAllFields(c);
    for (int i=0; i < fields.length; i++) {
      Field f=fields[i];
      String fName=f.getName();
      Object value=null;
      try {
        value=f.get(obj);
      }
 catch (      IllegalAccessException iae) {
        iae.printStackTrace();
      }
      if (value == null) {
        continue;
      }
      String typeName=f.getType().getCanonicalName();
      Class<?> clazz=f.getType();
      if (clazz.isArray()) {
        Object[] values=(Object[])value;
        for (int j=0; values != null && j < values.length; j++) {
          fieldToXML(sb,fName,typeName,values[j]);
        }
      }
 else {
        fieldToXML(sb,fName,typeName,value);
      }
    }
    sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    return sb.toString();
  }
}","public static String toXML(String tag,Object obj,String nameSpaceType){
  if (obj == null) {
    return ""String_Node_Str"";
  }
  Class<?> c=obj.getClass();
  if (c.isArray()) {
    StringBuffer sb=new StringBuffer();
    Object[] objs=(Object[])obj;
    for (int i=0; i < objs.length; i++) {
      sb.append(toXML(tag,objs[i],nameSpaceType));
    }
    return sb.toString();
  }
  if (c.getSimpleName().equals(""String_Node_Str"")) {
    ManagedObjectReference mor=(ManagedObjectReference)obj;
    StringBuffer sb=new StringBuffer(""String_Node_Str"" + tag + ""String_Node_Str""+ mor.type+ ""String_Node_Str"");
    sb.append(mor.val);
    sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    return sb.toString();
  }
 else   if (c.getCanonicalName().startsWith(""String_Node_Str"")) {
    return ""String_Node_Str"" + tag + ""String_Node_Str""+ obj+ ""String_Node_Str""+ tag+ ""String_Node_Str"";
  }
 else   if (c.getSimpleName().equals(""String_Node_Str"")) {
    String dateStr=DatatypeConverter.printTime((Calendar)obj);
    return ""String_Node_Str"" + tag + ""String_Node_Str""+ dateStr+ ""String_Node_Str""+ tag+ ""String_Node_Str"";
  }
 else {
    StringBuffer sb=new StringBuffer();
    if (nameSpaceType == null) {
      sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"" + tag + ""String_Node_Str""+ nameSpaceType+ ""String_Node_Str"");
    }
    Field[] fields=getAllFields(c);
    for (int i=0; i < fields.length; i++) {
      Field f=fields[i];
      String fName=f.getName();
      Object value=null;
      try {
        value=f.get(obj);
      }
 catch (      IllegalAccessException iae) {
        iae.printStackTrace();
      }
      if (value == null) {
        continue;
      }
      String typeName=f.getType().getCanonicalName();
      Class<?> clazz=f.getType();
      if (clazz.isArray()) {
        Object[] values=(Object[])value;
        for (int j=0; values != null && j < values.length; j++) {
          fieldToXML(sb,fName,typeName,values[j]);
        }
      }
 else {
        fieldToXML(sb,fName,typeName,value);
      }
    }
    sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    return sb.toString();
  }
}"
13691,"private static Object parseValue(String type,String[] values){
  if (""String_Node_Str"".equals(type) || ""String_Node_Str"".equals(type)) {
    return values[0];
  }
 else   if (""String_Node_Str"".equals(type)) {
    return values;
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new Integer(values[0]);
  }
 else   if (""String_Node_Str"".equals(type)) {
    int[] is=new int[values.length];
    for (int i=0; i < is.length; i++) {
      is[i]=Integer.parseInt(values[i]);
    }
    return is;
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new Short(values[0]);
  }
 else   if (""String_Node_Str"".equals(type)) {
    short[] ss=new short[values.length];
    for (int i=0; i < ss.length; i++) {
      ss[i]=Short.parseShort(values[i]);
    }
    return ss;
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new Byte(values[0]);
  }
 else   if (""String_Node_Str"".equals(type)) {
    byte[] bs=new byte[values.length];
    for (int i=0; i < bs.length; i++) {
      bs[i]=Byte.parseByte(values[i]);
    }
    return bs;
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new Long(values[0]);
  }
 else   if (""String_Node_Str"".equals(type)) {
    long[] ls=new long[values.length];
    for (int i=0; i < ls.length; i++) {
      ls[i]=Long.parseLong(values[i]);
    }
    return ls;
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new Boolean(values[0]);
  }
 else   if (""String_Node_Str"".equals(type)) {
    boolean[] bs=new boolean[values.length];
    for (int i=0; i < bs.length; i++) {
      bs[i]=Boolean.getBoolean(values[i]);
    }
    return bs;
  }
 else   if (""String_Node_Str"".equals(type)) {
    DatatypeConverter.setDatatypeConverter(DatatypeConverterImpl.theInstance);
    Calendar cal=DatatypeConverter.parseTime(values[0]);
    return cal;
  }
 else {
    System.out.println(""String_Node_Str"" + type);
  }
  return null;
}","private static Object parseValue(String type,String[] values){
  if (""String_Node_Str"".equals(type) || ""String_Node_Str"".equals(type)) {
    return values[0];
  }
 else   if (""String_Node_Str"".equals(type)) {
    return values;
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new Integer(values[0]);
  }
 else   if (""String_Node_Str"".equals(type)) {
    int[] is=new int[values.length];
    for (int i=0; i < is.length; i++) {
      is[i]=Integer.parseInt(values[i]);
    }
    return is;
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new Short(values[0]);
  }
 else   if (""String_Node_Str"".equals(type)) {
    short[] ss=new short[values.length];
    for (int i=0; i < ss.length; i++) {
      ss[i]=Short.parseShort(values[i]);
    }
    return ss;
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new Byte(values[0]);
  }
 else   if (""String_Node_Str"".equals(type)) {
    byte[] bs=new byte[values.length];
    for (int i=0; i < bs.length; i++) {
      bs[i]=Byte.parseByte(values[i]);
    }
    return bs;
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new Long(values[0]);
  }
 else   if (""String_Node_Str"".equals(type)) {
    long[] ls=new long[values.length];
    for (int i=0; i < ls.length; i++) {
      ls[i]=Long.parseLong(values[i]);
    }
    return ls;
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new Boolean(values[0]);
  }
 else   if (""String_Node_Str"".equals(type)) {
    boolean[] bs=new boolean[values.length];
    for (int i=0; i < bs.length; i++) {
      bs[i]=Boolean.getBoolean(values[i]);
    }
    return bs;
  }
 else   if (""String_Node_Str"".equals(type)) {
    Calendar cal=DatatypeConverter.parseTime(values[0]);
    return cal;
  }
 else {
    System.out.println(""String_Node_Str"" + type);
  }
  return null;
}"
13692,"/** 
 * Handle single VIM Data Object 
 */
private static Object fromXML(String type,Element node) throws Exception {
  Class<?> clazz=Class.forName(PACKAGE_NAME + ""String_Node_Str"" + type);
  Object obj=clazz.newInstance();
  List<?> subNodes=node.elements();
  for (int i=0; i < subNodes.size(); i++) {
    Element e=(Element)subNodes.get(i);
    String tagName=e.getName();
    Field field=null;
    if (tagName.equals(""String_Node_Str"") || tagName.equals(""String_Node_Str"") || tagName.equals(""String_Node_Str"")|| tagName.equals(""String_Node_Str"")|| tagName.equals(""String_Node_Str"")) {
      field=clazz.getField(""String_Node_Str"" + tagName);
    }
 else {
      field=clazz.getField(tagName);
    }
    Class<?> fType=field.getType();
    boolean isFieldArray=fType.isArray();
    String arrayTypeName=fType.getSimpleName();
    String xsiType=e.attributeValue(XSI_TYPE);
    if (xsiType != null && (!xsiType.startsWith(""String_Node_Str""))) {
      fType=Class.forName(PACKAGE_NAME + ""String_Node_Str"" + xsiType);
    }
    String fTypeFullName=fType.getCanonicalName();
    String fTypeSimpleName=fType.getSimpleName();
    if (fTypeSimpleName.startsWith(""String_Node_Str"")) {
      if (isFieldArray) {
        List<?> al=getAllArrayElements(subNodes,tagName,i,subNodes.size());
        i=i + al.size();
        ManagedObjectReference[] mos=new ManagedObjectReference[al.size()];
        for (int j=0; j < mos.length; j++) {
          Element elem=(Element)al.get(j);
          mos[j]=XmlGen.createMOR(elem.attributeValue(""String_Node_Str""),elem.getText());
        }
        field.set(obj,mos);
      }
 else {
        field.set(obj,createMOR(e.attributeValue(""String_Node_Str""),e.getText()));
      }
    }
 else     if (fType.isEnum()) {
      String enumStr=e.getText();
      Class enumClass=Class.forName(fTypeFullName);
      Object fo=Enum.valueOf(enumClass,enumStr);
      field.set(obj,fo);
    }
 else     if (((xsiType != null) && (!xsiType.startsWith(""String_Node_Str""))) || fTypeFullName.startsWith(PACKAGE_NAME)) {
      if (isFieldArray) {
        ArrayList<?> al=getAllArrayElements(subNodes,tagName,i,subNodes.size());
        i=i + al.size();
        arrayTypeName=arrayTypeName.substring(0,arrayTypeName.length() - 2);
        Object ao=Array.newInstance(Class.forName(PACKAGE_NAME + ""String_Node_Str"" + arrayTypeName),al.size());
        for (int j=0; j < al.size(); j++) {
          Element elem=(Element)al.get(j);
          String elemType=arrayTypeName;
          if (elem.attributeValue(XSI_TYPE) != null) {
            elemType=elem.attributeValue(XSI_TYPE);
          }
          Object o=fromXML(elemType,elem);
          Array.set(ao,j,o);
        }
        field.set(obj,ao);
      }
 else {
        Object o=null;
        if (xsiType != null) {
          o=fromXML(xsiType,e);
        }
 else {
          o=fromXML(fType.getSimpleName(),e);
        }
        field.set(obj,o);
      }
    }
 else {
      if (isFieldArray) {
        ArrayList<?> al=getAllArrayElements(subNodes,tagName,i,subNodes.size());
        i=i + al.size();
        String[] values=new String[al.size()];
        for (int j=0; j < values.length; j++) {
          values[j]=((Element)al.get(j)).getText();
        }
        String fTrueType=null;
        if (xsiType != null) {
          fTrueType=xsiType.substring(""String_Node_Str"".length()) + ""String_Node_Str"";
        }
 else {
          fTrueType=fTypeSimpleName;
          if (!fTrueType.endsWith(""String_Node_Str"")) {
            fTrueType=fTrueType + ""String_Node_Str"";
          }
        }
        setFieldValue(field,obj,fTrueType,values);
      }
 else {
        if (xsiType != null && xsiType.startsWith(""String_Node_Str"")) {
          xsiType=xsiType.substring(""String_Node_Str"".length());
          setFieldValue(field,obj,xsiType,new String[]{e.getText()});
        }
 else {
          setFieldValue(field,obj,xsiType,new String[]{e.getText()});
        }
      }
    }
  }
  return obj;
}","/** 
 * Handle single VIM Data Object 
 */
private static Object fromXML(String type,Element node) throws Exception {
  Class<?> clazz=Class.forName(PACKAGE_NAME + ""String_Node_Str"" + type);
  Object obj=clazz.newInstance();
  List<?> subNodes=node.elements();
  for (int i=0; i < subNodes.size(); i++) {
    Element e=(Element)subNodes.get(i);
    String tagName=e.getName();
    Field field=null;
    if (tagName.equals(""String_Node_Str"") || tagName.equals(""String_Node_Str"") || tagName.equals(""String_Node_Str"")|| tagName.equals(""String_Node_Str"")|| tagName.equals(""String_Node_Str"")) {
      field=clazz.getField(""String_Node_Str"" + tagName);
    }
 else {
      field=clazz.getField(tagName);
    }
    Class<?> fType=field.getType();
    boolean isFieldArray=fType.isArray();
    String arrayTypeName=fType.getSimpleName();
    String xsiType=e.attributeValue(XSI_TYPE);
    if (xsiType != null && (!xsiType.startsWith(""String_Node_Str""))) {
      fType=Class.forName(PACKAGE_NAME + ""String_Node_Str"" + xsiType);
    }
    String fTypeFullName=fType.getCanonicalName();
    String fTypeSimpleName=fType.getSimpleName();
    if (fTypeSimpleName.startsWith(""String_Node_Str"")) {
      if (isFieldArray) {
        List<?> al=getAllArrayElements(subNodes,tagName,i,subNodes.size());
        i=i + al.size() - 1;
        ManagedObjectReference[] mos=new ManagedObjectReference[al.size()];
        for (int j=0; j < mos.length; j++) {
          Element elem=(Element)al.get(j);
          mos[j]=XmlGen.createMOR(elem.attributeValue(""String_Node_Str""),elem.getText());
        }
        field.set(obj,mos);
      }
 else {
        field.set(obj,createMOR(e.attributeValue(""String_Node_Str""),e.getText()));
      }
    }
 else     if (fType.isEnum()) {
      String enumStr=e.getText();
      Class enumClass=Class.forName(fTypeFullName);
      Object fo=Enum.valueOf(enumClass,enumStr);
      field.set(obj,fo);
    }
 else     if (((xsiType != null) && (!xsiType.startsWith(""String_Node_Str""))) || fTypeFullName.startsWith(PACKAGE_NAME)) {
      if (isFieldArray) {
        ArrayList<?> al=getAllArrayElements(subNodes,tagName,i,subNodes.size());
        i=i + al.size() - 1;
        arrayTypeName=arrayTypeName.substring(0,arrayTypeName.length() - 2);
        Object ao=Array.newInstance(Class.forName(PACKAGE_NAME + ""String_Node_Str"" + arrayTypeName),al.size());
        for (int j=0; j < al.size(); j++) {
          Element elem=(Element)al.get(j);
          String elemType=arrayTypeName;
          if (elem.attributeValue(XSI_TYPE) != null) {
            elemType=elem.attributeValue(XSI_TYPE);
          }
          Object o=fromXML(elemType,elem);
          Array.set(ao,j,o);
        }
        field.set(obj,ao);
      }
 else {
        Object o=null;
        if (xsiType != null) {
          o=fromXML(xsiType,e);
        }
 else {
          o=fromXML(fType.getSimpleName(),e);
        }
        field.set(obj,o);
      }
    }
 else {
      if (isFieldArray) {
        ArrayList<?> al=getAllArrayElements(subNodes,tagName,i,subNodes.size());
        i=i + al.size() - 1;
        String[] values=new String[al.size()];
        for (int j=0; j < values.length; j++) {
          values[j]=((Element)al.get(j)).getText();
        }
        String fTrueType=null;
        if (xsiType != null) {
          fTrueType=xsiType.substring(""String_Node_Str"".length()) + ""String_Node_Str"";
        }
 else {
          fTrueType=fTypeSimpleName;
          if (!fTrueType.endsWith(""String_Node_Str"")) {
            fTrueType=fTrueType + ""String_Node_Str"";
          }
        }
        setFieldValue(field,obj,fTrueType,values);
      }
 else {
        if (xsiType != null && xsiType.startsWith(""String_Node_Str"")) {
          xsiType=xsiType.substring(""String_Node_Str"".length());
          setFieldValue(field,obj,xsiType,new String[]{e.getText()});
        }
 else {
          setFieldValue(field,obj,xsiType,new String[]{e.getText()});
        }
      }
    }
  }
  return obj;
}"
13693,"/** 
 * Retrieves properties from multiple managed objects.
 * @param mos the array of managed objects which could be of single type or mixed types. When they are mix-typed,the moType must be super type of all these managed objects.
 * @param moType the type of the managed object. This managed object type must have all the properties defined asin propPaths. 
 * @param propPaths the array of property path which has dot as separator, for example, ""name"", ""guest.toolsStatus"".
 * @return an array of Hashtable whose order is the same as the mos array. Each Hashtable has the properties forone managed object. Note: some of the properties you want to retrieve might not be set, and therefore you don't have an entry in the Hashtable at all. In other words, it's possible for you to get null for a property from the  resulted Hashtable.
 * @throws InvalidProperty
 * @throws RuntimeFault
 * @throws RemoteException
 */
public static Hashtable[] retrieveProperties(ManagedObject[] mos,String moType,String[] propPaths) throws InvalidProperty, RuntimeFault, RemoteException {
  if (mos == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (mos.length == 0 || mos[0] == null)   return new Hashtable[]{};
  PropertyCollector pc=mos[0].getServerConnection().getServiceInstance().getPropertyCollector();
  ObjectSpec[] oss=new ObjectSpec[mos.length];
  for (int i=0; i < oss.length; i++) {
    oss[i]=new ObjectSpec();
    oss[i].setObj(mos[i].getMOR());
  }
  PropertySpec pSpec=createPropertySpec(moType,false,propPaths);
  PropertyFilterSpec pfs=new PropertyFilterSpec(null,null,new PropertySpec[]{pSpec},oss);
  ObjectContent[] objs=pc.retrieveProperties(new PropertyFilterSpec[]{pfs});
  Hashtable[] pTables=new Hashtable[mos.length];
  for (int i=0; objs != null && i < objs.length && objs[i] != null; i++) {
    DynamicProperty[] props=objs[i].getPropSet();
    ManagedObjectReference mor=objs[i].getObj();
    int index=-1;
    if (mor.getType().equals(mos[i].getMOR().getType()) && mor.get_value().equals(mos[i].getMOR().get_value())) {
      index=i;
    }
 else {
      index=findIndex(mos,mor);
      if (index == -1)       throw new RuntimeException(""String_Node_Str"" + mor.getType() + ""String_Node_Str""+ mor.get_value());
    }
    pTables[index]=new Hashtable();
    for (int j=0; props != null && j < props.length; j++) {
      pTables[index].put(props[j].getName(),convertProperty(props[j].getVal()));
    }
  }
  return pTables;
}","/** 
 * Retrieves properties from multiple managed objects.
 * @param mos the array of managed objects which could be of single type or mixed types. When they are mix-typed,the moType must be super type of all these managed objects.
 * @param moType the type of the managed object. This managed object type must have all the properties defined asin propPaths. 
 * @param propPaths the array of property path which has dot as separator, for example, ""name"", ""guest.toolsStatus"".
 * @return an array of Hashtable whose order is the same as the mos array. Each Hashtable has the properties forone managed object. Note: some of the properties you want to retrieve might not be set, and therefore you don't have an entry in the Hashtable at all. In other words, it's possible for you to get null for a property from the  resulted Hashtable.
 * @throws InvalidProperty
 * @throws RuntimeFault
 * @throws RemoteException
 */
public static Hashtable[] retrieveProperties(ManagedObject[] mos,String moType,String[] propPaths) throws InvalidProperty, RuntimeFault, RemoteException {
  if (mos == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (mos.length == 0 || mos[0] == null)   return new Hashtable[]{};
  PropertyCollector pc=mos[0].getServerConnection().getServiceInstance().getPropertyCollector();
  ObjectSpec[] oss=new ObjectSpec[mos.length];
  for (int i=0; i < oss.length; i++) {
    oss[i]=new ObjectSpec();
    oss[i].setObj(mos[i].getMOR());
  }
  PropertySpec pSpec=createPropertySpec(moType,false,propPaths);
  PropertyFilterSpec pfs=new PropertyFilterSpec(null,null,new PropertySpec[]{pSpec},oss);
  ObjectContent[] objs=pc.retrieveProperties(new PropertyFilterSpec[]{pfs});
  Hashtable[] pTables=new Hashtable[mos.length];
  for (int i=0; objs != null && i < objs.length && objs[i] != null; i++) {
    DynamicProperty[] props=objs[i].getPropSet();
    ManagedObjectReference mor=objs[i].getObj();
    int index=-1;
    if (mor.getType().equals(mos[i].getMOR().getType()) && mor.get_value().equals(mos[i].getMOR().get_value())) {
      index=i;
    }
 else {
      index=findIndex(mos,mor);
      if (index == -1)       throw new RuntimeException(""String_Node_Str"" + mor.getType() + ""String_Node_Str""+ mor.get_value());
    }
    pTables[index]=new Hashtable();
    for (int j=0; props != null && j < props.length; j++) {
      Object obj=convertProperty(props[j].getVal());
      if (obj == null) {
        obj=NULL;
      }
      pTables[index].put(props[j].getName(),obj);
    }
  }
  return pTables;
}"
13694,"public static Object convertProperty(Object dynaPropVal){
  Object propertyValue=null;
  Class propClass=dynaPropVal.getClass();
  String propName=propClass.getName();
  if (propName.indexOf(""String_Node_Str"") != -1) {
    String methodName=propName.substring(propName.indexOf(""String_Node_Str"") + ""String_Node_Str"".length());
    try {
      Method getMethod=propClass.getMethod(""String_Node_Str"" + methodName,(Class[])null);
      if (getMethod == null) {
        getMethod=propClass.getMethod(""String_Node_Str"" + methodName.toLowerCase(),(Class[])null);
      }
      propertyValue=getMethod.invoke(dynaPropVal,(Object[])null);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (dynaPropVal.getClass().isArray()) {
    propertyValue=dynaPropVal;
  }
 else {
    propertyValue=dynaPropVal;
  }
  return propertyValue;
}","public static Object convertProperty(Object dynaPropVal){
  Object propertyValue=null;
  Class propClass=dynaPropVal.getClass();
  String propName=propClass.getName();
  if (propName.indexOf(""String_Node_Str"") != -1) {
    String methodName=propName.substring(propName.indexOf(""String_Node_Str"") + ""String_Node_Str"".length());
    try {
      Method getMethod=null;
      try {
        getMethod=propClass.getMethod(""String_Node_Str"" + methodName,(Class[])null);
      }
 catch (      NoSuchMethodException nsme) {
        getMethod=propClass.getMethod(""String_Node_Str"" + methodName.toLowerCase(),(Class[])null);
      }
      propertyValue=getMethod.invoke(dynaPropVal,(Object[])null);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (dynaPropVal.getClass().isArray()) {
    propertyValue=dynaPropVal;
  }
 else {
    propertyValue=dynaPropVal;
  }
  return propertyValue;
}"
13695,"public static String toXML(String tag,Object obj,String nameSpaceType){
  if (obj == null) {
    return ""String_Node_Str"";
  }
  Class<?> c=obj.getClass();
  if (c.isArray()) {
    StringBuffer sb=new StringBuffer();
    Object[] objs=(Object[])obj;
    for (int i=0; i < objs.length; i++) {
      sb.append(toXML(tag,objs[i],nameSpaceType));
    }
    return sb.toString();
  }
  if (c.getSimpleName().equals(""String_Node_Str"")) {
    ManagedObjectReference mor=(ManagedObjectReference)obj;
    StringBuffer sb=new StringBuffer(""String_Node_Str"" + tag + ""String_Node_Str""+ mor.type+ ""String_Node_Str"");
    sb.append(mor.val);
    sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    return sb.toString();
  }
 else   if (c.getCanonicalName().startsWith(""String_Node_Str"")) {
    return ""String_Node_Str"" + tag + ""String_Node_Str""+ obj+ ""String_Node_Str""+ tag+ ""String_Node_Str"";
  }
 else {
    StringBuffer sb=new StringBuffer();
    if (nameSpaceType == null) {
      sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"" + tag + ""String_Node_Str""+ nameSpaceType+ ""String_Node_Str"");
    }
    Field[] fields=getAllFields(c);
    for (int i=0; i < fields.length; i++) {
      Field f=fields[i];
      String fName=f.getName();
      Object value=null;
      try {
        value=f.get(obj);
      }
 catch (      IllegalAccessException iae) {
        iae.printStackTrace();
      }
      if (value == null) {
        continue;
      }
      String typeName=f.getType().getCanonicalName();
      Class<?> clazz=f.getType();
      if (clazz.isArray()) {
        Object[] values=(Object[])value;
        for (int j=0; values != null && j < values.length; j++) {
          fieldToXML(sb,fName,typeName,values[j]);
        }
      }
 else {
        fieldToXML(sb,fName,typeName,value);
      }
    }
    sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    return sb.toString();
  }
}","public static String toXML(String tag,Object obj,String nameSpaceType){
  if (obj == null) {
    return ""String_Node_Str"";
  }
  Class<?> c=obj.getClass();
  if (c.isArray()) {
    StringBuffer sb=new StringBuffer();
    Object[] objs=(Object[])obj;
    for (int i=0; i < objs.length; i++) {
      sb.append(toXML(tag,objs[i],nameSpaceType));
    }
    return sb.toString();
  }
  if (c.getSimpleName().equals(""String_Node_Str"")) {
    ManagedObjectReference mor=(ManagedObjectReference)obj;
    StringBuffer sb=new StringBuffer(""String_Node_Str"" + tag + ""String_Node_Str""+ mor.type+ ""String_Node_Str"");
    sb.append(mor.val);
    sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    return sb.toString();
  }
 else   if (c.getCanonicalName().startsWith(""String_Node_Str"")) {
    return ""String_Node_Str"" + tag + ""String_Node_Str""+ obj+ ""String_Node_Str""+ tag+ ""String_Node_Str"";
  }
 else   if (c.isEnum()) {
    return ""String_Node_Str"" + tag + ""String_Node_Str""+ obj+ ""String_Node_Str""+ tag+ ""String_Node_Str"";
  }
 else {
    StringBuffer sb=new StringBuffer();
    if (nameSpaceType == null) {
      sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"" + tag + ""String_Node_Str""+ nameSpaceType+ ""String_Node_Str"");
    }
    Field[] fields=getAllFields(c);
    for (int i=0; i < fields.length; i++) {
      Field f=fields[i];
      String fName=f.getName();
      Object value=null;
      try {
        value=f.get(obj);
      }
 catch (      IllegalAccessException iae) {
        iae.printStackTrace();
      }
      if (value == null) {
        continue;
      }
      String typeName=f.getType().getCanonicalName();
      Class<?> clazz=f.getType();
      if (clazz.isArray()) {
        Object[] values=(Object[])value;
        for (int j=0; values != null && j < values.length; j++) {
          fieldToXML(sb,fName,typeName,values[j]);
        }
      }
 else {
        fieldToXML(sb,fName,typeName,value);
      }
    }
    sb.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    return sb.toString();
  }
}"
13696,"/** 
 * Find a VM by its location on a datastore
 * @param datacenter The datacenter within which it searches.
 * @param dPath The datastore path, for example, ""[storage1] WinXP/WinXP.vmx"".
 * @return A VirtualMachine that pointed by the dPath
 * @throws RemoteException 
 * @throws RuntimeFault 
 * @throws InvalidDatastore 
 */
public VirtualMachine findByDatastorePath(Datacenter datacenter,String dPath) throws InvalidDatastore, RuntimeFault, RemoteException {
  if (datacenter == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ManagedObjectReference mor=getVimService().findByDatastorePath(getMOR(),datacenter.getMOR(),dPath);
  return new VirtualMachine(getServerConnection(),mor);
}","/** 
 * Find a VM by its location on a datastore
 * @param datacenter The datacenter within which it searches.
 * @param dPath The datastore path, for example, ""[storage1] WinXP/WinXP.vmx"".
 * @return A VirtualMachine that pointed by the dPath
 * @throws RemoteException 
 * @throws RuntimeFault 
 * @throws InvalidDatastore 
 */
public VirtualMachine findByDatastorePath(Datacenter datacenter,String dPath) throws InvalidDatastore, RuntimeFault, RemoteException {
  if (datacenter == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ManagedObjectReference mor=getVimService().findByDatastorePath(getMOR(),datacenter.getMOR(),dPath);
  return (VirtualMachine)MorUtil.createExactManagedEntity(getServerConnection(),mor);
}"
13697,"protected void splitChromosomes(Configuration hConf) throws URISyntaxException, IOException {
  parseDictFile(hConf);
  reduces=(int)(1.75 * nodes * reducerContainersPerNode);
  int tmpReduces=reduces + 1;
  Logger.DEBUG(""String_Node_Str"" + reduces);
  double factor=0.95;
  int factoredReduces=reduces;
  ChromosomeSplitter splitter=null;
  while (tmpReduces > reduces) {
    if (bedFile != null)     splitter=new ChromosomeSplitter(dict,bedFile,factoredReduces);
 else     if (readCountsPerRegionFile != null)     splitter=new ChromosomeSplitter(dict,readCountsPerRegionFile,factoredReduces,reorderRegions);
 else     splitter=new ChromosomeSplitter(dict,factoredReduces);
    tmpReduces=splitter.getRegionCount();
    factoredReduces=(int)(factoredReduces * factor);
  }
  String bedRegions=out + ""String_Node_Str"";
  splitter.exportSplitter(bedRegions,hConf);
  reduces=splitter.getRegionCount();
  Logger.DEBUG(""String_Node_Str"" + reduces);
  HalvadeConf.setBedRegions(hConf,bedRegions);
}","protected void splitChromosomes(Configuration hConf,int nReduces) throws URISyntaxException, IOException {
  parseDictFile(hConf);
  if (nReduces == 0)   reduces=(int)(1.75 * nodes * reducerContainersPerNode);
 else   reduces=nReduces;
  int tmpReduces=reduces + 1;
  Logger.DEBUG(""String_Node_Str"" + reduces);
  double factor=0.95;
  int factoredReduces=reduces;
  ChromosomeSplitter splitter=null;
  while (tmpReduces > reduces) {
    if (bedFile != null)     splitter=new ChromosomeSplitter(dict,bedFile,factoredReduces);
 else     if (readCountsPerRegionFile != null)     splitter=new ChromosomeSplitter(dict,readCountsPerRegionFile,factoredReduces,reorderRegions);
 else     splitter=new ChromosomeSplitter(dict,factoredReduces);
    tmpReduces=splitter.getRegionCount();
    factoredReduces=(int)(factoredReduces * factor);
  }
  String bedRegions=out + ""String_Node_Str"";
  splitter.exportSplitter(bedRegions,hConf);
  reduces=splitter.getRegionCount();
  Logger.DEBUG(""String_Node_Str"" + reduces);
  HalvadeConf.setBedRegions(hConf,bedRegions);
}"
13698,"public static void setJobResources(HalvadeOptions opt,Configuration conf,int type,boolean subtractAM,boolean BAMinput) throws InterruptedException {
  int tmpmem=(int)(opt.mem * 1024);
  int tmpvcores=opt.vcores;
  BAMinput=BAMinput && type < 3;
  int mmem=RESOURCE_REQ[BAMinput ? 3 : type][0];
  int rmem=RESOURCE_REQ[type][1] == ALL ? tmpmem - MEM_AM : RESOURCE_REQ[type][1];
  if (rmem == MEM_ELPREP && !opt.useElPrep)   rmem=MEM_REF;
  if ((opt.overrideMapMem > 0 || opt.overrideRedMem > 0) && type != COMBINE) {
    if (!BAMinput && opt.overrideMapMem > 0)     mmem=opt.overrideMapMem;
    if (type != RNA_SHMEM_PASS1 && opt.overrideRedMem > 0)     rmem=opt.overrideRedMem;
  }
  if (mmem > opt.mem * 1024 || rmem > opt.mem * 1024)   throw new InterruptedException(""String_Node_Str"" + opt.mem * 1024 + ""String_Node_Str"" + Math.max(rmem,mmem));
  if (opt.setMapContainers)   opt.mapContainersPerNode=Math.min(tmpvcores,Math.max(tmpmem / mmem,1));
  if (opt.setReduceContainers)   opt.reducerContainersPerNode=Math.min(tmpvcores,Math.max(tmpmem / rmem,1));
  HalvadeConf.setVcores(conf,opt.vcores);
  opt.mthreads=Math.max(1,tmpvcores / opt.mapContainersPerNode);
  opt.rthreads=Math.max(1,tmpvcores / opt.reducerContainersPerNode);
  if (opt.smtEnabled) {
    opt.mthreads*=2;
    opt.rthreads*=2;
  }
  if (opt.mthreads > 1 && opt.mthreads % 2 == 1) {
    opt.mthreads++;
    opt.mapContainersPerNode=Math.min(Math.max(tmpvcores / opt.mthreads,1),Math.max(tmpmem / mmem,1));
  }
  opt.maps=Math.max(1,opt.nodes * opt.mapContainersPerNode);
  opt.parallel_reducers=Math.max(1,opt.nodes * opt.reducerContainersPerNode);
  Logger.DEBUG(""String_Node_Str"" + opt.maps);
  HalvadeConf.setMapContainerCount(conf,opt.maps);
  if (subtractAM)   opt.rthreads-=VCORES_AM;
  Logger.DEBUG(""String_Node_Str"" + opt.mapContainersPerNode + ""String_Node_Str""+ opt.mthreads+ ""String_Node_Str""+ mmem+ ""String_Node_Str""+ opt.reducerContainersPerNode+ ""String_Node_Str""+ opt.rthreads+ ""String_Node_Str""+ rmem+ ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + opt.mthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + mmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + opt.rthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + rmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.30 * rmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.30 * mmem) + ""String_Node_Str"");
  if (type == COMBINE) {
    conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.80 * rmem) + ""String_Node_Str"");
    conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.80 * mmem) + ""String_Node_Str"");
  }
  if (type != COMBINE)   conf.set(""String_Node_Str"",""String_Node_Str"");
  HalvadeConf.setMapThreads(conf,opt.mthreads);
  HalvadeConf.setReducerThreads(conf,opt.rthreads);
}","public static void setJobResources(HalvadeOptions opt,Configuration conf,int type,boolean subtractAM,boolean BAMinput) throws InterruptedException {
  int tmpmem=(int)(opt.mem * 1024);
  int tmpvcores=opt.vcores;
  if (subtractAM)   tmpvcores-=VCORES_AM;
  BAMinput=BAMinput && type < 3;
  int mmem=RESOURCE_REQ[BAMinput ? 3 : type][0];
  int rmem=RESOURCE_REQ[type][1] == ALL ? tmpmem - MEM_AM : RESOURCE_REQ[type][1];
  if (rmem == MEM_ELPREP && !opt.useElPrep)   rmem=MEM_REF;
  if ((opt.overrideMapMem > 0 || opt.overrideRedMem > 0) && type != COMBINE) {
    if (!BAMinput && opt.overrideMapMem > 0)     mmem=opt.overrideMapMem;
    if (type != RNA_SHMEM_PASS1 && opt.overrideRedMem > 0)     rmem=opt.overrideRedMem;
  }
  if (mmem > opt.mem * 1024 || rmem > opt.mem * 1024)   throw new InterruptedException(""String_Node_Str"" + opt.mem * 1024 + ""String_Node_Str"" + Math.max(rmem,mmem));
  if (opt.setMapContainers)   opt.mapContainersPerNode=Math.min(tmpvcores,Math.max(tmpmem / mmem,1));
  if (opt.setReduceContainers && (type != RNA_SHMEM_PASS2 || type != COMBINE))   opt.reducerContainersPerNode=Math.min(tmpvcores,Math.max(tmpmem / rmem,1));
  HalvadeConf.setVcores(conf,opt.vcores);
  opt.mthreads=Math.max(1,tmpvcores / opt.mapContainersPerNode);
  opt.rthreads=Math.max(1,tmpvcores / opt.reducerContainersPerNode);
  if (opt.smtEnabled) {
    opt.mthreads*=2;
    opt.rthreads*=2;
  }
  if (opt.mthreads > 1 && opt.mthreads % 2 == 1) {
    opt.mthreads++;
    opt.mapContainersPerNode=Math.min(Math.max(tmpvcores / opt.mthreads,1),Math.max(tmpmem / mmem,1));
  }
  opt.maps=Math.max(1,opt.nodes * opt.mapContainersPerNode);
  opt.parallel_reducers=Math.max(1,opt.nodes * opt.reducerContainersPerNode);
  Logger.DEBUG(""String_Node_Str"" + opt.maps);
  HalvadeConf.setMapContainerCount(conf,opt.maps);
  Logger.DEBUG(""String_Node_Str"" + opt.mapContainersPerNode + ""String_Node_Str""+ opt.mthreads+ ""String_Node_Str""+ mmem+ ""String_Node_Str""+ opt.reducerContainersPerNode+ ""String_Node_Str""+ opt.rthreads+ ""String_Node_Str""+ rmem+ ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + opt.mthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + mmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + opt.rthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + rmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.30 * rmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.30 * mmem) + ""String_Node_Str"");
  if (type == COMBINE) {
    conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.80 * rmem) + ""String_Node_Str"");
    conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.80 * mmem) + ""String_Node_Str"");
  }
  if (type != COMBINE)   conf.set(""String_Node_Str"",""String_Node_Str"");
  HalvadeConf.setMapThreads(conf,opt.mthreads);
  HalvadeConf.setReducerThreads(conf,opt.rthreads);
}"
13699,"protected int runHalvadeJob(Configuration halvadeConf,String tmpOutDir,int jobType) throws IOException, URISyntaxException, InterruptedException, ClassNotFoundException {
  String pipeline=""String_Node_Str"";
  if (jobType == HalvadeResourceManager.RNA_SHMEM_PASS2) {
    HalvadeConf.setIsPass2(halvadeConf,true);
    HalvadeResourceManager.setJobResources(halvadeOpts,halvadeConf,jobType,false,halvadeOpts.useBamInput);
    pipeline=RNA_PASS2;
  }
 else   if (jobType == HalvadeResourceManager.DNA) {
    HalvadeResourceManager.setJobResources(halvadeOpts,halvadeConf,jobType,false,halvadeOpts.useBamInput);
    pipeline=DNA;
  }
  halvadeOpts.splitChromosomes(halvadeConf);
  HalvadeConf.setOutDir(halvadeConf,tmpOutDir);
  FileSystem outFs=FileSystem.get(new URI(tmpOutDir),halvadeConf);
  if (outFs.exists(new Path(tmpOutDir))) {
    Logger.INFO(""String_Node_Str"" + tmpOutDir + ""String_Node_Str"");
    Logger.INFO(""String_Node_Str"");
    System.exit(-2);
  }
  if (halvadeOpts.useBamInput)   setHeaderFile(halvadeOpts.in,halvadeConf);
  if (halvadeOpts.rnaPipeline)   HalvadeConf.setPass2Suffix(halvadeConf,pass2suffix);
  Job halvadeJob=Job.getInstance(halvadeConf,""String_Node_Str"" + pipeline);
  halvadeJob.addCacheArchive(new URI(halvadeOpts.halvadeBinaries));
  halvadeJob.setJarByClass(be.ugent.intec.halvade.hadoop.mapreduce.HalvadeMapper.class);
  addInputFiles(halvadeOpts.in,halvadeConf,halvadeJob);
  FileOutputFormat.setOutputPath(halvadeJob,new Path(tmpOutDir));
  if (jobType == HalvadeResourceManager.RNA_SHMEM_PASS2) {
    halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.StarAlignPassXMapper.class);
    halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.RnaGATKReducer.class);
  }
 else   if (jobType == HalvadeResourceManager.DNA) {
    halvadeJob.setMapperClass(halvadeOpts.alignmentTools[halvadeOpts.aln]);
    halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.DnaGATKReducer.class);
  }
  halvadeJob.setMapOutputKeyClass(ChromosomeRegion.class);
  halvadeJob.setMapOutputValueClass(SAMRecordWritable.class);
  halvadeJob.setInputFormatClass(HalvadeTextInputFormat.class);
  halvadeJob.setOutputKeyClass(Text.class);
  if (halvadeOpts.mergeBam) {
    halvadeJob.setSortComparatorClass(SimpleChrRegionComparator.class);
    halvadeJob.setOutputValueClass(SAMRecordWritable.class);
  }
 else {
    halvadeJob.setPartitionerClass(ChrRgPartitioner.class);
    halvadeJob.setSortComparatorClass(ChrRgSortComparator.class);
    halvadeJob.setGroupingComparatorClass(ChrRgGroupingComparator.class);
    halvadeJob.setOutputValueClass(VariantContextWritable.class);
  }
  if (halvadeOpts.justAlign && !halvadeOpts.mergeBam)   halvadeJob.setNumReduceTasks(0);
 else   if (halvadeOpts.mergeBam) {
    halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.BamMergeReducer.class);
    halvadeJob.setNumReduceTasks(1);
  }
 else {
    halvadeJob.setNumReduceTasks(halvadeOpts.reduces);
    if (halvadeOpts.countOnly) {
      halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.CountReadsReducer.class);
      halvadeJob.setOutputValueClass(LongWritable.class);
    }
  }
  if (halvadeOpts.useBamInput) {
    halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.AlignedBamMapper.class);
    halvadeJob.setInputFormatClass(BAMInputFormat.class);
  }
  return runTimedJob(halvadeJob,""String_Node_Str"");
}","protected int runHalvadeJob(Configuration halvadeConf,String tmpOutDir,int jobType) throws IOException, URISyntaxException, InterruptedException, ClassNotFoundException {
  String pipeline=""String_Node_Str"";
  if (jobType == HalvadeResourceManager.RNA_SHMEM_PASS2) {
    HalvadeConf.setIsPass2(halvadeConf,true);
    HalvadeResourceManager.setJobResources(halvadeOpts,halvadeConf,jobType,false,halvadeOpts.useBamInput);
    pipeline=RNA_PASS2;
  }
 else   if (jobType == HalvadeResourceManager.DNA) {
    HalvadeResourceManager.setJobResources(halvadeOpts,halvadeConf,jobType,false,halvadeOpts.useBamInput);
    pipeline=DNA;
  }
  halvadeOpts.splitChromosomes(halvadeConf,0);
  HalvadeConf.setOutDir(halvadeConf,tmpOutDir);
  FileSystem outFs=FileSystem.get(new URI(tmpOutDir),halvadeConf);
  if (outFs.exists(new Path(tmpOutDir))) {
    Logger.INFO(""String_Node_Str"" + tmpOutDir + ""String_Node_Str"");
    Logger.INFO(""String_Node_Str"");
    System.exit(-2);
  }
  if (halvadeOpts.useBamInput)   setHeaderFile(halvadeOpts.in,halvadeConf);
  if (halvadeOpts.rnaPipeline)   HalvadeConf.setPass2Suffix(halvadeConf,pass2suffix);
  Job halvadeJob=Job.getInstance(halvadeConf,""String_Node_Str"" + pipeline);
  halvadeJob.addCacheArchive(new URI(halvadeOpts.halvadeBinaries));
  halvadeJob.setJarByClass(be.ugent.intec.halvade.hadoop.mapreduce.HalvadeMapper.class);
  addInputFiles(halvadeOpts.in,halvadeConf,halvadeJob);
  FileOutputFormat.setOutputPath(halvadeJob,new Path(tmpOutDir));
  if (jobType == HalvadeResourceManager.RNA_SHMEM_PASS2) {
    halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.StarAlignPassXMapper.class);
    halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.RnaGATKReducer.class);
  }
 else   if (jobType == HalvadeResourceManager.DNA) {
    halvadeJob.setMapperClass(halvadeOpts.alignmentTools[halvadeOpts.aln]);
    halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.DnaGATKReducer.class);
  }
  halvadeJob.setMapOutputKeyClass(ChromosomeRegion.class);
  halvadeJob.setMapOutputValueClass(SAMRecordWritable.class);
  halvadeJob.setInputFormatClass(HalvadeTextInputFormat.class);
  halvadeJob.setOutputKeyClass(Text.class);
  if (halvadeOpts.mergeBam) {
    halvadeJob.setSortComparatorClass(SimpleChrRegionComparator.class);
    halvadeJob.setOutputValueClass(SAMRecordWritable.class);
  }
 else {
    halvadeJob.setPartitionerClass(ChrRgPartitioner.class);
    halvadeJob.setSortComparatorClass(ChrRgSortComparator.class);
    halvadeJob.setGroupingComparatorClass(ChrRgGroupingComparator.class);
    halvadeJob.setOutputValueClass(VariantContextWritable.class);
  }
  if (halvadeOpts.justAlign && !halvadeOpts.mergeBam)   halvadeJob.setNumReduceTasks(0);
 else   if (halvadeOpts.mergeBam) {
    halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.BamMergeReducer.class);
    halvadeJob.setNumReduceTasks(1);
  }
 else {
    halvadeJob.setNumReduceTasks(halvadeOpts.reduces);
    if (halvadeOpts.countOnly) {
      halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.CountReadsReducer.class);
      halvadeJob.setOutputValueClass(LongWritable.class);
    }
  }
  if (halvadeOpts.useBamInput) {
    halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.AlignedBamMapper.class);
    halvadeJob.setInputFormatClass(BAMInputFormat.class);
  }
  return runTimedJob(halvadeJob,""String_Node_Str"");
}"
13700,"protected int runCombineJob(String halvadeOutDir,String mergeOutDir,boolean featureCount) throws IOException, URISyntaxException, InterruptedException, ClassNotFoundException {
  Configuration combineConf=getConf();
  if (!halvadeOpts.out.endsWith(""String_Node_Str""))   halvadeOpts.out+=""String_Node_Str"";
  HalvadeConf.setInputDir(combineConf,halvadeOutDir);
  HalvadeConf.setOutDir(combineConf,mergeOutDir);
  FileSystem outFs=FileSystem.get(new URI(mergeOutDir),combineConf);
  if (outFs.exists(new Path(mergeOutDir))) {
    Logger.INFO(""String_Node_Str"" + mergeOutDir + ""String_Node_Str"");
    Logger.INFO(""String_Node_Str"");
    System.exit(-2);
  }
  HalvadeConf.setReportAllVariant(combineConf,halvadeOpts.reportAll);
  HalvadeResourceManager.setJobResources(halvadeOpts,combineConf,HalvadeResourceManager.COMBINE,false,halvadeOpts.useBamInput);
  halvadeOpts.splitChromosomes(combineConf);
  Job combineJob=Job.getInstance(combineConf,""String_Node_Str"");
  combineJob.setJarByClass(be.ugent.intec.halvade.hadoop.mapreduce.VCFCombineMapper.class);
  addInputFiles(halvadeOutDir,combineConf,combineJob,featureCount ? ""String_Node_Str"" : ""String_Node_Str"");
  FileOutputFormat.setOutputPath(combineJob,new Path(mergeOutDir));
  combineJob.setMapperClass(featureCount ? be.ugent.intec.halvade.hadoop.mapreduce.HTSeqCombineMapper.class : be.ugent.intec.halvade.hadoop.mapreduce.VCFCombineMapper.class);
  combineJob.setMapOutputKeyClass(featureCount ? Text.class : LongWritable.class);
  combineJob.setMapOutputValueClass(featureCount ? LongWritable.class : VariantContextWritable.class);
  combineJob.setInputFormatClass(featureCount ? TextInputFormat.class : VCFInputFormat.class);
  combineJob.setNumReduceTasks(1);
  combineJob.setReducerClass(featureCount ? be.ugent.intec.halvade.hadoop.mapreduce.HTSeqCombineReducer.class : be.ugent.intec.halvade.hadoop.mapreduce.VCFCombineReducer.class);
  combineJob.setOutputKeyClass(Text.class);
  combineJob.setOutputValueClass(featureCount ? LongWritable.class : VariantContextWritable.class);
  return runTimedJob(combineJob,(featureCount ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
}","protected int runCombineJob(String halvadeOutDir,String mergeOutDir,boolean featureCount) throws IOException, URISyntaxException, InterruptedException, ClassNotFoundException {
  Configuration combineConf=getConf();
  if (!halvadeOpts.out.endsWith(""String_Node_Str""))   halvadeOpts.out+=""String_Node_Str"";
  HalvadeConf.setInputDir(combineConf,halvadeOutDir);
  HalvadeConf.setOutDir(combineConf,mergeOutDir);
  FileSystem outFs=FileSystem.get(new URI(mergeOutDir),combineConf);
  if (outFs.exists(new Path(mergeOutDir))) {
    Logger.INFO(""String_Node_Str"" + mergeOutDir + ""String_Node_Str"");
    Logger.INFO(""String_Node_Str"");
    System.exit(-2);
  }
  HalvadeConf.setReportAllVariant(combineConf,halvadeOpts.reportAll);
  HalvadeResourceManager.setJobResources(halvadeOpts,combineConf,HalvadeResourceManager.COMBINE,false,halvadeOpts.useBamInput);
  Job combineJob=Job.getInstance(combineConf,""String_Node_Str"");
  combineJob.setJarByClass(be.ugent.intec.halvade.hadoop.mapreduce.VCFCombineMapper.class);
  addInputFiles(halvadeOutDir,combineConf,combineJob,featureCount ? ""String_Node_Str"" : ""String_Node_Str"");
  FileOutputFormat.setOutputPath(combineJob,new Path(mergeOutDir));
  combineJob.setMapperClass(featureCount ? be.ugent.intec.halvade.hadoop.mapreduce.HTSeqCombineMapper.class : be.ugent.intec.halvade.hadoop.mapreduce.VCFCombineMapper.class);
  combineJob.setMapOutputKeyClass(featureCount ? Text.class : LongWritable.class);
  combineJob.setMapOutputValueClass(featureCount ? LongWritable.class : VariantContextWritable.class);
  combineJob.setInputFormatClass(featureCount ? TextInputFormat.class : VCFInputFormat.class);
  combineJob.setNumReduceTasks(1);
  combineJob.setReducerClass(featureCount ? be.ugent.intec.halvade.hadoop.mapreduce.HTSeqCombineReducer.class : be.ugent.intec.halvade.hadoop.mapreduce.VCFCombineReducer.class);
  combineJob.setOutputKeyClass(Text.class);
  combineJob.setOutputValueClass(featureCount ? LongWritable.class : VariantContextWritable.class);
  return runTimedJob(combineJob,(featureCount ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
}"
13701,"protected int runPass1RNAJob(Configuration pass1Conf,String tmpOutDir) throws IOException, InterruptedException, ClassNotFoundException, URISyntaxException {
  HalvadeConf.setIsPass2(pass1Conf,false);
  HalvadeResourceManager.setJobResources(halvadeOpts,pass1Conf,HalvadeResourceManager.RNA_SHMEM_PASS1,halvadeOpts.nodes == 1,halvadeOpts.useBamInput);
  halvadeOpts.splitChromosomes(pass1Conf);
  HalvadeConf.setPass2Suffix(pass1Conf,pass2suffix);
  Job pass1Job=Job.getInstance(pass1Conf,""String_Node_Str"");
  pass1Job.addCacheArchive(new URI(halvadeOpts.halvadeBinaries));
  pass1Job.setJarByClass(be.ugent.intec.halvade.hadoop.mapreduce.HalvadeMapper.class);
  FileSystem fs=FileSystem.get(new URI(halvadeOpts.in),pass1Conf);
  try {
    if (fs.getFileStatus(new Path(halvadeOpts.in)).isDirectory()) {
      FileStatus[] files=fs.listStatus(new Path(halvadeOpts.in));
      for (      FileStatus file : files) {
        if (!file.isDirectory()) {
          FileInputFormat.addInputPath(pass1Job,file.getPath());
        }
      }
    }
 else {
      FileInputFormat.addInputPath(pass1Job,new Path(halvadeOpts.in));
    }
  }
 catch (  IOException|IllegalArgumentException e) {
    Logger.EXCEPTION(e);
  }
  FileSystem outFs=FileSystem.get(new URI(tmpOutDir),pass1Conf);
  boolean skipPass1=false;
  if (outFs.exists(new Path(tmpOutDir))) {
    skipPass1=outFs.exists(new Path(tmpOutDir + ""String_Node_Str""));
    if (skipPass1)     Logger.DEBUG(""String_Node_Str"");
 else {
      Logger.INFO(""String_Node_Str"" + tmpOutDir + ""String_Node_Str"");
      Logger.INFO(""String_Node_Str"");
      System.exit(-2);
    }
  }
  if (!skipPass1) {
    FileOutputFormat.setOutputPath(pass1Job,new Path(tmpOutDir));
    pass1Job.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.StarAlignPassXMapper.class);
    pass1Job.setInputFormatClass(HalvadeTextInputFormat.class);
    pass1Job.setMapOutputKeyClass(GenomeSJ.class);
    pass1Job.setMapOutputValueClass(Text.class);
    pass1Job.setSortComparatorClass(GenomeSJSortComparator.class);
    pass1Job.setGroupingComparatorClass(GenomeSJGroupingComparator.class);
    pass1Job.setNumReduceTasks(1);
    pass1Job.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.RebuildStarGenomeReducer.class);
    pass1Job.setOutputKeyClass(LongWritable.class);
    pass1Job.setOutputValueClass(Text.class);
    return runTimedJob(pass1Job,""String_Node_Str"");
  }
 else   return 0;
}","protected int runPass1RNAJob(Configuration pass1Conf,String tmpOutDir) throws IOException, InterruptedException, ClassNotFoundException, URISyntaxException {
  HalvadeConf.setIsPass2(pass1Conf,false);
  HalvadeResourceManager.setJobResources(halvadeOpts,pass1Conf,HalvadeResourceManager.RNA_SHMEM_PASS1,halvadeOpts.nodes == 1,halvadeOpts.useBamInput);
  int pass2Reduces=HalvadeResourceManager.getPass2Reduces(halvadeOpts);
  halvadeOpts.splitChromosomes(pass1Conf,pass2Reduces);
  HalvadeConf.setPass2Suffix(pass1Conf,pass2suffix);
  Job pass1Job=Job.getInstance(pass1Conf,""String_Node_Str"");
  pass1Job.addCacheArchive(new URI(halvadeOpts.halvadeBinaries));
  pass1Job.setJarByClass(be.ugent.intec.halvade.hadoop.mapreduce.HalvadeMapper.class);
  FileSystem fs=FileSystem.get(new URI(halvadeOpts.in),pass1Conf);
  try {
    if (fs.getFileStatus(new Path(halvadeOpts.in)).isDirectory()) {
      FileStatus[] files=fs.listStatus(new Path(halvadeOpts.in));
      for (      FileStatus file : files) {
        if (!file.isDirectory()) {
          FileInputFormat.addInputPath(pass1Job,file.getPath());
        }
      }
    }
 else {
      FileInputFormat.addInputPath(pass1Job,new Path(halvadeOpts.in));
    }
  }
 catch (  IOException|IllegalArgumentException e) {
    Logger.EXCEPTION(e);
  }
  FileSystem outFs=FileSystem.get(new URI(tmpOutDir),pass1Conf);
  boolean skipPass1=false;
  if (outFs.exists(new Path(tmpOutDir))) {
    skipPass1=outFs.exists(new Path(tmpOutDir + ""String_Node_Str""));
    if (skipPass1)     Logger.DEBUG(""String_Node_Str"");
 else {
      Logger.INFO(""String_Node_Str"" + tmpOutDir + ""String_Node_Str"");
      Logger.INFO(""String_Node_Str"");
      System.exit(-2);
    }
  }
  if (!skipPass1) {
    FileOutputFormat.setOutputPath(pass1Job,new Path(tmpOutDir));
    pass1Job.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.StarAlignPassXMapper.class);
    pass1Job.setInputFormatClass(HalvadeTextInputFormat.class);
    pass1Job.setMapOutputKeyClass(GenomeSJ.class);
    pass1Job.setMapOutputValueClass(Text.class);
    pass1Job.setSortComparatorClass(GenomeSJSortComparator.class);
    pass1Job.setGroupingComparatorClass(GenomeSJGroupingComparator.class);
    pass1Job.setNumReduceTasks(1);
    pass1Job.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.RebuildStarGenomeReducer.class);
    pass1Job.setOutputKeyClass(LongWritable.class);
    pass1Job.setOutputValueClass(Text.class);
    return runTimedJob(pass1Job,""String_Node_Str"");
  }
 else   return 0;
}"
13702,"public int GetOptions(String[] args,Configuration hConf) throws IOException, URISyntaxException {
  try {
    boolean result=parseArguments(args,hConf);
    if (!result) {
      HelpFormatter formatter=new HelpFormatter();
      formatter.setWidth(80);
      formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
      return 1;
    }
    onedec=new DecimalFormat(""String_Node_Str"");
    if (localRefDir == null) {
      localRefDir=tmpDir;
    }
    HalvadeConf.setScratchTempDir(hConf,tmpDir);
    HalvadeConf.setRefDirOnScratch(hConf,localRefDir);
    HalvadeConf.setRefOnHDFS(hConf,ref);
    if (STARGenome != null) {
      HalvadeConf.setStarDirOnHDFS(hConf,STARGenome);
    }
    HalvadeConf.setKnownSitesOnHDFS(hConf,hdfsSites);
    HalvadeConf.setIsPaired(hConf,paired);
    HalvadeConf.setIsRNA(hConf,rnaPipeline);
    if (bedFile != null) {
      HalvadeConf.setBed(hConf,bedFile);
    }
    if (filterBed != null) {
      HalvadeConf.setFilterBed(hConf,filterBed);
    }
    HalvadeConf.setInputIsBam(hConf,useBamInput);
    HalvadeConf.setFixQualEnc(hConf,fixQualEnc);
    HalvadeConf.setOutDir(hConf,out);
    HalvadeConf.setKeepFiles(hConf,keepFiles);
    HalvadeConf.setFilterDBSnp(hConf,filterDBSnp);
    HalvadeConf.clearTaskFiles(hConf);
    HalvadeConf.setUseElPrep(hConf,useElPrep);
    HalvadeConf.setUpdateReadGroup(hConf,updateRG);
    HalvadeConf.setUseUnifiedGenotyper(hConf,useGenotyper);
    HalvadeConf.setMergeBam(hConf,mergeBam);
    HalvadeConf.setKeepDups(hConf,keepDups);
    HalvadeConf.setRedistribute(hConf,redistribute);
    HalvadeConf.setReadGroup(hConf,""String_Node_Str"" + RGID + ""String_Node_Str""+ RGLB+ ""String_Node_Str""+ RGPL+ ""String_Node_Str""+ RGPU+ ""String_Node_Str""+ RGSM);
    HalvadeConf.setkeepChrSplitPairs(hConf,keepChrSplitPairs);
    if (STARGenome != null) {
      HalvadeConf.setStarDirPass2HDFS(hConf,out);
    }
    if (stargtf != null) {
      HalvadeConf.setStarGtf(hConf,stargtf);
    }
    if (chr != null) {
      HalvadeConf.setChrList(hConf,chr);
    }
    if (java != null) {
      HalvadeConf.setJava(hConf,java);
    }
    if (gff != null) {
      HalvadeConf.setGff(hConf,gff);
    }
    if (stand_call_conf > 0) {
      HalvadeConf.setSCC(hConf,stand_call_conf);
    }
    if (stand_emit_conf > 0) {
      HalvadeConf.setSEC(hConf,stand_emit_conf);
    }
  }
 catch (  ParseException e) {
    Logger.DEBUG(e.getMessage());
    HelpFormatter formatter=new HelpFormatter();
    formatter.setWidth(80);
    formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
    return 1;
  }
  return 0;
}","public int GetOptions(String[] args,Configuration hConf) throws IOException, URISyntaxException {
  try {
    boolean result=parseArguments(args,hConf);
    if (!result) {
      HelpFormatter formatter=new HelpFormatter();
      formatter.setWidth(80);
      formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
      return 1;
    }
    onedec=new DecimalFormat(""String_Node_Str"");
    HalvadeConf.setRefDirIsSet(hConf,localRefDir != null);
    if (localRefDir == null) {
      localRefDir=tmpDir;
    }
    HalvadeConf.setScratchTempDir(hConf,tmpDir);
    HalvadeConf.setRefDirOnScratch(hConf,localRefDir);
    HalvadeConf.setRefOnHDFS(hConf,ref);
    if (STARGenome != null) {
      HalvadeConf.setStarDirOnHDFS(hConf,STARGenome);
    }
    HalvadeConf.setKnownSitesOnHDFS(hConf,hdfsSites);
    HalvadeConf.setIsPaired(hConf,paired);
    HalvadeConf.setIsRNA(hConf,rnaPipeline);
    if (bedFile != null) {
      HalvadeConf.setBed(hConf,bedFile);
    }
    if (filterBed != null) {
      HalvadeConf.setFilterBed(hConf,filterBed);
    }
    HalvadeConf.setInputIsBam(hConf,useBamInput);
    HalvadeConf.setFixQualEnc(hConf,fixQualEnc);
    HalvadeConf.setOutDir(hConf,out);
    HalvadeConf.setKeepFiles(hConf,keepFiles);
    HalvadeConf.setFilterDBSnp(hConf,filterDBSnp);
    HalvadeConf.clearTaskFiles(hConf);
    HalvadeConf.setUseElPrep(hConf,useElPrep);
    HalvadeConf.setUpdateReadGroup(hConf,updateRG);
    HalvadeConf.setUseUnifiedGenotyper(hConf,useGenotyper);
    HalvadeConf.setMergeBam(hConf,mergeBam);
    HalvadeConf.setKeepDups(hConf,keepDups);
    HalvadeConf.setRedistribute(hConf,redistribute);
    HalvadeConf.setReadGroup(hConf,""String_Node_Str"" + RGID + ""String_Node_Str""+ RGLB+ ""String_Node_Str""+ RGPL+ ""String_Node_Str""+ RGPU+ ""String_Node_Str""+ RGSM);
    HalvadeConf.setkeepChrSplitPairs(hConf,keepChrSplitPairs);
    if (STARGenome != null) {
      HalvadeConf.setStarDirPass2HDFS(hConf,out);
    }
    if (stargtf != null) {
      HalvadeConf.setStarGtf(hConf,stargtf);
    }
    if (chr != null) {
      HalvadeConf.setChrList(hConf,chr);
    }
    if (java != null) {
      HalvadeConf.setJava(hConf,java);
    }
    if (gff != null) {
      HalvadeConf.setGff(hConf,gff);
    }
    if (stand_call_conf > 0) {
      HalvadeConf.setSCC(hConf,stand_call_conf);
    }
    if (stand_emit_conf > 0) {
      HalvadeConf.setSEC(hConf,stand_emit_conf);
    }
  }
 catch (  ParseException e) {
    Logger.DEBUG(e.getMessage());
    HelpFormatter formatter=new HelpFormatter();
    formatter.setWidth(80);
    formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
    return 1;
  }
  return 0;
}"
13703,"@Override protected void cleanup(Context context) throws IOException, InterruptedException {
  Logger.DEBUG(""String_Node_Str"" + totalValCount);
  Logger.DEBUG(""String_Node_Str"" + totalKeyCount);
  FileSystem fs=null;
  try {
    fs=FileSystem.get(new URI(out),context.getConfiguration());
  }
 catch (  URISyntaxException ex) {
    Logger.EXCEPTION(ex);
  }
  bw.close();
  File mergeFile=new File(mergeJS);
  Logger.DEBUG(""String_Node_Str"" + count + ""String_Node_Str""+ mergeJS);
  HalvadeFileUtils.uploadFileToHDFS(context,fs,mergeFile.getAbsolutePath(),out + mergeFile.getName());
  String newGenomeDir=refDir + jobId + ""String_Node_Str"";
  File starOut=new File(newGenomeDir);
  starOut.mkdirs();
  String stargtf=HalvadeConf.getStarGtf(context.getConfiguration());
  long time=STARInstance.rebuildStarGenome(context,bin,newGenomeDir,ref,mergeJS,overhang,threads,mem,stargtf);
  context.getCounter(HalvadeCounters.TIME_STAR_BUILD).increment(time);
  String pass2GenDir=HalvadeConf.getStarDirPass2HDFS(context.getConfiguration());
  File pass2check=new File(newGenomeDir + HalvadeConf.getPass2Suffix(context.getConfiguration()));
  pass2check.createNewFile();
  Logger.DEBUG(""String_Node_Str"" + pass2check.getAbsolutePath());
  if (requireUploadToHDFS) {
    Logger.DEBUG(""String_Node_Str"");
    fs.mkdirs(new Path(pass2GenDir));
    File[] genFiles=starOut.listFiles();
    for (    File gen : genFiles) {
      HalvadeFileUtils.uploadFileToHDFS(context,fs,gen.getAbsolutePath(),pass2GenDir + gen.getName());
    }
    Logger.DEBUG(""String_Node_Str"" + pass2GenDir);
  }
  HalvadeFileUtils.removeLocalFile(mergeJS);
}","@Override protected void cleanup(Context context) throws IOException, InterruptedException {
  Logger.DEBUG(""String_Node_Str"" + totalValCount);
  Logger.DEBUG(""String_Node_Str"" + totalKeyCount);
  FileSystem fs=null;
  try {
    fs=FileSystem.get(new URI(out),context.getConfiguration());
  }
 catch (  URISyntaxException ex) {
    Logger.EXCEPTION(ex);
  }
  bw.close();
  File mergeFile=new File(mergeJS);
  Logger.DEBUG(""String_Node_Str"" + count + ""String_Node_Str""+ mergeJS);
  HalvadeFileUtils.uploadFileToHDFS(context,fs,mergeFile.getAbsolutePath(),out + mergeFile.getName());
  String newGenomeDir=refDir + jobId + ""String_Node_Str"";
  File starOut=new File(newGenomeDir);
  starOut.mkdirs();
  String stargtf=HalvadeConf.getStarGtf(context.getConfiguration());
  long time=STARInstance.rebuildStarGenome(context,bin,newGenomeDir,ref,mergeJS,overhang,threads,mem,stargtf);
  context.getCounter(HalvadeCounters.TIME_STAR_BUILD).increment(time);
  if (requireUploadToHDFS) {
    String pass2GenDir=HalvadeConf.getStarDirPass2HDFS(context.getConfiguration());
    Logger.DEBUG(""String_Node_Str"");
    fs.mkdirs(new Path(pass2GenDir));
    File[] genFiles=starOut.listFiles();
    for (    File gen : genFiles) {
      HalvadeFileUtils.uploadFileToHDFS(context,fs,gen.getAbsolutePath(),pass2GenDir + gen.getName());
    }
    Logger.DEBUG(""String_Node_Str"" + pass2GenDir);
  }
 else {
    File pass2check=new File(newGenomeDir + HalvadeConf.getPass2Suffix(context.getConfiguration()));
    pass2check.createNewFile();
    Logger.DEBUG(""String_Node_Str"" + pass2check.getAbsolutePath());
  }
  HalvadeFileUtils.removeLocalFile(mergeJS);
}"
13704,"@Override protected void setup(Context context) throws IOException, InterruptedException {
  totalValCount=0;
  totalKeyCount=0;
  keyFactors=new ArrayList<>();
  tmpDir=HalvadeConf.getScratchTempDir(context.getConfiguration());
  refDir=HalvadeConf.getRefDirOnScratch(context.getConfiguration());
  requireUploadToHDFS=refDir.startsWith(tmpDir);
  out=HalvadeConf.getOutDir(context.getConfiguration());
  jobId=context.getJobID().toString();
  taskId=context.getTaskAttemptID().toString();
  taskId=taskId.substring(taskId.indexOf(""String_Node_Str""));
  mergeJS=tmpDir + taskId + ""String_Node_Str"";
  File file=new File(mergeJS);
  threads=HalvadeConf.getReducerThreads(context.getConfiguration());
  try {
    mem=Long.parseLong(context.getConfiguration().get(""String_Node_Str""));
  }
 catch (  NumberFormatException ex) {
    mem=0;
  }
  bin=checkBinaries(context);
  try {
    ref=HalvadeFileUtils.downloadGATKIndex(context,taskId);
  }
 catch (  URISyntaxException ex) {
    Logger.EXCEPTION(ex);
    throw new InterruptedException();
  }
  bw=new BufferedWriter(new FileWriter(file.getAbsoluteFile()));
  Logger.DEBUG(""String_Node_Str"" + mergeJS);
}","@Override protected void setup(Context context) throws IOException, InterruptedException {
  totalValCount=0;
  totalKeyCount=0;
  keyFactors=new ArrayList<>();
  tmpDir=HalvadeConf.getScratchTempDir(context.getConfiguration());
  refDir=HalvadeConf.getRefDirOnScratch(context.getConfiguration());
  requireUploadToHDFS=!HalvadeConf.getRefDirIsSet(context.getConfiguration());
  out=HalvadeConf.getOutDir(context.getConfiguration());
  jobId=context.getJobID().toString();
  taskId=context.getTaskAttemptID().toString();
  taskId=taskId.substring(taskId.indexOf(""String_Node_Str""));
  mergeJS=tmpDir + taskId + ""String_Node_Str"";
  File file=new File(mergeJS);
  threads=HalvadeConf.getReducerThreads(context.getConfiguration());
  try {
    mem=Long.parseLong(context.getConfiguration().get(""String_Node_Str""));
  }
 catch (  NumberFormatException ex) {
    mem=0;
  }
  bin=checkBinaries(context);
  try {
    ref=HalvadeFileUtils.downloadGATKIndex(context,taskId);
  }
 catch (  URISyntaxException ex) {
    Logger.EXCEPTION(ex);
    throw new InterruptedException();
  }
  bw=new BufferedWriter(new FileWriter(file.getAbsoluteFile()));
  Logger.DEBUG(""String_Node_Str"" + mergeJS);
}"
13705,"public static boolean getFixQualEnc(Configuration conf){
  String s=conf.get(fixQualEnc);
  if (s.equalsIgnoreCase(""String_Node_Str""))   return true;
 else   return false;
}","public static boolean getFixQualEnc(Configuration conf){
  return conf.getBoolean(fixQualEnc,false);
}"
13706,"public static void setFixQualEnc(Configuration conf,boolean val){
  if (val)   conf.set(fixQualEnc,""String_Node_Str"");
 else   conf.set(fixQualEnc,""String_Node_Str"");
}","public static void setFixQualEnc(Configuration conf,boolean val){
  conf.setBoolean(fixQualEnc,val);
}"
13707,"@Override protected void map(LongWritable key,SAMRecordWritable value,Context context) throws IOException, InterruptedException {
  try {
    value.get().getSAMString();
  }
 catch (  StringIndexOutOfBoundsException e) {
    Logger.DEBUG(""String_Node_Str"");
  }
catch (  IllegalArgumentException ex) {
    Logger.DEBUG(""String_Node_Str"" + value.get().getReadName());
    Logger.EXCEPTION(ex);
  }
  instance.writePairedSAMRecordToContext(value.get(),false);
}","@Override protected void map(LongWritable key,SAMRecordWritable value,Context context) throws IOException, InterruptedException {
  try {
    value.get().getSAMString();
    instance.writePairedSAMRecordToContext(value.get(),false);
  }
 catch (  StringIndexOutOfBoundsException e) {
    Logger.DEBUG(""String_Node_Str"");
  }
catch (  IllegalArgumentException ex) {
    Logger.DEBUG(""String_Node_Str"" + value.get().getReadName());
    Logger.EXCEPTION(ex);
  }
}"
13708,"public HashSet<Integer> getRegions(SAMRecord sam,int read1Ref){
  int readLength=sam.getReadLength();
  int beginpos1=sam.getAlignmentStart();
  HashSet<Integer> keys=new HashSet();
  if (read1Ref >= 0)   Collections.addAll(keys,getKey(sam.getReferenceName(),beginpos1,beginpos1 + readLength));
  return keys;
}","public HashSet<Integer> getRegions(SAMRecord sam,int read1Ref){
  int beginpos1=sam.getAlignmentStart();
  int endpos1=sam.getAlignmentEnd();
  HashSet<Integer> keys=new HashSet();
  if (read1Ref >= 0)   Collections.addAll(keys,getKey(sam.getReferenceName(),beginpos1,endpos1));
  return keys;
}"
13709,"public int GetOptions(String[] args,Configuration hConf) throws IOException, URISyntaxException {
  try {
    boolean result=parseArguments(args,hConf);
    if (!result) {
      HelpFormatter formatter=new HelpFormatter();
      formatter.setWidth(80);
      formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
      return 1;
    }
    onedec=new DecimalFormat(""String_Node_Str"");
    if (localRefDir == null) {
      localRefDir=tmpDir;
    }
    HalvadeConf.setScratchTempDir(hConf,tmpDir);
    HalvadeConf.setRefDirOnScratch(hConf,localRefDir);
    HalvadeConf.setRefOnHDFS(hConf,ref);
    if (STARGenome != null) {
      HalvadeConf.setStarDirOnHDFS(hConf,STARGenome);
    }
    HalvadeConf.setKnownSitesOnHDFS(hConf,hdfsSites);
    HalvadeConf.setIsPaired(hConf,paired);
    HalvadeConf.setIsRNA(hConf,rnaPipeline);
    if (bedFile != null) {
      HalvadeConf.setBed(hConf,bedFile);
    }
    if (filterBed != null) {
      HalvadeConf.setFilterBed(hConf,filterBed);
    }
    HalvadeConf.setInputIsBam(hConf,useBamInput);
    HalvadeConf.setOutDir(hConf,out);
    HalvadeConf.setKeepFiles(hConf,keepFiles);
    HalvadeConf.setFilterDBSnp(hConf,filterDBSnp);
    HalvadeConf.clearTaskFiles(hConf);
    HalvadeConf.setUseElPrep(hConf,useElPrep);
    HalvadeConf.setUseUnifiedGenotyper(hConf,useGenotyper);
    HalvadeConf.setRedistribute(hConf,redistribute);
    HalvadeConf.setReadGroup(hConf,""String_Node_Str"" + RGID + ""String_Node_Str""+ RGLB+ ""String_Node_Str""+ RGPL+ ""String_Node_Str""+ RGPU+ ""String_Node_Str""+ RGSM);
    HalvadeConf.setkeepChrSplitPairs(hConf,keepChrSplitPairs);
    if (STARGenome != null) {
      HalvadeConf.setStarDirPass2HDFS(hConf,out);
    }
    if (chr != null) {
      HalvadeConf.setChrList(hConf,chr);
    }
    if (java != null) {
      HalvadeConf.setJava(hConf,java);
    }
    if (gff != null) {
      HalvadeConf.setGff(hConf,gff);
    }
    if (stand_call_conf > 0) {
      HalvadeConf.setSCC(hConf,stand_call_conf);
    }
    if (stand_emit_conf > 0) {
      HalvadeConf.setSEC(hConf,stand_emit_conf);
    }
    parseDictFile(hConf);
    double inputSize=getInputSize(in,hConf);
    if (coverage == -1.0) {
      coverage=Math.max(1.0,DEFAULT_COVERAGE * (inputSize / DEFAULT_COVERAGE_SIZE));
    }
    Logger.DEBUG(""String_Node_Str"" + roundOneDecimal(coverage));
    reduces=(int)(coverage * REDUCE_TASKS_FACTOR);
    Logger.DEBUG(""String_Node_Str"" + reduces);
    ChromosomeSplitter splitter;
    if (bedFile != null)     splitter=new ChromosomeSplitter(dict,bedFile,reduces);
 else     splitter=new ChromosomeSplitter(dict,reduces);
    String bedRegions=out + ""String_Node_Str"";
    splitter.exportSplitter(bedRegions,hConf);
    reduces=splitter.getRegionCount();
    Logger.DEBUG(""String_Node_Str"" + reduces);
    HalvadeConf.setBedRegions(hConf,bedRegions);
  }
 catch (  ParseException e) {
    Logger.DEBUG(e.getMessage());
    HelpFormatter formatter=new HelpFormatter();
    formatter.setWidth(80);
    formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
    return 1;
  }
  return 0;
}","public int GetOptions(String[] args,Configuration hConf) throws IOException, URISyntaxException {
  try {
    boolean result=parseArguments(args,hConf);
    if (!result) {
      HelpFormatter formatter=new HelpFormatter();
      formatter.setWidth(80);
      formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
      return 1;
    }
    onedec=new DecimalFormat(""String_Node_Str"");
    if (localRefDir == null) {
      localRefDir=tmpDir;
    }
    HalvadeConf.setScratchTempDir(hConf,tmpDir);
    HalvadeConf.setRefDirOnScratch(hConf,localRefDir);
    HalvadeConf.setRefOnHDFS(hConf,ref);
    if (STARGenome != null) {
      HalvadeConf.setStarDirOnHDFS(hConf,STARGenome);
    }
    HalvadeConf.setKnownSitesOnHDFS(hConf,hdfsSites);
    HalvadeConf.setIsPaired(hConf,paired);
    HalvadeConf.setIsRNA(hConf,rnaPipeline);
    if (bedFile != null) {
      HalvadeConf.setBed(hConf,bedFile);
    }
    if (filterBed != null) {
      HalvadeConf.setFilterBed(hConf,filterBed);
    }
    HalvadeConf.setInputIsBam(hConf,useBamInput);
    HalvadeConf.setOutDir(hConf,out);
    HalvadeConf.setKeepFiles(hConf,keepFiles);
    HalvadeConf.setFilterDBSnp(hConf,filterDBSnp);
    HalvadeConf.clearTaskFiles(hConf);
    HalvadeConf.setUseElPrep(hConf,useElPrep);
    HalvadeConf.setUseUnifiedGenotyper(hConf,useGenotyper);
    HalvadeConf.setRedistribute(hConf,redistribute);
    HalvadeConf.setReadGroup(hConf,""String_Node_Str"" + RGID + ""String_Node_Str""+ RGLB+ ""String_Node_Str""+ RGPL+ ""String_Node_Str""+ RGPU+ ""String_Node_Str""+ RGSM);
    HalvadeConf.setkeepChrSplitPairs(hConf,keepChrSplitPairs);
    if (STARGenome != null) {
      HalvadeConf.setStarDirPass2HDFS(hConf,out);
    }
    if (chr != null) {
      HalvadeConf.setChrList(hConf,chr);
    }
    if (java != null) {
      HalvadeConf.setJava(hConf,java);
    }
    if (gff != null) {
      HalvadeConf.setGff(hConf,gff);
    }
    if (stand_call_conf > 0) {
      HalvadeConf.setSCC(hConf,stand_call_conf);
    }
    if (stand_emit_conf > 0) {
      HalvadeConf.setSEC(hConf,stand_emit_conf);
    }
    parseDictFile(hConf);
    double inputSize=getInputSize(in,hConf);
    if (coverage == -1.0) {
      coverage=Math.max(1.0,DEFAULT_COVERAGE * (inputSize / DEFAULT_COVERAGE_SIZE));
    }
    Logger.DEBUG(""String_Node_Str"" + roundOneDecimal(coverage));
    reduces=(int)(coverage * REDUCE_TASKS_FACTOR);
    Logger.DEBUG(""String_Node_Str"" + reduces);
    ChromosomeSplitter splitter;
    if (bedFile != null)     splitter=new ChromosomeSplitter(dict,bedFile,reduces);
 else     if (readCountsPerRegionFile != null)     splitter=new ChromosomeSplitter(dict,readCountsPerRegionFile,reduces,reorderRegions);
 else     splitter=new ChromosomeSplitter(dict,reduces);
    String bedRegions=out + ""String_Node_Str"";
    splitter.exportSplitter(bedRegions,hConf);
    reduces=splitter.getRegionCount();
    Logger.DEBUG(""String_Node_Str"" + reduces);
    HalvadeConf.setBedRegions(hConf,bedRegions);
  }
 catch (  ParseException e) {
    Logger.DEBUG(e.getMessage());
    HelpFormatter formatter=new HelpFormatter();
    formatter.setWidth(80);
    formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
    return 1;
  }
  return 0;
}"
13710,"protected boolean parseArguments(String[] args,Configuration halvadeConf) throws ParseException {
  createOptions();
  CommandLineParser parser=new GnuParser();
  CommandLine line=parser.parse(options,args);
  in=line.getOptionValue(""String_Node_Str"");
  out=line.getOptionValue(""String_Node_Str"");
  if (!out.endsWith(""String_Node_Str""))   out+=""String_Node_Str"";
  ref=line.getOptionValue(""String_Node_Str"");
  sites=line.getOptionValue(""String_Node_Str"");
  halvadeBinaries=line.getOptionValue(""String_Node_Str"");
  hdfsSites=sites.split(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str"")) {
    useBamInput=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    rnaPipeline=true;
    if (line.hasOption(""String_Node_Str""))     STARGenome=line.getOptionValue(""String_Node_Str"");
    if (!useBamInput && STARGenome == null) {
      throw new ParseException(""String_Node_Str"");
    }
  }
  if (line.hasOption(""String_Node_Str"")) {
    tmpDir=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    localRefDir=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    nodes=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    vcores=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    smtEnabled=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    mem=Double.parseDouble(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    setMapContainers=false;
    mapContainersPerNode=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    setReduceContainers=false;
    reducerContainersPerNode=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    overrideMem=Integer.parseInt(line.getOptionValue(""String_Node_Str"")) * 1024;
  }
  if (line.hasOption(""String_Node_Str"")) {
    stand_call_conf=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    stand_emit_conf=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    reportAll=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    keepFiles=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    redistribute=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    paired=false;
  }
  if (line.hasOption(""String_Node_Str"")) {
    justAlign=true;
    combineVcf=false;
  }
  if (line.hasOption(""String_Node_Str"")) {
    aln=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
    if (aln < 0 || aln > 3)     aln=0;
  }
  if (line.hasOption(""String_Node_Str"")) {
    java=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    gff=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    dryRun=true;
    combineVcf=false;
  }
  if (line.hasOption(""String_Node_Str"")) {
    keepChrSplitPairs=false;
  }
  if (line.hasOption(""String_Node_Str"")) {
    coverage=Double.parseDouble(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    mergeBam=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    justCombine=true;
    combineVcf=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    filterDBSnp=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    useGenotyper=false;
  }
  if (line.hasOption(""String_Node_Str"")) {
    useElPrep=false;
  }
  if (line.hasOption(""String_Node_Str"")) {
    RGID=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    RGLB=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    RGPL=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    RGPU=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    RGSM=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    bedFile=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    filterBed=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    Logger.SETLEVEL(Integer.parseInt(line.getOptionValue(""String_Node_Str"")));
  }
  if (line.hasOption(""String_Node_Str"")) {
    Properties props=line.getOptionProperties(""String_Node_Str"");
    Enumeration names=props.propertyNames();
    while (names.hasMoreElements()) {
      String name=(String)names.nextElement();
      addCustomArguments(halvadeConf,name,props.getProperty(name));
    }
  }
  return true;
}","protected boolean parseArguments(String[] args,Configuration halvadeConf) throws ParseException {
  createOptions();
  CommandLineParser parser=new GnuParser();
  CommandLine line=parser.parse(options,args);
  in=line.getOptionValue(""String_Node_Str"");
  out=line.getOptionValue(""String_Node_Str"");
  if (!out.endsWith(""String_Node_Str""))   out+=""String_Node_Str"";
  ref=line.getOptionValue(""String_Node_Str"");
  sites=line.getOptionValue(""String_Node_Str"");
  halvadeBinaries=line.getOptionValue(""String_Node_Str"");
  hdfsSites=sites.split(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str"")) {
    useBamInput=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    rnaPipeline=true;
    if (line.hasOption(""String_Node_Str""))     STARGenome=line.getOptionValue(""String_Node_Str"");
    if (!useBamInput && STARGenome == null) {
      throw new ParseException(""String_Node_Str"");
    }
  }
  if (line.hasOption(""String_Node_Str"")) {
    tmpDir=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    localRefDir=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    nodes=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    vcores=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    smtEnabled=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    mem=Double.parseDouble(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    readCountsPerRegionFile=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    setMapContainers=false;
    mapContainersPerNode=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    setReduceContainers=false;
    reducerContainersPerNode=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    overrideMem=Integer.parseInt(line.getOptionValue(""String_Node_Str"")) * 1024;
  }
  if (line.hasOption(""String_Node_Str"")) {
    stand_call_conf=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    stand_emit_conf=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    reportAll=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    keepFiles=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    redistribute=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    paired=false;
  }
  if (line.hasOption(""String_Node_Str"")) {
    justAlign=true;
    combineVcf=false;
  }
  if (line.hasOption(""String_Node_Str"")) {
    aln=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
    if (aln < 0 || aln > 3)     aln=0;
  }
  if (line.hasOption(""String_Node_Str"")) {
    java=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    gff=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    dryRun=true;
    combineVcf=false;
  }
  if (line.hasOption(""String_Node_Str"")) {
    keepChrSplitPairs=false;
  }
  if (line.hasOption(""String_Node_Str"")) {
    coverage=Double.parseDouble(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    mergeBam=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    justCombine=true;
    combineVcf=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    filterDBSnp=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    reorderRegions=true;
  }
  if (line.hasOption(""String_Node_Str"")) {
    useGenotyper=false;
  }
  if (line.hasOption(""String_Node_Str"")) {
    useElPrep=false;
  }
  if (line.hasOption(""String_Node_Str"")) {
    RGID=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    RGLB=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    RGPL=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    RGPU=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    RGSM=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    bedFile=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    filterBed=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    Logger.SETLEVEL(Integer.parseInt(line.getOptionValue(""String_Node_Str"")));
  }
  if (line.hasOption(""String_Node_Str"")) {
    Properties props=line.getOptionProperties(""String_Node_Str"");
    Enumeration names=props.propertyNames();
    while (names.hasMoreElements()) {
      String name=(String)names.nextElement();
      addCustomArguments(halvadeConf,name,props.getProperty(name));
    }
  }
  return true;
}"
13711,"protected void createOptions(){
  Option optIn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optOut=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBin=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRef=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optNodes=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optVcores=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMem=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRmem=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSites=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optStarGenome=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optTmp=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optrefdir=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJava=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optID=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optLB=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPL=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPU=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSM=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCov=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optScc=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSec=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBed=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"" + ""String_Node_Str"").create(""String_Node_Str"");
  Option optFilterBed=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"" + ""String_Node_Str"").create(""String_Node_Str"");
  Option optGff=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMpn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRpn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCustomArgs=OptionBuilder.withLongOpt(""String_Node_Str"").withArgName(""String_Node_Str"").hasArgs(2).withValueSeparator().withDescription(""String_Node_Str"" + ""String_Node_Str"" + getProgramNames()).create(""String_Node_Str"");
  Option optVerbose=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optAln=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSingle=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCombine=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPp=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optFilterDBsnp=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJustAlign=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSmt=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optKeep=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optHap=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRna=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optDry=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optDrop=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optReportAll=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBamIn=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRedis=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMergeBam=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  options.addOption(optIn);
  options.addOption(optOut);
  options.addOption(optRef);
  options.addOption(optSites);
  options.addOption(optBin);
  options.addOption(optTmp);
  options.addOption(optrefdir);
  options.addOption(optSingle);
  options.addOption(optAln);
  options.addOption(optID);
  options.addOption(optLB);
  options.addOption(optPL);
  options.addOption(optPU);
  options.addOption(optSM);
  options.addOption(optPp);
  options.addOption(optFilterDBsnp);
  options.addOption(optHap);
  options.addOption(optScc);
  options.addOption(optSec);
  options.addOption(optBed);
  options.addOption(optFilterBed);
  options.addOption(optJava);
  options.addOption(optCombine);
  options.addOption(optNodes);
  options.addOption(optVcores);
  options.addOption(optMem);
  options.addOption(optKeep);
  options.addOption(optJustAlign);
  options.addOption(optCov);
  options.addOption(optMpn);
  options.addOption(optGff);
  options.addOption(optRpn);
  options.addOption(optDry);
  options.addOption(optDrop);
  options.addOption(optReportAll);
  options.addOption(optSmt);
  options.addOption(optRna);
  options.addOption(optStarGenome);
  options.addOption(optBamIn);
  options.addOption(optCustomArgs);
  options.addOption(optRedis);
  options.addOption(optRmem);
  options.addOption(optMergeBam);
  options.addOption(optVerbose);
}","protected void createOptions(){
  Option optIn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optOut=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBin=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRef=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optNodes=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optVcores=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMem=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRmem=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSites=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optStarGenome=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optTmp=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optrefdir=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJava=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optID=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optLB=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPL=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPU=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSM=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCov=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optScc=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSec=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBed=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"" + ""String_Node_Str"").create(""String_Node_Str"");
  Option optFilterBed=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"" + ""String_Node_Str"").create(""String_Node_Str"");
  Option optGff=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMpn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRpn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCustomArgs=OptionBuilder.withLongOpt(""String_Node_Str"").withArgName(""String_Node_Str"").hasArgs(2).withValueSeparator().withDescription(""String_Node_Str"" + ""String_Node_Str"" + getProgramNames()).create(""String_Node_Str"");
  Option optVerbose=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optAln=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optReadsPerRegion=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSingle=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCombine=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPp=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optFilterDBsnp=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJustAlign=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSmt=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optKeep=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optHap=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRna=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optDry=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optDrop=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optReportAll=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBamIn=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRedis=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMergeBam=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optReorderRegions=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  options.addOption(optIn);
  options.addOption(optOut);
  options.addOption(optRef);
  options.addOption(optSites);
  options.addOption(optBin);
  options.addOption(optTmp);
  options.addOption(optrefdir);
  options.addOption(optSingle);
  options.addOption(optAln);
  options.addOption(optID);
  options.addOption(optLB);
  options.addOption(optPL);
  options.addOption(optPU);
  options.addOption(optSM);
  options.addOption(optPp);
  options.addOption(optFilterDBsnp);
  options.addOption(optHap);
  options.addOption(optScc);
  options.addOption(optSec);
  options.addOption(optBed);
  options.addOption(optFilterBed);
  options.addOption(optJava);
  options.addOption(optCombine);
  options.addOption(optNodes);
  options.addOption(optVcores);
  options.addOption(optMem);
  options.addOption(optKeep);
  options.addOption(optJustAlign);
  options.addOption(optCov);
  options.addOption(optMpn);
  options.addOption(optGff);
  options.addOption(optRpn);
  options.addOption(optDry);
  options.addOption(optDrop);
  options.addOption(optReportAll);
  options.addOption(optSmt);
  options.addOption(optRna);
  options.addOption(optReadsPerRegion);
  options.addOption(optStarGenome);
  options.addOption(optBamIn);
  options.addOption(optCustomArgs);
  options.addOption(optRedis);
  options.addOption(optRmem);
  options.addOption(optMergeBam);
  options.addOption(optVerbose);
  options.addOption(optReorderRegions);
}"
13712,"public static void setJobResources(HalvadeOptions opt,Configuration conf,int type,boolean subtractAM,boolean BAMinput) throws InterruptedException {
  int tmpmem=(int)(opt.mem * 1024);
  int tmpvcores=opt.vcores;
  BAMinput=BAMinput && type < 3;
  int mmem=RESOURCE_REQ[BAMinput ? 3 : type][0];
  int rmem=RESOURCE_REQ[type][1] == ALL ? tmpmem - MEM_AM : RESOURCE_REQ[type][1];
  if (opt.overrideMem > 0 && type != COMBINE) {
    if (!BAMinput)     mmem=opt.overrideMem;
    rmem=opt.overrideMem;
  }
  if (mmem > opt.mem * 1024 || rmem > opt.mem * 1024)   throw new InterruptedException(""String_Node_Str"" + opt.mem * 1024 + ""String_Node_Str"" + Math.max(rmem,mmem));
  if (opt.setMapContainers)   opt.mapContainersPerNode=Math.min(tmpvcores,Math.max(tmpmem / mmem,1));
  if (opt.setReduceContainers)   opt.reducerContainersPerNode=Math.min(tmpvcores,Math.max(tmpmem / rmem,1));
  opt.maps=Math.max(1,opt.nodes * opt.mapContainersPerNode);
  Logger.DEBUG(""String_Node_Str"" + opt.maps);
  HalvadeConf.setMapContainerCount(conf,opt.maps);
  HalvadeConf.setVcores(conf,opt.vcores);
  opt.mthreads=Math.max(1,tmpvcores / opt.mapContainersPerNode);
  opt.rthreads=Math.max(1,tmpvcores / opt.reducerContainersPerNode);
  if (opt.smtEnabled) {
    opt.mthreads*=2;
    opt.rthreads*=2;
  }
  Logger.DEBUG(""String_Node_Str"" + opt.mapContainersPerNode + ""String_Node_Str""+ opt.mthreads+ ""String_Node_Str""+ mmem+ ""String_Node_Str""+ opt.reducerContainersPerNode+ ""String_Node_Str""+ opt.rthreads+ ""String_Node_Str""+ rmem+ ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + opt.mthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + mmem);
  if (subtractAM)   conf.set(""String_Node_Str"",""String_Node_Str"" + (opt.rthreads - VCORES_AM));
 else   conf.set(""String_Node_Str"",""String_Node_Str"" + opt.rthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + rmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.8 * rmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.8 * mmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"");
  HalvadeConf.setMapThreads(conf,opt.mthreads);
  HalvadeConf.setReducerThreads(conf,opt.rthreads);
}","public static void setJobResources(HalvadeOptions opt,Configuration conf,int type,boolean subtractAM,boolean BAMinput) throws InterruptedException {
  int tmpmem=(int)(opt.mem * 1024);
  int tmpvcores=opt.vcores;
  BAMinput=BAMinput && type < 3;
  int mmem=RESOURCE_REQ[BAMinput ? 3 : type][0];
  int rmem=RESOURCE_REQ[type][1] == ALL ? tmpmem - MEM_AM : RESOURCE_REQ[type][1];
  if (opt.overrideMem > 0 && type != COMBINE) {
    if (!BAMinput)     mmem=opt.overrideMem;
    rmem=opt.overrideMem;
  }
  if (mmem > opt.mem * 1024 || rmem > opt.mem * 1024)   throw new InterruptedException(""String_Node_Str"" + opt.mem * 1024 + ""String_Node_Str"" + Math.max(rmem,mmem));
  if (opt.setMapContainers)   opt.mapContainersPerNode=Math.min(tmpvcores,Math.max(tmpmem / mmem,1));
  if (opt.setReduceContainers)   opt.reducerContainersPerNode=Math.min(tmpvcores,Math.max(tmpmem / rmem,1));
  opt.maps=Math.max(1,opt.nodes * opt.mapContainersPerNode);
  Logger.DEBUG(""String_Node_Str"" + opt.maps);
  HalvadeConf.setMapContainerCount(conf,opt.maps);
  HalvadeConf.setVcores(conf,opt.vcores);
  opt.mthreads=Math.max(1,tmpvcores / opt.mapContainersPerNode);
  opt.rthreads=Math.max(1,tmpvcores / opt.reducerContainersPerNode);
  if (opt.smtEnabled) {
    opt.mthreads*=2;
    opt.rthreads*=2;
  }
  Logger.DEBUG(""String_Node_Str"" + opt.mapContainersPerNode + ""String_Node_Str""+ opt.mthreads+ ""String_Node_Str""+ mmem+ ""String_Node_Str""+ opt.reducerContainersPerNode+ ""String_Node_Str""+ opt.rthreads+ ""String_Node_Str""+ rmem+ ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + opt.mthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + mmem);
  if (subtractAM)   conf.set(""String_Node_Str"",""String_Node_Str"" + (opt.rthreads - VCORES_AM));
 else   conf.set(""String_Node_Str"",""String_Node_Str"" + opt.rthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + rmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.7 * rmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.8 * mmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"");
  HalvadeConf.setMapThreads(conf,opt.mthreads);
  HalvadeConf.setReducerThreads(conf,opt.rthreads);
}"
13713,"@Override public int run(String[] strings) throws Exception {
  int ret=0;
  try {
    Configuration halvadeConf=getConf();
    halvadeOpts=new HalvadeOptions();
    int optReturn=halvadeOpts.GetOptions(strings,halvadeConf);
    if (optReturn != 0)     return optReturn;
    String halvadeDir=halvadeOpts.out + ""String_Node_Str"";
    if (!halvadeOpts.justCombine) {
      if (halvadeOpts.rnaPipeline) {
        if (!halvadeOpts.useBamInput) {
          ret=runPass1RNAJob(halvadeConf,halvadeOpts.out + ""String_Node_Str"");
          if (ret != 0) {
            Logger.DEBUG(""String_Node_Str"");
            System.exit(-1);
          }
          HalvadeConf.setIsPass2(halvadeConf,true);
        }
        ret=runHalvadeJob(halvadeConf,halvadeDir,HalvadeResourceManager.RNA_SHMEM_PASS2);
      }
 else {
        ret=runHalvadeJob(halvadeConf,halvadeDir,HalvadeResourceManager.DNA);
      }
      if (ret != 0) {
        Logger.DEBUG(""String_Node_Str"");
        System.exit(-2);
      }
    }
    if (!halvadeOpts.dryRun) {
      if (halvadeOpts.combineVcf)       runCombineJob(halvadeDir,halvadeOpts.out + ""String_Node_Str"",false);
      if (halvadeOpts.gff != null)       runCombineJob(halvadeDir,halvadeOpts.out + ""String_Node_Str"",true);
    }
  }
 catch (  IOException|ClassNotFoundException|IllegalArgumentException|IllegalStateException|InterruptedException|URISyntaxException e) {
    Logger.EXCEPTION(e);
  }
  return ret;
}","@Override public int run(String[] strings) throws Exception {
  int ret=0;
  try {
    Configuration halvadeConf=getConf();
    halvadeOpts=new HalvadeOptions();
    int optReturn=halvadeOpts.GetOptions(strings,halvadeConf);
    if (optReturn != 0)     return optReturn;
    String halvadeDir=halvadeOpts.out + ""String_Node_Str"";
    if (!halvadeOpts.justCombine) {
      if (halvadeOpts.rnaPipeline) {
        if (!halvadeOpts.useBamInput) {
          ret=runPass1RNAJob(halvadeConf,halvadeOpts.out + ""String_Node_Str"");
          if (ret != 0) {
            Logger.DEBUG(""String_Node_Str"");
            System.exit(-1);
          }
          HalvadeConf.setIsPass2(halvadeConf,true);
        }
        ret=runHalvadeJob(halvadeConf,halvadeDir,HalvadeResourceManager.RNA_SHMEM_PASS2);
      }
 else {
        ret=runHalvadeJob(halvadeConf,halvadeDir,HalvadeResourceManager.DNA);
      }
      if (ret != 0) {
        Logger.DEBUG(""String_Node_Str"");
        System.exit(-2);
      }
    }
    if (!halvadeOpts.dryRun && !halvadeOpts.mergeBam) {
      if (halvadeOpts.combineVcf)       runCombineJob(halvadeDir,halvadeOpts.out + ""String_Node_Str"",false);
      if (halvadeOpts.gff != null)       runCombineJob(halvadeDir,halvadeOpts.out + ""String_Node_Str"",true);
    }
  }
 catch (  IOException|ClassNotFoundException|IllegalArgumentException|IllegalStateException|InterruptedException|URISyntaxException e) {
    Logger.EXCEPTION(e);
  }
  return ret;
}"
13714,"public void runCombineVariants(String[] inputs,String output,String ref) throws InterruptedException {
  ArrayList<String> command=new ArrayList<String>();
  String[] gatkcmd={java,mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",multiThreadingTypes[0],""String_Node_Str"" + threads,""String_Node_Str"",ref,""String_Node_Str"",output,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  command.addAll(Arrays.asList(gatkcmd));
  if (inputs != null) {
    for (    String input : inputs) {
      command.add(""String_Node_Str"");
      command.add(input);
    }
  }
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  Object[] objectList=command.toArray();
  long estimatedTime=runProcessAndWait(""String_Node_Str"",Arrays.copyOf(objectList,objectList.length,String[].class));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_COMBINE_VCF).increment(estimatedTime);
}","public void runCombineVariants(String[] inputs,String output,String ref) throws InterruptedException {
  ArrayList<String> command=new ArrayList<String>();
  command.addAll(java);
  String[] gatkcmd={mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",multiThreadingTypes[0],""String_Node_Str"" + threads,""String_Node_Str"",ref,""String_Node_Str"",output,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  command.addAll(Arrays.asList(gatkcmd));
  if (inputs != null) {
    for (    String input : inputs) {
      command.add(""String_Node_Str"");
      command.add(input);
    }
  }
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  Object[] objectList=command.toArray();
  long estimatedTime=runProcessAndWait(""String_Node_Str"",Arrays.copyOf(objectList,objectList.length,String[].class));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_COMBINE_VCF).increment(estimatedTime);
}"
13715,"public void runSplitNCigarReads(String input,String output,String ref,String region,int newMaxQualScore) throws InterruptedException {
  String[] command={java,mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",output,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + newMaxQualScore,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",region};
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  long estimatedTime=runProcessAndWait(""String_Node_Str"",AddCustomArguments(command,customArgs));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_INDEL_REALN).increment(estimatedTime);
}","public void runSplitNCigarReads(String input,String output,String ref,String region,int newMaxQualScore) throws InterruptedException {
  String[] command={mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",output,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + newMaxQualScore,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",region};
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  long estimatedTime=runProcessAndWait(""String_Node_Str"",AddCustomArguments(command,customArgs));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_INDEL_REALN).increment(estimatedTime);
}"
13716,"public void runVariantFiltration(String input,String output,String ref,String region,int window,int cluster,double minFS,double maxQD) throws InterruptedException {
  String[] command={java,mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",output,""String_Node_Str"",region,""String_Node_Str"",""String_Node_Str"" + window,""String_Node_Str"",""String_Node_Str"" + cluster,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + roundOneDecimal(minFS),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + roundOneDecimal(maxQD)};
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  long estimatedTime=runProcessAndWait(""String_Node_Str"",AddCustomArguments(command,customArgs));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_INDEL_REALN).increment(estimatedTime);
}","public void runVariantFiltration(String input,String output,String ref,String region,int window,int cluster,double minFS,double maxQD) throws InterruptedException {
  String[] command={mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",output,""String_Node_Str"",region,""String_Node_Str"",""String_Node_Str"" + window,""String_Node_Str"",""String_Node_Str"" + cluster,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + roundOneDecimal(minFS),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + roundOneDecimal(maxQD)};
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  long estimatedTime=runProcessAndWait(""String_Node_Str"",AddCustomArguments(command,customArgs));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_INDEL_REALN).increment(estimatedTime);
}"
13717,"public void runUnifiedGenotyper(String input,String output,double scc,double sec,String ref,String[] knownSites,String region) throws InterruptedException {
  ArrayList<String> command=new ArrayList<String>();
  String[] gatkcmd={java,mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",multiThreadingTypes[threadingType],""String_Node_Str"" + threads,""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",output,""String_Node_Str"",roundOneDecimal(scc),""String_Node_Str"",roundOneDecimal(sec),""String_Node_Str"",region,NO_CMD_HEADER,DISABLE_VCF_LOCKING};
  command.addAll(Arrays.asList(gatkcmd));
  if (knownSites != null) {
    for (    String knownSite : knownSites) {
      command.add(""String_Node_Str"");
      command.add(knownSite);
    }
  }
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  Object[] objectList=command.toArray();
  long estimatedTime=runProcessAndWait(""String_Node_Str"",Arrays.copyOf(objectList,objectList.length,String[].class));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_VARIANT_CALLER).increment(estimatedTime);
}","public void runUnifiedGenotyper(String input,String output,double scc,double sec,String ref,String[] knownSites,String region) throws InterruptedException {
  ArrayList<String> command=new ArrayList<String>();
  command.addAll(java);
  String[] gatkcmd={mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",multiThreadingTypes[threadingType],""String_Node_Str"" + threads,""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",output,""String_Node_Str"",roundOneDecimal(scc),""String_Node_Str"",roundOneDecimal(sec),""String_Node_Str"",region,NO_CMD_HEADER,DISABLE_VCF_LOCKING};
  command.addAll(Arrays.asList(gatkcmd));
  if (knownSites != null) {
    for (    String knownSite : knownSites) {
      command.add(""String_Node_Str"");
      command.add(knownSite);
    }
  }
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  Object[] objectList=command.toArray();
  long estimatedTime=runProcessAndWait(""String_Node_Str"",Arrays.copyOf(objectList,objectList.length,String[].class));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_VARIANT_CALLER).increment(estimatedTime);
}"
13718,"public GATKTools(String reference,String bin){
  this.reference=reference;
  this.bin=bin;
  this.java=""String_Node_Str"";
  this.gatk=bin + ""String_Node_Str"";
  onedec=new DecimalFormat(""String_Node_Str"");
}","public GATKTools(String reference,String bin){
  this.reference=reference;
  this.bin=bin;
  java=new ArrayList<>();
  java.add(""String_Node_Str"");
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  java.add(customArgs);
  this.gatk=bin + ""String_Node_Str"";
  onedec=new DecimalFormat(""String_Node_Str"");
}"
13719,"public void setJava(String java){
  this.java=java;
}","public void setJava(String java){
  this.java.set(0,java);
}"
13720,"public void runVariantAnnotator(String input,String output,String ref,String region) throws InterruptedException {
  String[] command={java,mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",multiThreadingTypes[0],""String_Node_Str"" + threads,""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",output,""String_Node_Str"",region};
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  long estimatedTime=runProcessAndWait(""String_Node_Str"",AddCustomArguments(command,customArgs));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_INDEL_REALN).increment(estimatedTime);
}","public void runVariantAnnotator(String input,String output,String ref,String region) throws InterruptedException {
  String[] command={mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",multiThreadingTypes[0],""String_Node_Str"" + threads,""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",output,""String_Node_Str"",region};
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  long estimatedTime=runProcessAndWait(""String_Node_Str"",AddCustomArguments(command,customArgs));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_INDEL_REALN).increment(estimatedTime);
}"
13721,"public void runPrintReads(String input,String output,String ref,String table,String region) throws InterruptedException {
  String[] command={java,mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",output,""String_Node_Str"",table,""String_Node_Str"",region};
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  long estimatedTime=runProcessAndWait(""String_Node_Str"",AddCustomArguments(command,customArgs));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_PRINT_READS).increment(estimatedTime);
}","public void runPrintReads(String input,String output,String ref,String table,String region) throws InterruptedException {
  String[] command={mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",output,""String_Node_Str"",table,""String_Node_Str"",region};
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  long estimatedTime=runProcessAndWait(""String_Node_Str"",AddCustomArguments(command,customArgs));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_PRINT_READS).increment(estimatedTime);
}"
13722,"private static String[] AddCustomArguments(String[] command,String customArgs){
  if (customArgs == null || customArgs.isEmpty())   return command;
  ArrayList<String> tmp=new ArrayList(Arrays.asList(command));
  tmp=CommandGenerator.addToCommand(tmp,customArgs);
  Object[] ObjectList=tmp.toArray();
  return Arrays.copyOf(ObjectList,ObjectList.length,String[].class);
}","private String[] AddCustomArguments(String[] args,String customArgs){
  ArrayList<String> command=new ArrayList<>();
  command.addAll(java);
  Collections.addAll(command,args);
  command=CommandGenerator.addToCommand(command,customArgs);
  Object[] ObjectList=command.toArray();
  return Arrays.copyOf(ObjectList,ObjectList.length,String[].class);
}"
13723,"public String getJava(){
  return java;
}","public String getJava(){
  return java.get(0);
}"
13724,"public void runIndelRealigner(String input,String targets,String output,String ref,String region) throws InterruptedException {
  String[] command={java,mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",targets,""String_Node_Str"",output,""String_Node_Str"",region};
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  long estimatedTime=runProcessAndWait(""String_Node_Str"",AddCustomArguments(command,customArgs));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_INDEL_REALN).increment(estimatedTime);
}","public void runIndelRealigner(String input,String targets,String output,String ref,String region) throws InterruptedException {
  String[] command={mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",targets,""String_Node_Str"",output,""String_Node_Str"",region};
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  long estimatedTime=runProcessAndWait(""String_Node_Str"",AddCustomArguments(command,customArgs));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_INDEL_REALN).increment(estimatedTime);
}"
13725,"public void runRealignerTargetCreator(String input,String targets,String ref,String region) throws InterruptedException {
  String[] command={java,mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",multiThreadingTypes[0],""String_Node_Str"" + threads,""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",targets,""String_Node_Str"",region};
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  long estimatedTime=runProcessAndWait(""String_Node_Str"",AddCustomArguments(command,customArgs));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_TARGET_CREATOR).increment(estimatedTime);
}","public void runRealignerTargetCreator(String input,String targets,String ref,String region) throws InterruptedException {
  String[] command={mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",multiThreadingTypes[0],""String_Node_Str"" + threads,""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",targets,""String_Node_Str"",region};
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  long estimatedTime=runProcessAndWait(""String_Node_Str"",AddCustomArguments(command,customArgs));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_TARGET_CREATOR).increment(estimatedTime);
}"
13726,"public void runBaseRecalibrator(String input,String table,String ref,String[] knownSites,String region) throws InterruptedException {
  ArrayList<String> command=new ArrayList<>();
  String[] gatkcmd={java,mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",multiThreadingTypes[1],""String_Node_Str"" + threads,""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",table,""String_Node_Str"",region,DISABLE_VCF_LOCKING};
  command.addAll(Arrays.asList(gatkcmd));
  for (  String knownSite : knownSites) {
    command.add(""String_Node_Str"");
    command.add(knownSite);
  }
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  Object[] objectList=command.toArray();
  long estimatedTime=runProcessAndWait(""String_Node_Str"",Arrays.copyOf(objectList,objectList.length,String[].class));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_RECAL).increment(estimatedTime);
}","public void runBaseRecalibrator(String input,String table,String ref,String[] knownSites,String region) throws InterruptedException {
  ArrayList<String> command=new ArrayList<>();
  command.addAll(java);
  String[] gatkcmd={mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",multiThreadingTypes[1],""String_Node_Str"" + threads,""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",table,""String_Node_Str"",region,DISABLE_VCF_LOCKING};
  command.addAll(Arrays.asList(gatkcmd));
  for (  String knownSite : knownSites) {
    command.add(""String_Node_Str"");
    command.add(knownSite);
  }
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  Object[] objectList=command.toArray();
  long estimatedTime=runProcessAndWait(""String_Node_Str"",Arrays.copyOf(objectList,objectList.length,String[].class));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_RECAL).increment(estimatedTime);
}"
13727,"public void runHaplotypeCaller(String input,String output,boolean disableSoftClipping,double scc,double sec,String ref,String[] knownSites,String region) throws InterruptedException {
  ArrayList<String> command=new ArrayList<String>();
  String[] gatkcmd={java,mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",multiThreadingTypes[1],""String_Node_Str"" + threads,""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",output,""String_Node_Str"",roundOneDecimal(scc),""String_Node_Str"",roundOneDecimal(sec),""String_Node_Str"",region,NO_CMD_HEADER,DISABLE_VCF_LOCKING};
  command.addAll(Arrays.asList(gatkcmd));
  if (disableSoftClipping) {
    command.add(""String_Node_Str"");
  }
  if (knownSites != null) {
    for (    String knownSite : knownSites) {
      command.add(""String_Node_Str"");
      command.add(knownSite);
    }
  }
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  Object[] objectList=command.toArray();
  long estimatedTime=runProcessAndWait(""String_Node_Str"",Arrays.copyOf(objectList,objectList.length,String[].class));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_VARIANT_CALLER).increment(estimatedTime);
}","public void runHaplotypeCaller(String input,String output,boolean disableSoftClipping,double scc,double sec,String ref,String[] knownSites,String region) throws InterruptedException {
  ArrayList<String> command=new ArrayList<String>();
  command.addAll(java);
  String[] gatkcmd={mem,""String_Node_Str"",gatk,""String_Node_Str"",""String_Node_Str"",multiThreadingTypes[1],""String_Node_Str"" + threads,""String_Node_Str"",ref,""String_Node_Str"",input,""String_Node_Str"",output,""String_Node_Str"",roundOneDecimal(scc),""String_Node_Str"",roundOneDecimal(sec),""String_Node_Str"",region,NO_CMD_HEADER,DISABLE_VCF_LOCKING};
  command.addAll(Arrays.asList(gatkcmd));
  if (disableSoftClipping) {
    command.add(""String_Node_Str"");
  }
  if (knownSites != null) {
    for (    String knownSite : knownSites) {
      command.add(""String_Node_Str"");
      command.add(knownSite);
    }
  }
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  Object[] objectList=command.toArray();
  long estimatedTime=runProcessAndWait(""String_Node_Str"",Arrays.copyOf(objectList,objectList.length,String[].class));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_GATK_VARIANT_CALLER).increment(estimatedTime);
}"
13728,"public int runCleanSam(String input,String output) throws InterruptedException {
  String tool;
  if (bin.endsWith(""String_Node_Str""))   tool=bin + PicardTools[3];
 else   tool=bin + ""String_Node_Str"" + PicardTools[3];
  ArrayList<String> command=new ArrayList<>();
  command.add(java);
  command.add(mem);
  command.add(""String_Node_Str"");
  command.add(tool);
  command.add(""String_Node_Str"" + input);
  command.add(""String_Node_Str"" + output);
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  long estimatedTime=runProcessAndWait(""String_Node_Str"",GetStringVector(command));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_PICARD_CLEANSAM).increment(estimatedTime);
  return 0;
}","public int runCleanSam(String input,String output) throws InterruptedException {
  String tool;
  if (bin.endsWith(""String_Node_Str""))   tool=bin + PicardTools[3];
 else   tool=bin + ""String_Node_Str"" + PicardTools[3];
  ArrayList<String> command=new ArrayList<>();
  command.addAll(java);
  command.add(mem);
  command.add(""String_Node_Str"");
  command.add(tool);
  command.add(""String_Node_Str"" + input);
  command.add(""String_Node_Str"" + output);
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  long estimatedTime=runProcessAndWait(""String_Node_Str"",GetStringVector(command));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_PICARD_CLEANSAM).increment(estimatedTime);
  return 0;
}"
13729,"public int runAddOrReplaceReadGroups(String input,String output,String RGID,String RGLB,String RGPL,String RGPU,String RGSM) throws InterruptedException {
  String tool;
  if (bin.endsWith(""String_Node_Str""))   tool=bin + PicardTools[1];
 else   tool=bin + ""String_Node_Str"" + PicardTools[1];
  ArrayList<String> command=new ArrayList<>();
  command.add(java);
  command.add(mem);
  command.add(""String_Node_Str"");
  command.add(tool);
  command.add(""String_Node_Str"" + input);
  command.add(""String_Node_Str"" + output);
  command.add(""String_Node_Str"" + RGID);
  command.add(""String_Node_Str"" + RGLB);
  command.add(""String_Node_Str"" + RGPL);
  command.add(""String_Node_Str"" + RGPU);
  command.add(""String_Node_Str"" + RGSM);
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  long estimatedTime=runProcessAndWait(""String_Node_Str"",GetStringVector(command));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_PICARD_ADDGRP).increment(estimatedTime);
  return 0;
}","public int runAddOrReplaceReadGroups(String input,String output,String RGID,String RGLB,String RGPL,String RGPU,String RGSM) throws InterruptedException {
  String tool;
  if (bin.endsWith(""String_Node_Str""))   tool=bin + PicardTools[1];
 else   tool=bin + ""String_Node_Str"" + PicardTools[1];
  ArrayList<String> command=new ArrayList<>();
  command.addAll(java);
  command.add(mem);
  command.add(""String_Node_Str"");
  command.add(tool);
  command.add(""String_Node_Str"" + input);
  command.add(""String_Node_Str"" + output);
  command.add(""String_Node_Str"" + RGID);
  command.add(""String_Node_Str"" + RGLB);
  command.add(""String_Node_Str"" + RGPL);
  command.add(""String_Node_Str"" + RGPU);
  command.add(""String_Node_Str"" + RGSM);
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  long estimatedTime=runProcessAndWait(""String_Node_Str"",GetStringVector(command));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_PICARD_ADDGRP).increment(estimatedTime);
  return 0;
}"
13730,"public PreprocessingTools(String bin){
  this.bin=bin;
  this.java=""String_Node_Str"";
}","public PreprocessingTools(String bin){
  this.bin=bin;
  java=new ArrayList<>();
  java.add(""String_Node_Str"");
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  java.add(customArgs);
}"
13731,"public void setJava(String java){
  this.java=java;
}","public void setJava(String java){
  this.java.set(0,java);
}"
13732,"public int runBuildBamIndex(String input) throws InterruptedException {
  String tool;
  if (bin.endsWith(""String_Node_Str""))   tool=bin + PicardTools[0];
 else   tool=bin + ""String_Node_Str"" + PicardTools[0];
  ArrayList<String> command=new ArrayList<>();
  command.add(java);
  command.add(mem);
  command.add(""String_Node_Str"");
  command.add(tool);
  command.add(""String_Node_Str"" + input);
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  long estimatedTime=runProcessAndWait(""String_Node_Str"",GetStringVector(command));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_PICARD_BAI).increment(estimatedTime);
  return 0;
}","public int runBuildBamIndex(String input) throws InterruptedException {
  String tool;
  if (bin.endsWith(""String_Node_Str""))   tool=bin + PicardTools[0];
 else   tool=bin + ""String_Node_Str"" + PicardTools[0];
  ArrayList<String> command=new ArrayList<>();
  command.addAll(java);
  command.add(mem);
  command.add(""String_Node_Str"");
  command.add(tool);
  command.add(""String_Node_Str"" + input);
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  long estimatedTime=runProcessAndWait(""String_Node_Str"",GetStringVector(command));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_PICARD_BAI).increment(estimatedTime);
  return 0;
}"
13733,"public int runSortVcf(String input,String output) throws InterruptedException {
  String tool;
  if (bin.endsWith(""String_Node_Str""))   tool=bin + PicardTools[4];
 else   tool=bin + ""String_Node_Str"" + PicardTools[4];
  ArrayList<String> command=new ArrayList<>();
  command.add(java);
  command.add(mem);
  command.add(""String_Node_Str"");
  command.add(tool);
  command.add(""String_Node_Str"");
  command.add(""String_Node_Str"" + input);
  command.add(""String_Node_Str"" + output);
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  runProcessAndWait(""String_Node_Str"",GetStringVector(command));
  HalvadeFileUtils.removeLocalFile(output + ""String_Node_Str"");
  return 0;
}","public int runSortVcf(String input,String output) throws InterruptedException {
  String tool;
  if (bin.endsWith(""String_Node_Str""))   tool=bin + PicardTools[4];
 else   tool=bin + ""String_Node_Str"" + PicardTools[4];
  ArrayList<String> command=new ArrayList<>();
  command.addAll(java);
  command.add(mem);
  command.add(""String_Node_Str"");
  command.add(tool);
  command.add(""String_Node_Str"");
  command.add(""String_Node_Str"" + input);
  command.add(""String_Node_Str"" + output);
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  runProcessAndWait(""String_Node_Str"",GetStringVector(command));
  HalvadeFileUtils.removeLocalFile(output + ""String_Node_Str"");
  return 0;
}"
13734,"public String getJava(){
  return java;
}","public String getJava(){
  return java.get(0);
}"
13735,"public int runMarkDuplicates(String input,String output,String metrics) throws InterruptedException {
  String tool;
  if (bin.endsWith(""String_Node_Str""))   tool=bin + PicardTools[2];
 else   tool=bin + ""String_Node_Str"" + PicardTools[2];
  ArrayList<String> command=new ArrayList<>();
  command.add(java);
  command.add(mem);
  command.add(""String_Node_Str"");
  command.add(tool);
  command.add(""String_Node_Str"" + input);
  command.add(""String_Node_Str"" + output);
  command.add(""String_Node_Str"" + metrics);
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  long estimatedTime=runProcessAndWait(""String_Node_Str"",GetStringVector(command));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_PICARD_MARKDUP).increment(estimatedTime);
  return 0;
}","public int runMarkDuplicates(String input,String output,String metrics) throws InterruptedException {
  String tool;
  if (bin.endsWith(""String_Node_Str""))   tool=bin + PicardTools[2];
 else   tool=bin + ""String_Node_Str"" + PicardTools[2];
  ArrayList<String> command=new ArrayList<>();
  command.addAll(java);
  command.add(mem);
  command.add(""String_Node_Str"");
  command.add(tool);
  command.add(""String_Node_Str"" + input);
  command.add(""String_Node_Str"" + output);
  command.add(""String_Node_Str"" + metrics);
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  command=CommandGenerator.addToCommand(command,customArgs);
  long estimatedTime=runProcessAndWait(""String_Node_Str"",GetStringVector(command));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_PICARD_MARKDUP).increment(estimatedTime);
  return 0;
}"
13736,"@Override protected void map(LongWritable key,Text value,Mapper.Context context) throws IOException, InterruptedException {
  String[] split=value.toString().split(""String_Node_Str"");
  k.set(split[0]);
  v.set(Integer.parseInt(split[1]));
  context.write(k,v);
}","@Override protected void map(LongWritable key,Text value,Mapper.Context context) throws IOException, InterruptedException {
  String[] split=value.toString().split(""String_Node_Str"");
  k.set(split[0]);
  v.set(Integer.parseInt(split[split.length - 1]));
  context.write(k,v);
}"
13737,"public static String[] featureCounts(String bin,String gffFile,String bamFile,String outFile,int numberOfThreads,String customArgs){
  ArrayList<String> command=new ArrayList<>();
  if (bin.endsWith(""String_Node_Str""))   command.add(bin + featureCountsCommand);
 else   command.add(bin + ""String_Node_Str"" + featureCountsCommand);
  command=addToCommand(command,customArgs);
  command.add(featureCountsOptions[0]);
  command.add(new Integer(numberOfThreads).toString());
  command.add(featureCountsOptions[3]);
  command.add(""String_Node_Str"");
  command.add(featureCountsOptions[4]);
  command.add(""String_Node_Str"");
  command.add(featureCountsOptions[5]);
  command.add(featureCountsOptions[6]);
  command.add(featureCountsOptions[7]);
  command.add(featureCountsOptions[8]);
  command.add(featureCountsOptions[1]);
  command.add(gffFile);
  command.add(featureCountsOptions[2]);
  command.add(outFile);
  command.add(bamFile);
  Object[] ObjectList=command.toArray();
  String[] StringArray=Arrays.copyOf(ObjectList,ObjectList.length,String[].class);
  return StringArray;
}","public static String[] featureCounts(String bin,String gffFile,String bamFile,String outFile,int numberOfThreads,String customArgs){
  ArrayList<String> command=new ArrayList<>();
  if (bin.endsWith(""String_Node_Str""))   command.add(bin + featureCountsCommand);
 else   command.add(bin + ""String_Node_Str"" + featureCountsCommand);
  command=addToCommand(command,customArgs);
  command.add(featureCountsOptions[0]);
  command.add(new Integer(numberOfThreads).toString());
  int strandedness=0;
  command.add(featureCountsOptions[3]);
  command.add(strandedness + ""String_Node_Str"");
  command.add(featureCountsOptions[4]);
  command.add(""String_Node_Str"");
  command.add(featureCountsOptions[5]);
  command.add(featureCountsOptions[1]);
  command.add(gffFile);
  command.add(featureCountsOptions[2]);
  command.add(outFile);
  command.add(bamFile);
  Object[] ObjectList=command.toArray();
  String[] StringArray=Arrays.copyOf(ObjectList,ObjectList.length,String[].class);
  return StringArray;
}"
13738,"public static String downloadGFF(TaskInputOutputContext context,String id) throws IOException, URISyntaxException {
  Configuration conf=context.getConfiguration();
  String refDir=HalvadeConf.getRefDirOnScratch(conf);
  String gff=HalvadeConf.getGff(context.getConfiguration());
  if (gff == null)   return null;
  if (!refDir.endsWith(""String_Node_Str""))   refDir=refDir + ""String_Node_Str"";
  HalvadeFileLock lock=new HalvadeFileLock(context,refDir,GFF_LOCK);
  String gffFile=null;
  String gffSuffix=null;
  try {
    lock.getLock();
    ByteBuffer bytes=ByteBuffer.allocate(4);
    if (lock.read(bytes) > 0) {
      bytes.flip();
      long val=bytes.getInt();
      if (val == DEFAULT_LOCK_VAL)       Logger.DEBUG(""String_Node_Str"" + val);
 else {
        Logger.INFO(""String_Node_Str"");
        FileSystem fs=FileSystem.get(new URI(gff),conf);
        int si=gff.lastIndexOf('.');
        if (si > 0)         gffSuffix=gff.substring(si);
 else         throw new InterruptedException(""String_Node_Str"" + gff);
        gffFile=findFile(refDir,gffSuffix,false);
        if (gffFile == null)         gffFile=refDir + id;
        attemptDownloadFileFromHDFS(context,fs,gff,gffFile + gffSuffix,RETRIES);
        Logger.INFO(""String_Node_Str"");
        bytes.clear();
        bytes.putInt(DEFAULT_LOCK_VAL).flip();
        lock.forceWrite(bytes);
      }
    }
 else {
      Logger.INFO(""String_Node_Str"");
      Logger.DEBUG(""String_Node_Str"" + gff);
      FileSystem fs=FileSystem.get(new URI(gff),conf);
      int si=gff.lastIndexOf('.');
      if (si > 0)       gffSuffix=gff.substring(si);
 else       throw new InterruptedException(""String_Node_Str"" + gff);
      gffFile=findFile(refDir,gffSuffix,false);
      if (gffFile == null)       gffFile=refDir + id;
      attemptDownloadFileFromHDFS(context,fs,gff,gffFile + gffSuffix,RETRIES);
      Logger.INFO(""String_Node_Str"");
      bytes.clear();
      bytes.putInt(DEFAULT_LOCK_VAL).flip();
      lock.forceWrite(bytes);
    }
  }
 catch (  InterruptedException ex) {
    Logger.EXCEPTION(ex);
  }
 finally {
    lock.releaseLock();
  }
  if (gffFile == null)   gffFile=findFile(refDir,""String_Node_Str"",false);
  return gffFile + ""String_Node_Str"";
}","public static String downloadGFF(TaskInputOutputContext context,String id) throws IOException, URISyntaxException, InterruptedException {
  Configuration conf=context.getConfiguration();
  String refDir=HalvadeConf.getRefDirOnScratch(conf);
  String gff=HalvadeConf.getGff(context.getConfiguration());
  if (gff == null)   return null;
  String gffSuffix=null;
  int si=gff.lastIndexOf('.');
  if (si > 0)   gffSuffix=gff.substring(si);
 else   throw new InterruptedException(""String_Node_Str"" + gff);
  Logger.DEBUG(""String_Node_Str"" + gffSuffix);
  if (!refDir.endsWith(""String_Node_Str""))   refDir=refDir + ""String_Node_Str"";
  HalvadeFileLock lock=new HalvadeFileLock(context,refDir,GFF_LOCK);
  String gffFile=null;
  try {
    lock.getLock();
    ByteBuffer bytes=ByteBuffer.allocate(4);
    if (lock.read(bytes) > 0) {
      bytes.flip();
      long val=bytes.getInt();
      if (val == DEFAULT_LOCK_VAL)       Logger.DEBUG(""String_Node_Str"" + val);
 else {
        Logger.INFO(""String_Node_Str"");
        FileSystem fs=FileSystem.get(new URI(gff),conf);
        gffFile=findFile(refDir,gffSuffix,false);
        if (gffFile == null)         gffFile=refDir + id;
        attemptDownloadFileFromHDFS(context,fs,gff,gffFile + gffSuffix,RETRIES);
        Logger.INFO(""String_Node_Str"");
        bytes.clear();
        bytes.putInt(DEFAULT_LOCK_VAL).flip();
        lock.forceWrite(bytes);
      }
    }
 else {
      Logger.INFO(""String_Node_Str"");
      Logger.DEBUG(""String_Node_Str"" + gff);
      FileSystem fs=FileSystem.get(new URI(gff),conf);
      gffFile=findFile(refDir,gffSuffix,false);
      if (gffFile == null)       gffFile=refDir + id;
      attemptDownloadFileFromHDFS(context,fs,gff,gffFile + gffSuffix,RETRIES);
      Logger.INFO(""String_Node_Str"");
      bytes.clear();
      bytes.putInt(DEFAULT_LOCK_VAL).flip();
      lock.forceWrite(bytes);
    }
  }
 catch (  InterruptedException ex) {
    Logger.EXCEPTION(ex);
  }
 finally {
    lock.releaseLock();
  }
  if (gffFile == null)   gffFile=findFile(refDir,gffSuffix,false);
  return gffFile + gffSuffix;
}"
13739,"protected static int attemptDownloadFileFromHDFS(TaskInputOutputContext context,FileSystem fs,String from,String to,int tries) throws IOException {
  int val=privateDownloadFileFromHDFS(context,fs,from,to);
  int try_=1;
  while (val != 0 && try_ < tries) {
    val=privateDownloadFileFromHDFS(context,fs,from,to);
    try_++;
  }
  if (val == 0)   Logger.DEBUG(from + ""String_Node_Str"");
 else {
    Logger.DEBUG(from + ""String_Node_Str"");
    throw new IOException();
  }
  return val;
}","protected static int attemptDownloadFileFromHDFS(TaskInputOutputContext context,FileSystem fs,String from,String to,int tries) throws IOException {
  if (from.equalsIgnoreCase(to))   return 0;
  int val=privateDownloadFileFromHDFS(context,fs,from,to);
  int try_=1;
  while (val != 0 && try_ < tries) {
    val=privateDownloadFileFromHDFS(context,fs,from,to);
    try_++;
  }
  if (val == 0)   Logger.DEBUG(from + ""String_Node_Str"");
 else {
    Logger.DEBUG(from + ""String_Node_Str"");
    throw new IOException();
  }
  return val;
}"
13740,"protected boolean parseArguments(String[] args,Configuration halvadeConf) throws ParseException {
  createOptions();
  CommandLineParser parser=new GnuParser();
  CommandLine line=parser.parse(options,args);
  in=line.getOptionValue(""String_Node_Str"");
  out=line.getOptionValue(""String_Node_Str"");
  ref=line.getOptionValue(""String_Node_Str"");
  sites=line.getOptionValue(""String_Node_Str"");
  halvadeBinaries=line.getOptionValue(""String_Node_Str"");
  hdfsSites=sites.split(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str"")) {
    rnaPipeline=true;
    if (line.hasOption(""String_Node_Str""))     STARGenome=line.getOptionValue(""String_Node_Str"");
 else     throw new ParseException(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str""))   tmpDir=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   localRefDir=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   nodes=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   vcores=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   vcores*=2;
  if (line.hasOption(""String_Node_Str""))   useSharedMemory=true;
  if (line.hasOption(""String_Node_Str""))   mem=Double.parseDouble(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str"")) {
    setMapContainers=false;
    mapsPerContainer=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    setReduceContainers=false;
    reducersPerContainer=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str""))   stand_call_conf=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   stand_emit_conf=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   reportAll=true;
  if (line.hasOption(""String_Node_Str""))   keepFiles=true;
  if (line.hasOption(""String_Node_Str""))   paired=false;
  if (line.hasOption(""String_Node_Str"")) {
    justAlign=true;
    combineVcf=false;
  }
  if (line.hasOption(""String_Node_Str""))   reuseJVM=true;
  if (line.hasOption(""String_Node_Str""))   aln=false;
  if (line.hasOption(""String_Node_Str""))   java=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   exomeBedFile=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str"")) {
    dryRun=true;
    combineVcf=false;
  }
  if (line.hasOption(""String_Node_Str""))   keepChrSplitPairs=false;
  if (line.hasOption(""String_Node_Str""))   coverage=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str"")) {
    justCombine=true;
    combineVcf=true;
  }
  if (line.hasOption(""String_Node_Str""))   useBedTools=true;
  if (line.hasOption(""String_Node_Str""))   useGenotyper=false;
  if (line.hasOption(""String_Node_Str""))   useIPrep=false;
  if (line.hasOption(""String_Node_Str""))   RGID=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGLB=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGPL=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGPU=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGSM=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   chr=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str"")) {
    Properties props=line.getOptionProperties(""String_Node_Str"");
    Enumeration names=props.propertyNames();
    while (names.hasMoreElements()) {
      String name=(String)names.nextElement();
      addCustomArguments(halvadeConf,name,props.getProperty(name));
    }
  }
  return true;
}","protected boolean parseArguments(String[] args,Configuration halvadeConf) throws ParseException {
  createOptions();
  CommandLineParser parser=new GnuParser();
  CommandLine line=parser.parse(options,args);
  in=line.getOptionValue(""String_Node_Str"");
  out=line.getOptionValue(""String_Node_Str"");
  ref=line.getOptionValue(""String_Node_Str"");
  sites=line.getOptionValue(""String_Node_Str"");
  halvadeBinaries=line.getOptionValue(""String_Node_Str"");
  hdfsSites=sites.split(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str"")) {
    rnaPipeline=true;
    if (line.hasOption(""String_Node_Str""))     STARGenome=line.getOptionValue(""String_Node_Str"");
 else     throw new ParseException(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str""))   tmpDir=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   localRefDir=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   nodes=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   vcores=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   vcores*=2;
  if (line.hasOption(""String_Node_Str""))   useSharedMemory=true;
  if (line.hasOption(""String_Node_Str""))   mem=Double.parseDouble(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str"")) {
    setMapContainers=false;
    mapsPerContainer=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    setReduceContainers=false;
    reducersPerContainer=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str""))   stand_call_conf=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   stand_emit_conf=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   reportAll=true;
  if (line.hasOption(""String_Node_Str""))   keepFiles=true;
  if (line.hasOption(""String_Node_Str""))   paired=false;
  if (line.hasOption(""String_Node_Str"")) {
    justAlign=true;
    combineVcf=false;
  }
  if (line.hasOption(""String_Node_Str""))   reuseJVM=true;
  if (line.hasOption(""String_Node_Str""))   aln=false;
  if (line.hasOption(""String_Node_Str""))   java=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   exomeBedFile=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str"")) {
    dryRun=true;
    combineVcf=false;
  }
  if (line.hasOption(""String_Node_Str""))   keepChrSplitPairs=false;
  if (line.hasOption(""String_Node_Str""))   coverage=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str"")) {
    justCombine=true;
    combineVcf=true;
  }
  if (line.hasOption(""String_Node_Str""))   useBedTools=true;
  if (line.hasOption(""String_Node_Str""))   useGenotyper=false;
  if (line.hasOption(""String_Node_Str""))   useBamInput=true;
  if (line.hasOption(""String_Node_Str""))   useIPrep=false;
  if (line.hasOption(""String_Node_Str""))   RGID=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGLB=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGPL=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGPU=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGSM=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   chr=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str"")) {
    Properties props=line.getOptionProperties(""String_Node_Str"");
    Enumeration names=props.propertyNames();
    while (names.hasMoreElements()) {
      String name=(String)names.nextElement();
      addCustomArguments(halvadeConf,name,props.getProperty(name));
    }
  }
  return true;
}"
13741,"protected void createOptions(){
  Option optIn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optOut=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBin=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRef=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optNodes=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optVcores=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMem=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSites=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optStarGenome=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optTmp=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optrefdir=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJava=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optID=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optLB=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPL=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPU=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSM=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCov=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optScc=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSec=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optChr=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"" + ""String_Node_Str"").create(""String_Node_Str"");
  Option optEx=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMpn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRpn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCustomArgs=OptionBuilder.withLongOpt(""String_Node_Str"").withArgName(""String_Node_Str"").hasArgs(2).withValueSeparator().withDescription(""String_Node_Str"" + ""String_Node_Str"" + getProgramNames()).create(""String_Node_Str"");
  Option optSingle=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBmem=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCombine=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPp=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBed=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJVM=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJustAlign=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSmt=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optKeep=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optHap=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRna=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optDry=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optDrop=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optReportAll=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optShmem=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  options.addOption(optIn);
  options.addOption(optOut);
  options.addOption(optRef);
  options.addOption(optSites);
  options.addOption(optBin);
  options.addOption(optTmp);
  options.addOption(optrefdir);
  options.addOption(optSingle);
  options.addOption(optBmem);
  options.addOption(optID);
  options.addOption(optLB);
  options.addOption(optPL);
  options.addOption(optPU);
  options.addOption(optSM);
  options.addOption(optPp);
  options.addOption(optBed);
  options.addOption(optHap);
  options.addOption(optScc);
  options.addOption(optSec);
  options.addOption(optChr);
  options.addOption(optJVM);
  options.addOption(optJava);
  options.addOption(optCombine);
  options.addOption(optNodes);
  options.addOption(optVcores);
  options.addOption(optMem);
  options.addOption(optKeep);
  options.addOption(optJustAlign);
  options.addOption(optCov);
  options.addOption(optEx);
  options.addOption(optMpn);
  options.addOption(optRpn);
  options.addOption(optDry);
  options.addOption(optDrop);
  options.addOption(optReportAll);
  options.addOption(optSmt);
  options.addOption(optRna);
  options.addOption(optStarGenome);
  options.addOption(optShmem);
  options.addOption(optCustomArgs);
}","protected void createOptions(){
  Option optIn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optOut=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBin=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRef=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optNodes=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optVcores=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMem=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSites=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optStarGenome=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optTmp=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optrefdir=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJava=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optID=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optLB=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPL=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPU=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSM=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCov=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optScc=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSec=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optChr=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"" + ""String_Node_Str"").create(""String_Node_Str"");
  Option optEx=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMpn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRpn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCustomArgs=OptionBuilder.withLongOpt(""String_Node_Str"").withArgName(""String_Node_Str"").hasArgs(2).withValueSeparator().withDescription(""String_Node_Str"" + ""String_Node_Str"" + getProgramNames()).create(""String_Node_Str"");
  Option optSingle=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBmem=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCombine=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPp=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBed=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJVM=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJustAlign=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSmt=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optKeep=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optHap=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRna=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optDry=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optDrop=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optReportAll=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optShmem=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBamIn=OptionBuilder.withDescription(""String_Node_Str"").create(""String_Node_Str"");
  options.addOption(optIn);
  options.addOption(optOut);
  options.addOption(optRef);
  options.addOption(optSites);
  options.addOption(optBin);
  options.addOption(optTmp);
  options.addOption(optrefdir);
  options.addOption(optSingle);
  options.addOption(optBmem);
  options.addOption(optID);
  options.addOption(optLB);
  options.addOption(optPL);
  options.addOption(optPU);
  options.addOption(optSM);
  options.addOption(optPp);
  options.addOption(optBed);
  options.addOption(optHap);
  options.addOption(optScc);
  options.addOption(optSec);
  options.addOption(optChr);
  options.addOption(optJVM);
  options.addOption(optJava);
  options.addOption(optCombine);
  options.addOption(optNodes);
  options.addOption(optVcores);
  options.addOption(optMem);
  options.addOption(optKeep);
  options.addOption(optJustAlign);
  options.addOption(optCov);
  options.addOption(optEx);
  options.addOption(optMpn);
  options.addOption(optRpn);
  options.addOption(optDry);
  options.addOption(optDrop);
  options.addOption(optReportAll);
  options.addOption(optSmt);
  options.addOption(optRna);
  options.addOption(optStarGenome);
  options.addOption(optShmem);
  options.addOption(optBamIn);
  options.addOption(optCustomArgs);
}"
13742,"public static void setJobResources(HalvadeOptions opt,Configuration conf,int type,boolean subtractAM){
  int tmpmem=(int)(opt.mem * 1024);
  int tmpvcores=opt.vcores;
  if (subtractAM) {
    tmpmem-=MEM_AM;
    tmpvcores-=VCORES_AM;
  }
  if (opt.setMapContainers)   opt.mapsPerContainer=Math.min(tmpvcores,Math.max(tmpmem / RESOURCE_REQ[type][0],1));
  if (opt.setReduceContainers)   opt.reducersPerContainer=Math.min(tmpvcores,Math.max(tmpmem / RESOURCE_REQ[type][1],1));
  opt.maps=Math.max(1,opt.nodes * opt.mapsPerContainer);
  opt.mthreads=Math.max(1,tmpvcores / opt.mapsPerContainer);
  opt.rthreads=Math.max(1,tmpvcores / opt.reducersPerContainer);
  int mmem=RESOURCE_REQ[type][0];
  int rmem=RESOURCE_REQ[type][1] == ALL ? tmpmem : RESOURCE_REQ[type][1];
  Logger.DEBUG(""String_Node_Str"" + opt.mapsPerContainer + ""String_Node_Str""+ opt.mthreads+ ""String_Node_Str""+ mmem+ ""String_Node_Str""+ opt.reducersPerContainer+ ""String_Node_Str""+ opt.rthreads+ ""String_Node_Str""+ rmem+ ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + opt.mthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + opt.rthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + rmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + mmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.8 * rmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.8 * mmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"");
  HalvadeConf.setMapThreads(conf,opt.mthreads);
  HalvadeConf.setReducerThreads(conf,opt.rthreads);
}","public static void setJobResources(HalvadeOptions opt,Configuration conf,int type,boolean subtractAM){
  int tmpmem=(int)(opt.mem * 1024);
  int tmpvcores=opt.vcores;
  if (subtractAM) {
    tmpmem-=MEM_AM;
    tmpvcores-=VCORES_AM;
  }
  if (opt.setMapContainers)   opt.mapsPerContainer=Math.min(tmpvcores / 2,Math.max(tmpmem / RESOURCE_REQ[type][0],1));
  if (opt.setReduceContainers)   opt.reducersPerContainer=Math.min(tmpvcores,Math.max(tmpmem / RESOURCE_REQ[type][1],1));
  opt.maps=Math.max(1,opt.nodes * opt.mapsPerContainer);
  opt.mthreads=Math.max(1,tmpvcores / opt.mapsPerContainer);
  opt.rthreads=Math.max(1,tmpvcores / opt.reducersPerContainer);
  int mmem=RESOURCE_REQ[type][0];
  int rmem=RESOURCE_REQ[type][1] == ALL ? tmpmem : RESOURCE_REQ[type][1];
  Logger.DEBUG(""String_Node_Str"" + opt.mapsPerContainer + ""String_Node_Str""+ opt.mthreads+ ""String_Node_Str""+ mmem+ ""String_Node_Str""+ opt.reducersPerContainer+ ""String_Node_Str""+ opt.rthreads+ ""String_Node_Str""+ rmem+ ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + opt.mthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + opt.rthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + rmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + mmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.8 * rmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.8 * mmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"");
  HalvadeConf.setMapThreads(conf,opt.mthreads);
  HalvadeConf.setReducerThreads(conf,opt.rthreads);
}"
13743,"protected int runHalvadeJob(Configuration halvadeConf,String tmpOutDir,int jobType) throws IOException, URISyntaxException, InterruptedException, ClassNotFoundException {
  String pipeline=""String_Node_Str"";
  if (jobType == HalvadeResourceManager.RNA_SHMEM_PASS2) {
    HalvadeConf.setIsPass2(halvadeConf,true);
    HalvadeResourceManager.setJobResources(halvadeOpts,halvadeConf,jobType,false);
    pipeline=RNA_PASS2;
  }
 else   if (jobType == HalvadeResourceManager.RNA) {
    HalvadeResourceManager.setJobResources(halvadeOpts,halvadeConf,jobType,false);
    pipeline=RNA;
  }
 else   if (jobType == HalvadeResourceManager.DNA) {
    HalvadeResourceManager.setJobResources(halvadeOpts,halvadeConf,jobType,false);
    pipeline=DNA;
  }
  HalvadeConf.setOutDir(halvadeConf,tmpOutDir);
  FileSystem outFs=FileSystem.get(new URI(tmpOutDir),halvadeConf);
  if (outFs.exists(new Path(tmpOutDir))) {
    Logger.INFO(""String_Node_Str"" + tmpOutDir + ""String_Node_Str"");
    Logger.INFO(""String_Node_Str"");
    System.exit(-2);
  }
  Job halvadeJob=Job.getInstance(halvadeConf,""String_Node_Str"" + pipeline);
  halvadeJob.addCacheArchive(new URI(halvadeOpts.halvadeBinaries));
  halvadeJob.setJarByClass(be.ugent.intec.halvade.hadoop.mapreduce.HalvadeMapper.class);
  addInputFiles(halvadeOpts.in,halvadeConf,halvadeJob);
  FileOutputFormat.setOutputPath(halvadeJob,new Path(tmpOutDir));
  if (jobType == HalvadeResourceManager.RNA_SHMEM_PASS2) {
    halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.StarAlignPassXMapper.class);
    halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.RnaGATKReducer.class);
  }
 else   if (jobType == HalvadeResourceManager.RNA) {
    halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.StarAlignMapper.class);
    halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.RnaGATKReducer.class);
  }
 else   if (jobType == HalvadeResourceManager.DNA) {
    if (halvadeOpts.aln)     halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.BWAAlnMapper.class);
 else     halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.BWAMemMapper.class);
    halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.DnaGATKReducer.class);
  }
  if (halvadeOpts.justAlign)   halvadeJob.setNumReduceTasks(0);
 else   halvadeJob.setNumReduceTasks(halvadeOpts.reduces);
  halvadeJob.setMapOutputKeyClass(ChromosomeRegion.class);
  halvadeJob.setMapOutputValueClass(SAMRecordWritable.class);
  halvadeJob.setInputFormatClass(HalvadeTextInputFormat.class);
  halvadeJob.setPartitionerClass(ChrRgPartitioner.class);
  halvadeJob.setSortComparatorClass(ChrRgSortComparator.class);
  halvadeJob.setGroupingComparatorClass(ChrRgGroupingComparator.class);
  halvadeJob.setOutputKeyClass(Text.class);
  halvadeJob.setOutputValueClass(VariantContextWritable.class);
  return runTimedJob(halvadeJob,""String_Node_Str"");
}","protected int runHalvadeJob(Configuration halvadeConf,String tmpOutDir,int jobType) throws IOException, URISyntaxException, InterruptedException, ClassNotFoundException {
  String pipeline=""String_Node_Str"";
  if (jobType == HalvadeResourceManager.RNA_SHMEM_PASS2) {
    HalvadeConf.setIsPass2(halvadeConf,true);
    HalvadeResourceManager.setJobResources(halvadeOpts,halvadeConf,jobType,false);
    pipeline=RNA_PASS2;
  }
 else   if (jobType == HalvadeResourceManager.RNA) {
    HalvadeResourceManager.setJobResources(halvadeOpts,halvadeConf,jobType,false);
    pipeline=RNA;
  }
 else   if (jobType == HalvadeResourceManager.DNA) {
    HalvadeResourceManager.setJobResources(halvadeOpts,halvadeConf,jobType,false);
    pipeline=DNA;
  }
  HalvadeConf.setOutDir(halvadeConf,tmpOutDir);
  FileSystem outFs=FileSystem.get(new URI(tmpOutDir),halvadeConf);
  if (outFs.exists(new Path(tmpOutDir))) {
    Logger.INFO(""String_Node_Str"" + tmpOutDir + ""String_Node_Str"");
    Logger.INFO(""String_Node_Str"");
    System.exit(-2);
  }
  Job halvadeJob=Job.getInstance(halvadeConf,""String_Node_Str"" + pipeline);
  halvadeJob.addCacheArchive(new URI(halvadeOpts.halvadeBinaries));
  halvadeJob.setJarByClass(be.ugent.intec.halvade.hadoop.mapreduce.HalvadeMapper.class);
  addInputFiles(halvadeOpts.in,halvadeConf,halvadeJob);
  FileOutputFormat.setOutputPath(halvadeJob,new Path(tmpOutDir));
  if (jobType == HalvadeResourceManager.RNA_SHMEM_PASS2) {
    halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.StarAlignPassXMapper.class);
    halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.RnaGATKReducer.class);
  }
 else   if (jobType == HalvadeResourceManager.RNA) {
    halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.StarAlignMapper.class);
    halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.RnaGATKReducer.class);
  }
 else   if (jobType == HalvadeResourceManager.DNA) {
    if (halvadeOpts.aln)     halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.BWAAlnMapper.class);
 else     halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.BWAMemMapper.class);
    halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.DnaGATKReducer.class);
  }
  if (halvadeOpts.justAlign)   halvadeJob.setNumReduceTasks(0);
 else   halvadeJob.setNumReduceTasks(halvadeOpts.reduces);
  halvadeJob.setMapOutputKeyClass(ChromosomeRegion.class);
  halvadeJob.setMapOutputValueClass(SAMRecordWritable.class);
  halvadeJob.setInputFormatClass(HalvadeTextInputFormat.class);
  halvadeJob.setPartitionerClass(ChrRgPartitioner.class);
  halvadeJob.setSortComparatorClass(ChrRgSortComparator.class);
  halvadeJob.setGroupingComparatorClass(ChrRgGroupingComparator.class);
  halvadeJob.setOutputKeyClass(Text.class);
  halvadeJob.setOutputValueClass(VariantContextWritable.class);
  if (halvadeOpts.useBamInput) {
    halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.AlignedBamMapper.class);
    halvadeJob.setInputFormatClass(BAMInputFormat.class);
  }
  return runTimedJob(halvadeJob,""String_Node_Str"");
}"
13744,"@Override public int run(String[] strings) throws Exception {
  int ret=0;
  try {
    Configuration halvadeConf=getConf();
    halvadeOpts=new HalvadeOptions();
    int optReturn=halvadeOpts.GetOptions(strings,halvadeConf);
    if (optReturn != 0)     return optReturn;
    String halvadeDir=halvadeOpts.out + ""String_Node_Str"";
    if (!halvadeOpts.justCombine) {
      if (halvadeOpts.rnaPipeline) {
        if (halvadeOpts.useSharedMemory) {
          ret=runPass1RNAJob(halvadeConf,halvadeOpts.out + ""String_Node_Str"");
          if (ret != 0) {
            Logger.DEBUG(""String_Node_Str"");
            System.exit(-1);
          }
          HalvadeConf.setIsPass2(halvadeConf,true);
          ret=runHalvadeJob(halvadeConf,halvadeDir,HalvadeResourceManager.RNA_SHMEM_PASS2);
        }
 else {
          ret=runHalvadeJob(halvadeConf,halvadeDir,HalvadeResourceManager.RNA);
        }
      }
 else {
        ret=runHalvadeJob(halvadeConf,halvadeDir,HalvadeResourceManager.DNA);
      }
      if (ret != 0) {
        Logger.DEBUG(""String_Node_Str"");
        System.exit(-2);
      }
    }
    if (halvadeOpts.combineVcf)     runCombineJob(halvadeDir,halvadeOpts.out + ""String_Node_Str"");
  }
 catch (  IOException|ClassNotFoundException|IllegalArgumentException|IllegalStateException|InterruptedException|URISyntaxException e) {
    Logger.EXCEPTION(e);
  }
  return ret;
}","@Override public int run(String[] strings) throws Exception {
  int ret=0;
  try {
    Configuration halvadeConf=getConf();
    halvadeOpts=new HalvadeOptions();
    int optReturn=halvadeOpts.GetOptions(strings,halvadeConf);
    if (optReturn != 0)     return optReturn;
    String halvadeDir=halvadeOpts.out + ""String_Node_Str"";
    if (!halvadeOpts.justCombine) {
      if (halvadeOpts.rnaPipeline) {
        if (halvadeOpts.useSharedMemory && !halvadeOpts.useBamInput) {
          ret=runPass1RNAJob(halvadeConf,halvadeOpts.out + ""String_Node_Str"");
          if (ret != 0) {
            Logger.DEBUG(""String_Node_Str"");
            System.exit(-1);
          }
          HalvadeConf.setIsPass2(halvadeConf,true);
          ret=runHalvadeJob(halvadeConf,halvadeDir,HalvadeResourceManager.RNA_SHMEM_PASS2);
        }
 else {
          ret=runHalvadeJob(halvadeConf,halvadeDir,HalvadeResourceManager.RNA);
        }
      }
 else {
        ret=runHalvadeJob(halvadeConf,halvadeDir,HalvadeResourceManager.DNA);
      }
      if (ret != 0) {
        Logger.DEBUG(""String_Node_Str"");
        System.exit(-2);
      }
    }
    if (halvadeOpts.combineVcf)     runCombineJob(halvadeDir,halvadeOpts.out + ""String_Node_Str"");
  }
 catch (  IOException|ClassNotFoundException|IllegalArgumentException|IllegalStateException|InterruptedException|URISyntaxException e) {
    Logger.EXCEPTION(e);
  }
  return ret;
}"
13745,"@Override public void readFields(DataInput di) throws IOException {
  type=di.readInt();
  chromosome=di.readInt();
  firstBaseIntron=di.readInt();
  lastBaseIntron=di.readInt();
  overhang=di.readInt();
}","@Override public void readFields(DataInput di) throws IOException {
  type=di.readInt();
  secondary_key=di.readInt();
}"
13746,"public GenomeSJ(){
  this.type=0;
  this.chromosome=Integer.MAX_VALUE;
  this.firstBaseIntron=-1;
  this.lastBaseIntron=-1;
  this.overhang=-1;
}","public GenomeSJ(){
  this.type=0;
  this.secondary_key=-1;
}"
13747,"public void parseSJString(String sjString,SAMSequenceDictionary dict){
  String columns[]=sjString.split(""String_Node_Str"");
  this.type=0;
  this.chromosome=dict.getSequenceIndex(columns[0]);
  this.firstBaseIntron=Integer.parseInt(columns[1]);
  this.lastBaseIntron=Integer.parseInt(columns[2]);
}","public void parseSJString(String sjString,SAMSequenceDictionary dict){
  String columns[]=sjString.split(""String_Node_Str"");
  this.type=-1;
  this.secondary_key=dict.getSequenceIndex(columns[0]);
}"
13748,"@Override public int compareTo(GenomeSJ o){
  if (chromosome == o.chromosome) {
    if (firstBaseIntron == o.firstBaseIntron)     return lastBaseIntron - o.lastBaseIntron;
 else     return firstBaseIntron - o.firstBaseIntron;
  }
 else   return chromosome - o.chromosome;
}","@Override public int compareTo(GenomeSJ o){
  if (type == o.type) {
    return secondary_key - o.secondary_key;
  }
 else   return type - o.type;
}"
13749,"public void setOverhang(int overhang){
  this.type=1;
  this.overhang=overhang;
}","public void setOverhang(int overhang){
  this.type=-2;
  this.secondary_key=overhang;
}"
13750,"@Override public void write(DataOutput d) throws IOException {
  d.writeInt(type);
  d.writeInt(chromosome);
  d.writeInt(firstBaseIntron);
  d.writeInt(lastBaseIntron);
  d.writeInt(overhang);
}","@Override public void write(DataOutput d) throws IOException {
  d.writeInt(type);
  d.writeInt(secondary_key);
}"
13751,"@Override protected void reduce(GenomeSJ key,Iterable<Text> values,Context context) throws IOException, InterruptedException {
  Iterator<Text> it=values.iterator();
  Logger.DEBUG(""String_Node_Str"" + key);
  if (key.getType() == 0) {
    while (it.hasNext()) {
      bw.write(it.next().toString() + ""String_Node_Str"");
      count++;
    }
  }
 else   if (key.getType() == 1) {
    overhang=key.getOverhang();
    Logger.DEBUG(""String_Node_Str"" + overhang);
  }
}","@Override protected void reduce(GenomeSJ key,Iterable<Text> values,Context context) throws IOException, InterruptedException {
  Iterator<Text> it=values.iterator();
  if (key.getType() == -1) {
    while (it.hasNext()) {
      bw.write(it.next().toString() + ""String_Node_Str"");
      count++;
    }
    Logger.DEBUG(""String_Node_Str"" + count);
  }
 else   if (key.getType() == -2) {
    overhang=key.getSecKey();
    Logger.DEBUG(""String_Node_Str"" + overhang);
  }
 else {
    int valCount=0;
    while (it.hasNext()) {
      valCount++;
      it.next();
    }
    keyFactors.add(valCount);
    totalValCount+=valCount;
    totalKeyCount++;
    Logger.DEBUG(""String_Node_Str"" + key + ""String_Node_Str""+ valCount);
  }
}"
13752,"@Override protected void cleanup(Context context) throws IOException, InterruptedException {
  FileSystem fs=null;
  try {
    fs=FileSystem.get(new URI(out),context.getConfiguration());
  }
 catch (  URISyntaxException ex) {
    Logger.EXCEPTION(ex);
  }
  bw.close();
  File mergeFile=new File(mergeJS);
  Logger.DEBUG(""String_Node_Str"" + count + ""String_Node_Str""+ mergeJS);
  HalvadeFileUtils.uploadFileToHDFS(context,fs,mergeFile.getAbsolutePath(),out + mergeFile.getName());
  HalvadeFileUtils.removeLocalFile(mergeJS);
}","@Override protected void cleanup(Context context) throws IOException, InterruptedException {
  Logger.DEBUG(""String_Node_Str"" + totalValCount);
  Logger.DEBUG(""String_Node_Str"" + totalKeyCount);
  FileSystem fs=null;
  try {
    fs=FileSystem.get(new URI(out),context.getConfiguration());
  }
 catch (  URISyntaxException ex) {
    Logger.EXCEPTION(ex);
  }
  bw.close();
  File mergeFile=new File(mergeJS);
  Logger.DEBUG(""String_Node_Str"" + count + ""String_Node_Str""+ mergeJS);
  HalvadeFileUtils.uploadFileToHDFS(context,fs,mergeFile.getAbsolutePath(),out + mergeFile.getName());
  Logger.DEBUG(""String_Node_Str"" + jobId);
  String newGenomeDir=refDir + taskId + ""String_Node_Str"";
  File starOut=new File(newGenomeDir);
  starOut.mkdirs();
  long time=STARInstance.rebuildStarGenome(context,bin,newGenomeDir,ref,mergeJS,overhang,threads,mem);
  context.getCounter(HalvadeCounters.TIME_STAR_BUILD).increment(time);
  String pass2GenDir=HalvadeConf.getStarDirPass2HDFS(context.getConfiguration());
  File pass2check=new File(newGenomeDir + HalvadeFileUtils.HALVADE_STAR_SUFFIX_P2);
  pass2check.createNewFile();
  if (requireUploadToHDFS) {
    fs.mkdirs(new Path(pass2GenDir));
    File[] genFiles=starOut.listFiles();
    for (    File gen : genFiles) {
      HalvadeFileUtils.uploadFileToHDFS(context,fs,gen.getAbsolutePath(),pass2GenDir + gen.getName());
    }
    Logger.DEBUG(""String_Node_Str"" + pass2GenDir);
  }
  HalvadeFileUtils.removeLocalFile(mergeJS);
}"
13753,"@Override protected void setup(Context context) throws IOException, InterruptedException {
  tmpDir=HalvadeConf.getScratchTempDir(context.getConfiguration());
  refDir=HalvadeConf.getRefDirOnScratch(context.getConfiguration());
  out=HalvadeConf.getOutDir(context.getConfiguration());
  taskId=context.getTaskAttemptID().toString();
  taskId=taskId.substring(taskId.indexOf(""String_Node_Str""));
  mergeJS=tmpDir + taskId + ""String_Node_Str"";
  File file=new File(mergeJS);
  threads=HalvadeConf.getReducerThreads(context.getConfiguration());
  try {
    mem=Long.parseLong(context.getConfiguration().get(""String_Node_Str""));
  }
 catch (  NumberFormatException ex) {
    mem=0;
  }
  bin=checkBinaries(context);
  try {
    ref=HalvadeFileUtils.downloadGATKIndex(context,taskId);
  }
 catch (  URISyntaxException ex) {
    Logger.EXCEPTION(ex);
    throw new InterruptedException();
  }
  bw=new BufferedWriter(new FileWriter(file.getAbsoluteFile()));
  Logger.DEBUG(""String_Node_Str"" + mergeJS);
}","@Override protected void setup(Context context) throws IOException, InterruptedException {
  totalValCount=0;
  totalKeyCount=0;
  keyFactors=new ArrayList<>();
  tmpDir=HalvadeConf.getScratchTempDir(context.getConfiguration());
  refDir=HalvadeConf.getRefDirOnScratch(context.getConfiguration());
  out=HalvadeConf.getOutDir(context.getConfiguration());
  jobId=context.getJobID().toString();
  taskId=context.getTaskAttemptID().toString();
  taskId=taskId.substring(taskId.indexOf(""String_Node_Str""));
  mergeJS=tmpDir + taskId + ""String_Node_Str"";
  File file=new File(mergeJS);
  threads=HalvadeConf.getReducerThreads(context.getConfiguration());
  try {
    mem=Long.parseLong(context.getConfiguration().get(""String_Node_Str""));
  }
 catch (  NumberFormatException ex) {
    mem=0;
  }
  bin=checkBinaries(context);
  try {
    ref=HalvadeFileUtils.downloadGATKIndex(context,taskId);
  }
 catch (  URISyntaxException ex) {
    Logger.EXCEPTION(ex);
    throw new InterruptedException();
  }
  bw=new BufferedWriter(new FileWriter(file.getAbsoluteFile()));
  Logger.DEBUG(""String_Node_Str"" + mergeJS);
}"
13754,"@Override public int compare(WritableComparable a,WritableComparable b){
  GenomeSJ sj1=(GenomeSJ)a;
  GenomeSJ sj2=(GenomeSJ)b;
  return (-1) * sj1.compareTo(sj2);
}","@Override public int compare(WritableComparable a,WritableComparable b){
  GenomeSJ sj1=(GenomeSJ)a;
  GenomeSJ sj2=(GenomeSJ)b;
  return sj1.compareTo(sj2);
}"
13755,"public int GetOptions(String[] args,Configuration hConf) throws IOException, URISyntaxException {
  try {
    boolean result=parseArguments(args,hConf);
    if (!result) {
      HelpFormatter formatter=new HelpFormatter();
      formatter.setWidth(80);
      formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
      return 1;
    }
    onedec=new DecimalFormat(""String_Node_Str"");
    if (localRefDir == null) {
      localRefDir=tmpDir;
    }
    HalvadeConf.setScratchTempDir(hConf,tmpDir);
    HalvadeConf.setRefDirOnScratch(hConf,localRefDir);
    HalvadeConf.setRefOnHDFS(hConf,ref);
    if (STARGenome != null) {
      HalvadeConf.setStarDirOnHDFS(hConf,STARGenome);
    }
    HalvadeConf.setKnownSitesOnHDFS(hConf,hdfsSites);
    HalvadeConf.setIsPaired(hConf,paired);
    HalvadeConf.setIsRNA(hConf,rnaPipeline);
    if (exomeBedFile != null) {
      HalvadeConf.setExomeBed(hConf,exomeBedFile);
    }
    HalvadeConf.setOutDir(hConf,out);
    HalvadeConf.setKeepFiles(hConf,keepFiles);
    HalvadeConf.setUseBedTools(hConf,useBedTools);
    HalvadeConf.clearTaskFiles(hConf);
    HalvadeConf.setUseElPrep(hConf,useElPrep);
    HalvadeConf.setUseUnifiedGenotyper(hConf,useGenotyper);
    HalvadeConf.setReuseJVM(hConf,reuseJVM);
    HalvadeConf.setRedistribute(hConf,redistribute);
    HalvadeConf.setReadGroup(hConf,""String_Node_Str"" + RGID + ""String_Node_Str""+ RGLB+ ""String_Node_Str""+ RGPL+ ""String_Node_Str""+ RGPU+ ""String_Node_Str""+ RGSM);
    HalvadeConf.setkeepChrSplitPairs(hConf,keepChrSplitPairs);
    if (STARGenome != null && useSharedMemory) {
      HalvadeConf.setStarDirPass2HDFS(hConf,out);
    }
    if (chr != null) {
      HalvadeConf.setChrList(hConf,chr);
    }
    if (java != null) {
      HalvadeConf.setJava(hConf,java);
    }
    if (stand_call_conf > 0) {
      HalvadeConf.setSCC(hConf,stand_call_conf);
    }
    if (stand_emit_conf > 0) {
      HalvadeConf.setSEC(hConf,stand_emit_conf);
    }
    parseDictFile(hConf);
    double inputSize=getInputSize(in,hConf);
    if (coverage == -1.0) {
      coverage=Math.max(1.0,DEFAULT_COVERAGE * (inputSize / DEFAULT_COVERAGE_SIZE));
    }
    Logger.DEBUG(""String_Node_Str"" + roundOneDecimal(coverage));
    reduces=(int)(coverage * REDUCE_TASKS_FACTOR);
    ChromosomeSplitter splitter=new ChromosomeSplitter(dict,chr,reduces);
    HalvadeConf.setMinChrLength(hConf,splitter.getRegionSize());
    reduces=splitter.getRegionCount();
  }
 catch (  ParseException e) {
    Logger.DEBUG(e.getMessage());
    HelpFormatter formatter=new HelpFormatter();
    formatter.setWidth(80);
    formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
    return 1;
  }
  return 0;
}","public int GetOptions(String[] args,Configuration hConf) throws IOException, URISyntaxException {
  try {
    boolean result=parseArguments(args,hConf);
    if (!result) {
      HelpFormatter formatter=new HelpFormatter();
      formatter.setWidth(80);
      formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
      return 1;
    }
    onedec=new DecimalFormat(""String_Node_Str"");
    if (localRefDir == null) {
      localRefDir=tmpDir;
    }
    HalvadeConf.setScratchTempDir(hConf,tmpDir);
    HalvadeConf.setRefDirOnScratch(hConf,localRefDir);
    HalvadeConf.setRefOnHDFS(hConf,ref);
    if (STARGenome != null) {
      HalvadeConf.setStarDirOnHDFS(hConf,STARGenome);
    }
    HalvadeConf.setKnownSitesOnHDFS(hConf,hdfsSites);
    HalvadeConf.setIsPaired(hConf,paired);
    HalvadeConf.setIsRNA(hConf,rnaPipeline);
    if (exomeBedFile != null) {
      HalvadeConf.setExomeBed(hConf,exomeBedFile);
    }
    HalvadeConf.setOutDir(hConf,out);
    HalvadeConf.setKeepFiles(hConf,keepFiles);
    HalvadeConf.setUseBedTools(hConf,useBedTools);
    HalvadeConf.clearTaskFiles(hConf);
    HalvadeConf.setUseElPrep(hConf,useElPrep);
    HalvadeConf.setUseUnifiedGenotyper(hConf,useGenotyper);
    HalvadeConf.setReuseJVM(hConf,reuseJVM);
    HalvadeConf.setRedistribute(hConf,redistribute);
    HalvadeConf.setReadGroup(hConf,""String_Node_Str"" + RGID + ""String_Node_Str""+ RGLB+ ""String_Node_Str""+ RGPL+ ""String_Node_Str""+ RGPU+ ""String_Node_Str""+ RGSM);
    HalvadeConf.setkeepChrSplitPairs(hConf,keepChrSplitPairs);
    if (STARGenome != null && useSharedMemory) {
      HalvadeConf.setStarDirPass2HDFS(hConf,out);
    }
    if (chr != null) {
      HalvadeConf.setChrList(hConf,chr);
    }
    if (java != null) {
      HalvadeConf.setJava(hConf,java);
    }
    if (stand_call_conf > 0) {
      HalvadeConf.setSCC(hConf,stand_call_conf);
    }
    if (stand_emit_conf > 0) {
      HalvadeConf.setSEC(hConf,stand_emit_conf);
    }
    parseDictFile(hConf);
    double inputSize=getInputSize(in,hConf);
    if (coverage == -1.0) {
      coverage=Math.max(1.0,DEFAULT_COVERAGE * (inputSize / DEFAULT_COVERAGE_SIZE));
    }
    Logger.DEBUG(""String_Node_Str"" + roundOneDecimal(coverage));
    reduces=(int)(coverage * REDUCE_TASKS_FACTOR);
    ChromosomeSplitter splitter=new ChromosomeSplitter(dict,chr,reduces);
    HalvadeConf.setMinChrLength(hConf,splitter.getRegionSize());
    reduces=splitter.getRegionCount() + 1;
  }
 catch (  ParseException e) {
    Logger.DEBUG(e.getMessage());
    HelpFormatter formatter=new HelpFormatter();
    formatter.setWidth(80);
    formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
    return 1;
  }
  return 0;
}"
13756,"@Override protected void map(LongWritable key,SAMRecordWritable value,Context context) throws IOException, InterruptedException {
  SAMRecord sam=value.get();
  try {
    String s=sam.getSAMString();
  }
 catch (  StringIndexOutOfBoundsException e) {
    Logger.DEBUG(""String_Node_Str"");
    Logger.DEBUG(sam.getReadName() + ""String_Node_Str"" + sam.getReadString());
    throw e;
  }
  instance.writePairedSAMRecordToContext(value.get(),false);
}","@Override protected void map(LongWritable key,SAMRecordWritable value,Context context) throws IOException, InterruptedException {
  try {
    value.get().getSAMString();
  }
 catch (  StringIndexOutOfBoundsException e) {
    Logger.DEBUG(""String_Node_Str"");
  }
  instance.writePairedSAMRecordToContext(value.get(),false);
}"
13757,"@Override protected void processAlignments(Iterable<SAMRecordWritable> values,Context context,PreprocessingTools tools,GATKTools gatk) throws IOException, InterruptedException, URISyntaxException, QualityException {
  long startTime=System.currentTimeMillis();
  String region=tmpFileBase + ""String_Node_Str"";
  String preprocess=tmpFileBase + ""String_Node_Str"";
  String tmpFile1=tmpFileBase + ""String_Node_Str"";
  String tmpFile2=tmpFileBase + ""String_Node_Str"";
  String snps=tmpFileBase + ""String_Node_Str"";
  boolean useElPrep=HalvadeConf.getUseElPrep(context.getConfiguration());
  ChromosomeRange r=new ChromosomeRange();
  SAMRecordIterator SAMit=new SAMRecordIterator(values.iterator(),header,r);
  if (useElPrep && isFirstAttempt)   elPrepPreprocess(context,tools,SAMit,preprocess);
 else {
    if (!isFirstAttempt)     Logger.DEBUG(""String_Node_Str"" + taskId + ""String_Node_Str"");
    if (redistribute) {
      threads=6;
      gatk.setThreads(threads);
    }
    PicardPreprocess(context,tools,SAMit,preprocess);
  }
  region=makeRegionFile(context,r,tools,region);
  if (region == null)   return;
  indelRealignment(context,region,gatk,preprocess,tmpFile1);
  baseQualityScoreRecalibration(context,region,r,tools,gatk,tmpFile1,tmpFile2);
  DnaVariantCalling(context,region,gatk,tmpFile2,snps);
  variantFiles.add(snps);
  HalvadeFileUtils.removeLocalFile(region);
  long estimatedTime=System.currentTimeMillis() - startTime;
  Logger.DEBUG(""String_Node_Str"" + estimatedTime / 1000);
}","@Override protected void processAlignments(Iterable<SAMRecordWritable> values,Context context,PreprocessingTools tools,GATKTools gatk) throws IOException, InterruptedException, URISyntaxException, QualityException {
  long startTime=System.currentTimeMillis();
  String region=tmpFileBase + ""String_Node_Str"";
  String preprocess=tmpFileBase + ""String_Node_Str"";
  String tmpFile1=tmpFileBase + ""String_Node_Str"";
  String tmpFile2=tmpFileBase + ""String_Node_Str"";
  String snps=tmpFileBase + ""String_Node_Str"";
  boolean useElPrep=HalvadeConf.getUseElPrep(context.getConfiguration());
  ChromosomeRange r=new ChromosomeRange();
  SAMRecordIterator SAMit=new SAMRecordIterator(values.iterator(),header,r);
  if (useElPrep && isFirstAttempt)   elPrepPreprocess(context,tools,SAMit,preprocess);
 else {
    if (!isFirstAttempt)     Logger.DEBUG(""String_Node_Str"" + taskId + ""String_Node_Str"");
    if (redistribute) {
      threads=6;
      gatk.setThreads(threads);
      Logger.DEBUG(""String_Node_Str"");
    }
    PicardPreprocess(context,tools,SAMit,preprocess);
  }
  region=makeRegionFile(context,r,tools,region);
  if (region == null)   return;
  indelRealignment(context,region,gatk,preprocess,tmpFile1);
  baseQualityScoreRecalibration(context,region,r,tools,gatk,tmpFile1,tmpFile2);
  DnaVariantCalling(context,region,gatk,tmpFile2,snps);
  variantFiles.add(snps);
  HalvadeFileUtils.removeLocalFile(region);
  long estimatedTime=System.currentTimeMillis() - startTime;
  Logger.DEBUG(""String_Node_Str"" + estimatedTime / 1000);
}"
13758,"protected void PicardPreprocess(Context context,PreprocessingTools tools,SAMRecordIterator input,String output) throws InterruptedException, QualityException {
  outHeader=header.clone();
  outHeader.setSortOrder(SAMFileHeader.SortOrder.coordinate);
  String tmpOut1=tmpFileBase + ""String_Node_Str"";
  String tmpOut2=tmpFileBase + ""String_Node_Str"";
  String tmpOut3=tmpFileBase + ""String_Node_Str"";
  String tmpMetrics=tmpFileBase + ""String_Node_Str"";
  SAMFileWriterFactory factory=new SAMFileWriterFactory();
  SAMFileWriter writer=factory.makeBAMWriter(outHeader,true,new File(tmpOut1));
  long startTime=System.currentTimeMillis();
  int count=0;
  SAMRecord sam;
  while (input.hasNext()) {
    sam=input.next();
    writer.addAlignment(sam);
    count++;
  }
  int reads=input.getCount();
  writer.close();
  context.getCounter(HalvadeCounters.IN_PREP_READS).increment(reads);
  long estimatedTime=System.currentTimeMillis() - startTime;
  context.getCounter(HalvadeCounters.TIME_HADOOP_SAMTOBAM).increment(estimatedTime);
  Logger.DEBUG(""String_Node_Str"" + count + ""String_Node_Str""+ estimatedTime / 1000);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runCleanSam(tmpOut1,tmpOut2);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runMarkDuplicates(tmpOut2,tmpOut3,tmpMetrics);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runAddOrReplaceReadGroups(tmpOut3,output,RGID,RGLB,RGPL,RGPU,RGSM);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runBuildBamIndex(output);
  estimatedTime=System.currentTimeMillis() - startTime;
  Logger.DEBUG(""String_Node_Str"" + estimatedTime / 1000);
  HalvadeFileUtils.removeLocalFile(keep,tmpMetrics,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut1,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut2,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut3,context,HalvadeCounters.FOUT_GATK_TMP);
}","protected void PicardPreprocess(Context context,PreprocessingTools tools,SAMRecordIterator input,String output) throws InterruptedException, QualityException {
  outHeader=header.clone();
  outHeader.setSortOrder(SAMFileHeader.SortOrder.coordinate);
  String tmpOut1=tmpFileBase + ""String_Node_Str"";
  String tmpOut2=tmpFileBase + ""String_Node_Str"";
  String tmpOut3=tmpFileBase + ""String_Node_Str"";
  String tmpMetrics=tmpFileBase + ""String_Node_Str"";
  SAMFileWriterFactory factory=new SAMFileWriterFactory();
  outHeader.addReadGroup(bamrg);
  SAMFileWriter writer=factory.makeBAMWriter(outHeader,true,new File(tmpOut1));
  long startTime=System.currentTimeMillis();
  int count=0;
  SAMRecord sam;
  while (input.hasNext()) {
    sam=input.next();
    writer.addAlignment(sam);
    count++;
  }
  int reads=input.getCount();
  writer.close();
  context.getCounter(HalvadeCounters.IN_PREP_READS).increment(reads);
  long estimatedTime=System.currentTimeMillis() - startTime;
  context.getCounter(HalvadeCounters.TIME_HADOOP_SAMTOBAM).increment(estimatedTime);
  Logger.DEBUG(""String_Node_Str"" + count + ""String_Node_Str""+ estimatedTime / 1000);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runCleanSam(tmpOut1,tmpOut2);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runMarkDuplicates(tmpOut2,tmpOut3,tmpMetrics);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runAddOrReplaceReadGroups(tmpOut3,output,RGID,RGLB,RGPL,RGPU,RGSM);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runBuildBamIndex(output);
  estimatedTime=System.currentTimeMillis() - startTime;
  Logger.DEBUG(""String_Node_Str"" + estimatedTime / 1000);
  HalvadeFileUtils.removeLocalFile(keep,tmpMetrics,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut1,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut2,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut3,context,HalvadeCounters.FOUT_GATK_TMP);
}"
13759,"@Override protected void setup(Context context) throws IOException, InterruptedException {
  super.setup(context);
  isFirstAttempt=taskId.endsWith(""String_Node_Str"");
  isRNA=HalvadeConf.getIsRNA(context.getConfiguration());
  scc=HalvadeConf.getSCC(context.getConfiguration(),isRNA);
  sec=HalvadeConf.getSEC(context.getConfiguration(),isRNA);
  exomeBedFile=HalvadeConf.getExomeBed(context.getConfiguration());
  useBedTools=HalvadeConf.getUseBedTools(context.getConfiguration());
  useUnifiedGenotyper=HalvadeConf.getUseUnifiedGenotyper(context.getConfiguration());
  redistribute=HalvadeConf.getRedistribute(context.getConfiguration());
}","@Override protected void setup(Context context) throws IOException, InterruptedException {
  super.setup(context);
  isFirstAttempt=taskId.endsWith(""String_Node_Str"");
  isRNA=HalvadeConf.getIsRNA(context.getConfiguration());
  scc=HalvadeConf.getSCC(context.getConfiguration(),isRNA);
  sec=HalvadeConf.getSEC(context.getConfiguration(),isRNA);
  exomeBedFile=HalvadeConf.getExomeBed(context.getConfiguration());
  useBedTools=HalvadeConf.getUseBedTools(context.getConfiguration());
  useUnifiedGenotyper=HalvadeConf.getUseUnifiedGenotyper(context.getConfiguration());
  redistribute=HalvadeConf.getRedistribute(context.getConfiguration());
  containers=HalvadeConf.getMapContainerCount(context.getConfiguration());
  tasksLeft=Integer.parseInt(context.getConfiguration().get(""String_Node_Str"")) - taskNr;
  if (redistribute && tasksLeft < containers) {
    threads=6;
  }
}"
13760,"@Override protected void setup(Context context) throws IOException, InterruptedException {
  super.setup(context);
  keep=HalvadeConf.getKeepFiles(context.getConfiguration());
  java=HalvadeConf.getJava(context.getConfiguration());
  tmp=HalvadeConf.getScratchTempDir(context.getConfiguration());
  threads=HalvadeConf.getReducerThreads(context.getConfiguration());
  dict=HalvadeConf.getSequenceDictionary(context.getConfiguration());
  getReadGroupData(context.getConfiguration());
  taskId=context.getTaskAttemptID().toString();
  taskId=taskId.substring(taskId.indexOf(""String_Node_Str""));
  header=new SAMFileHeader();
  header.setSequenceDictionary(dict);
  count=0;
  variantFiles=new ArrayList<>();
  bin=checkBinaries(context);
  try {
    ref=HalvadeFileUtils.downloadGATKIndex(context,taskId);
  }
 catch (  URISyntaxException ex) {
    Logger.EXCEPTION(ex);
    throw new InterruptedException();
  }
}","@Override protected void setup(Context context) throws IOException, InterruptedException {
  super.setup(context);
  keep=HalvadeConf.getKeepFiles(context.getConfiguration());
  java=HalvadeConf.getJava(context.getConfiguration());
  tmp=HalvadeConf.getScratchTempDir(context.getConfiguration());
  threads=HalvadeConf.getReducerThreads(context.getConfiguration());
  dict=HalvadeConf.getSequenceDictionary(context.getConfiguration());
  getReadGroupData(context.getConfiguration());
  taskId=context.getTaskAttemptID().toString();
  taskId=taskId.substring(taskId.indexOf(""String_Node_Str""));
  taskNr=Integer.parseInt(taskId.split(""String_Node_Str"")[1]);
  header=new SAMFileHeader();
  header.setSequenceDictionary(dict);
  count=0;
  variantFiles=new ArrayList<>();
  bin=checkBinaries(context);
  bamrg=new SAMReadGroupRecord(RGID);
  bamrg.setLibrary(RGLB);
  bamrg.setPlatform(RGPL);
  bamrg.setPlatformUnit(RGPU);
  bamrg.setSample(RGSM);
  try {
    ref=HalvadeFileUtils.downloadGATKIndex(context,taskId);
  }
 catch (  URISyntaxException ex) {
    Logger.EXCEPTION(ex);
    throw new InterruptedException();
  }
}"
13761,"protected AlignerInstance(Mapper.Context context,String bin) throws IOException, URISyntaxException {
  AlignerInstance.context=context;
  header=null;
  containers=HalvadeConf.getMapContainerCount(context.getConfiguration());
  containerMinusTasksLeft=HalvadeConf.lessTasksLeftThanContainers(context.getConfiguration());
  redistribute=HalvadeConf.getRedistribute(context.getConfiguration());
  writableRecord=new SAMRecordWritable();
  writableRegion=new ChromosomeRegion();
  writeableCompactRegion=new GenomeSJ();
  stub=new Text();
  minChrLength=HalvadeConf.getMinChrLength(context.getConfiguration());
  chr=HalvadeConf.getChrList(context.getConfiguration());
  tmpdir=HalvadeConf.getScratchTempDir(context.getConfiguration());
  if (!tmpdir.endsWith(""String_Node_Str""))   tmpdir=tmpdir + ""String_Node_Str"";
  File tmp=new File(tmpdir);
  tmp.mkdirs();
  this.bin=bin;
  threads=HalvadeConf.getMapThreads(context.getConfiguration());
  isPaired=HalvadeConf.getIsPaired(context.getConfiguration());
  Logger.DEBUG(""String_Node_Str"" + isPaired);
  splitter=new ChromosomeSplitter(HalvadeConf.getSequenceDictionary(context.getConfiguration()),minChrLength,chr);
  keepChrSplitPairs=HalvadeConf.getkeepChrSplitPairs(context.getConfiguration());
  keep=HalvadeConf.getKeepFiles(context.getConfiguration());
}","protected AlignerInstance(Mapper.Context context,String bin) throws IOException, URISyntaxException {
  AlignerInstance.context=context;
  header=null;
  containers=HalvadeConf.getMapContainerCount(context.getConfiguration());
  tasksLeft=HalvadeConf.getMapTasksLeft(context.getConfiguration());
  redistribute=HalvadeConf.getRedistribute(context.getConfiguration());
  writableRecord=new SAMRecordWritable();
  writableRegion=new ChromosomeRegion();
  writeableCompactRegion=new GenomeSJ();
  stub=new Text();
  minChrLength=HalvadeConf.getMinChrLength(context.getConfiguration());
  chr=HalvadeConf.getChrList(context.getConfiguration());
  tmpdir=HalvadeConf.getScratchTempDir(context.getConfiguration());
  if (!tmpdir.endsWith(""String_Node_Str""))   tmpdir=tmpdir + ""String_Node_Str"";
  File tmp=new File(tmpdir);
  tmp.mkdirs();
  this.bin=bin;
  threads=HalvadeConf.getMapThreads(context.getConfiguration());
  isPaired=HalvadeConf.getIsPaired(context.getConfiguration());
  Logger.DEBUG(""String_Node_Str"" + isPaired);
  splitter=new ChromosomeSplitter(HalvadeConf.getSequenceDictionary(context.getConfiguration()),minChrLength,chr);
  keepChrSplitPairs=HalvadeConf.getkeepChrSplitPairs(context.getConfiguration());
  keep=HalvadeConf.getKeepFiles(context.getConfiguration());
}"
13762,"public int writePairedSAMRecordToContext(SAMRecord sam,boolean useCompact) throws IOException, InterruptedException {
  int count=0;
  int read1Ref=sam.getReferenceIndex();
  int read2Ref=sam.getMateReferenceIndex();
  if (!sam.getReadUnmappedFlag() && (read1Ref == read2Ref || keepChrSplitPairs) && (read1Ref > 0 || read2Ref > 0)) {
    context.getCounter(HalvadeCounters.OUT_BWA_READS).increment(1);
    writableRecord.set(sam);
    int[] keys=new int[4];
    int readLength=sam.getReadLength();
    int beginpos1=sam.getAlignmentStart();
    int beginpos2=sam.getMateAlignmentStart();
    int keyrange_start=0;
    int keyrange_end=4;
    if (read1Ref > 0) {
      keys[0]=splitter.getKey(splitter.getRegion(beginpos1,read1Ref),read1Ref);
      if (splitter.checkUpperBound(beginpos1 + readLength,read1Ref))       keys[1]=splitter.getKey(splitter.getRegion(beginpos1 + readLength,read1Ref),read1Ref);
 else       keys[1]=keys[0];
    }
 else     keyrange_start=2;
    if (read2Ref > 0) {
      keys[2]=splitter.getKey(splitter.getRegion(beginpos2,read2Ref),read2Ref);
      if (splitter.checkUpperBound(beginpos2 + readLength,read2Ref))       keys[3]=splitter.getKey(splitter.getRegion(beginpos2 + readLength,read2Ref),read2Ref);
 else       keys[3]=keys[2];
    }
 else     keyrange_end=2;
    Arrays.sort(keys);
    if (keyrange_start != keyrange_end) {
      if (useCompact) {
        writeableCompactRegion.setRegion(keys[keyrange_start],beginpos1);
        context.write(writeableCompactRegion,stub);
      }
 else {
        writableRegion.setChromosomeRegion(read1Ref,beginpos1,keys[keyrange_start]);
        context.write(writableRegion,writableRecord);
      }
      count++;
      for (int i=keyrange_start + 1; i < keyrange_end; i++) {
        if (keys[i] != keys[i - 1]) {
          context.getCounter(HalvadeCounters.OUT_OVERLAPPING_READS).increment(1);
          if (useCompact) {
            writeableCompactRegion.setRegion(keys[i],beginpos1);
            context.write(writeableCompactRegion,stub);
          }
 else {
            writableRegion.setChromosomeRegion(read1Ref,beginpos1,keys[i]);
            context.write(writableRegion,writableRecord);
          }
          count++;
        }
      }
    }
  }
 else {
    if (sam.getReadUnmappedFlag())     context.getCounter(HalvadeCounters.OUT_UNMAPPED_READS).increment(1);
 else     context.getCounter(HalvadeCounters.OUT_DIFF_CHR_READS).increment(1);
  }
  return count;
}","public int writePairedSAMRecordToContext(SAMRecord sam,boolean useCompact) throws IOException, InterruptedException {
  int count=0;
  int read1Ref=sam.getReferenceIndex();
  int read2Ref=sam.getMateReferenceIndex();
  if (!sam.getReadUnmappedFlag() && (read1Ref == read2Ref || keepChrSplitPairs) && (read1Ref >= 0 || read2Ref >= 0)) {
    context.getCounter(HalvadeCounters.OUT_BWA_READS).increment(1);
    writableRecord.set(sam);
    ArrayList<Integer> keys=new ArrayList<>();
    int readLength=sam.getReadLength();
    int beginpos1=sam.getAlignmentStart();
    int beginpos2=sam.getMateAlignmentStart();
    if (read1Ref >= 0) {
      keys.add(splitter.getKey(splitter.getRegion(beginpos1,read1Ref),read1Ref));
      keys.add(splitter.getKey(splitter.getRegion(beginpos1 + readLength,read1Ref),read1Ref));
    }
    if (read2Ref >= 0) {
      keys.add(splitter.getKey(splitter.getRegion(beginpos2,read2Ref),read2Ref));
      keys.add(splitter.getKey(splitter.getRegion(beginpos2 + readLength,read2Ref),read2Ref));
    }
    Set<Integer> mySet=new HashSet<>(keys);
    Iterator<Integer> it=mySet.iterator();
    while (it.hasNext()) {
      int key=it.next();
      if (useCompact) {
        writeableCompactRegion.setRegion(key,beginpos1);
        context.write(writeableCompactRegion,stub);
      }
 else {
        writableRegion.setChromosomeRegion(read1Ref,beginpos1,key);
        context.write(writableRegion,writableRecord);
      }
      count++;
    }
  }
 else {
    if (sam.getReadUnmappedFlag())     context.getCounter(HalvadeCounters.OUT_UNMAPPED_READS).increment(1);
 else     context.getCounter(HalvadeCounters.OUT_DIFF_CHR_READS).increment(1);
  }
  return count;
}"
13763,"protected void getIdleCores(Mapper.Context context) throws IOException {
  if (containerMinusTasksLeft > 0)   threads=6;
}","protected void getIdleCores(Mapper.Context context) throws IOException {
  if (tasksLeft < containers)   threads=6;
}"
13764,"@Override protected void startAligner(Mapper.Context context) throws IOException, InterruptedException {
  if (redistribute && containerMinusTasksLeft > 0) {
    getIdleCores(context);
    Logger.DEBUG(""String_Node_Str"" + threads);
  }
  int threadsToUse=threads;
  if (isPaired && threadsToUse > 1)   threadsToUse/=2;
  String[] command1=CommandGenerator.bwaAln(bin,ref,""String_Node_Str"",getFileName(tmpdir,taskId,true,1),threadsToUse,alnCustomArgs);
  reads1=new ProcessBuilderWrapper(command1,bin);
  reads1.setThreads(threadsToUse);
  reads1.startProcess(null,System.err);
  if (!reads1.isAlive())   throw new ProcessException(""String_Node_Str"",reads1.getExitState());
  File file1=new File(getFileName(tmpdir,taskId,false,1));
  if (!file1.exists()) {
    file1.createNewFile();
  }
  fastqFile1=new BufferedWriter(new FileWriter(file1.getAbsoluteFile()));
  if (isPaired) {
    if (threads > 1) {
      String[] command2=CommandGenerator.bwaAln(bin,ref,""String_Node_Str"",getFileName(tmpdir,taskId,true,2),threadsToUse,alnCustomArgs);
      reads2=new ProcessBuilderWrapper(command2,bin);
      reads2.setThreads(threadsToUse);
      reads2.startProcess(null,System.err);
      if (!reads2.isAlive())       throw new ProcessException(""String_Node_Str"",reads2.getExitState());
    }
    File file2=new File(getFileName(tmpdir,taskId,false,2));
    if (!file2.exists()) {
      file2.createNewFile();
    }
    fastqFile2=new BufferedWriter(new FileWriter(file2.getAbsoluteFile()));
  }
}","@Override protected void startAligner(Mapper.Context context) throws IOException, InterruptedException {
  if (redistribute) {
    getIdleCores(context);
    Logger.DEBUG(""String_Node_Str"" + threads);
  }
  int threadsToUse=threads;
  if (isPaired && threadsToUse > 1)   threadsToUse/=2;
  String[] command1=CommandGenerator.bwaAln(bin,ref,""String_Node_Str"",getFileName(tmpdir,taskId,true,1),threadsToUse,alnCustomArgs);
  reads1=new ProcessBuilderWrapper(command1,bin);
  reads1.setThreads(threadsToUse);
  reads1.startProcess(null,System.err);
  if (!reads1.isAlive())   throw new ProcessException(""String_Node_Str"",reads1.getExitState());
  File file1=new File(getFileName(tmpdir,taskId,false,1));
  if (!file1.exists()) {
    file1.createNewFile();
  }
  fastqFile1=new BufferedWriter(new FileWriter(file1.getAbsoluteFile()));
  if (isPaired) {
    if (threads > 1) {
      String[] command2=CommandGenerator.bwaAln(bin,ref,""String_Node_Str"",getFileName(tmpdir,taskId,true,2),threadsToUse,alnCustomArgs);
      reads2=new ProcessBuilderWrapper(command2,bin);
      reads2.setThreads(threadsToUse);
      reads2.startProcess(null,System.err);
      if (!reads2.isAlive())       throw new ProcessException(""String_Node_Str"",reads2.getExitState());
    }
    File file2=new File(getFileName(tmpdir,taskId,false,2));
    if (!file2.exists()) {
      file2.createNewFile();
    }
    fastqFile2=new BufferedWriter(new FileWriter(file2.getAbsoluteFile()));
  }
}"
13765,"public static void setJobResources(HalvadeOptions opt,Configuration conf,int type,boolean subtractAM){
  int tmpmem=(int)(opt.mem * 1024);
  int tmpvcores=opt.vcores;
  if (opt.setMapContainers)   opt.mapContainersPerNode=Math.min(tmpvcores,Math.max(tmpmem / RESOURCE_REQ[type][0],1));
  if (opt.setReduceContainers)   opt.reducerContainersPerNode=Math.min(tmpvcores,Math.max(tmpmem / RESOURCE_REQ[type][1],1));
  opt.maps=Math.max(1,opt.nodes * opt.mapContainersPerNode);
  Logger.DEBUG(""String_Node_Str"" + opt.maps);
  HalvadeConf.setMapContainerCount(conf,opt.maps);
  HalvadeConf.setVcores(conf,opt.vcores);
  opt.mthreads=Math.max(1,tmpvcores / opt.mapContainersPerNode);
  opt.rthreads=Math.max(1,tmpvcores / opt.reducerContainersPerNode);
  if (opt.smtEnabled) {
    opt.mthreads*=2;
    opt.rthreads*=2;
  }
  int mmem=RESOURCE_REQ[type][0];
  int rmem=RESOURCE_REQ[type][1] == ALL ? tmpmem - MEM_AM : RESOURCE_REQ[type][1];
  if (type == DNA) {
    if (opt.overrideMem > 0) {
      mmem=opt.overrideMem;
      rmem=opt.overrideMem;
    }
  }
  Logger.DEBUG(""String_Node_Str"" + opt.mapContainersPerNode + ""String_Node_Str""+ opt.mthreads+ ""String_Node_Str""+ mmem+ ""String_Node_Str""+ opt.reducerContainersPerNode+ ""String_Node_Str""+ opt.rthreads+ ""String_Node_Str""+ rmem+ ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + opt.mthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + mmem);
  if (subtractAM)   conf.set(""String_Node_Str"",""String_Node_Str"" + (opt.rthreads - VCORES_AM));
 else   conf.set(""String_Node_Str"",""String_Node_Str"" + opt.rthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + rmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.8 * rmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.8 * mmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"");
  HalvadeConf.setMapThreads(conf,opt.mthreads);
  HalvadeConf.setReducerThreads(conf,opt.rthreads);
}","public static void setJobResources(HalvadeOptions opt,Configuration conf,int type,boolean subtractAM){
  int tmpmem=(int)(opt.mem * 1024);
  int tmpvcores=opt.vcores;
  int mmem=RESOURCE_REQ[type][0];
  int rmem=RESOURCE_REQ[type][1] == ALL ? tmpmem - MEM_AM : RESOURCE_REQ[type][1];
  if (type == DNA && opt.overrideMem > 0) {
    mmem=opt.overrideMem;
    rmem=opt.overrideMem;
  }
  if (opt.setMapContainers)   opt.mapContainersPerNode=Math.min(tmpvcores,Math.max(tmpmem / mmem,1));
  if (opt.setReduceContainers)   opt.reducerContainersPerNode=Math.min(tmpvcores,Math.max(tmpmem / rmem,1));
  opt.maps=Math.max(1,opt.nodes * opt.mapContainersPerNode);
  Logger.DEBUG(""String_Node_Str"" + opt.maps);
  HalvadeConf.setMapContainerCount(conf,opt.maps);
  HalvadeConf.setVcores(conf,opt.vcores);
  opt.mthreads=Math.max(1,tmpvcores / opt.mapContainersPerNode);
  opt.rthreads=Math.max(1,tmpvcores / opt.reducerContainersPerNode);
  if (opt.smtEnabled) {
    opt.mthreads*=2;
    opt.rthreads*=2;
  }
  Logger.DEBUG(""String_Node_Str"" + opt.mapContainersPerNode + ""String_Node_Str""+ opt.mthreads+ ""String_Node_Str""+ mmem+ ""String_Node_Str""+ opt.reducerContainersPerNode+ ""String_Node_Str""+ opt.rthreads+ ""String_Node_Str""+ rmem+ ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + opt.mthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + mmem);
  if (subtractAM)   conf.set(""String_Node_Str"",""String_Node_Str"" + (opt.rthreads - VCORES_AM));
 else   conf.set(""String_Node_Str"",""String_Node_Str"" + opt.rthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + rmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.8 * rmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + (int)(0.8 * mmem) + ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"");
  HalvadeConf.setMapThreads(conf,opt.mthreads);
  HalvadeConf.setReducerThreads(conf,opt.rthreads);
}"
13766,"@Override protected void map(LongWritable key,SAMRecordWritable value,Context context) throws IOException, InterruptedException {
  SAMRecord sam=value.get();
  Logger.DEBUG(sam.getSAMString());
  instance.writePairedSAMRecordToContext(value.get(),false);
}","@Override protected void map(LongWritable key,SAMRecordWritable value,Context context) throws IOException, InterruptedException {
  SAMRecord sam=value.get();
  try {
    String s=sam.getSAMString();
  }
 catch (  StringIndexOutOfBoundsException e) {
    Logger.DEBUG(""String_Node_Str"");
    Logger.DEBUG(sam.getReadName() + ""String_Node_Str"" + sam.getReadString());
    throw e;
  }
  instance.writePairedSAMRecordToContext(value.get(),false);
}"
13767,"protected void PicardPreprocess(Context context,PreprocessingTools tools,SAMRecordIterator input,String output) throws InterruptedException, QualityException, IOException, URISyntaxException {
  outHeader=header.clone();
  outHeader.setSortOrder(SAMFileHeader.SortOrder.coordinate);
  String tmpOut1=tmpFileBase + ""String_Node_Str"";
  String tmpOut2=tmpFileBase + ""String_Node_Str"";
  String tmpOut3=tmpFileBase + ""String_Node_Str"";
  String fCounts=tmpFileBase + ""String_Node_Str"";
  String tmpMetrics=tmpFileBase + ""String_Node_Str"";
  SAMFileWriterFactory factory=new SAMFileWriterFactory();
  if (!inputIsBam)   outHeader.addReadGroup(bamrg);
  SAMFileWriter writer=factory.makeBAMWriter(outHeader,true,new File(tmpOut1));
  long startTime=System.currentTimeMillis();
  int count=0;
  SAMRecord sam;
  while (input.hasNext()) {
    sam=input.next();
    writer.addAlignment(sam);
    count++;
  }
  int reads=input.getCount();
  writer.close();
  context.getCounter(HalvadeCounters.IN_PREP_READS).increment(reads);
  long estimatedTime=System.currentTimeMillis() - startTime;
  context.getCounter(HalvadeCounters.TIME_HADOOP_SAMTOBAM).increment(estimatedTime);
  Logger.DEBUG(""String_Node_Str"" + count + ""String_Node_Str""+ estimatedTime / 1000);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runCleanSam(tmpOut1,tmpOut2);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runMarkDuplicates(tmpOut2,tmpOut3,tmpMetrics);
  if (gff != null) {
    Logger.DEBUG(""String_Node_Str"");
    context.setStatus(""String_Node_Str"");
    tools.runFeatureCounts(gff,tmpOut3,fCounts);
    HalvadeFileUtils.uploadFileToHDFS(context,FileSystem.get(new URI(outputdir),context.getConfiguration()),fCounts,outputdir + context.getTaskAttemptID().toString() + ""String_Node_Str"");
    HalvadeFileUtils.uploadFileToHDFS(context,null,ref,tmp);
  }
  if (!inputIsBam) {
    Logger.DEBUG(""String_Node_Str"");
    context.setStatus(""String_Node_Str"");
    tools.runAddOrReplaceReadGroups(tmpOut3,output,RGID,RGLB,RGPL,RGPU,RGSM);
  }
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runBuildBamIndex(output);
  estimatedTime=System.currentTimeMillis() - startTime;
  Logger.DEBUG(""String_Node_Str"" + estimatedTime / 1000);
  HalvadeFileUtils.removeLocalFile(keep,tmpMetrics,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut1,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut2,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut3,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,htseq);
}","protected void PicardPreprocess(Context context,PreprocessingTools tools,SAMRecordIterator input,String output) throws InterruptedException, QualityException, IOException, URISyntaxException {
  outHeader=header.clone();
  outHeader.setSortOrder(SAMFileHeader.SortOrder.coordinate);
  String tmpOut1=tmpFileBase + ""String_Node_Str"";
  String tmpOut2=tmpFileBase + ""String_Node_Str"";
  String tmpOut3=tmpFileBase + ""String_Node_Str"";
  String fCounts=tmpFileBase + ""String_Node_Str"";
  String tmpMetrics=tmpFileBase + ""String_Node_Str"";
  SAMFileWriterFactory factory=new SAMFileWriterFactory();
  if (!inputIsBam)   outHeader.addReadGroup(bamrg);
  SAMFileWriter writer=factory.makeBAMWriter(outHeader,true,new File(tmpOut1));
  long startTime=System.currentTimeMillis();
  int count=0;
  SAMRecord sam;
  while (input.hasNext()) {
    sam=input.next();
    writer.addAlignment(sam);
    count++;
  }
  int reads=input.getCount();
  writer.close();
  context.getCounter(HalvadeCounters.IN_PREP_READS).increment(reads);
  long estimatedTime=System.currentTimeMillis() - startTime;
  context.getCounter(HalvadeCounters.TIME_HADOOP_SAMTOBAM).increment(estimatedTime);
  Logger.DEBUG(""String_Node_Str"" + count + ""String_Node_Str""+ estimatedTime / 1000);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runCleanSam(tmpOut1,tmpOut2);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runMarkDuplicates(tmpOut2,tmpOut3,tmpMetrics);
  if (gff != null) {
    Logger.DEBUG(""String_Node_Str"");
    context.setStatus(""String_Node_Str"");
    tools.runFeatureCounts(gff,tmpOut3,fCounts);
    HalvadeFileUtils.uploadFileToHDFS(context,FileSystem.get(new URI(outputdir),context.getConfiguration()),fCounts,outputdir + context.getTaskAttemptID().toString() + ""String_Node_Str"");
    HalvadeFileUtils.uploadFileToHDFS(context,null,ref,tmp);
  }
  if (!inputIsBam) {
    Logger.DEBUG(""String_Node_Str"");
    context.setStatus(""String_Node_Str"");
    tools.runAddOrReplaceReadGroups(tmpOut3,output,RGID,RGLB,RGPL,RGPU,RGSM);
  }
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runBuildBamIndex(output);
  estimatedTime=System.currentTimeMillis() - startTime;
  Logger.DEBUG(""String_Node_Str"" + estimatedTime / 1000);
  HalvadeFileUtils.removeLocalFile(keep,tmpMetrics,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut1,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut2,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut3,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,fCounts);
}"
13768,"@Override protected void setup(Context context) throws IOException, InterruptedException {
  super.setup(context);
  isFirstAttempt=taskId.endsWith(""String_Node_Str"");
  isRNA=HalvadeConf.getIsRNA(context.getConfiguration());
  scc=HalvadeConf.getSCC(context.getConfiguration(),isRNA);
  sec=HalvadeConf.getSEC(context.getConfiguration(),isRNA);
  gff=HalvadeFileUtils.downloadGFF(context,taskId);
  exomeBedFile=HalvadeConf.getBed(context.getConfiguration());
  useBedTools=HalvadeConf.getUseBedTools(context.getConfiguration());
  useUnifiedGenotyper=HalvadeConf.getUseUnifiedGenotyper(context.getConfiguration());
  redistribute=HalvadeConf.getRedistribute(context.getConfiguration());
  containers=HalvadeConf.getMapContainerCount(context.getConfiguration());
  tasksLeft=Integer.parseInt(context.getConfiguration().get(""String_Node_Str"")) - taskNr;
  if (redistribute && tasksLeft < containers) {
    threads=6;
  }
}","@Override protected void setup(Context context) throws IOException, InterruptedException {
  super.setup(context);
  isFirstAttempt=taskId.endsWith(""String_Node_Str"");
  isRNA=HalvadeConf.getIsRNA(context.getConfiguration());
  scc=HalvadeConf.getSCC(context.getConfiguration(),isRNA);
  sec=HalvadeConf.getSEC(context.getConfiguration(),isRNA);
  try {
    gff=HalvadeFileUtils.downloadGFF(context,taskId);
  }
 catch (  URISyntaxException ex) {
    Logger.EXCEPTION(ex);
    throw new InterruptedException(""String_Node_Str"");
  }
  exomeBedFile=HalvadeConf.getBed(context.getConfiguration());
  useBedTools=HalvadeConf.getUseBedTools(context.getConfiguration());
  useUnifiedGenotyper=HalvadeConf.getUseUnifiedGenotyper(context.getConfiguration());
  redistribute=HalvadeConf.getRedistribute(context.getConfiguration());
  containers=HalvadeConf.getMapContainerCount(context.getConfiguration());
  tasksLeft=Integer.parseInt(context.getConfiguration().get(""String_Node_Str"")) - taskNr;
  if (redistribute && tasksLeft < containers) {
    threads=6;
  }
}"
13769,"protected String downloadGFF(TaskInputOutputContext context,String id){
}","public static String downloadGFF(TaskInputOutputContext context,String id) throws IOException, URISyntaxException {
  Configuration conf=context.getConfiguration();
  String refDir=HalvadeConf.getRefDirOnScratch(conf);
  if (!refDir.endsWith(""String_Node_Str""))   refDir=refDir + ""String_Node_Str"";
  HalvadeFileLock lock=new HalvadeFileLock(context,refDir,GFF_LOCK);
  String gffFile=null;
  String gffSuffix=null;
  try {
    lock.getLock();
    ByteBuffer bytes=ByteBuffer.allocate(4);
    if (lock.read(bytes) > 0) {
      bytes.flip();
      long val=bytes.getInt();
      if (val == DEFAULT_LOCK_VAL)       Logger.DEBUG(""String_Node_Str"" + val);
 else {
        Logger.INFO(""String_Node_Str"");
        String gff=HalvadeConf.getGff(context.getConfiguration());
        FileSystem fs=FileSystem.get(new URI(gff),conf);
        int si=gff.lastIndexOf('.');
        if (si > 0)         gffSuffix=gff.substring(si);
 else         throw new InterruptedException(""String_Node_Str"" + gff);
        gffFile=findFile(refDir,gffSuffix,false);
        if (gffFile == null)         gffFile=refDir + id;
        attemptDownloadFileFromHDFS(context,fs,gff,gffFile + gffSuffix,RETRIES);
        Logger.INFO(""String_Node_Str"");
        bytes.clear();
        bytes.putInt(DEFAULT_LOCK_VAL).flip();
        lock.forceWrite(bytes);
      }
    }
 else {
      Logger.INFO(""String_Node_Str"");
      String gff=HalvadeConf.getGff(context.getConfiguration());
      FileSystem fs=FileSystem.get(new URI(gff),conf);
      int si=gff.lastIndexOf('.');
      if (si > 0)       gffSuffix=gff.substring(si);
 else       throw new InterruptedException(""String_Node_Str"" + gff);
      gffFile=findFile(refDir,gffSuffix,false);
      if (gffFile == null)       gffFile=refDir + id;
      attemptDownloadFileFromHDFS(context,fs,gff,gffFile + gffSuffix,RETRIES);
      Logger.INFO(""String_Node_Str"");
      bytes.clear();
      bytes.putInt(DEFAULT_LOCK_VAL).flip();
      lock.forceWrite(bytes);
    }
  }
 catch (  InterruptedException ex) {
    Logger.EXCEPTION(ex);
  }
 finally {
    lock.releaseLock();
  }
  if (gffFile == null)   gffFile=findFile(refDir,""String_Node_Str"",false);
  return gffFile + ""String_Node_Str"";
}"
13770,"protected void PicardPreprocess(Context context,PreprocessingTools tools,SAMRecordIterator input,String output) throws InterruptedException, QualityException, IOException, URISyntaxException {
  outHeader=header.clone();
  outHeader.setSortOrder(SAMFileHeader.SortOrder.coordinate);
  String tmpOut1=tmpFileBase + ""String_Node_Str"";
  String tmpOut2=tmpFileBase + ""String_Node_Str"";
  String tmpOut3=tmpFileBase + ""String_Node_Str"";
  String fCounts=tmpFileBase + ""String_Node_Str"";
  String tmpMetrics=tmpFileBase + ""String_Node_Str"";
  SAMFileWriterFactory factory=new SAMFileWriterFactory();
  if (!inputIsBam)   outHeader.addReadGroup(bamrg);
  SAMFileWriter writer=factory.makeBAMWriter(outHeader,true,new File(tmpOut1));
  long startTime=System.currentTimeMillis();
  int count=0;
  SAMRecord sam;
  while (input.hasNext()) {
    sam=input.next();
    writer.addAlignment(sam);
    count++;
  }
  int reads=input.getCount();
  writer.close();
  context.getCounter(HalvadeCounters.IN_PREP_READS).increment(reads);
  long estimatedTime=System.currentTimeMillis() - startTime;
  context.getCounter(HalvadeCounters.TIME_HADOOP_SAMTOBAM).increment(estimatedTime);
  Logger.DEBUG(""String_Node_Str"" + count + ""String_Node_Str""+ estimatedTime / 1000);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runCleanSam(tmpOut1,tmpOut2);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runMarkDuplicates(tmpOut2,tmpOut3,tmpMetrics);
  if (gff != null) {
    Logger.DEBUG(""String_Node_Str"");
    context.setStatus(""String_Node_Str"");
    tools.runFeatureCounts(gff,tmpOut3,fCounts);
    HalvadeFileUtils.uploadFileToHDFS(context,FileSystem.get(new URI(outputdir),context.getConfiguration()),fCounts,outputdir + context.getTaskAttemptID().toString() + ""String_Node_Str"");
    HalvadeFileUtils.uploadFileToHDFS(context,null,ref,tmp);
  }
  if (!inputIsBam) {
    Logger.DEBUG(""String_Node_Str"");
    context.setStatus(""String_Node_Str"");
    tools.runAddOrReplaceReadGroups(tmpOut3,output,RGID,RGLB,RGPL,RGPU,RGSM);
  }
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runBuildBamIndex(output);
  estimatedTime=System.currentTimeMillis() - startTime;
  Logger.DEBUG(""String_Node_Str"" + estimatedTime / 1000);
  HalvadeFileUtils.removeLocalFile(keep,tmpMetrics,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut1,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut2,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut3,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,fCounts);
}","protected void PicardPreprocess(Context context,PreprocessingTools tools,SAMRecordIterator input,String output) throws InterruptedException, QualityException, IOException, URISyntaxException {
  outHeader=header.clone();
  outHeader.setSortOrder(SAMFileHeader.SortOrder.coordinate);
  String tmpOut1=tmpFileBase + ""String_Node_Str"";
  String tmpOut2=tmpFileBase + ""String_Node_Str"";
  String tmpOut3=tmpFileBase + ""String_Node_Str"";
  String fCounts=tmpFileBase + ""String_Node_Str"";
  String tmpMetrics=tmpFileBase + ""String_Node_Str"";
  SAMFileWriterFactory factory=new SAMFileWriterFactory();
  if (!inputIsBam)   outHeader.addReadGroup(bamrg);
  SAMFileWriter writer=factory.makeBAMWriter(outHeader,true,new File(tmpOut1));
  long startTime=System.currentTimeMillis();
  int count=0;
  SAMRecord sam;
  while (input.hasNext()) {
    sam=input.next();
    writer.addAlignment(sam);
    count++;
  }
  int reads=input.getCount();
  writer.close();
  context.getCounter(HalvadeCounters.IN_PREP_READS).increment(reads);
  long estimatedTime=System.currentTimeMillis() - startTime;
  context.getCounter(HalvadeCounters.TIME_HADOOP_SAMTOBAM).increment(estimatedTime);
  Logger.DEBUG(""String_Node_Str"" + count + ""String_Node_Str""+ estimatedTime / 1000);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runCleanSam(tmpOut1,tmpOut2);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runMarkDuplicates(tmpOut2,tmpOut3,tmpMetrics);
  if (gff != null) {
    Logger.DEBUG(""String_Node_Str"");
    context.setStatus(""String_Node_Str"");
    tools.runFeatureCounts(gff,tmpOut3,fCounts,threads);
    HalvadeFileUtils.uploadFileToHDFS(context,FileSystem.get(new URI(outputdir),context.getConfiguration()),fCounts,outputdir + context.getTaskAttemptID().toString() + ""String_Node_Str"");
    HalvadeFileUtils.uploadFileToHDFS(context,null,ref,tmp);
  }
  if (!inputIsBam) {
    Logger.DEBUG(""String_Node_Str"");
    context.setStatus(""String_Node_Str"");
    tools.runAddOrReplaceReadGroups(tmpOut3,output,RGID,RGLB,RGPL,RGPU,RGSM);
  }
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  tools.runBuildBamIndex(output);
  estimatedTime=System.currentTimeMillis() - startTime;
  Logger.DEBUG(""String_Node_Str"" + estimatedTime / 1000);
  HalvadeFileUtils.removeLocalFile(keep,tmpMetrics,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut1,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut2,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,tmpOut3,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,fCounts);
}"
13771,"protected void elPrepPreprocess(Context context,PreprocessingTools tools,SAMRecordIterator input,String output) throws InterruptedException, IOException, QualityException, URISyntaxException {
  String dictF=ref.substring(0,ref.lastIndexOf('.')) + ""String_Node_Str"";
  String rg=createReadGroupRecordString(RGID,RGLB,RGPL,RGPU,RGSM);
  String preSamOut=tmpFileBase + ""String_Node_Str"";
  String samOut=tmpFileBase + ""String_Node_Str"";
  String fCounts=tmpFileBase + ""String_Node_Str"";
  outHeader=header.clone();
  outHeader.setSortOrder(SAMFileHeader.SortOrder.coordinate);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  int reads;
  if (keep)   reads=tools.callElPrep(preSamOut,samOut,inputIsBam ? null : rg,threads,input,outHeader,dictF);
 else   reads=tools.streamElPrep(context,samOut,inputIsBam ? null : rg,threads,input,outHeader,dictF);
  Logger.DEBUG(reads + ""String_Node_Str"");
  context.getCounter(HalvadeCounters.IN_PREP_READS).increment(reads);
  if (gff != null) {
    Logger.DEBUG(""String_Node_Str"");
    context.setStatus(""String_Node_Str"");
    tools.runFeatureCounts(gff,samOut,fCounts);
    HalvadeFileUtils.uploadFileToHDFS(context,FileSystem.get(new URI(outputdir),context.getConfiguration()),fCounts,outputdir + context.getTaskAttemptID().toString() + ""String_Node_Str"");
  }
  context.setStatus(""String_Node_Str"");
  Logger.DEBUG(""String_Node_Str"");
  tools.callSAMToBAM(samOut,output,threads);
  context.setStatus(""String_Node_Str"");
  Logger.DEBUG(""String_Node_Str"");
  tools.runBuildBamIndex(output);
  HalvadeFileUtils.removeLocalFile(keep,preSamOut,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,samOut,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,fCounts);
}","protected void elPrepPreprocess(Context context,PreprocessingTools tools,SAMRecordIterator input,String output) throws InterruptedException, IOException, QualityException, URISyntaxException {
  String dictF=ref.substring(0,ref.lastIndexOf('.')) + ""String_Node_Str"";
  String rg=createReadGroupRecordString(RGID,RGLB,RGPL,RGPU,RGSM);
  String preSamOut=tmpFileBase + ""String_Node_Str"";
  String samOut=tmpFileBase + ""String_Node_Str"";
  String fCounts=tmpFileBase + ""String_Node_Str"";
  outHeader=header.clone();
  outHeader.setSortOrder(SAMFileHeader.SortOrder.coordinate);
  Logger.DEBUG(""String_Node_Str"");
  context.setStatus(""String_Node_Str"");
  int reads;
  if (keep)   reads=tools.callElPrep(preSamOut,samOut,inputIsBam ? null : rg,threads,input,outHeader,dictF);
 else   reads=tools.streamElPrep(context,samOut,inputIsBam ? null : rg,threads,input,outHeader,dictF);
  Logger.DEBUG(reads + ""String_Node_Str"");
  context.getCounter(HalvadeCounters.IN_PREP_READS).increment(reads);
  if (gff != null) {
    Logger.DEBUG(""String_Node_Str"");
    context.setStatus(""String_Node_Str"");
    tools.runFeatureCounts(gff,samOut,fCounts,threads);
    HalvadeFileUtils.uploadFileToHDFS(context,FileSystem.get(new URI(outputdir),context.getConfiguration()),fCounts,outputdir + context.getTaskAttemptID().toString() + ""String_Node_Str"");
  }
  context.setStatus(""String_Node_Str"");
  Logger.DEBUG(""String_Node_Str"");
  tools.callSAMToBAM(samOut,output,threads);
  context.setStatus(""String_Node_Str"");
  Logger.DEBUG(""String_Node_Str"");
  tools.runBuildBamIndex(output);
  HalvadeFileUtils.removeLocalFile(keep,preSamOut,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,samOut,context,HalvadeCounters.FOUT_GATK_TMP);
  HalvadeFileUtils.removeLocalFile(keep,fCounts);
}"
13772,"public void runFeatureCounts(String gff,String bam,String count) throws InterruptedException, IOException {
  long startTime=System.currentTimeMillis();
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  String[] command=CommandGenerator.featureCounts(bin,gff,bam,count,customArgs);
  long estimatedTime=runProcessAndWait(""String_Node_Str"",GetStringVector(command));
  if (context != null)   context.getCounter(HalvadeCounters.TIME_FEATURECOUNTS).increment(estimatedTime);
}","public void runFeatureCounts(String gff,String bam,String count,int threads) throws InterruptedException, IOException {
  String customArgs=HalvadeConf.getCustomArgs(context.getConfiguration(),""String_Node_Str"",""String_Node_Str"");
  String[] command=CommandGenerator.featureCounts(bin,gff,bam,count,threads,customArgs);
  long estimatedTime=runProcessAndWait(""String_Node_Str"",command);
  if (context != null)   context.getCounter(HalvadeCounters.TIME_FEATURECOUNTS).increment(estimatedTime);
}"
13773,"private void getBestDistribution(Configuration conf){
  if (mapsPerContainer == -1)   mapsPerContainer=Math.min(Math.max(vcores / VCORES_MAP_TASK,1),Math.max(mem / MEM_MAP_TASK,1));
  if (reducersPerContainer == -1)   reducersPerContainer=Math.min(Math.max(vcores / VCORES_REDUCE_TASK,1),Math.max(mem / MEM_REDUCE_TASK,1));
  mappers=Math.max(1,nodes * mapsPerContainer);
  mthreads=Math.max(1,vcores / mapsPerContainer);
  GATKCPUThreads=Math.max(1,vcores / reducersPerContainer);
  GATKdataThreads=Math.max(1,vcores / reducersPerContainer);
  int mmem=Math.min(mem * 1024,mem * 1024 / mapsPerContainer);
  int rmem=Math.min(mem * 1024,((SWAP_EXTRA + mem) * 1024 / reducersPerContainer));
  be.ugent.intec.halvade.utils.Logger.DEBUG(""String_Node_Str"" + mapsPerContainer + ""String_Node_Str""+ mthreads+ ""String_Node_Str""+ mmem+ ""String_Node_Str""+ reducersPerContainer+ ""String_Node_Str""+ GATKCPUThreads+ ""String_Node_Str""+ rmem+ ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + mthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + mmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + GATKCPUThreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + rmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + 1.0);
  reducers=(int)(coverage * REDUCE_TASKS_FACTOR * nodes* reducersPerContainer);
}","private void getBestDistribution(Configuration conf){
  if (mapsPerContainer == -1)   mapsPerContainer=Math.min(Math.max(vcores / VCORES_MAP_TASK,1),Math.max(mem / MEM_MAP_TASK,1));
  if (reducersPerContainer == -1)   reducersPerContainer=Math.min(Math.max(vcores / VCORES_REDUCE_TASK,1),Math.max(mem / MEM_REDUCE_TASK,1));
  mappers=Math.max(1,nodes * mapsPerContainer);
  mthreads=Math.max(1,vcores / mapsPerContainer);
  GATKCPUThreads=Math.max(1,vcores / reducersPerContainer);
  GATKdataThreads=Math.max(1,vcores / reducersPerContainer);
  int mmem=Math.min(mem * 1024,mem * 1024 / mapsPerContainer);
  int rmem=Math.min(mem * 1024,((SWAP_EXTRA + mem) * 1024 / reducersPerContainer));
  be.ugent.intec.halvade.utils.Logger.DEBUG(""String_Node_Str"" + mapsPerContainer + ""String_Node_Str""+ mthreads+ ""String_Node_Str""+ mmem+ ""String_Node_Str""+ reducersPerContainer+ ""String_Node_Str""+ GATKCPUThreads+ ""String_Node_Str""+ rmem+ ""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"" + mthreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + mmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + GATKCPUThreads);
  conf.set(""String_Node_Str"",""String_Node_Str"" + rmem);
  conf.set(""String_Node_Str"",""String_Node_Str"" + 1.0);
  reducers=(int)(coverage * REDUCE_TASKS_FACTOR);
}"
13774,"public int GetOptions(String[] args,Configuration halvadeConf) throws IOException, URISyntaxException {
  try {
    parseArguments(args);
    localRef=tmpDir + ""String_Node_Str"";
    getBestDistribution(halvadeConf);
    MyConf.setTasksPerNode(halvadeConf,reducersPerContainer);
    MyConf.setScratchTempDir(halvadeConf,tmpDir);
    MyConf.setRefOnHDFS(halvadeConf,ref);
    MyConf.setRefOnScratch(halvadeConf,localRef);
    MyConf.setKnownSitesOnHDFS(halvadeConf,hdfsSites);
    MyConf.setNumThreads(halvadeConf,mthreads);
    MyConf.setGATKNumDataThreads(halvadeConf,GATKdataThreads);
    MyConf.setGATKNumCPUThreads(halvadeConf,GATKCPUThreads);
    MyConf.setNumNodes(halvadeConf,mappers);
    MyConf.setIsPaired(halvadeConf,paired);
    if (exomeBedFile != null)     MyConf.setExomeBed(halvadeConf,exomeBedFile);
    MyConf.setFastqEncoding(halvadeConf,FASTQ_ENCODING[0]);
    MyConf.setOutDir(halvadeConf,out);
    MyConf.setKeepFiles(halvadeConf,keepFiles);
    MyConf.setUseBedTools(halvadeConf,useBedTools);
    MyConf.clearTaskFiles(halvadeConf);
    MyConf.setUseIPrep(halvadeConf,useIPrep);
    MyConf.setUseUnifiedGenotyper(halvadeConf,useGenotyper);
    MyConf.setReuseJVM(halvadeConf,reuseJVM);
    MyConf.setReadGroup(halvadeConf,""String_Node_Str"" + RGID + ""String_Node_Str""+ RGLB+ ""String_Node_Str""+ RGPL+ ""String_Node_Str""+ RGPU+ ""String_Node_Str""+ RGSM);
    MyConf.setkeepChrSplitPairs(halvadeConf,keepChrSplitPairs);
    if (ca_bwa_aln != null)     MyConf.setBwaAlnArgs(halvadeConf,ca_bwa_aln);
    if (ca_bwa_mem != null)     MyConf.setBwaMemArgs(halvadeConf,ca_bwa_mem);
    if (ca_bwa_samxe != null)     MyConf.setBwaSamxeArgs(halvadeConf,ca_bwa_samxe);
    if (ca_elprep != null)     MyConf.setElPrepArgs(halvadeConf,ca_elprep);
    if (ca_samtools_view != null)     MyConf.setSamtoolsViewArgs(halvadeConf,ca_samtools_view);
    if (ca_bedtools_dbsnp != null)     MyConf.setBedToolsDbSnpArgs(halvadeConf,ca_bedtools_dbsnp);
    if (ca_bedtools_exome != null)     MyConf.setBedToolsExomeArgs(halvadeConf,ca_bedtools_exome);
    if (ca_picard_bai != null)     MyConf.setPicardBaiArgs(halvadeConf,ca_picard_bai);
    if (ca_picard_rg != null)     MyConf.setPicardAddReadGroupArgs(halvadeConf,ca_picard_rg);
    if (ca_picard_dedup != null)     MyConf.setPicardMarkDupArgs(halvadeConf,ca_picard_dedup);
    if (ca_picard_clean != null)     MyConf.setPicardCleanSamArgs(halvadeConf,ca_picard_clean);
    if (ca_gatk_rtc != null)     MyConf.setGatkRealignerTargetCreatorArgs(halvadeConf,ca_gatk_rtc);
    if (ca_gatk_ir != null)     MyConf.setGatkIndelRealignerArgs(halvadeConf,ca_gatk_ir);
    if (ca_gatk_br != null)     MyConf.setGatkBaseRecalibratorArgs(halvadeConf,ca_gatk_br);
    if (ca_gatk_pr != null)     MyConf.setGatkPrintReadsArgs(halvadeConf,ca_gatk_pr);
    if (ca_gatk_cv != null)     MyConf.setGatkCombineVariantsArgs(halvadeConf,ca_gatk_cv);
    if (ca_gatk_vc != null)     MyConf.setGatkVariantCallerArgs(halvadeConf,ca_gatk_vc);
    if (chr != null)     MyConf.setChrList(halvadeConf,chr);
    if (java != null)     MyConf.setJava(halvadeConf,java);
    if (stand_call_conf > 0)     MyConf.setSCC(halvadeConf,stand_call_conf);
    if (stand_emit_conf > 0)     MyConf.setSEC(halvadeConf,stand_emit_conf);
    FileSystem fs=FileSystem.get(new URI(out),halvadeConf);
    if (fs.exists(new Path(out)) && !justCombine) {
      Logger.INFO(""String_Node_Str"" + out + ""String_Node_Str"");
      Logger.INFO(""String_Node_Str"");
      fs.delete(new Path(out),true);
    }
    parseANNFile(halvadeConf);
    setKeysPerChromosome();
    MyConf.setMinChrLength(halvadeConf,minChrLength);
    MyConf.setMultiplier(halvadeConf,multiplier);
    getNumberOfRegions(halvadeConf);
    if (!halvadeDir.endsWith(""String_Node_Str""))     halvadeDir+=""String_Node_Str"";
  }
 catch (  ParseException e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    HelpFormatter formatter=new HelpFormatter();
    formatter.setWidth(80);
    formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
    return 1;
  }
  return 0;
}","public int GetOptions(String[] args,Configuration halvadeConf) throws IOException, URISyntaxException {
  try {
    parseArguments(args);
    localRefDir=tmpDir;
    getBestDistribution(halvadeConf);
    HalvadeConf.setTasksPerNode(halvadeConf,reducersPerContainer);
    HalvadeConf.setScratchTempDir(halvadeConf,tmpDir);
    HalvadeConf.setRefOnHDFS(halvadeConf,ref);
    HalvadeConf.setStarDirOnHDFS(halvadeConf,STARGenome);
    HalvadeConf.setRefDirOnScratch(halvadeConf,localRefDir);
    HalvadeConf.setKnownSitesOnHDFS(halvadeConf,hdfsSites);
    HalvadeConf.setNumThreads(halvadeConf,mthreads);
    HalvadeConf.setGATKNumDataThreads(halvadeConf,GATKdataThreads);
    HalvadeConf.setGATKNumCPUThreads(halvadeConf,GATKCPUThreads);
    HalvadeConf.setNumNodes(halvadeConf,mappers);
    HalvadeConf.setIsPaired(halvadeConf,paired);
    if (exomeBedFile != null)     HalvadeConf.setExomeBed(halvadeConf,exomeBedFile);
    HalvadeConf.setOutDir(halvadeConf,out);
    HalvadeConf.setKeepFiles(halvadeConf,keepFiles);
    HalvadeConf.setUseBedTools(halvadeConf,useBedTools);
    HalvadeConf.clearTaskFiles(halvadeConf);
    HalvadeConf.setUseIPrep(halvadeConf,useIPrep);
    HalvadeConf.setUseUnifiedGenotyper(halvadeConf,useGenotyper);
    HalvadeConf.setReuseJVM(halvadeConf,reuseJVM);
    HalvadeConf.setReadGroup(halvadeConf,""String_Node_Str"" + RGID + ""String_Node_Str""+ RGLB+ ""String_Node_Str""+ RGPL+ ""String_Node_Str""+ RGPU+ ""String_Node_Str""+ RGSM);
    HalvadeConf.setkeepChrSplitPairs(halvadeConf,keepChrSplitPairs);
    if (ca_bwa_aln != null)     HalvadeConf.setBwaAlnArgs(halvadeConf,ca_bwa_aln);
    if (ca_bwa_mem != null)     HalvadeConf.setBwaMemArgs(halvadeConf,ca_bwa_mem);
    if (ca_bwa_samxe != null)     HalvadeConf.setBwaSamxeArgs(halvadeConf,ca_bwa_samxe);
    if (ca_elprep != null)     HalvadeConf.setElPrepArgs(halvadeConf,ca_elprep);
    if (ca_samtools_view != null)     HalvadeConf.setSamtoolsViewArgs(halvadeConf,ca_samtools_view);
    if (ca_bedtools_dbsnp != null)     HalvadeConf.setBedToolsDbSnpArgs(halvadeConf,ca_bedtools_dbsnp);
    if (ca_bedtools_exome != null)     HalvadeConf.setBedToolsExomeArgs(halvadeConf,ca_bedtools_exome);
    if (ca_picard_bai != null)     HalvadeConf.setPicardBaiArgs(halvadeConf,ca_picard_bai);
    if (ca_picard_rg != null)     HalvadeConf.setPicardAddReadGroupArgs(halvadeConf,ca_picard_rg);
    if (ca_picard_dedup != null)     HalvadeConf.setPicardMarkDupArgs(halvadeConf,ca_picard_dedup);
    if (ca_picard_clean != null)     HalvadeConf.setPicardCleanSamArgs(halvadeConf,ca_picard_clean);
    if (ca_gatk_rtc != null)     HalvadeConf.setGatkRealignerTargetCreatorArgs(halvadeConf,ca_gatk_rtc);
    if (ca_gatk_ir != null)     HalvadeConf.setGatkIndelRealignerArgs(halvadeConf,ca_gatk_ir);
    if (ca_gatk_br != null)     HalvadeConf.setGatkBaseRecalibratorArgs(halvadeConf,ca_gatk_br);
    if (ca_gatk_pr != null)     HalvadeConf.setGatkPrintReadsArgs(halvadeConf,ca_gatk_pr);
    if (ca_gatk_cv != null)     HalvadeConf.setGatkCombineVariantsArgs(halvadeConf,ca_gatk_cv);
    if (ca_gatk_vc != null)     HalvadeConf.setGatkVariantCallerArgs(halvadeConf,ca_gatk_vc);
    if (chr != null)     HalvadeConf.setChrList(halvadeConf,chr);
    if (java != null)     HalvadeConf.setJava(halvadeConf,java);
    if (stand_call_conf > 0)     HalvadeConf.setSCC(halvadeConf,stand_call_conf);
    if (stand_emit_conf > 0)     HalvadeConf.setSEC(halvadeConf,stand_emit_conf);
    FileSystem fs=FileSystem.get(new URI(out),halvadeConf);
    if (fs.exists(new Path(out)) && !justCombine) {
      Logger.INFO(""String_Node_Str"" + out + ""String_Node_Str"");
      Logger.INFO(""String_Node_Str"");
      fs.delete(new Path(out),true);
    }
    parseDictFile(halvadeConf);
    ChromosomeSplitter splitter=new ChromosomeSplitter(dict,chr,reducers);
    HalvadeConf.setMinChrLength(halvadeConf,splitter.getRegionSize());
    reducers=splitter.getRegionCount();
    HalvadeConf.setReducers(halvadeConf,reducers);
  }
 catch (  ParseException e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    HelpFormatter formatter=new HelpFormatter();
    formatter.setWidth(80);
    formatter.printHelp(""String_Node_Str"" + ""String_Node_Str"",options);
    return 1;
  }
  return 0;
}"
13775,"protected void parseArguments(String[] args) throws ParseException {
  createOptions();
  CommandLineParser parser=new GnuParser();
  CommandLine line=parser.parse(options,args);
  in=line.getOptionValue(""String_Node_Str"");
  out=line.getOptionValue(""String_Node_Str"");
  ref=line.getOptionValue(""String_Node_Str"");
  sites=line.getOptionValue(""String_Node_Str"");
  hdfsSites=sites.split(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   tmpDir=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   nodes=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   vcores=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   mem=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   mapsPerContainer=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   reducersPerContainer=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str"")) {
    halvadeDir=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str""))   stand_call_conf=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   stand_emit_conf=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   reportAll=true;
  if (line.hasOption(""String_Node_Str""))   keepFiles=true;
  if (line.hasOption(""String_Node_Str""))   paired=false;
  if (line.hasOption(""String_Node_Str""))   justAlign=true;
  if (line.hasOption(""String_Node_Str""))   reuseJVM=true;
  if (line.hasOption(""String_Node_Str""))   aln=false;
  if (line.hasOption(""String_Node_Str""))   regionSize=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   java=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   manifest=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   justPut=true;
  if (line.hasOption(""String_Node_Str"")) {
    exomeBedFile=line.getOptionValue(""String_Node_Str"");
    coverage=EXOME_COV;
  }
  if (line.hasOption(""String_Node_Str""))   dryRun=true;
  if (line.hasOption(""String_Node_Str""))   keepChrSplitPairs=false;
  if (line.hasOption(""String_Node_Str""))   coverage=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   justCombine=true;
  if (line.hasOption(""String_Node_Str""))   useBedTools=true;
  if (line.hasOption(""String_Node_Str""))   useGenotyper=false;
  if (line.hasOption(""String_Node_Str""))   useIPrep=false;
  if (line.hasOption(""String_Node_Str""))   RGID=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGLB=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGPL=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGPU=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGSM=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   chr=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_bwa_aln=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_bwa_mem=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_bwa_samxe=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_elprep=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_samtools_view=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_bedtools_dbsnp=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_bedtools_exome=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_picard_bai=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_picard_rg=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_picard_dedup=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_picard_clean=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_gatk_rtc=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_gatk_ir=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_gatk_br=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_gatk_pr=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_gatk_cv=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_gatk_vc=line.getOptionValue(""String_Node_Str"");
}","protected void parseArguments(String[] args) throws ParseException {
  createOptions();
  CommandLineParser parser=new GnuParser();
  CommandLine line=parser.parse(options,args);
  in=line.getOptionValue(""String_Node_Str"");
  out=line.getOptionValue(""String_Node_Str"");
  ref=line.getOptionValue(""String_Node_Str"");
  STARGenome=line.getOptionValue(""String_Node_Str"");
  sites=line.getOptionValue(""String_Node_Str"");
  hdfsSites=sites.split(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   tmpDir=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   nodes=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   vcores=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   vcores*=2;
  if (line.hasOption(""String_Node_Str""))   rnaPipeline=true;
  if (line.hasOption(""String_Node_Str""))   mem=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   mapsPerContainer=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   reducersPerContainer=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str"")) {
    halvadeBinaries=line.getOptionValue(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str""))   stand_call_conf=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   stand_emit_conf=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   reportAll=true;
  if (line.hasOption(""String_Node_Str""))   keepFiles=true;
  if (line.hasOption(""String_Node_Str""))   paired=false;
  if (line.hasOption(""String_Node_Str""))   justAlign=true;
  if (line.hasOption(""String_Node_Str""))   reuseJVM=true;
  if (line.hasOption(""String_Node_Str""))   aln=false;
  if (line.hasOption(""String_Node_Str""))   java=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   manifest=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str"")) {
    exomeBedFile=line.getOptionValue(""String_Node_Str"");
    coverage=EXOME_COV;
  }
  if (line.hasOption(""String_Node_Str""))   dryRun=true;
  if (line.hasOption(""String_Node_Str""))   keepChrSplitPairs=false;
  if (line.hasOption(""String_Node_Str""))   coverage=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  if (line.hasOption(""String_Node_Str""))   justCombine=true;
  if (line.hasOption(""String_Node_Str""))   useBedTools=true;
  if (line.hasOption(""String_Node_Str""))   useGenotyper=false;
  if (line.hasOption(""String_Node_Str""))   useIPrep=false;
  if (line.hasOption(""String_Node_Str""))   RGID=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGLB=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGPL=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGPU=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   RGSM=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   chr=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_bwa_aln=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_bwa_mem=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_bwa_samxe=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_elprep=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_samtools_view=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_bedtools_dbsnp=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_bedtools_exome=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_picard_bai=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_picard_rg=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_picard_dedup=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_picard_clean=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_gatk_rtc=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_gatk_ir=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_gatk_br=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_gatk_pr=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_gatk_cv=line.getOptionValue(""String_Node_Str"");
  if (line.hasOption(""String_Node_Str""))   ca_gatk_vc=line.getOptionValue(""String_Node_Str"");
}"
13776,"protected void createOptions(){
  Option optIn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optOut=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBin=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRef=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSites=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optTmp=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSingle=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBmem=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMan=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJava=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPut=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCombine=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optID=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optLB=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPL=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPU=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSM=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPp=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBed=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJVM=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJustAlign=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optKeep=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optHap=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCov=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optScc=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSec=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optChr=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"" + ""String_Node_Str"").create(""String_Node_Str"");
  Option optEx=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optNodes=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optVcores=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMem=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMpn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRpn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCABwaAln=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCABwaMem=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCABwaSampe=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAElprep=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCASamtools=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCABedtoolsDb=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCABedtoolsEx=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAPicardBai=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAPicardRg=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAPicardDedup=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAPicardClean=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAGatkRtc=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAGatkIr=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAGatkBr=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAGatkPr=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAGatkCv=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAGatkVc=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optDry=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optDrop=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optStartupJob=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optReportAll=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  options.addOption(optIn);
  options.addOption(optOut);
  options.addOption(optRef);
  options.addOption(optSites);
  options.addOption(optBin);
  options.addOption(optTmp);
  options.addOption(optSingle);
  options.addOption(optBmem);
  options.addOption(optMan);
  options.addOption(optPut);
  options.addOption(optID);
  options.addOption(optLB);
  options.addOption(optPL);
  options.addOption(optPU);
  options.addOption(optSM);
  options.addOption(optPp);
  options.addOption(optBed);
  options.addOption(optHap);
  options.addOption(optScc);
  options.addOption(optSec);
  options.addOption(optChr);
  options.addOption(optJVM);
  options.addOption(optJava);
  options.addOption(optCombine);
  options.addOption(optNodes);
  options.addOption(optVcores);
  options.addOption(optMem);
  options.addOption(optKeep);
  options.addOption(optJustAlign);
  options.addOption(optCov);
  options.addOption(optEx);
  options.addOption(optMpn);
  options.addOption(optRpn);
  options.addOption(optDry);
  options.addOption(optDrop);
  options.addOption(optReportAll);
  options.addOption(optCABwaAln);
  options.addOption(optCABwaMem);
  options.addOption(optCABwaSampe);
  options.addOption(optCAElprep);
  options.addOption(optCASamtools);
  options.addOption(optCABedtoolsDb);
  options.addOption(optCABedtoolsEx);
  options.addOption(optCAPicardBai);
  options.addOption(optCAPicardRg);
  options.addOption(optCAPicardDedup);
  options.addOption(optCAPicardClean);
  options.addOption(optCAGatkRtc);
  options.addOption(optCAGatkIr);
  options.addOption(optCAGatkBr);
  options.addOption(optCAGatkPr);
  options.addOption(optCAGatkCv);
  options.addOption(optCAGatkVc);
}","protected void createOptions(){
  Option optIn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optOut=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBin=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRef=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optStarGenome=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSites=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optTmp=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSingle=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBmem=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMan=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJava=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCombine=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optID=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optLB=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPL=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPU=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSM=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optPp=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optBed=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJVM=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optJustAlign=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSmt=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optKeep=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optHap=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRna=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCov=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optScc=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optSec=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optChr=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"" + ""String_Node_Str"").create(""String_Node_Str"");
  Option optEx=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optNodes=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optVcores=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMem=OptionBuilder.withArgName(""String_Node_Str"").hasArg().isRequired(true).withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optMpn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optRpn=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCABwaAln=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCABwaMem=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCABwaSampe=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAElprep=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCASamtools=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCABedtoolsDb=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCABedtoolsEx=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAPicardBai=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAPicardRg=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAPicardDedup=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAPicardClean=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAGatkRtc=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAGatkIr=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAGatkBr=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAGatkPr=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAGatkCv=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optCAGatkVc=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optDry=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optDrop=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optStartupJob=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Option optReportAll=OptionBuilder.withArgName(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str"");
  options.addOption(optIn);
  options.addOption(optOut);
  options.addOption(optRef);
  options.addOption(optSites);
  options.addOption(optBin);
  options.addOption(optTmp);
  options.addOption(optSingle);
  options.addOption(optBmem);
  options.addOption(optMan);
  options.addOption(optID);
  options.addOption(optLB);
  options.addOption(optPL);
  options.addOption(optPU);
  options.addOption(optSM);
  options.addOption(optPp);
  options.addOption(optBed);
  options.addOption(optHap);
  options.addOption(optScc);
  options.addOption(optSec);
  options.addOption(optChr);
  options.addOption(optJVM);
  options.addOption(optJava);
  options.addOption(optCombine);
  options.addOption(optNodes);
  options.addOption(optVcores);
  options.addOption(optMem);
  options.addOption(optKeep);
  options.addOption(optJustAlign);
  options.addOption(optCov);
  options.addOption(optEx);
  options.addOption(optMpn);
  options.addOption(optRpn);
  options.addOption(optDry);
  options.addOption(optDrop);
  options.addOption(optReportAll);
  options.addOption(optSmt);
  options.addOption(optRna);
  options.addOption(optStarGenome);
  options.addOption(optCABwaAln);
  options.addOption(optCABwaMem);
  options.addOption(optCABwaSampe);
  options.addOption(optCAElprep);
  options.addOption(optCASamtools);
  options.addOption(optCABedtoolsDb);
  options.addOption(optCABedtoolsEx);
  options.addOption(optCAPicardBai);
  options.addOption(optCAPicardRg);
  options.addOption(optCAPicardDedup);
  options.addOption(optCAPicardClean);
  options.addOption(optCAGatkRtc);
  options.addOption(optCAGatkIr);
  options.addOption(optCAGatkBr);
  options.addOption(optCAGatkPr);
  options.addOption(optCAGatkCv);
  options.addOption(optCAGatkVc);
}"
13777,"@Override public int run(String[] strings) throws Exception {
  int ret=1;
  try {
    Configuration halvadeConf=getConf();
    halvadeOpts=new HalvadeOptions();
    int optR=halvadeOpts.GetOptions(strings,halvadeConf);
    if (optR != 0)     return optR;
    if (halvadeOpts.justPut)     return 0;
    Job halvadeJob=new Job(halvadeConf,""String_Node_Str"");
    halvadeJob.addCacheArchive(new URI(halvadeOpts.halvadeDir + ""String_Node_Str""));
    halvadeJob.setJarByClass(be.ugent.intec.halvade.hadoop.mapreduce.BWAMemMapper.class);
    FileSystem fs=FileSystem.get(new URI(halvadeOpts.in),halvadeConf);
    try {
      if (fs.getFileStatus(new Path(halvadeOpts.in)).isDirectory()) {
        FileStatus[] files=fs.listStatus(new Path(halvadeOpts.in));
        for (        FileStatus file : files) {
          if (!file.isDirectory()) {
            FileInputFormat.addInputPath(halvadeJob,file.getPath());
          }
        }
      }
 else {
        FileInputFormat.addInputPath(halvadeJob,new Path(halvadeOpts.in));
      }
    }
 catch (    Exception e) {
      Logger.EXCEPTION(e);
    }
    FileOutputFormat.setOutputPath(halvadeJob,new Path(halvadeOpts.out));
    if (halvadeOpts.aln)     halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.BWAAlnMapper.class);
 else     halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.BWAMemMapper.class);
    halvadeJob.setMapOutputKeyClass(ChromosomeRegion.class);
    halvadeJob.setMapOutputValueClass(SAMRecordWritable.class);
    halvadeJob.setInputFormatClass(TextInputFormat.class);
    halvadeJob.setPartitionerClass(ChrRgPartitioner.class);
    halvadeJob.setSortComparatorClass(ChrRgPositionComparator.class);
    halvadeJob.setGroupingComparatorClass(ChrRgRegionComparator.class);
    if (halvadeOpts.justAlign)     halvadeJob.setNumReduceTasks(0);
 else     halvadeJob.setNumReduceTasks(halvadeOpts.reducers);
    halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.GATKReducer.class);
    halvadeJob.setOutputKeyClass(Text.class);
    halvadeJob.setOutputValueClass(VariantContextWritable.class);
    if (halvadeOpts.dryRun)     return 0;
    Timer timer=new Timer();
    timer.start();
    ret=halvadeJob.waitForCompletion(true) ? 0 : 1;
    timer.stop();
    Logger.DEBUG(""String_Node_Str"" + timer);
    if (halvadeOpts.combineVcf && ret == 0) {
      Logger.DEBUG(""String_Node_Str"");
      Configuration combineConf=getConf();
      if (!halvadeOpts.out.endsWith(""String_Node_Str""))       halvadeOpts.out+=""String_Node_Str"";
      MyConf.setInputDir(combineConf,halvadeOpts.out);
      MyConf.setOutDir(combineConf,halvadeOpts.out + ""String_Node_Str"");
      MyConf.setReportAllVariant(combineConf,halvadeOpts.reportAll);
      Job combineJob=new Job(combineConf,""String_Node_Str"");
      combineJob.setJarByClass(be.ugent.intec.halvade.hadoop.mapreduce.VCFCombineMapper.class);
      try {
        if (fs.getFileStatus(new Path(halvadeOpts.out)).isDirectory()) {
          FileStatus[] files=fs.listStatus(new Path(halvadeOpts.out));
          for (          FileStatus file : files) {
            if (!file.isDirectory() && file.getPath().getName().endsWith(""String_Node_Str"")) {
              FileInputFormat.addInputPath(combineJob,file.getPath());
            }
          }
        }
      }
 catch (      Exception e) {
        Logger.EXCEPTION(e);
      }
      FileOutputFormat.setOutputPath(combineJob,new Path(halvadeOpts.out + ""String_Node_Str""));
      combineJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.VCFCombineMapper.class);
      combineJob.setMapOutputKeyClass(LongWritable.class);
      combineJob.setMapOutputValueClass(VariantContextWritable.class);
      combineJob.setInputFormatClass(VCFInputFormat.class);
      combineJob.setNumReduceTasks(1);
      combineJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.VCFCombineReducer.class);
      combineJob.setOutputKeyClass(Text.class);
      combineJob.setOutputValueClass(VariantContextWritable.class);
      timer=new Timer();
      timer.start();
      ret=combineJob.waitForCompletion(true) ? 0 : 1;
      timer.stop();
      Logger.DEBUG(""String_Node_Str"" + timer);
    }
 else {
    }
  }
 catch (  Exception e) {
    Logger.EXCEPTION(e);
  }
  return ret;
}","@Override public int run(String[] strings) throws Exception {
  int ret=1;
  try {
    Configuration halvadeConf=getConf();
    halvadeOpts=new HalvadeOptions();
    int optR=halvadeOpts.GetOptions(strings,halvadeConf);
    if (optR != 0)     return optR;
    Job halvadeJob=Job.getInstance(halvadeConf,""String_Node_Str"");
    halvadeJob.addCacheArchive(new URI(halvadeOpts.halvadeBinaries));
    halvadeJob.setJarByClass(be.ugent.intec.halvade.hadoop.mapreduce.HalvadeMapper.class);
    FileSystem fs=FileSystem.get(new URI(halvadeOpts.in),halvadeConf);
    try {
      if (fs.getFileStatus(new Path(halvadeOpts.in)).isDirectory()) {
        FileStatus[] files=fs.listStatus(new Path(halvadeOpts.in));
        for (        FileStatus file : files) {
          if (!file.isDirectory()) {
            FileInputFormat.addInputPath(halvadeJob,file.getPath());
          }
        }
      }
 else {
        FileInputFormat.addInputPath(halvadeJob,new Path(halvadeOpts.in));
      }
    }
 catch (    Exception e) {
      Logger.EXCEPTION(e);
    }
    FileOutputFormat.setOutputPath(halvadeJob,new Path(halvadeOpts.out));
    if (halvadeOpts.rnaPipeline)     halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.StarAlignMapper.class);
 else {
      if (halvadeOpts.aln)       halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.BWAAlnMapper.class);
 else       halvadeJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.BWAMemMapper.class);
    }
    halvadeJob.setMapOutputKeyClass(ChromosomeRegion.class);
    halvadeJob.setMapOutputValueClass(SAMRecordWritable.class);
    halvadeJob.setInputFormatClass(TextInputFormat.class);
    halvadeJob.setPartitionerClass(ChrRgPartitioner.class);
    halvadeJob.setSortComparatorClass(ChrRgPositionComparator.class);
    halvadeJob.setGroupingComparatorClass(ChrRgRegionComparator.class);
    if (halvadeOpts.justAlign)     halvadeJob.setNumReduceTasks(0);
 else     halvadeJob.setNumReduceTasks(halvadeOpts.reducers);
    if (halvadeOpts.rnaPipeline)     halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.RnaGATKReducer.class);
 else     halvadeJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.DnaGATKReducer.class);
    halvadeJob.setOutputKeyClass(Text.class);
    halvadeJob.setOutputValueClass(VariantContextWritable.class);
    if (halvadeOpts.dryRun)     return 0;
    Timer timer=new Timer();
    timer.start();
    ret=halvadeJob.waitForCompletion(true) ? 0 : 1;
    timer.stop();
    Logger.DEBUG(""String_Node_Str"" + timer);
    if (halvadeOpts.combineVcf && ret == 0) {
      Logger.DEBUG(""String_Node_Str"");
      Configuration combineConf=getConf();
      if (!halvadeOpts.out.endsWith(""String_Node_Str""))       halvadeOpts.out+=""String_Node_Str"";
      HalvadeConf.setInputDir(combineConf,halvadeOpts.out);
      HalvadeConf.setOutDir(combineConf,halvadeOpts.out + ""String_Node_Str"");
      HalvadeConf.setReportAllVariant(combineConf,halvadeOpts.reportAll);
      Job combineJob=new Job(combineConf,""String_Node_Str"");
      combineJob.setJarByClass(be.ugent.intec.halvade.hadoop.mapreduce.VCFCombineMapper.class);
      try {
        if (fs.getFileStatus(new Path(halvadeOpts.out)).isDirectory()) {
          FileStatus[] files=fs.listStatus(new Path(halvadeOpts.out));
          for (          FileStatus file : files) {
            if (!file.isDirectory() && file.getPath().getName().endsWith(""String_Node_Str"")) {
              FileInputFormat.addInputPath(combineJob,file.getPath());
            }
          }
        }
      }
 catch (      Exception e) {
        Logger.EXCEPTION(e);
      }
      FileOutputFormat.setOutputPath(combineJob,new Path(halvadeOpts.out + ""String_Node_Str""));
      combineJob.setMapperClass(be.ugent.intec.halvade.hadoop.mapreduce.VCFCombineMapper.class);
      combineJob.setMapOutputKeyClass(LongWritable.class);
      combineJob.setMapOutputValueClass(VariantContextWritable.class);
      combineJob.setInputFormatClass(VCFInputFormat.class);
      combineJob.setNumReduceTasks(1);
      combineJob.setReducerClass(be.ugent.intec.halvade.hadoop.mapreduce.VCFCombineReducer.class);
      combineJob.setOutputKeyClass(Text.class);
      combineJob.setOutputValueClass(VariantContextWritable.class);
      timer=new Timer();
      timer.start();
      ret=combineJob.waitForCompletion(true) ? 0 : 1;
      timer.stop();
      Logger.DEBUG(""String_Node_Str"" + timer);
    }
 else {
    }
  }
 catch (  Exception e) {
    Logger.EXCEPTION(e);
  }
  return ret;
}"
13778,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  final SampleItem parent=new SampleItem(""String_Node_Str"",new SampleItem(""String_Node_Str"",new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.DEVICE)),new SampleItem(""String_Node_Str"",new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.STACK_LAYOUT),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.FLOW_LAYOUT),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.TAGS_VIEW),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.FLIPPER_VIEW),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.PROGRESS_VIEW),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.SCALE_VIEW)),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.CAMERA),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.DIALOG));
  if (getSupportFragmentManager().findFragmentByTag(TAG_LIST_FRAGMENT) == null) {
    final SampleListFragment fragment=SampleListFragment.newInstance(parent,false);
    getSupportFragmentManager().beginTransaction().replace(R.id.id_common_fragment,fragment,TAG_LIST_FRAGMENT).commit();
  }
  final View view=findViewById(R.id.id_common_fragment);
  view.postDelayed(new Runnable(){
    @Override public void run(){
      startActivityAsStack(createSampleIntent(SampleItem.SampleItemType.SCALE_VIEW));
    }
  }
,100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  final SampleItem parent=new SampleItem(""String_Node_Str"",new SampleItem(""String_Node_Str"",new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.DEVICE)),new SampleItem(""String_Node_Str"",new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.STACK_LAYOUT),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.FLOW_LAYOUT),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.TAGS_VIEW),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.FLIPPER_VIEW),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.PROGRESS_VIEW),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.SCALE_VIEW)),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.CAMERA),new SampleItem(""String_Node_Str"",SampleItem.SampleItemType.DIALOG));
  if (getSupportFragmentManager().findFragmentByTag(TAG_LIST_FRAGMENT) == null) {
    final SampleListFragment fragment=SampleListFragment.newInstance(parent,false);
    getSupportFragmentManager().beginTransaction().replace(R.id.id_common_fragment,fragment,TAG_LIST_FRAGMENT).commit();
  }
  final View view=findViewById(R.id.id_common_fragment);
  view.postDelayed(new Runnable(){
    @Override public void run(){
      startActivityAsStack(createSampleIntent(SampleItem.SampleItemType.FLOW_LAYOUT));
    }
  }
,100);
}"
13779,"@Override public void run(){
  startActivityAsStack(createSampleIntent(SampleItem.SampleItemType.SCALE_VIEW));
}","@Override public void run(){
  startActivityAsStack(createSampleIntent(SampleItem.SampleItemType.FLOW_LAYOUT));
}"
13780,"@Override public void onViewCreated(@NonNull View view,@Nullable Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  final LayoutInflater inflater=LayoutInflater.from(getContext());
  final String[] messages=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final FlowLayout flowLayout1=view.findViewById(R.id.fragment_sample_flow_layout_flow1);
  for (  String s : messages) {
    final TextView tv=(TextView)inflater.inflate(R.layout.item_textview_rounded,flowLayout1,false);
    tv.setText(s);
    flowLayout1.addView(tv);
  }
}","@Override public void onViewCreated(@NonNull View view,@Nullable Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  final LayoutInflater inflater=LayoutInflater.from(getContext());
  final String[] messages=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final FlowLayout flowLayout1=view.findViewById(R.id.fragment_sample_flow_layout_flow1);
  for (  String s : messages) {
    final TextView tv=(TextView)inflater.inflate(R.layout.item_textview_rounded,flowLayout1,false);
    tv.setText(s);
    flowLayout1.addView(tv);
  }
}"
13781,"public String relativeTimeShort(final Context context,final long currentTime,final long time){
  final long secondsDelta=time - currentTime;
  if (secondsDelta < 0) {
    return timeAgoShort(context,-secondsDelta);
  }
 else {
    return ""String_Node_Str"";
  }
}","public String relativeTimeShort(final Context context,final long currentTime,final long time){
  final long secondsDelta=time - currentTime;
  if (secondsDelta < 0) {
    return timeAgoShort(context,-secondsDelta);
  }
 else {
    return context.getResources().getString(R.string.time_ago_short_now);
  }
}"
13782,"private void showContent(){
  mContentView.animate().alpha(1.0f).setDuration(300).start();
}","private void showContent(){
  if (mContentView != null) {
    mContentView.animate().alpha(1.0f).setDuration(300).start();
  }
}"
13783,"public void destroy(final Activity activity,final boolean animated){
  if (animated) {
    mContentView.animate().alpha(0).setDuration(150).setListener(new AnimationEndListener(){
      @Override public void onAnimationEndOrCanceled(      Animator animation){
        animate().alpha(0).setDuration(300).setListener(new AnimationEndListener(){
          @Override public void onAnimationEndOrCanceled(          Animator animation){
            removeView(mContentView);
            mContentView=null;
            if (activity != null) {
              ((ViewGroup)activity.getWindow().getDecorView()).removeView(ActivityOverlayView.this);
            }
          }
        }
).start();
      }
    }
).start();
  }
 else {
    removeView(mContentView);
    mContentView=null;
    if (activity != null) {
      ((ViewGroup)activity.getWindow().getDecorView()).removeView(ActivityOverlayView.this);
    }
  }
}","public void destroy(final Activity activity,final boolean animated){
  if (mContentView == null) {
    return;
  }
  if (animated) {
    mContentView.animate().alpha(0).setDuration(150).setListener(new AnimationEndListener(){
      @Override public void onAnimationEndOrCanceled(      Animator animation){
        animate().alpha(0).setDuration(300).setListener(new AnimationEndListener(){
          @Override public void onAnimationEndOrCanceled(          Animator animation){
            removeView(mContentView);
            mContentView=null;
            if (activity != null) {
              ((ViewGroup)activity.getWindow().getDecorView()).removeView(ActivityOverlayView.this);
            }
          }
        }
).start();
      }
    }
).start();
  }
 else {
    removeView(mContentView);
    mContentView=null;
    if (activity != null) {
      ((ViewGroup)activity.getWindow().getDecorView()).removeView(ActivityOverlayView.this);
    }
  }
}"
13784,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  final int width=MeasureSpec.getSize(widthMeasureSpec);
  setMeasuredDimension(width,width);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  final int width=MeasureSpec.getSize(widthMeasureSpec);
  setMeasuredDimension(width,width);
  for (int i=0; i < getChildCount(); i++) {
    View v=getChildAt(i);
    v.measure(MeasureSpec.makeMeasureSpec(width,MeasureSpec.AT_MOST),MeasureSpec.makeMeasureSpec(width,MeasureSpec.AT_MOST));
  }
}"
13785,"public void setTimeFormat(final String timeFormat){
  final StringBuilder sb=new StringBuilder();
  boolean shouldIgnore=false;
  for (int i=0; i < timeFormat.length(); ) {
    if (shouldIgnore) {
      sb.append(timeFormat.charAt(i));
      i++;
    }
    if (timeFormat.charAt(i) == '\'') {
      shouldIgnore=!shouldIgnore;
      i++;
    }
 else     if (timeFormat.startsWith(DAY_PLACEHOLDER,i)) {
      sb.append(""String_Node_Str"");
      i+=2;
    }
 else     if (timeFormat.startsWith(HOUR_PLACEHOLDER,i)) {
      sb.append(""String_Node_Str"");
      i+=2;
    }
 else     if (timeFormat.startsWith(MINUTE_PLACEHOLDER,i)) {
      sb.append(""String_Node_Str"");
      i+=2;
    }
 else     if (timeFormat.startsWith(SECOND_PLACEHOLDER,i)) {
      sb.append(""String_Node_Str"");
      i+=2;
    }
 else {
      sb.append(timeFormat.charAt(i));
      i++;
    }
  }
  mTimeFormat=sb.toString();
}","public void setTimeFormat(final String timeFormat){
  final StringBuilder sb=new StringBuilder();
  boolean shouldIgnore=false;
  for (int i=0; i < timeFormat.length(); ) {
    if (timeFormat.charAt(i) == '\'') {
      shouldIgnore=!shouldIgnore;
      i++;
    }
 else     if (shouldIgnore) {
      sb.append(timeFormat.charAt(i));
      i++;
      continue;
    }
 else     if (timeFormat.startsWith(DAY_PLACEHOLDER,i)) {
      sb.append(""String_Node_Str"");
      i+=2;
    }
 else     if (timeFormat.startsWith(HOUR_PLACEHOLDER,i)) {
      sb.append(""String_Node_Str"");
      i+=2;
    }
 else     if (timeFormat.startsWith(MINUTE_PLACEHOLDER,i)) {
      sb.append(""String_Node_Str"");
      i+=2;
    }
 else     if (timeFormat.startsWith(SECOND_PLACEHOLDER,i)) {
      sb.append(""String_Node_Str"");
      i+=2;
    }
 else {
      sb.append(timeFormat.charAt(i));
      i++;
    }
  }
  mTimeFormat=sb.toString();
}"
13786,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  System.out.println(""String_Node_Str"" + w + ""String_Node_Str""+ h);
  final float length=Math.min(w,h);
  final float strokeWidth=length * mProgressRingStrokeRatio;
  mRadius=length / 2 - strokeWidth;
  final float textSize=mRadius / 2;
  mPaint.setStrokeWidth(strokeWidth);
  mProgressRect.left=length / 2 - mRadius - strokeWidth / 2;
  mProgressRect.top=length / 2 - mRadius - strokeWidth / 2;
  mProgressRect.right=length / 2 + mRadius + strokeWidth / 2;
  mProgressRect.bottom=length / 2 + mRadius + strokeWidth / 2;
  mTextPaint.setTextSize(textSize);
  invalidate();
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  System.out.println(""String_Node_Str"" + w + ""String_Node_Str""+ h);
  final float length=Math.min(w,h);
  final float strokeWidth=length * mProgressRingStrokeRatio;
  mRadius=length / 2 - strokeWidth;
  final float textSize=mRadius / 2;
  mPaint.setStrokeWidth(strokeWidth);
  mProgressRect.left=w / 2 - mRadius - strokeWidth / 2;
  mProgressRect.top=h / 2 - mRadius - strokeWidth / 2;
  mProgressRect.right=w / 2 + mRadius + strokeWidth / 2;
  mProgressRect.bottom=h / 2 + mRadius + strokeWidth / 2;
  mTextPaint.setTextSize(textSize);
  invalidate();
}"
13787,"@Override protected void onDraw(final Canvas canvas){
  mPaint.setColor(Color.TRANSPARENT);
  canvas.drawRect(0,0,getMeasuredWidth(),getMeasuredHeight(),mPaint);
  mPaint.setStyle(Paint.Style.FILL);
  mPaint.setColor(mCircleBackgroundColor);
  canvas.drawCircle(getMeasuredWidth(),getMeasuredHeight(),mRadius,mPaint);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setColor(mProgressBaseColor);
  canvas.drawArc(mProgressRect,-90,360 * this.bottomRingProgress,false,mPaint);
  mPaint.setColor(mProgressColor);
  canvas.drawArc(mProgressRect,-90,360 * this.progress,false,mPaint);
  if (mShouldShowPercentage) {
    final String progressText=String.format(""String_Node_Str"",(int)(this.progress * 100));
    mTextPaint.getTextBounds(progressText,0,progressText.length(),mTextRect);
    canvas.drawText(progressText,getMeasuredWidth() / 2 - (mTextRect.right - mTextRect.left) / 2,getMeasuredHeight() / 2 + (mTextRect.bottom - mTextRect.top) / 2,mTextPaint);
  }
}","@Override protected void onDraw(final Canvas canvas){
  mPaint.setColor(Color.TRANSPARENT);
  canvas.drawRect(0,0,getMeasuredWidth(),getMeasuredHeight(),mPaint);
  mPaint.setStyle(Paint.Style.FILL);
  mPaint.setColor(mCircleBackgroundColor);
  canvas.drawCircle(getMeasuredWidth() / 2,getMeasuredHeight() / 2,mRadius,mPaint);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setColor(mProgressBaseColor);
  canvas.drawArc(mProgressRect,-90,360 * this.bottomRingProgress,false,mPaint);
  mPaint.setColor(mProgressColor);
  canvas.drawArc(mProgressRect,-90,360 * this.progress,false,mPaint);
  if (mShouldShowPercentage) {
    final String progressText=String.format(""String_Node_Str"",(int)(this.progress * 100));
    mTextPaint.getTextBounds(progressText,0,progressText.length(),mTextRect);
    canvas.drawText(progressText,getMeasuredWidth() / 2 - (mTextRect.right - mTextRect.left) / 2,getMeasuredHeight() / 2 + (mTextRect.bottom - mTextRect.top) / 2,mTextPaint);
  }
}"
13788,"@Override public int getCount(){
  return mTitlesRes.length;
}","@Override public int getCount(){
  return mDrawablesRes.length;
}"
13789,"private void calculateLayout(){
  final int childCount=getChildCount();
  float currentLineX=0;
  float currentLineY=0;
  float currentLineMaxHeight=0;
  ArrayList<View> currentLineChildren=new ArrayList<>();
  int i=0;
  while (i < childCount) {
    final View child=getChildAt(i);
    final float childWidth=child.getMeasuredWidth();
    final float childHeight=child.getMeasuredHeight();
    if (currentLineX + mHorizontalSpacing + childWidth < mMaximumWidth || currentLineChildren.size() == 0) {
      currentLineMaxHeight=Math.max(currentLineMaxHeight,childHeight);
      currentLineChildren.add(child);
      currentLineX+=childWidth + mHorizontalSpacing;
      i++;
    }
 else {
      assignLayoutForLine(currentLineChildren,currentLineY,currentLineMaxHeight);
      currentLineChildren.clear();
      currentLineY+=currentLineMaxHeight + mVerticalSpacing;
      currentLineMaxHeight=0;
      currentLineX=0;
    }
  }
  if (currentLineChildren.size() > 0) {
    assignLayoutForLine(currentLineChildren,currentLineY,currentLineMaxHeight);
    currentLineChildren.clear();
    currentLineY+=currentLineMaxHeight;
  }
 else {
    currentLineY-=mVerticalSpacing;
  }
  setMeasuredDimension(mMaximumWidth,(int)currentLineY);
}","private void calculateLayout(){
  final int childCount=getChildCount();
  float currentLineX=0;
  float currentLineY=0;
  float currentLineMaxHeight=0;
  ArrayList<View> currentLineChildren=new ArrayList<>();
  int i=0;
  while (i < childCount) {
    final View child=getChildAt(i);
    if (child.getVisibility() == View.GONE) {
      i++;
      continue;
    }
    final float childWidth=child.getMeasuredWidth();
    final float childHeight=child.getMeasuredHeight();
    if (currentLineX + mHorizontalSpacing + childWidth < mMaximumWidth || currentLineChildren.size() == 0) {
      currentLineMaxHeight=Math.max(currentLineMaxHeight,childHeight);
      currentLineChildren.add(child);
      currentLineX+=childWidth + mHorizontalSpacing;
      i++;
    }
 else {
      assignLayoutForLine(currentLineChildren,currentLineY,currentLineMaxHeight);
      currentLineChildren.clear();
      currentLineY+=currentLineMaxHeight + mVerticalSpacing;
      currentLineMaxHeight=0;
      currentLineX=0;
    }
  }
  if (currentLineChildren.size() > 0) {
    assignLayoutForLine(currentLineChildren,currentLineY,currentLineMaxHeight);
    currentLineChildren.clear();
    currentLineY+=currentLineMaxHeight;
  }
 else {
    currentLineY-=mVerticalSpacing;
  }
  setMeasuredDimension(mMaximumWidth,(int)currentLineY);
}"
13790,"@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  final String title=getArguments().getString(ARG_TITLE);
  final String button1=getArguments().getString(ARG_BUTTON1);
  final String button2=getArguments().getString(ARG_BUTTON2);
  final String text=getArguments().getString(ARG_TEXT);
  final Object attachedObject;
  if (getArguments().containsKey(ARG_OBJECT_S)) {
    attachedObject=getArguments().getSerializable(ARG_OBJECT_S);
  }
 else {
    attachedObject=getArguments().getParcelable(ARG_OBJECT_P);
  }
  final AlertDialog.Builder builder=new AlertDialog.Builder(getActivity()).setIcon(R.drawable.ic_close_black_18dp).setTitle(title).setPositiveButton(button1,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      mCallback.onAlertDialogFragmentButton1Clicked(getTag(),attachedObject);
    }
  }
);
  if (button2 != INVALID_RES) {
    builder.setNegativeButton(button2,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialog,      int which){
        mCallback.onAlertDialogFragmentButton2Clicked(getTag(),attachedObject);
      }
    }
);
  }
  builder.setMessage(text);
  final Dialog dialog=builder.create();
  dialog.setCanceledOnTouchOutside(getArguments().getBoolean(ARG_CANCELLABLE));
  return dialog;
}","@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  final String title=getArguments().getString(ARG_TITLE);
  final String button1=getArguments().getString(ARG_BUTTON1);
  final String button2=getArguments().getString(ARG_BUTTON2);
  final String text=getArguments().getString(ARG_TEXT);
  final Object attachedObject;
  if (getArguments().containsKey(ARG_OBJECT_S)) {
    attachedObject=getArguments().getSerializable(ARG_OBJECT_S);
  }
 else {
    attachedObject=getArguments().getParcelable(ARG_OBJECT_P);
  }
  final AlertDialog.Builder builder=new AlertDialog.Builder(getActivity()).setIcon(R.drawable.ic_close_black_18dp).setTitle(title).setPositiveButton(button1,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      if (mCallback == null) {
        return;
      }
      mCallback.onAlertDialogFragmentButton1Clicked(getTag(),attachedObject);
    }
  }
);
  if (button2 != INVALID_RES) {
    builder.setNegativeButton(button2,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialog,      int which){
        if (mCallback == null) {
          return;
        }
        mCallback.onAlertDialogFragmentButton2Clicked(getTag(),attachedObject);
      }
    }
);
  }
  builder.setMessage(text);
  final Dialog dialog=builder.create();
  dialog.setCanceledOnTouchOutside(getArguments().getBoolean(ARG_CANCELLABLE));
  return dialog;
}"
13791,"@Override public void onClick(DialogInterface dialog,int which){
  mCallback.onAlertDialogFragmentButton2Clicked(getTag(),attachedObject);
}","@Override public void onClick(DialogInterface dialog,int which){
  if (mCallback == null) {
    return;
  }
  mCallback.onAlertDialogFragmentButton2Clicked(getTag(),attachedObject);
}"
13792,"@Override public void onCancel(DialogInterface dialog){
  super.onCancel(dialog);
  final Object attachedObject;
  if (getArguments().containsKey(ARG_OBJECT_S)) {
    attachedObject=getArguments().getSerializable(ARG_OBJECT_S);
  }
 else {
    attachedObject=getArguments().getParcelable(ARG_OBJECT_P);
  }
  mCallback.onAlertDialogFragmentCanceled(getTag(),attachedObject);
}","@Override public void onCancel(DialogInterface dialog){
  super.onCancel(dialog);
  if (mCallback == null) {
    return;
  }
  final Object attachedObject;
  if (getArguments().containsKey(ARG_OBJECT_S)) {
    attachedObject=getArguments().getSerializable(ARG_OBJECT_S);
  }
 else {
    attachedObject=getArguments().getParcelable(ARG_OBJECT_P);
  }
  mCallback.onAlertDialogFragmentCanceled(getTag(),attachedObject);
}"
13793,"/** 
 * @param context  context
 * @param attrs    attributes
 * @param defStyle defined style
 */
private void initAttrs(Context context,AttributeSet attrs,int defStyle){
  final TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.RecyclerViewPager,defStyle,0);
  mFlingFactor=a.getFloat(R.styleable.RecyclerViewPager_oh_flingFactor,mFlingFactor);
  mTriggerOffset=a.getFloat(R.styleable.RecyclerViewPager_oh_triggerOffset,mTriggerOffset);
  mSinglePageFling=a.getBoolean(R.styleable.RecyclerViewPager_oh_singlePageFling,mSinglePageFling);
  mOverlapRatio=a.getDimension(R.styleable.RecyclerViewPager_oh_overlap_ratio,mOverlapRatio);
  mOverlapAmount=a.getDimension(R.styleable.RecyclerViewPager_oh_overlap_amount,mOverlapAmount);
  a.recycle();
}","/** 
 * @param context  context
 * @param attrs    attributes
 * @param defStyle defined style
 */
private void initAttrs(Context context,AttributeSet attrs,int defStyle){
  final TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.RecyclerViewPager,defStyle,0);
  mFlingFactor=a.getFloat(R.styleable.RecyclerViewPager_oh_flingFactor,mFlingFactor);
  mTriggerOffset=a.getFloat(R.styleable.RecyclerViewPager_oh_triggerOffset,mTriggerOffset);
  mSinglePageFling=a.getBoolean(R.styleable.RecyclerViewPager_oh_singlePageFling,mSinglePageFling);
  mOverlapRatio=a.getFloat(R.styleable.RecyclerViewPager_oh_overlap_ratio,mOverlapRatio);
  mOverlapAmount=a.getDimension(R.styleable.RecyclerViewPager_oh_overlap_amount,mOverlapAmount);
  a.recycle();
}"
13794,"public FlexGridViewHolder(View view,final int sizing){
  super(view);
}","public FlexGridViewHolder(View view,final int sizing){
  super(view);
  mSizing=sizing;
  view.setTag(R.id.view_sizing_tag_key,Integer.valueOf(sizing));
}"
13795,"@Override public int getDecoratedMeasuredHeight(View child){
  return super.getDecoratedMeasuredHeight(child);
}","@Override public int getDecoratedMeasuredHeight(View child){
  final Integer sizing=(Integer)child.getTag(R.id.view_sizing_tag_key);
  if (sizing != null) {
    final int superMeasured=super.getDecoratedMeasuredHeight(child);
    final int childMeasured=child.getMeasuredHeight();
    final int offset=superMeasured - childMeasured;
    if (sizing.intValue() == FlexGridViewHolder.SIZE_SQUARE) {
      return getDecoratedMeasuredWidth(child) + offset;
    }
 else     if (sizing.intValue() > 0) {
      return sizing.intValue() + offset;
    }
  }
  return super.getDecoratedMeasuredHeight(child);
}"
13796,"@Override public void getItemOffsets(Rect outRect,View view,RecyclerView parent,RecyclerView.State state){
  super.getItemOffsets(outRect,view,parent,state);
  final int position=parent.getChildPosition(view);
  if (parent.getLayoutManager() instanceof GridLayoutManager) {
    final GridLayoutManager.SpanSizeLookup sizeLookUp=((GridLayoutManager)parent.getLayoutManager()).getSpanSizeLookup();
    final int span=((GridLayoutManager)parent.getLayoutManager()).getSpanCount();
    final int groupIndex=sizeLookUp.getSpanGroupIndex(position,span);
    if (groupIndex == 0) {
      outRect.top=mTopContentInset;
    }
 else {
      final int lastRowGroupIndex=sizeLookUp.getSpanGroupIndex(parent.getAdapter().getItemCount() - 1,span);
      if (groupIndex == lastRowGroupIndex) {
        outRect.bottom=mBottomContentInset;
      }
    }
  }
 else {
    if (position == 0) {
      outRect.top=mTopContentInset;
    }
    if (position == parent.getAdapter().getItemCount() - 1) {
      outRect.bottom=mBottomContentInset;
    }
  }
  outRect.left=mItemMargin / 2;
  outRect.right=mItemMargin / 2;
  outRect.top+=mItemMargin / 2;
  outRect.bottom+=mItemMargin / 2;
}","@Override public void getItemOffsets(Rect outRect,View view,RecyclerView parent,RecyclerView.State state){
  super.getItemOffsets(outRect,view,parent,state);
  final int position=parent.getChildAdapterPosition(view);
  if (parent.getLayoutManager() instanceof GridLayoutManager) {
    final GridLayoutManager.SpanSizeLookup sizeLookUp=((GridLayoutManager)parent.getLayoutManager()).getSpanSizeLookup();
    final int span=((GridLayoutManager)parent.getLayoutManager()).getSpanCount();
    final int groupIndex=sizeLookUp.getSpanGroupIndex(position,span);
    if (groupIndex == 0) {
      outRect.top=mTopContentInset;
    }
 else {
      final int lastRowGroupIndex=sizeLookUp.getSpanGroupIndex(parent.getAdapter().getItemCount() - 1,span);
      if (groupIndex == lastRowGroupIndex) {
        outRect.bottom=mBottomContentInset;
      }
    }
  }
 else {
    if (position == 0) {
      outRect.top=mTopContentInset;
    }
    if (position == parent.getAdapter().getItemCount() - 1) {
      outRect.bottom=mBottomContentInset;
    }
  }
  outRect.left=mItemMargin / 2;
  outRect.right=mItemMargin / 2;
  outRect.top+=mItemMargin / 2;
  outRect.bottom+=mItemMargin / 2;
}"
13797,"@Override public void onClick(View v){
}","@Override public void onClick(View v){
  if (!mAutoTriggerLoading) {
    notifyLoadingStarted(getItemCount() - 1);
    mAutoTriggerLoading=true;
    final ProgressBar progressBar=(ProgressBar)v.findViewById(R.id.view_loading_progress);
    final TextView loadMoreText=(TextView)v.findViewById(R.id.view_loading_load_more_text);
    progressBar.setVisibility(View.VISIBLE);
    loadMoreText.setVisibility(View.INVISIBLE);
  }
}"
13798,"@Override public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType){
  return null;
}","@Override public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType){
  if (viewType == TYPE_VIEW_LOADING) {
    final LoadingViewHolder holder=new LoadingViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.view_adapter_loading,parent,false));
    holder.itemView.setOnClickListener(this);
    return holder;
  }
 else {
    return mWrappedAdapter.createViewHolder(parent,viewType);
  }
}"
13799,"@Override public void onBindViewHolder(ViewHolder viewHolder,int position){
}","@Override public void onBindViewHolder(ViewHolder viewHolder,int position){
  if (isLoadingView(position)) {
    @SuppressWarnings(""String_Node_Str"") final LoadingViewHolder holder=(LoadingViewHolder)viewHolder;
    if (mAutoTriggerLoading) {
      notifyLoadingStarted(position);
    }
    if (holder != null) {
      if (mAutoTriggerLoading) {
        holder.mProgressBar.setVisibility(View.VISIBLE);
        holder.mLoadMoreText.setVisibility(View.INVISIBLE);
      }
 else {
        holder.mProgressBar.setVisibility(View.INVISIBLE);
        holder.mLoadMoreText.setVisibility(View.VISIBLE);
      }
    }
  }
 else {
    mWrappedAdapter.onBindViewHolder(viewHolder,position);
  }
}"
13800,"@Override public void onScrolled(RecyclerView recyclerView,int dx,int dy){
  super.onScrolled(recyclerView,dx,dy);
  if (dy == 0) {
    final int childHeight=getHeight() - getPaddingTop() - getPaddingBottom()- getOverlapOffset();
    mCurrentScrollY=getCurrentPosition() * childHeight;
  }
 else {
    mCurrentScrollY+=dy;
  }
  if (mPagerScrollListener.get() != null) {
    mPagerScrollListener.get().onPagerScroll(RecyclerViewPager.this,mCurrentScrollY,dy);
  }
}","@Override public void onScrolled(RecyclerView recyclerView,int dx,int dy){
  super.onScrolled(recyclerView,dx,dy);
  if (dy == 0) {
    final int childHeight=getHeight() - getPaddingTop() - getPaddingBottom()- getOverlapOffset();
    mCurrentScrollY=getCurrentPosition() * childHeight;
  }
 else {
    mCurrentScrollY+=dy;
  }
  if (mPagerScrollListener != null && mPagerScrollListener.get() != null) {
    mPagerScrollListener.get().onPagerScroll(RecyclerViewPager.this,mCurrentScrollY,dy);
  }
}"
13801,"public int decode_nal_units(int[] buf_base,int buf_offset,int buf_size){
  int buf_index=0;
  H264Context hx=this;
  int context_count=0;
  int next_avc=((this.is_avc != 0) ? 0 : buf_size);
  this.max_contexts=1;
  if (0 == (s.flags2 & MpegEncContext.CODEC_FLAG2_CHUNKS)) {
    this.current_slice=0;
    if (0 == s.first_field)     s.current_picture_ptr=null;
    SEIDecoder.ff_h264_reset_sei(this);
  }
  for (; ; ) {
    int consumed;
    int dst_length;
    int bit_length;
    int[] ptr_base;
    int ptr_offset;
    int i, nalsize=0;
    int err;
    if (buf_index >= next_avc) {
      if (buf_index >= buf_size)       break;
      nalsize=0;
      for (i=0; i < this.nal_length_size; i++)       nalsize=(nalsize << 8) | buf_base[buf_offset + buf_index++];
      if (nalsize <= 0 || nalsize > buf_size - buf_index) {
        break;
      }
      next_avc=buf_index + nalsize;
    }
 else {
      for (; buf_index + 3 < next_avc; buf_index++) {
        if (buf_base[buf_offset + buf_index] == 0 && buf_base[buf_offset + buf_index + 1] == 0 && buf_base[buf_offset + buf_index + 2] == 1)         break;
      }
      if (buf_index + 3 >= buf_size)       break;
      buf_index+=3;
      if (buf_index >= next_avc)       continue;
    }
    hx=this.thread_context[context_count];
    int[] param=new int[3];
    ptr_base=hx.ff_h264_decode_nal(buf_base,buf_offset + buf_index,param,next_avc - buf_index);
    dst_length=param[0];
    consumed=param[1];
    ptr_offset=param[2];
    if (ptr_base == null || dst_length < 0) {
      return -1;
    }
    i=buf_index + consumed;
    if ((s.workaround_bugs & MpegEncContext.FF_BUG_AUTODETECT) != 0 && i + 3 < next_avc && buf_base[buf_offset + i] == 0x00 && buf_base[buf_offset + i + 1] == 0x00 && buf_base[buf_offset + i + 2] == 0x01 && buf_base[buf_offset + i + 3] == 0x0E0)     s.workaround_bugs|=MpegEncContext.FF_BUG_TRUNCATED;
    if (0 == (s.workaround_bugs & MpegEncContext.FF_BUG_TRUNCATED)) {
      while (ptr_base[ptr_offset + dst_length - 1] == 0 && dst_length > 0)       dst_length--;
    }
    bit_length=(dst_length == 0) ? 0 : (8 * dst_length - ff_h264_decode_rbsp_trailing(ptr_base,ptr_offset + dst_length - 1));
    if (this.is_avc != 0 && (nalsize != consumed) && nalsize != 0) {
    }
    buf_index+=consumed;
    if ((s.hurry_up == 1 && this.nal_ref_idc == 0) || (s.skip_frame >= MpegEncContext.AVDISCARD_NONREF && this.nal_ref_idc == 0))     continue;
    boolean doAgain=false;
    do {
      doAgain=false;
      err=0;
switch (hx.nal_unit_type) {
case NAL_IDR_SLICE:
        if (this.nal_unit_type != NAL_IDR_SLICE) {
          return -1;
        }
      idr();
case NAL_SLICE:
    hx.s.gb.init_get_bits(ptr_base,ptr_offset,bit_length);
  hx.intra_gb_ptr=hx.inter_gb_ptr=hx.s.gb;
hx.s.data_partitioning=0;
err=decode_slice_header(hx,this);
if ((err) != 0) break;
if (this.current_slice == 1) {
}
s.current_picture_ptr.key_frame|=(((hx.nal_unit_type == NAL_IDR_SLICE) || (this.sei_recovery_frame_cnt >= 0)) ? 1 : 0);
if (hx.redundant_pic_count == 0 && hx.s.hurry_up < 5 && (s.skip_frame < MpegEncContext.AVDISCARD_NONREF || hx.nal_ref_idc != 0) && (s.skip_frame < MpegEncContext.AVDISCARD_BIDIR || hx.slice_type_nos != FF_B_TYPE) && (s.skip_frame < MpegEncContext.AVDISCARD_NONKEY || hx.slice_type_nos == FF_I_TYPE) && s.skip_frame < MpegEncContext.AVDISCARD_ALL) {
if (s.hwaccel != 0) {
}
 else {
context_count++;
}
}
break;
case NAL_DPA:
hx.s.gb.init_get_bits(ptr_base,ptr_offset,bit_length);
hx.intra_gb_ptr=hx.inter_gb_ptr=null;
err=decode_slice_header(hx,this);
if ((err) < 0) break;
hx.s.data_partitioning=1;
break;
case NAL_DPB:
hx.intra_gb=new GetBitContext();
hx.intra_gb.init_get_bits(ptr_base,ptr_offset,bit_length);
hx.intra_gb_ptr=hx.intra_gb;
break;
case NAL_DPC:
hx.inter_gb.init_get_bits(ptr_base,ptr_offset,bit_length);
hx.inter_gb_ptr=hx.inter_gb;
if (hx.redundant_pic_count == 0 && hx.intra_gb_ptr != null && hx.s.data_partitioning != 0 && s.context_initialized != 0 && s.hurry_up < 5 && (s.skip_frame < MpegEncContext.AVDISCARD_NONREF || hx.nal_ref_idc != 0) && (s.skip_frame < MpegEncContext.AVDISCARD_BIDIR || hx.slice_type_nos != FF_B_TYPE) && (s.skip_frame < MpegEncContext.AVDISCARD_NONKEY || hx.slice_type_nos == FF_I_TYPE) && s.skip_frame < MpegEncContext.AVDISCARD_ALL) {
context_count++;
}
break;
case NAL_SEI:
s.gb.init_get_bits(ptr_base,ptr_offset,bit_length);
ff_h264_decode_sei();
break;
case NAL_SPS:
s.gb.init_get_bits(ptr_base,ptr_offset,bit_length);
ff_h264_decode_seq_parameter_set();
if ((s.flags & MpegEncContext.CODEC_FLAG_LOW_DELAY) != 0) s.low_delay=1;
if (s.has_b_frames < 2) s.has_b_frames=((0 == s.low_delay) ? 1 : 0);
break;
case NAL_PPS:
s.gb.init_get_bits(ptr_base,ptr_offset,bit_length);
ff_h264_decode_picture_parameter_set(bit_length);
break;
case NAL_AUD:
case NAL_END_SEQUENCE:
case NAL_END_STREAM:
case NAL_FILLER_DATA:
case NAL_SPS_EXT:
case NAL_AUXILIARY_SLICE:
break;
default :
}
if (context_count == this.max_contexts) {
decode_slice();
context_count=0;
}
if (err < 0) {
}
 else if (err == 1) {
this.nal_unit_type=hx.nal_unit_type;
this.nal_ref_idc=hx.nal_ref_idc;
hx=this;
doAgain=true;
}
}
 while (doAgain == true);
}
if (context_count != 0) decode_slice();
return buf_index;
}","public int decode_nal_units(int[] buf_base,int buf_offset,int buf_size){
  int buf_index=0;
  H264Context hx=this;
  int context_count=0;
  int next_avc=((this.is_avc != 0) ? 0 : buf_size);
  this.max_contexts=1;
  if (0 == (s.flags2 & MpegEncContext.CODEC_FLAG2_CHUNKS)) {
    this.current_slice=0;
    if (0 == s.first_field)     s.current_picture_ptr=null;
    SEIDecoder.ff_h264_reset_sei(this);
  }
  for (; ; ) {
    int consumed;
    int dst_length;
    int bit_length;
    int[] ptr_base;
    int ptr_offset;
    int i, nalsize=0;
    int err;
    if (buf_index >= next_avc) {
      if (buf_index >= buf_size)       break;
      nalsize=0;
      for (i=0; i < this.nal_length_size; i++)       nalsize=(nalsize << 8) | buf_base[buf_offset + buf_index++];
      if (nalsize <= 0 || nalsize > buf_size - buf_index) {
        break;
      }
      next_avc=buf_index + nalsize;
    }
 else {
      for (; buf_index + 3 < next_avc; buf_index++) {
        if (buf_base[buf_offset + buf_index] == 0 && buf_base[buf_offset + buf_index + 1] == 0 && buf_base[buf_offset + buf_index + 2] == 1)         break;
      }
      if (buf_index + 3 >= buf_size)       break;
      buf_index+=3;
      if (buf_index >= next_avc)       continue;
    }
    hx=this.thread_context[context_count];
    int[] param=new int[3];
    ptr_base=hx.ff_h264_decode_nal(buf_base,buf_offset + buf_index,param,next_avc - buf_index);
    dst_length=param[0];
    consumed=param[1];
    ptr_offset=param[2];
    if (ptr_base == null || dst_length < 0) {
      System.out.println(""String_Node_Str"" + ptr_base + ""String_Node_Str""+ dst_length);
      return -1;
    }
    i=buf_index + consumed;
    if ((s.workaround_bugs & MpegEncContext.FF_BUG_AUTODETECT) != 0 && i + 3 < next_avc && buf_base[buf_offset + i] == 0x00 && buf_base[buf_offset + i + 1] == 0x00 && buf_base[buf_offset + i + 2] == 0x01 && buf_base[buf_offset + i + 3] == 0x0E0)     s.workaround_bugs|=MpegEncContext.FF_BUG_TRUNCATED;
    if (0 == (s.workaround_bugs & MpegEncContext.FF_BUG_TRUNCATED)) {
      while (ptr_base[ptr_offset + dst_length - 1] == 0 && dst_length > 0)       dst_length--;
    }
    bit_length=(dst_length == 0) ? 0 : (8 * dst_length - ff_h264_decode_rbsp_trailing(ptr_base,ptr_offset + dst_length - 1));
    if (this.is_avc != 0 && (nalsize != consumed) && nalsize != 0) {
      System.out.println(""String_Node_Str"" + consumed + ""String_Node_Str""+ nalsize);
    }
    buf_index+=consumed;
    if ((s.hurry_up == 1 && this.nal_ref_idc == 0) || (s.skip_frame >= MpegEncContext.AVDISCARD_NONREF && this.nal_ref_idc == 0))     continue;
    boolean doAgain=false;
    do {
      doAgain=false;
      err=0;
switch (hx.nal_unit_type) {
case NAL_IDR_SLICE:
        if (this.nal_unit_type != NAL_IDR_SLICE) {
          System.out.println(""String_Node_Str"");
          return -1;
        }
      idr();
case NAL_SLICE:
    hx.s.gb.init_get_bits(ptr_base,ptr_offset,bit_length);
  hx.intra_gb_ptr=hx.inter_gb_ptr=hx.s.gb;
hx.s.data_partitioning=0;
err=decode_slice_header(hx,this);
if ((err) != 0) {
System.out.println(""String_Node_Str"" + err);
break;
}
s.current_picture_ptr.key_frame|=(((hx.nal_unit_type == NAL_IDR_SLICE) || (this.sei_recovery_frame_cnt >= 0)) ? 1 : 0);
if (hx.redundant_pic_count == 0 && hx.s.hurry_up < 5 && (s.skip_frame < MpegEncContext.AVDISCARD_NONREF || hx.nal_ref_idc != 0) && (s.skip_frame < MpegEncContext.AVDISCARD_BIDIR || hx.slice_type_nos != FF_B_TYPE) && (s.skip_frame < MpegEncContext.AVDISCARD_NONKEY || hx.slice_type_nos == FF_I_TYPE) && s.skip_frame < MpegEncContext.AVDISCARD_ALL) {
if (s.hwaccel != 0) {
System.out.println(""String_Node_Str"");
}
 else {
context_count++;
}
}
break;
case NAL_DPA:
hx.s.gb.init_get_bits(ptr_base,ptr_offset,bit_length);
hx.intra_gb_ptr=hx.inter_gb_ptr=null;
err=decode_slice_header(hx,this);
if ((err) < 0) {
System.out.println(""String_Node_Str"" + err);
break;
}
hx.s.data_partitioning=1;
break;
case NAL_DPB:
hx.intra_gb=new GetBitContext();
hx.intra_gb.init_get_bits(ptr_base,ptr_offset,bit_length);
hx.intra_gb_ptr=hx.intra_gb;
break;
case NAL_DPC:
hx.inter_gb.init_get_bits(ptr_base,ptr_offset,bit_length);
hx.inter_gb_ptr=hx.inter_gb;
if (hx.redundant_pic_count == 0 && hx.intra_gb_ptr != null && hx.s.data_partitioning != 0 && s.context_initialized != 0 && s.hurry_up < 5 && (s.skip_frame < MpegEncContext.AVDISCARD_NONREF || hx.nal_ref_idc != 0) && (s.skip_frame < MpegEncContext.AVDISCARD_BIDIR || hx.slice_type_nos != FF_B_TYPE) && (s.skip_frame < MpegEncContext.AVDISCARD_NONKEY || hx.slice_type_nos == FF_I_TYPE) && s.skip_frame < MpegEncContext.AVDISCARD_ALL) {
context_count++;
}
break;
case NAL_SEI:
s.gb.init_get_bits(ptr_base,ptr_offset,bit_length);
ff_h264_decode_sei();
break;
case NAL_SPS:
s.gb.init_get_bits(ptr_base,ptr_offset,bit_length);
ff_h264_decode_seq_parameter_set();
if ((s.flags & MpegEncContext.CODEC_FLAG_LOW_DELAY) != 0) s.low_delay=1;
if (s.has_b_frames < 2) s.has_b_frames=((0 == s.low_delay) ? 1 : 0);
break;
case NAL_PPS:
s.gb.init_get_bits(ptr_base,ptr_offset,bit_length);
ff_h264_decode_picture_parameter_set(bit_length);
break;
case NAL_AUD:
case NAL_END_SEQUENCE:
case NAL_END_STREAM:
case NAL_FILLER_DATA:
case NAL_SPS_EXT:
case NAL_AUXILIARY_SLICE:
break;
default :
System.out.println(""String_Node_Str"" + hx.nal_unit_type + ""String_Node_Str""+ bit_length);
}
if (context_count == this.max_contexts) {
decode_slice();
context_count=0;
}
if (err < 0) {
System.out.println(""String_Node_Str"" + err);
}
 else if (err == 1) {
this.nal_unit_type=hx.nal_unit_type;
this.nal_ref_idc=hx.nal_ref_idc;
hx=this;
doAgain=true;
}
}
 while (doAgain == true);
}
if (context_count != 0) decode_slice();
return buf_index;
}"
13802,"public int ff_h264_execute_ref_pic_marking(MMCO[] mmco,int mmco_count){
  int i, j=0;
  int current_ref_assigned=0;
  AVFrame pic=null;
  for (i=0; i < mmco_count; i++) {
    int structure=0, frame_num=0;
    if (mmco[i].opcode == MMCO.MMCO_SHORT2UNUSED || mmco[i].opcode == MMCO.MMCO_SHORT2LONG) {
      int[] param=new int[1];
      frame_num=pic_num_extract(mmco[i].short_pic_num,param);
      structure=param[0];
      pic=find_short(frame_num,param);
      j=param[0];
      if (null == pic) {
        continue;
      }
    }
switch (mmco[i].opcode) {
case MMCO.MMCO_SHORT2UNUSED:
      remove_short(frame_num,structure ^ MpegEncContext.PICT_FRAME);
    break;
case MMCO.MMCO_SHORT2LONG:
  if (this.long_ref[mmco[i].long_arg] != pic)   remove_long(mmco[i].long_arg,0);
remove_short_at_index(j);
this.long_ref[mmco[i].long_arg]=pic;
if (this.long_ref[mmco[i].long_arg] != null) {
this.long_ref[mmco[i].long_arg].long_ref=1;
this.long_ref_count++;
}
break;
case MMCO.MMCO_LONG2UNUSED:
int[] param=new int[]{structure};
j=pic_num_extract(mmco[i].long_arg,param);
structure=param[0];
pic=this.long_ref[j];
if (pic != null) {
remove_long(j,structure ^ MpegEncContext.PICT_FRAME);
}
break;
case MMCO.MMCO_LONG:
if (this.long_ref[mmco[i].long_arg] != s.current_picture_ptr) {
remove_long(mmco[i].long_arg,0);
this.long_ref[mmco[i].long_arg]=s.current_picture_ptr;
this.long_ref[mmco[i].long_arg].long_ref=1;
this.long_ref_count++;
}
s.current_picture_ptr.reference|=s.picture_structure;
current_ref_assigned=1;
break;
case MMCO.MMCO_SET_MAX_LONG:
for (j=mmco[i].long_arg; j < 16; j++) {
remove_long(j,0);
}
break;
case MMCO.MMCO_RESET:
while (this.short_ref_count != 0) {
remove_short(this.short_ref[0].frame_num,0);
}
for (j=0; j < 16; j++) {
remove_long(j,0);
}
s.current_picture_ptr.poc=s.current_picture_ptr.field_poc[0]=s.current_picture_ptr.field_poc[1]=this.poc_lsb=this.poc_msb=this.frame_num=s.current_picture_ptr.frame_num=0;
s.current_picture_ptr.mmco_reset=1;
break;
default :
}
}
if (0 == current_ref_assigned) {
if (0 != this.short_ref_count && this.short_ref[0] == s.current_picture_ptr) {
s.current_picture_ptr.reference=MpegEncContext.PICT_FRAME;
}
 else if (0 != s.current_picture_ptr.long_ref) {
}
 else {
pic=remove_short(s.current_picture_ptr.frame_num,0);
if (pic != null) {
}
if (this.short_ref_count != 0) {
for (int k=this.short_ref_count; k >= 1; k--) this.short_ref[k]=this.short_ref[k - 1];
}
this.short_ref[0]=s.current_picture_ptr;
this.short_ref_count++;
s.current_picture_ptr.reference|=s.picture_structure;
}
}
if (this.long_ref_count + this.short_ref_count > this.sps.ref_frame_count) {
if (this.long_ref_count != 0 && 0 == this.short_ref_count) {
for (i=0; i < 16; ++i) if (this.long_ref[i] != null) break;
remove_long(i,0);
}
 else {
pic=this.short_ref[this.short_ref_count - 1];
remove_short(pic.frame_num,0);
}
}
return 0;
}","public int ff_h264_execute_ref_pic_marking(MMCO[] mmco,int mmco_count){
  int i, j=0;
  int current_ref_assigned=0;
  AVFrame pic=null;
  for (i=0; i < mmco_count; i++) {
    int structure=0, frame_num=0;
    if (mmco[i].opcode == MMCO.MMCO_SHORT2UNUSED || mmco[i].opcode == MMCO.MMCO_SHORT2LONG) {
      int[] param=new int[1];
      frame_num=pic_num_extract(mmco[i].short_pic_num,param);
      structure=param[0];
      pic=find_short(frame_num,param);
      j=param[0];
      if (null == pic) {
        continue;
      }
    }
switch (mmco[i].opcode) {
case MMCO.MMCO_SHORT2UNUSED:
      remove_short(frame_num,structure ^ MpegEncContext.PICT_FRAME);
    break;
case MMCO.MMCO_SHORT2LONG:
  if (this.long_ref[mmco[i].long_arg] != pic)   remove_long(mmco[i].long_arg,0);
remove_short_at_index(j);
this.long_ref[mmco[i].long_arg]=pic;
if (this.long_ref[mmco[i].long_arg] != null) {
this.long_ref[mmco[i].long_arg].long_ref=1;
this.long_ref_count++;
}
break;
case MMCO.MMCO_LONG2UNUSED:
int[] param=new int[]{structure};
j=pic_num_extract(mmco[i].long_arg,param);
structure=param[0];
pic=this.long_ref[j];
if (pic != null) {
remove_long(j,structure ^ MpegEncContext.PICT_FRAME);
}
break;
case MMCO.MMCO_LONG:
if (this.long_ref[mmco[i].long_arg] != s.current_picture_ptr) {
remove_long(mmco[i].long_arg,0);
this.long_ref[mmco[i].long_arg]=s.current_picture_ptr;
this.long_ref[mmco[i].long_arg].long_ref=1;
this.long_ref_count++;
}
s.current_picture_ptr.reference|=s.picture_structure;
current_ref_assigned=1;
break;
case MMCO.MMCO_SET_MAX_LONG:
for (j=mmco[i].long_arg; j < 16; j++) {
remove_long(j,0);
}
break;
case MMCO.MMCO_RESET:
while (this.short_ref_count != 0) {
remove_short(this.short_ref[0].frame_num,0);
}
for (j=0; j < 16; j++) {
remove_long(j,0);
}
s.current_picture_ptr.poc=s.current_picture_ptr.field_poc[0]=s.current_picture_ptr.field_poc[1]=this.poc_lsb=this.poc_msb=this.frame_num=s.current_picture_ptr.frame_num=0;
s.current_picture_ptr.mmco_reset=1;
break;
default :
}
}
if (0 == current_ref_assigned) {
if (0 != this.short_ref_count && this.short_ref[0] == s.current_picture_ptr) {
s.current_picture_ptr.reference=MpegEncContext.PICT_FRAME;
}
 else if (0 != s.current_picture_ptr.long_ref) {
}
 else {
pic=remove_short(s.current_picture_ptr.frame_num,0);
if (pic != null) {
System.out.println(""String_Node_Str"" + pic);
}
if (this.short_ref_count != 0) {
for (int k=this.short_ref_count; k >= 1; k--) this.short_ref[k]=this.short_ref[k - 1];
}
this.short_ref[0]=s.current_picture_ptr;
this.short_ref_count++;
s.current_picture_ptr.reference|=s.picture_structure;
}
}
if (this.long_ref_count + this.short_ref_count > this.sps.ref_frame_count) {
if (this.long_ref_count != 0 && 0 == this.short_ref_count) {
for (i=0; i < 16; ++i) if (this.long_ref[i] != null) break;
remove_long(i,0);
}
 else {
pic=this.short_ref[this.short_ref_count - 1];
remove_short(pic.frame_num,0);
}
}
return 0;
}"
13803,"public void run(){
  System.out.println(""String_Node_Str"");
  while (shouldRun)   try {
    playStream();
  }
 catch (  Exception e) {
  }
}","public void run(){
  if (DEBUG)   System.out.println(""String_Node_Str"");
  while (shouldRun) {
    try {
      playStream();
    }
 catch (    Exception e) {
      if (DEBUG)       System.out.println(""String_Node_Str"" + e);
    }
  }
  if (DEBUG)   System.out.println(""String_Node_Str"");
}"
13804,"@SuppressWarnings(""String_Node_Str"") public boolean playStream() throws Exception {
  H264Decoder codec=null;
  MpegEncContext c=null;
  int frame, len;
  int[] got_picture=new int[1];
  AVFrame picture;
  byte[] inbuf=new byte[INBUF_SIZE + MpegEncContext.FF_INPUT_BUFFER_PADDING_SIZE];
  int[] inbuf_int=new int[INBUF_SIZE + MpegEncContext.FF_INPUT_BUFFER_PADDING_SIZE];
  AVPacket avpkt=new AVPacket();
  avpkt.av_init_packet();
  Arrays.fill(inbuf,INBUF_SIZE,MpegEncContext.FF_INPUT_BUFFER_PADDING_SIZE + INBUF_SIZE,(byte)0);
  System.out.println(""String_Node_Str"");
  codec=new H264Decoder();
  if (codec == null) {
    System.out.println(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"");
  }
  c=MpegEncContext.avcodec_alloc_context();
  picture=AVFrame.avcodec_alloc_frame();
  if ((codec.capabilities & H264Decoder.CODEC_CAP_TRUNCATED) != 0)   c.flags|=MpegEncContext.CODEC_FLAG_TRUNCATED;
  if (c.avcodec_open(codec) < 0) {
    System.out.println(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    frame=0;
    int dataPointer;
    int[] cacheRead=new int[3];
    cacheRead[0]=stream.read();
    cacheRead[1]=stream.read();
    cacheRead[2]=stream.read();
    while (!(cacheRead[0] == 0x00 && cacheRead[1] == 0x00 && cacheRead[2] == 0x01)) {
      cacheRead[0]=cacheRead[1];
      cacheRead[1]=cacheRead[2];
      cacheRead[2]=stream.read();
    }
    boolean hasMoreNAL=true;
    inbuf_int[0]=inbuf_int[1]=inbuf_int[2]=0x00;
    inbuf_int[3]=0x01;
    while (hasMoreNAL) {
      dataPointer=4;
      cacheRead[0]=stream.read();
      if (cacheRead[0] == -1)       hasMoreNAL=false;
      cacheRead[1]=stream.read();
      if (cacheRead[1] == -1)       hasMoreNAL=false;
      cacheRead[2]=stream.read();
      if (cacheRead[2] == -1)       hasMoreNAL=false;
      while (!(cacheRead[0] == 0x00 && cacheRead[1] == 0x00 && cacheRead[2] == 0x01) && hasMoreNAL) {
        inbuf_int[dataPointer++]=cacheRead[0];
        cacheRead[0]=cacheRead[1];
        cacheRead[1]=cacheRead[2];
        cacheRead[2]=stream.read();
        if (cacheRead[2] == -1)         hasMoreNAL=false;
      }
      avpkt.size=dataPointer;
      avpkt.data_base=inbuf_int;
      avpkt.data_offset=0;
      try {
        while (avpkt.size > 0) {
          len=c.avcodec_decode_video2(picture,got_picture,avpkt);
          if (len < 0) {
            break;
          }
          if (got_picture[0] != 0) {
            picture=c.priv_data.displayPicture;
            callback.imageUpdated(picture);
            ++frame;
          }
          avpkt.size-=len;
          avpkt.data_offset+=len;
        }
      }
 catch (      Exception ie) {
        ie.printStackTrace();
      }
    }
  }
  finally {
    c.avcodec_close();
    c=null;
    picture=null;
    System.out.println(""String_Node_Str"");
  }
  return true;
}","@SuppressWarnings(""String_Node_Str"") public boolean playStream() throws Exception {
  H264Decoder codec=null;
  MpegEncContext c=null;
  int frame, len;
  int[] got_picture=new int[1];
  AVFrame picture;
  byte[] inbuf=new byte[INBUF_SIZE + MpegEncContext.FF_INPUT_BUFFER_PADDING_SIZE];
  int[] inbuf_int=new int[INBUF_SIZE + MpegEncContext.FF_INPUT_BUFFER_PADDING_SIZE];
  AVPacket avpkt=new AVPacket();
  avpkt.av_init_packet();
  Arrays.fill(inbuf,INBUF_SIZE,MpegEncContext.FF_INPUT_BUFFER_PADDING_SIZE + INBUF_SIZE,(byte)0);
  System.out.println(""String_Node_Str"");
  codec=new H264Decoder();
  if (codec == null) {
    System.out.println(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"");
  }
  c=MpegEncContext.avcodec_alloc_context();
  picture=AVFrame.avcodec_alloc_frame();
  if ((codec.capabilities & H264Decoder.CODEC_CAP_TRUNCATED) != 0)   c.flags|=MpegEncContext.CODEC_FLAG_TRUNCATED;
  if (c.avcodec_open(codec) < 0) {
    System.out.println(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    frame=0;
    int dataPointer;
    int[] cacheRead=new int[3];
    cacheRead[0]=stream.read();
    cacheRead[1]=stream.read();
    cacheRead[2]=stream.read();
    while (!(cacheRead[0] == 0x00 && cacheRead[1] == 0x00 && cacheRead[2] == 0x01)) {
      cacheRead[0]=cacheRead[1];
      cacheRead[1]=cacheRead[2];
      cacheRead[2]=stream.read();
    }
    boolean hasMoreNAL=true;
    inbuf_int[0]=inbuf_int[1]=inbuf_int[2]=0x00;
    inbuf_int[3]=0x01;
    while (hasMoreNAL) {
      dataPointer=4;
      cacheRead[0]=stream.read();
      if (cacheRead[0] == -1)       hasMoreNAL=false;
      cacheRead[1]=stream.read();
      if (cacheRead[1] == -1)       hasMoreNAL=false;
      cacheRead[2]=stream.read();
      if (cacheRead[2] == -1)       hasMoreNAL=false;
      while (!(cacheRead[0] == 0x00 && cacheRead[1] == 0x00 && cacheRead[2] == 0x01) && hasMoreNAL) {
        inbuf_int[dataPointer++]=cacheRead[0];
        cacheRead[0]=cacheRead[1];
        cacheRead[1]=cacheRead[2];
        cacheRead[2]=stream.read();
        if (cacheRead[2] == -1)         hasMoreNAL=false;
      }
      avpkt.size=dataPointer;
      avpkt.data_base=inbuf_int;
      avpkt.data_offset=0;
      try {
        while (avpkt.size > 0) {
          len=c.avcodec_decode_video2(picture,got_picture,avpkt);
          if (len < 0) {
            if (DEBUG)             System.out.println(""String_Node_Str"" + len);
            break;
          }
          if (got_picture[0] != 0) {
            picture=c.priv_data.displayPicture;
            callback.imageUpdated(picture);
            ++frame;
          }
 else {
            if (DEBUG)             System.out.println(""String_Node_Str"" + got_picture[0]);
            break;
          }
          avpkt.size-=len;
          avpkt.data_offset+=len;
        }
      }
 catch (      Exception ie) {
        ie.printStackTrace();
      }
    }
  }
  finally {
    c.avcodec_close();
    c=null;
    picture=null;
    System.out.println(""String_Node_Str"");
  }
  if (DEBUG)   System.out.println(""String_Node_Str"");
  return true;
}"
13805,"/** 
 * Stop a SignalFlow computation.
 * @param handle computation id
 * @param parameters computation parameter
 */
public void stop(String handle,Map<String,String> parameters);","/** 
 * Stop a SignalFlow computation.
 * @param handle computation id
 * @param parameters computation parameter
 */
void stop(String handle,Map<String,String> parameters);"
13806,"/** 
 * Keepalive a SignalFlow computation.
 * @param handle computation id
 */
public void keepalive(String handle);","/** 
 * Keep-alive a SignalFlow computation.
 * @param handle computation id
 */
void keepalive(String handle);"
13807,"/** 
 * Start executing the given SignalFlow program without being attached to the output of the computation.
 * @param program computation written in signalflow language
 * @param parameters computation parameters
 */
public void start(String program,Map<String,String> parameters);","/** 
 * Start executing the given SignalFlow program without being attached to the output of the computation.
 * @param program computation written in signalflow language
 * @param parameters computation parameters
 */
void start(String program,Map<String,String> parameters);"
13808,"/** 
 * Attach to an existing SignalFlow computation.
 * @param handle computation id
 * @param parameters computation parameters
 * @return An open channel attached to the given computation.
 */
public Channel attach(String handle,Map<String,String> parameters);","/** 
 * Attach to an existing SignalFlow computation.
 * @param handle computation id
 * @param parameters computation parameters
 * @return An open channel attached to the given computation.
 */
Channel attach(String handle,Map<String,String> parameters);"
13809,"/** 
 * Execute the given SignalFlow program and stream the output back.
 * @param program computation written in signalflow language
 * @param parameters computation parameters
 * @return An open channel attached to the newly started computation.
 */
public Channel execute(String program,Map<String,String> parameters);","/** 
 * Execute the given SignalFlow program and stream the output back.
 * @param program computation written in signalflow language
 * @param parameters computation parameters
 * @return An open channel attached to the newly started computation.
 */
Channel execute(String program,Map<String,String> parameters);"
13810,"/** 
 * Close this SignalFlow transport.
 * @param code numeric error id
 * @param reason Optional description of why closing
 */
public void close(int code,String reason);","/** 
 * Close this SignalFlow transport.
 * @param code numeric error id
 * @param reason Optional description of why closing
 */
void close(int code,String reason);"
13811,"/** 
 * Execute a preflight of the given SignalFlow program and stream the output back.
 * @param program computation written in signalflow language
 * @param parameters
 * @return
 */
public Channel preflight(String program,Map<String,String> parameters);","/** 
 * Execute a preflight of the given SignalFlow program and stream the output back.
 * @param program computation written in signalflow language
 * @param parameters computation parameters
 * @return An open channel attached to the newly started preflight computation.
 */
Channel preflight(String program,Map<String,String> parameters);"
13812,"@Test public void testReporter() throws InterruptedException {
  StoredDataPointReceiver dbank=new StoredDataPointReceiver();
  assertEquals(0,dbank.addDataPoints.size());
  MetricRegistry metricRegistery=new MetricRegistry();
  SignalFuseReporter reporter=new SignalFuseReporter.Builder(metricRegistery,new StaticAuthToken(""String_Node_Str""),""String_Node_Str"").setDataPointReceiverFactory(new StaticDataPointReceiverFactory(dbank)).setDetailsToAdd(ImmutableSet.of(SignalFuseReporter.MetricDetails.COUNT,SignalFuseReporter.MetricDetails.MIN,SignalFuseReporter.MetricDetails.MAX)).build();
  metricRegistery.register(""String_Node_Str"",new Gauge<Integer>(){
    public Integer getValue(){
      return 1;
    }
  }
);
  reporter.getMetricMetadata().tagMetric(metricRegistery.counter(""String_Node_Str"")).withMetricName(""String_Node_Str"").withSourceName(""String_Node_Str"").withMetricType(SignalFuseProtocolBuffers.MetricType.GAUGE);
  metricRegistery.counter(""String_Node_Str"").inc();
  metricRegistery.counter(""String_Node_Str"").inc();
  metricRegistery.timer(""String_Node_Str"").time().close();
  reporter.report();
  assertEquals(5,dbank.addDataPoints.size());
  assertEquals(""String_Node_Str"",dbank.addDataPoints.get(1).getMetric());
  assertEquals(""String_Node_Str"",dbank.addDataPoints.get(1).getSource());
  assertEquals(SignalFuseProtocolBuffers.MetricType.GAUGE,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.CUMULATIVE_COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.GAUGE,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(2,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(""String_Node_Str"",dbank.addDataPoints.get(2).getMetric());
  dbank.addDataPoints.clear();
  reporter.getMetricMetadata().tagMetric(metricRegistery.counter(""String_Node_Str"")).withMetricType(SignalFuseProtocolBuffers.MetricType.COUNTER);
  SfUtil.cumulativeCounter(metricRegistery,""String_Node_Str"",reporter.getMetricMetadata(),new Gauge<Long>(){
    private long i=0;
    @Override public Long getValue(){
      return i++;
    }
  }
);
  metricRegistery.counter(""String_Node_Str"").inc(10);
  reporter.report();
  assertEquals(7,dbank.addDataPoints.size());
  assertEquals(10,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(0,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(SignalFuseProtocolBuffers.MetricType.COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.CUMULATIVE_COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  metricRegistery.counter(""String_Node_Str"").inc(14);
  dbank.addDataPoints.clear();
  reporter.report();
  assertEquals(7,dbank.addDataPoints.size());
  assertEquals(14,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(1,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
}","@Test public void testReporter() throws InterruptedException {
  StoredDataPointReceiver dbank=new StoredDataPointReceiver();
  assertEquals(0,dbank.addDataPoints.size());
  MetricRegistry metricRegistery=new MetricRegistry();
  SignalFuseReporter reporter=new SignalFuseReporter.Builder(metricRegistery,new StaticAuthToken(""String_Node_Str""),""String_Node_Str"").setDataPointReceiverFactory(new StaticDataPointReceiverFactory(dbank)).setDetailsToAdd(ImmutableSet.of(SignalFuseReporter.MetricDetails.COUNT,SignalFuseReporter.MetricDetails.MIN,SignalFuseReporter.MetricDetails.MAX)).build();
  metricRegistery.register(""String_Node_Str"",new Gauge<Integer>(){
    public Integer getValue(){
      return 1;
    }
  }
);
  reporter.getMetricMetadata().tagMetric(metricRegistery.counter(""String_Node_Str"")).withMetricName(""String_Node_Str"").withSourceName(""String_Node_Str"").withMetricType(SignalFuseProtocolBuffers.MetricType.GAUGE);
  reporter.getMetricMetadata().tagMetric(metricRegistery.counter(""String_Node_Str"")).withMetricName(""String_Node_Str"");
  metricRegistery.counter(""String_Node_Str"").inc();
  metricRegistery.counter(""String_Node_Str"").inc();
  metricRegistery.timer(""String_Node_Str"").time().close();
  reporter.report();
  assertEquals(6,dbank.addDataPoints.size());
  assertEquals(""String_Node_Str"",dbank.addDataPoints.get(1).getMetric());
  assertEquals(""String_Node_Str"",dbank.addDataPoints.get(1).getSource());
  assertEquals(SignalFuseProtocolBuffers.MetricType.GAUGE,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.CUMULATIVE_COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.GAUGE,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(2,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertNotNull(dbank.lastValueFor(""String_Node_Str"",""String_Node_Str""));
  dbank.addDataPoints.clear();
  reporter.getMetricMetadata().tagMetric(metricRegistery.counter(""String_Node_Str"")).withMetricType(SignalFuseProtocolBuffers.MetricType.COUNTER);
  SfUtil.cumulativeCounter(metricRegistery,""String_Node_Str"",reporter.getMetricMetadata(),new Gauge<Long>(){
    private long i=0;
    @Override public Long getValue(){
      return i++;
    }
  }
);
  metricRegistery.counter(""String_Node_Str"").inc(10);
  reporter.report();
  assertEquals(8,dbank.addDataPoints.size());
  assertEquals(10,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(0,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(SignalFuseProtocolBuffers.MetricType.COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.CUMULATIVE_COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  metricRegistery.counter(""String_Node_Str"").inc(14);
  dbank.addDataPoints.clear();
  reporter.report();
  assertEquals(8,dbank.addDataPoints.size());
  assertEquals(14,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(1,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
}"
13813,"/** 
 * @Deprecated
 */
T withSourceName(String sourceName);","/** 
 * Tag the metric with a sf_source
 * @param sourceName    Source name for the sf_source
 * @return this
 * @deprecated The use of the build in source parameter is deprecated and discouraged.  Use{@link #withDimension(String,String)} instead.
 */
T withSourceName(String sourceName);"
13814,"/** 
 * Construct the basic JVM metrics using a supplied SignalFuse MetricFactory.
 * @param metricRegistry
 */
public BasicJvmMetrics(MetricRegistry metricRegistry){
  runtimeBean=ManagementFactory.getRuntimeMXBean();
  memoryBean=ManagementFactory.getMemoryMXBean();
  threadBean=ManagementFactory.getThreadMXBean();
  for (  GarbageCollectorMXBean gcBean : ManagementFactory.getGarbageCollectorMXBeans()) {
    allGcBeans.add(gcBean);
    Set<String> poolNames=new HashSet<String>(Arrays.asList(gcBean.getMemoryPoolNames()));
    if (poolNames.contains(OLD_GEN_POOL_NAME)) {
      oldGenGcBeans.add(gcBean);
    }
 else {
      youngGenGcBeans.add(gcBean);
    }
  }
  this.uptimeGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new UptimeCallback());
  this.totalMemoryGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new TotalMemoryCallback());
  this.usedMemoryGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new UsedMemoryCallback());
  this.maxMemoryGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new MaxMemoryCallback());
  this.cpuLoadGauge=createDoublePeriodicGauge(metricRegistry,""String_Node_Str"",new CpuLoadCallback());
  this.totalThreadCountGauge=createIntegerPeriodicGauge(metricRegistry,""String_Node_Str"",new TotalThreadCountCallback());
  this.daemonThreadCountGauge=createIntegerPeriodicGauge(metricRegistry,""String_Node_Str"",new DaemonThreadCountCallback());
  this.gcTimeGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new GcTimeCallback());
  this.gcLoadGauge=createDoublePeriodicGauge(metricRegistry,""String_Node_Str"",new GcLoadCallback());
  this.gcYoungCountGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new GcCountCallback(youngGenGcBeans));
  this.gcOldCountGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new GcCountCallback(oldGenGcBeans));
}","/** 
 * Construct the basic JVM metrics using a supplied SignalFuse MetricFactory.
 * @param metricRegistry The registry to give these metrics to
 */
public BasicJvmMetrics(MetricRegistry metricRegistry){
  runtimeBean=ManagementFactory.getRuntimeMXBean();
  memoryBean=ManagementFactory.getMemoryMXBean();
  threadBean=ManagementFactory.getThreadMXBean();
  for (  GarbageCollectorMXBean gcBean : ManagementFactory.getGarbageCollectorMXBeans()) {
    allGcBeans.add(gcBean);
    Set<String> poolNames=new HashSet<String>(Arrays.asList(gcBean.getMemoryPoolNames()));
    if (poolNames.contains(OLD_GEN_POOL_NAME)) {
      oldGenGcBeans.add(gcBean);
    }
 else {
      youngGenGcBeans.add(gcBean);
    }
  }
  this.uptimeGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new UptimeCallback());
  this.totalMemoryGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new TotalMemoryCallback());
  this.usedMemoryGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new UsedMemoryCallback());
  this.maxMemoryGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new MaxMemoryCallback());
  this.cpuLoadGauge=createDoublePeriodicGauge(metricRegistry,""String_Node_Str"",new CpuLoadCallback());
  this.totalThreadCountGauge=createIntegerPeriodicGauge(metricRegistry,""String_Node_Str"",new TotalThreadCountCallback());
  this.daemonThreadCountGauge=createIntegerPeriodicGauge(metricRegistry,""String_Node_Str"",new DaemonThreadCountCallback());
  this.gcTimeGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new GcTimeCallback());
  this.gcLoadGauge=createDoublePeriodicGauge(metricRegistry,""String_Node_Str"",new GcLoadCallback());
  this.gcYoungCountGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new GcCountCallback(youngGenGcBeans));
  this.gcOldCountGauge=createPeriodicGauge(metricRegistry,""String_Node_Str"",new GcCountCallback(oldGenGcBeans));
}"
13815,"@Override public Long getValue(){
  return customerQueue.size();
}","@Override public Long getValue(){
  return i++;
}"
13816,"@Test public void testReporter() throws InterruptedException {
  StoredDataPointReceiver dbank=new StoredDataPointReceiver();
  assertEquals(0,dbank.addDataPoints.size());
  MetricRegistry metricRegistery=new MetricRegistry();
  SignalFuseReporter reporter=new SignalFuseReporter.Builder(metricRegistery,new StaticAuthToken(""String_Node_Str""),""String_Node_Str"").setDataPointReceiverFactory(new StaticDataPointReceiverFactory(dbank)).setDetailsToAdd(ImmutableSet.of(SignalFuseReporter.MetricDetails.COUNT,SignalFuseReporter.MetricDetails.MIN,SignalFuseReporter.MetricDetails.MAX)).build();
  Metric gauge=metricRegistery.register(""String_Node_Str"",new Gauge<Integer>(){
    public Integer getValue(){
      return 1;
    }
  }
);
  final MetricMetadata metricMetadata=reporter.getMetricMetadata();
  metricMetadata.forMetric(metricRegistery.counter(""String_Node_Str"")).withMetricName(""String_Node_Str"").withSourceName(""String_Node_Str"").withMetricType(SignalFuseProtocolBuffers.MetricType.GAUGE);
  metricMetadata.forMetric(metricRegistery.counter(""String_Node_Str"")).withMetricName(""String_Node_Str"");
  metricRegistery.counter(""String_Node_Str"").inc();
  metricRegistery.counter(""String_Node_Str"").inc();
  metricRegistery.timer(""String_Node_Str"").time().close();
  reporter.report();
  assertEquals(6,dbank.addDataPoints.size());
  assertEquals(""String_Node_Str"",dbank.addDataPoints.get(1).getMetric());
  assertEquals(""String_Node_Str"",dbank.addDataPoints.get(1).getSource());
  assertEquals(SignalFuseProtocolBuffers.MetricType.GAUGE,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.CUMULATIVE_COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.GAUGE,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(2,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertNotNull(dbank.lastValueFor(""String_Node_Str"",""String_Node_Str""));
  dbank.addDataPoints.clear();
  metricMetadata.forMetric(metricRegistery.counter(""String_Node_Str"")).withMetricType(SignalFuseProtocolBuffers.MetricType.COUNTER);
  SfUtil.cumulativeCounter(metricRegistery,""String_Node_Str"",metricMetadata,new Gauge<Long>(){
    private long i=0;
    @Override public Long getValue(){
      return i++;
    }
  }
);
  final Queue customerQueue=new ArrayBlockingQueue();
  metricMetadata.forMetric(new Gauge<Long>(){
    @Override public Long getValue(){
      return customerQueue.size();
    }
  }
).withDimension(""String_Node_Str"",""String_Node_Str"").register(metricRegistery);
  Counter distributedCounter=metricMetadata.forMetric(new IncrementalCounter()).withDimension(""String_Node_Str"",""String_Node_Str"").withMetricName(""String_Node_Str"").withSourceName(""String_Node_Str"").register(metricRegistery);
  assertNotNull(metricRegistery.getCounters().get(""String_Node_Str""));
  distributedCounter.inc(123);
  metricRegistery.counter(""String_Node_Str"").inc(10);
  metricMetadata.forBuilder(IncrementalCounter.Builder.INSTANCE).withSourceName(""String_Node_Str"").withMetricName(""String_Node_Str"").createOrGet(metricRegistery).inc(1);
  try {
    metricMetadata.forBuilder(SettableLongGauge.Builder.INSTANCE).withSourceName(""String_Node_Str"").withMetricName(""String_Node_Str"").createOrGet(metricRegistery);
    throw new RuntimeException(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  reporter.report();
  assertEquals(10,dbank.addDataPoints.size());
  assertEquals(10,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(0,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(123,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(1,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(2,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  distributedCounter.inc(1);
  distributedCounter.inc(3);
  assertEquals(SignalFuseProtocolBuffers.MetricType.COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.CUMULATIVE_COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  metricRegistery.counter(""String_Node_Str"").inc(14);
  dbank.addDataPoints.clear();
  metricMetadata.forBuilder(IncrementalCounter.Builder.INSTANCE).withSourceName(""String_Node_Str"").withMetricName(""String_Node_Str"").createOrGet(metricRegistery).inc(3);
  assertEquals(0,SfUtil.removeMetrics(metricRegistery,new Counter()));
  assertEquals(2,SfUtil.removeMetrics(metricRegistery,gauge,metricRegistery.counter(""String_Node_Str"")));
  assertEquals(true,dbank.clearValues(""String_Node_Str"",""String_Node_Str""));
  assertEquals(false,dbank.clearValues(""String_Node_Str"",""String_Node_Str""));
  reporter.report();
  assertEquals(8,dbank.addDataPoints.size());
  assertEquals(0,dbank.valuesFor(""String_Node_Str"",""String_Node_Str"").size());
  assertEquals(24,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(1,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(4,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(3,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  try {
    metricMetadata.forBuilder(IncrementalCounter.Builder.INSTANCE).withSourceName(""String_Node_Str"").withMetricName(""String_Node_Str"").withMetricType(SignalFuseProtocolBuffers.MetricType.GAUGE).createOrGet(metricRegistery);
    throw new RuntimeException(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  metricMetadata.forMetric(new Counter()).withSourceName(""String_Node_Str"").withMetricName(""String_Node_Str"").register(metricRegistery);
  try {
    metricMetadata.forBuilder(IncrementalCounter.Builder.INSTANCE).withSourceName(""String_Node_Str"").withMetricName(""String_Node_Str"").createOrGet(metricRegistery);
    throw new RuntimeException(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
}","@Test public void testReporter() throws InterruptedException {
  StoredDataPointReceiver dbank=new StoredDataPointReceiver();
  assertEquals(0,dbank.addDataPoints.size());
  MetricRegistry metricRegistery=new MetricRegistry();
  SignalFuseReporter reporter=new SignalFuseReporter.Builder(metricRegistery,new StaticAuthToken(""String_Node_Str""),""String_Node_Str"").setDataPointReceiverFactory(new StaticDataPointReceiverFactory(dbank)).setDetailsToAdd(ImmutableSet.of(SignalFuseReporter.MetricDetails.COUNT,SignalFuseReporter.MetricDetails.MIN,SignalFuseReporter.MetricDetails.MAX)).build();
  Metric gauge=metricRegistery.register(""String_Node_Str"",new Gauge<Integer>(){
    public Integer getValue(){
      return 1;
    }
  }
);
  final MetricMetadata metricMetadata=reporter.getMetricMetadata();
  metricMetadata.forMetric(metricRegistery.counter(""String_Node_Str"")).withMetricName(""String_Node_Str"").withSourceName(""String_Node_Str"").withMetricType(SignalFuseProtocolBuffers.MetricType.GAUGE);
  metricMetadata.forMetric(metricRegistery.counter(""String_Node_Str"")).withMetricName(""String_Node_Str"");
  metricRegistery.counter(""String_Node_Str"").inc();
  metricRegistery.counter(""String_Node_Str"").inc();
  metricRegistery.timer(""String_Node_Str"").time().close();
  reporter.report();
  assertEquals(6,dbank.addDataPoints.size());
  assertEquals(""String_Node_Str"",dbank.addDataPoints.get(1).getMetric());
  assertEquals(""String_Node_Str"",dbank.addDataPoints.get(1).getSource());
  assertEquals(SignalFuseProtocolBuffers.MetricType.GAUGE,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.CUMULATIVE_COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.GAUGE,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(2,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertNotNull(dbank.lastValueFor(""String_Node_Str"",""String_Node_Str""));
  dbank.addDataPoints.clear();
  metricMetadata.forMetric(metricRegistery.counter(""String_Node_Str"")).withMetricType(SignalFuseProtocolBuffers.MetricType.COUNTER);
  SfUtil.cumulativeCounter(metricRegistery,""String_Node_Str"",metricMetadata,new Gauge<Long>(){
    private long i=0;
    @Override public Long getValue(){
      return i++;
    }
  }
);
  Counter distributedCounter=metricMetadata.forMetric(new IncrementalCounter()).withMetricName(""String_Node_Str"").withSourceName(""String_Node_Str"").register(metricRegistery);
  assertNotNull(metricRegistery.getCounters().get(""String_Node_Str""));
  distributedCounter.inc(123);
  metricRegistery.counter(""String_Node_Str"").inc(10);
  metricMetadata.forBuilder(IncrementalCounter.Builder.INSTANCE).withSourceName(""String_Node_Str"").withMetricName(""String_Node_Str"").createOrGet(metricRegistery).inc(1);
  try {
    metricMetadata.forBuilder(SettableLongGauge.Builder.INSTANCE).withSourceName(""String_Node_Str"").withMetricName(""String_Node_Str"").createOrGet(metricRegistery);
    throw new RuntimeException(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  reporter.report();
  assertEquals(10,dbank.addDataPoints.size());
  assertEquals(10,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(0,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(123,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(1,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(2,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  distributedCounter.inc(1);
  distributedCounter.inc(3);
  assertEquals(SignalFuseProtocolBuffers.MetricType.COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  assertEquals(SignalFuseProtocolBuffers.MetricType.CUMULATIVE_COUNTER,dbank.registeredMetrics.get(""String_Node_Str""));
  metricRegistery.counter(""String_Node_Str"").inc(14);
  dbank.addDataPoints.clear();
  metricMetadata.forBuilder(IncrementalCounter.Builder.INSTANCE).withSourceName(""String_Node_Str"").withMetricName(""String_Node_Str"").createOrGet(metricRegistery).inc(3);
  assertEquals(0,SfUtil.removeMetrics(metricRegistery,new Counter()));
  assertEquals(2,SfUtil.removeMetrics(metricRegistery,gauge,metricRegistery.counter(""String_Node_Str"")));
  assertEquals(true,dbank.clearValues(""String_Node_Str"",""String_Node_Str""));
  assertEquals(false,dbank.clearValues(""String_Node_Str"",""String_Node_Str""));
  reporter.report();
  assertEquals(8,dbank.addDataPoints.size());
  assertEquals(0,dbank.valuesFor(""String_Node_Str"",""String_Node_Str"").size());
  assertEquals(24,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(1,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(4,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  assertEquals(3,dbank.lastValueFor(""String_Node_Str"",""String_Node_Str"").getIntValue());
  try {
    metricMetadata.forBuilder(IncrementalCounter.Builder.INSTANCE).withSourceName(""String_Node_Str"").withMetricName(""String_Node_Str"").withMetricType(SignalFuseProtocolBuffers.MetricType.GAUGE).createOrGet(metricRegistery);
    throw new RuntimeException(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  metricMetadata.forMetric(new Counter()).withSourceName(""String_Node_Str"").withMetricName(""String_Node_Str"").register(metricRegistery);
  try {
    metricMetadata.forBuilder(IncrementalCounter.Builder.INSTANCE).withSourceName(""String_Node_Str"").withMetricName(""String_Node_Str"").createOrGet(metricRegistery);
    throw new RuntimeException(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
}"
13817,"/** 
 * Nb. Post-constructor for what is inside the class such as methods, members etc. + imports. Both this method and the super class'es   {@link ObjectType#initType}methods must be called for the class to be fully initialized and ready for use. Must be called only once.
 * @param members Member variables for class.
 * @param properties Property methods for class.
 * @param nonPropertyMethods Other methods for class.
 */
public void initContent(List<Member> members,List<Property> properties,List<Method> nonPropertyMethods){
  if (initializedContent)   throw new IllegalStateException(""String_Node_Str"");
  this.members=Objects.requireNonNull(members);
  this.properties=Objects.requireNonNull(properties);
  this.methods=Objects.requireNonNull(nonPropertyMethods);
  initializedContent=true;
}","/** 
 * Nb. Post-constructor for what is inside the class such as methods, members etc. + imports. Both this method and the super class'es   {@link ObjectType#initType}methods must be called for the class to be fully initialized and ready for use. Must be called only once.
 * @param members Member variables for class.
 * @param methods Other methods for class.
 * @param declaredModifiers declared clazz modifiers (empty if a new Clazz)
 */
public void initContent(List<Member> members,List<Method> methods,EnumSet<Modifier> declaredModifiers){
  if (initializedContent)   throw new IllegalStateException(""String_Node_Str"");
  this.members=Objects.requireNonNull(members);
  this.methods=Objects.requireNonNull(methods);
  this.declaredModifiers=Objects.requireNonNull(declaredModifiers);
  initializedContent=true;
}"
13818,"public BasicClazz(Configuration configuration,String qualifiedProtoTypicalTypeName,ThrowingFunction<BasicClazz,HelperTypes> helperFactoryMethod) throws Exception {
  super(qualifiedProtoTypicalTypeName);
  super.clazzUsingType=this;
  this.configuration=Objects.requireNonNull(configuration);
  this.packageName=getPackageFromQualifiedName(qualifiedProtoTypicalTypeName);
  this.helperTypes=helperFactoryMethod.apply(this);
  this.properties=new ArrayList<Property>();
  this.methods=new ArrayList<Method>();
  this.members=new ArrayList<Member>();
  initializedContent=false;
}","public BasicClazz(BasicClazz optClazzUsingType,Configuration configuration,String qualifiedProtoTypicalTypeName,ThrowingFunction<BasicClazz,HelperTypes> helperFactoryMethod,NoType noType) throws Exception {
  super(optClazzUsingType,qualifiedProtoTypicalTypeName,noType);
  this.configuration=Objects.requireNonNull(configuration);
  this.packageName=getPackageFromQualifiedName(qualifiedProtoTypicalTypeName);
  this.helperTypes=helperFactoryMethod.apply(this);
  this.methods=new ArrayList<Method>();
  this.members=new ArrayList<Member>();
  this.declaredModifiers=EnumSet.noneOf(Modifier.class);
  initializedContent=false;
}"
13819,"@Override public String toString(int level){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)));
  if (level < MAX_RECURSIVE_LEVEL) {
    sb.append(""String_Node_Str"" + initialized() + ""String_Node_Str""+ qualifiedProtoTypicalTypeName);
  }
  if (level == 0) {
    sb.append(""String_Node_Str"" + packageName + System.lineSeparator()+ ""String_Node_Str""+ baseClazzType.toString(level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ interfaceTypes.stream().map(t -> t.toString(level + 1)).collect(Collectors.joining(""String_Node_Str"" + System.lineSeparator()))+ ""String_Node_Str""+ System.lineSeparator()+ ""String_Node_Str""+ interfaceTypesWithAscendants.stream().map(t -> t.toString(level + 1)).collect(Collectors.joining(""String_Node_Str"" + System.lineSeparator()))+ ""String_Node_Str""+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(genericTypeArguments,level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(members,level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(properties,level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(methods,level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ configuration+ ""String_Node_Str""+ System.lineSeparator());
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(int level){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)));
  if (level < MAX_RECURSIVE_LEVEL) {
    sb.append(""String_Node_Str"" + initialized() + ""String_Node_Str""+ qualifiedProtoTypicalTypeName);
  }
  if (level <= 0) {
    sb.append(""String_Node_Str"" + packageName + System.lineSeparator()+ ""String_Node_Str""+ baseClazzType.toString(level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ interfaceTypes.stream().map(t -> t.toString(level + 1)).collect(Collectors.joining(""String_Node_Str"" + System.lineSeparator()))+ ""String_Node_Str""+ System.lineSeparator()+ ""String_Node_Str""+ superTypesWithAscendants.stream().map(t -> t.toString(level + 1)).collect(Collectors.joining(""String_Node_Str"" + System.lineSeparator()))+ ""String_Node_Str""+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(genericTypeArguments,""String_Node_Str"",level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(members,System.lineSeparator(),level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(methods,System.lineSeparator(),level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ declaredModifiers);
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
13820,"/** 
 * Nb. Post-constructor for what is inside the class such as methods, members etc. + imports. Calls super class'es initContent internally Both this method and the ancestor class'es   {@link ObjectType#initType}methods must be called for the class to be fully initialized and ready for use. Must be called only once.
 * @param members Member variables for class.
 * @param properties Property methods for class.
 * @param nonPropertyMethods Other methods for class.
 * @param importTypes Types to be imported for class.
 * @param chosenComparableMembers Members to be used for compareToOperation
 */
public void initContent(List<Member> members,List<Property> properties,List<Method> nonPropertyMethods,List<Type> importTypes,List<Member> chosenComparableMembers){
  super.initContent(members,properties,nonPropertyMethods);
  this.importTypes=Objects.requireNonNull(importTypes);
  this.chosenComparableMembers=Objects.requireNonNull(chosenComparableMembers);
}","/** 
 * Nb. Post-constructor for what is inside the class such as methods, members etc. + imports. Calls super class'es initContent internally Both this method and the ancestor class'es   {@link ObjectType#initType}methods must be called for the class to be fully initialized and ready for use. Must be called only once.
 * @param members Member variables for class.
 * @param properties Property methods for class.
 * @param methods Non-property methods for class.
 * @param importTypes Types to be imported for class.
 * @param chosenComparableMembers Members to be used for compareToOperation
 */
public void initContent(List<Member> members,List<Property> properties,List<Method> methods,List<Type> importTypes,List<Member> chosenComparableMembers){
  super.initContent(members,methods,EnumSet.noneOf(Modifier.class));
  this.properties=Objects.requireNonNull(properties);
  this.importTypes=Objects.requireNonNull(importTypes);
  this.chosenComparableMembers=Objects.requireNonNull(chosenComparableMembers);
}"
13821,"/** 
 * Constructs a prelimiary Clazz instance from a configuration with only a few values such as name specificed in advanced. After constructing the instance, the various setters must be used to finish initialization.
 * @param configuration The configuration of how generated code should look.
 * @param qualifiedClassName The full name of the class that should be generated.
 * @param qualifiedMaster The fill name of the item this class was generated from.
 * @param javaDoc JavaDoc if any.
 * @param fileHeaderText Text to output as header for file(s).
 * @param helperFactoryMethod Method that can generate helper types for this class.
 * @throws Exception Exception if could not construct clazz.
 */
public Clazz(Configuration configuration,String qualifiedClassName,String qualifiedMaster,String javaDoc,String fileHeaderText,ThrowingFunction<BasicClazz,HelperTypes> helperFactoryMethod) throws Exception {
  super(configuration,qualifiedClassName,helperFactoryMethod);
  super.clazzUsingType=this;
  this.qualifiedMaster=qualifiedMaster;
  this.interfaceTypes=new ArrayList<Type>();
  this.baseClazzType=new NoType(this);
  this.javaDoc=Objects.requireNonNull(javaDoc);
  this.fileHeaderText=Objects.requireNonNull(fileHeaderText);
  this.importTypes=new ArrayList<Type>();
}","/** 
 * Constructs a prelimiary Clazz instance from a configuration with only a few values such as name specificed in advanced. After constructing the instance, the various setters must be used to finish initialization.
 * @param configuration The configuration of how generated code should look.
 * @param qualifiedClassName The full name of the class that should be generated.
 * @param qualifiedMaster The fill name of the item this class was generated from.
 * @param javaDoc JavaDoc if any.
 * @param fileHeaderText Text to output as header for file(s).
 * @param helperFactoryMethod Method that can generate helper types for this class.
 * @param noType Helper type that represents no-type.
 * @throws Exception Exception if could not construct clazz.
 */
public Clazz(Configuration configuration,String qualifiedClassName,String qualifiedMaster,String javaDoc,String fileHeaderText,ThrowingFunction<BasicClazz,HelperTypes> helperFactoryMethod,NoType noType) throws Exception {
  super(null,configuration,qualifiedClassName,helperFactoryMethod,noType);
  super.clazzUsingType=this;
  this.qualifiedMaster=qualifiedMaster;
  this.interfaceTypes=new ArrayList<Type>();
  this.baseClazzType=noType;
  this.javaDoc=Objects.requireNonNull(javaDoc);
  this.fileHeaderText=Objects.requireNonNull(fileHeaderText);
  this.importTypes=new ArrayList<Type>();
}"
13822,"@Override public String toString(int level){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)));
  if (level < MAX_RECURSIVE_LEVEL) {
    sb.append(""String_Node_Str"" + initialized() + ""String_Node_Str""+ qualifiedProtoTypicalTypeName);
  }
  if (level == 0) {
    sb.append(""String_Node_Str"" + packageName + System.lineSeparator()+ ""String_Node_Str""+ baseClazzType.toString(level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ interfaceTypes.stream().map(t -> t.toString(level + 1)).collect(Collectors.joining(""String_Node_Str"" + System.lineSeparator()))+ ""String_Node_Str""+ System.lineSeparator()+ ""String_Node_Str""+ interfaceTypesWithAscendants.stream().map(t -> t.toString(level + 1)).collect(Collectors.joining(""String_Node_Str"" + System.lineSeparator()))+ ""String_Node_Str""+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(importTypes,level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(genericTypeArguments,level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(members,level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(properties,level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(methods,level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ configuration+ ""String_Node_Str""+ System.lineSeparator());
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(int level){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)));
  if (level < MAX_RECURSIVE_LEVEL) {
    sb.append(""String_Node_Str"" + initialized() + ""String_Node_Str""+ qualifiedProtoTypicalTypeName);
  }
  if (level == 0) {
    sb.append(""String_Node_Str"" + packageName + System.lineSeparator()+ ""String_Node_Str""+ baseClazzType.toString(level)+ System.lineSeparator()+ ""String_Node_Str""+ interfaceTypes.stream().map(t -> t.toString(level + 1)).collect(Collectors.joining(""String_Node_Str"" + System.lineSeparator()))+ ""String_Node_Str""+ System.lineSeparator()+ ""String_Node_Str""+ superTypesWithAscendants.stream().map(t -> t.toString(level + 1)).collect(Collectors.joining(""String_Node_Str"" + System.lineSeparator()))+ ""String_Node_Str""+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(importTypes,""String_Node_Str"",level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(genericTypeArguments,""String_Node_Str"",level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(members,System.lineSeparator(),level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(properties,System.lineSeparator(),level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ ToStringUtil.toString(methods,System.lineSeparator(),level + 1)+ System.lineSeparator());
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
13823,"public List<Method> getClaimedImplementationMethods(){
  return methods.stream().filter(m -> m.implementationInfo == ImplementationInfo.IMPLEMENTATION_CLAIMED_BY_GENERATED_OBJECT).collect(Collectors.toList());
}","public List<Method> getClaimedImplementationMethods(){
  return methods.stream().filter(m -> m.implementationInfo == ImplementationInfo.IMPLEMENTATION_PROVIDED_BY_THIS_OBJECT).collect(Collectors.toList());
}"
13824,"/** 
 * {@inheritDoc}
 */
@Override public final char[] getCharArray(){
  return charArray;
}","/** 
 * {@inheritDoc}
 */
@Override public char[] getCharArray(){
  return charArray;
}"
13825,"/** 
 * {@inheritDoc}
 */
@Override public final int[][] getIntMultiArray(){
  return intMultiArray;
}","/** 
 * {@inheritDoc}
 */
@Override public int[][] getIntMultiArray(){
  return intMultiArray;
}"
13826,"/** 
 * {@inheritDoc}
 */
@Override public final byte getByte(){
  return _byte;
}","/** 
 * {@inheritDoc}
 */
@Override public byte getByte(){
  return _byte;
}"
13827,"/** 
 * {@inheritDoc}
 */
@Override public final long[][] getLongMultiArray(){
  return longMultiArray;
}","/** 
 * {@inheritDoc}
 */
@Override public long[][] getLongMultiArray(){
  return longMultiArray;
}"
13828,"/** 
 * {@inheritDoc}
 */
@Override public final double getDouble(){
  return _double;
}","/** 
 * {@inheritDoc}
 */
@Override public double getDouble(){
  return _double;
}"
13829,"/** 
 * {@inheritDoc}
 */
@Override public final double[][] getDoubleMultiArray(){
  return doubleMultiArray;
}","/** 
 * {@inheritDoc}
 */
@Override public double[][] getDoubleMultiArray(){
  return doubleMultiArray;
}"
13830,"/** 
 * {@inheritDoc}
 */
@Override public final float getFloat(){
  return _float;
}","/** 
 * {@inheritDoc}
 */
@Override public float getFloat(){
  return _float;
}"
13831,"/** 
 * {@inheritDoc}
 */
@Override public final double[] getDoubleArray(){
  return doubleArray;
}","/** 
 * {@inheritDoc}
 */
@Override public double[] getDoubleArray(){
  return doubleArray;
}"
13832,"/** 
 * {@inheritDoc}
 */
@Override public final boolean isBoolean(){
  return _boolean;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isBoolean(){
  return _boolean;
}"
13833,"/** 
 * {@inheritDoc}
 */
@Override public final java.util.Date getDate(){
  return date;
}","/** 
 * {@inheritDoc}
 */
@Override public java.util.Date getDate(){
  return date;
}"
13834,"/** 
 * {@inheritDoc}
 */
@Override public final boolean[] getBooleanArray(){
  return booleanArray;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean[] getBooleanArray(){
  return booleanArray;
}"
13835,"/** 
 * {@inheritDoc}
 */
@Override public final Object getObject(){
  return _object;
}","/** 
 * {@inheritDoc}
 */
@Override public Object getObject(){
  return _object;
}"
13836,"/** 
 * {@inheritDoc}
 */
@Override public final Object[][] getObjectMultiArray(){
  return objectMultiArray;
}","/** 
 * {@inheritDoc}
 */
@Override public Object[][] getObjectMultiArray(){
  return objectMultiArray;
}"
13837,"/** 
 * {@inheritDoc}
 */
@Override public final float[][] getFloatMultiArray(){
  return floatMultiArray;
}","/** 
 * {@inheritDoc}
 */
@Override public float[][] getFloatMultiArray(){
  return floatMultiArray;
}"
13838,"/** 
 * {@inheritDoc}
 */
@Override public final char[][] getCharMultiArray(){
  return charMultiArray;
}","/** 
 * {@inheritDoc}
 */
@Override public char[][] getCharMultiArray(){
  return charMultiArray;
}"
13839,"/** 
 * {@inheritDoc}
 */
@Override public final boolean[][] getBooleanMultiArray(){
  return booleanMultiArray;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean[][] getBooleanMultiArray(){
  return booleanMultiArray;
}"
13840,"/** 
 * {@inheritDoc}
 */
@Override public final ComplexInterfaceWithAllTypes getOther(){
  return other;
}","/** 
 * {@inheritDoc}
 */
@Override public ComplexInterfaceWithAllTypes getOther(){
  return other;
}"
13841,"/** 
 * {@inheritDoc}
 */
@Override public final Object[] getObjectArray(){
  return objectArray;
}","/** 
 * {@inheritDoc}
 */
@Override public Object[] getObjectArray(){
  return objectArray;
}"
13842,"/** 
 * {@inheritDoc}
 */
@Override public final String getString(){
  return _string;
}","/** 
 * {@inheritDoc}
 */
@Override public String getString(){
  return _string;
}"
13843,"/** 
 * {@inheritDoc}
 */
@Override public final float[] getFloatArray(){
  return floatArray;
}","/** 
 * {@inheritDoc}
 */
@Override public float[] getFloatArray(){
  return floatArray;
}"
13844,"/** 
 * {@inheritDoc}
 */
@Override public final long[] getLongArray(){
  return longArray;
}","/** 
 * {@inheritDoc}
 */
@Override public long[] getLongArray(){
  return longArray;
}"
13845,"/** 
 * {@inheritDoc}
 */
@Override public final long getLong(){
  return _long;
}","/** 
 * {@inheritDoc}
 */
@Override public long getLong(){
  return _long;
}"
13846,"/** 
 * {@inheritDoc}
 */
@Override public final int getInt(){
  return _int;
}","/** 
 * {@inheritDoc}
 */
@Override public int getInt(){
  return _int;
}"
13847,"/** 
 * {@inheritDoc}
 */
@Override public final char getChar(){
  return _char;
}","/** 
 * {@inheritDoc}
 */
@Override public char getChar(){
  return _char;
}"
13848,"/** 
 * {@inheritDoc}
 */
@Override public final byte[][] getByteMultiArray(){
  return byteMultiArray;
}","/** 
 * {@inheritDoc}
 */
@Override public byte[][] getByteMultiArray(){
  return byteMultiArray;
}"
13849,"/** 
 * {@inheritDoc}
 */
@Override public final byte[] getByteArray(){
  return byteArray;
}","/** 
 * {@inheritDoc}
 */
@Override public byte[] getByteArray(){
  return byteArray;
}"
13850,"/** 
 * {@inheritDoc}
 */
@Override public final int[] getIntArray(){
  return intArray;
}","/** 
 * {@inheritDoc}
 */
@Override public int[] getIntArray(){
  return intArray;
}"
13851,"/** 
 * {@inheritDoc}
 */
@Override public final Object getObject(){
  return _object;
}","/** 
 * {@inheritDoc}
 */
@Override public Object getObject(){
  return _object;
}"
13852,"/** 
 * {@inheritDoc}
 */
@Override public final String getValue(){
  return value;
}","/** 
 * {@inheritDoc}
 */
@Override public String getValue(){
  return value;
}"
13853,"/** 
 * {@inheritDoc}
 */
@Override public final void setValue(final String value){
  this.value=Objects.requireNonNull(value);
}","/** 
 * {@inheritDoc}
 */
@Override public void setValue(final String value){
  this.value=Objects.requireNonNull(value);
}"
13854,"/** 
 * {@inheritDoc}
 */
@Override public final Object getObject(){
  return _object;
}","/** 
 * {@inheritDoc}
 */
@Override public Object getObject(){
  return _object;
}"
13855,"/** 
 * {@inheritDoc}
 */
@Override public final String getString(){
  return _string;
}","/** 
 * {@inheritDoc}
 */
@Override public String getString(){
  return _string;
}"
13856,"/** 
 * Constructs a prelimiary Clazz instance from a configuration with only a few values such as name specificed in advanced. After constructing the instance, the various setters must be used to finish initialization.
 * @param configuration The configuration of how generated code should look.
 * @param qualifiedClassName The full name of the class that should be generated.
 * @param qualifiedMaster The fill name of the item this class was generated from.
 * @param javaDoc JavaDoc if any.
 * @param fileHeaderText Text to output as header for file(s).
 * @param helperFactoryMethod Method that can generate helper types for this class.
 * @param noType Helper type that represents no-type.
 * @throws Exception Exception if could not construct clazz.
 */
public Clazz(Configuration configuration,String qualifiedClassName,String qualifiedMaster,String javaDoc,String fileHeaderText,ThrowingFunction<BasicClazz,HelperTypes> helperFactoryMethod,NoType noType) throws Exception {
  super(null,configuration,qualifiedClassName,helperFactoryMethod,noType);
  super.clazzUsingType=this;
  this.qualifiedMaster=qualifiedMaster;
  this.interfaceTypes=new ArrayList<Type>();
  this.baseClazzType=noType;
  this.javaDoc=Objects.requireNonNull(javaDoc);
  this.fileHeaderText=Objects.requireNonNull(fileHeaderText);
  this.importTypes=new ArrayList<Type>();
  this.modifiers=EnumSet.noneOf(Modifier.class);
}","/** 
 * Constructs a prelimiary Clazz instance from a configuration with only a few values such as name specificed in advanced. After constructing the instance, the various setters must be used to finish initialization.
 * @param configuration The configuration of how generated code should look.
 * @param qualifiedClassName The full name of the class that should be generated.
 * @param qualifiedMaster The fill name of the item this class was generated from.
 * @param javaDoc JavaDoc if any.
 * @param fileHeaderText Text to output as header for file(s).
 * @param helperFactoryMethod Method that can generate helper types for this class.
 * @throws Exception Exception if could not construct clazz.
 */
public Clazz(Configuration configuration,String qualifiedClassName,String qualifiedMaster,String javaDoc,String fileHeaderText,ThrowingFunction<BasicClazz,HelperTypes> helperFactoryMethod) throws Exception {
  super(null,configuration,qualifiedClassName,helperFactoryMethod);
  super.clazzUsingType=this;
  this.qualifiedMaster=qualifiedMaster;
  this.interfaceTypes=new ArrayList<Type>();
  this.baseClazzType=null;
  this.javaDoc=Objects.requireNonNull(javaDoc);
  this.fileHeaderText=Objects.requireNonNull(fileHeaderText);
  this.importTypes=new ArrayList<Type>();
  this.modifiers=EnumSet.noneOf(Modifier.class);
}"
13857,"@Override public String toString(int level){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)));
  if (level < MAX_RECURSIVE_LEVEL)   sb.append(""String_Node_Str"" + name + ""String_Node_Str""+ type.getPrototypicalName()+ ""String_Node_Str""+ properties.stream().map(p -> p.name).collect(Collectors.joining(""String_Node_Str""))+ ""String_Node_Str""+ declaredModifiers+ ""String_Node_Str""+ getModifiers()+ ""String_Node_Str""+ isMutable()+ ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(int level){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)));
  if (level < MAX_RECURSIVE_LEVEL)   sb.append(""String_Node_Str"" + name + ""String_Node_Str""+ type.getPrototypicalName()+ ""String_Node_Str""+ clazz.getName()+ ""String_Node_Str""+ properties.stream().map(p -> p.name).collect(Collectors.joining(""String_Node_Str""))+ ""String_Node_Str""+ declaredModifiers+ ""String_Node_Str""+ getModifiers()+ ""String_Node_Str""+ isMutable()+ ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
13858,"/** 
 * Nb. Post-constructor for what this type is based on such as supertypes. This method must be called for the type to be fully initialized. Nb. Subclasses of this class may require additional post-constructors to be called. Must be called only once.
 * @param baseClazzType Base class of this type if any (NoType if no base class exist).
 * @param interfaceTypes Direct super-interfaces of this type.
 * @param superTypesWithAncestors All ancestor interfaces of this type.
 * @param genericTypeArguments Generic arguments of this type.
 */
public void initType(Type baseClazzType,List<Type> interfaceTypes,Set<Type> superTypesWithAncestors,List<Type> genericTypeArguments){
}","/** 
 * Nb. Post-constructor for what this type is based on such as supertypes. This method must be called for the type to be fully initialized. Nb. Subclasses of this class may require additional post-constructors to be called. Must be called only once.
 * @param baseClazzType Base class of this type if any (NoType if no base class exist).
 * @param interfaceTypes Direct super-interfaces of this type.
 * @param superTypesWithAncestors All ancestor interfaces of this type.
 * @param genericTypeArguments Generic arguments of this type.
 */
public void initType(ObjectType baseClazzType,List<Type> interfaceTypes,Set<Type> superTypesWithAncestors,List<Type> genericTypeArguments){
}"
13859,"public Type getBaseClazzType(){
}","public ObjectType getBaseClazzType(){
}"
13860,"private ObjectType(BasicClazz clazzUsingType,String qualifiedProtoTypicalTypeName,Type baseClazz,List<Type> superInterfaces,Set<Type> superTypesWithAncestors,List<Type> genericTypeArguments){
  super(clazzUsingType,qualifiedProtoTypicalTypeName);
  this.genericTypeArguments=genericTypeArguments;
  this.baseClazzType=Objects.requireNonNull(baseClazz);
  this.interfaceTypes=Objects.requireNonNull(superInterfaces);
  this.superTypesWithAscendants=Objects.requireNonNull(superTypesWithAncestors);
}","private ObjectType(BasicClazz clazzUsingType,String qualifiedProtoTypicalTypeName,ObjectType baseClazz,List<Type> superInterfaces,Set<Type> superTypesWithAncestors,List<Type> genericTypeArguments){
  super(clazzUsingType,qualifiedProtoTypicalTypeName);
  this.genericTypeArguments=genericTypeArguments;
  this.baseClazzType=baseClazz;
  this.interfaceTypes=Objects.requireNonNull(superInterfaces);
  this.superTypesWithAscendants=Objects.requireNonNull(superTypesWithAncestors);
}"
13861,"@Override public String toString(int level){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)));
  if (level < MAX_RECURSIVE_LEVEL)   sb.append(""String_Node_Str"" + initialized() + ""String_Node_Str""+ qualifiedProtoTypicalTypeName+ ""String_Node_Str""+ getName()+ ""String_Node_Str""+ ToStringUtil.toString(genericTypeArguments,""String_Node_Str"",level + 1)+ ""String_Node_Str""+ baseClazzType.toString(level + 1)+ ""String_Node_Str""+ ToStringUtil.toString(interfaceTypes,""String_Node_Str"",level + 1));
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(int level){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)));
  if (level < MAX_RECURSIVE_LEVEL)   sb.append(""String_Node_Str"" + initialized() + ""String_Node_Str""+ qualifiedProtoTypicalTypeName+ ""String_Node_Str""+ getName()+ ""String_Node_Str""+ ToStringUtil.toString(genericTypeArguments,""String_Node_Str"",level + 1)+ System.lineSeparator()+ ""String_Node_Str""+ baseClazzType.toString(level + 1)+ ""String_Node_Str""+ ToStringUtil.toString(interfaceTypes,System.lineSeparator(),level + 1));
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
13862,"public static <T>T createInstanceUsingFactory(Class<T> clazz) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  Method mostCompleteFactoryMethod=Arrays.stream(clazz.getMethods()).filter(m -> m.getName().equals(ConfigurationDefaults.factoryMethodName) && Modifier.isStatic(m.getModifiers())).max((a,b) -> Integer.compare(a.getParameterCount(),b.getParameterCount())).get();
  Parameter[] parameters=mostCompleteFactoryMethod.getParameters();
  Object[] args=new Object[parameters.length];
  for (int i=0; i < parameters.length; ++i) {
    args[i]=getTestValue(parameters[i].getType());
  }
  return (T)mostCompleteFactoryMethod.invoke(null,args);
}","@SuppressWarnings(""String_Node_Str"") public static <T>T createInstanceUsingFactory(Class<T> clazz) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  Method mostCompleteFactoryMethod=Arrays.stream(clazz.getMethods()).filter(m -> m.getName().equals(ConfigurationDefaults.factoryMethodName) && Modifier.isStatic(m.getModifiers())).max((a,b) -> Integer.compare(a.getParameterCount(),b.getParameterCount())).get();
  Parameter[] parameters=mostCompleteFactoryMethod.getParameters();
  Object[] args=new Object[parameters.length];
  for (int i=0; i < parameters.length; ++i) {
    args[i]=getTestValue(parameters[i].getType());
  }
  return (T)mostCompleteFactoryMethod.invoke(null,args);
}"
13863,"public DelegateConstructor(BasicClazz clazz,Type declaringType,Type returnType,List<Parameter> parameters,List<Type> thrownTypes,String javaDoc,EnumSet<Modifier> declaredModifiers,ImplementationInfo implementationInfo,Constructor delegateMethod){
  super(clazz,declaringType,returnType,parameters,thrownTypes,javaDoc,declaredModifiers,implementationInfo);
  this.delegateConstructor=Objects.requireNonNull(delegateMethod);
}","public DelegateConstructor(BasicClazz clazz,Type declaringType,Type returnType,List<Parameter> parameters,List<Type> thrownTypes,String javaDoc,EnumSet<Modifier> declaredModifiers,EnumSet<Modifier> modifiers,ImplementationInfo implementationInfo,Constructor delegateMethod){
  super(clazz,declaringType,returnType,parameters,thrownTypes,javaDoc,declaredModifiers,modifiers,implementationInfo);
  this.delegateConstructor=Objects.requireNonNull(delegateMethod);
}"
13864,"public Method(BasicClazz clazz,Type declaringType,String methodName,Type returnType,List<Parameter> parameters,List<Type> thrownTypes,String javaDoc,EnumSet<Modifier> declaredModifiers,EnumSet<Modifier> modifiers,ImplementationInfo implementationInfo,TemplateKind templateKind){
  super(clazz,methodName,declaredModifiers);
  this.declaringType=Objects.requireNonNull(declaringType);
  this.parameters=Objects.requireNonNull(parameters);
  this.thrownTypes=Objects.requireNonNull(thrownTypes);
  this.javaDoc=Objects.requireNonNull(javaDoc);
  this.returnType=Objects.requireNonNull(returnType);
  this.modifiers=modifiers;
  this.implementationInfo=implementationInfo;
switch (templateKind) {
case TYPED:
    this.templateName=STUtil.getTypedTemplateName(name,parameters.stream().map(p -> p.getErasedType().getQualifiedName()));
  break;
case UNTYPED:
this.templateName=STUtil.getUnTypedTemplateName(name);
break;
case CONSTRUCTOR:
this.templateName=STUtil.getConstructorTemplateName(methodName);
break;
case PROPERTY:
this.templateName=STUtil.getPropertyTemplateName(methodName);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + templateKind);
}
}","public Method(BasicClazz clazz,Type declaringType,String methodName,Type returnType,List<Parameter> parameters,List<Type> thrownTypes,String javaDoc,EnumSet<Modifier> declaredModifiers,EnumSet<Modifier> modifiers,ImplementationInfo implementationInfo,TemplateKind templateKind){
  super(clazz,methodName,declaredModifiers);
  this.declaringType=Objects.requireNonNull(declaringType);
  this.parameters=Objects.requireNonNull(parameters);
  this.thrownTypes=Objects.requireNonNull(thrownTypes);
  this.javaDoc=Objects.requireNonNull(javaDoc);
  this.returnType=Objects.requireNonNull(returnType);
  this.modifiers=modifiers;
  this.implementationInfo=implementationInfo;
  this.overriddenByMethod=Optional.empty();
  this.overridesMethod=Optional.empty();
switch (templateKind) {
case TYPED:
    this.templateName=STUtil.getTypedTemplateName(name,parameters.stream().map(p -> p.getErasedType().getQualifiedName()));
  break;
case UNTYPED:
this.templateName=STUtil.getUnTypedTemplateName(name);
break;
case CONSTRUCTOR:
this.templateName=STUtil.getConstructorTemplateName(methodName);
break;
case PROPERTY:
this.templateName=STUtil.getPropertyTemplateName(methodName);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + templateKind);
}
}"
13865,"@Override public String toString(int level){
  StringBuilder sb=new StringBuilder();
  String name=isConstructor() ? ""String_Node_Str"" : ""String_Node_Str"";
  sb.append(name + ""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)));
  if (level < MAX_RECURSIVE_LEVEL)   sb.append(""String_Node_Str"" + declaringType.getName() + ""String_Node_Str""+ getName()+ ""String_Node_Str""+ parameters.stream().map(t -> t.toString(level + 1)).collect(Collectors.joining(""String_Node_Str"" + System.lineSeparator()))+ ""String_Node_Str""+ ""String_Node_Str""+ returnType.getPrototypicalName()+ ""String_Node_Str""+ thrownTypes.stream().map(t -> t.getPrototypicalName()).collect(Collectors.joining(""String_Node_Str"" + System.lineSeparator()))+ ""String_Node_Str""+ ""String_Node_Str""+ declaredModifiers+ ""String_Node_Str""+ modifiers+ ""String_Node_Str""+ implementationInfo+ ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(int level){
  StringBuilder sb=new StringBuilder();
  String name=isConstructor() ? ""String_Node_Str"" : ""String_Node_Str"";
  sb.append(name + ""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)));
  if (level < MAX_RECURSIVE_LEVEL)   sb.append(""String_Node_Str"" + declaringType.getName() + ""String_Node_Str""+ getName()+ ""String_Node_Str""+ parameters.stream().map(t -> t.toString(level + 1)).collect(Collectors.joining(""String_Node_Str"" + System.lineSeparator()))+ ""String_Node_Str""+ ""String_Node_Str""+ returnType.getPrototypicalName()+ ""String_Node_Str""+ thrownTypes.stream().map(t -> t.getPrototypicalName()).collect(Collectors.joining(""String_Node_Str"" + System.lineSeparator()))+ ""String_Node_Str""+ ""String_Node_Str""+ this.isOverridden()+ ""String_Node_Str""+ declaredModifiers+ ""String_Node_Str""+ modifiers+ ""String_Node_Str""+ implementationInfo+ ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
13866,"public void setImplementationInfo(ImplementationInfo implementationInfo){
  this.implementationInfo=implementationInfo;
}","public void setImplementationInfo(ImplementationInfo implementationInfo){
  this.implementationInfo=Objects.requireNonNull(implementationInfo);
}"
13867,"public String outputClass() throws Exception {
  lastException=null;
  String result=null;
  STGroup.verbose=LOGGER.isLoggable(Level.FINE);
  STGroup.trackCreationEvents=cfg.isDebugStringTemplatesEnabled();
  STGroup group=stTemplates.getSTGroup();
  group.registerModelAdaptor(Model.class,new STCustomModelAdaptor());
  group.registerRenderer(Date.class,new STISODateRender());
  group.setListener(new ErrorListener());
  ST st=group.getInstanceOf(mainTemplate);
  try {
    st.add(mainTemplateArg,Objects.requireNonNull(clazz));
  }
 catch (  Exception e) {
    throw new STException(""String_Node_Str"",e);
  }
  result=st.render(Objects.requireNonNull(cfg).getLocale(),cfg.getLineWidth());
  if (result == null)   throw new STException(""String_Node_Str"");
  Exception exception=lastException;
  if (exception != null)   throw exception;
  if (cfg.isDebugStringTemplatesEnabled()) {
    LOGGER.warning(() -> ""String_Node_Str"");
    STViz viz=st.inspect();
    viz.waitForClose();
  }
  return result;
}","public String outputClass() throws Exception {
  lastException=null;
  String result=null;
  STGroup group=stTemplates.getSTGroup();
  stTemplates.exceptions().clear();
  group.registerModelAdaptor(Model.class,new STCustomModelAdaptor());
  group.registerRenderer(Date.class,new STISODateRender());
  ST st=group.getInstanceOf(mainTemplate);
  try {
    st.add(mainTemplateArg,Objects.requireNonNull(clazz));
  }
 catch (  Exception e) {
    throw new STException(""String_Node_Str"",e);
  }
  result=st.render(Objects.requireNonNull(cfg).getLocale(),cfg.getLineWidth());
  if (!stTemplates.exceptions().isEmpty())   throw stTemplates.exceptions().getFirst();
  if (result == null)   throw new STException(""String_Node_Str"");
  if (cfg.isDebugStringTemplatesEnabled()) {
    LOGGER.warning(() -> ""String_Node_Str"");
    STViz viz=st.inspect();
    viz.waitForClose();
  }
  return result;
}"
13868,"public STTemplates(ResourceLoader resourceLoader,Configuration cfg) throws Exception {
  STGroup defaultGroup=new STGroupFile(mainTemplateFile,delimiterStartChar,delimiterStopChar);
  String customTemplateFileName=cfg.getCustomJavaTemplateFileName();
  if (customTemplateFileName != null) {
    URI uri=resourceLoader.getFileResourceAsURL(customTemplateFileName);
    URL url=uri.toURL();
    group=new STGroupFile(url,templateFilesEncoding,delimiterStartChar,delimiterStopChar);
    group.importTemplates(defaultGroup);
    LOGGER.info(() -> ""String_Node_Str"" + customTemplateFileName + ""String_Node_Str""+ url.toString());
  }
 else {
    group=defaultGroup;
  }
  Set<String> templateNames=getAllTemplateNames(group);
  templateMethodNames=Collections.unmodifiableSet(Collections.unmodifiableSet(templateNames.stream().filter(n -> n.startsWith(method_prefix)).map(n -> templateNameToMethodName(n)).collect(Collectors.toSet())));
  if (LOGGER.isLoggable(Level.FINE))   for (  String templateName : templateMethodNames)   LOGGER.fine(""String_Node_Str"" + templateName + ""String_Node_Str"");
}","public STTemplates(ResourceLoader resourceLoader,Configuration cfg) throws Exception {
  stExceptions=new ArrayDeque<STException>();
  STGroup.verbose=LOGGER.isLoggable(Level.FINE);
  STGroup.trackCreationEvents=cfg.isDebugStringTemplatesEnabled();
  STGroup defaultGroup=new STGroupFile(mainTemplateFile,delimiterStartChar,delimiterStopChar);
  String customTemplateFileName=cfg.getCustomJavaTemplateFileName();
  if (customTemplateFileName != null) {
    URI uri=resourceLoader.getFileResourceAsURL(customTemplateFileName);
    URL url=uri.toURL();
    group=new STGroupFile(url,templateFilesEncoding,delimiterStartChar,delimiterStopChar);
    group.importTemplates(defaultGroup);
    LOGGER.info(() -> ""String_Node_Str"" + customTemplateFileName + ""String_Node_Str""+ url.toString());
  }
 else {
    group=defaultGroup;
  }
  group.setListener(myErrorListener);
  Set<String> templateNames=getAllTemplateNames(group);
  templateMethodNames=Collections.unmodifiableSet(Collections.unmodifiableSet(templateNames.stream().filter(n -> n.startsWith(method_prefix)).map(n -> templateNameToMethodName(n)).collect(Collectors.toSet())));
  if (LOGGER.isLoggable(Level.FINE))   for (  String templateName : templateMethodNames)   LOGGER.fine(""String_Node_Str"" + templateName + ""String_Node_Str"");
}"
13869,"private void generate(TypeElement element,Configuration configuration,ResourceLoader resourceLoader) throws Exception {
  LOGGER.fine(() -> ""String_Node_Str"" + processingEnvClassName);
  Messager messager=processingEnv.getMessager();
  Filer filer=processingEnv.getFiler();
  Types types=processingEnv.getTypeUtils();
  Elements elements=processingEnv.getElementUtils();
  if (!resourceLoader.hasSourcePaths())   messager.printMessage(Kind.WARNING,""String_Node_Str"" + ConfigurationOptionKeys.SOURCEPATH + ""String_Node_Str"");
 else {
    LOGGER.fine(() -> ""String_Node_Str"" + resourceLoader);
  }
  STTemplates templates=new STTemplates(resourceLoader,configuration);
  ModelBuilder clazzFactory=new ModelBuilder(types,elements,(msgElement,kind,err) -> {
    if (msgElement != null)     messager.printMessage(kind,err,msgElement);
 else     messager.printMessage(kind,err);
  }
,element,configuration,resourceLoader,templates);
  Clazz clazz=clazzFactory.buildNewCLazz();
  if (clazz == null)   return;
  LOGGER.info(() -> ""String_Node_Str"" + System.lineSeparator() + clazz.toString());
  String fileName=stripGenericQualifier(clazz.getName());
  JavaFileObject target=filer.createSourceFile(fileName,element);
  STCodeWriter writer=new STCodeWriter(clazz,configuration,templates);
  try (PrintWriter targetWriter=new PrintWriter(target.openWriter())){
    String output=writer.outputClass();
    if (output != null) {
      targetWriter.write(output);
      LOGGER.info(() -> ""String_Node_Str"" + fileName + ""String_Node_Str""+ System.lineSeparator()+ output);
    }
  }
 }","private void generate(TypeElement element,Configuration configuration,ResourceLoader resourceLoader) throws Exception {
  LOGGER.fine(() -> ""String_Node_Str"" + processingEnvClassName);
  Messager messager=processingEnv.getMessager();
  Filer filer=processingEnv.getFiler();
  Types types=processingEnv.getTypeUtils();
  Elements elements=processingEnv.getElementUtils();
  if (!resourceLoader.hasSourcePaths())   messager.printMessage(Kind.WARNING,""String_Node_Str"" + ConfigurationOptionKeys.SOURCEPATH + ""String_Node_Str"");
 else {
    LOGGER.fine(() -> ""String_Node_Str"" + resourceLoader);
  }
  STTemplates templates=new STTemplates(resourceLoader,configuration);
  ModelBuilder clazzFactory=new ModelBuilder(types,elements,(msgElement,kind,err) -> {
    if (msgElement != null)     messager.printMessage(kind,err,msgElement);
 else     messager.printMessage(kind,err);
  }
,element,configuration,resourceLoader,templates);
  Clazz clazz=clazzFactory.buildNewCLazz();
  if (clazz == null)   return;
  LOGGER.info(() -> ""String_Node_Str"" + System.lineSeparator() + clazz.toString());
  String fileName=stripGenericQualifier(clazz.getQualifiedName());
  JavaFileObject target=filer.createSourceFile(fileName,element);
  STCodeWriter writer=new STCodeWriter(clazz,configuration,templates);
  try (PrintWriter targetWriter=new PrintWriter(target.openWriter())){
    String output=writer.outputClass();
    if (output != null) {
      targetWriter.write(output);
      messager.printMessage(Kind.NOTE,""String_Node_Str"" + target.getName());
      LOGGER.info(() -> ""String_Node_Str"" + fileName + ""String_Node_Str""+ System.lineSeparator()+ output);
    }
  }
 }"
13870,"private static Member createPropertyMemberIfValidProperty(Clazz clazz,TypeElement interfaceElement,Configuration configuration,ExecutableElement methodElement,PropertyKind kind,DiagnosticMessageConsumer errorConsumer) throws Exception {
  TypeMirror propertyType;
  List<? extends VariableElement> setterParams=methodElement.getParameters();
  if (kind == PropertyKind.GETTER) {
    if (setterParams.size() != 0) {
      if (!configuration.isMalformedPropertiesIgnored())       errorConsumer.message(methodElement,Kind.ERROR,String.format(ProcessorMessages.MalFormedGetter,methodElement.toString()));
      return null;
    }
    TypeMirror returnType=methodElement.getReturnType();
    propertyType=returnType;
    return new Member(clazz,new Type(clazz,propertyType),syntesisePropertyMemberName(methodElement));
  }
 else   if (kind == PropertyKind.SETTER) {
    if (setterParams.size() != 1) {
      if (!configuration.isMalformedPropertiesIgnored())       errorConsumer.message(methodElement,Kind.ERROR,String.format(ProcessorMessages.MalFormedSetter,methodElement.toString()));
      return null;
    }
    TypeMirror returnType=methodElement.getReturnType();
    String returnTypeName=returnType.toString();
    if (!returnTypeName.equals(""String_Node_Str"") && !returnTypeName.equals(interfaceElement.toString()) && !returnTypeName.equals(clazz.getQualifiedName())) {
      if (!configuration.isMalformedPropertiesIgnored())       errorConsumer.message(methodElement,Kind.ERROR,String.format(ProcessorMessages.MalFormedSetter,methodElement.toString()));
      return null;
    }
    propertyType=setterParams.get(0).asType();
  }
 else {
    return null;
  }
  return new Member(clazz,new Type(clazz,propertyType),syntesisePropertyMemberName(methodElement));
}","private static Member createPropertyMemberIfValidProperty(Clazz clazz,TypeElement interfaceElement,Configuration configuration,ExecutableElement methodElement,PropertyKind kind,DiagnosticMessageConsumer errorConsumer) throws Exception {
  TypeMirror propertyType;
  List<? extends VariableElement> setterParams=methodElement.getParameters();
  if (kind == PropertyKind.GETTER) {
    if (setterParams.size() != 0) {
      if (!configuration.isMalformedPropertiesIgnored())       errorConsumer.message(methodElement,Kind.ERROR,String.format(ProcessorMessages.MalFormedGetter,methodElement.toString()));
      return null;
    }
    TypeMirror returnType=methodElement.getReturnType();
    propertyType=returnType;
    return new Member(clazz,new Type(clazz,propertyType),syntesisePropertyMemberName(configuration.getGetterPrefixes(),methodElement));
  }
 else   if (kind == PropertyKind.SETTER) {
    if (setterParams.size() != 1) {
      if (!configuration.isMalformedPropertiesIgnored())       errorConsumer.message(methodElement,Kind.ERROR,String.format(ProcessorMessages.MalFormedSetter,methodElement.toString()));
      return null;
    }
    TypeMirror returnType=methodElement.getReturnType();
    String returnTypeName=returnType.toString();
    if (!returnTypeName.equals(""String_Node_Str"") && !returnTypeName.equals(interfaceElement.toString()) && !returnTypeName.equals(clazz.getQualifiedName())) {
      if (!configuration.isMalformedPropertiesIgnored())       errorConsumer.message(methodElement,Kind.ERROR,String.format(ProcessorMessages.MalFormedSetter,methodElement.toString()));
      return null;
    }
    propertyType=setterParams.get(0).asType();
    return new Member(clazz,new Type(clazz,propertyType),syntesisePropertyMemberName(configuration.getSetterPrefixes(),methodElement));
  }
 else {
    return null;
  }
}"
13871,"private static String syntesisePropertyMemberName(ExecutableElement method){
  String name=method.getSimpleName().toString();
  int skip;
  if (name.startsWith(""String_Node_Str""))   skip=2;
 else   if (name.startsWith(""String_Node_Str"") || name.startsWith(""String_Node_Str""))   skip=3;
 else   skip=0;
  if (name.length() > skip)   name=name.substring(skip);
  name=Introspector.decapitalize(name);
  name=NamesUtil.makeSafeJavaIdentifier(name);
  return name;
}","private static String syntesisePropertyMemberName(String[] propertyPrefixes,ExecutableElement method){
  String name=method.getSimpleName().toString();
  int i=0;
  while (i < propertyPrefixes.length) {
    String prefix=propertyPrefixes[i++];
    int skip=prefix.length();
    if (name.startsWith(prefix) && name.length() > skip) {
      name=name.substring(skip);
      name=Introspector.decapitalize(name);
      name=NamesUtil.makeSafeJavaIdentifier(name);
      return name;
    }
  }
  return name;
}"
13872,"@Override public synchronized void onResumeGame(){
  if (ResourcesManager.getInstance().settingsService.isMute()) {
    ResourcesManager.getInstance().musicService.muteMusic();
  }
  if (!(mEngine.getScene() instanceof GameScene) && !(mEngine.getScene() instanceof ScoreScreen)) {
    ResourcesManager.getInstance().musicService.playMusic();
  }
  levelInfoDataSource.open();
  super.onResumeGame();
}","@Override public synchronized void onResumeGame(){
  if (ResourcesManager.getInstance().settingsService.isMute()) {
    ResourcesManager.getInstance().musicService.muteMusic();
  }
  if ((mEngine.getScene() instanceof MainMenuScene) || (mEngine.getScene() instanceof SettingsScene) || (mEngine.getScene() instanceof LevelChoiceScene)) {
    ResourcesManager.getInstance().musicService.playMusic();
  }
  levelInfoDataSource.open();
  super.onResumeGame();
}"
13873,"public JustPlayScore getBestJustPlayScore(){
  Cursor cursor=database.query(TABLE_SCORE,new String[]{COLUMN_SCORE_POINTS,COLUMN_SCORE_SOLVED_LEVELS},null,null,null,null,COLUMN_SCORE_POINTS + ""String_Node_Str"",""String_Node_Str"");
  if (cursor.getCount() == 0) {
    return null;
  }
  cursor.moveToFirst();
  return cursorToJustPlayScore(cursor);
}","public JustPlayScore getBestJustPlayScore(){
  Cursor cursor=database.query(TABLE_SCORE,new String[]{COLUMN_SCORE_POINTS,COLUMN_SCORE_SOLVED_LEVELS},null,null,null,null,COLUMN_SCORE_POINTS + ""String_Node_Str"",""String_Node_Str"");
  if (cursor.getCount() == 0) {
    return null;
  }
  cursor.moveToFirst();
  JustPlayScore justPlayScore=cursorToJustPlayScore(cursor);
  cursor.close();
  return justPlayScore;
}"
13874,"@Override public void onSolvedGame(){
  timeBasedGameService.stop();
  restartButton.setVisible(false);
  if (!leaveScene) {
    leaveScene=true;
    engine.registerUpdateHandler(new TimerHandler(1f,new ITimerCallback(){
      @Override public void onTimePassed(      TimerHandler pTimerHandler){
        engine.unregisterUpdateHandler(pTimerHandler);
        storyService.loadJustPlayScoreSceneFromJustPlayScene(new JustPlayLevelResult(timeBasedGameService.getRemainingTime(),gameService.getLevel().getMovesCount(),gameService.getLevel().getMinimumMovesToSolve()));
      }
    }
));
  }
}","@Override public void onSolvedGame(){
  timeBasedGameService.stop();
  restartButton.setVisible(false);
  if (!leaveScene) {
    restartButton.setEnabled(false);
    leaveScene=true;
    engine.registerUpdateHandler(new TimerHandler(1f,new ITimerCallback(){
      @Override public void onTimePassed(      TimerHandler pTimerHandler){
        engine.unregisterUpdateHandler(pTimerHandler);
        storyService.loadJustPlayScoreSceneFromJustPlayScene(new JustPlayLevelResult(timeBasedGameService.getRemainingTime(),gameService.getLevel().getMovesCount(),gameService.getLevel().getMinimumMovesToSolve()));
      }
    }
));
  }
}"
13875,"@Override public void onLostGame(){
  if (!leaveScene) {
    leaveScene=true;
    engine.registerUpdateHandler(new TimerHandler(1f,new ITimerCallback(){
      @Override public void onTimePassed(      TimerHandler pTimerHandler){
        engine.unregisterUpdateHandler(pTimerHandler);
        storyService.loadJustPlayScoreSceneFromJustPlayScene(new JustPlayLevelResult(-1,gameService.getLevel().getMovesCount(),gameService.getLevel().getMinimumMovesToSolve()));
      }
    }
));
  }
}","@Override public void onLostGame(){
  if (!leaveScene) {
    restartButton.setEnabled(false);
    leaveScene=true;
    engine.registerUpdateHandler(new TimerHandler(1f,new ITimerCallback(){
      @Override public void onTimePassed(      TimerHandler pTimerHandler){
        engine.unregisterUpdateHandler(pTimerHandler);
        storyService.loadJustPlayScoreSceneFromJustPlayScene(new JustPlayLevelResult(-1,gameService.getLevel().getMovesCount(),gameService.getLevel().getMinimumMovesToSolve()));
      }
    }
));
  }
}"
13876,"public JustPlayGameScene(TimeBasedGameService timeBasedGameService,JustPlayLevel justPlayLevel){
  super(justPlayLevel.getLevel());
  this.justPlayLevel=justPlayLevel;
  leaveScene=false;
  this.timeBasedGameService=timeBasedGameService;
  timeBasedGameService.attach(this);
  leftTime.setText(String.valueOf(justPlayLevel.getLeftTime()));
}","public JustPlayGameScene(TimeBasedGameService timeBasedGameService,JustPlayLevel justPlayLevel){
  super(justPlayLevel.getLevel());
  this.justPlayLevel=justPlayLevel;
  leaveScene=false;
  this.timeBasedGameService=timeBasedGameService;
  timeBasedGameService.attach(this);
  leftTime.setText(String.valueOf(justPlayLevel.getLeftTime()));
  checkRestartedLevel(timeBasedGameService);
}"
13877,"void shiftLine(boolean horizontal,int row,int steps);","void shiftLine(boolean horizontal,int row,int steps,boolean silent);"
13878,"private void notifyAllObserver(){
  for (  GameSceneObserver observer : observers) {
    observer.updateGameScene();
  }
}","@Override public void notifyAllObserver(){
  for (  GameSceneObserver observer : observers) {
    observer.updateGameScene();
  }
}"
13879,"@Override public void shiftLine(boolean horizontal,int row,int steps){
  gameFieldService.shiftLine(level,horizontal,row,steps);
  solvedPuzzle=gameFieldService.solvedPuzzle(level);
  notifyAllObserver();
}","@Override public void shiftLine(boolean horizontal,int row,int steps,boolean silent){
  gameFieldService.shiftLine(level,horizontal,row,steps);
  solvedPuzzle=gameFieldService.solvedPuzzle(level);
  if (!silent) {
    notifyAllObserver();
  }
}"
13880,"public void oneStep(final boolean horizontal,int row,final int direction){
  if (row < 0) {
    return;
  }
  this.horizontal=horizontal;
  this.row=row;
  this.direction=direction;
  row++;
  if (horizontal) {
    if (row > tileSprites.length - 2) {
      return;
    }
    this.countModifier=tileSprites.length - 2;
    this.modifierFinished=0;
    for (int x=1; x < tileSprites.length - 1; x++) {
      TileSprite tileSprite=tileSprites[x][row];
      tileSprite.registerEntityModifier(new MoveXModifier(0.3f,tileSprite.getX(),tileSprite.getX() + tileSprite.getWidth() * direction,EaseQuadInOut.getInstance()){
        @Override protected void onModifierFinished(        IEntity pItem){
          oneModifierFinished();
          super.onModifierFinished(pItem);
        }
      }
);
    }
  }
 else {
    if (row > tileSprites[0].length - 2) {
      return;
    }
    this.countModifier=tileSprites[row].length - 2;
    this.modifierFinished=0;
    for (int y=1; y < tileSprites[row].length - 1; y++) {
      TileSprite tileSprite=tileSprites[row][y];
      tileSprite.registerEntityModifier(new MoveYModifier(0.3f,tileSprite.getY(),tileSprite.getY() + tileSprite.getWidth() * direction,EaseQuadInOut.getInstance()){
        @Override protected void onModifierFinished(        IEntity pItem){
          oneModifierFinished();
          super.onModifierFinished(pItem);
        }
      }
);
    }
  }
}","public void oneStep(final boolean horizontal,int row,final int direction){
  if (row < 0) {
    return;
  }
  this.horizontal=horizontal;
  this.row=row;
  this.direction=direction;
  row++;
  if (horizontal) {
    if (row > tileSprites.length - 2) {
      return;
    }
    gameService.shiftLine(true,row - 1,direction,true);
    this.countModifier=tileSprites.length - 2;
    this.modifierFinished=0;
    for (int x=1; x < tileSprites.length - 1; x++) {
      TileSprite tileSprite=tileSprites[x][row];
      tileSprite.registerEntityModifier(new MoveXModifier(0.3f,tileSprite.getX(),tileSprite.getX() + tileSprite.getWidth() * direction,EaseQuadInOut.getInstance()){
        @Override protected void onModifierFinished(        IEntity pItem){
          oneModifierFinished();
          super.onModifierFinished(pItem);
        }
      }
);
    }
  }
 else {
    if (row > tileSprites[0].length - 2) {
      return;
    }
    gameService.shiftLine(false,row - 1,direction,true);
    this.countModifier=tileSprites[row].length - 2;
    this.modifierFinished=0;
    for (int y=1; y < tileSprites[row].length - 1; y++) {
      TileSprite tileSprite=tileSprites[row][y];
      tileSprite.registerEntityModifier(new MoveYModifier(0.3f,tileSprite.getY(),tileSprite.getY() + tileSprite.getWidth() * direction,EaseQuadInOut.getInstance()){
        @Override protected void onModifierFinished(        IEntity pItem){
          oneModifierFinished();
          super.onModifierFinished(pItem);
        }
      }
);
    }
  }
}"
13881,"private void oneModifierFinished(){
  modifierFinished++;
  if (modifierFinished == countModifier) {
    active=false;
    gameService.shiftLine(horizontal,row,direction);
  }
}","private void oneModifierFinished(){
  modifierFinished++;
  if (modifierFinished == countModifier) {
    active=false;
    gameService.notifyAllObserver();
  }
}"
13882,"public void addTiles(boolean finished){
  int tileIndex;
  if (finished) {
    tileIndex=1;
  }
 else {
    tileIndex=0;
  }
  detachChildren();
  Tile[][] field=gameService.getLevel().getField();
  int width=field.length;
  int heigth=field[0].length;
  tileSprites=new TileSprite[width][heigth];
  int tilePositionY=0;
  for (int y=0; y < heigth; y++) {
    int tilePositionX=0;
    for (int x=0; x < width; x++) {
      if (field[x][y].getShortcut() != 'n') {
        TextureRegion pTextureRegion=tileRegionMap.get(field[x][y].getShortcut());
        TextureRegion pTextureRegionFilled=tileRegionMap.get(Character.toUpperCase(field[x][y].getShortcut()));
        List<ITextureRegion> textureRegions=Arrays.<ITextureRegion>asList(pTextureRegion,pTextureRegionFilled);
switch (field[x][y].getTileType()) {
case PUZZLE:
          TileSprite tileSprite=new TileSprite(tilePositionX,tilePositionY,spacePerTile,spacePerTile,textureRegions,vbom);
        tileSprite.setITextureRegionIndex(tileIndex);
      attachChild(tileSprite);
    tileSprites[x][y]=tileSprite;
  break;
case FINISH:
finish=createFinishAnsStart(x,y,tilePositionX,tilePositionY,textureRegions,field);
finish.setITextureRegionIndex(tileIndex);
break;
case START:
start=createFinishAnsStart(x,y,tilePositionX,tilePositionY,textureRegions,field);
start.setITextureRegionIndex(tileIndex);
break;
default :
break;
}
}
tilePositionX+=spacePerTile;
}
tilePositionY+=spacePerTile;
}
attachChild(new Sprite(spacePerTile,spacePerTile,spacePerTile * (width - 2),spacePerTile * (width - 2),tilesBorderRegion,vbom));
}","public void addTiles(boolean finished){
  int tileIndex;
  if (finished) {
    tileIndex=1;
  }
 else {
    tileIndex=0;
  }
  detachChildren();
  if (active) {
    oneModifierFinished(true);
  }
  Tile[][] field=gameService.getLevel().getField();
  int width=field.length;
  int heigth=field[0].length;
  tileSprites=new TileSprite[width][heigth];
  int tilePositionY=0;
  for (int y=0; y < heigth; y++) {
    int tilePositionX=0;
    for (int x=0; x < width; x++) {
      if (field[x][y].getShortcut() != 'n') {
        TextureRegion pTextureRegion=tileRegionMap.get(field[x][y].getShortcut());
        TextureRegion pTextureRegionFilled=tileRegionMap.get(Character.toUpperCase(field[x][y].getShortcut()));
        List<ITextureRegion> textureRegions=Arrays.<ITextureRegion>asList(pTextureRegion,pTextureRegionFilled);
switch (field[x][y].getTileType()) {
case PUZZLE:
          TileSprite tileSprite=new TileSprite(tilePositionX,tilePositionY,spacePerTile,spacePerTile,textureRegions,vbom);
        tileSprite.setITextureRegionIndex(tileIndex);
      attachChild(tileSprite);
    tileSprites[x][y]=tileSprite;
  break;
case FINISH:
TileSprite finish=createFinishAnsStart(x,y,tilePositionX,tilePositionY,textureRegions,field);
finish.setITextureRegionIndex(tileIndex);
break;
case START:
TileSprite start=createFinishAnsStart(x,y,tilePositionX,tilePositionY,textureRegions,field);
start.setITextureRegionIndex(tileIndex);
break;
default :
break;
}
}
tilePositionX+=spacePerTile;
}
tilePositionY+=spacePerTile;
}
attachChild(new Sprite(spacePerTile,spacePerTile,spacePerTile * (width - 2),spacePerTile * (width - 2),tilesBorderRegion,vbom));
}"
13883,"@Override protected void onModifierFinished(IEntity pItem){
  oneModifierFinished();
  super.onModifierFinished(pItem);
}","@Override protected void onModifierFinished(IEntity pItem){
  oneModifierFinished(false);
  super.onModifierFinished(pItem);
}"
13884,"public void oneStep(final boolean horizontal,int row,final int direction){
  if (row < 0) {
    return;
  }
  row++;
  if (horizontal) {
    if (row > tileSprites.length - 2) {
      return;
    }
    gameService.shiftLine(true,row - 1,direction,true);
    this.countModifier=tileSprites.length - 2;
    this.modifierFinished=0;
    for (int x=1; x < tileSprites.length - 1; x++) {
      TileSprite tileSprite=tileSprites[x][row];
      tileSprite.registerEntityModifier(new MoveXModifier(0.3f,tileSprite.getX(),tileSprite.getX() + tileSprite.getWidth() * direction,EaseQuadInOut.getInstance()){
        @Override protected void onModifierFinished(        IEntity pItem){
          oneModifierFinished();
          super.onModifierFinished(pItem);
        }
      }
);
    }
  }
 else {
    if (row > tileSprites[0].length - 2) {
      return;
    }
    gameService.shiftLine(false,row - 1,direction,true);
    this.countModifier=tileSprites[row].length - 2;
    this.modifierFinished=0;
    for (int y=1; y < tileSprites[row].length - 1; y++) {
      TileSprite tileSprite=tileSprites[row][y];
      tileSprite.registerEntityModifier(new MoveYModifier(0.3f,tileSprite.getY(),tileSprite.getY() + tileSprite.getWidth() * direction,EaseQuadInOut.getInstance()){
        @Override protected void onModifierFinished(        IEntity pItem){
          oneModifierFinished();
          super.onModifierFinished(pItem);
        }
      }
);
    }
  }
}","public void oneStep(final boolean horizontal,int row,final int direction){
  if (row < 0) {
    return;
  }
  row++;
  if (horizontal) {
    if (row > tileSprites.length - 2) {
      return;
    }
    gameService.shiftLine(true,row - 1,direction,true);
    active=true;
    this.countModifier=tileSprites.length - 2;
    this.modifierFinished=0;
    for (int x=1; x < tileSprites.length - 1; x++) {
      TileSprite tileSprite=tileSprites[x][row];
      tileSprite.registerEntityModifier(new MoveXModifier(0.3f,tileSprite.getX(),tileSprite.getX() + tileSprite.getWidth() * direction,EaseQuadInOut.getInstance()){
        @Override protected void onModifierFinished(        IEntity pItem){
          oneModifierFinished(false);
          super.onModifierFinished(pItem);
        }
      }
);
    }
  }
 else {
    if (row > tileSprites[0].length - 2) {
      return;
    }
    gameService.shiftLine(false,row - 1,direction,true);
    active=true;
    this.countModifier=tileSprites[row].length - 2;
    this.modifierFinished=0;
    for (int y=1; y < tileSprites[row].length - 1; y++) {
      TileSprite tileSprite=tileSprites[row][y];
      tileSprite.registerEntityModifier(new MoveYModifier(0.3f,tileSprite.getY(),tileSprite.getY() + tileSprite.getWidth() * direction,EaseQuadInOut.getInstance()){
        @Override protected void onModifierFinished(        IEntity pItem){
          oneModifierFinished(false);
          super.onModifierFinished(pItem);
        }
      }
);
    }
  }
}"
13885,"private void oneModifierFinished(){
  modifierFinished++;
  if (modifierFinished == countModifier) {
    active=false;
    gameService.notifyAllObserver();
  }
}","private void oneModifierFinished(boolean now){
  modifierFinished++;
  if (modifierFinished == countModifier | now) {
    active=false;
    gameService.notifyAllObserver();
  }
}"
13886,"private void registerTouchHandler(){
  GameSceneSingleMoveDetector gameSceneSingleMoveDetector=new GameSceneSingleMoveDetector(0,getTileSceneStartY() + spacePerTile,spacePerTile,gameFieldView);
  continuousHoldDetector=new ContinuousHoldDetector(0,100,0.01f,gameSceneSingleMoveDetector);
  setOnSceneTouchListener(continuousHoldDetector);
}","private void registerTouchHandler(){
  GameSceneSingleMoveDetector gameSceneSingleMoveDetector=new GameSceneSingleMoveDetector(0,getTileSceneStartY() + spacePerTile,spacePerTile,gameFieldView,gameService);
  continuousHoldDetector=new ContinuousHoldDetector(0,100,0.01f,gameSceneSingleMoveDetector);
  setOnSceneTouchListener(continuousHoldDetector);
}"
13887,"@Override public void onHoldFinished(HoldDetector pHoldDetector,long pHoldTimeMilliseconds,int pPointerID,float pHoldX,float pHoldY){
  int row;
  if (!isMoved) {
    if (Math.abs(pHoldX - firstX) > Math.abs(pHoldY - firstY)) {
      if (pHoldX - firstX > SWIPE_SENSITIVITY) {
        row=(int)((firstY - fieldStartY) / widthPerTile);
        gameFieldView.oneStep(true,row,1);
        isMoved=true;
      }
 else       if (firstX - pHoldX > SWIPE_SENSITIVITY) {
        row=(int)((firstY - fieldStartY) / widthPerTile);
        gameFieldView.oneStep(true,row,-1);
        isMoved=true;
      }
    }
 else     if (pHoldY - firstY > SWIPE_SENSITIVITY) {
      row=(int)((firstX - fieldStartX) / widthPerTile);
      gameFieldView.oneStep(false,row,1);
      isMoved=true;
    }
 else     if (firstY - pHoldY > SWIPE_SENSITIVITY) {
      row=(int)((firstX - fieldStartX) / widthPerTile);
      gameFieldView.oneStep(false,row,-1);
      isMoved=true;
    }
  }
}","@Override public void onHoldFinished(HoldDetector pHoldDetector,long pHoldTimeMilliseconds,int pPointerID,float pHoldX,float pHoldY){
  if (!gameService.solvedPuzzle()) {
    int row;
    if (!isMoved) {
      if (Math.abs(pHoldX - firstX) > Math.abs(pHoldY - firstY)) {
        if (pHoldX - firstX > SWIPE_SENSITIVITY) {
          row=(int)((firstY - fieldStartY) / widthPerTile);
          gameFieldView.oneStep(true,row,1);
          isMoved=true;
        }
 else         if (firstX - pHoldX > SWIPE_SENSITIVITY) {
          row=(int)((firstY - fieldStartY) / widthPerTile);
          gameFieldView.oneStep(true,row,-1);
          isMoved=true;
        }
      }
 else       if (pHoldY - firstY > SWIPE_SENSITIVITY) {
        row=(int)((firstX - fieldStartX) / widthPerTile);
        gameFieldView.oneStep(false,row,1);
        isMoved=true;
      }
 else       if (firstY - pHoldY > SWIPE_SENSITIVITY) {
        row=(int)((firstX - fieldStartX) / widthPerTile);
        gameFieldView.oneStep(false,row,-1);
        isMoved=true;
      }
    }
  }
}"
13888,"@Override public void onHoldStarted(HoldDetector pHoldDetector,int pPointerID,float pHoldX,float pHoldY){
  firstX=pHoldX;
  firstY=pHoldY;
  isMoved=false;
}","@Override public void onHoldStarted(HoldDetector pHoldDetector,int pPointerID,float pHoldX,float pHoldY){
  if (!gameService.solvedPuzzle()) {
    firstX=pHoldX;
    firstY=pHoldY;
    isMoved=false;
  }
}"
13889,"@Override public void onHold(HoldDetector pHoldDetector,long pHoldTimeMilliseconds,int pPointerID,float pHoldX,float pHoldY){
  int row;
  if (!isMoved) {
    if (pHoldX - firstX > widthPerTile) {
      row=(int)((firstY - fieldStartY) / widthPerTile);
      gameFieldView.oneStep(true,row,1);
      isMoved=true;
    }
 else     if (firstX - pHoldX > widthPerTile) {
      row=(int)((firstY - fieldStartY) / widthPerTile);
      gameFieldView.oneStep(true,row,-1);
      isMoved=true;
    }
 else     if (pHoldY - firstY > widthPerTile) {
      row=(int)((firstX - fieldStartX) / widthPerTile);
      gameFieldView.oneStep(false,row,1);
      isMoved=true;
    }
 else     if (firstY - pHoldY > widthPerTile) {
      row=(int)((firstX - fieldStartX) / widthPerTile);
      gameFieldView.oneStep(false,row,-1);
      isMoved=true;
    }
  }
}","@Override public void onHold(HoldDetector pHoldDetector,long pHoldTimeMilliseconds,int pPointerID,float pHoldX,float pHoldY){
  if (!gameService.solvedPuzzle()) {
    int row;
    if (!isMoved) {
      if (pHoldX - firstX > widthPerTile) {
        row=(int)((firstY - fieldStartY) / widthPerTile);
        gameFieldView.oneStep(true,row,1);
        isMoved=true;
      }
 else       if (firstX - pHoldX > widthPerTile) {
        row=(int)((firstY - fieldStartY) / widthPerTile);
        gameFieldView.oneStep(true,row,-1);
        isMoved=true;
      }
 else       if (pHoldY - firstY > widthPerTile) {
        row=(int)((firstX - fieldStartX) / widthPerTile);
        gameFieldView.oneStep(false,row,1);
        isMoved=true;
      }
 else       if (firstY - pHoldY > widthPerTile) {
        row=(int)((firstX - fieldStartX) / widthPerTile);
        gameFieldView.oneStep(false,row,-1);
        isMoved=true;
      }
    }
  }
}"
13890,"public GameSceneSingleMoveDetector(float startX,float startY,float widthPerTile,GameFieldView gameFieldView){
  this.fieldStartX=startX;
  this.fieldStartY=startY;
  this.widthPerTile=widthPerTile;
  this.gameFieldView=gameFieldView;
  isMoved=false;
  SWIPE_SENSITIVITY=widthPerTile * 0.1f;
}","public GameSceneSingleMoveDetector(float startX,float startY,float widthPerTile,GameFieldView gameFieldView,GameService gameService){
  this.fieldStartX=startX;
  this.fieldStartY=startY;
  this.widthPerTile=widthPerTile;
  this.gameFieldView=gameFieldView;
  isMoved=false;
  SWIPE_SENSITIVITY=widthPerTile * 0.1f;
  this.gameService=gameService;
}"
13891,"@Override public void start(){
  engine.registerUpdateHandler(new TimerHandler(0.1f,new ITimerCallback(){
    @Override public void onTimePassed(    final TimerHandler pTimerHandler){
      engine.unregisterUpdateHandler(pTimerHandler);
      ResourcesManager.getInstance().loadLevelChoiceSceneResources();
      ResourcesManager.getInstance().loadScoreSceneResources();
      ResourcesManager.getInstance().loadTutorialSceneResources();
      ResourcesManager.getInstance().loadGameSceneResources();
      choiceScene=new LevelChoiceScene();
      setScene(choiceScene);
    }
  }
));
}","@Override public void start(){
  engine.registerUpdateHandler(new TimerHandler(0.1f,new ITimerCallback(){
    @Override public void onTimePassed(    final TimerHandler pTimerHandler){
      engine.unregisterUpdateHandler(pTimerHandler);
      ResourcesManager.getInstance().loadLevelChoiceSceneResources();
      ResourcesManager.getInstance().loadScoreSceneResources();
      ResourcesManager.getInstance().loadTutorialSceneResources();
      ResourcesManager.getInstance().loadGameSceneResources();
      ResourcesManager.getInstance().loadLevelModeCompleteResources();
      choiceScene=new LevelChoiceScene();
      setScene(choiceScene);
    }
  }
));
}"
13892,"public TimeBasedGameServiceImpl(Level level,int remainingTime){
  gameService=new GameServiceImpl(level);
  gameService.attach(this);
  this.remainingTime=remainingTime;
  observers=new ArrayList<>();
}","public TimeBasedGameServiceImpl(Level level,int remainingTime){
  gameService=new GameServiceImpl(level);
  this.remainingTime=remainingTime;
  observers=new ArrayList<>();
}"
13893,"@Override public void update(){
  updateTiles();
  scoreText.setText(String.valueOf(gameService.getLevel().getMovesCount()));
  if (gameService.solvedPuzzle()) {
    setOnSceneTouchListener(null);
    gameFieldView.setTubesState(1);
    baseScene.registerUpdateHandler(new TimerHandler(0.1f,new ITimerCallback(){
      public void onTimePassed(      final TimerHandler pTimerHandler){
        baseScene.unregisterUpdateHandler(pTimerHandler);
        onSolvedGame();
      }
    }
));
  }
  if (gameService.lostLevel()) {
    onLostGame();
  }
}","@Override public void update(){
  updateTiles();
  scoreText.setText(String.valueOf(gameService.getLevel().getMovesCount()));
  if (gameService.solvedPuzzle()) {
    setOnSceneTouchListener(null);
    gameFieldView.setTubesState(1);
    gameService.detatch(this);
    baseScene.registerUpdateHandler(new TimerHandler(0.1f,new ITimerCallback(){
      public void onTimePassed(      final TimerHandler pTimerHandler){
        baseScene.unregisterUpdateHandler(pTimerHandler);
        onSolvedGame();
      }
    }
));
  }
  if (gameService.lostLevel()) {
    onLostGame();
  }
}"
13894,"private void updateTiles(){
  detachChild(gameFieldView);
  gameFieldView.addTiles();
  attachChild(gameFieldView);
}","private void updateTiles(){
  baseScene.registerUpdateHandler(new TimerHandler(0.1f,new ITimerCallback(){
    public void onTimePassed(    final TimerHandler pTimerHandler){
      detachChild(gameFieldView);
      gameFieldView.addTiles();
      attachChild(gameFieldView);
    }
  }
));
}"
13895,"public GameScene(Level level){
  super();
  this.level=level;
  initializeLogic();
  calculateSpacePerTile(gameService.getLevel().getField().length - 2);
  levelBackup=new Level(gameService.getLevel());
  addBackground();
  addTiles();
  addButtons();
  addScoreText();
  addCustomLabels();
  registerTouchHandler();
  gameService.attach(this);
  resourcesManager.musicService.stopMusic();
}","public GameScene(Level level){
  super();
  this.level=level;
  initializeLogic();
  calculateSpacePerTile(gameService.getLevel().getField().length - 2);
  levelBackup=new Level(gameService.getLevel());
  addBackground();
  addTiles();
  addButtons();
  addScoreText();
  addCustomLabels();
  registerTouchHandler();
  resourcesManager.musicService.stopMusic();
}"
13896,"@Override protected void initializeLogic(){
  gameService=new GameServiceImpl(this.level);
}","@Override protected void initializeLogic(){
  gameService=new GameServiceImpl(this.level);
  gameService.attach(this);
}"
13897,"@Override protected void initializeLogic(){
  timeBasedGameService=new TimeBasedGameServiceImpl(level,10);
  gameService=timeBasedGameService;
  timeBasedGameService.start();
}","@Override protected void initializeLogic(){
  timeBasedGameService=new TimeBasedGameServiceImpl(level,10);
  gameService=timeBasedGameService;
  timeBasedGameService.start();
  gameService.attach(this);
}"
13898,"@Override public void onTimePassed(TimerHandler pTimerHandler){
  engine.unregisterUpdateHandler(pTimerHandler);
  storyService.loadJustPlayScoreSceneFromJustPlayScene(new JustPlayLevelResult(justPlayLevel.getLeftTime() - 12,gameService.getLevel().getMovesCount()));
}","@Override public void onTimePassed(TimerHandler pTimerHandler){
  leftTime.setText(String.valueOf(timeBasedGameService.getRemainingTime()));
}"
13899,"@Override public void update(){
  super.update();
  leftTime.setText(String.valueOf(timeBasedGameService.getRemainingTime()));
}","@Override public void update(){
  super.update();
  engine.registerUpdateHandler(new TimerHandler(0.1f,new ITimerCallback(){
    @Override public void onTimePassed(    TimerHandler pTimerHandler){
      leftTime.setText(String.valueOf(timeBasedGameService.getRemainingTime()));
    }
  }
));
}"
13900,void moveRight();,void moveRight(int screen);
13901,"@Override public void moveRight(){
  if (currentScreen < screenCount - 1) {
    currentScreen++;
  }
  updateAll();
}","@Override public void moveRight(int screen){
  if (screen < screenCount) {
    currentScreen=screen;
  }
  updateAll();
}"
13902,"private void moveToLastUnlocked(){
  LevelInfo lastUnlocked=levelService.getLastUnlocked();
  int screenToJumpTo=(int)(lastUnlocked.getLevelId() - 0.1) / 12;
  while (levelChoiceService.getCurrentScreen() < screenToJumpTo) {
    levelChoiceService.moveRight();
  }
}","private void moveToLastUnlocked(){
  LevelInfo lastUnlocked=levelService.getLastUnlocked();
  int screenToJumpTo=(int)(lastUnlocked.getLevelId() - 0.1) / 12;
  levelChoiceService.moveRight(screenToJumpTo);
}"
13903,"private void addChangeLevelButtons(){
  screenCount=(levelInfos.size() / 12) + 1;
  currentScreen=0;
  rightArrow=new ButtonSprite(camera.getWidth() * 0.93f - LEVEL_SELECT_ICON_WIDTH,camera.getHeight() * 0.8f,resourcesManager.levelChoiceArrowRightRegion,vbom,new ButtonSprite.OnClickListener(){
    @Override public void onClick(    ButtonSprite pButtonSprite,    float pTouchAreaLocalX,    float pTouchAreaLocalY){
      if (currentScreen < screenCount - 1) {
        currentScreen++;
        entityToFollow.registerEntityModifier(new MoveXModifier(0.5f,entityToFollow.getX(),currentScreen * camera.getWidth() + camera.getWidth() / 2,EaseQuartInOut.getInstance()));
        if (currentScreen == screenCount - 1) {
          rightArrow.setVisible(false);
        }
        leftArrow.setVisible(true);
      }
    }
  }
);
  leftArrow=new ButtonSprite(camera.getWidth() * 0.07f,camera.getHeight() * 0.8f,resourcesManager.levelChoiceArrowLeftRegion,vbom,new ButtonSprite.OnClickListener(){
    @Override public void onClick(    ButtonSprite pButtonSprite,    float pTouchAreaLocalX,    float pTouchAreaLocalY){
      if (currentScreen > 0) {
        currentScreen--;
        entityToFollow.registerEntityModifier(new MoveXModifier(0.5f,entityToFollow.getX(),currentScreen * camera.getWidth() + camera.getWidth() / 2,EaseQuartInOut.getInstance()));
        if (currentScreen == 0) {
          leftArrow.setVisible(false);
        }
        rightArrow.setVisible(true);
      }
    }
  }
);
  leftArrow.setVisible(false);
  if (screenCount == 1) {
    rightArrow.setVisible(false);
  }
  arrowHud=new HUD();
  arrowHud.attachChild(leftArrow);
  arrowHud.attachChild(rightArrow);
  arrowHud.registerTouchArea(leftArrow);
  arrowHud.registerTouchArea(rightArrow);
  camera.setHUD(arrowHud);
  entityToFollow=new Entity(camera.getWidth() / 2,camera.getHeight() / 2);
  attachChild(entityToFollow);
  camera.setChaseEntity(entityToFollow);
}","private void addChangeLevelButtons(){
  screenCount=(((int)(levelInfos.size() - 0.1) / 12)) + 1;
  currentScreen=0;
  rightArrow=new ButtonSprite(camera.getWidth() * 0.93f - LEVEL_SELECT_ICON_WIDTH,camera.getHeight() * 0.8f,resourcesManager.levelChoiceArrowRightRegion,vbom,new ButtonSprite.OnClickListener(){
    @Override public void onClick(    ButtonSprite pButtonSprite,    float pTouchAreaLocalX,    float pTouchAreaLocalY){
      if (currentScreen < screenCount - 1) {
        currentScreen++;
        entityToFollow.registerEntityModifier(new MoveXModifier(0.5f,entityToFollow.getX(),currentScreen * camera.getWidth() + camera.getWidth() / 2,EaseQuartInOut.getInstance()));
        if (currentScreen == screenCount - 1) {
          rightArrow.setVisible(false);
        }
        leftArrow.setVisible(true);
      }
    }
  }
);
  leftArrow=new ButtonSprite(camera.getWidth() * 0.07f,camera.getHeight() * 0.8f,resourcesManager.levelChoiceArrowLeftRegion,vbom,new ButtonSprite.OnClickListener(){
    @Override public void onClick(    ButtonSprite pButtonSprite,    float pTouchAreaLocalX,    float pTouchAreaLocalY){
      if (currentScreen > 0) {
        currentScreen--;
        entityToFollow.registerEntityModifier(new MoveXModifier(0.5f,entityToFollow.getX(),currentScreen * camera.getWidth() + camera.getWidth() / 2,EaseQuartInOut.getInstance()));
        if (currentScreen == 0) {
          leftArrow.setVisible(false);
        }
        rightArrow.setVisible(true);
      }
    }
  }
);
  leftArrow.setVisible(false);
  if (screenCount == 1) {
    rightArrow.setVisible(false);
  }
  arrowHud=new HUD();
  arrowHud.attachChild(leftArrow);
  arrowHud.attachChild(rightArrow);
  arrowHud.registerTouchArea(leftArrow);
  arrowHud.registerTouchArea(rightArrow);
  camera.setHUD(arrowHud);
  entityToFollow=new Entity(camera.getWidth() / 2,camera.getHeight() / 2);
  attachChild(entityToFollow);
  camera.setChaseEntity(entityToFollow);
}"
13904,"public String[] fromGameField(Level gameField){
  Tile tiles[][]=gameField.getField();
  String level[]=new String[tiles[0].length];
  for (int y=0; y < tiles[0].length; y++) {
    level[y]=new String();
    for (int x=0; x < tiles.length; x++) {
      level[y]=level[y] + String.valueOf(tiles[x][y].getShortcut());
    }
  }
  return level;
}","public String[] fromGameField(Level gameField){
  Tile tiles[][]=gameField.getField();
  int indexOfProperties=0;
  if (gameField.getId() == null) {
    gameField.setId(-1);
  }
  String level[]=new String[tiles[0].length + 3];
  level[0]=String.valueOf(gameField.getId());
  level[1]=String.valueOf(gameField.getMinimumMovesToSolve());
  level[2]=""String_Node_Str"";
  for (int y=0; y < tiles[0].length; y++) {
    level[y + 3]=new String();
    for (int x=0; x < tiles.length; x++) {
      level[y + 3]=level[y + 3] + String.valueOf(tiles[x][y].getShortcut());
    }
  }
  return level;
}"
13905,"public Level fromString(String[] string){
  Tile[][] field;
  Level level=new Level();
  field=new Tile[string[0].length()][string.length];
  for (int i=0; i < string[0].length(); i++) {
    for (int j=0; j < string.length; j++) {
      Tile currentTile=new Tile(characterTileHashMap.get(string[j].charAt(i)));
      if (currentTile.getTileType() != TileType.NONE) {
        if (i == 0) {
          checkInvalidTile(currentTile);
          currentTile.setRight(true);
        }
        if (i == string[0].length() - 1) {
          checkInvalidTile(currentTile);
          currentTile.setLeft(true);
        }
        if (j == 0) {
          checkInvalidTile(currentTile);
          currentTile.setBottom(true);
        }
        if (j == string.length - 1) {
          checkInvalidTile(currentTile);
          currentTile.setTop(true);
        }
      }
      field[i][j]=currentTile;
      if (currentTile.getTileType() == TileType.START) {
        level.setStartX(i);
        level.setStartY(j);
      }
    }
  }
  level.setField(field);
  return level;
}","public Level fromString(String[] string){
  Tile[][] field;
  Level level=new Level();
  int indexOfProperties=0;
  for (; string[indexOfProperties].charAt(0) != '#'; indexOfProperties++) {
switch (indexOfProperties) {
case 0:
      level.setId(Integer.parseInt(string[0]));
    break;
case 1:
  level.setMinimumMovesToSolve(Integer.parseInt(string[1]));
break;
default :
break;
}
}
ArrayList<String> stringsForField=new ArrayList<>();
for (int i=indexOfProperties + 1; i < string.length; i++) {
stringsForField.add(i - indexOfProperties - 1,string[i]);
}
field=getTiles(stringsForField.toArray(new String[stringsForField.size()]),level);
level.setField(field);
return level;
}"
13906,"private void addChangeLevelButtons(){
  rightArrow=new ButtonSprite(camera.getWidth() * 0.93f - LEVEL_SELECT_ICON_WIDTH,camera.getHeight() * 0.8f,resourcesManager.levelChoiceArrowRightRegion,vbom,new ButtonSprite.OnClickListener(){
    @Override public void onClick(    ButtonSprite pButtonSprite,    float pTouchAreaLocalX,    float pTouchAreaLocalY){
      if (currentScreen < screenCount - 1) {
        currentScreen++;
        entityToFollow.registerEntityModifier(new MoveXModifier(0.5f,entityToFollow.getX(),currentScreen * camera.getWidth() + camera.getWidth() / 2));
        if (currentScreen == screenCount - 1) {
          leftArrow.setVisible(true);
        }
        leftArrow.setVisible(true);
      }
    }
  }
);
  leftArrow=new ButtonSprite(camera.getWidth() * 0.07f,camera.getHeight() * 0.8f,resourcesManager.levelChoiceArrowLeftRegion,vbom,new ButtonSprite.OnClickListener(){
    @Override public void onClick(    ButtonSprite pButtonSprite,    float pTouchAreaLocalX,    float pTouchAreaLocalY){
      if (currentScreen > 0) {
        currentScreen--;
        entityToFollow.registerEntityModifier(new MoveXModifier(0.5f,entityToFollow.getX(),currentScreen * camera.getWidth() + camera.getWidth() / 2));
        if (currentScreen == 0) {
          leftArrow.setVisible(false);
        }
        rightArrow.setVisible(true);
      }
    }
  }
);
  leftArrow.setVisible(false);
  if (screenCount == 1) {
    rightArrow.setVisible(false);
  }
  HUD arrowHud=new HUD();
  arrowHud.attachChild(leftArrow);
  arrowHud.attachChild(rightArrow);
  arrowHud.registerTouchArea(leftArrow);
  arrowHud.registerTouchArea(rightArrow);
  camera.setHUD(arrowHud);
}","private void addChangeLevelButtons(){
  rightArrow=new ButtonSprite(camera.getWidth() * 0.93f - LEVEL_SELECT_ICON_WIDTH,camera.getHeight() * 0.8f,resourcesManager.levelChoiceArrowRightRegion,vbom,new ButtonSprite.OnClickListener(){
    @Override public void onClick(    ButtonSprite pButtonSprite,    float pTouchAreaLocalX,    float pTouchAreaLocalY){
      if (currentScreen < screenCount - 1) {
        currentScreen++;
        entityToFollow.registerEntityModifier(new MoveXModifier(0.5f,entityToFollow.getX(),currentScreen * camera.getWidth() + camera.getWidth() / 2));
        if (currentScreen == screenCount - 1) {
          rightArrow.setVisible(false);
        }
        leftArrow.setVisible(true);
      }
    }
  }
);
  leftArrow=new ButtonSprite(camera.getWidth() * 0.07f,camera.getHeight() * 0.8f,resourcesManager.levelChoiceArrowLeftRegion,vbom,new ButtonSprite.OnClickListener(){
    @Override public void onClick(    ButtonSprite pButtonSprite,    float pTouchAreaLocalX,    float pTouchAreaLocalY){
      if (currentScreen > 0) {
        currentScreen--;
        entityToFollow.registerEntityModifier(new MoveXModifier(0.5f,entityToFollow.getX(),currentScreen * camera.getWidth() + camera.getWidth() / 2));
        if (currentScreen == 0) {
          leftArrow.setVisible(false);
        }
        rightArrow.setVisible(true);
      }
    }
  }
);
  leftArrow.setVisible(false);
  if (screenCount == 1) {
    rightArrow.setVisible(false);
  }
  HUD arrowHud=new HUD();
  arrowHud.attachChild(leftArrow);
  arrowHud.attachChild(rightArrow);
  arrowHud.registerTouchArea(leftArrow);
  arrowHud.registerTouchArea(rightArrow);
  camera.setHUD(arrowHud);
}"
13907,"public void addTiles(){
  tileGroup.detachChildren();
  Tile[][] field=gameService.getGameField().getField();
  int width=field.length;
  int heigth=field[0].length;
  spacePerTile=MainActivity.CAMERA_WIDTH / width;
  float tilesSceneStartY=getTileSceneStartY(spacePerTile);
  tileGroup.setPosition(0,tilesSceneStartY);
  int tilePositionY=0;
  tileSprites=new TileSprite[width][heigth];
  for (int y=0; y < heigth; y++) {
    int tilePositionX=0;
    for (int x=0; x < width; x++) {
      if (field[x][y].getShortcut() != 'n') {
        TextureRegion pTextureRegion=resourcesManager.regionTileMap.get(field[x][y].getShortcut());
        TileSprite tileSprite=new TileSprite(tilePositionX,tilePositionY,spacePerTile,spacePerTile,pTextureRegion,vbom);
        tileGroup.attachChild(tileSprite);
        if (field[x][y].getTileType() == TileType.PUZZLE) {
          tileSprites[x][y]=tileSprite;
        }
      }
      tilePositionX+=spacePerTile;
    }
    tilePositionY+=spacePerTile;
  }
  tileGroup.attachChild(new Sprite(spacePerTile,spacePerTile,spacePerTile * (width - 2),spacePerTile * (width - 2),resourcesManager.tilesBorderRegion,vbom));
  setSolved(gameService.solvedPuzzle());
}","public void addTiles(){
  tileGroup.detachChildren();
  Tile[][] field=gameService.getGameField().getField();
  int width=field.length;
  int heigth=field[0].length;
  spacePerTile=camera.getWidth() / width;
  float tilesSceneStartY=getTileSceneStartY(spacePerTile);
  tileGroup.setPosition(0,tilesSceneStartY);
  int tilePositionY=0;
  tileSprites=new TileSprite[width][heigth];
  for (int y=0; y < heigth; y++) {
    int tilePositionX=0;
    for (int x=0; x < width; x++) {
      if (field[x][y].getShortcut() != 'n') {
        TextureRegion pTextureRegion=resourcesManager.regionTileMap.get(field[x][y].getShortcut());
        TileSprite tileSprite=new TileSprite(tilePositionX,tilePositionY,spacePerTile,spacePerTile,pTextureRegion,vbom);
        tileGroup.attachChild(tileSprite);
        if (field[x][y].getTileType() == TileType.PUZZLE) {
          tileSprites[x][y]=tileSprite;
        }
      }
      tilePositionX+=spacePerTile;
    }
    tilePositionY+=spacePerTile;
  }
  tileGroup.attachChild(new Sprite(spacePerTile,spacePerTile,spacePerTile * (width - 2),spacePerTile * (width - 2),resourcesManager.tilesBorderRegion,vbom));
  setSolved(gameService.solvedPuzzle());
}"
13908,"@Override public void createScene(Object o){
  int foo=(MainActivity.CAMERA_HEIGHT - MainActivity.CAMERA_WIDTH) / 2;
  setBackground(new Background(Color.WHITE));
  this.attachChild(new Sprite(0,foo,MainActivity.CAMERA_WIDTH,MainActivity.CAMERA_WIDTH,ResourcesManager.getInstance().loadingScreenBackgroundRegion,vbom){
    @Override protected void preDraw(    GLState pGLState,    Camera pCamera){
      super.preDraw(pGLState,pCamera);
      pGLState.enableDither();
    }
  }
);
}","@Override public void createScene(Object o){
  float spriteSTartY=(camera.getHeight() - camera.getWidth()) / 2;
  setBackground(new Background(Color.WHITE));
  this.attachChild(new Sprite(0,spriteSTartY,camera.getWidth(),camera.getWidth(),ResourcesManager.getInstance().loadingScreenBackgroundRegion,vbom){
    @Override protected void preDraw(    GLState pGLState,    Camera pCamera){
      super.preDraw(pGLState,pCamera);
      pGLState.enableDither();
    }
  }
);
}"
13909,"private void createMenuChildScene(){
  Sprite playItemSprite=new Sprite(0,0,resourcesManager.play_region,vbom){
    @Override public boolean onAreaTouched(    TouchEvent pSceneTouchEvent,    float pTouchAreaLocalX,    float pTouchAreaLocalY){
      sceneService.loadGameScene();
      return true;
    }
  }
;
  playItemSprite.setPosition(MainActivity.CAMERA_WIDTH / 2 - playItemSprite.getWidthScaled() / 2,MainActivity.CAMERA_HEIGHT / 2 - playItemSprite.getHeightScaled());
  attachChild(playItemSprite);
  registerTouchArea(playItemSprite);
  Sprite levelItemSprite=new Sprite(0,0,resourcesManager.level_mode_region,vbom){
    @Override public boolean onAreaTouched(    TouchEvent pSceneTouchEvent,    float pTouchAreaLocalX,    float pTouchAreaLocalY){
      sceneService.loadLevelChoiceSceneFromMenuScene();
      return true;
    }
  }
;
  levelItemSprite.setPosition(MainActivity.CAMERA_WIDTH / 2 - levelItemSprite.getWidthScaled() / 2,MainActivity.CAMERA_HEIGHT / 2);
  attachChild(levelItemSprite);
  registerTouchArea(levelItemSprite);
}","private void createMenuChildScene(){
  Sprite playItemSprite=new Sprite(0,0,resourcesManager.play_region,vbom){
    @Override public boolean onAreaTouched(    TouchEvent pSceneTouchEvent,    float pTouchAreaLocalX,    float pTouchAreaLocalY){
      sceneService.loadGameScene();
      return true;
    }
  }
;
  playItemSprite.setPosition(camera.getWidth() / 2 - playItemSprite.getWidthScaled() / 2,camera.getHeight() / 2 - playItemSprite.getHeightScaled());
  attachChild(playItemSprite);
  registerTouchArea(playItemSprite);
  Sprite levelItemSprite=new Sprite(0,0,resourcesManager.level_mode_region,vbom){
    @Override public boolean onAreaTouched(    TouchEvent pSceneTouchEvent,    float pTouchAreaLocalX,    float pTouchAreaLocalY){
      sceneService.loadLevelChoiceSceneFromMenuScene();
      return true;
    }
  }
;
  levelItemSprite.setPosition(camera.getWidth() / 2 - levelItemSprite.getWidthScaled() / 2,camera.getHeight() / 2);
  attachChild(levelItemSprite);
  registerTouchArea(levelItemSprite);
}"
13910,"@Override public void onHold(HoldDetector pHoldDetector,long pHoldTimeMilliseconds,int pPointerID,float pHoldX,float pHoldY){
  if (!horizontal && !vertical) {
    if (Math.abs(moveStartX - pHoldX) > MainActivity.CAMERA_WIDTH / 100) {
      horizontal=true;
      row=(int)((moveStartY - startY) / widthPerTile);
    }
    if (Math.abs(moveStartY - pHoldY) > MainActivity.CAMERA_WIDTH / 100) {
      vertical=true;
      row=(int)((moveStartX - startX) / widthPerTile);
    }
  }
 else {
    if (horizontal) {
      float moveSize=pHoldX - moveStartX;
      if (moveSize > widthPerTile) {
        gameService.shiftLine(true,row,1);
        moveStartX=pHoldX;
        gameScene.moveTiles(true,row,0,true);
      }
 else       if (moveSize < (0 - widthPerTile)) {
        gameService.shiftLine(true,row,-1);
        moveStartX=pHoldX;
        gameScene.moveTiles(true,row,0,true);
      }
 else {
        gameScene.moveTiles(true,row,moveSize,false);
      }
    }
 else {
      float moveSize=pHoldY - moveStartY;
      if (moveSize > widthPerTile) {
        gameService.shiftLine(false,row,1);
        moveStartY=pHoldY;
        gameScene.moveTiles(false,row,0,true);
      }
 else       if (moveSize < (0 - widthPerTile)) {
        gameService.shiftLine(false,row,-1);
        moveStartY=pHoldY;
        gameScene.moveTiles(false,row,0,true);
      }
 else {
        gameScene.moveTiles(false,row,moveSize,false);
      }
    }
  }
}","@Override public void onHold(HoldDetector pHoldDetector,long pHoldTimeMilliseconds,int pPointerID,float pHoldX,float pHoldY){
  if (!horizontal && !vertical) {
    if (Math.abs(moveStartX - pHoldX) > gameScene.camera.getWidth() / 100) {
      horizontal=true;
      row=(int)((moveStartY - startY) / widthPerTile);
    }
    if (Math.abs(moveStartY - pHoldY) > gameScene.camera.getWidth() / 100) {
      vertical=true;
      row=(int)((moveStartX - startX) / widthPerTile);
    }
  }
 else {
    if (horizontal) {
      float moveSize=pHoldX - moveStartX;
      if (moveSize > widthPerTile) {
        gameService.shiftLine(true,row,1);
        moveStartX=pHoldX;
        gameScene.moveTiles(true,row,0,true);
      }
 else       if (moveSize < (0 - widthPerTile)) {
        gameService.shiftLine(true,row,-1);
        moveStartX=pHoldX;
        gameScene.moveTiles(true,row,0,true);
      }
 else {
        gameScene.moveTiles(true,row,moveSize,false);
      }
    }
 else {
      float moveSize=pHoldY - moveStartY;
      if (moveSize > widthPerTile) {
        gameService.shiftLine(false,row,1);
        moveStartY=pHoldY;
        gameScene.moveTiles(false,row,0,true);
      }
 else       if (moveSize < (0 - widthPerTile)) {
        gameService.shiftLine(false,row,-1);
        moveStartY=pHoldY;
        gameScene.moveTiles(false,row,0,true);
      }
 else {
        gameScene.moveTiles(false,row,moveSize,false);
      }
    }
  }
}"
13911,"public void shiftLine(GameField gameField,boolean horizontal,int row,int steps){
  if (horizontal) {
    Tile line[]=new Tile[gameField.getField().length - 2];
    for (int i=0; i < gameField.getField().length - 2; i++) {
      line[i]=gameField.getField()[i + 1][row + 1];
      gameField.getField()[i + 1][row + 1]=null;
    }
    for (int i=0; i < gameField.getField().length - 2; i++) {
      int newPosition=i + steps;
      newPosition=shiftToPositive(newPosition,gameField.getField().length - 2);
      newPosition=newPosition % (gameField.getField().length - 2);
      gameField.getField()[newPosition + 1][row + 1]=line[i];
    }
  }
 else {
    Tile line[]=new Tile[gameField.getField()[0].length - 2];
    for (int i=0; i < gameField.getField()[0].length - 2; i++) {
      line[i]=gameField.getField()[row + 1][i + 1];
      gameField.getField()[row + 1][i + 1]=null;
    }
    for (int i=0; i < gameField.getField()[0].length - 2; i++) {
      int newPosition=(i + steps);
      newPosition=shiftToPositive(newPosition,gameField.getField()[0].length - 2);
      newPosition=newPosition % (gameField.getField()[0].length - 2);
      gameField.getField()[row + 1][newPosition + 1]=line[i];
    }
  }
}","public void shiftLine(GameField gameField,boolean horizontal,int row,int steps){
  if (horizontal) {
    if (row < gameField.getField().length - 2) {
      Tile line[]=new Tile[gameField.getField().length - 2];
      for (int i=0; i < gameField.getField().length - 2; i++) {
        line[i]=gameField.getField()[i + 1][row + 1];
        gameField.getField()[i + 1][row + 1]=null;
      }
      for (int i=0; i < gameField.getField().length - 2; i++) {
        int newPosition=i + steps;
        newPosition=shiftToPositive(newPosition,gameField.getField().length - 2);
        newPosition=newPosition % (gameField.getField().length - 2);
        gameField.getField()[newPosition + 1][row + 1]=line[i];
      }
    }
  }
 else {
    if (row < gameField.getField()[0].length - 2) {
      Tile line[]=new Tile[gameField.getField()[0].length - 2];
      for (int i=0; i < gameField.getField()[0].length - 2; i++) {
        line[i]=gameField.getField()[row + 1][i + 1];
        gameField.getField()[row + 1][i + 1]=null;
      }
      for (int i=0; i < gameField.getField()[0].length - 2; i++) {
        int newPosition=(i + steps);
        newPosition=shiftToPositive(newPosition,gameField.getField()[0].length - 2);
        newPosition=newPosition % (gameField.getField()[0].length - 2);
        gameField.getField()[row + 1][newPosition + 1]=line[i];
      }
    }
  }
}"
13912,"public GameField destroyField(GameField gameField,int minShiftCount,int maxShiftCount,int maxValue){
  GameFieldService gameFieldService=new GameFieldService();
  GameEndService gameEndService=new GameEndService();
  int shiftCount=(int)(Math.random() * (maxShiftCount - minShiftCount + 1) + minShiftCount);
  for (int i=0; i < shiftCount; i++) {
    boolean horizontal=(Math.random() > 0.5f);
    int row;
    if (horizontal) {
      row=(int)(Math.random() * (gameField.getField()[0].length - 1));
    }
 else {
      row=(int)(Math.random() * (gameField.getField().length - 1));
    }
    gameFieldService.shiftLine(gameField,horizontal,row,(int)(Math.random() * (maxValue + 1)));
  }
  return gameField;
}","public GameField destroyField(GameField gameField,int minShiftCount,int maxShiftCount,int maxValue){
  GameFieldService gameFieldService=new GameFieldService();
  GameEndService gameEndService=new GameEndService();
  int shiftCount=(int)(Math.random() * (maxShiftCount - minShiftCount + 1) + minShiftCount);
  for (int i=0; i < shiftCount; i++) {
    boolean horizontal=(Math.random() > 0.5f);
    int row;
    if (horizontal) {
      row=(int)(Math.random() * (gameField.getField()[0].length - 2));
    }
 else {
      row=(int)(Math.random() * (gameField.getField().length - 2));
    }
    gameFieldService.shiftLine(gameField,horizontal,row,(int)(Math.random() * (maxValue + 1)));
  }
  return gameField;
}"
13913,"public GameField generateSolvedField(int width,int height){
  GameField gameField=new GameField();
  int startX;
  int startY;
  int direction;
  tiles=new Tile[width][height];
  for (int i=1; i < width - 1; i++) {
    for (int j=1; j < height - 1; j++) {
      tiles[i][j]=new Tile(false,false,false,false,UNDEFINED,'o');
    }
  }
  for (int i=0; i < width; i++) {
    tiles[i][0]=new Tile(false,false,false,false,TileType.NONE,'n');
  }
  for (int i=0; i < width; i++) {
    tiles[i][height - 1]=new Tile(false,false,false,false,TileType.NONE,'n');
  }
  for (int i=0; i < height; i++) {
    tiles[0][i]=new Tile(false,false,false,false,TileType.NONE,'n');
  }
  for (int i=0; i < height; i++) {
    tiles[width - 1][i]=new Tile(false,false,false,false,TileType.NONE,'n');
  }
  Tile startTile;
switch ((int)(Math.random() * (4))) {
case 0:
    startTile=new Tile(false,true,false,false,TileType.START,'s');
  startX=(int)(Math.random() * (width - 2) + 1);
startY=0;
direction=0;
tiles[startX][0]=startTile;
break;
case 1:
startTile=new Tile(true,false,false,false,TileType.START,'s');
startX=(int)(Math.random() * (width - 2) + 1);
startY=height - 1;
direction=2;
tiles[startX][height - 1]=startTile;
break;
case 2:
startTile=new Tile(false,false,false,true,TileType.START,'s');
startX=0;
startY=(int)(Math.random() * (height - 2) + 1);
direction=1;
tiles[startX][startY]=startTile;
break;
case 3:
startTile=new Tile(false,false,true,false,TileType.START,'s');
startX=width - 1;
startY=(int)(Math.random() * (height - 2) + 1);
direction=3;
tiles[startX][startY]=startTile;
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
int x=startX;
int y=startY;
while ((x != 0 && x != width - 1 && y != 0 && y != height - 1) || (x == startX && y == startY)) {
if (Math.random() < 0.7f && !(startX == x && startY == y)) {
direction=(int)(Math.random() * 4);
}
int xNew=x + directionsX[direction];
int yNew=y + directionsY[direction];
while (tiles[xNew][yNew].getTileType() != UNDEFINED && tiles[xNew][yNew].getShortcut() != 'n') {
direction=(int)(Math.random() * (4) + 0);
xNew=x + directionsX[direction];
yNew=y + directionsY[direction];
}
switch (direction) {
case 0:
tiles[x][y].setBottom(true);
tiles[xNew][yNew].setTop(true);
break;
case 1:
tiles[x][y].setRight(true);
tiles[xNew][yNew].setLeft(true);
break;
case 2:
tiles[x][y].setTop(true);
tiles[xNew][yNew].setBottom(true);
break;
case 3:
tiles[x][y].setLeft(true);
tiles[xNew][yNew].setRight(true);
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
x=xNew;
y=yNew;
tiles[x][y].setTileType(TileType.PUZZLE);
}
for (int i=1; i < width - 1; i++) {
for (int j=1; j < height - 1; j++) {
tiles[i][j].setTileType(PUZZLE);
tiles[i][j].setShortcut(tileShortcutHashMap.get(tiles[i][j]));
}
}
tiles[x][y].setTileType(TileType.FINISH);
tiles[x][y].setShortcut('f');
gameField.setStartX(startX);
gameField.setStartY(startY);
gameField.setField(tiles);
return gameField;
}","public GameField generateSolvedField(int width,int height){
  int number=0;
  GameField gameField=new GameField();
  int startX;
  int startY;
  int direction;
  tiles=new Tile[width][height];
  for (int i=1; i < width - 1; i++) {
    for (int j=1; j < height - 1; j++) {
      tiles[i][j]=new Tile(false,false,false,false,UNDEFINED,'o');
    }
  }
  for (int i=0; i < width; i++) {
    tiles[i][0]=new Tile(false,false,false,false,TileType.NONE,'n');
  }
  for (int i=0; i < width; i++) {
    tiles[i][height - 1]=new Tile(false,false,false,false,TileType.NONE,'n');
  }
  for (int i=0; i < height; i++) {
    tiles[0][i]=new Tile(false,false,false,false,TileType.NONE,'n');
  }
  for (int i=0; i < height; i++) {
    tiles[width - 1][i]=new Tile(false,false,false,false,TileType.NONE,'n');
  }
  Tile startTile;
switch ((int)(Math.random() * (4))) {
case 0:
    startTile=new Tile(false,true,false,false,TileType.START,'s');
  startX=(int)(Math.random() * (width - 2) + 1);
startY=0;
direction=0;
tiles[startX][0]=startTile;
break;
case 1:
startTile=new Tile(true,false,false,false,TileType.START,'s');
startX=(int)(Math.random() * (width - 2) + 1);
startY=height - 1;
direction=2;
tiles[startX][height - 1]=startTile;
break;
case 2:
startTile=new Tile(false,false,false,true,TileType.START,'s');
startX=0;
startY=(int)(Math.random() * (height - 2) + 1);
direction=1;
tiles[startX][startY]=startTile;
break;
case 3:
startTile=new Tile(false,false,true,false,TileType.START,'s');
startX=width - 1;
startY=(int)(Math.random() * (height - 2) + 1);
direction=3;
tiles[startX][startY]=startTile;
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
int x=startX;
int y=startY;
while ((x != 0 && x != width - 1 && y != 0 && y != height - 1) || (x == startX && y == startY)) {
number++;
if (Math.random() < 0.7f && !(startX == x && startY == y)) {
direction=(int)(Math.random() * 4);
}
int xNew=x + directionsX[direction];
int yNew=y + directionsY[direction];
boolean directions[]=new boolean[]{false,false,false,false};
while (tiles[xNew][yNew].getTileType() != UNDEFINED && tiles[xNew][yNew].getShortcut() != 'n') {
if (directions[0] && directions[1] && directions[2]&& directions[3]) {
return generateSolvedField(width,height);
}
directions[direction]=true;
direction=(int)(Math.random() * (4) + 0);
xNew=x + directionsX[direction];
yNew=y + directionsY[direction];
}
switch (direction) {
case 0:
tiles[x][y].setBottom(true);
tiles[xNew][yNew].setTop(true);
break;
case 1:
tiles[x][y].setRight(true);
tiles[xNew][yNew].setLeft(true);
break;
case 2:
tiles[x][y].setTop(true);
tiles[xNew][yNew].setBottom(true);
break;
case 3:
tiles[x][y].setLeft(true);
tiles[xNew][yNew].setRight(true);
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
x=xNew;
y=yNew;
tiles[x][y].setTileType(TileType.PUZZLE);
}
for (int i=1; i < width - 1; i++) {
for (int j=1; j < height - 1; j++) {
tiles[i][j].setTileType(PUZZLE);
tiles[i][j].setShortcut(tileShortcutHashMap.get(tiles[i][j]));
}
}
tiles[x][y].setTileType(TileType.FINISH);
tiles[x][y].setShortcut('f');
gameField.setStartX(startX);
gameField.setStartY(startY);
gameField.setField(tiles);
if (number > (width - 2) * (height - 2) / 3) {
return gameField;
}
 else {
return generateSolvedField(width,height);
}
}"
13914,"/** 
 * Returns an instance of this Chronology that operates in the UTC time zone. Chronologies that do not operate in a time zone or are already UTC must return themself.
 * @return a version of this chronology that ignores time zones
 */
public abstract Chronology withUTC();","/** 
 * Returns an instance of this Chronology that operates in the UTC time zone. Chronologies that do not operate in a time zone or are already UTC must return themselves.
 * @return a version of this chronology that ignores time zones
 */
public abstract Chronology withUTC();"
13915,"/** 
 * Returns a copy of this date with the century of era field updated. <p> DateMidnight is immutable, so there are no set methods. Instead, this method returns a new instance with the value of century of era changed.
 * @param centuryOfEra  the centurey of era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 * @since 1.3
 */
public DateMidnight withCenturyOfEra(int centuryOfEra){
  return withMillis(getChronology().centuryOfEra().set(getMillis(),centuryOfEra));
}","/** 
 * Returns a copy of this date with the century of era field updated. <p> DateMidnight is immutable, so there are no set methods. Instead, this method returns a new instance with the value of century of era changed.
 * @param centuryOfEra  the century of era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 * @since 1.3
 */
public DateMidnight withCenturyOfEra(int centuryOfEra){
  return withMillis(getChronology().centuryOfEra().set(getMillis(),centuryOfEra));
}"
13916,"/** 
 * Returns a new DateTime with this field set to the maximum value for this field. <p> This operation is useful for obtaining a DateTime on the last day of the month, as month lengths vary. <pre> DateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue(); </pre> <p> Where possible, the offset from UTC will be retained, thus applications may need to call   {@link DateTime#withLaterOffsetAtOverlap()} on the resultto force the later time during a DST overlap if desired. <p> From v2.2, this method handles a daylight svaings time gap, setting the time to the last instant before the gap. <p> The DateTime attached to this property is unchanged by this call.
 * @return a copy of the DateTime with this field set to its maximum
 * @since 1.2
 */
public DateTime withMaximumValue(){
  try {
    return setCopy(getMaximumValue());
  }
 catch (  RuntimeException ex) {
    if (IllegalInstantException.isIllegalInstant(ex)) {
      long beforeGap=getChronology().getZone().previousTransition(getMillis() + DateTimeConstants.MILLIS_PER_DAY);
      return new DateTime(beforeGap,getChronology());
    }
    throw ex;
  }
}","/** 
 * Returns a new DateTime with this field set to the maximum value for this field. <p> This operation is useful for obtaining a DateTime on the last day of the month, as month lengths vary. <pre> DateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue(); </pre> <p> Where possible, the offset from UTC will be retained, thus applications may need to call   {@link DateTime#withLaterOffsetAtOverlap()} on the resultto force the later time during a DST overlap if desired. <p> From v2.2, this method handles a daylight savings time gap, setting the time to the last instant before the gap. <p> The DateTime attached to this property is unchanged by this call.
 * @return a copy of the DateTime with this field set to its maximum
 * @since 1.2
 */
public DateTime withMaximumValue(){
  try {
    return setCopy(getMaximumValue());
  }
 catch (  RuntimeException ex) {
    if (IllegalInstantException.isIllegalInstant(ex)) {
      long beforeGap=getChronology().getZone().previousTransition(getMillis() + DateTimeConstants.MILLIS_PER_DAY);
      return new DateTime(beforeGap,getChronology());
    }
    throw ex;
  }
}"
13917,"/** 
 * Returns a new DateTime with this field set to the minimum value for this field. <p> Where possible, the offset from UTC will be retained, thus applications may need to call   {@link DateTime#withEarlierOffsetAtOverlap()} on the resultto force the earlier time during a DST overlap if desired. <p> From v2.2, this method handles a daylight svaings time gap, setting the time to the first instant after the gap. <p> The DateTime attached to this property is unchanged by this call.
 * @return a copy of the DateTime with this field set to its minimum
 * @since 1.2
 */
public DateTime withMinimumValue(){
  try {
    return setCopy(getMinimumValue());
  }
 catch (  RuntimeException ex) {
    if (IllegalInstantException.isIllegalInstant(ex)) {
      long afterGap=getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY);
      return new DateTime(afterGap,getChronology());
    }
    throw ex;
  }
}","/** 
 * Returns a new DateTime with this field set to the minimum value for this field. <p> Where possible, the offset from UTC will be retained, thus applications may need to call   {@link DateTime#withEarlierOffsetAtOverlap()} on the resultto force the earlier time during a DST overlap if desired. <p> From v2.2, this method handles a daylight savings time gap, setting the time to the first instant after the gap. <p> The DateTime attached to this property is unchanged by this call.
 * @return a copy of the DateTime with this field set to its minimum
 * @since 1.2
 */
public DateTime withMinimumValue(){
  try {
    return setCopy(getMinimumValue());
  }
 catch (  RuntimeException ex) {
    if (IllegalInstantException.isIllegalInstant(ex)) {
      long afterGap=getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY);
      return new DateTime(afterGap,getChronology());
    }
    throw ex;
  }
}"
13918,"/** 
 * Returns a copy of this datetime with the century of era field updated. <p> DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of century of era changed.
 * @param centuryOfEra  the centurey of era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 * @since 1.3
 */
public DateTime withCenturyOfEra(int centuryOfEra){
  return withMillis(getChronology().centuryOfEra().set(getMillis(),centuryOfEra));
}","/** 
 * Returns a copy of this datetime with the century of era field updated. <p> DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of century of era changed.
 * @param centuryOfEra  the century of era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 * @since 1.3
 */
public DateTime withCenturyOfEra(int centuryOfEra){
  return withMillis(getChronology().centuryOfEra().set(getMillis(),centuryOfEra));
}"
13919,"/** 
 * Adds a value (which may be negative) to the partial instant, wrapping the whole partial if the maximum size of the partial is reached. <p> The value will be added to this field, overflowing into larger fields if necessary. Smaller fields should be unaffected, except where the result would be an invalid value for a smaller field. In this case the smaller field is adjusted to be in range. <p> Partial instants only contain some fields. This may result in a maximum possible value, such as TimeOfDay normally being limited to 23:59:59:999. If ths limit is reached by the addition, this method will wrap back to 00:00:00.000. In fact, you would generally only use this method for classes that have a limitation such as this. <p> For example, in the ISO chronology:<br> 10:20:30 add 20 minutes is 10:40:30<br> 10:20:30 add 45 minutes is 11:05:30<br> 10:20:30 add 16 hours is 02:20:30<br>
 * @param instant  the partial instant
 * @param fieldIndex  the index of this field in the partial
 * @param values  the values of the partial instant which should be updated
 * @param valueToAdd  the value to add, in the units of the field
 * @return the passed in values
 * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached
 */
public abstract int[] addWrapPartial(ReadablePartial instant,int fieldIndex,int[] values,int valueToAdd);","/** 
 * Adds a value (which may be negative) to the partial instant, wrapping the whole partial if the maximum size of the partial is reached. <p> The value will be added to this field, overflowing into larger fields if necessary. Smaller fields should be unaffected, except where the result would be an invalid value for a smaller field. In this case the smaller field is adjusted to be in range. <p> Partial instants only contain some fields. This may result in a maximum possible value, such as TimeOfDay normally being limited to 23:59:59:999. If this limit is reached by the addition, this method will wrap back to 00:00:00.000. In fact, you would generally only use this method for classes that have a limitation such as this. <p> For example, in the ISO chronology:<br> 10:20:30 add 20 minutes is 10:40:30<br> 10:20:30 add 45 minutes is 11:05:30<br> 10:20:30 add 16 hours is 02:20:30<br>
 * @param instant  the partial instant
 * @param fieldIndex  the index of this field in the partial
 * @param values  the values of the partial instant which should be updated
 * @param valueToAdd  the value to add, in the units of the field
 * @return the passed in values
 * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached
 */
public abstract int[] addWrapPartial(ReadablePartial instant,int fieldIndex,int[] values,int valueToAdd);"
13920,"/** 
 * Constructor.
 * @param name  the name to use
 * @param ordinal  the byte value for the oridinal index
 * @param unitType  the unit duration type
 * @param rangeType  the range duration type
 */
StandardDateTimeFieldType(String name,byte ordinal,DurationFieldType unitType,DurationFieldType rangeType){
  super(name);
  iOrdinal=ordinal;
  iUnitType=unitType;
  iRangeType=rangeType;
}","/** 
 * Constructor.
 * @param name  the name to use
 * @param ordinal  the byte value for the ordinal index
 * @param unitType  the unit duration type
 * @param rangeType  the range duration type
 */
StandardDateTimeFieldType(String name,byte ordinal,DurationFieldType unitType,DurationFieldType rangeType){
  super(name);
  iOrdinal=ordinal;
  iUnitType=unitType;
  iRangeType=rangeType;
}"
13921,"/** 
 * Gets a hash code compatable with equals.
 * @return suitable hashcode
 */
public int hashCode(){
  return 57 + getID().hashCode();
}","/** 
 * Gets a hash code compatible with equals.
 * @return suitable hashcode
 */
public int hashCode(){
  return 57 + getID().hashCode();
}"
13922,"/** 
 * Creates a <code>Days</code> representing the number of whole days in the specified interval. This method corectly handles any daylight savings time changes that may occur during the interval.
 * @param interval  the interval to extract days from, null returns zero
 * @return the period in days
 * @throws IllegalArgumentException if the partials are null or invalid
 */
public static Days daysIn(ReadableInterval interval){
  if (interval == null) {
    return Days.ZERO;
  }
  int amount=BaseSingleFieldPeriod.between(interval.getStart(),interval.getEnd(),DurationFieldType.days());
  return Days.days(amount);
}","/** 
 * Creates a <code>Days</code> representing the number of whole days in the specified interval. This method correctly handles any daylight savings time changes that may occur during the interval.
 * @param interval  the interval to extract days from, null returns zero
 * @return the period in days
 * @throws IllegalArgumentException if the partials are null or invalid
 */
public static Days daysIn(ReadableInterval interval){
  if (interval == null) {
    return Days.ZERO;
  }
  int amount=BaseSingleFieldPeriod.between(interval.getStart(),interval.getEnd(),DurationFieldType.days());
  return Days.days(amount);
}"
13923,"/** 
 * Returns a copy of this date with the century of era field updated. <p> LocalDate is immutable, so there are no set methods. Instead, this method returns a new instance with the value of century of era changed.
 * @param centuryOfEra  the centurey of era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */
public LocalDate withCenturyOfEra(int centuryOfEra){
  return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(),centuryOfEra));
}","/** 
 * Returns a copy of this date with the century of era field updated. <p> LocalDate is immutable, so there are no set methods. Instead, this method returns a new instance with the value of century of era changed.
 * @param centuryOfEra  the century of era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */
public LocalDate withCenturyOfEra(int centuryOfEra){
  return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(),centuryOfEra));
}"
13924,"/** 
 * Gets the value of the field at the specifed index. <p> This method is required to support the <code>ReadablePartial</code> interface. The supported fields are Year, MonthOfYear and DayOfMonth. Note that all fields from day and above may in fact be queried via other methods.
 * @param index  the index, zero to two
 * @return the value
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public int getValue(int index){
switch (index) {
case YEAR:
    return getChronology().year().get(getLocalMillis());
case MONTH_OF_YEAR:
  return getChronology().monthOfYear().get(getLocalMillis());
case DAY_OF_MONTH:
return getChronology().dayOfMonth().get(getLocalMillis());
default :
throw new IndexOutOfBoundsException(""String_Node_Str"" + index);
}
}","/** 
 * Gets the value of the field at the specified index. <p> This method is required to support the <code>ReadablePartial</code> interface. The supported fields are Year, MonthOfYear and DayOfMonth. Note that all fields from day and above may in fact be queried via other methods.
 * @param index  the index, zero to two
 * @return the value
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public int getValue(int index){
switch (index) {
case YEAR:
    return getChronology().year().get(getLocalMillis());
case MONTH_OF_YEAR:
  return getChronology().monthOfYear().get(getLocalMillis());
case DAY_OF_MONTH:
return getChronology().dayOfMonth().get(getLocalMillis());
default :
throw new IndexOutOfBoundsException(""String_Node_Str"" + index);
}
}"
13925,"/** 
 * Returns a copy of this datetime with the century of era field updated. <p> LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of century of era changed.
 * @param centuryOfEra  the centurey of era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */
public LocalDateTime withCenturyOfEra(int centuryOfEra){
  return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(),centuryOfEra));
}","/** 
 * Returns a copy of this datetime with the century of era field updated. <p> LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of century of era changed.
 * @param centuryOfEra  the century of era to set
 * @return a copy of this object with the field set
 * @throws IllegalArgumentException if the value is invalid
 */
public LocalDateTime withCenturyOfEra(int centuryOfEra){
  return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(),centuryOfEra));
}"
13926,"/** 
 * Gets the value of the field at the specifed index. <p> This method is required to support the <code>ReadablePartial</code> interface. The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
 * @param index  the index, zero to two
 * @return the value
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public int getValue(int index){
switch (index) {
case YEAR:
    return getChronology().year().get(getLocalMillis());
case MONTH_OF_YEAR:
  return getChronology().monthOfYear().get(getLocalMillis());
case DAY_OF_MONTH:
return getChronology().dayOfMonth().get(getLocalMillis());
case MILLIS_OF_DAY:
return getChronology().millisOfDay().get(getLocalMillis());
default :
throw new IndexOutOfBoundsException(""String_Node_Str"" + index);
}
}","/** 
 * Gets the value of the field at the specified index. <p> This method is required to support the <code>ReadablePartial</code> interface. The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
 * @param index  the index, zero to two
 * @return the value
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public int getValue(int index){
switch (index) {
case YEAR:
    return getChronology().year().get(getLocalMillis());
case MONTH_OF_YEAR:
  return getChronology().monthOfYear().get(getLocalMillis());
case DAY_OF_MONTH:
return getChronology().dayOfMonth().get(getLocalMillis());
case MILLIS_OF_DAY:
return getChronology().millisOfDay().get(getLocalMillis());
default :
throw new IndexOutOfBoundsException(""String_Node_Str"" + index);
}
}"
13927,"/** 
 * Gets the value of the field at the specifed index. <p> This method is required to support the <code>ReadablePartial</code> interface. The supported fields are HourOfDay, MinuteOfHour, SecondOfMinute and MillisOfSecond.
 * @param index  the index, zero to three
 * @return the value
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public int getValue(int index){
switch (index) {
case HOUR_OF_DAY:
    return getChronology().hourOfDay().get(getLocalMillis());
case MINUTE_OF_HOUR:
  return getChronology().minuteOfHour().get(getLocalMillis());
case SECOND_OF_MINUTE:
return getChronology().secondOfMinute().get(getLocalMillis());
case MILLIS_OF_SECOND:
return getChronology().millisOfSecond().get(getLocalMillis());
default :
throw new IndexOutOfBoundsException(""String_Node_Str"" + index);
}
}","/** 
 * Gets the value of the field at the specified index. <p> This method is required to support the <code>ReadablePartial</code> interface. The supported fields are HourOfDay, MinuteOfHour, SecondOfMinute and MillisOfSecond.
 * @param index  the index, zero to three
 * @return the value
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public int getValue(int index){
switch (index) {
case HOUR_OF_DAY:
    return getChronology().hourOfDay().get(getLocalMillis());
case MINUTE_OF_HOUR:
  return getChronology().minuteOfHour().get(getLocalMillis());
case SECOND_OF_MINUTE:
return getChronology().secondOfMinute().get(getLocalMillis());
case MILLIS_OF_SECOND:
return getChronology().millisOfSecond().get(getLocalMillis());
default :
throw new IndexOutOfBoundsException(""String_Node_Str"" + index);
}
}"
13928,"/** 
 * Converts this LocalTime to a full datetime using the specified time zone setting the time fields from this instance and the date fields from the current time. <p> This method uses the chronology from this instance plus the time zone specified.
 * @param zone  the zone to use, null means default
 * @return this time as a datetime using todays date
 */
public DateTime toDateTimeToday(DateTimeZone zone){
  Chronology chrono=getChronology().withZone(zone);
  long instantMillis=DateTimeUtils.currentTimeMillis();
  long resolved=chrono.set(this,instantMillis);
  return new DateTime(resolved,chrono);
}","/** 
 * Converts this LocalTime to a full datetime using the specified time zone setting the time fields from this instance and the date fields from the current time. <p> This method uses the chronology from this instance plus the time zone specified.
 * @param zone  the zone to use, null means default
 * @return this time as a datetime using today's date
 */
public DateTime toDateTimeToday(DateTimeZone zone){
  Chronology chrono=getChronology().withZone(zone);
  long instantMillis=DateTimeUtils.currentTimeMillis();
  long resolved=chrono.set(this,instantMillis);
  return new DateTime(resolved,chrono);
}"
13929,"/** 
 * Creates a <code>Months</code> representing the number of whole months in the specified interval. This method corectly handles any daylight savings time changes that may occur during the interval.
 * @param interval  the interval to extract months from, null returns zero
 * @return the period in months
 * @throws IllegalArgumentException if the partials are null or invalid
 */
public static Months monthsIn(ReadableInterval interval){
  if (interval == null) {
    return Months.ZERO;
  }
  int amount=BaseSingleFieldPeriod.between(interval.getStart(),interval.getEnd(),DurationFieldType.months());
  return Months.months(amount);
}","/** 
 * Creates a <code>Months</code> representing the number of whole months in the specified interval. This method correctly handles any daylight savings time changes that may occur during the interval.
 * @param interval  the interval to extract months from, null returns zero
 * @return the period in months
 * @throws IllegalArgumentException if the partials are null or invalid
 */
public static Months monthsIn(ReadableInterval interval){
  if (interval == null) {
    return Months.ZERO;
  }
  int amount=BaseSingleFieldPeriod.between(interval.getStart(),interval.getEnd(),DurationFieldType.months());
  return Months.months(amount);
}"
13930,"/** 
 * Gets a copy of this Partial with the value of the specified field increased. If this partial does not support the field, an exception is thrown. <p> If the addition is zero, then <code>this</code> is returned. The addition will overflow into larger fields (eg. minute to hour). If the maximum is reached, the addition will wra.
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */
public Partial withFieldAddWrapped(DurationFieldType fieldType,int amount){
  int index=indexOfSupported(fieldType);
  if (amount == 0) {
    return this;
  }
  int[] newValues=getValues();
  newValues=getField(index).addWrapPartial(this,index,newValues,amount);
  return new Partial(this,newValues);
}","/** 
 * Gets a copy of this Partial with the value of the specified field increased. If this partial does not support the field, an exception is thrown. <p> If the addition is zero, then <code>this</code> is returned. The addition will overflow into larger fields (eg. minute to hour). If the maximum is reached, the addition will wrap.
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */
public Partial withFieldAddWrapped(DurationFieldType fieldType,int amount){
  int index=indexOfSupported(fieldType);
  if (amount == 0) {
    return this;
  }
  int[] newValues=getValues();
  newValues=getField(index).addWrapPartial(this,index,newValues,amount);
  return new Partial(this,newValues);
}"
13931,"/** 
 * Gets a hash code for the duration that is compatable with the  equals method. The following formula must be used: <pre> long len = getMillis(); return (int) (len ^ (len >>> 32)); </pre>
 * @return a hash code
 */
int hashCode();","/** 
 * Gets a hash code for the duration that is compatible with the equals method. The following formula must be used: <pre> long len = getMillis(); return (int) (len ^ (len >>> 32)); </pre>
 * @return a hash code
 */
int hashCode();"
13932,"/** 
 * Gets a hash code for the time interval that is compatable with the  equals method. <p> The formula used must be as follows: <pre>int result = 97; result = 31 * result + ((int) (getStartMillis() ^ (getStartMillis() >>> 32))); result = 31 * result + ((int) (getEndMillis() ^ (getEndMillis() >>> 32))); result = 31 * result + getChronology().hashCode(); return result;</pre>
 * @return a hash code
 */
int hashCode();","/** 
 * Gets a hash code for the time interval that is compatible with the equals method. <p> The formula used must be as follows: <pre>int result = 97; result = 31 * result + ((int) (getStartMillis() ^ (getStartMillis() >>> 32))); result = 31 * result + ((int) (getEndMillis() ^ (getEndMillis() >>> 32))); result = 31 * result + getChronology().hashCode(); return result;</pre>
 * @return a hash code
 */
int hashCode();"
13933,"/** 
 * Adds to the value of this field in a copy of this TimeOfDay, throwing an Exception if the bounds are exceeded. <p> The value will be added to this field. If the value is too large to be added solely to this field then it will affect larger fields. Smaller fields are unaffected. <p> If the result would be too large (beyond 23:59:59:999) or too small (less than 00:00:00.000) then an Execption is thrown. For the alternate behaviour which wraps to the next 'day', see   {@link #addToCopy(int)}. <p> The TimeOfDay attached to this property is unchanged by this call. Instead, a new instance is returned.
 * @param valueToAdd  the value to add to the field in the copy
 * @return a copy of the TimeOfDay with the field value changed
 * @throws IllegalArgumentException if the value isn't valid
 */
public TimeOfDay addNoWrapToCopy(int valueToAdd){
  int[] newValues=iTimeOfDay.getValues();
  newValues=getField().add(iTimeOfDay,iFieldIndex,newValues,valueToAdd);
  return new TimeOfDay(iTimeOfDay,newValues);
}","/** 
 * Adds to the value of this field in a copy of this TimeOfDay, throwing an Exception if the bounds are exceeded. <p> The value will be added to this field. If the value is too large to be added solely to this field then it will affect larger fields. Smaller fields are unaffected. <p> If the result would be too large (beyond 23:59:59:999) or too small (less than 00:00:00.000) then an Exception is thrown. For the alternate behaviour which wraps to the next 'day', see   {@link #addToCopy(int)}. <p> The TimeOfDay attached to this property is unchanged by this call. Instead, a new instance is returned.
 * @param valueToAdd  the value to add to the field in the copy
 * @return a copy of the TimeOfDay with the field value changed
 * @throws IllegalArgumentException if the value isn't valid
 */
public TimeOfDay addNoWrapToCopy(int valueToAdd){
  int[] newValues=iTimeOfDay.getValues();
  newValues=getField().add(iTimeOfDay,iFieldIndex,newValues,valueToAdd);
  return new TimeOfDay(iTimeOfDay,newValues);
}"
13934,"/** 
 * Constructs a YearMonthDay from a <code>java.util.Date</code> using exactly the same field values avoiding any time zone effects. <p> Each field is queried from the Date and assigned to the YearMonthDay. This is useful if you have been using the Date as a local date, ignoing the zone. <p> This factory method always creates a YearMonthDay with ISO chronology.
 * @param date  the Date to extract fields from
 * @return the created YearMonthDay
 * @throws IllegalArgumentException if the calendar is null
 * @throws IllegalArgumentException if the date is invalid for the ISO chronology
 * @since 1.2
 */
public static YearMonthDay fromDateFields(Date date){
  if (date == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new YearMonthDay(date.getYear() + 1900,date.getMonth() + 1,date.getDate());
}","/** 
 * Constructs a YearMonthDay from a <code>java.util.Date</code> using exactly the same field values avoiding any time zone effects. <p> Each field is queried from the Date and assigned to the YearMonthDay. This is useful if you have been using the Date as a local date, ignoring the zone. <p> This factory method always creates a YearMonthDay with ISO chronology.
 * @param date  the Date to extract fields from
 * @return the created YearMonthDay
 * @throws IllegalArgumentException if the calendar is null
 * @throws IllegalArgumentException if the date is invalid for the ISO chronology
 * @since 1.2
 */
public static YearMonthDay fromDateFields(Date date){
  if (date == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new YearMonthDay(date.getYear() + 1900,date.getMonth() + 1,date.getDate());
}"
13935,"/** 
 * Constructs a YearMonthDay from a <code>java.util.Calendar</code> using exactly the same field values avoiding any time zone effects. <p> Each field is queried from the Calendar and assigned to the YearMonthDay. This is useful if you have been using the Calendar as a local date, ignoing the zone. <p> This factory method ignores the type of the calendar and always creates a YearMonthDay with ISO chronology. It is expected that you will only pass in instances of <code>GregorianCalendar</code> however this is not validated.
 * @param calendar  the Calendar to extract fields from
 * @return the created YearMonthDay
 * @throws IllegalArgumentException if the calendar is null
 * @throws IllegalArgumentException if the date is invalid for the ISO chronology
 * @since 1.2
 */
public static YearMonthDay fromCalendarFields(Calendar calendar){
  if (calendar == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new YearMonthDay(calendar.get(Calendar.YEAR),calendar.get(Calendar.MONTH) + 1,calendar.get(Calendar.DAY_OF_MONTH));
}","/** 
 * Constructs a YearMonthDay from a <code>java.util.Calendar</code> using exactly the same field values avoiding any time zone effects. <p> Each field is queried from the Calendar and assigned to the YearMonthDay. This is useful if you have been using the Calendar as a local date, ignoring the zone. <p> This factory method ignores the type of the calendar and always creates a YearMonthDay with ISO chronology. It is expected that you will only pass in instances of <code>GregorianCalendar</code> however this is not validated.
 * @param calendar  the Calendar to extract fields from
 * @return the created YearMonthDay
 * @throws IllegalArgumentException if the calendar is null
 * @throws IllegalArgumentException if the date is invalid for the ISO chronology
 * @since 1.2
 */
public static YearMonthDay fromCalendarFields(Calendar calendar){
  if (calendar == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new YearMonthDay(calendar.get(Calendar.YEAR),calendar.get(Calendar.MONTH) + 1,calendar.get(Calendar.DAY_OF_MONTH));
}"
13936,"/** 
 * Creates a <code>Years</code> representing the number of whole years in the specified interval. This method corectly handles any daylight savings time changes that may occur during the interval.
 * @param interval  the interval to extract years from, null returns zero
 * @return the period in years
 * @throws IllegalArgumentException if the partials are null or invalid
 */
public static Years yearsIn(ReadableInterval interval){
  if (interval == null) {
    return Years.ZERO;
  }
  int amount=BaseSingleFieldPeriod.between(interval.getStart(),interval.getEnd(),DurationFieldType.years());
  return Years.years(amount);
}","/** 
 * Creates a <code>Years</code> representing the number of whole years in the specified interval. This method correctly handles any daylight savings time changes that may occur during the interval.
 * @param interval  the interval to extract years from, null returns zero
 * @return the period in years
 * @throws IllegalArgumentException if the partials are null or invalid
 */
public static Years yearsIn(ReadableInterval interval){
  if (interval == null) {
    return Years.ZERO;
  }
  int amount=BaseSingleFieldPeriod.between(interval.getStart(),interval.getEnd(),DurationFieldType.years());
  return Years.years(amount);
}"
13937,"/** 
 * Get the date time as a <code>java.util.GregorianCalendar</code>, assigning exactly the same millisecond instant. <p> The JDK and Joda-Time both have time zone implementations and these differ in accuracy. Joda-Time's implementation is generally more up to date and thus more accurate - for example JDK1.3 has no historical data. The effect of this is that the field values of the <code>Calendar</code> may differ from those of this object, even though the milliseond value is the same. Most of the time this just means that the JDK field values are wrong, as our time zone information is more up to date.
 * @return a GregorianCalendar initialised with this datetime
 */
public GregorianCalendar toGregorianCalendar(){
  DateTimeZone zone=getZone();
  GregorianCalendar cal=new GregorianCalendar(zone.toTimeZone());
  cal.setTime(toDate());
  return cal;
}","/** 
 * Get the date time as a <code>java.util.GregorianCalendar</code>, assigning exactly the same millisecond instant. <p> The JDK and Joda-Time both have time zone implementations and these differ in accuracy. Joda-Time's implementation is generally more up to date and thus more accurate - for example JDK1.3 has no historical data. The effect of this is that the field values of the <code>Calendar</code> may differ from those of this object, even though the millisecond value is the same. Most of the time this just means that the JDK field values are wrong, as our time zone information is more up to date.
 * @return a GregorianCalendar initialised with this datetime
 */
public GregorianCalendar toGregorianCalendar(){
  DateTimeZone zone=getZone();
  GregorianCalendar cal=new GregorianCalendar(zone.toTimeZone());
  cal.setTime(toDate());
  return cal;
}"
13938,"/** 
 * Get the date time as a <code>java.util.Calendar</code>, assigning exactly the same millisecond instant. The locale is passed in, enabling Calendar to select the correct localized subclass. <p> The JDK and Joda-Time both have time zone implementations and these differ in accuracy. Joda-Time's implementation is generally more up to date and thus more accurate - for example JDK1.3 has no historical data. The effect of this is that the field values of the <code>Calendar</code> may differ from those of this object, even though the milliseond value is the same. Most of the time this just means that the JDK field values are wrong, as our time zone information is more up to date.
 * @param locale  the locale to get the Calendar for, or default if null
 * @return a localized Calendar initialised with this datetime
 */
public Calendar toCalendar(Locale locale){
  if (locale == null) {
    locale=Locale.getDefault();
  }
  DateTimeZone zone=getZone();
  Calendar cal=Calendar.getInstance(zone.toTimeZone(),locale);
  cal.setTime(toDate());
  return cal;
}","/** 
 * Get the date time as a <code>java.util.Calendar</code>, assigning exactly the same millisecond instant. The locale is passed in, enabling Calendar to select the correct localized subclass. <p> The JDK and Joda-Time both have time zone implementations and these differ in accuracy. Joda-Time's implementation is generally more up to date and thus more accurate - for example JDK1.3 has no historical data. The effect of this is that the field values of the <code>Calendar</code> may differ from those of this object, even though the millisecond value is the same. Most of the time this just means that the JDK field values are wrong, as our time zone information is more up to date.
 * @param locale  the locale to get the Calendar for, or default if null
 * @return a localized Calendar initialised with this datetime
 */
public Calendar toCalendar(Locale locale){
  if (locale == null) {
    locale=Locale.getDefault();
  }
  DateTimeZone zone=getZone();
  Calendar cal=Calendar.getInstance(zone.toTimeZone(),locale);
  cal.setTime(toDate());
  return cal;
}"
13939,"/** 
 * Gets the field at the specifed index.
 * @param index  the index
 * @return the field
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public DateTimeField getField(int index){
  return getField(index,getChronology());
}","/** 
 * Gets the field at the specified index.
 * @param index  the index
 * @return the field
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public DateTimeField getField(int index){
  return getField(index,getChronology());
}"
13940,"/** 
 * Gets the field type at the specifed index.
 * @param index  the index
 * @return the field type
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public DateTimeFieldType getFieldType(int index){
  return getField(index,getChronology()).getType();
}","/** 
 * Gets the field type at the specified index.
 * @param index  the index
 * @return the field type
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public DateTimeFieldType getFieldType(int index){
  return getField(index,getChronology()).getType();
}"
13941,"static int csCompare(CharSequence text,int position,String search){
  int compareLen=Math.min(text.length() - position,search.length());
  for (int i=0; i < compareLen; i++) {
    int result=search.charAt(i) - text.charAt(position + i);
    if (result != 0) {
      return result;
    }
  }
  return 0;
}","static int csCompare(CharSequence text,int position,String search){
  int matchLen=text.length() - position;
  int searchLen=search.length();
  int compareLen=Math.min(matchLen,searchLen);
  for (int i=0; i < compareLen; i++) {
    int result=search.charAt(i) - text.charAt(position + i);
    if (result != 0) {
      return result;
    }
  }
  return searchLen - matchLen;
}"
13942,"Rule(StringTokenizer st){
  iName=st.nextToken().intern();
  iFromYear=parseYear(st.nextToken(),0);
  iToYear=parseYear(st.nextToken(),iFromYear);
  if (iToYear < iFromYear) {
    throw new IllegalArgumentException();
  }
  iType=parseOptional(st.nextToken());
  iDateTimeOfYear=new DateTimeOfYear(st);
  iSaveMillis=parseTime(st.nextToken());
  iLetterS=parseOptional(st.nextToken());
}","Rule(StringTokenizer st){
  if (st.countTokens() < 6) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  iName=st.nextToken().intern();
  iFromYear=parseYear(st.nextToken(),0);
  iToYear=parseYear(st.nextToken(),iFromYear);
  if (iToYear < iFromYear) {
    throw new IllegalArgumentException();
  }
  iType=parseOptional(st.nextToken());
  iDateTimeOfYear=new DateTimeOfYear(st);
  iSaveMillis=parseTime(st.nextToken());
  iLetterS=parseOptional(st.nextToken());
}"
13943,"public void parseDataFile(BufferedReader in,boolean backward) throws IOException {
  Zone zone=null;
  String line;
  while ((line=in.readLine()) != null) {
    String trimmed=line.trim();
    if (trimmed.length() == 0 || trimmed.charAt(0) == '#') {
      continue;
    }
    int index=line.indexOf('#');
    if (index >= 0) {
      line=line.substring(0,index);
    }
    StringTokenizer st=new StringTokenizer(line,""String_Node_Str"");
    if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {
      if (zone != null) {
        zone.chain(st);
      }
      continue;
    }
 else {
      if (zone != null) {
        iZones.add(zone);
      }
      zone=null;
    }
    if (st.hasMoreTokens()) {
      String token=st.nextToken();
      if (token.equalsIgnoreCase(""String_Node_Str"")) {
        Rule r=new Rule(st);
        RuleSet rs=iRuleSets.get(r.iName);
        if (rs == null) {
          rs=new RuleSet(r);
          iRuleSets.put(r.iName,rs);
        }
 else {
          rs.addRule(r);
        }
      }
 else       if (token.equalsIgnoreCase(""String_Node_Str"")) {
        zone=new Zone(st);
      }
 else       if (token.equalsIgnoreCase(""String_Node_Str"")) {
        String real=st.nextToken();
        String alias=st.nextToken();
        if (backward || alias.equals(""String_Node_Str"") || alias.startsWith(""String_Node_Str"")|| alias.equals(""String_Node_Str"")) {
          iBackLinks.add(real);
          iBackLinks.add(alias);
        }
 else {
          iGoodLinks.add(real);
          iGoodLinks.add(alias);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + line);
      }
    }
  }
  if (zone != null) {
    iZones.add(zone);
  }
}","public void parseDataFile(BufferedReader in,boolean backward) throws IOException {
  Zone zone=null;
  String line;
  while ((line=in.readLine()) != null) {
    String trimmed=line.trim();
    if (trimmed.length() == 0 || trimmed.charAt(0) == '#') {
      continue;
    }
    int index=line.indexOf('#');
    if (index >= 0) {
      line=line.substring(0,index);
    }
    StringTokenizer st=new StringTokenizer(line,""String_Node_Str"");
    if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {
      if (zone != null) {
        zone.chain(st);
      }
      continue;
    }
 else {
      if (zone != null) {
        iZones.add(zone);
      }
      zone=null;
    }
    if (st.hasMoreTokens()) {
      String token=st.nextToken();
      if (token.equalsIgnoreCase(""String_Node_Str"")) {
        Rule r=new Rule(st);
        RuleSet rs=iRuleSets.get(r.iName);
        if (rs == null) {
          rs=new RuleSet(r);
          iRuleSets.put(r.iName,rs);
        }
 else {
          rs.addRule(r);
        }
      }
 else       if (token.equalsIgnoreCase(""String_Node_Str"")) {
        if (st.countTokens() < 4) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        zone=new Zone(st);
      }
 else       if (token.equalsIgnoreCase(""String_Node_Str"")) {
        String real=st.nextToken();
        String alias=st.nextToken();
        if (backward || alias.equals(""String_Node_Str"") || alias.startsWith(""String_Node_Str"")|| alias.equals(""String_Node_Str"")) {
          iBackLinks.add(real);
          iBackLinks.add(alias);
        }
 else {
          iGoodLinks.add(real);
          iGoodLinks.add(alias);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + line);
      }
    }
  }
  if (zone != null) {
    iZones.add(zone);
  }
}"
13944,"/** 
 * Creates a new interval with the specified start millisecond instant.
 * @param endInstant  the end instant for the new interval
 * @return an interval with the start from this interval and the specified end
 * @throws IllegalArgumentException if the resulting interval has end before start
 */
public Interval withEndMillis(long endInstant){
  if (endInstant == getEndMillis()) {
    return this;
  }
  return new Interval(getStartMillis(),endInstant,getChronology());
}","/** 
 * Creates a new interval with the specified end millisecond instant.
 * @param endInstant  the end instant for the new interval
 * @return an interval with the start from this interval and the specified end
 * @throws IllegalArgumentException if the resulting interval has end before start
 */
public Interval withEndMillis(long endInstant){
  if (endInstant == getEndMillis()) {
    return this;
  }
  return new Interval(getStartMillis(),endInstant,getChronology());
}"
13945,"/** 
 * Gets the duration of this time interval in milliseconds. <p> The duration is equal to the end millis minus the start millis.
 * @return the duration of the time interval in milliseconds
 * @throws ArithmeticException if the duration exceeds the capacity of a long
 */
public long toDurationMillis(){
  return FieldUtils.safeAdd(getEndMillis(),-getStartMillis());
}","/** 
 * Gets the duration of this time interval in milliseconds. <p> The duration is equal to the end millis minus the start millis.
 * @return the duration of the time interval in milliseconds
 * @throws ArithmeticException if the duration exceeds the capacity of a long
 */
public long toDurationMillis(){
  return FieldUtils.safeSubtract(getEndMillis(),getStartMillis());
}"
13946,"public void testPatchedNameKeysGazaHistoric() throws Exception {
  DateTimeZone zone=DateTimeZone.forID(""String_Node_Str"");
  DateTime now=new DateTime(1944,1,1,0,0,0,0);
  String str1=zone.getName(now.getMillis());
  String str2=zone.getName(now.plusMonths(6).getMillis());
  assertEquals(false,str1.equals(str2));
}","public void testPatchedNameKeysGazaHistoric() throws Exception {
  DateTimeZone zone=DateTimeZone.forID(""String_Node_Str"");
  DateTime now=new DateTime(1943,1,1,0,0,0,0);
  String str1=zone.getName(now.getMillis());
  String str2=zone.getName(now.plusMonths(6).getMillis());
  assertEquals(false,str1.equals(str2));
}"
13947,"protected int getMaximumValueForSet(long instant,int value){
  int maxLessOne=iChronology.getDaysInYearMax() - 1;
  return value > maxLessOne ? getMaximumValue(instant) : maxLessOne;
}","protected int getMaximumValueForSet(long instant,int value){
  int maxLessOne=iChronology.getDaysInYearMax() - 1;
  return (value > maxLessOne || value < 1) ? getMaximumValue(instant) : maxLessOne;
}"
13948,"/** 
 * Gets an instance of the CopticChronology. The time zone of the returned instance is UTC.
 * @return a singleton UTC instance of the chronology
 */
public static IslamicChronology getInstanceUTC(){
  return INSTANCE_UTC;
}","/** 
 * Gets an instance of the IslamicChronology. The time zone of the returned instance is UTC.
 * @return a singleton UTC instance of the chronology
 */
public static IslamicChronology getInstanceUTC(){
  return INSTANCE_UTC;
}"
13949,"/** 
 * Gets an instance of the CopticChronology in the given time zone.
 * @param zone  the time zone to get the chronology in, null is default
 * @param leapYears  the type defining the leap year pattern
 * @return a chronology in the specified time zone
 */
public static IslamicChronology getInstance(DateTimeZone zone,LeapYearPatternType leapYears){
  if (zone == null) {
    zone=DateTimeZone.getDefault();
  }
  IslamicChronology chrono;
synchronized (cCache) {
    IslamicChronology[] chronos=(IslamicChronology[])cCache.get(zone);
    if (chronos == null) {
      chronos=new IslamicChronology[4];
      cCache.put(zone,chronos);
    }
    chrono=chronos[leapYears.index];
    if (chrono == null) {
      if (zone == DateTimeZone.UTC) {
        chrono=new IslamicChronology(null,null,leapYears);
        DateTime lowerLimit=new DateTime(1,1,1,0,0,0,0,chrono);
        chrono=new IslamicChronology(LimitChronology.getInstance(chrono,lowerLimit,null),null,leapYears);
      }
 else {
        chrono=getInstance(DateTimeZone.UTC,leapYears);
        chrono=new IslamicChronology(ZonedChronology.getInstance(chrono,zone),null,leapYears);
      }
      chronos[leapYears.index]=chrono;
    }
  }
  return chrono;
}","/** 
 * Gets an instance of the IslamicChronology in the given time zone.
 * @param zone  the time zone to get the chronology in, null is default
 * @param leapYears  the type defining the leap year pattern
 * @return a chronology in the specified time zone
 */
public static IslamicChronology getInstance(DateTimeZone zone,LeapYearPatternType leapYears){
  if (zone == null) {
    zone=DateTimeZone.getDefault();
  }
  IslamicChronology chrono;
synchronized (cCache) {
    IslamicChronology[] chronos=(IslamicChronology[])cCache.get(zone);
    if (chronos == null) {
      chronos=new IslamicChronology[4];
      cCache.put(zone,chronos);
    }
    chrono=chronos[leapYears.index];
    if (chrono == null) {
      if (zone == DateTimeZone.UTC) {
        chrono=new IslamicChronology(null,null,leapYears);
        DateTime lowerLimit=new DateTime(1,1,1,0,0,0,0,chrono);
        chrono=new IslamicChronology(LimitChronology.getInstance(chrono,lowerLimit,null),null,leapYears);
      }
 else {
        chrono=getInstance(DateTimeZone.UTC,leapYears);
        chrono=new IslamicChronology(ZonedChronology.getInstance(chrono,zone),null,leapYears);
      }
      chronos[leapYears.index]=chrono;
    }
  }
  return chrono;
}"
13950,"public void testForStyle_shortTime() throws Exception {
  DateTimeFormatter f=DateTimeFormat.shortTime();
  DateTimeFormatter g=DateTimeFormat.forStyle(""String_Node_Str"");
  assertSame(g,f);
  DateTime dt=new DateTime(2004,6,9,10,20,30,0);
  String expect=DateFormat.getTimeInstance(DateFormat.SHORT,UK).format(dt.toDate());
  assertEquals(expect,f.print(dt));
  expect=DateFormat.getTimeInstance(DateFormat.SHORT,US).format(dt.toDate());
  assertEquals(expect,f.withLocale(US).print(dt));
  expect=DateFormat.getTimeInstance(DateFormat.SHORT,FRANCE).format(dt.toDate());
  assertEquals(expect,f.withLocale(FRANCE).print(dt));
  DateTime date=new DateTime(DateFormat.getTimeInstance(DateFormat.SHORT,FRANCE).parse(expect));
  assertEquals(date,f.withLocale(FRANCE).parseDateTime(expect));
}","public void testForStyle_shortTime() throws Exception {
  DateTimeFormatter f=DateTimeFormat.shortTime();
  DateTimeFormatter g=DateTimeFormat.forStyle(""String_Node_Str"");
  assertSame(g,f);
  DateTime dt=new DateTime(2004,6,9,10,20,30,0);
  String expect=DateFormat.getTimeInstance(DateFormat.SHORT,UK).format(dt.toDate());
  assertEquals(expect,f.print(dt));
  expect=DateFormat.getTimeInstance(DateFormat.SHORT,US).format(dt.toDate());
  assertEquals(expect,f.withLocale(US).print(dt));
  expect=DateFormat.getTimeInstance(DateFormat.SHORT,FRANCE).format(dt.toDate());
  assertEquals(expect,f.withLocale(FRANCE).print(dt));
  if (TimeZone.getDefault() instanceof SimpleTimeZone) {
  }
 else {
    DateTime date=new DateTime(DateFormat.getTimeInstance(DateFormat.SHORT,FRANCE).parse(expect));
    assertEquals(date,f.withLocale(FRANCE).parseDateTime(expect));
  }
}"
13951,"protected void assemble(Fields fields){
  if (getParam() == null) {
    DateTimeField field=fields.year;
    fields.year=new OffsetDateTimeField(field,BUDDHIST_OFFSET);
    field=fields.yearOfEra;
    fields.yearOfEra=new OffsetDateTimeField(fields.year,DateTimeFieldType.yearOfEra(),BUDDHIST_OFFSET);
    field=fields.weekyear;
    fields.weekyear=new OffsetDateTimeField(field,BUDDHIST_OFFSET);
    field=new OffsetDateTimeField(fields.yearOfEra,99);
    fields.centuryOfEra=new DividedDateTimeField(field,DateTimeFieldType.centuryOfEra(),100);
    field=new RemainderDateTimeField((DividedDateTimeField)fields.centuryOfEra);
    fields.yearOfCentury=new OffsetDateTimeField(field,DateTimeFieldType.yearOfCentury(),1);
    field=new RemainderDateTimeField(fields.weekyear,DateTimeFieldType.weekyearOfCentury(),100);
    fields.weekyearOfCentury=new OffsetDateTimeField(field,DateTimeFieldType.weekyearOfCentury(),1);
    fields.era=ThaiBuddhistEraDateTimeField.INSTANCE;
  }
}","protected void assemble(Fields fields){
  if (getParam() == null) {
    DateTimeField field=fields.year;
    fields.year=new OffsetDateTimeField(new SkipUndoDateTimeField(this,field),BUDDHIST_OFFSET);
    field=fields.yearOfEra;
    fields.yearOfEra=new DelegatedDateTimeField(fields.year,DateTimeFieldType.yearOfEra());
    field=fields.weekyear;
    fields.weekyear=new OffsetDateTimeField(new SkipUndoDateTimeField(this,field),BUDDHIST_OFFSET);
    field=new OffsetDateTimeField(fields.yearOfEra,99);
    fields.centuryOfEra=new DividedDateTimeField(field,DateTimeFieldType.centuryOfEra(),100);
    field=new RemainderDateTimeField((DividedDateTimeField)fields.centuryOfEra);
    fields.yearOfCentury=new OffsetDateTimeField(field,DateTimeFieldType.yearOfCentury(),1);
    field=new RemainderDateTimeField(fields.weekyear,DateTimeFieldType.weekyearOfCentury(),100);
    fields.weekyearOfCentury=new OffsetDateTimeField(field,DateTimeFieldType.weekyearOfCentury(),1);
    fields.era=ThaiBuddhistEraDateTimeField.INSTANCE;
  }
}"
13952,"/** 
 * Constructor.
 * @param field  the field being decorated
 * @param type  the field type override
 */
protected DelegatedDateTimeField(DateTimeField field,DateTimeFieldType type){
  super();
  if (field == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  iField=field;
  iType=(type == null ? field.getType() : type);
}","/** 
 * Constructor.
 * @param field  the field being decorated
 * @param type  the field type override
 */
public DelegatedDateTimeField(DateTimeField field,DateTimeFieldType type){
  super();
  if (field == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  iField=field;
  iType=(type == null ? field.getType() : type);
}"
13953,"/** 
 * Gets a copy of this date with the value of the specified field increased. <p> If the addition is zero, then <code>this</code> is returned. <p> These three lines are equivalent: <pre> YearMonthDay added = ymd.withField(DateTimeFieldType.dayOfMonth(), 6); YearMonthDay added = ymd.dayOfMonth().addToCopy(6); YearMonthDay added = ymd.property(DateTimeFieldType.dayOfMonth()).addToCopy(6); </pre>
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */
public YearMonthDay withFieldAdded(DurationFieldType fieldType,int amount){
  if (amount == 0) {
    return this;
  }
  int index=indexOfSupported(fieldType);
  int[] newValues=getValues();
  newValues=getField(index).add(this,index,newValues,amount);
  return new YearMonthDay(this,newValues);
}","/** 
 * Gets a copy of this date with the value of the specified field increased. <p> If the addition is zero, then <code>this</code> is returned. <p> These three lines are equivalent: <pre> YearMonthDay added = ymd.withFieldAdded(DateTimeFieldType.dayOfMonth(), 6); YearMonthDay added = ymd.dayOfMonth().addToCopy(6); YearMonthDay added = ymd.property(DateTimeFieldType.dayOfMonth()).addToCopy(6); </pre>
 * @param fieldType  the field type to add to, not null
 * @param amount  the amount to add
 * @return a copy of this instance with the field updated
 * @throws IllegalArgumentException if the value is null or invalid
 * @throws ArithmeticException if the new datetime exceeds the capacity
 */
public YearMonthDay withFieldAdded(DurationFieldType fieldType,int amount){
  int index=indexOfSupported(fieldType);
  if (amount == 0) {
    return this;
  }
  int[] newValues=getValues();
  newValues=getField(index).add(this,index,newValues,amount);
  return new YearMonthDay(this,newValues);
}"
13954,"/** 
 * Gets a copy of this date with the specified field set to a new value. <p> For example, if the field type is <code>dayOfMonth</code> then the day would be changed in the returned instance. <p> These three lines are equivalent: <pre> YearMonthDay updated = ymd.withField(DateTimeFieldType.dayOfMonth(), 6); YearMonthDay updated = ymd.dayOfMonth().setCopy(6); YearMonthDay updated = ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6); </pre>
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public YearMonthDay withField(DateTimeFieldType fieldType,int value){
  if (value == 0) {
    return this;
  }
  int index=indexOfSupported(fieldType);
  int[] newValues=getValues();
  newValues=getField(index).set(this,index,newValues,value);
  return new YearMonthDay(this,newValues);
}","/** 
 * Gets a copy of this date with the specified field set to a new value. <p> For example, if the field type is <code>dayOfMonth</code> then the day would be changed in the returned instance. <p> These three lines are equivalent: <pre> YearMonthDay updated = ymd.withField(DateTimeFieldType.dayOfMonth(), 6); YearMonthDay updated = ymd.dayOfMonth().setCopy(6); YearMonthDay updated = ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6); </pre>
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public YearMonthDay withField(DateTimeFieldType fieldType,int value){
  int index=indexOfSupported(fieldType);
  if (value == 0) {
    return this;
  }
  int[] newValues=getValues();
  newValues=getField(index).set(this,index,newValues,value);
  return new YearMonthDay(this,newValues);
}"
13955,"/** 
 * Gets a copy of this date with the specified field set to a new value. <p> For example, if the field type is <code>dayOfMonth</code> then the day would be changed in the returned instance. <p> These three lines are equivalent: <pre> YearMonthDay updated = ymd.withField(DateTimeFieldType.dayOfMonth(), 6); YearMonthDay updated = ymd.dayOfMonth().setCopy(6); YearMonthDay updated = ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6); </pre>
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public YearMonthDay withField(DateTimeFieldType fieldType,int value){
  int index=indexOfSupported(fieldType);
  if (value == 0) {
    return this;
  }
  int[] newValues=getValues();
  newValues=getField(index).set(this,index,newValues,value);
  return new YearMonthDay(this,newValues);
}","/** 
 * Gets a copy of this date with the specified field set to a new value. <p> For example, if the field type is <code>dayOfMonth</code> then the day would be changed in the returned instance. <p> These three lines are equivalent: <pre> YearMonthDay updated = ymd.withField(DateTimeFieldType.dayOfMonth(), 6); YearMonthDay updated = ymd.dayOfMonth().setCopy(6); YearMonthDay updated = ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6); </pre>
 * @param fieldType  the field type to set, not null
 * @param value  the value to set
 * @return a copy of this instance with the field set
 * @throws IllegalArgumentException if the value is null or invalid
 */
public YearMonthDay withField(DateTimeFieldType fieldType,int value){
  int index=indexOfSupported(fieldType);
  if (value == getValue(index)) {
    return this;
  }
  int[] newValues=getValues();
  newValues=getField(index).set(this,index,newValues,value);
  return new YearMonthDay(this,newValues);
}"
13956,"/** 
 * Gets the long name of this datetime zone suitable for display using the specified locale. <p> If the name is not available for the locale, then this method returns a string in the format <code>[+-]hh:mm</code>.
 * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for
 * @param locale  the locale to get the name for
 * @return the human-readable long name in the specified locale
 */
public String getName(long instant,Locale locale){
  if (locale == null) {
    locale=Locale.getDefault();
  }
  String nameKey=getNameKey(instant);
  if (nameKey == null) {
    return iID;
  }
  String name=cNameProvider.getName(locale,iID,nameKey);
  if (name != null) {
    return name;
  }
  return printTimeZone(getOffset(instant));
}","/** 
 * Gets the long name of this datetime zone suitable for display using the specified locale. <p> If the name is not available for the locale, then this method returns a string in the format <code>[+-]hh:mm</code>.
 * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for
 * @param locale  the locale to get the name for
 * @return the human-readable long name in the specified locale
 */
public String getName(long instant,Locale locale){
  if (locale == null) {
    locale=Locale.getDefault();
  }
  String nameKey=getNameKey(instant);
  if (nameKey == null) {
    return iID;
  }
  String name=cNameProvider.getName(locale,iID,nameKey);
  if (name != null) {
    return name;
  }
  return printOffset(getOffset(instant));
}"
13957,"/** 
 * Gets the short name of this datetime zone suitable for display using the specified locale. <p> If the name is not available for the locale, then this method returns a string in the format <code>[+-]hh:mm</code>.
 * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for
 * @param locale  the locale to get the name for
 * @return the human-readable short name in the specified locale
 */
public String getShortName(long instant,Locale locale){
  if (locale == null) {
    locale=Locale.getDefault();
  }
  String nameKey=getNameKey(instant);
  if (nameKey == null) {
    return iID;
  }
  String name=cNameProvider.getShortName(locale,iID,nameKey);
  if (name != null) {
    return name;
  }
  return printTimeZone(getOffset(instant));
}","/** 
 * Gets the short name of this datetime zone suitable for display using the specified locale. <p> If the name is not available for the locale, then this method returns a string in the format <code>[+-]hh:mm</code>.
 * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for
 * @param locale  the locale to get the name for
 * @return the human-readable short name in the specified locale
 */
public String getShortName(long instant,Locale locale){
  if (locale == null) {
    locale=Locale.getDefault();
  }
  String nameKey=getNameKey(instant);
  if (nameKey == null) {
    return iID;
  }
  String name=cNameProvider.getShortName(locale,iID,nameKey);
  if (name != null) {
    return name;
  }
  return printOffset(getOffset(instant));
}"
13958,"/** 
 * Get the time zone by Java TimeZone. <p> DateTimeZone only accepts a subset of the IDs from TimeZone. The excluded IDs are the short three letter form (except UTC). This  method will attempt to convert between time zones created using the short IDs and the full version.
 * @param zone  the zone to convert, null means default
 * @return the DateTimeZone object for the zone
 * @throws IllegalArgumentException if the zone is not recognised
 */
public static DateTimeZone getInstance(java.util.TimeZone zone){
  if (zone == null) {
    return getDefault();
  }
  final String id=zone.getID();
  if (id.equals(""String_Node_Str"")) {
    return DateTimeZone.UTC;
  }
  DateTimeZone dtz=null;
  String convId=getConvertedId(id);
  if (convId != null) {
    dtz=cProvider.getZone(convId);
  }
  if (dtz == null) {
    dtz=cProvider.getZone(id);
  }
  if (dtz != null) {
    return dtz;
  }
  if (convId == null) {
    convId=zone.getDisplayName();
    if (convId.startsWith(""String_Node_Str"") || convId.startsWith(""String_Node_Str"")) {
      convId=convId.substring(3);
      int offset=-(int)offsetFormatter().parseMillis(convId,ISOChronology.getInstance(UTC));
      if (offset == 0L) {
        return DateTimeZone.UTC;
      }
 else {
        convId=printTimeZone(offset);
        return fixedOffsetZone(convId,offset);
      }
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"" + id);
}","/** 
 * Get the time zone by Java TimeZone. <p> DateTimeZone only accepts a subset of the IDs from TimeZone. The excluded IDs are the short three letter form (except UTC). This  method will attempt to convert between time zones created using the short IDs and the full version.
 * @param zone  the zone to convert, null means default
 * @return the DateTimeZone object for the zone
 * @throws IllegalArgumentException if the zone is not recognised
 */
public static DateTimeZone getInstance(java.util.TimeZone zone){
  if (zone == null) {
    return getDefault();
  }
  final String id=zone.getID();
  if (id.equals(""String_Node_Str"")) {
    return DateTimeZone.UTC;
  }
  DateTimeZone dtz=null;
  String convId=getConvertedId(id);
  if (convId != null) {
    dtz=cProvider.getZone(convId);
  }
  if (dtz == null) {
    dtz=cProvider.getZone(id);
  }
  if (dtz != null) {
    return dtz;
  }
  if (convId == null) {
    convId=zone.getDisplayName();
    if (convId.startsWith(""String_Node_Str"") || convId.startsWith(""String_Node_Str"")) {
      convId=convId.substring(3);
      int offset=parseOffset(convId);
      if (offset == 0L) {
        return DateTimeZone.UTC;
      }
 else {
        convId=printOffset(offset);
        return fixedOffsetZone(convId,offset);
      }
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"" + id);
}"
13959,"private PeriodFormat(){
  iDefault=new PeriodFormatterBuilder().appendYears().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"").appendMonths().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"").appendWeeks().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"").appendDays().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"").appendHours().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"").appendMinutes().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"").appendSeconds().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"").appendMillis().appendSuffix(""String_Node_Str"",""String_Node_Str"").toFormatter();
}","private PeriodFormat(){
  String[] variants={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  iDefault=new PeriodFormatterBuilder().appendYears().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"",variants).appendMonths().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"",variants).appendWeeks().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"",variants).appendDays().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"",variants).appendHours().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"",variants).appendMinutes().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"",variants).appendSeconds().appendSuffix(""String_Node_Str"",""String_Node_Str"").appendSeparator(""String_Node_Str"",""String_Node_Str"",variants).appendMillis().appendSuffix(""String_Node_Str"",""String_Node_Str"").toFormatter();
}"
13960,"private PeriodFormatterBuilder appendSeparator(String text,String finalText,boolean useBefore,boolean useAfter){
  if (text == null || finalText == null) {
    throw new IllegalArgumentException();
  }
  clearPrefix();
  List formatters=iFormatters;
  if (formatters.size() == 0) {
    if (useAfter && useBefore == false) {
      formatters.add(new Separator(text,finalText,Literal.EMPTY,useBefore,useAfter));
    }
    return this;
  }
  int i;
  Separator lastSeparator=null;
  for (i=formatters.size(); --i >= 0; ) {
    if (formatters.get(i) instanceof Separator) {
      lastSeparator=(Separator)formatters.get(i);
      formatters=formatters.subList(i + 1,formatters.size());
      break;
    }
  }
  if (lastSeparator != null && formatters.size() == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else {
    BasePeriodFormatter composite=createComposite(formatters);
    formatters.clear();
    formatters.add(new Separator(text,finalText,composite,useBefore,useAfter));
  }
  return this;
}","private PeriodFormatterBuilder appendSeparator(String text,String finalText,String[] variants,boolean useBefore,boolean useAfter){
  if (text == null || finalText == null) {
    throw new IllegalArgumentException();
  }
  clearPrefix();
  List formatters=iFormatters;
  if (formatters.size() == 0) {
    if (useAfter && useBefore == false) {
      formatters.add(new Separator(text,finalText,variants,Literal.EMPTY,useBefore,useAfter));
    }
    return this;
  }
  int i;
  Separator lastSeparator=null;
  for (i=formatters.size(); --i >= 0; ) {
    if (formatters.get(i) instanceof Separator) {
      lastSeparator=(Separator)formatters.get(i);
      formatters=formatters.subList(i + 1,formatters.size());
      break;
    }
  }
  if (lastSeparator != null && formatters.size() == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else {
    BasePeriodFormatter composite=createComposite(formatters);
    formatters.clear();
    formatters.add(new Separator(text,finalText,variants,composite,useBefore,useAfter));
  }
  return this;
}"
13961,"/** 
 * Append a separator, which is output only if fields are printed before the separator. <p> For example, <code>builder.appendDays().appendSeparator("","").appendHours()</code> will only output the comma if the days fields is output. <p> The text will be parsed case-insensitively. <p> Note: appending a separator discontinues any further work on the latest appended field.
 * @param text  the text to use as a separator
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */
public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text){
  return appendSeparator(text,text,true,false);
}","/** 
 * Append a separator, which is output only if fields are printed before the separator. <p> For example, <code>builder.appendDays().appendSeparatorIfFieldsBefore("","").appendHours()</code> will only output the comma if the days fields is output. <p> The text will be parsed case-insensitively. <p> Note: appending a separator discontinues any further work on the latest appended field.
 * @param text  the text to use as a separator
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */
public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text){
  return appendSeparator(text,text,null,true,false);
}"
13962,"/** 
 * Append a separator, which is output only if fields are printed after the separator. <p> For example, <code>builder.appendDays().appendSeparator("","").appendHours()</code> will only output the comma if the hours fields is output. <p> The text will be parsed case-insensitively. <p> Note: appending a separator discontinues any further work on the latest appended field.
 * @param text  the text to use as a separator
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */
public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text){
  return appendSeparator(text,text,false,true);
}","/** 
 * Append a separator, which is output only if fields are printed after the separator. <p> For example, <code>builder.appendDays().appendSeparatorIfFieldsAfter("","").appendHours()</code> will only output the comma if the hours fields is output. <p> The text will be parsed case-insensitively. <p> Note: appending a separator discontinues any further work on the latest appended field.
 * @param text  the text to use as a separator
 * @return this PeriodFormatterBuilder
 * @throws IllegalStateException if this separator follows a previous one
 */
public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text){
  return appendSeparator(text,text,null,false,true);
}"
13963,"Separator(String text,String finalText,BasePeriodFormatter before,boolean useBefore,boolean useAfter){
  iText=text;
  iFinalText=finalText;
  iBefore=before;
  iUseBefore=useBefore;
  iUseAfter=useAfter;
}","Separator(String text,String finalText,String[] variants,BasePeriodFormatter before,boolean useBefore,boolean useAfter){
  iText=text;
  iFinalText=finalText;
  if ((finalText == null || text.equals(finalText)) && (variants == null || variants.length == 0)) {
    iParsedForms=new String[]{text};
  }
 else {
    TreeSet parsedSet=new TreeSet(String.CASE_INSENSITIVE_ORDER);
    parsedSet.add(text);
    parsedSet.add(finalText);
    if (variants != null) {
      for (int i=variants.length; --i >= 0; ) {
        parsedSet.add(variants[i]);
      }
    }
    ArrayList parsedList=new ArrayList(parsedSet);
    Collections.reverse(parsedList);
    iParsedForms=(String[])parsedList.toArray(new String[parsedList.size()]);
  }
  iBefore=before;
  iUseBefore=useBefore;
  iUseAfter=useAfter;
}"
13964,"public DateTimeField getField(Chronology chrono){
  DateTimeField wrappedField=iWrappedType.getField(chrono);
  RemainderDateTimeField field=iRecent;
  if (field.getWrappedField() == wrappedField) {
    return field;
  }
  field=new RemainderDateTimeField(wrappedField,iType,iDivisor);
  iRecent=field;
  return field;
}","public DateTimeField getField(Chronology chrono){
  DateTimeField wrappedField=iWrappedType.getField(chrono);
  RemainderDateTimeField field=iRecent;
  if (field != null && field.getWrappedField() == wrappedField) {
    return field;
  }
  field=new RemainderDateTimeField(wrappedField,iType,iDivisor);
  iRecent=field;
  return field;
}"
13965,"/** 
 * This method assumes that this field is properly rounded on 1970-01-01T00:00:00. If the rounding alignment differs, override this method as follows: <pre> return super.roundCeiling(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS; </pre>
 */
public long roundCeiling(long instant){
  if (instant >= 0) {
    instant-=1;
    return instant - instant % iUnitMillis + iUnitMillis;
  }
 else {
    return instant - instant % iUnitMillis;
  }
}","/** 
 * This method assumes that this field is properly rounded on 1970-01-01T00:00:00. If the rounding alignment differs, override this method as follows: <pre> return super.roundCeiling(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS; </pre>
 */
public long roundCeiling(long instant){
  if (instant > 0) {
    instant-=1;
    return instant - instant % iUnitMillis + iUnitMillis;
  }
 else {
    return instant - instant % iUnitMillis;
  }
}"
13966,"long set(long millis){
  if (iText == null) {
    return iField.set(millis,iValue);
  }
 else {
    return iField.set(millis,iText,iLocale);
  }
}","long set(long millis,boolean reset){
  if (iText == null) {
    millis=iField.set(millis,iValue);
  }
 else {
    millis=iField.set(millis,iText,iLocale);
  }
  if (reset) {
    millis=iField.roundFloor(millis);
  }
  return millis;
}"
13967,"/** 
 * Computes the parsed datetime by setting the saved fields. This method is idempotent, but it is not thread-safe.
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 */
public long computeMillis(){
  SavedField[] savedFields=iSavedFields;
  int count=iSavedFieldsCount;
  if (iSavedFieldsShared) {
    iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
    iSavedFieldsShared=false;
  }
  sort(savedFields,count);
  long millis=iMillis;
  for (int i=0; i < count; i++) {
    millis=savedFields[i].set(millis);
  }
  if (iZone == null) {
    millis-=iOffset;
  }
 else {
    int offset=iZone.getOffsetFromLocal(millis);
    millis-=offset;
    if (offset != iZone.getOffset(millis)) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  return millis;
}","/** 
 * Computes the parsed datetime by setting the saved fields. This method is idempotent, but it is not thread-safe.
 * @param resetFields false by default, but when true, unsaved field values are cleared
 * @return milliseconds since 1970-01-01T00:00:00Z
 * @throws IllegalArgumentException if any field is out of range
 */
public long computeMillis(boolean resetFields){
  SavedField[] savedFields=iSavedFields;
  int count=iSavedFieldsCount;
  if (iSavedFieldsShared) {
    iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
    iSavedFieldsShared=false;
  }
  sort(savedFields,count);
  long millis=iMillis;
  for (int i=0; i < count; i++) {
    millis=savedFields[i].set(millis,resetFields);
  }
  if (iZone == null) {
    millis-=iOffset;
  }
 else {
    int offset=iZone.getOffsetFromLocal(millis);
    millis-=offset;
    if (offset != iZone.getOffset(millis)) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  return millis;
}"
13968,"/** 
 * Adds this period to the given instant using the chronology of the specified instant (if present), returning a new Instant. <p> To add just once, pass in a scalar of one. To subtract once, pass in a scalar of minus one.
 * @param instant  the instant to add the period to, null means now
 * @param scalar  the number of times to add the period, negative to subtract
 * @return instant with the original value plus this period times scalar
 * @throws ArithmeticException if the result of the calculation is too large
 */
public final Instant addTo(ReadableInstant instant,int scalar){
  long instantMillis=DateTimeUtils.getInstantMillis(instant);
  return new Instant(addTo(instantMillis,scalar,instant.getChronology()));
}","/** 
 * Adds this period to the given instant using the chronology of the specified instant (if present), returning a new Instant. <p> To add just once, pass in a scalar of one. To subtract once, pass in a scalar of minus one.
 * @param instant  the instant to add the period to, null means now
 * @param scalar  the number of times to add the period, negative to subtract
 * @return instant with the original value plus this period times scalar
 * @throws ArithmeticException if the result of the calculation is too large
 */
public final Instant addTo(ReadableInstant instant,int scalar){
  long instantMillis=DateTimeUtils.getInstantMillis(instant);
  Chronology chrono=DateTimeUtils.getInstantChronology(instant,null);
  return new Instant(addTo(instantMillis,scalar,chrono));
}"
13969,"/** 
 * Sets the duration of this time interval, preserving the end instant.
 * @param duration  new duration for interval, null means zero length
 * @throws IllegalArgumentException if the end is before the start
 * @throws ArithmeticException if the start instant exceeds the capacity of a long
 */
public void setDurationBeforeEnd(ReadableDuration duration){
  long durationMillis=DateTimeUtils.getDurationMillis(duration);
  setStartMillis(FieldUtils.safeAdd(getStartMillis(),-durationMillis));
}","/** 
 * Sets the duration of this time interval, preserving the end instant.
 * @param duration  new duration for interval, null means zero length
 * @throws IllegalArgumentException if the end is before the start
 * @throws ArithmeticException if the start instant exceeds the capacity of a long
 */
public void setDurationBeforeEnd(ReadableDuration duration){
  long durationMillis=DateTimeUtils.getDurationMillis(duration);
  setStartMillis(FieldUtils.safeAdd(getEndMillis(),-durationMillis));
}"
13970,"public void testAddIntoRWI3(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,1);
  expected=ISOChronology.getInstance().months().add(expected,2);
  expected=ISOChronology.getInstance().weeks().add(expected,3);
  expected=ISOChronology.getInstance().days().add(expected,4);
  expected=ISOChronology.getInstance().hours().add(expected,5);
  expected=ISOChronology.getInstance().minutes().add(expected,6);
  expected=ISOChronology.getInstance().seconds().add(expected,7);
  expected=ISOChronology.getInstance().millis().add(expected,8);
  Duration test=new Duration(1,2,3,4,5,6,7,8);
  try {
    test.addInto(null,1);
    fail();
  }
 catch (  IllegalArgumentException ex) {
  }
}","public void testAddIntoRWI3(){
  Duration test=new Duration(1,2,3,4,5,6,7,8);
  try {
    test.addInto(null,1);
    fail();
  }
 catch (  IllegalArgumentException ex) {
  }
}"
13971,"public void testAddTo2(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,-2);
  expected=ISOChronology.getInstance().months().add(expected,-4);
  expected=ISOChronology.getInstance().weeks().add(expected,-6);
  expected=ISOChronology.getInstance().days().add(expected,-8);
  expected=ISOChronology.getInstance().hours().add(expected,-10);
  expected=ISOChronology.getInstance().minutes().add(expected,-12);
  expected=ISOChronology.getInstance().seconds().add(expected,-14);
  expected=ISOChronology.getInstance().millis().add(expected,-16);
  Duration test=new Duration(1,2,3,4,5,6,7,8);
  long added=test.addTo(TEST_TIME_NOW,-2);
  assertEquals(expected,added);
}","public void testAddTo2(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstanceUTC().years().add(expected,-2);
  expected=ISOChronology.getInstanceUTC().months().add(expected,-4);
  expected=ISOChronology.getInstanceUTC().weeks().add(expected,-6);
  expected=ISOChronology.getInstanceUTC().days().add(expected,-8);
  expected=ISOChronology.getInstanceUTC().hours().add(expected,-10);
  expected=ISOChronology.getInstanceUTC().minutes().add(expected,-12);
  expected=ISOChronology.getInstanceUTC().seconds().add(expected,-14);
  expected=ISOChronology.getInstanceUTC().millis().add(expected,-16);
  Duration test=new Duration(1,2,3,4,5,6,7,8);
  long added=test.addTo(TEST_TIME_NOW,-2);
  assertEquals(expected,added);
}"
13972,"public void testAddTo1(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,1);
  expected=ISOChronology.getInstance().months().add(expected,2);
  expected=ISOChronology.getInstance().weeks().add(expected,3);
  expected=ISOChronology.getInstance().days().add(expected,4);
  expected=ISOChronology.getInstance().hours().add(expected,5);
  expected=ISOChronology.getInstance().minutes().add(expected,6);
  expected=ISOChronology.getInstance().seconds().add(expected,7);
  expected=ISOChronology.getInstance().millis().add(expected,8);
  Duration test=new Duration(1,2,3,4,5,6,7,8);
  long added=test.addTo(TEST_TIME_NOW,1);
  assertEquals(expected,added);
}","public void testAddTo1(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstanceUTC().years().add(expected,1);
  expected=ISOChronology.getInstanceUTC().months().add(expected,2);
  expected=ISOChronology.getInstanceUTC().weeks().add(expected,3);
  expected=ISOChronology.getInstanceUTC().days().add(expected,4);
  expected=ISOChronology.getInstanceUTC().hours().add(expected,5);
  expected=ISOChronology.getInstanceUTC().minutes().add(expected,6);
  expected=ISOChronology.getInstanceUTC().seconds().add(expected,7);
  expected=ISOChronology.getInstanceUTC().millis().add(expected,8);
  Duration test=new Duration(1,2,3,4,5,6,7,8);
  long added=test.addTo(TEST_TIME_NOW,1);
  assertEquals(expected,added);
}"
13973,"public void testAddToRI2(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,-2);
  expected=ISOChronology.getInstance().months().add(expected,-4);
  expected=ISOChronology.getInstance().weeks().add(expected,-6);
  expected=ISOChronology.getInstance().days().add(expected,-8);
  expected=ISOChronology.getInstance().hours().add(expected,-10);
  expected=ISOChronology.getInstance().minutes().add(expected,-12);
  expected=ISOChronology.getInstance().seconds().add(expected,-14);
  expected=ISOChronology.getInstance().millis().add(expected,-16);
  Duration test=new Duration(1,2,3,4,5,6,7,8);
  Instant added=test.addTo(new Instant(),-2);
  assertEquals(expected,added.getMillis());
}","public void testAddToRI2(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstanceUTC().years().add(expected,-2);
  expected=ISOChronology.getInstanceUTC().months().add(expected,-4);
  expected=ISOChronology.getInstanceUTC().weeks().add(expected,-6);
  expected=ISOChronology.getInstanceUTC().days().add(expected,-8);
  expected=ISOChronology.getInstanceUTC().hours().add(expected,-10);
  expected=ISOChronology.getInstanceUTC().minutes().add(expected,-12);
  expected=ISOChronology.getInstanceUTC().seconds().add(expected,-14);
  expected=ISOChronology.getInstanceUTC().millis().add(expected,-16);
  Duration test=new Duration(1,2,3,4,5,6,7,8);
  Instant added=test.addTo(new Instant(),-2);
  assertEquals(expected,added.getMillis());
}"
13974,"public void testAddToRI1(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,1);
  expected=ISOChronology.getInstance().months().add(expected,2);
  expected=ISOChronology.getInstance().weeks().add(expected,3);
  expected=ISOChronology.getInstance().days().add(expected,4);
  expected=ISOChronology.getInstance().hours().add(expected,5);
  expected=ISOChronology.getInstance().minutes().add(expected,6);
  expected=ISOChronology.getInstance().seconds().add(expected,7);
  expected=ISOChronology.getInstance().millis().add(expected,8);
  Duration test=new Duration(1,2,3,4,5,6,7,8);
  Instant added=test.addTo(new Instant(),1);
  assertEquals(expected,added.getMillis());
}","public void testAddToRI1(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstanceUTC().years().add(expected,1);
  expected=ISOChronology.getInstanceUTC().months().add(expected,2);
  expected=ISOChronology.getInstanceUTC().weeks().add(expected,3);
  expected=ISOChronology.getInstanceUTC().days().add(expected,4);
  expected=ISOChronology.getInstanceUTC().hours().add(expected,5);
  expected=ISOChronology.getInstanceUTC().minutes().add(expected,6);
  expected=ISOChronology.getInstanceUTC().seconds().add(expected,7);
  expected=ISOChronology.getInstanceUTC().millis().add(expected,8);
  Duration test=new Duration(1,2,3,4,5,6,7,8);
  Instant added=test.addTo(new Instant(),1);
  assertEquals(expected,added.getMillis());
}"
13975,"public void testAddToRI3(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,1);
  expected=ISOChronology.getInstance().months().add(expected,2);
  expected=ISOChronology.getInstance().weeks().add(expected,3);
  expected=ISOChronology.getInstance().days().add(expected,4);
  expected=ISOChronology.getInstance().hours().add(expected,5);
  expected=ISOChronology.getInstance().minutes().add(expected,6);
  expected=ISOChronology.getInstance().seconds().add(expected,7);
  expected=ISOChronology.getInstance().millis().add(expected,8);
  Duration test=new Duration(1,2,3,4,5,6,7,8);
  Instant added=test.addTo(null,1);
  assertEquals(expected,added.getMillis());
}","public void testAddToRI3(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,-2);
  expected=ISOChronology.getInstance().months().add(expected,-4);
  expected=ISOChronology.getInstance().weeks().add(expected,-6);
  expected=ISOChronology.getInstance().days().add(expected,-8);
  expected=ISOChronology.getInstance().hours().add(expected,-10);
  expected=ISOChronology.getInstance().minutes().add(expected,-12);
  expected=ISOChronology.getInstance().seconds().add(expected,-14);
  expected=ISOChronology.getInstance().millis().add(expected,-16);
  Duration test=new Duration(1,2,3,4,5,6,7,8);
  Instant added=test.addTo(new DateTime(),-2);
  assertEquals(expected,added.getMillis());
}"
13976,"public void testAddToRI2(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,-2);
  expected=ISOChronology.getInstance().months().add(expected,-4);
  expected=ISOChronology.getInstance().weeks().add(expected,-6);
  expected=ISOChronology.getInstance().days().add(expected,-8);
  expected=ISOChronology.getInstance().hours().add(expected,-10);
  expected=ISOChronology.getInstance().minutes().add(expected,-12);
  expected=ISOChronology.getInstance().seconds().add(expected,-14);
  expected=ISOChronology.getInstance().millis().add(expected,-16);
  MutableDuration test=new MutableDuration(1,2,3,4,5,6,7,8);
  Instant added=test.addTo(new Instant(),-2);
  assertEquals(expected,added.getMillis());
}","public void testAddToRI2(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstanceUTC().years().add(expected,-2);
  expected=ISOChronology.getInstanceUTC().months().add(expected,-4);
  expected=ISOChronology.getInstanceUTC().weeks().add(expected,-6);
  expected=ISOChronology.getInstanceUTC().days().add(expected,-8);
  expected=ISOChronology.getInstanceUTC().hours().add(expected,-10);
  expected=ISOChronology.getInstanceUTC().minutes().add(expected,-12);
  expected=ISOChronology.getInstanceUTC().seconds().add(expected,-14);
  expected=ISOChronology.getInstanceUTC().millis().add(expected,-16);
  MutableDuration test=new MutableDuration(1,2,3,4,5,6,7,8);
  Instant added=test.addTo(new Instant(),-2);
  assertEquals(expected,added.getMillis());
}"
13977,"public void testAddToRI1(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,1);
  expected=ISOChronology.getInstance().months().add(expected,2);
  expected=ISOChronology.getInstance().weeks().add(expected,3);
  expected=ISOChronology.getInstance().days().add(expected,4);
  expected=ISOChronology.getInstance().hours().add(expected,5);
  expected=ISOChronology.getInstance().minutes().add(expected,6);
  expected=ISOChronology.getInstance().seconds().add(expected,7);
  expected=ISOChronology.getInstance().millis().add(expected,8);
  MutableDuration test=new MutableDuration(1,2,3,4,5,6,7,8);
  Instant added=test.addTo(new Instant(),1);
  assertEquals(expected,added.getMillis());
}","public void testAddToRI1(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstanceUTC().years().add(expected,1);
  expected=ISOChronology.getInstanceUTC().months().add(expected,2);
  expected=ISOChronology.getInstanceUTC().weeks().add(expected,3);
  expected=ISOChronology.getInstanceUTC().days().add(expected,4);
  expected=ISOChronology.getInstanceUTC().hours().add(expected,5);
  expected=ISOChronology.getInstanceUTC().minutes().add(expected,6);
  expected=ISOChronology.getInstanceUTC().seconds().add(expected,7);
  expected=ISOChronology.getInstanceUTC().millis().add(expected,8);
  MutableDuration test=new MutableDuration(1,2,3,4,5,6,7,8);
  Instant added=test.addTo(new Instant(),1);
  assertEquals(expected,added.getMillis());
}"
13978,"public void testAddToRI3(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,1);
  expected=ISOChronology.getInstance().months().add(expected,2);
  expected=ISOChronology.getInstance().weeks().add(expected,3);
  expected=ISOChronology.getInstance().days().add(expected,4);
  expected=ISOChronology.getInstance().hours().add(expected,5);
  expected=ISOChronology.getInstance().minutes().add(expected,6);
  expected=ISOChronology.getInstance().seconds().add(expected,7);
  expected=ISOChronology.getInstance().millis().add(expected,8);
  MutableDuration test=new MutableDuration(1,2,3,4,5,6,7,8);
  Instant added=test.addTo(null,1);
  assertEquals(expected,added.getMillis());
}","public void testAddToRI3(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,-2);
  expected=ISOChronology.getInstance().months().add(expected,-4);
  expected=ISOChronology.getInstance().weeks().add(expected,-6);
  expected=ISOChronology.getInstance().days().add(expected,-8);
  expected=ISOChronology.getInstance().hours().add(expected,-10);
  expected=ISOChronology.getInstance().minutes().add(expected,-12);
  expected=ISOChronology.getInstance().seconds().add(expected,-14);
  expected=ISOChronology.getInstance().millis().add(expected,-16);
  MutableDuration test=new MutableDuration(1,2,3,4,5,6,7,8);
  Instant added=test.addTo(new DateTime(),-2);
  assertEquals(expected,added.getMillis());
}"
13979,"public void testAddIntoRWI3(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,1);
  expected=ISOChronology.getInstance().months().add(expected,2);
  expected=ISOChronology.getInstance().weeks().add(expected,3);
  expected=ISOChronology.getInstance().days().add(expected,4);
  expected=ISOChronology.getInstance().hours().add(expected,5);
  expected=ISOChronology.getInstance().minutes().add(expected,6);
  expected=ISOChronology.getInstance().seconds().add(expected,7);
  expected=ISOChronology.getInstance().millis().add(expected,8);
  MutableDuration test=new MutableDuration(1,2,3,4,5,6,7,8);
  try {
    test.addInto(null,1);
    fail();
  }
 catch (  IllegalArgumentException ex) {
  }
}","public void testAddIntoRWI3(){
  MutableDuration test=new MutableDuration(1,2,3,4,5,6,7,8);
  try {
    test.addInto(null,1);
    fail();
  }
 catch (  IllegalArgumentException ex) {
  }
}"
13980,"public void testAddTo2(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,-2);
  expected=ISOChronology.getInstance().months().add(expected,-4);
  expected=ISOChronology.getInstance().weeks().add(expected,-6);
  expected=ISOChronology.getInstance().days().add(expected,-8);
  expected=ISOChronology.getInstance().hours().add(expected,-10);
  expected=ISOChronology.getInstance().minutes().add(expected,-12);
  expected=ISOChronology.getInstance().seconds().add(expected,-14);
  expected=ISOChronology.getInstance().millis().add(expected,-16);
  MutableDuration test=new MutableDuration(1,2,3,4,5,6,7,8);
  long added=test.addTo(TEST_TIME_NOW,-2);
  assertEquals(expected,added);
}","public void testAddTo2(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstanceUTC().years().add(expected,-2);
  expected=ISOChronology.getInstanceUTC().months().add(expected,-4);
  expected=ISOChronology.getInstanceUTC().weeks().add(expected,-6);
  expected=ISOChronology.getInstanceUTC().days().add(expected,-8);
  expected=ISOChronology.getInstanceUTC().hours().add(expected,-10);
  expected=ISOChronology.getInstanceUTC().minutes().add(expected,-12);
  expected=ISOChronology.getInstanceUTC().seconds().add(expected,-14);
  expected=ISOChronology.getInstanceUTC().millis().add(expected,-16);
  MutableDuration test=new MutableDuration(1,2,3,4,5,6,7,8);
  long added=test.addTo(TEST_TIME_NOW,-2);
  assertEquals(expected,added);
}"
13981,"public void testAddTo1(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstance().years().add(expected,1);
  expected=ISOChronology.getInstance().months().add(expected,2);
  expected=ISOChronology.getInstance().weeks().add(expected,3);
  expected=ISOChronology.getInstance().days().add(expected,4);
  expected=ISOChronology.getInstance().hours().add(expected,5);
  expected=ISOChronology.getInstance().minutes().add(expected,6);
  expected=ISOChronology.getInstance().seconds().add(expected,7);
  expected=ISOChronology.getInstance().millis().add(expected,8);
  MutableDuration test=new MutableDuration(1,2,3,4,5,6,7,8);
  long added=test.addTo(TEST_TIME_NOW,1);
  assertEquals(expected,added);
}","public void testAddTo1(){
  long expected=TEST_TIME_NOW;
  expected=ISOChronology.getInstanceUTC().years().add(expected,1);
  expected=ISOChronology.getInstanceUTC().months().add(expected,2);
  expected=ISOChronology.getInstanceUTC().weeks().add(expected,3);
  expected=ISOChronology.getInstanceUTC().days().add(expected,4);
  expected=ISOChronology.getInstanceUTC().hours().add(expected,5);
  expected=ISOChronology.getInstanceUTC().minutes().add(expected,6);
  expected=ISOChronology.getInstanceUTC().seconds().add(expected,7);
  expected=ISOChronology.getInstanceUTC().millis().add(expected,8);
  MutableDuration test=new MutableDuration(1,2,3,4,5,6,7,8);
  long added=test.addTo(TEST_TIME_NOW,1);
  assertEquals(expected,added);
}"
13982,"/** 
 * Adds this duration into the given mutable instant. <p> To add just once, pass in a scalar of one. To subtract once, pass in a scalar of minus one.
 * @param instant  the instant to update with the added duration, must not be null
 * @param scalar  the number of times to add the duration, negative to subtract
 * @throws IllegalArgumentException if the instant is null
 * @throws ArithmeticException if the result of the calculation is too large
 */
public final void addInto(ReadWritableInstant instant,int scalar){
  if (instant == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  instant.setMillis(addTo(instant.getMillis(),scalar));
}","/** 
 * Adds this duration into the given mutable instant using the chronology of the specified mutable instant (if present). <p> To add just once, pass in a scalar of one. To subtract once, pass in a scalar of minus one.
 * @param instant  the instant to update with the added duration, must not be null
 * @param scalar  the number of times to add the duration, negative to subtract
 * @throws IllegalArgumentException if the instant is null
 * @throws ArithmeticException if the result of the calculation is too large
 */
public final void addInto(ReadWritableInstant instant,int scalar){
  if (instant == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  instant.setMillis(addTo(instant.getMillis(),scalar,instant.getChronology()));
}"
13983,"/** 
 * Adds this duration to the given instant, returning a new Instant. <p> To add just once, pass in a scalar of one. To subtract once, pass in a scalar of minus one.
 * @param instant  the instant to add the duration to, null means now
 * @param scalar  the number of times to add the duration, negative to subtract
 * @return instant with the original value plus this duration times scalar
 * @throws ArithmeticException if the result of the calculation is too large
 */
public final Instant addTo(ReadableInstant instant,int scalar){
  if (instant == null) {
    return new Instant(addTo(DateTimeUtils.currentTimeMillis(),scalar));
  }
  return new Instant(addTo(instant.getMillis(),scalar));
}","/** 
 * Adds this duration to the given instant using the chronology of the specified instant (if present), returning a new Instant. <p> To add just once, pass in a scalar of one. To subtract once, pass in a scalar of minus one.
 * @param instant  the instant to add the duration to, null means now
 * @param scalar  the number of times to add the duration, negative to subtract
 * @return instant with the original value plus this duration times scalar
 * @throws ArithmeticException if the result of the calculation is too large
 */
public final Instant addTo(ReadableInstant instant,int scalar){
  if (instant == null) {
    return new Instant(addTo(DateTimeUtils.currentTimeMillis(),scalar));
  }
  return new Instant(addTo(instant.getMillis(),scalar,instant.getChronology()));
}"
13984,"private static synchronized DateTimeFormatter offsetFormatter(){
  if (cOffsetFormatter == null) {
    cOffsetFormatter=new DateTimeFormatterBuilder(UTC).appendTimeZoneOffset(null,true,2,4).toFormatter();
  }
  return cOffsetFormatter;
}","private static synchronized DateTimeFormatter offsetFormatter(){
  if (cOffsetFormatter == null) {
    cOffsetFormatter=new DateTimeFormatterBuilder((Chronology)null,null).appendTimeZoneOffset(null,true,2,4).toFormatter();
  }
  return cOffsetFormatter;
}"
13985,"/** 
 * Creates a DateTimeFormatterBuilder with any chronology and locale.
 * @param chrono Chronology to use, or null for default of ISO
 * @param locale Locale to use, or null for default
 */
public DateTimeFormatterBuilder(Chronology chrono,Locale locale){
  if (chrono == null) {
    chrono=ISOChronology.getInstance();
  }
  if (locale == null) {
    locale=Locale.getDefault();
  }
  iChrono=chrono;
  iChronoUTC=chrono.withUTC();
  DateTimeZone zone=chrono.getZone();
  iLocale=locale;
  iElementPairs=new ArrayList();
}","/** 
 * Creates a DateTimeFormatterBuilder with any chronology and locale.
 * @param chrono Chronology to use, or null for default of ISO
 * @param locale Locale to use, or null for default
 */
public DateTimeFormatterBuilder(Chronology chrono,Locale locale){
  if (chrono == null) {
    if (DateTimeZone.getDefault() == null) {
      iChrono=iChronoUTC=null;
    }
 else {
      iChrono=iChronoUTC=ISOChronology.getInstance();
    }
  }
 else {
    iChrono=chrono;
    iChronoUTC=chrono.withUTC();
  }
  if (locale == null) {
    locale=Locale.getDefault();
  }
  iLocale=locale;
  iElementPairs=new ArrayList();
}"
13986,"/** 
 * @param julian chronology used before the cutover instant
 * @param gregorian chronology used at and after the cutover instant
 * @param cutoverInstant instant when the gregorian chronology began
 */
CutoverChronology(JulianChronology julian,GregorianChronology gregorian,long cutoverInstant){
  checkUTC(julian);
  checkUTC(gregorian);
  if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {
    throw new IllegalArgumentException();
  }
  if (julian.isCenturyISO() != gregorian.isCenturyISO()) {
    throw new IllegalArgumentException();
  }
  iJulianChronology=julian;
  iGregorianChronology=gregorian;
  iCutoverInstant=cutoverInstant;
  iGapDuration=cutoverInstant - julianToGregorian(cutoverInstant);
  copyFields(gregorian);
  if (gregorian.millisOfDay().get(cutoverInstant) == 0) {
    iMillisOfSecondField=new CutoverField(julian.millisOfSecond(),iMillisOfSecondField);
    iMillisOfDayField=new CutoverField(julian.millisOfDay(),iMillisOfDayField);
    iSecondOfMinuteField=new CutoverField(julian.secondOfMinute(),iSecondOfMinuteField);
    iSecondOfDayField=new CutoverField(julian.secondOfDay(),iSecondOfDayField);
    iMinuteOfHourField=new CutoverField(julian.minuteOfHour(),iMinuteOfHourField);
    iMinuteOfDayField=new CutoverField(julian.minuteOfDay(),iMinuteOfDayField);
    iHourOfDayField=new CutoverField(julian.hourOfDay(),iHourOfDayField);
    iHourOfHalfdayField=new CutoverField(julian.hourOfHalfday(),iHourOfHalfdayField);
    iClockhourOfDayField=new CutoverField(julian.clockhourOfDay(),iClockhourOfDayField);
    iClockhourOfHalfdayField=new CutoverField(julian.clockhourOfHalfday(),iClockhourOfHalfdayField);
    iHalfdayOfDayField=new CutoverField(julian.halfdayOfDay(),iHalfdayOfDayField);
  }
{
    iEraField=new CutoverField(julian.era(),gregorian.era());
    iDayOfMonthField=new CutoverField(julian.dayOfMonth(),gregorian.dayOfMonth());
  }
{
    long cutover=gregorian.year().roundCeiling(iCutoverInstant);
    iDayOfYearField=new CutoverField(julian.dayOfYear(),gregorian.dayOfYear(),cutover);
  }
{
    long cutover=gregorian.weekyear().roundCeiling(iCutoverInstant);
    iWeekOfWeekyearField=new CutoverField(julian.weekOfWeekyear(),gregorian.weekOfWeekyear(),cutover);
  }
{
    iYearField=new ImpreciseCutoverField(julian.year(),gregorian.year());
    iYearsField=iYearField.getDurationField();
    iYearOfEraField=new ImpreciseCutoverField(julian.yearOfEra(),gregorian.yearOfEra(),iYearsField);
    iYearOfCenturyField=new ImpreciseCutoverField(julian.yearOfCentury(),gregorian.yearOfCentury(),iYearsField);
    iCenturyOfEraField=new ImpreciseCutoverField(julian.centuryOfEra(),gregorian.centuryOfEra());
    iCenturiesField=iCenturyOfEraField.getDurationField();
    iMonthOfYearField=new ImpreciseCutoverField(julian.monthOfYear(),gregorian.monthOfYear());
    iMonthsField=iMonthOfYearField.getDurationField();
    iWeekyearField=new ImpreciseCutoverField(julian.weekyear(),gregorian.weekyear());
    iWeekyearsField=iWeekyearField.getDurationField();
  }
}","/** 
 * @param julian chronology used before the cutover instant
 * @param gregorian chronology used at and after the cutover instant
 * @param cutoverInstant instant when the gregorian chronology began
 */
CutoverChronology(JulianChronology julian,GregorianChronology gregorian,long cutoverInstant){
  checkUTC(julian);
  checkUTC(gregorian);
  if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {
    throw new IllegalArgumentException();
  }
  if (julian.isCenturyISO() != gregorian.isCenturyISO()) {
    throw new IllegalArgumentException();
  }
  iJulianChronology=julian;
  iGregorianChronology=gregorian;
  iCutoverInstant=cutoverInstant;
  iGapDuration=cutoverInstant - julianToGregorianByYear(cutoverInstant);
  copyFields(gregorian);
  if (gregorian.millisOfDay().get(cutoverInstant) == 0) {
    iMillisOfSecondField=new CutoverField(julian.millisOfSecond(),iMillisOfSecondField);
    iMillisOfDayField=new CutoverField(julian.millisOfDay(),iMillisOfDayField);
    iSecondOfMinuteField=new CutoverField(julian.secondOfMinute(),iSecondOfMinuteField);
    iSecondOfDayField=new CutoverField(julian.secondOfDay(),iSecondOfDayField);
    iMinuteOfHourField=new CutoverField(julian.minuteOfHour(),iMinuteOfHourField);
    iMinuteOfDayField=new CutoverField(julian.minuteOfDay(),iMinuteOfDayField);
    iHourOfDayField=new CutoverField(julian.hourOfDay(),iHourOfDayField);
    iHourOfHalfdayField=new CutoverField(julian.hourOfHalfday(),iHourOfHalfdayField);
    iClockhourOfDayField=new CutoverField(julian.clockhourOfDay(),iClockhourOfDayField);
    iClockhourOfHalfdayField=new CutoverField(julian.clockhourOfHalfday(),iClockhourOfHalfdayField);
    iHalfdayOfDayField=new CutoverField(julian.halfdayOfDay(),iHalfdayOfDayField);
  }
{
    iEraField=new CutoverField(julian.era(),gregorian.era());
    iDayOfMonthField=new CutoverField(julian.dayOfMonth(),gregorian.dayOfMonth());
  }
{
    long cutover=gregorian.year().roundCeiling(iCutoverInstant);
    iDayOfYearField=new CutoverField(julian.dayOfYear(),gregorian.dayOfYear(),cutover);
  }
{
    long cutover=gregorian.weekyear().roundCeiling(iCutoverInstant);
    iWeekOfWeekyearField=new CutoverField(julian.weekOfWeekyear(),gregorian.weekOfWeekyear(),cutover,true);
  }
{
    iYearField=new ImpreciseCutoverField(julian.year(),gregorian.year());
    iYearsField=iYearField.getDurationField();
    iYearOfEraField=new ImpreciseCutoverField(julian.yearOfEra(),gregorian.yearOfEra(),iYearsField);
    iYearOfCenturyField=new ImpreciseCutoverField(julian.yearOfCentury(),gregorian.yearOfCentury(),iYearsField);
    iCenturyOfEraField=new ImpreciseCutoverField(julian.centuryOfEra(),gregorian.centuryOfEra());
    iCenturiesField=iCenturyOfEraField.getDurationField();
    iMonthOfYearField=new ImpreciseCutoverField(julian.monthOfYear(),gregorian.monthOfYear());
    iMonthsField=iMonthOfYearField.getDurationField();
    iWeekyearField=new ImpreciseCutoverField(julian.weekyear(),gregorian.weekyear(),true);
    iWeekyearsField=iWeekyearField.getDurationField();
  }
}"
13987,"/** 
 * Uses a shared duration field rather than creating a new one.
 * @param durationField shared duration field
 */
ImpreciseCutoverField(DateTimeField julianField,DateTimeField gregorianField,DurationField durationField){
  super(julianField,gregorianField);
  if (durationField == null) {
    durationField=new LinkedDurationField(iDurationField,this);
  }
  iDurationField=durationField;
}","/** 
 * Uses a shared duration field rather than creating a new one.
 * @param durationField shared duration field
 */
ImpreciseCutoverField(DateTimeField julianField,DateTimeField gregorianField,DurationField durationField,boolean convertByWeekyear){
  super(julianField,gregorianField,convertByWeekyear);
  if (durationField == null) {
    durationField=new LinkedDurationField(iDurationField,this);
  }
  iDurationField=durationField;
}"
13988,"CutoverField(DateTimeField julianField,DateTimeField gregorianField,long cutoverInstant){
  super(gregorianField.getName());
  iJulianField=julianField;
  iGregorianField=gregorianField;
  iCutover=cutoverInstant;
  iDurationField=gregorianField.getDurationField();
}","CutoverField(DateTimeField julianField,DateTimeField gregorianField,long cutoverInstant,boolean convertByWeekyear){
  super(gregorianField.getName());
  iJulianField=julianField;
  iGregorianField=gregorianField;
  iCutover=cutoverInstant;
  iConvertByWeekyear=convertByWeekyear;
  iDurationField=gregorianField.getDurationField();
}"
13989,"long julianToGregorian(long instant){
  return convert(instant,iJulianChronology,iGregorianChronology);
}","protected long julianToGregorian(long instant){
  if (iConvertByWeekyear) {
    return julianToGregorianByWeekyear(instant);
  }
 else {
    return julianToGregorianByYear(instant);
  }
}"
13990,"long gregorianToJulian(long instant){
  return convert(instant,iGregorianChronology,iJulianChronology);
}","protected long gregorianToJulian(long instant){
  if (iConvertByWeekyear) {
    return gregorianToJulianByWeekyear(instant);
  }
 else {
    return gregorianToJulianByYear(instant);
  }
}"
13991,"/** 
 * Called when applying a time zone.
 */
private GJChronology(Chronology base){
  super(base,null);
}","/** 
 * Called when applying a time zone.
 */
private GJChronology(Chronology base,JulianChronology julian,GregorianChronology gregorian,Instant cutoverInstant){
  super(base,new Object[]{julian,gregorian,cutoverInstant});
}"
13992,"/** 
 * Gets the cutover instant between Gregorian and Julian chronologies.
 * @return the cutover instant
 */
public Instant getGregorianCutover(){
  Instant cutover=iCutoverInstant;
  if (cutover == null) {
    iCutoverInstant=cutover=new Instant(iCutoverMillis);
  }
  return cutover;
}","/** 
 * Gets the cutover instant between Gregorian and Julian chronologies.
 * @return the cutover instant
 */
public Instant getGregorianCutover(){
  return iCutoverInstant;
}"
13993,"protected void assemble(Fields fields){
  if (getBase() != null) {
    return;
  }
  Object[] params=(Object[])getParam();
  JulianChronology julian=(JulianChronology)params[0];
  GregorianChronology gregorian=(GregorianChronology)params[1];
  Instant cutoverInstant=(Instant)params[2];
  iCutoverMillis=cutoverInstant.getMillis();
  if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {
    throw new IllegalArgumentException();
  }
  iJulianChronology=julian;
  iGregorianChronology=gregorian;
  iCutoverInstant=cutoverInstant;
  iGapDuration=iCutoverMillis - julianToGregorianByYear(iCutoverMillis);
  fields.copyFieldsFrom(gregorian);
  if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {
    fields.millisOfSecond=new CutoverField(julian.millisOfSecond(),fields.millisOfSecond);
    fields.millisOfDay=new CutoverField(julian.millisOfDay(),fields.millisOfDay);
    fields.secondOfMinute=new CutoverField(julian.secondOfMinute(),fields.secondOfMinute);
    fields.secondOfDay=new CutoverField(julian.secondOfDay(),fields.secondOfDay);
    fields.minuteOfHour=new CutoverField(julian.minuteOfHour(),fields.minuteOfHour);
    fields.minuteOfDay=new CutoverField(julian.minuteOfDay(),fields.minuteOfDay);
    fields.hourOfDay=new CutoverField(julian.hourOfDay(),fields.hourOfDay);
    fields.hourOfHalfday=new CutoverField(julian.hourOfHalfday(),fields.hourOfHalfday);
    fields.clockhourOfDay=new CutoverField(julian.clockhourOfDay(),fields.clockhourOfDay);
    fields.clockhourOfHalfday=new CutoverField(julian.clockhourOfHalfday(),fields.clockhourOfHalfday);
    fields.halfdayOfDay=new CutoverField(julian.halfdayOfDay(),fields.halfdayOfDay);
  }
{
    fields.era=new CutoverField(julian.era(),fields.era);
    fields.dayOfMonth=new CutoverField(julian.dayOfMonth(),fields.dayOfMonth);
  }
{
    long cutover=gregorian.year().roundCeiling(iCutoverMillis);
    fields.dayOfYear=new CutoverField(julian.dayOfYear(),fields.dayOfYear,cutover);
  }
{
    long cutover=gregorian.weekyear().roundCeiling(iCutoverMillis);
    fields.weekOfWeekyear=new CutoverField(julian.weekOfWeekyear(),fields.weekOfWeekyear,cutover,true);
  }
{
    fields.year=new ImpreciseCutoverField(julian.year(),fields.year);
    fields.years=fields.year.getDurationField();
    fields.yearOfEra=new ImpreciseCutoverField(julian.yearOfEra(),fields.yearOfEra,fields.years);
    fields.yearOfCentury=new ImpreciseCutoverField(julian.yearOfCentury(),fields.yearOfCentury,fields.years);
    fields.centuryOfEra=new ImpreciseCutoverField(julian.centuryOfEra(),fields.centuryOfEra);
    fields.centuries=fields.centuryOfEra.getDurationField();
    fields.monthOfYear=new ImpreciseCutoverField(julian.monthOfYear(),fields.monthOfYear);
    fields.months=fields.monthOfYear.getDurationField();
    fields.weekyear=new ImpreciseCutoverField(julian.weekyear(),fields.weekyear,true);
    fields.weekyears=fields.weekyear.getDurationField();
  }
}","protected void assemble(Fields fields){
  Object[] params=(Object[])getParam();
  JulianChronology julian=(JulianChronology)params[0];
  GregorianChronology gregorian=(GregorianChronology)params[1];
  Instant cutoverInstant=(Instant)params[2];
  iCutoverMillis=cutoverInstant.getMillis();
  iJulianChronology=julian;
  iGregorianChronology=gregorian;
  iCutoverInstant=cutoverInstant;
  if (getBase() != null) {
    return;
  }
  if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {
    throw new IllegalArgumentException();
  }
  iGapDuration=iCutoverMillis - julianToGregorianByYear(iCutoverMillis);
  fields.copyFieldsFrom(gregorian);
  if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {
    fields.millisOfSecond=new CutoverField(julian.millisOfSecond(),fields.millisOfSecond);
    fields.millisOfDay=new CutoverField(julian.millisOfDay(),fields.millisOfDay);
    fields.secondOfMinute=new CutoverField(julian.secondOfMinute(),fields.secondOfMinute);
    fields.secondOfDay=new CutoverField(julian.secondOfDay(),fields.secondOfDay);
    fields.minuteOfHour=new CutoverField(julian.minuteOfHour(),fields.minuteOfHour);
    fields.minuteOfDay=new CutoverField(julian.minuteOfDay(),fields.minuteOfDay);
    fields.hourOfDay=new CutoverField(julian.hourOfDay(),fields.hourOfDay);
    fields.hourOfHalfday=new CutoverField(julian.hourOfHalfday(),fields.hourOfHalfday);
    fields.clockhourOfDay=new CutoverField(julian.clockhourOfDay(),fields.clockhourOfDay);
    fields.clockhourOfHalfday=new CutoverField(julian.clockhourOfHalfday(),fields.clockhourOfHalfday);
    fields.halfdayOfDay=new CutoverField(julian.halfdayOfDay(),fields.halfdayOfDay);
  }
{
    fields.era=new CutoverField(julian.era(),fields.era);
    fields.dayOfMonth=new CutoverField(julian.dayOfMonth(),fields.dayOfMonth);
  }
{
    long cutover=gregorian.year().roundCeiling(iCutoverMillis);
    fields.dayOfYear=new CutoverField(julian.dayOfYear(),fields.dayOfYear,cutover);
  }
{
    long cutover=gregorian.weekyear().roundCeiling(iCutoverMillis);
    fields.weekOfWeekyear=new CutoverField(julian.weekOfWeekyear(),fields.weekOfWeekyear,cutover,true);
  }
{
    fields.year=new ImpreciseCutoverField(julian.year(),fields.year);
    fields.years=fields.year.getDurationField();
    fields.yearOfEra=new ImpreciseCutoverField(julian.yearOfEra(),fields.yearOfEra,fields.years);
    fields.yearOfCentury=new ImpreciseCutoverField(julian.yearOfCentury(),fields.yearOfCentury,fields.years);
    fields.centuryOfEra=new ImpreciseCutoverField(julian.centuryOfEra(),fields.centuryOfEra);
    fields.centuries=fields.centuryOfEra.getDurationField();
    fields.monthOfYear=new ImpreciseCutoverField(julian.monthOfYear(),fields.monthOfYear);
    fields.months=fields.monthOfYear.getDurationField();
    fields.weekyear=new ImpreciseCutoverField(julian.weekyear(),fields.weekyear,true);
    fields.weekyears=fields.weekyear.getDurationField();
  }
}"
13994,"/** 
 * Constructs an instance from an Object that represents a date, using the specified chronology. <p> The recognised object types are defined in   {@link ConverterManager} andinclude ReadableInstant, String, Calendar and Date.
 * @param instant  the datetime object, must not be null
 * @param chronology  the chronology, null means ISOChronology
 * @throws IllegalArgumentException if the date or chronology is null
 */
protected AbstractPartialInstant(Object instant,final Chronology chronology){
  iChronology=selectChronologyUTC(chronology);
  InstantConverter converter=ConverterManager.getInstance().getInstantConverter(instant);
  iMillis=resetUnsupportedFields(toLocalTime(converter.getInstantMillis(instant),converter.getChronology(instant),iChronology));
}","/** 
 * Constructs an instance from an Object that represents a date, using the specified chronology. <p> The recognised object types are defined in   {@link ConverterManager} andinclude ReadableInstant, String, Calendar and Date.
 * @param instant  the datetime object, must not be null
 * @param chronology  the chronology, null means ISOChronology
 * @throws IllegalArgumentException if the date or chronology is null
 */
protected AbstractPartialInstant(Object instant,final Chronology chronology){
  InstantConverter converter=ConverterManager.getInstance().getInstantConverter(instant);
  Chronology original=converter.getChronology(instant,chronology);
  iChronology=selectChronologyUTC(original);
  iMillis=resetUnsupportedFields(toLocalTime(converter.getInstantMillis(instant,chronology),original,iChronology));
}"
13995,"/** 
 * Instructs the printer to emit a numeric weekyear field.
 * @param minDigits minumum number of digits to <i>print</i>
 * @param maxDigits maximum number of digits to <i>parse</i>, or the estimatedmaximum number of digits to print
 * @return this DateTimeFormatterBuilder
 */
public DateTimeFormatterBuilder appendWeekyear(final int minDigits,final int maxDigits){
  return appendDecimal(iChronoUTC.weekyear(),minDigits,maxDigits);
}","/** 
 * Instructs the printer to emit a numeric weekyear field.
 * @param minDigits minumum number of digits to <i>print</i>
 * @param maxDigits maximum number of digits to <i>parse</i>, or the estimatedmaximum number of digits to print
 * @return this DateTimeFormatterBuilder
 */
public DateTimeFormatterBuilder appendWeekyear(final int minDigits,final int maxDigits){
  return appendSignedDecimal(iChronoUTC.weekyear(),minDigits,maxDigits);
}"
13996,"public int parseInto(final DateTimeParserBucket bucket,final String text,final int position){
  DateTimeParser[] parsers=iParsers;
  int length=parsers.length;
  final Object originalState=bucket.saveState();
  boolean isOptional=false;
  int bestValidPos=position;
  Object bestValidState=null;
  int bestInvalidPos=position;
  for (int i=0; i < length; i++) {
    DateTimeParser parser=parsers[i];
    if (parser == null) {
      if (bestValidPos <= position) {
        return position;
      }
      isOptional=true;
      break;
    }
    int parsePos=parser.parseInto(bucket,text,position);
    if (parsePos >= position) {
      if (parsePos > bestValidPos) {
        if (parsePos >= text.length() || (i + 1) >= length || parsers[i + 1] == null) {
          return parsePos;
        }
        bestValidPos=parsePos;
        bestValidState=bucket.saveState();
      }
    }
 else {
      bucket.undoChanges(originalState);
      if (parsePos < 0) {
        parsePos=~parsePos;
        if (parsePos > bestInvalidPos) {
          bestInvalidPos=parsePos;
        }
      }
    }
  }
  if (bestValidPos > position || (bestValidPos == position && isOptional)) {
    if (bestValidState != null) {
      bucket.undoChanges(bestValidState);
    }
    return bestValidPos;
  }
  return ~bestInvalidPos;
}","public int parseInto(final DateTimeParserBucket bucket,final String text,final int position){
  DateTimeParser[] parsers=iParsers;
  int length=parsers.length;
  final Object originalState=bucket.saveState();
  boolean isOptional=false;
  int bestValidPos=position;
  Object bestValidState=null;
  int bestInvalidPos=position;
  for (int i=0; i < length; i++) {
    DateTimeParser parser=parsers[i];
    if (parser == null) {
      if (bestValidPos <= position) {
        return position;
      }
      isOptional=true;
      break;
    }
    int parsePos=parser.parseInto(bucket,text,position);
    if (parsePos >= position) {
      if (parsePos > bestValidPos) {
        if (parsePos >= text.length() || (i + 1) >= length || parsers[i + 1] == null) {
          return parsePos;
        }
        bestValidPos=parsePos;
        bestValidState=bucket.saveState();
      }
    }
 else {
      if (parsePos < 0) {
        parsePos=~parsePos;
        if (parsePos > bestInvalidPos) {
          bestInvalidPos=parsePos;
        }
      }
    }
    bucket.restoreState(originalState);
  }
  if (bestValidPos > position || (bestValidPos == position && isOptional)) {
    if (bestValidState != null) {
      bucket.restoreState(bestValidState);
    }
    return bestValidPos;
  }
  return ~bestInvalidPos;
}"
13997,"public int parseInto(DateTimeParserBucket bucket,String text,int position){
  DateTimeParser[] parsers=iParsers;
  int length=parsers.length;
  Object state=bucket.saveState();
  int bestInvalidPos=position;
  int bestInvalidParser=0;
  int bestValidPos=position;
  int bestValidParser=0;
  for (int i=0; i < length; i++) {
    if (i != 0) {
      bucket.undoChanges(state);
    }
    DateTimeParser parser=parsers[i];
    if (parser == null) {
      if (bestValidPos > position) {
        break;
      }
      return position;
    }
    int parsePos=parser.parseInto(bucket,text,position);
    if (parsePos >= position) {
      if (parsePos >= text.length()) {
        return parsePos;
      }
      if (parsePos > bestValidPos) {
        bestValidPos=parsePos;
        bestValidParser=i;
      }
    }
 else {
      parsePos=~parsePos;
      if (parsePos > bestInvalidPos) {
        bestInvalidPos=parsePos;
        bestInvalidParser=i;
      }
    }
  }
  if (bestValidPos > position) {
    if (bestValidParser == length - 1) {
      return bestValidPos;
    }
    bucket.undoChanges(state);
    return parsers[bestValidParser].parseInto(bucket,text,position);
  }
  if (bestInvalidParser == length - 1) {
    return ~bestInvalidPos;
  }
  bucket.undoChanges(state);
  return parsers[bestInvalidParser].parseInto(bucket,text,position);
}","public int parseInto(final DateTimeParserBucket bucket,final String text,final int position){
  DateTimeParser[] parsers=iParsers;
  int length=parsers.length;
  final Object originalState=bucket.saveState();
  boolean isOptional=false;
  int bestValidPos=position;
  Object bestValidState=null;
  int bestInvalidPos=position;
  for (int i=0; i < length; i++) {
    DateTimeParser parser=parsers[i];
    if (parser == null) {
      if (bestValidPos <= position) {
        return position;
      }
      isOptional=true;
      break;
    }
    int parsePos=parser.parseInto(bucket,text,position);
    if (parsePos >= position) {
      if (parsePos > bestValidPos) {
        if (parsePos >= text.length() || (i + 1) >= length || parsers[i + 1] == null) {
          return parsePos;
        }
        bestValidPos=parsePos;
        bestValidState=bucket.saveState();
      }
    }
 else {
      bucket.undoChanges(originalState);
      if (parsePos < 0) {
        parsePos=~parsePos;
        if (parsePos > bestInvalidPos) {
          bestInvalidPos=parsePos;
        }
      }
    }
  }
  if (bestValidPos > position || (bestValidPos == position && isOptional)) {
    if (bestValidState != null) {
      bucket.undoChanges(bestValidState);
    }
    return bestValidPos;
  }
  return ~bestInvalidPos;
}"
13998,"/** 
 * Appends a printer and a set of matching parsers. When parsing, the first parser in the list is selected for parsing. If it fails, the next is chosen, and so on. If none of these parsers succeeds, then the failed position of the parser that made the greatest progress is returned. <p> Only the printer is optional. In addtion, it is illegal for any but the last of the parser array elements to be null. If the last element is null, this represents the empty parser. The presence of an empty parser indicates that the entire array of parse formats is optional.
 * @return this DateTimeFormatterBuilder
 * @throws IllegalArgumentException if any parser element but the last is null
 */
public DateTimeFormatterBuilder append(final DateTimePrinter printer,final DateTimeParser[] parsers) throws IllegalArgumentException {
  if (parsers == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int length=parsers.length;
  if (length == 1) {
    return append(printer,parsers[0]);
  }
  DateTimeParser[] copyOfParsers=new DateTimeParser[length];
  int i;
  for (i=0; i < length - 1; i++) {
    if ((copyOfParsers[i]=parsers[i]) == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  copyOfParsers[i]=parsers[i];
  return append0(printer,new MatchingParser(iChrono,copyOfParsers));
}","/** 
 * Appends a printer and a set of matching parsers. When parsing, the first parser in the list is selected for parsing. If it fails, the next is chosen, and so on. If none of these parsers succeeds, then the failed position of the parser that made the greatest progress is returned. <p> Only the printer is optional. In addtion, it is illegal for any but the last of the parser array elements to be null. If the last element is null, this represents the empty parser. The presence of an empty parser indicates that the entire array of parse formats is optional.
 * @return this DateTimeFormatterBuilder
 * @throws IllegalArgumentException if any parser element but the last is null
 */
public DateTimeFormatterBuilder append(final DateTimePrinter printer,final DateTimeParser[] parsers) throws IllegalArgumentException {
  if (parsers == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int length=parsers.length;
  if (length == 1) {
    if (parsers[0] == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    return append0(printer,parsers[0]);
  }
  DateTimeParser[] copyOfParsers=new DateTimeParser[length];
  int i;
  for (i=0; i < length - 1; i++) {
    if ((copyOfParsers[i]=parsers[i]) == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  copyOfParsers[i]=parsers[i];
  return append0(printer,new MatchingParser(iChrono,copyOfParsers));
}"
13999,"static String createErrorMessage(final String text,final int errorPos){
  int sampleLen=errorPos + 20;
  String sampleText;
  if (text.length() <= sampleLen) {
    sampleText=text;
  }
 else {
    sampleText=text.substring(0,sampleLen).concat(""String_Node_Str"");
  }
  if (errorPos <= 0) {
    return ""String_Node_Str"" + sampleText + '""';
  }
  if (errorPos >= text.length()) {
    return ""String_Node_Str"" + sampleText + ""String_Node_Str"";
  }
  return ""String_Node_Str"" + sampleText + ""String_Node_Str""+ sampleText.substring(errorPos)+ '""';
}","static String createErrorMessage(final String text,final int errorPos){
  int sampleLen=errorPos + 20;
  String sampleText;
  if (text.length() <= sampleLen + 3) {
    sampleText=text;
  }
 else {
    sampleText=text.substring(0,sampleLen).concat(""String_Node_Str"");
  }
  if (errorPos <= 0) {
    return ""String_Node_Str"" + sampleText + '""';
  }
  if (errorPos >= text.length()) {
    return ""String_Node_Str"" + sampleText + ""String_Node_Str"";
  }
  return ""String_Node_Str"" + sampleText + ""String_Node_Str""+ sampleText.substring(errorPos)+ '""';
}"
14000,"private void makeGraphCall(){
  Session session=Session.getActiveSession();
  Request.Callback graphCallback=new Request.Callback(){
    @Override public void onCompleted(    Response response){
      if (graphContext != null) {
        if (response.getError() != null) {
          graphContext.error(response.getError().getErrorMessage());
        }
 else {
          GraphObject graphObject=response.getGraphObject();
          graphContext.success(graphObject.getInnerJSONObject());
        }
        graphPath=null;
        graphContext=null;
      }
    }
  }
;
  try {
    graphPath=URLDecoder.decode(graphPath,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
  String[] urlParts=graphPath.split(""String_Node_Str"");
  String graphAction=urlParts[0];
  Request graphRequest=Request.newGraphPathRequest(null,graphAction,graphCallback);
  Bundle params=graphRequest.getParameters();
  if (urlParts.length > 1) {
    String[] queries=urlParts[1].split(""String_Node_Str"");
    for (    String query : queries) {
      int splitPoint=query.indexOf(""String_Node_Str"");
      if (splitPoint > 0) {
        String key=query.substring(0,splitPoint);
        String value=query.substring(splitPoint + 1,query.length());
        params.putString(key,value);
      }
    }
  }
  params.putString(""String_Node_Str"",session.getAccessToken());
  graphRequest.setParameters(params);
  graphRequest.executeAsync();
}","private void makeGraphCall(){
  Session session=Session.getActiveSession();
  Request.Callback graphCallback=new Request.Callback(){
    @Override public void onCompleted(    Response response){
      if (graphContext != null) {
        if (response.getError() != null) {
          graphContext.error(getErrorResponse(response.getError()));
        }
 else {
          GraphObject graphObject=response.getGraphObject();
          graphContext.success(graphObject.getInnerJSONObject());
        }
        graphPath=null;
        graphContext=null;
      }
    }
  }
;
  try {
    graphPath=URLDecoder.decode(graphPath,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
  String[] urlParts=graphPath.split(""String_Node_Str"");
  String graphAction=urlParts[0];
  Request graphRequest=Request.newGraphPathRequest(null,graphAction,graphCallback);
  Bundle params=graphRequest.getParameters();
  if (urlParts.length > 1) {
    String[] queries=urlParts[1].split(""String_Node_Str"");
    for (    String query : queries) {
      int splitPoint=query.indexOf(""String_Node_Str"");
      if (splitPoint > 0) {
        String key=query.substring(0,splitPoint);
        String value=query.substring(splitPoint + 1,query.length());
        params.putString(key,value);
      }
    }
  }
  params.putString(""String_Node_Str"",session.getAccessToken());
  graphRequest.setParameters(params);
  graphRequest.executeAsync();
}"
