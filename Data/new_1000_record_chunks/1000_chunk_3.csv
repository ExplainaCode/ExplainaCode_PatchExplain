record_number,buggy_code,fixed_code
2001,"public RotateState(RotateState source,RotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFromDegrees=mCurrentDegrees=source.mFromDegrees;
    mToDegrees=source.mToDegrees;
    mCanConstantState=mCheckedConstantState=true;
  }
}","public RotateState(RotateState source,RotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(source.mDrawable.getLayoutDirection());
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFromDegrees=mCurrentDegrees=source.mFromDegrees;
    mToDegrees=source.mToDegrees;
    mCanConstantState=mCheckedConstantState=true;
  }
}"
2002,"ScaleState(ScaleState orig,ScaleDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mScaleWidth=orig.mScaleWidth;
    mScaleHeight=orig.mScaleHeight;
    mGravity=orig.mGravity;
    mUseIntrinsicSizeAsMin=orig.mUseIntrinsicSizeAsMin;
    mCheckedConstantState=mCanConstantState=true;
  }
}","ScaleState(ScaleState orig,ScaleDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(orig.mDrawable.getLayoutDirection());
    mScaleWidth=orig.mScaleWidth;
    mScaleHeight=orig.mScaleHeight;
    mGravity=orig.mGravity;
    mUseIntrinsicSizeAsMin=orig.mUseIntrinsicSizeAsMin;
    mCheckedConstantState=mCanConstantState=true;
  }
}"
2003,"public void moveTaskToTop(int taskId){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (mWindowMap) {
      Task task=mTaskIdToTask.get(taskId);
      if (task == null) {
        Slog.e(TAG,""String_Node_Str"" + taskId + ""String_Node_Str"");
        return;
      }
      final TaskStack stack=task.mStack;
      final DisplayContent displayContent=task.getDisplayContent();
      final boolean isHomeStackTask=stack.isHomeStack();
      final boolean homeIsOnTop=displayContent.homeOnTop();
      if (!isHomeStackTask && homeIsOnTop) {
        moveHomeTasksLocked(false);
        displayContent.moveHomeStackBox(false);
      }
 else       if (isHomeStackTask && !homeIsOnTop) {
        displayContent.moveHomeStackBox(true);
      }
      stack.moveTaskToTop(task);
      displayContent.moveStack(stack,true);
      moveTaskWindowsLocked(task);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","public void moveTaskToTop(int taskId){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (mWindowMap) {
      Task task=mTaskIdToTask.get(taskId);
      if (task == null) {
        Slog.e(TAG,""String_Node_Str"" + taskId + ""String_Node_Str"");
        return;
      }
      final TaskStack stack=task.mStack;
      final DisplayContent displayContent=task.getDisplayContent();
      final boolean isHomeStackTask=stack.isHomeStack();
      final boolean homeIsOnTop=displayContent.homeOnTop();
      if (!isHomeStackTask && homeIsOnTop) {
        moveHomeTasksLocked(false);
        displayContent.moveHomeStackBox(false);
      }
 else       if (isHomeStackTask && !homeIsOnTop) {
        displayContent.moveHomeStackBox(true);
      }
      stack.moveTaskToTop(task);
      displayContent.moveStack(stack,true);
      moveStackWindowsLocked(stack);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
2004,"private int findAppWindowInsertionPointLocked(AppWindowToken target){
  final int taskId=target.groupId;
  Task targetTask=mTaskIdToTask.get(taskId);
  if (targetTask == null) {
    Slog.w(TAG,""String_Node_Str"" + target + ""String_Node_Str""+ taskId);
    return 0;
  }
  DisplayContent displayContent=targetTask.getDisplayContent();
  if (displayContent == null) {
    Slog.w(TAG,""String_Node_Str"" + target);
    return 0;
  }
  final WindowList windows=displayContent.getWindowList();
  final int NW=windows.size();
  boolean found=false;
  final ArrayList<Task> tasks=displayContent.getTasks();
  for (int taskNdx=tasks.size() - 1; taskNdx >= 0; --taskNdx) {
    final Task task=tasks.get(taskNdx);
    if (!found && task.taskId != taskId) {
      continue;
    }
    AppTokenList tokens=task.mAppTokens;
    for (int tokenNdx=tokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      final AppWindowToken wtoken=tokens.get(tokenNdx);
      if (!found && wtoken == target) {
        found=true;
      }
      if (found) {
        if (DEBUG_REORDER)         Slog.v(TAG,""String_Node_Str"" + wtoken.token);
        if (wtoken.sendingToBottom) {
          if (DEBUG_REORDER)           Slog.v(TAG,""String_Node_Str"");
          continue;
        }
        for (int i=wtoken.windows.size() - 1; i >= 0; --i) {
          WindowState win=wtoken.windows.get(i);
          for (int j=win.mChildWindows.size() - 1; j >= 0; --j) {
            WindowState cwin=win.mChildWindows.get(j);
            if (cwin.mSubLayer >= 0) {
              for (int pos=NW - 1; pos >= 0; pos--) {
                if (windows.get(pos) == cwin) {
                  if (DEBUG_REORDER)                   Slog.v(TAG,""String_Node_Str"" + (pos + 1));
                  return pos + 1;
                }
              }
            }
          }
          for (int pos=NW - 1; pos >= 0; pos--) {
            if (windows.get(pos) == win) {
              if (DEBUG_REORDER)               Slog.v(TAG,""String_Node_Str"" + (pos + 1));
              return pos + 1;
            }
          }
        }
      }
    }
  }
  return 0;
}","private int findAppWindowInsertionPointLocked(AppWindowToken target){
  final int taskId=target.groupId;
  Task targetTask=mTaskIdToTask.get(taskId);
  if (targetTask == null) {
    Slog.w(TAG,""String_Node_Str"" + target + ""String_Node_Str""+ taskId);
    return 0;
  }
  DisplayContent displayContent=targetTask.getDisplayContent();
  if (displayContent == null) {
    Slog.w(TAG,""String_Node_Str"" + target);
    return 0;
  }
  final WindowList windows=displayContent.getWindowList();
  final int NW=windows.size();
  boolean found=false;
  final ArrayList<Task> tasks=displayContent.getTasks();
  for (int taskNdx=tasks.size() - 1; taskNdx >= 0; --taskNdx) {
    final Task task=tasks.get(taskNdx);
    if (!found && task.taskId != taskId) {
      continue;
    }
    AppTokenList tokens=task.mAppTokens;
    for (int tokenNdx=tokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      final AppWindowToken wtoken=tokens.get(tokenNdx);
      if (!found && wtoken == target) {
        found=true;
      }
      if (found) {
        if (DEBUG_REORDER)         Slog.v(TAG,""String_Node_Str"" + wtoken.token);
        if (wtoken.sendingToBottom) {
          if (DEBUG_REORDER)           Slog.v(TAG,""String_Node_Str"");
          continue;
        }
        for (int i=wtoken.windows.size() - 1; i >= 0; --i) {
          WindowState win=wtoken.windows.get(i);
          for (int j=win.mChildWindows.size() - 1; j >= 0; --j) {
            WindowState cwin=win.mChildWindows.get(j);
            if (cwin.mSubLayer >= 0) {
              for (int pos=NW - 1; pos >= 0; pos--) {
                if (windows.get(pos) == cwin) {
                  if (DEBUG_REORDER)                   Slog.v(TAG,""String_Node_Str"" + (pos + 1));
                  return pos + 1;
                }
              }
            }
          }
          for (int pos=NW - 1; pos >= 0; pos--) {
            if (windows.get(pos) == win) {
              if (DEBUG_REORDER)               Slog.v(TAG,""String_Node_Str"" + (pos + 1));
              return pos + 1;
            }
          }
        }
      }
    }
  }
  for (int pos=NW - 1; pos >= 0; pos--) {
    if (windows.get(pos).mIsWallpaper) {
      if (DEBUG_REORDER)       Slog.v(TAG,""String_Node_Str"" + pos);
      return pos + 1;
    }
  }
  return 0;
}"
2005,"int adjustWallpaperWindowsLocked(){
  mInnerFields.mWallpaperMayChange=false;
  boolean targetChanged=false;
  final DisplayInfo displayInfo=getDefaultDisplayContentLocked().getDisplayInfo();
  final int dw=displayInfo.appWidth;
  final int dh=displayInfo.appHeight;
  final WindowList windows=getDefaultWindowListLocked();
  int N=windows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int windowDetachedI=-1;
  int i=N;
  while (i > 0) {
    i--;
    w=windows.get(i);
    if ((w.mAttrs.type == TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w != mAnimator.mWindowDetachedWallpaper && w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.mAppAnimator.animation == null) {
        if (DEBUG_WALLPAPER)         Slog.v(TAG,""String_Node_Str"" + w);
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w+ ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ w.mWinAnimator.mDrawState);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isOnScreen() && (mWallpaperTarget == w || w.isDrawFinishedLw())) {
      if (DEBUG_WALLPAPER)       Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && w.mWinAnimator.isAnimating()) {
        if (DEBUG_WALLPAPER)         Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
 else     if (w == mAnimator.mWindowDetachedWallpaper) {
      windowDetachedI=i;
    }
  }
  if (foundW == null && windowDetachedI >= 0) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
    foundW=w;
    foundI=windowDetachedI;
  }
  if (mWallpaperTarget != foundW && (mLowerWallpaperTarget == null || mLowerWallpaperTarget != foundW)) {
    if (DEBUG_WALLPAPER_LIGHT) {
      Slog.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    targetChanged=true;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.isAnimatingLw();
      boolean foundAnim=foundW.isAnimatingLw();
      if (DEBUG_WALLPAPER_LIGHT) {
        Slog.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=windows.indexOf(oldW);
        if (DEBUG_WALLPAPER_LIGHT) {
          Slog.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER_LIGHT) {
            Slog.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER_LIGHT) {
              Slog.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else           if (foundI > oldI) {
            if (DEBUG_WALLPAPER_LIGHT) {
              Slog.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER_LIGHT) {
              Slog.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else   if (mLowerWallpaperTarget != null) {
    if (!mLowerWallpaperTarget.isAnimatingLw() || !mUpperWallpaperTarget.isAnimatingLw()) {
      if (DEBUG_WALLPAPER_LIGHT) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
      mWallpaperTarget=foundW;
      targetChanged=true;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Slog.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.mAppAnimator.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=windows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (foundW.mAttachedWindow == null || wb.mAttachedWindow != foundW.mAttachedWindow) && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || foundW.mToken == null || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Slog.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? windows.get(foundI - 1) : null;
  }
  if (visible) {
    if (mWallpaperTarget.mWallpaperX >= 0) {
      mLastWallpaperX=mWallpaperTarget.mWallpaperX;
      mLastWallpaperXStep=mWallpaperTarget.mWallpaperXStep;
    }
    if (mWallpaperTarget.mWallpaperY >= 0) {
      mLastWallpaperY=mWallpaperTarget.mWallpaperY;
      mLastWallpaperYStep=mWallpaperTarget.mWallpaperYStep;
    }
  }
  int changed=0;
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      if (DEBUG_WALLPAPER_LIGHT)       Slog.d(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ !visible);
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      getDefaultDisplayContentLocked().layoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      dispatchWallpaperVisibility(wallpaper,visible);
      wallpaper.mWinAnimator.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER_LIGHT)       Slog.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mWinAnimator.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? windows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=windows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        windows.remove(oldIndex);
        mWindowsChanged=true;
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER_LIGHT || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) {
        Slog.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      }
      windows.add(foundI,wallpaper);
      mWindowsChanged=true;
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  final TaskStack targetStack=mWallpaperTarget == null ? null : mWallpaperTarget.getStack();
  if ((changed & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0 && targetStack != null && !targetStack.isHomeStack()) {
    for (i=foundI - 1; i >= 0; --i) {
      WindowState win=windows.get(i);
      if (!win.isVisibleLw()) {
        continue;
      }
      final TaskStack winStack=win.getStack();
      if (winStack != null && !winStack.isHomeStack() && winStack != targetStack) {
        windows.remove(i);
        windows.add(foundI + 1,win);
      }
    }
  }
  if (targetChanged && DEBUG_WALLPAPER_LIGHT) {
    Slog.d(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
  }
  return changed;
}","int adjustWallpaperWindowsLocked(){
  mInnerFields.mWallpaperMayChange=false;
  boolean targetChanged=false;
  final DisplayInfo displayInfo=getDefaultDisplayContentLocked().getDisplayInfo();
  final int dw=displayInfo.appWidth;
  final int dh=displayInfo.appHeight;
  final WindowList windows=getDefaultWindowListLocked();
  int N=windows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int windowDetachedI=-1;
  int i=N;
  while (i > 0) {
    i--;
    w=windows.get(i);
    if ((w.mAttrs.type == TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w != mAnimator.mWindowDetachedWallpaper && w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.mAppAnimator.animation == null) {
        if (DEBUG_WALLPAPER)         Slog.v(TAG,""String_Node_Str"" + w);
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w+ ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ w.mWinAnimator.mDrawState);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isOnScreen() && (mWallpaperTarget == w || w.isDrawFinishedLw())) {
      if (DEBUG_WALLPAPER)       Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && w.mWinAnimator.isAnimating()) {
        if (DEBUG_WALLPAPER)         Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
 else     if (w == mAnimator.mWindowDetachedWallpaper) {
      windowDetachedI=i;
    }
  }
  if (foundW == null && windowDetachedI >= 0) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
    foundW=w;
    foundI=windowDetachedI;
  }
  if (mWallpaperTarget != foundW && (mLowerWallpaperTarget == null || mLowerWallpaperTarget != foundW)) {
    if (DEBUG_WALLPAPER_LIGHT) {
      Slog.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    targetChanged=true;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.isAnimatingLw();
      boolean foundAnim=foundW.isAnimatingLw();
      if (DEBUG_WALLPAPER_LIGHT) {
        Slog.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=windows.indexOf(oldW);
        if (DEBUG_WALLPAPER_LIGHT) {
          Slog.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER_LIGHT) {
            Slog.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER_LIGHT) {
              Slog.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else           if (foundI > oldI) {
            if (DEBUG_WALLPAPER_LIGHT) {
              Slog.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER_LIGHT) {
              Slog.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else   if (mLowerWallpaperTarget != null) {
    if (!mLowerWallpaperTarget.isAnimatingLw() || !mUpperWallpaperTarget.isAnimatingLw()) {
      if (DEBUG_WALLPAPER_LIGHT) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
      mWallpaperTarget=foundW;
      targetChanged=true;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Slog.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.mAppAnimator.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=windows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (foundW.mAttachedWindow == null || wb.mAttachedWindow != foundW.mAttachedWindow) && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || foundW.mToken == null || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Slog.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? windows.get(foundI - 1) : null;
  }
  if (visible) {
    if (mWallpaperTarget.mWallpaperX >= 0) {
      mLastWallpaperX=mWallpaperTarget.mWallpaperX;
      mLastWallpaperXStep=mWallpaperTarget.mWallpaperXStep;
    }
    if (mWallpaperTarget.mWallpaperY >= 0) {
      mLastWallpaperY=mWallpaperTarget.mWallpaperY;
      mLastWallpaperYStep=mWallpaperTarget.mWallpaperYStep;
    }
  }
  int changed=0;
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      if (DEBUG_WALLPAPER_LIGHT)       Slog.d(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ !visible);
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      getDefaultDisplayContentLocked().layoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      dispatchWallpaperVisibility(wallpaper,visible);
      wallpaper.mWinAnimator.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER_LIGHT)       Slog.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mWinAnimator.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? windows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=windows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        windows.remove(oldIndex);
        mWindowsChanged=true;
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER_LIGHT || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) {
        Slog.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ 0);
      }
      windows.add(0,wallpaper);
      mWindowsChanged=true;
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  if (targetChanged && DEBUG_WALLPAPER_LIGHT) {
    Slog.d(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
  }
  return changed;
}"
2006,"public void moveTaskToBottom(int taskId){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (mWindowMap) {
      Task task=mTaskIdToTask.get(taskId);
      if (task == null) {
        Slog.e(TAG,""String_Node_Str"" + taskId + ""String_Node_Str"");
        return;
      }
      task.mStack.moveTaskToBottom(task);
      moveTaskWindowsLocked(task);
      task.getDisplayContent().moveStack(task.mStack,false);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","public void moveTaskToBottom(int taskId){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (mWindowMap) {
      Task task=mTaskIdToTask.get(taskId);
      if (task == null) {
        Slog.e(TAG,""String_Node_Str"" + taskId + ""String_Node_Str"");
        return;
      }
      final TaskStack stack=task.mStack;
      stack.moveTaskToBottom(task);
      task.getDisplayContent().moveStack(stack,false);
      moveStackWindowsLocked(stack);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
2007,"private static void exportMethods(Context context,Object view,BufferedWriter out,Class<?> klass,String prefix) throws IOException {
  final Method[] methods=getExportedPropertyMethods(klass);
  int count=methods.length;
  for (int i=0; i < count; i++) {
    final Method method=methods[i];
    try {
      Object methodValue=method.invoke(view,(Object[])null);
      final Class<?> returnType=method.getReturnType();
      final ExportedProperty property=sAnnotations.get(method);
      String categoryPrefix=property.category().length() != 0 ? property.category() + ""String_Node_Str"" : ""String_Node_Str"";
      if (returnType == int.class) {
        if (property.resolveId() && context != null) {
          final int id=(Integer)methodValue;
          methodValue=resolveId(context,id);
        }
 else {
          final FlagToString[] flagsMapping=property.flagMapping();
          if (flagsMapping.length > 0) {
            final int intValue=(Integer)methodValue;
            final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
            exportUnrolledFlags(out,flagsMapping,intValue,valuePrefix);
          }
          final IntToString[] mapping=property.mapping();
          if (mapping.length > 0) {
            final int intValue=(Integer)methodValue;
            boolean mapped=false;
            int mappingCount=mapping.length;
            for (int j=0; j < mappingCount; j++) {
              final IntToString mapper=mapping[j];
              if (mapper.from() == intValue) {
                methodValue=mapper.to();
                mapped=true;
                break;
              }
            }
            if (!mapped) {
              methodValue=intValue;
            }
          }
        }
      }
 else       if (returnType == int[].class) {
        final int[] array=(int[])methodValue;
        final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
        final String suffix=""String_Node_Str"";
        exportUnrolledArray(context,out,property,array,valuePrefix,suffix);
        return;
      }
 else       if (!returnType.isPrimitive()) {
        if (property.deepExport()) {
          dumpViewProperties(context,methodValue,out,prefix + property.prefix());
          continue;
        }
      }
      writeEntry(out,categoryPrefix + prefix,method.getName(),""String_Node_Str"",methodValue);
    }
 catch (    IllegalAccessException e) {
    }
catch (    InvocationTargetException e) {
    }
  }
}","private static void exportMethods(Context context,Object view,BufferedWriter out,Class<?> klass,String prefix) throws IOException {
  final Method[] methods=getExportedPropertyMethods(klass);
  int count=methods.length;
  for (int i=0; i < count; i++) {
    final Method method=methods[i];
    try {
      Object methodValue=callMethodOnAppropriateTheadBlocking(method,view);
      final Class<?> returnType=method.getReturnType();
      final ExportedProperty property=sAnnotations.get(method);
      String categoryPrefix=property.category().length() != 0 ? property.category() + ""String_Node_Str"" : ""String_Node_Str"";
      if (returnType == int.class) {
        if (property.resolveId() && context != null) {
          final int id=(Integer)methodValue;
          methodValue=resolveId(context,id);
        }
 else {
          final FlagToString[] flagsMapping=property.flagMapping();
          if (flagsMapping.length > 0) {
            final int intValue=(Integer)methodValue;
            final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
            exportUnrolledFlags(out,flagsMapping,intValue,valuePrefix);
          }
          final IntToString[] mapping=property.mapping();
          if (mapping.length > 0) {
            final int intValue=(Integer)methodValue;
            boolean mapped=false;
            int mappingCount=mapping.length;
            for (int j=0; j < mappingCount; j++) {
              final IntToString mapper=mapping[j];
              if (mapper.from() == intValue) {
                methodValue=mapper.to();
                mapped=true;
                break;
              }
            }
            if (!mapped) {
              methodValue=intValue;
            }
          }
        }
      }
 else       if (returnType == int[].class) {
        final int[] array=(int[])methodValue;
        final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
        final String suffix=""String_Node_Str"";
        exportUnrolledArray(context,out,property,array,valuePrefix,suffix);
        return;
      }
 else       if (!returnType.isPrimitive()) {
        if (property.deepExport()) {
          dumpViewProperties(context,methodValue,out,prefix + property.prefix());
          continue;
        }
      }
      writeEntry(out,categoryPrefix + prefix,method.getName(),""String_Node_Str"",methodValue);
    }
 catch (    IllegalAccessException e) {
    }
catch (    InvocationTargetException e) {
    }
catch (    TimeoutException e) {
    }
  }
}"
2008,"private static void exportMethods(Context context,Object view,BufferedWriter out,Class<?> klass,String prefix) throws IOException {
  final Method[] methods=getExportedPropertyMethods(klass);
  int count=methods.length;
  for (int i=0; i < count; i++) {
    final Method method=methods[i];
    try {
      Object methodValue=method.invoke(view,(Object[])null);
      final Class<?> returnType=method.getReturnType();
      final ExportedProperty property=sAnnotations.get(method);
      String categoryPrefix=property.category().length() != 0 ? property.category() + ""String_Node_Str"" : ""String_Node_Str"";
      if (returnType == int.class) {
        if (property.resolveId() && context != null) {
          final int id=(Integer)methodValue;
          methodValue=resolveId(context,id);
        }
 else {
          final FlagToString[] flagsMapping=property.flagMapping();
          if (flagsMapping.length > 0) {
            final int intValue=(Integer)methodValue;
            final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
            exportUnrolledFlags(out,flagsMapping,intValue,valuePrefix);
          }
          final IntToString[] mapping=property.mapping();
          if (mapping.length > 0) {
            final int intValue=(Integer)methodValue;
            boolean mapped=false;
            int mappingCount=mapping.length;
            for (int j=0; j < mappingCount; j++) {
              final IntToString mapper=mapping[j];
              if (mapper.from() == intValue) {
                methodValue=mapper.to();
                mapped=true;
                break;
              }
            }
            if (!mapped) {
              methodValue=intValue;
            }
          }
        }
      }
 else       if (returnType == int[].class) {
        final int[] array=(int[])methodValue;
        final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
        final String suffix=""String_Node_Str"";
        exportUnrolledArray(context,out,property,array,valuePrefix,suffix);
        return;
      }
 else       if (!returnType.isPrimitive()) {
        if (property.deepExport()) {
          dumpViewProperties(context,methodValue,out,prefix + property.prefix());
          continue;
        }
      }
      writeEntry(out,categoryPrefix + prefix,method.getName(),""String_Node_Str"",methodValue);
    }
 catch (    IllegalAccessException e) {
    }
catch (    InvocationTargetException e) {
    }
  }
}","private static void exportMethods(Context context,Object view,BufferedWriter out,Class<?> klass,String prefix) throws IOException {
  final Method[] methods=getExportedPropertyMethods(klass);
  int count=methods.length;
  for (int i=0; i < count; i++) {
    final Method method=methods[i];
    try {
      Object methodValue=callMethodOnAppropriateTheadBlocking(method,view);
      final Class<?> returnType=method.getReturnType();
      final ExportedProperty property=sAnnotations.get(method);
      String categoryPrefix=property.category().length() != 0 ? property.category() + ""String_Node_Str"" : ""String_Node_Str"";
      if (returnType == int.class) {
        if (property.resolveId() && context != null) {
          final int id=(Integer)methodValue;
          methodValue=resolveId(context,id);
        }
 else {
          final FlagToString[] flagsMapping=property.flagMapping();
          if (flagsMapping.length > 0) {
            final int intValue=(Integer)methodValue;
            final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
            exportUnrolledFlags(out,flagsMapping,intValue,valuePrefix);
          }
          final IntToString[] mapping=property.mapping();
          if (mapping.length > 0) {
            final int intValue=(Integer)methodValue;
            boolean mapped=false;
            int mappingCount=mapping.length;
            for (int j=0; j < mappingCount; j++) {
              final IntToString mapper=mapping[j];
              if (mapper.from() == intValue) {
                methodValue=mapper.to();
                mapped=true;
                break;
              }
            }
            if (!mapped) {
              methodValue=intValue;
            }
          }
        }
      }
 else       if (returnType == int[].class) {
        final int[] array=(int[])methodValue;
        final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
        final String suffix=""String_Node_Str"";
        exportUnrolledArray(context,out,property,array,valuePrefix,suffix);
        return;
      }
 else       if (!returnType.isPrimitive()) {
        if (property.deepExport()) {
          dumpViewProperties(context,methodValue,out,prefix + property.prefix());
          continue;
        }
      }
      writeEntry(out,categoryPrefix + prefix,method.getName(),""String_Node_Str"",methodValue);
    }
 catch (    IllegalAccessException e) {
    }
catch (    InvocationTargetException e) {
    }
catch (    TimeoutException e) {
    }
  }
}"
2009,"private static void exportMethods(Context context,Object view,BufferedWriter out,Class<?> klass,String prefix) throws IOException {
  final Method[] methods=getExportedPropertyMethods(klass);
  int count=methods.length;
  for (int i=0; i < count; i++) {
    final Method method=methods[i];
    try {
      Object methodValue=method.invoke(view,(Object[])null);
      final Class<?> returnType=method.getReturnType();
      final ExportedProperty property=sAnnotations.get(method);
      String categoryPrefix=property.category().length() != 0 ? property.category() + ""String_Node_Str"" : ""String_Node_Str"";
      if (returnType == int.class) {
        if (property.resolveId() && context != null) {
          final int id=(Integer)methodValue;
          methodValue=resolveId(context,id);
        }
 else {
          final FlagToString[] flagsMapping=property.flagMapping();
          if (flagsMapping.length > 0) {
            final int intValue=(Integer)methodValue;
            final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
            exportUnrolledFlags(out,flagsMapping,intValue,valuePrefix);
          }
          final IntToString[] mapping=property.mapping();
          if (mapping.length > 0) {
            final int intValue=(Integer)methodValue;
            boolean mapped=false;
            int mappingCount=mapping.length;
            for (int j=0; j < mappingCount; j++) {
              final IntToString mapper=mapping[j];
              if (mapper.from() == intValue) {
                methodValue=mapper.to();
                mapped=true;
                break;
              }
            }
            if (!mapped) {
              methodValue=intValue;
            }
          }
        }
      }
 else       if (returnType == int[].class) {
        final int[] array=(int[])methodValue;
        final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
        final String suffix=""String_Node_Str"";
        exportUnrolledArray(context,out,property,array,valuePrefix,suffix);
        return;
      }
 else       if (!returnType.isPrimitive()) {
        if (property.deepExport()) {
          dumpViewProperties(context,methodValue,out,prefix + property.prefix());
          continue;
        }
      }
      writeEntry(out,categoryPrefix + prefix,method.getName(),""String_Node_Str"",methodValue);
    }
 catch (    IllegalAccessException e) {
    }
catch (    InvocationTargetException e) {
    }
  }
}","private static void exportMethods(Context context,Object view,BufferedWriter out,Class<?> klass,String prefix) throws IOException {
  final Method[] methods=getExportedPropertyMethods(klass);
  int count=methods.length;
  for (int i=0; i < count; i++) {
    final Method method=methods[i];
    try {
      Object methodValue=callMethodOnAppropriateTheadBlocking(method,view);
      final Class<?> returnType=method.getReturnType();
      final ExportedProperty property=sAnnotations.get(method);
      String categoryPrefix=property.category().length() != 0 ? property.category() + ""String_Node_Str"" : ""String_Node_Str"";
      if (returnType == int.class) {
        if (property.resolveId() && context != null) {
          final int id=(Integer)methodValue;
          methodValue=resolveId(context,id);
        }
 else {
          final FlagToString[] flagsMapping=property.flagMapping();
          if (flagsMapping.length > 0) {
            final int intValue=(Integer)methodValue;
            final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
            exportUnrolledFlags(out,flagsMapping,intValue,valuePrefix);
          }
          final IntToString[] mapping=property.mapping();
          if (mapping.length > 0) {
            final int intValue=(Integer)methodValue;
            boolean mapped=false;
            int mappingCount=mapping.length;
            for (int j=0; j < mappingCount; j++) {
              final IntToString mapper=mapping[j];
              if (mapper.from() == intValue) {
                methodValue=mapper.to();
                mapped=true;
                break;
              }
            }
            if (!mapped) {
              methodValue=intValue;
            }
          }
        }
      }
 else       if (returnType == int[].class) {
        final int[] array=(int[])methodValue;
        final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
        final String suffix=""String_Node_Str"";
        exportUnrolledArray(context,out,property,array,valuePrefix,suffix);
        return;
      }
 else       if (!returnType.isPrimitive()) {
        if (property.deepExport()) {
          dumpViewProperties(context,methodValue,out,prefix + property.prefix());
          continue;
        }
      }
      writeEntry(out,categoryPrefix + prefix,method.getName(),""String_Node_Str"",methodValue);
    }
 catch (    IllegalAccessException e) {
    }
catch (    InvocationTargetException e) {
    }
catch (    TimeoutException e) {
    }
  }
}"
2010,"@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf){
  mHaveFrame=true;
  final int type=mAttrs.type;
  if (mAppToken != null) {
    mContainingFrame.set(getStackBounds());
  }
 else {
    mContainingFrame.set(pf);
  }
  mDisplayFrame.set(df);
  final int pw=mContainingFrame.width();
  final int ph=mContainingFrame.height();
  int w, h;
  if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0) {
    if (mAttrs.width < 0) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mAttrs.width * mGlobalScale + .5f);
    }
 else {
      w=mAttrs.width;
    }
    if (mAttrs.height < 0) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mAttrs.height * mGlobalScale + .5f);
    }
 else {
      h=mAttrs.height;
    }
  }
 else {
    if (mAttrs.width == WindowManager.LayoutParams.MATCH_PARENT) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mRequestedWidth * mGlobalScale + .5f);
    }
 else {
      w=mRequestedWidth;
    }
    if (mAttrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mRequestedHeight * mGlobalScale + .5f);
    }
 else {
      h=mRequestedHeight;
    }
  }
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  mOverscanFrame.set(of);
  mContentFrame.set(cf);
  mVisibleFrame.set(vf);
  final int fw=mFrame.width();
  final int fh=mFrame.height();
  float x, y;
  if (mEnforceSizeCompat) {
    x=mAttrs.x * mGlobalScale;
    y=mAttrs.y * mGlobalScale;
  }
 else {
    x=mAttrs.x;
    y=mAttrs.y;
  }
  Gravity.apply(mAttrs.gravity,w,h,mContainingFrame,(int)(x + mAttrs.horizontalMargin * pw),(int)(y + mAttrs.verticalMargin * ph),mFrame);
  Gravity.applyDisplay(mAttrs.gravity,df,mFrame);
  mContentFrame.set(Math.max(mContentFrame.left,mFrame.left),Math.max(mContentFrame.top,mFrame.top),Math.min(mContentFrame.right,mFrame.right),Math.min(mContentFrame.bottom,mFrame.bottom));
  mVisibleFrame.set(Math.max(mVisibleFrame.left,mFrame.left),Math.max(mVisibleFrame.top,mFrame.top),Math.min(mVisibleFrame.right,mFrame.right),Math.min(mVisibleFrame.bottom,mFrame.bottom));
  mOverscanInsets.set(mOverscanFrame.left - mFrame.left,mOverscanFrame.top - mFrame.top,mFrame.right - mOverscanFrame.right,mFrame.bottom - mOverscanFrame.bottom);
  mContentInsets.set(mContentFrame.left - mFrame.left,mContentFrame.top - mFrame.top,mFrame.right - mContentFrame.right,mFrame.bottom - mContentFrame.bottom);
  mVisibleInsets.set(mVisibleFrame.left - mFrame.left,mVisibleFrame.top - mFrame.top,mFrame.right - mVisibleFrame.right,mFrame.bottom - mVisibleFrame.bottom);
  mCompatFrame.set(mFrame);
  if (mEnforceSizeCompat) {
    mOverscanInsets.scale(mInvGlobalScale);
    mContentInsets.scale(mInvGlobalScale);
    mVisibleInsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != mFrame.width() || fh != mFrame.height())) {
    final DisplayInfo displayInfo=mDisplayContent.getDisplayInfo();
    mService.updateWallpaperOffsetLocked(this,displayInfo.appWidth,displayInfo.appHeight,false);
  }
  if (WindowManagerService.localLOGV) {
    Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ mContentInsets.toShortString()+ ""String_Node_Str""+ mVisibleInsets.toShortString());
  }
}","@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf){
  mHaveFrame=true;
  final int type=mAttrs.type;
  if (mAppToken != null) {
    mContainingFrame.set(getStackBounds());
  }
 else {
    mContainingFrame.set(pf);
  }
  mDisplayFrame.set(df);
  final int pw=mContainingFrame.width();
  final int ph=mContainingFrame.height();
  int w, h;
  if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0) {
    if (mAttrs.width < 0) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mAttrs.width * mGlobalScale + .5f);
    }
 else {
      w=mAttrs.width;
    }
    if (mAttrs.height < 0) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mAttrs.height * mGlobalScale + .5f);
    }
 else {
      h=mAttrs.height;
    }
  }
 else {
    if (mAttrs.width == WindowManager.LayoutParams.MATCH_PARENT) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mRequestedWidth * mGlobalScale + .5f);
    }
 else {
      w=mRequestedWidth;
    }
    if (mAttrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mRequestedHeight * mGlobalScale + .5f);
    }
 else {
      h=mRequestedHeight;
    }
  }
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  mOverscanFrame.set(of);
  mContentFrame.set(cf);
  mVisibleFrame.set(vf);
  final int fw=mFrame.width();
  final int fh=mFrame.height();
  float x, y;
  if (mEnforceSizeCompat) {
    x=mAttrs.x * mGlobalScale;
    y=mAttrs.y * mGlobalScale;
  }
 else {
    x=mAttrs.x;
    y=mAttrs.y;
  }
  Gravity.apply(mAttrs.gravity,w,h,mContainingFrame,(int)(x + mAttrs.horizontalMargin * pw),(int)(y + mAttrs.verticalMargin * ph),mFrame);
  Gravity.applyDisplay(mAttrs.gravity,df,mFrame);
  mContentFrame.set(Math.max(mContentFrame.left,mFrame.left),Math.max(mContentFrame.top,mFrame.top),Math.min(mContentFrame.right,mFrame.right),Math.min(mContentFrame.bottom,mFrame.bottom));
  mVisibleFrame.set(Math.max(mVisibleFrame.left,mFrame.left),Math.max(mVisibleFrame.top,mFrame.top),Math.min(mVisibleFrame.right,mFrame.right),Math.min(mVisibleFrame.bottom,mFrame.bottom));
  mOverscanInsets.set(Math.max(mOverscanFrame.left - mFrame.left,0),Math.max(mOverscanFrame.top - mFrame.top,0),Math.max(mFrame.right - mOverscanFrame.right,0),Math.max(mFrame.bottom - mOverscanFrame.bottom,0));
  mContentInsets.set(mContentFrame.left - mFrame.left,mContentFrame.top - mFrame.top,mFrame.right - mContentFrame.right,mFrame.bottom - mContentFrame.bottom);
  mVisibleInsets.set(mVisibleFrame.left - mFrame.left,mVisibleFrame.top - mFrame.top,mFrame.right - mVisibleFrame.right,mFrame.bottom - mVisibleFrame.bottom);
  mCompatFrame.set(mFrame);
  if (mEnforceSizeCompat) {
    mOverscanInsets.scale(mInvGlobalScale);
    mContentInsets.scale(mInvGlobalScale);
    mVisibleInsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != mFrame.width() || fh != mFrame.height())) {
    final DisplayInfo displayInfo=mDisplayContent.getDisplayInfo();
    mService.updateWallpaperOffsetLocked(this,displayInfo.appWidth,displayInfo.appHeight,false);
  }
  if (WindowManagerService.localLOGV) {
    Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ mContentInsets.toShortString()+ ""String_Node_Str""+ mVisibleInsets.toShortString());
  }
}"
2011,"public AnimatedRotateState(AnimatedRotateState source,AnimatedRotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFramesCount=source.mFramesCount;
    mFrameDuration=source.mFrameDuration;
    mCanConstantState=mCheckedConstantState=true;
  }
}","public AnimatedRotateState(AnimatedRotateState source,AnimatedRotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(source.mDrawable.getLayoutDirection());
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFramesCount=source.mFramesCount;
    mFrameDuration=source.mFrameDuration;
    mCanConstantState=mCheckedConstantState=true;
  }
}"
2012,"ClipState(ClipState orig,ClipDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mOrientation=orig.mOrientation;
    mGravity=orig.mGravity;
    mCheckedConstantState=mCanConstantState=true;
  }
}","ClipState(ClipState orig,ClipDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(orig.mDrawable.getLayoutDirection());
    mOrientation=orig.mOrientation;
    mGravity=orig.mGravity;
    mCheckedConstantState=mCanConstantState=true;
  }
}"
2013,"DrawableContainerState(DrawableContainerState orig,DrawableContainer owner,Resources res){
  mOwner=owner;
  if (orig != null) {
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    final Drawable[] origDr=orig.mDrawables;
    mDrawables=new Drawable[origDr.length];
    mNumChildren=orig.mNumChildren;
    final int N=mNumChildren;
    for (int i=0; i < N; i++) {
      if (res != null) {
        mDrawables[i]=origDr[i].getConstantState().newDrawable(res);
      }
 else {
        mDrawables[i]=origDr[i].getConstantState().newDrawable();
      }
      mDrawables[i].setCallback(owner);
    }
    mCheckedConstantState=mCanConstantState=true;
    mVariablePadding=orig.mVariablePadding;
    if (orig.mConstantPadding != null) {
      mConstantPadding=new Rect(orig.mConstantPadding);
    }
    mConstantSize=orig.mConstantSize;
    mComputedConstantSize=orig.mComputedConstantSize;
    mConstantWidth=orig.mConstantWidth;
    mConstantHeight=orig.mConstantHeight;
    mConstantMinimumWidth=orig.mConstantMinimumWidth;
    mConstantMinimumHeight=orig.mConstantMinimumHeight;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mDither=orig.mDither;
    mEnterFadeDuration=orig.mEnterFadeDuration;
    mExitFadeDuration=orig.mExitFadeDuration;
  }
 else {
    mDrawables=new Drawable[10];
    mNumChildren=0;
    mCheckedConstantState=mCanConstantState=false;
  }
}","DrawableContainerState(DrawableContainerState orig,DrawableContainer owner,Resources res){
  mOwner=owner;
  if (orig != null) {
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    final Drawable[] origDr=orig.mDrawables;
    mDrawables=new Drawable[origDr.length];
    mNumChildren=orig.mNumChildren;
    final int N=mNumChildren;
    for (int i=0; i < N; i++) {
      if (res != null) {
        mDrawables[i]=origDr[i].getConstantState().newDrawable(res);
      }
 else {
        mDrawables[i]=origDr[i].getConstantState().newDrawable();
      }
      mDrawables[i].setCallback(owner);
      mDrawables[i].setLayoutDirection(origDr[i].getLayoutDirection());
    }
    mCheckedConstantState=mCanConstantState=true;
    mVariablePadding=orig.mVariablePadding;
    if (orig.mConstantPadding != null) {
      mConstantPadding=new Rect(orig.mConstantPadding);
    }
    mConstantSize=orig.mConstantSize;
    mComputedConstantSize=orig.mComputedConstantSize;
    mConstantWidth=orig.mConstantWidth;
    mConstantHeight=orig.mConstantHeight;
    mConstantMinimumWidth=orig.mConstantMinimumWidth;
    mConstantMinimumHeight=orig.mConstantMinimumHeight;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mDither=orig.mDither;
    mEnterFadeDuration=orig.mEnterFadeDuration;
    mExitFadeDuration=orig.mExitFadeDuration;
  }
 else {
    mDrawables=new Drawable[10];
    mNumChildren=0;
    mCheckedConstantState=mCanConstantState=false;
  }
}"
2014,"public boolean selectDrawable(int idx){
  if (idx == mCurIndex) {
    return false;
  }
  final long now=SystemClock.uptimeMillis();
  if (DEBUG)   android.util.Log.i(TAG,toString() + ""String_Node_Str"" + mCurIndex+ ""String_Node_Str""+ idx+ ""String_Node_Str""+ mDrawableContainerState.mExitFadeDuration+ ""String_Node_Str""+ mDrawableContainerState.mEnterFadeDuration);
  if (mDrawableContainerState.mExitFadeDuration > 0) {
    if (mLastDrawable != null) {
      mLastDrawable.setVisible(false,false);
    }
    if (mCurrDrawable != null) {
      mLastDrawable=mCurrDrawable;
      mExitAnimationEnd=now + mDrawableContainerState.mExitFadeDuration;
    }
 else {
      mLastDrawable=null;
      mExitAnimationEnd=0;
    }
  }
 else   if (mCurrDrawable != null) {
    mCurrDrawable.setVisible(false,false);
  }
  if (idx >= 0 && idx < mDrawableContainerState.mNumChildren) {
    Drawable d=mDrawableContainerState.mDrawables[idx];
    mCurrDrawable=d;
    mCurIndex=idx;
    if (d != null) {
      d.mutate();
      if (mDrawableContainerState.mEnterFadeDuration > 0) {
        mEnterAnimationEnd=now + mDrawableContainerState.mEnterFadeDuration;
      }
 else {
        d.setAlpha(mAlpha);
      }
      d.setVisible(isVisible(),true);
      d.setDither(mDrawableContainerState.mDither);
      d.setColorFilter(mColorFilter);
      d.setState(getState());
      d.setLevel(getLevel());
      d.setBounds(getBounds());
    }
  }
 else {
    mCurrDrawable=null;
    mCurIndex=-1;
  }
  if (mEnterAnimationEnd != 0 || mExitAnimationEnd != 0) {
    if (mAnimationRunnable == null) {
      mAnimationRunnable=new Runnable(){
        @Override public void run(){
          animate(true);
          invalidateSelf();
        }
      }
;
    }
 else {
      unscheduleSelf(mAnimationRunnable);
    }
    animate(true);
  }
  invalidateSelf();
  return true;
}","public boolean selectDrawable(int idx){
  if (idx == mCurIndex) {
    return false;
  }
  final long now=SystemClock.uptimeMillis();
  if (DEBUG)   android.util.Log.i(TAG,toString() + ""String_Node_Str"" + mCurIndex+ ""String_Node_Str""+ idx+ ""String_Node_Str""+ mDrawableContainerState.mExitFadeDuration+ ""String_Node_Str""+ mDrawableContainerState.mEnterFadeDuration);
  if (mDrawableContainerState.mExitFadeDuration > 0) {
    if (mLastDrawable != null) {
      mLastDrawable.setVisible(false,false);
    }
    if (mCurrDrawable != null) {
      mLastDrawable=mCurrDrawable;
      mExitAnimationEnd=now + mDrawableContainerState.mExitFadeDuration;
    }
 else {
      mLastDrawable=null;
      mExitAnimationEnd=0;
    }
  }
 else   if (mCurrDrawable != null) {
    mCurrDrawable.setVisible(false,false);
  }
  if (idx >= 0 && idx < mDrawableContainerState.mNumChildren) {
    Drawable d=mDrawableContainerState.mDrawables[idx];
    mCurrDrawable=d;
    mCurIndex=idx;
    if (d != null) {
      d.mutate();
      if (mDrawableContainerState.mEnterFadeDuration > 0) {
        mEnterAnimationEnd=now + mDrawableContainerState.mEnterFadeDuration;
      }
 else {
        d.setAlpha(mAlpha);
      }
      d.setVisible(isVisible(),true);
      d.setDither(mDrawableContainerState.mDither);
      d.setColorFilter(mColorFilter);
      d.setState(getState());
      d.setLevel(getLevel());
      d.setBounds(getBounds());
      d.setLayoutDirection(getLayoutDirection());
    }
  }
 else {
    mCurrDrawable=null;
    mCurIndex=-1;
  }
  if (mEnterAnimationEnd != 0 || mExitAnimationEnd != 0) {
    if (mAnimationRunnable == null) {
      mAnimationRunnable=new Runnable(){
        @Override public void run(){
          animate(true);
          invalidateSelf();
        }
      }
;
    }
 else {
      unscheduleSelf(mAnimationRunnable);
    }
    animate(true);
  }
  invalidateSelf();
  return true;
}"
2015,"InsetState(InsetState orig,InsetDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mInsetLeft=orig.mInsetLeft;
    mInsetTop=orig.mInsetTop;
    mInsetRight=orig.mInsetRight;
    mInsetBottom=orig.mInsetBottom;
    mCheckedConstantState=mCanConstantState=true;
  }
}","InsetState(InsetState orig,InsetDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(orig.mDrawable.getLayoutDirection());
    mInsetLeft=orig.mInsetLeft;
    mInsetTop=orig.mInsetTop;
    mInsetRight=orig.mInsetRight;
    mInsetBottom=orig.mInsetBottom;
    mCheckedConstantState=mCanConstantState=true;
  }
}"
2016,"/** 
 * @hide 
 */
@Override public void setLayoutDirection(int layoutDirection){
  if (getLayoutDirection() != layoutDirection) {
    final ChildDrawable[] array=mLayerState.mChildren;
    final int N=mLayerState.mNum;
    for (int i=0; i < N; i++) {
      array[i].mDrawable.setLayoutDirection(layoutDirection);
    }
  }
  super.setLayoutDirection(layoutDirection);
}","/** 
 * @hide 
 */
@Override public void setLayoutDirection(int layoutDirection){
  final ChildDrawable[] array=mLayerState.mChildren;
  final int N=mLayerState.mNum;
  for (int i=0; i < N; i++) {
    array[i].mDrawable.setLayoutDirection(layoutDirection);
  }
  super.setLayoutDirection(layoutDirection);
}"
2017,"LayerState(LayerState orig,LayerDrawable owner,Resources res){
  if (orig != null) {
    final ChildDrawable[] origChildDrawable=orig.mChildren;
    final int N=orig.mNum;
    mNum=N;
    mChildren=new ChildDrawable[N];
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    for (int i=0; i < N; i++) {
      final ChildDrawable r=mChildren[i]=new ChildDrawable();
      final ChildDrawable or=origChildDrawable[i];
      if (res != null) {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable(res);
      }
 else {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable();
      }
      r.mDrawable.setCallback(owner);
      r.mInsetL=or.mInsetL;
      r.mInsetT=or.mInsetT;
      r.mInsetR=or.mInsetR;
      r.mInsetB=or.mInsetB;
      r.mId=or.mId;
    }
    mHaveOpacity=orig.mHaveOpacity;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mCheckedConstantState=mCanConstantState=true;
  }
 else {
    mNum=0;
    mChildren=null;
  }
}","LayerState(LayerState orig,LayerDrawable owner,Resources res){
  if (orig != null) {
    final ChildDrawable[] origChildDrawable=orig.mChildren;
    final int N=orig.mNum;
    mNum=N;
    mChildren=new ChildDrawable[N];
    mChangingConfigurations=orig.mChangingConfigurations;
    mChildrenChangingConfigurations=orig.mChildrenChangingConfigurations;
    for (int i=0; i < N; i++) {
      final ChildDrawable r=mChildren[i]=new ChildDrawable();
      final ChildDrawable or=origChildDrawable[i];
      if (res != null) {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable(res);
      }
 else {
        r.mDrawable=or.mDrawable.getConstantState().newDrawable();
      }
      r.mDrawable.setCallback(owner);
      r.mDrawable.setLayoutDirection(or.mDrawable.getLayoutDirection());
      r.mInsetL=or.mInsetL;
      r.mInsetT=or.mInsetT;
      r.mInsetR=or.mInsetR;
      r.mInsetB=or.mInsetB;
      r.mId=or.mId;
    }
    mHaveOpacity=orig.mHaveOpacity;
    mOpacity=orig.mOpacity;
    mHaveStateful=orig.mHaveStateful;
    mStateful=orig.mStateful;
    mCheckedConstantState=mCanConstantState=true;
  }
 else {
    mNum=0;
    mChildren=null;
  }
}"
2018,"public RotateState(RotateState source,RotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFromDegrees=mCurrentDegrees=source.mFromDegrees;
    mToDegrees=source.mToDegrees;
    mCanConstantState=mCheckedConstantState=true;
  }
}","public RotateState(RotateState source,RotateDrawable owner,Resources res){
  if (source != null) {
    if (res != null) {
      mDrawable=source.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=source.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(source.mDrawable.getLayoutDirection());
    mPivotXRel=source.mPivotXRel;
    mPivotX=source.mPivotX;
    mPivotYRel=source.mPivotYRel;
    mPivotY=source.mPivotY;
    mFromDegrees=mCurrentDegrees=source.mFromDegrees;
    mToDegrees=source.mToDegrees;
    mCanConstantState=mCheckedConstantState=true;
  }
}"
2019,"ScaleState(ScaleState orig,ScaleDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mScaleWidth=orig.mScaleWidth;
    mScaleHeight=orig.mScaleHeight;
    mGravity=orig.mGravity;
    mUseIntrinsicSizeAsMin=orig.mUseIntrinsicSizeAsMin;
    mCheckedConstantState=mCanConstantState=true;
  }
}","ScaleState(ScaleState orig,ScaleDrawable owner,Resources res){
  if (orig != null) {
    if (res != null) {
      mDrawable=orig.mDrawable.getConstantState().newDrawable(res);
    }
 else {
      mDrawable=orig.mDrawable.getConstantState().newDrawable();
    }
    mDrawable.setCallback(owner);
    mDrawable.setLayoutDirection(orig.mDrawable.getLayoutDirection());
    mScaleWidth=orig.mScaleWidth;
    mScaleHeight=orig.mScaleHeight;
    mGravity=orig.mGravity;
    mUseIntrinsicSizeAsMin=orig.mUseIntrinsicSizeAsMin;
    mCheckedConstantState=mCanConstantState=true;
  }
}"
2020,"@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf){
  mHaveFrame=true;
  final int type=mAttrs.type;
  if (mAppToken != null) {
    mContainingFrame.set(getStackBounds());
  }
 else {
    mContainingFrame.set(pf);
  }
  mDisplayFrame.set(df);
  final int pw=mContainingFrame.width();
  final int ph=mContainingFrame.height();
  int w, h;
  if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0) {
    if (mAttrs.width < 0) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mAttrs.width * mGlobalScale + .5f);
    }
 else {
      w=mAttrs.width;
    }
    if (mAttrs.height < 0) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mAttrs.height * mGlobalScale + .5f);
    }
 else {
      h=mAttrs.height;
    }
  }
 else {
    if (mAttrs.width == WindowManager.LayoutParams.MATCH_PARENT) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mRequestedWidth * mGlobalScale + .5f);
    }
 else {
      w=mRequestedWidth;
    }
    if (mAttrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mRequestedHeight * mGlobalScale + .5f);
    }
 else {
      h=mRequestedHeight;
    }
  }
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  mOverscanFrame.set(of);
  mContentFrame.set(cf);
  mVisibleFrame.set(vf);
  final int fw=mFrame.width();
  final int fh=mFrame.height();
  float x, y;
  if (mEnforceSizeCompat) {
    x=mAttrs.x * mGlobalScale;
    y=mAttrs.y * mGlobalScale;
  }
 else {
    x=mAttrs.x;
    y=mAttrs.y;
  }
  Gravity.apply(mAttrs.gravity,w,h,mContainingFrame,(int)(x + mAttrs.horizontalMargin * pw),(int)(y + mAttrs.verticalMargin * ph),mFrame);
  Gravity.applyDisplay(mAttrs.gravity,df,mFrame);
  mContentFrame.set(Math.max(mContentFrame.left,mFrame.left),Math.max(mContentFrame.top,mFrame.top),Math.min(mContentFrame.right,mFrame.right),Math.min(mContentFrame.bottom,mFrame.bottom));
  mVisibleFrame.set(Math.max(mVisibleFrame.left,mFrame.left),Math.max(mVisibleFrame.top,mFrame.top),Math.min(mVisibleFrame.right,mFrame.right),Math.min(mVisibleFrame.bottom,mFrame.bottom));
  mOverscanInsets.set(mOverscanFrame.left - mFrame.left,mOverscanFrame.top - mFrame.top,mFrame.right - mOverscanFrame.right,mFrame.bottom - mOverscanFrame.bottom);
  mContentInsets.set(mContentFrame.left - mFrame.left,mContentFrame.top - mFrame.top,mFrame.right - mContentFrame.right,mFrame.bottom - mContentFrame.bottom);
  mVisibleInsets.set(mVisibleFrame.left - mFrame.left,mVisibleFrame.top - mFrame.top,mFrame.right - mVisibleFrame.right,mFrame.bottom - mVisibleFrame.bottom);
  mCompatFrame.set(mFrame);
  if (mEnforceSizeCompat) {
    mOverscanInsets.scale(mInvGlobalScale);
    mContentInsets.scale(mInvGlobalScale);
    mVisibleInsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != mFrame.width() || fh != mFrame.height())) {
    final DisplayInfo displayInfo=mDisplayContent.getDisplayInfo();
    mService.updateWallpaperOffsetLocked(this,displayInfo.appWidth,displayInfo.appHeight,false);
  }
  if (WindowManagerService.localLOGV) {
    Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ mContentInsets.toShortString()+ ""String_Node_Str""+ mVisibleInsets.toShortString());
  }
}","@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf){
  mHaveFrame=true;
  final int type=mAttrs.type;
  if (mAppToken != null) {
    mContainingFrame.set(getStackBounds());
  }
 else {
    mContainingFrame.set(pf);
  }
  mDisplayFrame.set(df);
  final int pw=mContainingFrame.width();
  final int ph=mContainingFrame.height();
  int w, h;
  if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0) {
    if (mAttrs.width < 0) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mAttrs.width * mGlobalScale + .5f);
    }
 else {
      w=mAttrs.width;
    }
    if (mAttrs.height < 0) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mAttrs.height * mGlobalScale + .5f);
    }
 else {
      h=mAttrs.height;
    }
  }
 else {
    if (mAttrs.width == WindowManager.LayoutParams.MATCH_PARENT) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mRequestedWidth * mGlobalScale + .5f);
    }
 else {
      w=mRequestedWidth;
    }
    if (mAttrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mRequestedHeight * mGlobalScale + .5f);
    }
 else {
      h=mRequestedHeight;
    }
  }
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  mOverscanFrame.set(of);
  mContentFrame.set(cf);
  mVisibleFrame.set(vf);
  final int fw=mFrame.width();
  final int fh=mFrame.height();
  float x, y;
  if (mEnforceSizeCompat) {
    x=mAttrs.x * mGlobalScale;
    y=mAttrs.y * mGlobalScale;
  }
 else {
    x=mAttrs.x;
    y=mAttrs.y;
  }
  Gravity.apply(mAttrs.gravity,w,h,mContainingFrame,(int)(x + mAttrs.horizontalMargin * pw),(int)(y + mAttrs.verticalMargin * ph),mFrame);
  Gravity.applyDisplay(mAttrs.gravity,df,mFrame);
  mContentFrame.set(Math.max(mContentFrame.left,mFrame.left),Math.max(mContentFrame.top,mFrame.top),Math.min(mContentFrame.right,mFrame.right),Math.min(mContentFrame.bottom,mFrame.bottom));
  mVisibleFrame.set(Math.max(mVisibleFrame.left,mFrame.left),Math.max(mVisibleFrame.top,mFrame.top),Math.min(mVisibleFrame.right,mFrame.right),Math.min(mVisibleFrame.bottom,mFrame.bottom));
  mOverscanInsets.set(Math.max(mOverscanFrame.left - mFrame.left,0),Math.max(mOverscanFrame.top - mFrame.top,0),Math.max(mFrame.right - mOverscanFrame.right,0),Math.max(mFrame.bottom - mOverscanFrame.bottom,0));
  mContentInsets.set(mContentFrame.left - mFrame.left,mContentFrame.top - mFrame.top,mFrame.right - mContentFrame.right,mFrame.bottom - mContentFrame.bottom);
  mVisibleInsets.set(mVisibleFrame.left - mFrame.left,mVisibleFrame.top - mFrame.top,mFrame.right - mVisibleFrame.right,mFrame.bottom - mVisibleFrame.bottom);
  mCompatFrame.set(mFrame);
  if (mEnforceSizeCompat) {
    mOverscanInsets.scale(mInvGlobalScale);
    mContentInsets.scale(mInvGlobalScale);
    mVisibleInsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != mFrame.width() || fh != mFrame.height())) {
    final DisplayInfo displayInfo=mDisplayContent.getDisplayInfo();
    mService.updateWallpaperOffsetLocked(this,displayInfo.appWidth,displayInfo.appHeight,false);
  }
  if (WindowManagerService.localLOGV) {
    Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ mContentInsets.toShortString()+ ""String_Node_Str""+ mVisibleInsets.toShortString());
  }
}"
2021,"private void addSystemTiles(ViewGroup parent,LayoutInflater inflater){
  final QuickSettingsBasicTile wifiTile=new QuickSettingsBasicTile(mContext);
  wifiTile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
    }
  }
);
  if (LONG_PRESS_TOGGLES) {
    wifiTile.setOnLongClickListener(new View.OnLongClickListener(){
      @Override public boolean onLongClick(      View v){
        final boolean enable=(mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
        new AsyncTask<Void,Void,Void>(){
          @Override protected Void doInBackground(          Void... args){
            final int wifiApState=mWifiManager.getWifiApState();
            if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
              mWifiManager.setWifiApEnabled(null,false);
            }
            mWifiManager.setWifiEnabled(enable);
            return null;
          }
        }
.execute();
        wifiTile.setPressed(false);
        return true;
      }
    }
);
  }
  mModel.addWifiTile(wifiTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      WifiState wifiState=(WifiState)state;
      wifiTile.setImageResource(wifiState.iconId);
      wifiTile.setText(wifiState.label);
      wifiTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi,wifiState.signalContentDescription,(wifiState.connected) ? wifiState.label : ""String_Node_Str""));
    }
  }
);
  parent.addView(wifiTile);
  if (mModel.deviceHasMobileData()) {
    QuickSettingsTileView rssiTile=(QuickSettingsTileView)inflater.inflate(R.layout.quick_settings_tile,parent,false);
    rssiTile.setContent(R.layout.quick_settings_tile_rssi,inflater);
    rssiTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        Intent intent=new Intent();
        intent.setComponent(new ComponentName(""String_Node_Str"",""String_Node_Str""));
        startSettingsActivity(intent);
      }
    }
);
    mModel.addRSSITile(rssiTile,new QuickSettingsModel.RefreshCallback(){
      @Override public void refreshView(      QuickSettingsTileView view,      State state){
        RSSIState rssiState=(RSSIState)state;
        ImageView iv=(ImageView)view.findViewById(R.id.rssi_image);
        ImageView iov=(ImageView)view.findViewById(R.id.rssi_overlay_image);
        TextView tv=(TextView)view.findViewById(R.id.rssi_textview);
        iv.setImageDrawable(null);
        iv.setImageResource(rssiState.signalIconId);
        if (rssiState.dataTypeIconId > 0) {
          iov.setImageResource(rssiState.dataTypeIconId);
        }
 else {
          iov.setImageDrawable(null);
        }
        tv.setText(state.label);
        view.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile,rssiState.signalContentDescription,rssiState.dataContentDescription,state.label));
      }
    }
);
    parent.addView(rssiTile);
  }
  if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
    final QuickSettingsBasicTile rotationLockTile=new QuickSettingsBasicTile(mContext);
    rotationLockTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        boolean locked=RotationPolicy.isRotationLocked(mContext);
        RotationPolicy.setRotationLock(mContext,!locked);
      }
    }
);
    mModel.addRotationLockTile(rotationLockTile,new QuickSettingsModel.BasicRefreshCallback(rotationLockTile));
    parent.addView(rotationLockTile);
  }
  final QuickSettingsBasicTile batteryTile=new QuickSettingsBasicTile(mContext);
  batteryTile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
    }
  }
);
  mModel.addBatteryTile(batteryTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      QuickSettingsModel.BatteryState batteryState=(QuickSettingsModel.BatteryState)state;
      Drawable d=batteryState.pluggedIn ? mChargingBatteryLevels : mBatteryLevels;
      String t;
      if (batteryState.batteryLevel == 100) {
        t=mContext.getString(R.string.quick_settings_battery_charged_label);
      }
 else {
        t=batteryState.pluggedIn ? mContext.getString(R.string.quick_settings_battery_charging_label,batteryState.batteryLevel) : mContext.getString(R.string.status_bar_settings_battery_meter_format,batteryState.batteryLevel);
      }
      d.setLevel(batteryState.batteryLevel);
      batteryTile.setImageDrawable(d);
      batteryTile.setText(t);
      batteryTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery,t));
    }
  }
);
  parent.addView(batteryTile);
  final QuickSettingsBasicTile airplaneTile=new QuickSettingsBasicTile(mContext);
  mModel.addAirplaneModeTile(airplaneTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      airplaneTile.setImageResource(state.iconId);
      String airplaneState=mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
      airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane,airplaneState));
      airplaneTile.setText(state.label);
    }
  }
);
  parent.addView(airplaneTile);
  if (mModel.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
    final QuickSettingsBasicTile bluetoothTile=new QuickSettingsBasicTile(mContext);
    bluetoothTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
      }
    }
);
    if (LONG_PRESS_TOGGLES) {
      bluetoothTile.setOnLongClickListener(new View.OnLongClickListener(){
        @Override public boolean onLongClick(        View v){
          if (mBluetoothAdapter.isEnabled()) {
            mBluetoothAdapter.disable();
          }
 else {
            mBluetoothAdapter.enable();
          }
          bluetoothTile.setPressed(false);
          return true;
        }
      }
);
    }
    mModel.addBluetoothTile(bluetoothTile,new QuickSettingsModel.RefreshCallback(){
      @Override public void refreshView(      QuickSettingsTileView unused,      State state){
        BluetoothState bluetoothState=(BluetoothState)state;
        bluetoothTile.setImageResource(state.iconId);
        bluetoothTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth,bluetoothState.stateContentDescription));
        bluetoothTile.setText(state.label);
      }
    }
);
    parent.addView(bluetoothTile);
  }
}","private void addSystemTiles(ViewGroup parent,LayoutInflater inflater){
  final QuickSettingsBasicTile wifiTile=new QuickSettingsBasicTile(mContext);
  wifiTile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
    }
  }
);
  if (LONG_PRESS_TOGGLES) {
    wifiTile.setOnLongClickListener(new View.OnLongClickListener(){
      @Override public boolean onLongClick(      View v){
        final boolean enable=(mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
        new AsyncTask<Void,Void,Void>(){
          @Override protected Void doInBackground(          Void... args){
            final int wifiApState=mWifiManager.getWifiApState();
            if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
              mWifiManager.setWifiApEnabled(null,false);
            }
            mWifiManager.setWifiEnabled(enable);
            return null;
          }
        }
.execute();
        wifiTile.setPressed(false);
        return true;
      }
    }
);
  }
  mModel.addWifiTile(wifiTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      WifiState wifiState=(WifiState)state;
      wifiTile.setImageResource(wifiState.iconId);
      wifiTile.setText(wifiState.label);
      wifiTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi,wifiState.signalContentDescription,(wifiState.connected) ? wifiState.label : ""String_Node_Str""));
    }
  }
);
  parent.addView(wifiTile);
  if (mModel.deviceHasMobileData()) {
    QuickSettingsTileView rssiTile=(QuickSettingsTileView)inflater.inflate(R.layout.quick_settings_tile,parent,false);
    rssiTile.setContent(R.layout.quick_settings_tile_rssi,inflater);
    rssiTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        Intent intent=new Intent();
        intent.setComponent(new ComponentName(""String_Node_Str"",""String_Node_Str""));
        startSettingsActivity(intent);
      }
    }
);
    mModel.addRSSITile(rssiTile,new QuickSettingsModel.RefreshCallback(){
      @Override public void refreshView(      QuickSettingsTileView view,      State state){
        RSSIState rssiState=(RSSIState)state;
        ImageView iv=(ImageView)view.findViewById(R.id.rssi_image);
        ImageView iov=(ImageView)view.findViewById(R.id.rssi_overlay_image);
        TextView tv=(TextView)view.findViewById(R.id.rssi_textview);
        iv.setImageDrawable(null);
        iv.setImageResource(rssiState.signalIconId);
        if (rssiState.dataTypeIconId > 0) {
          iov.setImageResource(rssiState.dataTypeIconId);
        }
 else {
          iov.setImageDrawable(null);
        }
        tv.setText(state.label);
        view.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile,rssiState.signalContentDescription,rssiState.dataContentDescription,state.label));
      }
    }
);
    parent.addView(rssiTile);
  }
  if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
    final QuickSettingsBasicTile rotationLockTile=new QuickSettingsBasicTile(mContext);
    rotationLockTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        boolean locked=RotationPolicy.isRotationLocked(mContext);
        RotationPolicy.setRotationLock(mContext,!locked);
      }
    }
);
    mModel.addRotationLockTile(rotationLockTile,new QuickSettingsModel.BasicRefreshCallback(rotationLockTile));
    parent.addView(rotationLockTile);
  }
  final QuickSettingsBasicTile batteryTile=new QuickSettingsBasicTile(mContext);
  batteryTile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
    }
  }
);
  mModel.addBatteryTile(batteryTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      QuickSettingsModel.BatteryState batteryState=(QuickSettingsModel.BatteryState)state;
      Drawable d=batteryState.pluggedIn ? mChargingBatteryLevels : mBatteryLevels;
      String t;
      if (batteryState.batteryLevel == 100) {
        t=mContext.getString(R.string.quick_settings_battery_charged_label);
      }
 else {
        t=batteryState.pluggedIn ? mContext.getString(R.string.quick_settings_battery_charging_label,batteryState.batteryLevel) : mContext.getString(R.string.status_bar_settings_battery_meter_format,batteryState.batteryLevel);
      }
      batteryTile.setImageDrawable(d);
      batteryTile.getImageView().setImageLevel(batteryState.batteryLevel);
      batteryTile.setText(t);
      batteryTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery,t));
    }
  }
);
  parent.addView(batteryTile);
  final QuickSettingsBasicTile airplaneTile=new QuickSettingsBasicTile(mContext);
  mModel.addAirplaneModeTile(airplaneTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      airplaneTile.setImageResource(state.iconId);
      String airplaneState=mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
      airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane,airplaneState));
      airplaneTile.setText(state.label);
    }
  }
);
  parent.addView(airplaneTile);
  if (mModel.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
    final QuickSettingsBasicTile bluetoothTile=new QuickSettingsBasicTile(mContext);
    bluetoothTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
      }
    }
);
    if (LONG_PRESS_TOGGLES) {
      bluetoothTile.setOnLongClickListener(new View.OnLongClickListener(){
        @Override public boolean onLongClick(        View v){
          if (mBluetoothAdapter.isEnabled()) {
            mBluetoothAdapter.disable();
          }
 else {
            mBluetoothAdapter.enable();
          }
          bluetoothTile.setPressed(false);
          return true;
        }
      }
);
    }
    mModel.addBluetoothTile(bluetoothTile,new QuickSettingsModel.RefreshCallback(){
      @Override public void refreshView(      QuickSettingsTileView unused,      State state){
        BluetoothState bluetoothState=(BluetoothState)state;
        bluetoothTile.setImageResource(state.iconId);
        bluetoothTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth,bluetoothState.stateContentDescription));
        bluetoothTile.setText(state.label);
      }
    }
);
    parent.addView(bluetoothTile);
  }
}"
2022,"static void updateWifiDisplayStatus(WifiDisplayStatus newStatus){
  final WifiDisplayStatus oldStatus=sStatic.mLastKnownWifiDisplayStatus;
  boolean wantScan=false;
  boolean blockScan=false;
  WifiDisplay[] oldDisplays=oldStatus != null ? oldStatus.getRememberedDisplays() : WifiDisplay.EMPTY_ARRAY;
  WifiDisplay[] newDisplays;
  WifiDisplay[] availableDisplays;
  WifiDisplay activeDisplay;
  if (newStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_ON) {
    newDisplays=newStatus.getRememberedDisplays();
    availableDisplays=newStatus.getAvailableDisplays();
    activeDisplay=newStatus.getActiveDisplay();
  }
 else {
    newDisplays=availableDisplays=WifiDisplay.EMPTY_ARRAY;
    activeDisplay=null;
  }
  for (int i=0; i < newDisplays.length; i++) {
    final WifiDisplay d=newDisplays[i];
    final WifiDisplay oldRemembered=findMatchingDisplay(d,oldDisplays);
    if (oldRemembered == null) {
      addRouteStatic(makeWifiDisplayRoute(d,findMatchingDisplay(d,availableDisplays) != null));
      wantScan=true;
    }
 else {
      final boolean available=findMatchingDisplay(d,availableDisplays) != null;
      final RouteInfo route=findWifiDisplayRoute(d);
      updateWifiDisplayRoute(route,d,available,newStatus);
    }
    if (d.equals(activeDisplay)) {
      final RouteInfo activeRoute=findWifiDisplayRoute(d);
      if (activeRoute != null) {
        selectRouteStatic(activeRoute.getSupportedTypes(),activeRoute);
        blockScan=true;
      }
    }
  }
  for (int i=0; i < oldDisplays.length; i++) {
    final WifiDisplay d=oldDisplays[i];
    final WifiDisplay newDisplay=findMatchingDisplay(d,newDisplays);
    if (newDisplay == null) {
      removeRoute(findWifiDisplayRoute(d));
    }
  }
  if (wantScan && !blockScan) {
    sStatic.mDisplayService.scanWifiDisplays();
  }
  sStatic.mLastKnownWifiDisplayStatus=newStatus;
}","static void updateWifiDisplayStatus(WifiDisplayStatus newStatus){
  final WifiDisplayStatus oldStatus=sStatic.mLastKnownWifiDisplayStatus;
  boolean wantScan=false;
  boolean blockScan=false;
  WifiDisplay[] oldDisplays=oldStatus != null ? oldStatus.getRememberedDisplays() : WifiDisplay.EMPTY_ARRAY;
  WifiDisplay[] newDisplays;
  WifiDisplay[] availableDisplays;
  WifiDisplay activeDisplay;
  if (newStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_ON) {
    newDisplays=newStatus.getRememberedDisplays();
    availableDisplays=newStatus.getAvailableDisplays();
    activeDisplay=newStatus.getActiveDisplay();
  }
 else {
    newDisplays=availableDisplays=WifiDisplay.EMPTY_ARRAY;
    activeDisplay=null;
  }
  for (int i=0; i < newDisplays.length; i++) {
    final WifiDisplay d=newDisplays[i];
    final boolean available=findMatchingDisplay(d,availableDisplays) != null;
    RouteInfo route=findWifiDisplayRoute(d);
    if (route == null) {
      route=makeWifiDisplayRoute(d,available);
      addRouteStatic(route);
      wantScan=true;
    }
 else {
      updateWifiDisplayRoute(route,d,available,newStatus);
    }
    if (d.equals(activeDisplay)) {
      selectRouteStatic(route.getSupportedTypes(),route);
      blockScan=true;
    }
  }
  for (int i=0; i < oldDisplays.length; i++) {
    final WifiDisplay d=oldDisplays[i];
    final WifiDisplay newDisplay=findMatchingDisplay(d,newDisplays);
    if (newDisplay == null) {
      removeRoute(findWifiDisplayRoute(d));
    }
  }
  if (wantScan && !blockScan) {
    sStatic.mDisplayService.scanWifiDisplays();
  }
  sStatic.mLastKnownWifiDisplayStatus=newStatus;
}"
2023,"private void addSystemTiles(ViewGroup parent,LayoutInflater inflater){
  final QuickSettingsBasicTile wifiTile=new QuickSettingsBasicTile(mContext);
  wifiTile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
    }
  }
);
  if (LONG_PRESS_TOGGLES) {
    wifiTile.setOnLongClickListener(new View.OnLongClickListener(){
      @Override public boolean onLongClick(      View v){
        final boolean enable=(mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
        new AsyncTask<Void,Void,Void>(){
          @Override protected Void doInBackground(          Void... args){
            final int wifiApState=mWifiManager.getWifiApState();
            if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
              mWifiManager.setWifiApEnabled(null,false);
            }
            mWifiManager.setWifiEnabled(enable);
            return null;
          }
        }
.execute();
        wifiTile.setPressed(false);
        return true;
      }
    }
);
  }
  mModel.addWifiTile(wifiTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      WifiState wifiState=(WifiState)state;
      wifiTile.setImageResource(wifiState.iconId);
      wifiTile.setText(wifiState.label);
      wifiTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi,wifiState.signalContentDescription,(wifiState.connected) ? wifiState.label : ""String_Node_Str""));
    }
  }
);
  parent.addView(wifiTile);
  if (mModel.deviceHasMobileData()) {
    QuickSettingsTileView rssiTile=(QuickSettingsTileView)inflater.inflate(R.layout.quick_settings_tile,parent,false);
    rssiTile.setContent(R.layout.quick_settings_tile_rssi,inflater);
    rssiTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        Intent intent=new Intent();
        intent.setComponent(new ComponentName(""String_Node_Str"",""String_Node_Str""));
        startSettingsActivity(intent);
      }
    }
);
    mModel.addRSSITile(rssiTile,new QuickSettingsModel.RefreshCallback(){
      @Override public void refreshView(      QuickSettingsTileView view,      State state){
        RSSIState rssiState=(RSSIState)state;
        ImageView iv=(ImageView)view.findViewById(R.id.rssi_image);
        ImageView iov=(ImageView)view.findViewById(R.id.rssi_overlay_image);
        TextView tv=(TextView)view.findViewById(R.id.rssi_textview);
        iv.setImageDrawable(null);
        iv.setImageResource(rssiState.signalIconId);
        if (rssiState.dataTypeIconId > 0) {
          iov.setImageResource(rssiState.dataTypeIconId);
        }
 else {
          iov.setImageDrawable(null);
        }
        tv.setText(state.label);
        view.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile,rssiState.signalContentDescription,rssiState.dataContentDescription,state.label));
      }
    }
);
    parent.addView(rssiTile);
  }
  if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
    final QuickSettingsBasicTile rotationLockTile=new QuickSettingsBasicTile(mContext);
    rotationLockTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        boolean locked=RotationPolicy.isRotationLocked(mContext);
        RotationPolicy.setRotationLock(mContext,!locked);
      }
    }
);
    mModel.addRotationLockTile(rotationLockTile,new QuickSettingsModel.BasicRefreshCallback(rotationLockTile));
    parent.addView(rotationLockTile);
  }
  final QuickSettingsBasicTile batteryTile=new QuickSettingsBasicTile(mContext);
  batteryTile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
    }
  }
);
  mModel.addBatteryTile(batteryTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      QuickSettingsModel.BatteryState batteryState=(QuickSettingsModel.BatteryState)state;
      Drawable d=batteryState.pluggedIn ? mChargingBatteryLevels : mBatteryLevels;
      String t;
      if (batteryState.batteryLevel == 100) {
        t=mContext.getString(R.string.quick_settings_battery_charged_label);
      }
 else {
        t=batteryState.pluggedIn ? mContext.getString(R.string.quick_settings_battery_charging_label,batteryState.batteryLevel) : mContext.getString(R.string.status_bar_settings_battery_meter_format,batteryState.batteryLevel);
      }
      d.setLevel(batteryState.batteryLevel);
      batteryTile.setImageDrawable(d);
      batteryTile.setText(t);
      batteryTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery,t));
    }
  }
);
  parent.addView(batteryTile);
  final QuickSettingsBasicTile airplaneTile=new QuickSettingsBasicTile(mContext);
  mModel.addAirplaneModeTile(airplaneTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      airplaneTile.setImageResource(state.iconId);
      String airplaneState=mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
      airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane,airplaneState));
      airplaneTile.setText(state.label);
    }
  }
);
  parent.addView(airplaneTile);
  if (mModel.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
    final QuickSettingsBasicTile bluetoothTile=new QuickSettingsBasicTile(mContext);
    bluetoothTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
      }
    }
);
    if (LONG_PRESS_TOGGLES) {
      bluetoothTile.setOnLongClickListener(new View.OnLongClickListener(){
        @Override public boolean onLongClick(        View v){
          if (mBluetoothAdapter.isEnabled()) {
            mBluetoothAdapter.disable();
          }
 else {
            mBluetoothAdapter.enable();
          }
          bluetoothTile.setPressed(false);
          return true;
        }
      }
);
    }
    mModel.addBluetoothTile(bluetoothTile,new QuickSettingsModel.RefreshCallback(){
      @Override public void refreshView(      QuickSettingsTileView unused,      State state){
        BluetoothState bluetoothState=(BluetoothState)state;
        bluetoothTile.setImageResource(state.iconId);
        bluetoothTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth,bluetoothState.stateContentDescription));
        bluetoothTile.setText(state.label);
      }
    }
);
    parent.addView(bluetoothTile);
  }
}","private void addSystemTiles(ViewGroup parent,LayoutInflater inflater){
  final QuickSettingsBasicTile wifiTile=new QuickSettingsBasicTile(mContext);
  wifiTile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
    }
  }
);
  if (LONG_PRESS_TOGGLES) {
    wifiTile.setOnLongClickListener(new View.OnLongClickListener(){
      @Override public boolean onLongClick(      View v){
        final boolean enable=(mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
        new AsyncTask<Void,Void,Void>(){
          @Override protected Void doInBackground(          Void... args){
            final int wifiApState=mWifiManager.getWifiApState();
            if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
              mWifiManager.setWifiApEnabled(null,false);
            }
            mWifiManager.setWifiEnabled(enable);
            return null;
          }
        }
.execute();
        wifiTile.setPressed(false);
        return true;
      }
    }
);
  }
  mModel.addWifiTile(wifiTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      WifiState wifiState=(WifiState)state;
      wifiTile.setImageResource(wifiState.iconId);
      wifiTile.setText(wifiState.label);
      wifiTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi,wifiState.signalContentDescription,(wifiState.connected) ? wifiState.label : ""String_Node_Str""));
    }
  }
);
  parent.addView(wifiTile);
  if (mModel.deviceHasMobileData()) {
    QuickSettingsTileView rssiTile=(QuickSettingsTileView)inflater.inflate(R.layout.quick_settings_tile,parent,false);
    rssiTile.setContent(R.layout.quick_settings_tile_rssi,inflater);
    rssiTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        Intent intent=new Intent();
        intent.setComponent(new ComponentName(""String_Node_Str"",""String_Node_Str""));
        startSettingsActivity(intent);
      }
    }
);
    mModel.addRSSITile(rssiTile,new QuickSettingsModel.RefreshCallback(){
      @Override public void refreshView(      QuickSettingsTileView view,      State state){
        RSSIState rssiState=(RSSIState)state;
        ImageView iv=(ImageView)view.findViewById(R.id.rssi_image);
        ImageView iov=(ImageView)view.findViewById(R.id.rssi_overlay_image);
        TextView tv=(TextView)view.findViewById(R.id.rssi_textview);
        iv.setImageDrawable(null);
        iv.setImageResource(rssiState.signalIconId);
        if (rssiState.dataTypeIconId > 0) {
          iov.setImageResource(rssiState.dataTypeIconId);
        }
 else {
          iov.setImageDrawable(null);
        }
        tv.setText(state.label);
        view.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile,rssiState.signalContentDescription,rssiState.dataContentDescription,state.label));
      }
    }
);
    parent.addView(rssiTile);
  }
  if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
    final QuickSettingsBasicTile rotationLockTile=new QuickSettingsBasicTile(mContext);
    rotationLockTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        boolean locked=RotationPolicy.isRotationLocked(mContext);
        RotationPolicy.setRotationLock(mContext,!locked);
      }
    }
);
    mModel.addRotationLockTile(rotationLockTile,new QuickSettingsModel.BasicRefreshCallback(rotationLockTile));
    parent.addView(rotationLockTile);
  }
  final QuickSettingsBasicTile batteryTile=new QuickSettingsBasicTile(mContext);
  batteryTile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
    }
  }
);
  mModel.addBatteryTile(batteryTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      QuickSettingsModel.BatteryState batteryState=(QuickSettingsModel.BatteryState)state;
      Drawable d=batteryState.pluggedIn ? mChargingBatteryLevels : mBatteryLevels;
      String t;
      if (batteryState.batteryLevel == 100) {
        t=mContext.getString(R.string.quick_settings_battery_charged_label);
      }
 else {
        t=batteryState.pluggedIn ? mContext.getString(R.string.quick_settings_battery_charging_label,batteryState.batteryLevel) : mContext.getString(R.string.status_bar_settings_battery_meter_format,batteryState.batteryLevel);
      }
      batteryTile.setImageDrawable(d);
      batteryTile.getImageView().setImageLevel(batteryState.batteryLevel);
      batteryTile.setText(t);
      batteryTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery,t));
    }
  }
);
  parent.addView(batteryTile);
  final QuickSettingsBasicTile airplaneTile=new QuickSettingsBasicTile(mContext);
  mModel.addAirplaneModeTile(airplaneTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      airplaneTile.setImageResource(state.iconId);
      String airplaneState=mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
      airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane,airplaneState));
      airplaneTile.setText(state.label);
    }
  }
);
  parent.addView(airplaneTile);
  if (mModel.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
    final QuickSettingsBasicTile bluetoothTile=new QuickSettingsBasicTile(mContext);
    bluetoothTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
      }
    }
);
    if (LONG_PRESS_TOGGLES) {
      bluetoothTile.setOnLongClickListener(new View.OnLongClickListener(){
        @Override public boolean onLongClick(        View v){
          if (mBluetoothAdapter.isEnabled()) {
            mBluetoothAdapter.disable();
          }
 else {
            mBluetoothAdapter.enable();
          }
          bluetoothTile.setPressed(false);
          return true;
        }
      }
);
    }
    mModel.addBluetoothTile(bluetoothTile,new QuickSettingsModel.RefreshCallback(){
      @Override public void refreshView(      QuickSettingsTileView unused,      State state){
        BluetoothState bluetoothState=(BluetoothState)state;
        bluetoothTile.setImageResource(state.iconId);
        bluetoothTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth,bluetoothState.stateContentDescription));
        bluetoothTile.setText(state.label);
      }
    }
);
    parent.addView(bluetoothTile);
  }
}"
2024,"private void addSystemTiles(ViewGroup parent,LayoutInflater inflater){
  final QuickSettingsBasicTile wifiTile=new QuickSettingsBasicTile(mContext);
  wifiTile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
    }
  }
);
  if (LONG_PRESS_TOGGLES) {
    wifiTile.setOnLongClickListener(new View.OnLongClickListener(){
      @Override public boolean onLongClick(      View v){
        final boolean enable=(mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
        new AsyncTask<Void,Void,Void>(){
          @Override protected Void doInBackground(          Void... args){
            final int wifiApState=mWifiManager.getWifiApState();
            if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
              mWifiManager.setWifiApEnabled(null,false);
            }
            mWifiManager.setWifiEnabled(enable);
            return null;
          }
        }
.execute();
        wifiTile.setPressed(false);
        return true;
      }
    }
);
  }
  mModel.addWifiTile(wifiTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      WifiState wifiState=(WifiState)state;
      wifiTile.setImageResource(wifiState.iconId);
      wifiTile.setText(wifiState.label);
      wifiTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi,wifiState.signalContentDescription,(wifiState.connected) ? wifiState.label : ""String_Node_Str""));
    }
  }
);
  parent.addView(wifiTile);
  if (mModel.deviceHasMobileData()) {
    QuickSettingsTileView rssiTile=(QuickSettingsTileView)inflater.inflate(R.layout.quick_settings_tile,parent,false);
    rssiTile.setContent(R.layout.quick_settings_tile_rssi,inflater);
    rssiTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        Intent intent=new Intent();
        intent.setComponent(new ComponentName(""String_Node_Str"",""String_Node_Str""));
        startSettingsActivity(intent);
      }
    }
);
    mModel.addRSSITile(rssiTile,new QuickSettingsModel.RefreshCallback(){
      @Override public void refreshView(      QuickSettingsTileView view,      State state){
        RSSIState rssiState=(RSSIState)state;
        ImageView iv=(ImageView)view.findViewById(R.id.rssi_image);
        ImageView iov=(ImageView)view.findViewById(R.id.rssi_overlay_image);
        TextView tv=(TextView)view.findViewById(R.id.rssi_textview);
        iv.setImageDrawable(null);
        iv.setImageResource(rssiState.signalIconId);
        if (rssiState.dataTypeIconId > 0) {
          iov.setImageResource(rssiState.dataTypeIconId);
        }
 else {
          iov.setImageDrawable(null);
        }
        tv.setText(state.label);
        view.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile,rssiState.signalContentDescription,rssiState.dataContentDescription,state.label));
      }
    }
);
    parent.addView(rssiTile);
  }
  if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
    final QuickSettingsBasicTile rotationLockTile=new QuickSettingsBasicTile(mContext);
    rotationLockTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        boolean locked=RotationPolicy.isRotationLocked(mContext);
        RotationPolicy.setRotationLock(mContext,!locked);
      }
    }
);
    mModel.addRotationLockTile(rotationLockTile,new QuickSettingsModel.BasicRefreshCallback(rotationLockTile));
    parent.addView(rotationLockTile);
  }
  final QuickSettingsBasicTile batteryTile=new QuickSettingsBasicTile(mContext);
  batteryTile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
    }
  }
);
  mModel.addBatteryTile(batteryTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      QuickSettingsModel.BatteryState batteryState=(QuickSettingsModel.BatteryState)state;
      Drawable d=batteryState.pluggedIn ? mChargingBatteryLevels : mBatteryLevels;
      String t;
      if (batteryState.batteryLevel == 100) {
        t=mContext.getString(R.string.quick_settings_battery_charged_label);
      }
 else {
        t=batteryState.pluggedIn ? mContext.getString(R.string.quick_settings_battery_charging_label,batteryState.batteryLevel) : mContext.getString(R.string.status_bar_settings_battery_meter_format,batteryState.batteryLevel);
      }
      d.setLevel(batteryState.batteryLevel);
      batteryTile.setImageDrawable(d);
      batteryTile.setText(t);
      batteryTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery,t));
    }
  }
);
  parent.addView(batteryTile);
  final QuickSettingsBasicTile airplaneTile=new QuickSettingsBasicTile(mContext);
  mModel.addAirplaneModeTile(airplaneTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      airplaneTile.setImageResource(state.iconId);
      String airplaneState=mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
      airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane,airplaneState));
      airplaneTile.setText(state.label);
    }
  }
);
  parent.addView(airplaneTile);
  if (mModel.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
    final QuickSettingsBasicTile bluetoothTile=new QuickSettingsBasicTile(mContext);
    bluetoothTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
      }
    }
);
    if (LONG_PRESS_TOGGLES) {
      bluetoothTile.setOnLongClickListener(new View.OnLongClickListener(){
        @Override public boolean onLongClick(        View v){
          if (mBluetoothAdapter.isEnabled()) {
            mBluetoothAdapter.disable();
          }
 else {
            mBluetoothAdapter.enable();
          }
          bluetoothTile.setPressed(false);
          return true;
        }
      }
);
    }
    mModel.addBluetoothTile(bluetoothTile,new QuickSettingsModel.RefreshCallback(){
      @Override public void refreshView(      QuickSettingsTileView unused,      State state){
        BluetoothState bluetoothState=(BluetoothState)state;
        bluetoothTile.setImageResource(state.iconId);
        bluetoothTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth,bluetoothState.stateContentDescription));
        bluetoothTile.setText(state.label);
      }
    }
);
    parent.addView(bluetoothTile);
  }
}","private void addSystemTiles(ViewGroup parent,LayoutInflater inflater){
  final QuickSettingsBasicTile wifiTile=new QuickSettingsBasicTile(mContext);
  wifiTile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
    }
  }
);
  if (LONG_PRESS_TOGGLES) {
    wifiTile.setOnLongClickListener(new View.OnLongClickListener(){
      @Override public boolean onLongClick(      View v){
        final boolean enable=(mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
        new AsyncTask<Void,Void,Void>(){
          @Override protected Void doInBackground(          Void... args){
            final int wifiApState=mWifiManager.getWifiApState();
            if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
              mWifiManager.setWifiApEnabled(null,false);
            }
            mWifiManager.setWifiEnabled(enable);
            return null;
          }
        }
.execute();
        wifiTile.setPressed(false);
        return true;
      }
    }
);
  }
  mModel.addWifiTile(wifiTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      WifiState wifiState=(WifiState)state;
      wifiTile.setImageResource(wifiState.iconId);
      wifiTile.setText(wifiState.label);
      wifiTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi,wifiState.signalContentDescription,(wifiState.connected) ? wifiState.label : ""String_Node_Str""));
    }
  }
);
  parent.addView(wifiTile);
  if (mModel.deviceHasMobileData()) {
    QuickSettingsTileView rssiTile=(QuickSettingsTileView)inflater.inflate(R.layout.quick_settings_tile,parent,false);
    rssiTile.setContent(R.layout.quick_settings_tile_rssi,inflater);
    rssiTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        Intent intent=new Intent();
        intent.setComponent(new ComponentName(""String_Node_Str"",""String_Node_Str""));
        startSettingsActivity(intent);
      }
    }
);
    mModel.addRSSITile(rssiTile,new QuickSettingsModel.RefreshCallback(){
      @Override public void refreshView(      QuickSettingsTileView view,      State state){
        RSSIState rssiState=(RSSIState)state;
        ImageView iv=(ImageView)view.findViewById(R.id.rssi_image);
        ImageView iov=(ImageView)view.findViewById(R.id.rssi_overlay_image);
        TextView tv=(TextView)view.findViewById(R.id.rssi_textview);
        iv.setImageDrawable(null);
        iv.setImageResource(rssiState.signalIconId);
        if (rssiState.dataTypeIconId > 0) {
          iov.setImageResource(rssiState.dataTypeIconId);
        }
 else {
          iov.setImageDrawable(null);
        }
        tv.setText(state.label);
        view.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile,rssiState.signalContentDescription,rssiState.dataContentDescription,state.label));
      }
    }
);
    parent.addView(rssiTile);
  }
  if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
    final QuickSettingsBasicTile rotationLockTile=new QuickSettingsBasicTile(mContext);
    rotationLockTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        boolean locked=RotationPolicy.isRotationLocked(mContext);
        RotationPolicy.setRotationLock(mContext,!locked);
      }
    }
);
    mModel.addRotationLockTile(rotationLockTile,new QuickSettingsModel.BasicRefreshCallback(rotationLockTile));
    parent.addView(rotationLockTile);
  }
  final QuickSettingsBasicTile batteryTile=new QuickSettingsBasicTile(mContext);
  batteryTile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
    }
  }
);
  mModel.addBatteryTile(batteryTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      QuickSettingsModel.BatteryState batteryState=(QuickSettingsModel.BatteryState)state;
      Drawable d=batteryState.pluggedIn ? mChargingBatteryLevels : mBatteryLevels;
      String t;
      if (batteryState.batteryLevel == 100) {
        t=mContext.getString(R.string.quick_settings_battery_charged_label);
      }
 else {
        t=batteryState.pluggedIn ? mContext.getString(R.string.quick_settings_battery_charging_label,batteryState.batteryLevel) : mContext.getString(R.string.status_bar_settings_battery_meter_format,batteryState.batteryLevel);
      }
      batteryTile.setImageDrawable(d);
      batteryTile.getImageView().setImageLevel(batteryState.batteryLevel);
      batteryTile.setText(t);
      batteryTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery,t));
    }
  }
);
  parent.addView(batteryTile);
  final QuickSettingsBasicTile airplaneTile=new QuickSettingsBasicTile(mContext);
  mModel.addAirplaneModeTile(airplaneTile,new QuickSettingsModel.RefreshCallback(){
    @Override public void refreshView(    QuickSettingsTileView unused,    State state){
      airplaneTile.setImageResource(state.iconId);
      String airplaneState=mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
      airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane,airplaneState));
      airplaneTile.setText(state.label);
    }
  }
);
  parent.addView(airplaneTile);
  if (mModel.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
    final QuickSettingsBasicTile bluetoothTile=new QuickSettingsBasicTile(mContext);
    bluetoothTile.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
      }
    }
);
    if (LONG_PRESS_TOGGLES) {
      bluetoothTile.setOnLongClickListener(new View.OnLongClickListener(){
        @Override public boolean onLongClick(        View v){
          if (mBluetoothAdapter.isEnabled()) {
            mBluetoothAdapter.disable();
          }
 else {
            mBluetoothAdapter.enable();
          }
          bluetoothTile.setPressed(false);
          return true;
        }
      }
);
    }
    mModel.addBluetoothTile(bluetoothTile,new QuickSettingsModel.RefreshCallback(){
      @Override public void refreshView(      QuickSettingsTileView unused,      State state){
        BluetoothState bluetoothState=(BluetoothState)state;
        bluetoothTile.setImageResource(state.iconId);
        bluetoothTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth,bluetoothState.stateContentDescription));
        bluetoothTile.setText(state.label);
      }
    }
);
    parent.addView(bluetoothTile);
  }
}"
2025,"public void init(UserInfo user,KeyguardMultiUserSelectorView userSelector){
  mUserInfo=user;
  mUserSelector=userSelector;
  mUserImage=(ImageView)findViewById(R.id.keyguard_user_avatar);
  mUserName=(TextView)findViewById(R.id.keyguard_user_name);
  Bitmap icon=mUserManager.getUserIcon(user.id);
  if (icon == null) {
    if (DEBUG)     Log.w(TAG,""String_Node_Str"" + user.id);
    icon=BitmapFactory.decodeResource(mContext.getResources(),R.drawable.ic_contact_picture);
  }
  mFramed=(KeyguardCircleFramedDrawable)KeyguardViewMediator.getAvatarCache().get(user.id);
  if (mFramed == null || !mFramed.verifyParams(mIconSize,mFrameColor,mStroke,mFrameShadowColor,mShadowRadius,mHighlightColor)) {
    Bitmap icon=null;
    try {
      icon=BitmapFactory.decodeFile(rewriteIconPath(user.iconPath));
    }
 catch (    Exception e) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + user.iconPath,e);
    }
    if (icon == null) {
      icon=BitmapFactory.decodeResource(mContext.getResources(),com.android.internal.R.drawable.ic_contact_picture);
    }
    mFramed=new KeyguardCircleFramedDrawable(icon,(int)mIconSize,mFrameColor,mStroke,mFrameShadowColor,mShadowRadius,mHighlightColor);
    KeyguardViewMediator.getAvatarCache().put(user.id,mFramed);
  }
  mFramed.reset();
  mUserImage.setImageDrawable(mFramed);
  mUserName.setText(mUserInfo.name);
  setOnClickListener(mUserSelector);
  mInit=false;
}","public void init(UserInfo user,KeyguardMultiUserSelectorView userSelector){
  mUserInfo=user;
  mUserSelector=userSelector;
  mUserImage=(ImageView)findViewById(R.id.keyguard_user_avatar);
  mUserName=(TextView)findViewById(R.id.keyguard_user_name);
  mFramed=(KeyguardCircleFramedDrawable)KeyguardViewMediator.getAvatarCache().get(user.id);
  if (mFramed == null || !mFramed.verifyParams(mIconSize,mFrameColor,mStroke,mFrameShadowColor,mShadowRadius,mHighlightColor)) {
    Bitmap icon=null;
    try {
      icon=BitmapFactory.decodeFile(rewriteIconPath(user.iconPath));
    }
 catch (    Exception e) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + user.iconPath,e);
    }
    if (icon == null) {
      icon=BitmapFactory.decodeResource(mContext.getResources(),com.android.internal.R.drawable.ic_contact_picture);
    }
    mFramed=new KeyguardCircleFramedDrawable(icon,(int)mIconSize,mFrameColor,mStroke,mFrameShadowColor,mShadowRadius,mHighlightColor);
    KeyguardViewMediator.getAvatarCache().put(user.id,mFramed);
  }
  mFramed.reset();
  mUserImage.setImageDrawable(mFramed);
  mUserName.setText(mUserInfo.name);
  setOnClickListener(mUserSelector);
  mInit=false;
}"
2026,"static void updateWifiDisplayStatus(WifiDisplayStatus newStatus){
  final WifiDisplayStatus oldStatus=sStatic.mLastKnownWifiDisplayStatus;
  boolean wantScan=false;
  boolean blockScan=false;
  WifiDisplay[] oldDisplays=oldStatus != null ? oldStatus.getRememberedDisplays() : WifiDisplay.EMPTY_ARRAY;
  WifiDisplay[] newDisplays;
  WifiDisplay[] availableDisplays;
  WifiDisplay activeDisplay;
  if (newStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_ON) {
    newDisplays=newStatus.getRememberedDisplays();
    availableDisplays=newStatus.getAvailableDisplays();
    activeDisplay=newStatus.getActiveDisplay();
  }
 else {
    newDisplays=availableDisplays=WifiDisplay.EMPTY_ARRAY;
    activeDisplay=null;
  }
  for (int i=0; i < newDisplays.length; i++) {
    final WifiDisplay d=newDisplays[i];
    final WifiDisplay oldRemembered=findMatchingDisplay(d,oldDisplays);
    if (oldRemembered == null) {
      addRouteStatic(makeWifiDisplayRoute(d,findMatchingDisplay(d,availableDisplays) != null));
      wantScan=true;
    }
 else {
      final boolean available=findMatchingDisplay(d,availableDisplays) != null;
      final RouteInfo route=findWifiDisplayRoute(d);
      updateWifiDisplayRoute(route,d,available,newStatus);
    }
    if (d.equals(activeDisplay)) {
      final RouteInfo activeRoute=findWifiDisplayRoute(d);
      if (activeRoute != null) {
        selectRouteStatic(activeRoute.getSupportedTypes(),activeRoute);
        blockScan=true;
      }
    }
  }
  for (int i=0; i < oldDisplays.length; i++) {
    final WifiDisplay d=oldDisplays[i];
    final WifiDisplay newDisplay=findMatchingDisplay(d,newDisplays);
    if (newDisplay == null) {
      removeRoute(findWifiDisplayRoute(d));
    }
  }
  if (wantScan && !blockScan) {
    sStatic.mDisplayService.scanWifiDisplays();
  }
  sStatic.mLastKnownWifiDisplayStatus=newStatus;
}","static void updateWifiDisplayStatus(WifiDisplayStatus newStatus){
  final WifiDisplayStatus oldStatus=sStatic.mLastKnownWifiDisplayStatus;
  boolean wantScan=false;
  boolean blockScan=false;
  WifiDisplay[] oldDisplays=oldStatus != null ? oldStatus.getRememberedDisplays() : WifiDisplay.EMPTY_ARRAY;
  WifiDisplay[] newDisplays;
  WifiDisplay[] availableDisplays;
  WifiDisplay activeDisplay;
  if (newStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_ON) {
    newDisplays=newStatus.getRememberedDisplays();
    availableDisplays=newStatus.getAvailableDisplays();
    activeDisplay=newStatus.getActiveDisplay();
  }
 else {
    newDisplays=availableDisplays=WifiDisplay.EMPTY_ARRAY;
    activeDisplay=null;
  }
  for (int i=0; i < newDisplays.length; i++) {
    final WifiDisplay d=newDisplays[i];
    final boolean available=findMatchingDisplay(d,availableDisplays) != null;
    RouteInfo route=findWifiDisplayRoute(d);
    if (route == null) {
      route=makeWifiDisplayRoute(d,available);
      addRouteStatic(route);
      wantScan=true;
    }
 else {
      updateWifiDisplayRoute(route,d,available,newStatus);
    }
    if (d.equals(activeDisplay)) {
      selectRouteStatic(route.getSupportedTypes(),route);
      blockScan=true;
    }
  }
  for (int i=0; i < oldDisplays.length; i++) {
    final WifiDisplay d=oldDisplays[i];
    final WifiDisplay newDisplay=findMatchingDisplay(d,newDisplays);
    if (newDisplay == null) {
      removeRoute(findWifiDisplayRoute(d));
    }
  }
  if (wantScan && !blockScan) {
    sStatic.mDisplayService.scanWifiDisplays();
  }
  sStatic.mLastKnownWifiDisplayStatus=newStatus;
}"
2027,"static void updateWifiDisplayStatus(WifiDisplayStatus newStatus){
  final WifiDisplayStatus oldStatus=sStatic.mLastKnownWifiDisplayStatus;
  boolean wantScan=false;
  boolean blockScan=false;
  WifiDisplay[] oldDisplays=oldStatus != null ? oldStatus.getRememberedDisplays() : WifiDisplay.EMPTY_ARRAY;
  WifiDisplay[] newDisplays;
  WifiDisplay[] availableDisplays;
  WifiDisplay activeDisplay;
  if (newStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_ON) {
    newDisplays=newStatus.getRememberedDisplays();
    availableDisplays=newStatus.getAvailableDisplays();
    activeDisplay=newStatus.getActiveDisplay();
  }
 else {
    newDisplays=availableDisplays=WifiDisplay.EMPTY_ARRAY;
    activeDisplay=null;
  }
  for (int i=0; i < newDisplays.length; i++) {
    final WifiDisplay d=newDisplays[i];
    final WifiDisplay oldRemembered=findMatchingDisplay(d,oldDisplays);
    if (oldRemembered == null) {
      addRouteStatic(makeWifiDisplayRoute(d,findMatchingDisplay(d,availableDisplays) != null));
      wantScan=true;
    }
 else {
      final boolean available=findMatchingDisplay(d,availableDisplays) != null;
      final RouteInfo route=findWifiDisplayRoute(d);
      updateWifiDisplayRoute(route,d,available,newStatus);
    }
    if (d.equals(activeDisplay)) {
      final RouteInfo activeRoute=findWifiDisplayRoute(d);
      if (activeRoute != null) {
        selectRouteStatic(activeRoute.getSupportedTypes(),activeRoute);
        blockScan=true;
      }
    }
  }
  for (int i=0; i < oldDisplays.length; i++) {
    final WifiDisplay d=oldDisplays[i];
    final WifiDisplay newDisplay=findMatchingDisplay(d,newDisplays);
    if (newDisplay == null) {
      removeRoute(findWifiDisplayRoute(d));
    }
  }
  if (wantScan && !blockScan) {
    sStatic.mDisplayService.scanWifiDisplays();
  }
  sStatic.mLastKnownWifiDisplayStatus=newStatus;
}","static void updateWifiDisplayStatus(WifiDisplayStatus newStatus){
  final WifiDisplayStatus oldStatus=sStatic.mLastKnownWifiDisplayStatus;
  boolean wantScan=false;
  boolean blockScan=false;
  WifiDisplay[] oldDisplays=oldStatus != null ? oldStatus.getRememberedDisplays() : WifiDisplay.EMPTY_ARRAY;
  WifiDisplay[] newDisplays;
  WifiDisplay[] availableDisplays;
  WifiDisplay activeDisplay;
  if (newStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_ON) {
    newDisplays=newStatus.getRememberedDisplays();
    availableDisplays=newStatus.getAvailableDisplays();
    activeDisplay=newStatus.getActiveDisplay();
  }
 else {
    newDisplays=availableDisplays=WifiDisplay.EMPTY_ARRAY;
    activeDisplay=null;
  }
  for (int i=0; i < newDisplays.length; i++) {
    final WifiDisplay d=newDisplays[i];
    final boolean available=findMatchingDisplay(d,availableDisplays) != null;
    RouteInfo route=findWifiDisplayRoute(d);
    if (route == null) {
      route=makeWifiDisplayRoute(d,available);
      addRouteStatic(route);
      wantScan=true;
    }
 else {
      updateWifiDisplayRoute(route,d,available,newStatus);
    }
    if (d.equals(activeDisplay)) {
      selectRouteStatic(route.getSupportedTypes(),route);
      blockScan=true;
    }
  }
  for (int i=0; i < oldDisplays.length; i++) {
    final WifiDisplay d=oldDisplays[i];
    final WifiDisplay newDisplay=findMatchingDisplay(d,newDisplays);
    if (newDisplay == null) {
      removeRoute(findWifiDisplayRoute(d));
    }
  }
  if (wantScan && !blockScan) {
    sStatic.mDisplayService.scanWifiDisplays();
  }
  sStatic.mLastKnownWifiDisplayStatus=newStatus;
}"
2028,"static void updateWifiDisplayStatus(WifiDisplayStatus newStatus){
  final WifiDisplayStatus oldStatus=sStatic.mLastKnownWifiDisplayStatus;
  boolean wantScan=false;
  boolean blockScan=false;
  WifiDisplay[] oldDisplays=oldStatus != null ? oldStatus.getRememberedDisplays() : WifiDisplay.EMPTY_ARRAY;
  WifiDisplay[] newDisplays;
  WifiDisplay[] availableDisplays;
  WifiDisplay activeDisplay;
  if (newStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_ON) {
    newDisplays=newStatus.getRememberedDisplays();
    availableDisplays=newStatus.getAvailableDisplays();
    activeDisplay=newStatus.getActiveDisplay();
  }
 else {
    newDisplays=availableDisplays=WifiDisplay.EMPTY_ARRAY;
    activeDisplay=null;
  }
  for (int i=0; i < newDisplays.length; i++) {
    final WifiDisplay d=newDisplays[i];
    final WifiDisplay oldRemembered=findMatchingDisplay(d,oldDisplays);
    if (oldRemembered == null) {
      addRouteStatic(makeWifiDisplayRoute(d,findMatchingDisplay(d,availableDisplays) != null));
      wantScan=true;
    }
 else {
      final boolean available=findMatchingDisplay(d,availableDisplays) != null;
      final RouteInfo route=findWifiDisplayRoute(d);
      updateWifiDisplayRoute(route,d,available,newStatus);
    }
    if (d.equals(activeDisplay)) {
      final RouteInfo activeRoute=findWifiDisplayRoute(d);
      if (activeRoute != null) {
        selectRouteStatic(activeRoute.getSupportedTypes(),activeRoute);
        blockScan=true;
      }
    }
  }
  for (int i=0; i < oldDisplays.length; i++) {
    final WifiDisplay d=oldDisplays[i];
    final WifiDisplay newDisplay=findMatchingDisplay(d,newDisplays);
    if (newDisplay == null) {
      removeRoute(findWifiDisplayRoute(d));
    }
  }
  if (wantScan && !blockScan) {
    sStatic.mDisplayService.scanWifiDisplays();
  }
  sStatic.mLastKnownWifiDisplayStatus=newStatus;
}","static void updateWifiDisplayStatus(WifiDisplayStatus newStatus){
  final WifiDisplayStatus oldStatus=sStatic.mLastKnownWifiDisplayStatus;
  boolean wantScan=false;
  boolean blockScan=false;
  WifiDisplay[] oldDisplays=oldStatus != null ? oldStatus.getRememberedDisplays() : WifiDisplay.EMPTY_ARRAY;
  WifiDisplay[] newDisplays;
  WifiDisplay[] availableDisplays;
  WifiDisplay activeDisplay;
  if (newStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_ON) {
    newDisplays=newStatus.getRememberedDisplays();
    availableDisplays=newStatus.getAvailableDisplays();
    activeDisplay=newStatus.getActiveDisplay();
  }
 else {
    newDisplays=availableDisplays=WifiDisplay.EMPTY_ARRAY;
    activeDisplay=null;
  }
  for (int i=0; i < newDisplays.length; i++) {
    final WifiDisplay d=newDisplays[i];
    final boolean available=findMatchingDisplay(d,availableDisplays) != null;
    RouteInfo route=findWifiDisplayRoute(d);
    if (route == null) {
      route=makeWifiDisplayRoute(d,available);
      addRouteStatic(route);
      wantScan=true;
    }
 else {
      updateWifiDisplayRoute(route,d,available,newStatus);
    }
    if (d.equals(activeDisplay)) {
      selectRouteStatic(route.getSupportedTypes(),route);
      blockScan=true;
    }
  }
  for (int i=0; i < oldDisplays.length; i++) {
    final WifiDisplay d=oldDisplays[i];
    final WifiDisplay newDisplay=findMatchingDisplay(d,newDisplays);
    if (newDisplay == null) {
      removeRoute(findWifiDisplayRoute(d));
    }
  }
  if (wantScan && !blockScan) {
    sStatic.mDisplayService.scanWifiDisplays();
  }
  sStatic.mLastKnownWifiDisplayStatus=newStatus;
}"
2029,"static void updateWifiDisplayStatus(WifiDisplayStatus newStatus){
  final WifiDisplayStatus oldStatus=sStatic.mLastKnownWifiDisplayStatus;
  boolean wantScan=false;
  boolean blockScan=false;
  WifiDisplay[] oldDisplays=oldStatus != null ? oldStatus.getRememberedDisplays() : WifiDisplay.EMPTY_ARRAY;
  WifiDisplay[] newDisplays;
  WifiDisplay[] availableDisplays;
  WifiDisplay activeDisplay;
  if (newStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_ON) {
    newDisplays=newStatus.getRememberedDisplays();
    availableDisplays=newStatus.getAvailableDisplays();
    activeDisplay=newStatus.getActiveDisplay();
  }
 else {
    newDisplays=availableDisplays=WifiDisplay.EMPTY_ARRAY;
    activeDisplay=null;
  }
  for (int i=0; i < newDisplays.length; i++) {
    final WifiDisplay d=newDisplays[i];
    final WifiDisplay oldRemembered=findMatchingDisplay(d,oldDisplays);
    if (oldRemembered == null) {
      addRouteStatic(makeWifiDisplayRoute(d,findMatchingDisplay(d,availableDisplays) != null));
      wantScan=true;
    }
 else {
      final boolean available=findMatchingDisplay(d,availableDisplays) != null;
      final RouteInfo route=findWifiDisplayRoute(d);
      updateWifiDisplayRoute(route,d,available,newStatus);
    }
    if (d.equals(activeDisplay)) {
      final RouteInfo activeRoute=findWifiDisplayRoute(d);
      if (activeRoute != null) {
        selectRouteStatic(activeRoute.getSupportedTypes(),activeRoute);
        blockScan=true;
      }
    }
  }
  for (int i=0; i < oldDisplays.length; i++) {
    final WifiDisplay d=oldDisplays[i];
    final WifiDisplay newDisplay=findMatchingDisplay(d,newDisplays);
    if (newDisplay == null) {
      removeRoute(findWifiDisplayRoute(d));
    }
  }
  if (wantScan && !blockScan) {
    sStatic.mDisplayService.scanWifiDisplays();
  }
  sStatic.mLastKnownWifiDisplayStatus=newStatus;
}","static void updateWifiDisplayStatus(WifiDisplayStatus newStatus){
  final WifiDisplayStatus oldStatus=sStatic.mLastKnownWifiDisplayStatus;
  boolean wantScan=false;
  boolean blockScan=false;
  WifiDisplay[] oldDisplays=oldStatus != null ? oldStatus.getRememberedDisplays() : WifiDisplay.EMPTY_ARRAY;
  WifiDisplay[] newDisplays;
  WifiDisplay[] availableDisplays;
  WifiDisplay activeDisplay;
  if (newStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_ON) {
    newDisplays=newStatus.getRememberedDisplays();
    availableDisplays=newStatus.getAvailableDisplays();
    activeDisplay=newStatus.getActiveDisplay();
  }
 else {
    newDisplays=availableDisplays=WifiDisplay.EMPTY_ARRAY;
    activeDisplay=null;
  }
  for (int i=0; i < newDisplays.length; i++) {
    final WifiDisplay d=newDisplays[i];
    final boolean available=findMatchingDisplay(d,availableDisplays) != null;
    RouteInfo route=findWifiDisplayRoute(d);
    if (route == null) {
      route=makeWifiDisplayRoute(d,available);
      addRouteStatic(route);
      wantScan=true;
    }
 else {
      updateWifiDisplayRoute(route,d,available,newStatus);
    }
    if (d.equals(activeDisplay)) {
      selectRouteStatic(route.getSupportedTypes(),route);
      blockScan=true;
    }
  }
  for (int i=0; i < oldDisplays.length; i++) {
    final WifiDisplay d=oldDisplays[i];
    final WifiDisplay newDisplay=findMatchingDisplay(d,newDisplays);
    if (newDisplay == null) {
      removeRoute(findWifiDisplayRoute(d));
    }
  }
  if (wantScan && !blockScan) {
    sStatic.mDisplayService.scanWifiDisplays();
  }
  sStatic.mLastKnownWifiDisplayStatus=newStatus;
}"
2030,"/** 
 * Replace existing canvas while ensuring that the swap has occurred before the previous native canvas is unreferenced.
 */
private void safeCanvasSwap(int nativeCanvas){
  final int oldCanvas=mNativeCanvas;
  mNativeCanvas=nativeCanvas;
  mFinalizer.mNativeCanvas=nativeCanvas;
  copyNativeCanvasState(oldCanvas,mNativeCanvas);
  finalizer(oldCanvas);
}","/** 
 * Replace existing canvas while ensuring that the swap has occurred before the previous native canvas is unreferenced.
 */
private void safeCanvasSwap(int nativeCanvas,boolean copyState){
  final int oldCanvas=mNativeCanvas;
  mNativeCanvas=nativeCanvas;
  mFinalizer.mNativeCanvas=nativeCanvas;
  if (copyState) {
    copyNativeCanvasState(oldCanvas,mNativeCanvas);
  }
  finalizer(oldCanvas);
}"
2031,"/** 
 * Specify a bitmap for the canvas to draw into. As a side-effect, the canvas' target density is updated to match that of the bitmap while all other state such as the layers, filters, matrix, and clip are reset.
 * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
 * @see #setDensity(int)
 * @see #getDensity()
 */
public void setBitmap(Bitmap bitmap){
  if (isHardwareAccelerated()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (bitmap == null) {
    safeCanvasSwap(initRaster(0));
    mDensity=Bitmap.DENSITY_NONE;
  }
 else {
    if (!bitmap.isMutable()) {
      throw new IllegalStateException();
    }
    throwIfRecycled(bitmap);
    safeCanvasSwap(initRaster(bitmap.ni()));
    mDensity=bitmap.mDensity;
  }
  mBitmap=bitmap;
}","/** 
 * Specify a bitmap for the canvas to draw into. All canvas state such as  layers, filters, and the save/restore stack are reset with the exception of the current matrix and clip stack. Additionally, as a side-effect the canvas' target density is updated to match that of the bitmap.
 * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
 * @see #setDensity(int)
 * @see #getDensity()
 */
public void setBitmap(Bitmap bitmap){
  if (isHardwareAccelerated()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (bitmap == null) {
    safeCanvasSwap(initRaster(0),false);
    mDensity=Bitmap.DENSITY_NONE;
  }
 else {
    if (!bitmap.isMutable()) {
      throw new IllegalStateException();
    }
    throwIfRecycled(bitmap);
    safeCanvasSwap(initRaster(bitmap.ni()),true);
    mDensity=bitmap.mDensity;
  }
  mBitmap=bitmap;
}"
2032,"@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf){
  mHaveFrame=true;
  final Rect container=mContainingFrame;
  container.set(pf);
  final Rect display=mDisplayFrame;
  display.set(df);
  final int pw=container.right - container.left;
  final int ph=container.bottom - container.top;
  int w, h;
  if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0) {
    if (mAttrs.width < 0) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mAttrs.width * mGlobalScale + .5f);
    }
 else {
      w=mAttrs.width;
    }
    if (mAttrs.height < 0) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mAttrs.height * mGlobalScale + .5f);
    }
 else {
      h=mAttrs.height;
    }
  }
 else {
    if (mAttrs.width == WindowManager.LayoutParams.MATCH_PARENT) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mRequestedWidth * mGlobalScale + .5f);
    }
 else {
      w=mRequestedWidth;
    }
    if (mAttrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mRequestedHeight * mGlobalScale + .5f);
    }
 else {
      h=mRequestedHeight;
    }
  }
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  final Rect overscan=mOverscanFrame;
  overscan.set(of);
  final Rect content=mContentFrame;
  content.set(cf);
  final Rect visible=mVisibleFrame;
  visible.set(vf);
  final Rect frame=mFrame;
  final int fw=frame.width();
  final int fh=frame.height();
  float x, y;
  if (mEnforceSizeCompat) {
    x=mAttrs.x * mGlobalScale;
    y=mAttrs.y * mGlobalScale;
  }
 else {
    x=mAttrs.x;
    y=mAttrs.y;
  }
  Gravity.apply(mAttrs.gravity,w,h,container,(int)(x + mAttrs.horizontalMargin * pw),(int)(y + mAttrs.verticalMargin * ph),frame);
  Gravity.applyDisplay(mAttrs.gravity,df,frame);
  if (content.left < frame.left)   content.left=frame.left;
  if (content.top < frame.top)   content.top=frame.top;
  if (content.right > frame.right)   content.right=frame.right;
  if (content.bottom > frame.bottom)   content.bottom=frame.bottom;
  if (visible.left < frame.left)   visible.left=frame.left;
  if (visible.top < frame.top)   visible.top=frame.top;
  if (visible.right > frame.right)   visible.right=frame.right;
  if (visible.bottom > frame.bottom)   visible.bottom=frame.bottom;
  final Rect overscanInsets=mOverscanInsets;
  overscanInsets.left=overscan.left - frame.left;
  overscanInsets.top=overscan.top - frame.top;
  overscanInsets.right=frame.right - overscan.right;
  overscanInsets.bottom=frame.bottom - overscan.bottom;
  final Rect contentInsets=mContentInsets;
  contentInsets.left=content.left - frame.left;
  contentInsets.top=content.top - frame.top;
  contentInsets.right=frame.right - content.right;
  contentInsets.bottom=frame.bottom - content.bottom;
  final Rect visibleInsets=mVisibleInsets;
  visibleInsets.left=visible.left - frame.left;
  visibleInsets.top=visible.top - frame.top;
  visibleInsets.right=frame.right - visible.right;
  visibleInsets.bottom=frame.bottom - visible.bottom;
  mCompatFrame.set(frame);
  if (mEnforceSizeCompat) {
    overscanInsets.scale(mInvGlobalScale);
    contentInsets.scale(mInvGlobalScale);
    visibleInsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != frame.width() || fh != frame.height())) {
    final DisplayInfo displayInfo=mDisplayContent.getDisplayInfo();
    mService.updateWallpaperOffsetLocked(this,displayInfo.appWidth,displayInfo.appHeight,false);
  }
  if (WindowManagerService.localLOGV) {
    Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ contentInsets.toShortString()+ ""String_Node_Str""+ visibleInsets.toShortString());
  }
}","@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf){
  mHaveFrame=true;
  final Rect container=mContainingFrame;
  container.set(pf);
  final Rect display=mDisplayFrame;
  display.set(df);
  final int pw=container.right - container.left;
  final int ph=container.bottom - container.top;
  int w, h;
  if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0) {
    if (mAttrs.width < 0) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mAttrs.width * mGlobalScale + .5f);
    }
 else {
      w=mAttrs.width;
    }
    if (mAttrs.height < 0) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mAttrs.height * mGlobalScale + .5f);
    }
 else {
      h=mAttrs.height;
    }
  }
 else {
    if (mAttrs.width == WindowManager.LayoutParams.MATCH_PARENT) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mRequestedWidth * mGlobalScale + .5f);
    }
 else {
      w=mRequestedWidth;
    }
    if (mAttrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mRequestedHeight * mGlobalScale + .5f);
    }
 else {
      h=mRequestedHeight;
    }
  }
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  final Rect overscan=mOverscanFrame;
  overscan.set(of);
  final Rect content=mContentFrame;
  content.set(cf);
  final Rect visible=mVisibleFrame;
  visible.set(vf);
  final Rect frame=mFrame;
  final int fw=frame.width();
  final int fh=frame.height();
  float x, y;
  if (mEnforceSizeCompat) {
    x=mAttrs.x * mGlobalScale;
    y=mAttrs.y * mGlobalScale;
  }
 else {
    x=mAttrs.x;
    y=mAttrs.y;
  }
  Gravity.apply(mAttrs.gravity,w,h,container,(int)(x + mAttrs.horizontalMargin * pw),(int)(y + mAttrs.verticalMargin * ph),frame);
  Gravity.applyDisplay(mAttrs.gravity,df,frame);
  if (content.left < frame.left)   content.left=frame.left;
  if (content.top < frame.top)   content.top=frame.top;
  if (content.right > frame.right)   content.right=frame.right;
  if (content.bottom > frame.bottom)   content.bottom=frame.bottom;
  if (visible.left < frame.left)   visible.left=frame.left;
  if (visible.top < frame.top)   visible.top=frame.top;
  if (visible.right > frame.right)   visible.right=frame.right;
  if (visible.bottom > frame.bottom)   visible.bottom=frame.bottom;
  final Rect overscanInsets=mOverscanInsets;
  overscanInsets.left=overscan.left > frame.left ? overscan.left - frame.left : 0;
  overscanInsets.top=overscan.top > frame.top ? overscan.top - frame.top : 0;
  overscanInsets.right=overscan.right < frame.right ? frame.right - overscan.right : 0;
  overscanInsets.bottom=overscan.bottom < frame.bottom ? frame.bottom - overscan.bottom : 0;
  final Rect contentInsets=mContentInsets;
  contentInsets.left=content.left - frame.left;
  contentInsets.top=content.top - frame.top;
  contentInsets.right=frame.right - content.right;
  contentInsets.bottom=frame.bottom - content.bottom;
  final Rect visibleInsets=mVisibleInsets;
  visibleInsets.left=visible.left - frame.left;
  visibleInsets.top=visible.top - frame.top;
  visibleInsets.right=frame.right - visible.right;
  visibleInsets.bottom=frame.bottom - visible.bottom;
  mCompatFrame.set(frame);
  if (mEnforceSizeCompat) {
    overscanInsets.scale(mInvGlobalScale);
    contentInsets.scale(mInvGlobalScale);
    visibleInsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != frame.width() || fh != frame.height())) {
    final DisplayInfo displayInfo=mDisplayContent.getDisplayInfo();
    mService.updateWallpaperOffsetLocked(this,displayInfo.appWidth,displayInfo.appHeight,false);
  }
  if (WindowManagerService.localLOGV) {
    Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ contentInsets.toShortString()+ ""String_Node_Str""+ visibleInsets.toShortString());
  }
}"
2033,"@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf){
  mHaveFrame=true;
  final Rect container=mContainingFrame;
  container.set(pf);
  final Rect display=mDisplayFrame;
  display.set(df);
  final int pw=container.right - container.left;
  final int ph=container.bottom - container.top;
  int w, h;
  if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0) {
    if (mAttrs.width < 0) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mAttrs.width * mGlobalScale + .5f);
    }
 else {
      w=mAttrs.width;
    }
    if (mAttrs.height < 0) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mAttrs.height * mGlobalScale + .5f);
    }
 else {
      h=mAttrs.height;
    }
  }
 else {
    if (mAttrs.width == WindowManager.LayoutParams.MATCH_PARENT) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mRequestedWidth * mGlobalScale + .5f);
    }
 else {
      w=mRequestedWidth;
    }
    if (mAttrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mRequestedHeight * mGlobalScale + .5f);
    }
 else {
      h=mRequestedHeight;
    }
  }
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  final Rect overscan=mOverscanFrame;
  overscan.set(of);
  final Rect content=mContentFrame;
  content.set(cf);
  final Rect visible=mVisibleFrame;
  visible.set(vf);
  final Rect frame=mFrame;
  final int fw=frame.width();
  final int fh=frame.height();
  float x, y;
  if (mEnforceSizeCompat) {
    x=mAttrs.x * mGlobalScale;
    y=mAttrs.y * mGlobalScale;
  }
 else {
    x=mAttrs.x;
    y=mAttrs.y;
  }
  Gravity.apply(mAttrs.gravity,w,h,container,(int)(x + mAttrs.horizontalMargin * pw),(int)(y + mAttrs.verticalMargin * ph),frame);
  Gravity.applyDisplay(mAttrs.gravity,df,frame);
  if (content.left < frame.left)   content.left=frame.left;
  if (content.top < frame.top)   content.top=frame.top;
  if (content.right > frame.right)   content.right=frame.right;
  if (content.bottom > frame.bottom)   content.bottom=frame.bottom;
  if (visible.left < frame.left)   visible.left=frame.left;
  if (visible.top < frame.top)   visible.top=frame.top;
  if (visible.right > frame.right)   visible.right=frame.right;
  if (visible.bottom > frame.bottom)   visible.bottom=frame.bottom;
  final Rect overscanInsets=mOverscanInsets;
  overscanInsets.left=overscan.left - frame.left;
  overscanInsets.top=overscan.top - frame.top;
  overscanInsets.right=frame.right - overscan.right;
  overscanInsets.bottom=frame.bottom - overscan.bottom;
  final Rect contentInsets=mContentInsets;
  contentInsets.left=content.left - frame.left;
  contentInsets.top=content.top - frame.top;
  contentInsets.right=frame.right - content.right;
  contentInsets.bottom=frame.bottom - content.bottom;
  final Rect visibleInsets=mVisibleInsets;
  visibleInsets.left=visible.left - frame.left;
  visibleInsets.top=visible.top - frame.top;
  visibleInsets.right=frame.right - visible.right;
  visibleInsets.bottom=frame.bottom - visible.bottom;
  mCompatFrame.set(frame);
  if (mEnforceSizeCompat) {
    overscanInsets.scale(mInvGlobalScale);
    contentInsets.scale(mInvGlobalScale);
    visibleInsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != frame.width() || fh != frame.height())) {
    final DisplayInfo displayInfo=mDisplayContent.getDisplayInfo();
    mService.updateWallpaperOffsetLocked(this,displayInfo.appWidth,displayInfo.appHeight,false);
  }
  if (WindowManagerService.localLOGV) {
    Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ contentInsets.toShortString()+ ""String_Node_Str""+ visibleInsets.toShortString());
  }
}","@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf){
  mHaveFrame=true;
  final Rect container=mContainingFrame;
  container.set(pf);
  final Rect display=mDisplayFrame;
  display.set(df);
  final int pw=container.right - container.left;
  final int ph=container.bottom - container.top;
  int w, h;
  if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0) {
    if (mAttrs.width < 0) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mAttrs.width * mGlobalScale + .5f);
    }
 else {
      w=mAttrs.width;
    }
    if (mAttrs.height < 0) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mAttrs.height * mGlobalScale + .5f);
    }
 else {
      h=mAttrs.height;
    }
  }
 else {
    if (mAttrs.width == WindowManager.LayoutParams.MATCH_PARENT) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mRequestedWidth * mGlobalScale + .5f);
    }
 else {
      w=mRequestedWidth;
    }
    if (mAttrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mRequestedHeight * mGlobalScale + .5f);
    }
 else {
      h=mRequestedHeight;
    }
  }
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  final Rect overscan=mOverscanFrame;
  overscan.set(of);
  final Rect content=mContentFrame;
  content.set(cf);
  final Rect visible=mVisibleFrame;
  visible.set(vf);
  final Rect frame=mFrame;
  final int fw=frame.width();
  final int fh=frame.height();
  float x, y;
  if (mEnforceSizeCompat) {
    x=mAttrs.x * mGlobalScale;
    y=mAttrs.y * mGlobalScale;
  }
 else {
    x=mAttrs.x;
    y=mAttrs.y;
  }
  Gravity.apply(mAttrs.gravity,w,h,container,(int)(x + mAttrs.horizontalMargin * pw),(int)(y + mAttrs.verticalMargin * ph),frame);
  Gravity.applyDisplay(mAttrs.gravity,df,frame);
  if (content.left < frame.left)   content.left=frame.left;
  if (content.top < frame.top)   content.top=frame.top;
  if (content.right > frame.right)   content.right=frame.right;
  if (content.bottom > frame.bottom)   content.bottom=frame.bottom;
  if (visible.left < frame.left)   visible.left=frame.left;
  if (visible.top < frame.top)   visible.top=frame.top;
  if (visible.right > frame.right)   visible.right=frame.right;
  if (visible.bottom > frame.bottom)   visible.bottom=frame.bottom;
  final Rect overscanInsets=mOverscanInsets;
  overscanInsets.left=overscan.left > frame.left ? overscan.left - frame.left : 0;
  overscanInsets.top=overscan.top > frame.top ? overscan.top - frame.top : 0;
  overscanInsets.right=overscan.right < frame.right ? frame.right - overscan.right : 0;
  overscanInsets.bottom=overscan.bottom < frame.bottom ? frame.bottom - overscan.bottom : 0;
  final Rect contentInsets=mContentInsets;
  contentInsets.left=content.left - frame.left;
  contentInsets.top=content.top - frame.top;
  contentInsets.right=frame.right - content.right;
  contentInsets.bottom=frame.bottom - content.bottom;
  final Rect visibleInsets=mVisibleInsets;
  visibleInsets.left=visible.left - frame.left;
  visibleInsets.top=visible.top - frame.top;
  visibleInsets.right=frame.right - visible.right;
  visibleInsets.bottom=frame.bottom - visible.bottom;
  mCompatFrame.set(frame);
  if (mEnforceSizeCompat) {
    overscanInsets.scale(mInvGlobalScale);
    contentInsets.scale(mInvGlobalScale);
    visibleInsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != frame.width() || fh != frame.height())) {
    final DisplayInfo displayInfo=mDisplayContent.getDisplayInfo();
    mService.updateWallpaperOffsetLocked(this,displayInfo.appWidth,displayInfo.appHeight,false);
  }
  if (WindowManagerService.localLOGV) {
    Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ contentInsets.toShortString()+ ""String_Node_Str""+ visibleInsets.toShortString());
  }
}"
2034,"/** 
 * Replace existing canvas while ensuring that the swap has occurred before the previous native canvas is unreferenced.
 */
private void safeCanvasSwap(int nativeCanvas){
  final int oldCanvas=mNativeCanvas;
  mNativeCanvas=nativeCanvas;
  mFinalizer.mNativeCanvas=nativeCanvas;
  copyNativeCanvasState(oldCanvas,mNativeCanvas);
  finalizer(oldCanvas);
}","/** 
 * Replace existing canvas while ensuring that the swap has occurred before the previous native canvas is unreferenced.
 */
private void safeCanvasSwap(int nativeCanvas,boolean copyState){
  final int oldCanvas=mNativeCanvas;
  mNativeCanvas=nativeCanvas;
  mFinalizer.mNativeCanvas=nativeCanvas;
  if (copyState) {
    copyNativeCanvasState(oldCanvas,mNativeCanvas);
  }
  finalizer(oldCanvas);
}"
2035,"/** 
 * Specify a bitmap for the canvas to draw into. As a side-effect, the canvas' target density is updated to match that of the bitmap while all other state such as the layers, filters, matrix, and clip are reset.
 * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
 * @see #setDensity(int)
 * @see #getDensity()
 */
public void setBitmap(Bitmap bitmap){
  if (isHardwareAccelerated()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (bitmap == null) {
    safeCanvasSwap(initRaster(0));
    mDensity=Bitmap.DENSITY_NONE;
  }
 else {
    if (!bitmap.isMutable()) {
      throw new IllegalStateException();
    }
    throwIfRecycled(bitmap);
    safeCanvasSwap(initRaster(bitmap.ni()));
    mDensity=bitmap.mDensity;
  }
  mBitmap=bitmap;
}","/** 
 * Specify a bitmap for the canvas to draw into. All canvas state such as  layers, filters, and the save/restore stack are reset with the exception of the current matrix and clip stack. Additionally, as a side-effect the canvas' target density is updated to match that of the bitmap.
 * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
 * @see #setDensity(int)
 * @see #getDensity()
 */
public void setBitmap(Bitmap bitmap){
  if (isHardwareAccelerated()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (bitmap == null) {
    safeCanvasSwap(initRaster(0),false);
    mDensity=Bitmap.DENSITY_NONE;
  }
 else {
    if (!bitmap.isMutable()) {
      throw new IllegalStateException();
    }
    throwIfRecycled(bitmap);
    safeCanvasSwap(initRaster(bitmap.ni()),true);
    mDensity=bitmap.mDensity;
  }
  mBitmap=bitmap;
}"
2036,"/** 
 * Replace existing canvas while ensuring that the swap has occurred before the previous native canvas is unreferenced.
 */
private void safeCanvasSwap(int nativeCanvas){
  final int oldCanvas=mNativeCanvas;
  mNativeCanvas=nativeCanvas;
  mFinalizer.mNativeCanvas=nativeCanvas;
  copyNativeCanvasState(oldCanvas,mNativeCanvas);
  finalizer(oldCanvas);
}","/** 
 * Replace existing canvas while ensuring that the swap has occurred before the previous native canvas is unreferenced.
 */
private void safeCanvasSwap(int nativeCanvas,boolean copyState){
  final int oldCanvas=mNativeCanvas;
  mNativeCanvas=nativeCanvas;
  mFinalizer.mNativeCanvas=nativeCanvas;
  if (copyState) {
    copyNativeCanvasState(oldCanvas,mNativeCanvas);
  }
  finalizer(oldCanvas);
}"
2037,"/** 
 * Specify a bitmap for the canvas to draw into. As a side-effect, the canvas' target density is updated to match that of the bitmap while all other state such as the layers, filters, matrix, and clip are reset.
 * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
 * @see #setDensity(int)
 * @see #getDensity()
 */
public void setBitmap(Bitmap bitmap){
  if (isHardwareAccelerated()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (bitmap == null) {
    safeCanvasSwap(initRaster(0));
    mDensity=Bitmap.DENSITY_NONE;
  }
 else {
    if (!bitmap.isMutable()) {
      throw new IllegalStateException();
    }
    throwIfRecycled(bitmap);
    safeCanvasSwap(initRaster(bitmap.ni()));
    mDensity=bitmap.mDensity;
  }
  mBitmap=bitmap;
}","/** 
 * Specify a bitmap for the canvas to draw into. All canvas state such as  layers, filters, and the save/restore stack are reset with the exception of the current matrix and clip stack. Additionally, as a side-effect the canvas' target density is updated to match that of the bitmap.
 * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
 * @see #setDensity(int)
 * @see #getDensity()
 */
public void setBitmap(Bitmap bitmap){
  if (isHardwareAccelerated()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (bitmap == null) {
    safeCanvasSwap(initRaster(0),false);
    mDensity=Bitmap.DENSITY_NONE;
  }
 else {
    if (!bitmap.isMutable()) {
      throw new IllegalStateException();
    }
    throwIfRecycled(bitmap);
    safeCanvasSwap(initRaster(bitmap.ni()),true);
    mDensity=bitmap.mDensity;
  }
  mBitmap=bitmap;
}"
2038,"@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf){
  mHaveFrame=true;
  final Rect container=mContainingFrame;
  container.set(pf);
  final Rect display=mDisplayFrame;
  display.set(df);
  final int pw=container.right - container.left;
  final int ph=container.bottom - container.top;
  int w, h;
  if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0) {
    if (mAttrs.width < 0) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mAttrs.width * mGlobalScale + .5f);
    }
 else {
      w=mAttrs.width;
    }
    if (mAttrs.height < 0) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mAttrs.height * mGlobalScale + .5f);
    }
 else {
      h=mAttrs.height;
    }
  }
 else {
    if (mAttrs.width == WindowManager.LayoutParams.MATCH_PARENT) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mRequestedWidth * mGlobalScale + .5f);
    }
 else {
      w=mRequestedWidth;
    }
    if (mAttrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mRequestedHeight * mGlobalScale + .5f);
    }
 else {
      h=mRequestedHeight;
    }
  }
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  final Rect overscan=mOverscanFrame;
  overscan.set(of);
  final Rect content=mContentFrame;
  content.set(cf);
  final Rect visible=mVisibleFrame;
  visible.set(vf);
  final Rect frame=mFrame;
  final int fw=frame.width();
  final int fh=frame.height();
  float x, y;
  if (mEnforceSizeCompat) {
    x=mAttrs.x * mGlobalScale;
    y=mAttrs.y * mGlobalScale;
  }
 else {
    x=mAttrs.x;
    y=mAttrs.y;
  }
  Gravity.apply(mAttrs.gravity,w,h,container,(int)(x + mAttrs.horizontalMargin * pw),(int)(y + mAttrs.verticalMargin * ph),frame);
  Gravity.applyDisplay(mAttrs.gravity,df,frame);
  if (content.left < frame.left)   content.left=frame.left;
  if (content.top < frame.top)   content.top=frame.top;
  if (content.right > frame.right)   content.right=frame.right;
  if (content.bottom > frame.bottom)   content.bottom=frame.bottom;
  if (visible.left < frame.left)   visible.left=frame.left;
  if (visible.top < frame.top)   visible.top=frame.top;
  if (visible.right > frame.right)   visible.right=frame.right;
  if (visible.bottom > frame.bottom)   visible.bottom=frame.bottom;
  final Rect overscanInsets=mOverscanInsets;
  overscanInsets.left=overscan.left - frame.left;
  overscanInsets.top=overscan.top - frame.top;
  overscanInsets.right=frame.right - overscan.right;
  overscanInsets.bottom=frame.bottom - overscan.bottom;
  final Rect contentInsets=mContentInsets;
  contentInsets.left=content.left - frame.left;
  contentInsets.top=content.top - frame.top;
  contentInsets.right=frame.right - content.right;
  contentInsets.bottom=frame.bottom - content.bottom;
  final Rect visibleInsets=mVisibleInsets;
  visibleInsets.left=visible.left - frame.left;
  visibleInsets.top=visible.top - frame.top;
  visibleInsets.right=frame.right - visible.right;
  visibleInsets.bottom=frame.bottom - visible.bottom;
  mCompatFrame.set(frame);
  if (mEnforceSizeCompat) {
    overscanInsets.scale(mInvGlobalScale);
    contentInsets.scale(mInvGlobalScale);
    visibleInsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != frame.width() || fh != frame.height())) {
    final DisplayInfo displayInfo=mDisplayContent.getDisplayInfo();
    mService.updateWallpaperOffsetLocked(this,displayInfo.appWidth,displayInfo.appHeight,false);
  }
  if (WindowManagerService.localLOGV) {
    Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ contentInsets.toShortString()+ ""String_Node_Str""+ visibleInsets.toShortString());
  }
}","@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf){
  mHaveFrame=true;
  final Rect container=mContainingFrame;
  container.set(pf);
  final Rect display=mDisplayFrame;
  display.set(df);
  final int pw=container.right - container.left;
  final int ph=container.bottom - container.top;
  int w, h;
  if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0) {
    if (mAttrs.width < 0) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mAttrs.width * mGlobalScale + .5f);
    }
 else {
      w=mAttrs.width;
    }
    if (mAttrs.height < 0) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mAttrs.height * mGlobalScale + .5f);
    }
 else {
      h=mAttrs.height;
    }
  }
 else {
    if (mAttrs.width == WindowManager.LayoutParams.MATCH_PARENT) {
      w=pw;
    }
 else     if (mEnforceSizeCompat) {
      w=(int)(mRequestedWidth * mGlobalScale + .5f);
    }
 else {
      w=mRequestedWidth;
    }
    if (mAttrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      h=ph;
    }
 else     if (mEnforceSizeCompat) {
      h=(int)(mRequestedHeight * mGlobalScale + .5f);
    }
 else {
      h=mRequestedHeight;
    }
  }
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  final Rect overscan=mOverscanFrame;
  overscan.set(of);
  final Rect content=mContentFrame;
  content.set(cf);
  final Rect visible=mVisibleFrame;
  visible.set(vf);
  final Rect frame=mFrame;
  final int fw=frame.width();
  final int fh=frame.height();
  float x, y;
  if (mEnforceSizeCompat) {
    x=mAttrs.x * mGlobalScale;
    y=mAttrs.y * mGlobalScale;
  }
 else {
    x=mAttrs.x;
    y=mAttrs.y;
  }
  Gravity.apply(mAttrs.gravity,w,h,container,(int)(x + mAttrs.horizontalMargin * pw),(int)(y + mAttrs.verticalMargin * ph),frame);
  Gravity.applyDisplay(mAttrs.gravity,df,frame);
  if (content.left < frame.left)   content.left=frame.left;
  if (content.top < frame.top)   content.top=frame.top;
  if (content.right > frame.right)   content.right=frame.right;
  if (content.bottom > frame.bottom)   content.bottom=frame.bottom;
  if (visible.left < frame.left)   visible.left=frame.left;
  if (visible.top < frame.top)   visible.top=frame.top;
  if (visible.right > frame.right)   visible.right=frame.right;
  if (visible.bottom > frame.bottom)   visible.bottom=frame.bottom;
  final Rect overscanInsets=mOverscanInsets;
  overscanInsets.left=overscan.left > frame.left ? overscan.left - frame.left : 0;
  overscanInsets.top=overscan.top > frame.top ? overscan.top - frame.top : 0;
  overscanInsets.right=overscan.right < frame.right ? frame.right - overscan.right : 0;
  overscanInsets.bottom=overscan.bottom < frame.bottom ? frame.bottom - overscan.bottom : 0;
  final Rect contentInsets=mContentInsets;
  contentInsets.left=content.left - frame.left;
  contentInsets.top=content.top - frame.top;
  contentInsets.right=frame.right - content.right;
  contentInsets.bottom=frame.bottom - content.bottom;
  final Rect visibleInsets=mVisibleInsets;
  visibleInsets.left=visible.left - frame.left;
  visibleInsets.top=visible.top - frame.top;
  visibleInsets.right=frame.right - visible.right;
  visibleInsets.bottom=frame.bottom - visible.bottom;
  mCompatFrame.set(frame);
  if (mEnforceSizeCompat) {
    overscanInsets.scale(mInvGlobalScale);
    contentInsets.scale(mInvGlobalScale);
    visibleInsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != frame.width() || fh != frame.height())) {
    final DisplayInfo displayInfo=mDisplayContent.getDisplayInfo();
    mService.updateWallpaperOffsetLocked(this,displayInfo.appWidth,displayInfo.appHeight,false);
  }
  if (WindowManagerService.localLOGV) {
    Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ contentInsets.toShortString()+ ""String_Node_Str""+ visibleInsets.toShortString());
  }
}"
2039,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mCompatibilityInfo.get();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.flags&=~WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
      desiredWindowWidth=packageMetrics.widthPixels;
      desiredWindowHeight=packageMetrics.heightPixels;
    }
    attachInfo.mSurface=mSurface;
    attachInfo.mUse32BitDrawingCache=true;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(attachInfo,0);
    attachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  getRunQueue().executeActions(attachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && !mStopped;
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          DisplayMetrics packageMetrics=res.getDisplayMetrics();
          desiredWindowWidth=packageMetrics.widthPixels;
          desiredWindowHeight=packageMetrics.heightPixels;
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (attachInfo.mForceReportNewAttributes) {
    attachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mFitSystemWindowsRequested) {
    mFitSystemWindowsRequested=false;
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    host.fitSystemWindows(mFitSystemWindowsInsets);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      mWindowsAnimating|=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        if (mWidth > 0 && mHeight > 0 && lp != null && ((lp.systemUiVisibility | lp.subtreeSystemUiVisibility) & View.SYSTEM_UI_LAYOUT_FLAGS) == 0 && mSurface != null && mSurface.isValid() && !mAttachInfo.mTurnOffWindowResizeAnim && mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled() && mAttachInfo.mHardwareRenderer.validate() && lp != null && !PixelFormat.formatHasAlpha(lp.format)) {
          disposeResizeBuffer();
          boolean completed=false;
          HardwareCanvas hwRendererCanvas=mAttachInfo.mHardwareRenderer.getCanvas();
          HardwareCanvas layerCanvas=null;
          try {
            if (mResizeBuffer == null) {
              mResizeBuffer=mAttachInfo.mHardwareRenderer.createHardwareLayer(mWidth,mHeight,false);
            }
 else             if (mResizeBuffer.getWidth() != mWidth || mResizeBuffer.getHeight() != mHeight) {
              mResizeBuffer.resize(mWidth,mHeight);
            }
            layerCanvas=mResizeBuffer.start(hwRendererCanvas);
            final int restoreCount=layerCanvas.save();
            int yoff;
            final boolean scrolling=mScroller != null && mScroller.computeScrollOffset();
            if (scrolling) {
              yoff=mScroller.getCurrY();
              mScroller.abortAnimation();
            }
 else {
              yoff=mScrollY;
            }
            layerCanvas.translate(0,-yoff);
            if (mTranslator != null) {
              mTranslator.translateCanvas(layerCanvas);
            }
            DisplayList displayList=mView.mDisplayList;
            if (displayList != null) {
              layerCanvas.drawDisplayList(displayList,null,DisplayList.FLAG_CLIP_CHILDREN);
            }
 else {
              mView.draw(layerCanvas);
            }
            drawAccessibilityFocusedDrawableIfNeeded(layerCanvas);
            mResizeBufferStartTime=SystemClock.uptimeMillis();
            mResizeBufferDuration=mView.getResources().getInteger(com.android.internal.R.integer.config_mediumAnimTime);
            completed=true;
            layerCanvas.restoreToCount(restoreCount);
          }
 catch (          OutOfMemoryError e) {
            Log.w(TAG,""String_Node_Str"",e);
          }
 finally {
            if (mResizeBuffer != null) {
              mResizeBuffer.end(hwRendererCanvas);
              if (!completed) {
                mResizeBuffer.destroy();
                mResizeBuffer=null;
              }
            }
          }
        }
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mFitSystemWindowsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mFitSystemWindowsRequested=false;
        mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
        host.fitSystemWindows(mFitSystemWindowsInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mHolder.getSurface());
            }
 catch (            Surface.OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        disposeResizeBuffer();
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy(true);
        }
      }
 else       if (surfaceGenerationId != mSurface.getGenerationId() && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mHolder.getSurface());
        }
 catch (        Surface.OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      if (hwInitialized || windowShouldResize || mWidth != mAttachInfo.mHardwareRenderer.getWidth() || mHeight != mAttachInfo.mHardwareRenderer.getHeight()) {
        mAttachInfo.mHardwareRenderer.setup(mWidth,mHeight);
        if (!hwInitialized) {
          mAttachInfo.mHardwareRenderer.invalidate(mHolder.getSurface());
          mFullRedrawNeeded=true;
        }
      }
    }
    if (!mStopped) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    final boolean windowMoved=(attachInfo.mWindowLeft != frame.left || attachInfo.mWindowTop != frame.top);
    if (windowMoved) {
      if (mTranslator != null) {
        mTranslator.translateRectInScreenToAppWinFrame(frame);
      }
      attachInfo.mWindowLeft=frame.left;
      attachInfo.mWindowTop=frame.top;
    }
  }
  final boolean didLayout=layoutRequested && !mStopped;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,desiredWindowWidth,desiredWindowHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
    if (AccessibilityManager.getInstance(host.mContext).isEnabled()) {
      postSendWindowContentChangedCallback(mView);
    }
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    insets.reset();
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  boolean skipDraw=false;
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
    }
    if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0) {
      mWindowsAnimating=true;
    }
  }
 else   if (mWindowsAnimating) {
    skipDraw=true;
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE;
  if (!cancelDraw && !newSurface) {
    if (!skipDraw || mReportNextDraw) {
      if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
        for (int i=0; i < mPendingTransitions.size(); ++i) {
          mPendingTransitions.get(i).startChangingAnimations();
        }
        mPendingTransitions.clear();
      }
      performDraw();
    }
  }
 else {
    if (viewVisibility == View.VISIBLE) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mCompatibilityInfo.get();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.flags&=~WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
      desiredWindowWidth=packageMetrics.widthPixels;
      desiredWindowHeight=packageMetrics.heightPixels;
    }
    attachInfo.mSurface=mSurface;
    attachInfo.mUse32BitDrawingCache=true;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(attachInfo,0);
    attachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  getRunQueue().executeActions(attachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && !mStopped;
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          DisplayMetrics packageMetrics=res.getDisplayMetrics();
          desiredWindowWidth=packageMetrics.widthPixels;
          desiredWindowHeight=packageMetrics.heightPixels;
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (attachInfo.mForceReportNewAttributes) {
    attachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mFitSystemWindowsRequested) {
    mFitSystemWindowsRequested=false;
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    host.fitSystemWindows(mFitSystemWindowsInsets);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (!mDrawDuringWindowsAnimating) {
        mWindowsAnimating|=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        if (mWidth > 0 && mHeight > 0 && lp != null && ((lp.systemUiVisibility | lp.subtreeSystemUiVisibility) & View.SYSTEM_UI_LAYOUT_FLAGS) == 0 && mSurface != null && mSurface.isValid() && !mAttachInfo.mTurnOffWindowResizeAnim && mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled() && mAttachInfo.mHardwareRenderer.validate() && lp != null && !PixelFormat.formatHasAlpha(lp.format)) {
          disposeResizeBuffer();
          boolean completed=false;
          HardwareCanvas hwRendererCanvas=mAttachInfo.mHardwareRenderer.getCanvas();
          HardwareCanvas layerCanvas=null;
          try {
            if (mResizeBuffer == null) {
              mResizeBuffer=mAttachInfo.mHardwareRenderer.createHardwareLayer(mWidth,mHeight,false);
            }
 else             if (mResizeBuffer.getWidth() != mWidth || mResizeBuffer.getHeight() != mHeight) {
              mResizeBuffer.resize(mWidth,mHeight);
            }
            layerCanvas=mResizeBuffer.start(hwRendererCanvas);
            final int restoreCount=layerCanvas.save();
            int yoff;
            final boolean scrolling=mScroller != null && mScroller.computeScrollOffset();
            if (scrolling) {
              yoff=mScroller.getCurrY();
              mScroller.abortAnimation();
            }
 else {
              yoff=mScrollY;
            }
            layerCanvas.translate(0,-yoff);
            if (mTranslator != null) {
              mTranslator.translateCanvas(layerCanvas);
            }
            DisplayList displayList=mView.mDisplayList;
            if (displayList != null) {
              layerCanvas.drawDisplayList(displayList,null,DisplayList.FLAG_CLIP_CHILDREN);
            }
 else {
              mView.draw(layerCanvas);
            }
            drawAccessibilityFocusedDrawableIfNeeded(layerCanvas);
            mResizeBufferStartTime=SystemClock.uptimeMillis();
            mResizeBufferDuration=mView.getResources().getInteger(com.android.internal.R.integer.config_mediumAnimTime);
            completed=true;
            layerCanvas.restoreToCount(restoreCount);
          }
 catch (          OutOfMemoryError e) {
            Log.w(TAG,""String_Node_Str"",e);
          }
 finally {
            if (mResizeBuffer != null) {
              mResizeBuffer.end(hwRendererCanvas);
              if (!completed) {
                mResizeBuffer.destroy();
                mResizeBuffer=null;
              }
            }
          }
        }
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mFitSystemWindowsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mFitSystemWindowsRequested=false;
        mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
        host.fitSystemWindows(mFitSystemWindowsInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mHolder.getSurface());
            }
 catch (            Surface.OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        disposeResizeBuffer();
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy(true);
        }
      }
 else       if (surfaceGenerationId != mSurface.getGenerationId() && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mHolder.getSurface());
        }
 catch (        Surface.OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      if (hwInitialized || windowShouldResize || mWidth != mAttachInfo.mHardwareRenderer.getWidth() || mHeight != mAttachInfo.mHardwareRenderer.getHeight()) {
        mAttachInfo.mHardwareRenderer.setup(mWidth,mHeight);
        if (!hwInitialized) {
          mAttachInfo.mHardwareRenderer.invalidate(mHolder.getSurface());
          mFullRedrawNeeded=true;
        }
      }
    }
    if (!mStopped) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    final boolean windowMoved=(attachInfo.mWindowLeft != frame.left || attachInfo.mWindowTop != frame.top);
    if (windowMoved) {
      if (mTranslator != null) {
        mTranslator.translateRectInScreenToAppWinFrame(frame);
      }
      attachInfo.mWindowLeft=frame.left;
      attachInfo.mWindowTop=frame.top;
    }
  }
  final boolean didLayout=layoutRequested && !mStopped;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,desiredWindowWidth,desiredWindowHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
    if (AccessibilityManager.getInstance(host.mContext).isEnabled()) {
      postSendWindowContentChangedCallback(mView);
    }
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    insets.reset();
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  boolean skipDraw=false;
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
    }
    if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0) {
      mWindowsAnimating=true;
    }
  }
 else   if (mWindowsAnimating) {
    skipDraw=true;
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE;
  if (!cancelDraw && !newSurface) {
    if (!skipDraw || mReportNextDraw) {
      if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
        for (int i=0; i < mPendingTransitions.size(); ++i) {
          mPendingTransitions.get(i).startChangingAnimations();
        }
        mPendingTransitions.clear();
      }
      performDraw();
    }
  }
 else {
    if (viewVisibility == View.VISIBLE) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}"
2040,"private void animateInIconOfFirstTask(){
  if (mItemToAnimateInWhenWindowAnimationIsFinished != null && !mRecentTasksLoader.isFirstScreenful()) {
    int timeSinceWindowAnimation=(int)(System.currentTimeMillis() - mWindowAnimationStartTime);
    final int minStartDelay=125;
    final int startDelay=Math.max(0,Math.min(minStartDelay - timeSinceWindowAnimation,minStartDelay));
    final int duration=250;
    final ViewHolder holder=mItemToAnimateInWhenWindowAnimationIsFinished;
    final TimeInterpolator cubic=new DecelerateInterpolator(1.5f);
    FirstFrameAnimatorHelper.initializeDrawListener(holder.iconView);
    for (    View v : new View[]{holder.iconView,holder.labelView,holder.calloutLine}) {
      if (v != null) {
        ViewPropertyAnimator vpa=v.animate().translationX(0).translationY(0).alpha(1f).setStartDelay(startDelay).setDuration(duration).setInterpolator(cubic);
        FirstFrameAnimatorHelper h=new FirstFrameAnimatorHelper(vpa,v);
      }
    }
    mItemToAnimateInWhenWindowAnimationIsFinished=null;
    mAnimateIconOfFirstTask=false;
  }
}","private void animateInIconOfFirstTask(){
  if (mItemToAnimateInWhenWindowAnimationIsFinished != null && !mRecentTasksLoader.isFirstScreenful()) {
    int timeSinceWindowAnimation=(int)(System.currentTimeMillis() - mWindowAnimationStartTime);
    final int minStartDelay=150;
    final int startDelay=Math.max(0,Math.min(minStartDelay - timeSinceWindowAnimation,minStartDelay));
    final int duration=250;
    final ViewHolder holder=mItemToAnimateInWhenWindowAnimationIsFinished;
    final TimeInterpolator cubic=new DecelerateInterpolator(1.5f);
    FirstFrameAnimatorHelper.initializeDrawListener(holder.iconView);
    for (    View v : new View[]{holder.iconView,holder.labelView,holder.calloutLine}) {
      if (v != null) {
        ViewPropertyAnimator vpa=v.animate().translationX(0).translationY(0).alpha(1f).setStartDelay(startDelay).setDuration(duration).setInterpolator(cubic);
        FirstFrameAnimatorHelper h=new FirstFrameAnimatorHelper(vpa,v);
      }
    }
    mItemToAnimateInWhenWindowAnimationIsFinished=null;
    mAnimateIconOfFirstTask=false;
  }
}"
2041,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mCompatibilityInfo.get();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.flags&=~WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
      desiredWindowWidth=packageMetrics.widthPixels;
      desiredWindowHeight=packageMetrics.heightPixels;
    }
    attachInfo.mSurface=mSurface;
    attachInfo.mUse32BitDrawingCache=true;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(attachInfo,0);
    attachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  getRunQueue().executeActions(attachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && !mStopped;
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          DisplayMetrics packageMetrics=res.getDisplayMetrics();
          desiredWindowWidth=packageMetrics.widthPixels;
          desiredWindowHeight=packageMetrics.heightPixels;
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (attachInfo.mForceReportNewAttributes) {
    attachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mFitSystemWindowsRequested) {
    mFitSystemWindowsRequested=false;
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    host.fitSystemWindows(mFitSystemWindowsInsets);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      mWindowsAnimating|=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        if (mWidth > 0 && mHeight > 0 && lp != null && ((lp.systemUiVisibility | lp.subtreeSystemUiVisibility) & View.SYSTEM_UI_LAYOUT_FLAGS) == 0 && mSurface != null && mSurface.isValid() && !mAttachInfo.mTurnOffWindowResizeAnim && mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled() && mAttachInfo.mHardwareRenderer.validate() && lp != null && !PixelFormat.formatHasAlpha(lp.format)) {
          disposeResizeBuffer();
          boolean completed=false;
          HardwareCanvas hwRendererCanvas=mAttachInfo.mHardwareRenderer.getCanvas();
          HardwareCanvas layerCanvas=null;
          try {
            if (mResizeBuffer == null) {
              mResizeBuffer=mAttachInfo.mHardwareRenderer.createHardwareLayer(mWidth,mHeight,false);
            }
 else             if (mResizeBuffer.getWidth() != mWidth || mResizeBuffer.getHeight() != mHeight) {
              mResizeBuffer.resize(mWidth,mHeight);
            }
            layerCanvas=mResizeBuffer.start(hwRendererCanvas);
            final int restoreCount=layerCanvas.save();
            int yoff;
            final boolean scrolling=mScroller != null && mScroller.computeScrollOffset();
            if (scrolling) {
              yoff=mScroller.getCurrY();
              mScroller.abortAnimation();
            }
 else {
              yoff=mScrollY;
            }
            layerCanvas.translate(0,-yoff);
            if (mTranslator != null) {
              mTranslator.translateCanvas(layerCanvas);
            }
            DisplayList displayList=mView.mDisplayList;
            if (displayList != null) {
              layerCanvas.drawDisplayList(displayList,null,DisplayList.FLAG_CLIP_CHILDREN);
            }
 else {
              mView.draw(layerCanvas);
            }
            drawAccessibilityFocusedDrawableIfNeeded(layerCanvas);
            mResizeBufferStartTime=SystemClock.uptimeMillis();
            mResizeBufferDuration=mView.getResources().getInteger(com.android.internal.R.integer.config_mediumAnimTime);
            completed=true;
            layerCanvas.restoreToCount(restoreCount);
          }
 catch (          OutOfMemoryError e) {
            Log.w(TAG,""String_Node_Str"",e);
          }
 finally {
            if (mResizeBuffer != null) {
              mResizeBuffer.end(hwRendererCanvas);
              if (!completed) {
                mResizeBuffer.destroy();
                mResizeBuffer=null;
              }
            }
          }
        }
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mFitSystemWindowsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mFitSystemWindowsRequested=false;
        mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
        host.fitSystemWindows(mFitSystemWindowsInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mHolder.getSurface());
            }
 catch (            Surface.OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        disposeResizeBuffer();
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy(true);
        }
      }
 else       if (surfaceGenerationId != mSurface.getGenerationId() && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mHolder.getSurface());
        }
 catch (        Surface.OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      if (hwInitialized || windowShouldResize || mWidth != mAttachInfo.mHardwareRenderer.getWidth() || mHeight != mAttachInfo.mHardwareRenderer.getHeight()) {
        mAttachInfo.mHardwareRenderer.setup(mWidth,mHeight);
        if (!hwInitialized) {
          mAttachInfo.mHardwareRenderer.invalidate(mHolder.getSurface());
          mFullRedrawNeeded=true;
        }
      }
    }
    if (!mStopped) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    final boolean windowMoved=(attachInfo.mWindowLeft != frame.left || attachInfo.mWindowTop != frame.top);
    if (windowMoved) {
      if (mTranslator != null) {
        mTranslator.translateRectInScreenToAppWinFrame(frame);
      }
      attachInfo.mWindowLeft=frame.left;
      attachInfo.mWindowTop=frame.top;
    }
  }
  final boolean didLayout=layoutRequested && !mStopped;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,desiredWindowWidth,desiredWindowHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
    if (AccessibilityManager.getInstance(host.mContext).isEnabled()) {
      postSendWindowContentChangedCallback(mView);
    }
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    insets.reset();
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  boolean skipDraw=false;
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
    }
    if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0) {
      mWindowsAnimating=true;
    }
  }
 else   if (mWindowsAnimating) {
    skipDraw=true;
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE;
  if (!cancelDraw && !newSurface) {
    if (!skipDraw || mReportNextDraw) {
      if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
        for (int i=0; i < mPendingTransitions.size(); ++i) {
          mPendingTransitions.get(i).startChangingAnimations();
        }
        mPendingTransitions.clear();
      }
      performDraw();
    }
  }
 else {
    if (viewVisibility == View.VISIBLE) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mCompatibilityInfo.get();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.flags&=~WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
      desiredWindowWidth=packageMetrics.widthPixels;
      desiredWindowHeight=packageMetrics.heightPixels;
    }
    attachInfo.mSurface=mSurface;
    attachInfo.mUse32BitDrawingCache=true;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(attachInfo,0);
    attachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  getRunQueue().executeActions(attachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && !mStopped;
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          DisplayMetrics packageMetrics=res.getDisplayMetrics();
          desiredWindowWidth=packageMetrics.widthPixels;
          desiredWindowHeight=packageMetrics.heightPixels;
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (attachInfo.mForceReportNewAttributes) {
    attachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mFitSystemWindowsRequested) {
    mFitSystemWindowsRequested=false;
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    host.fitSystemWindows(mFitSystemWindowsInsets);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (!mDrawDuringWindowsAnimating) {
        mWindowsAnimating|=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        if (mWidth > 0 && mHeight > 0 && lp != null && ((lp.systemUiVisibility | lp.subtreeSystemUiVisibility) & View.SYSTEM_UI_LAYOUT_FLAGS) == 0 && mSurface != null && mSurface.isValid() && !mAttachInfo.mTurnOffWindowResizeAnim && mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled() && mAttachInfo.mHardwareRenderer.validate() && lp != null && !PixelFormat.formatHasAlpha(lp.format)) {
          disposeResizeBuffer();
          boolean completed=false;
          HardwareCanvas hwRendererCanvas=mAttachInfo.mHardwareRenderer.getCanvas();
          HardwareCanvas layerCanvas=null;
          try {
            if (mResizeBuffer == null) {
              mResizeBuffer=mAttachInfo.mHardwareRenderer.createHardwareLayer(mWidth,mHeight,false);
            }
 else             if (mResizeBuffer.getWidth() != mWidth || mResizeBuffer.getHeight() != mHeight) {
              mResizeBuffer.resize(mWidth,mHeight);
            }
            layerCanvas=mResizeBuffer.start(hwRendererCanvas);
            final int restoreCount=layerCanvas.save();
            int yoff;
            final boolean scrolling=mScroller != null && mScroller.computeScrollOffset();
            if (scrolling) {
              yoff=mScroller.getCurrY();
              mScroller.abortAnimation();
            }
 else {
              yoff=mScrollY;
            }
            layerCanvas.translate(0,-yoff);
            if (mTranslator != null) {
              mTranslator.translateCanvas(layerCanvas);
            }
            DisplayList displayList=mView.mDisplayList;
            if (displayList != null) {
              layerCanvas.drawDisplayList(displayList,null,DisplayList.FLAG_CLIP_CHILDREN);
            }
 else {
              mView.draw(layerCanvas);
            }
            drawAccessibilityFocusedDrawableIfNeeded(layerCanvas);
            mResizeBufferStartTime=SystemClock.uptimeMillis();
            mResizeBufferDuration=mView.getResources().getInteger(com.android.internal.R.integer.config_mediumAnimTime);
            completed=true;
            layerCanvas.restoreToCount(restoreCount);
          }
 catch (          OutOfMemoryError e) {
            Log.w(TAG,""String_Node_Str"",e);
          }
 finally {
            if (mResizeBuffer != null) {
              mResizeBuffer.end(hwRendererCanvas);
              if (!completed) {
                mResizeBuffer.destroy();
                mResizeBuffer=null;
              }
            }
          }
        }
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mFitSystemWindowsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mFitSystemWindowsRequested=false;
        mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
        host.fitSystemWindows(mFitSystemWindowsInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mHolder.getSurface());
            }
 catch (            Surface.OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        disposeResizeBuffer();
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy(true);
        }
      }
 else       if (surfaceGenerationId != mSurface.getGenerationId() && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mHolder.getSurface());
        }
 catch (        Surface.OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      if (hwInitialized || windowShouldResize || mWidth != mAttachInfo.mHardwareRenderer.getWidth() || mHeight != mAttachInfo.mHardwareRenderer.getHeight()) {
        mAttachInfo.mHardwareRenderer.setup(mWidth,mHeight);
        if (!hwInitialized) {
          mAttachInfo.mHardwareRenderer.invalidate(mHolder.getSurface());
          mFullRedrawNeeded=true;
        }
      }
    }
    if (!mStopped) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    final boolean windowMoved=(attachInfo.mWindowLeft != frame.left || attachInfo.mWindowTop != frame.top);
    if (windowMoved) {
      if (mTranslator != null) {
        mTranslator.translateRectInScreenToAppWinFrame(frame);
      }
      attachInfo.mWindowLeft=frame.left;
      attachInfo.mWindowTop=frame.top;
    }
  }
  final boolean didLayout=layoutRequested && !mStopped;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,desiredWindowWidth,desiredWindowHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
    if (AccessibilityManager.getInstance(host.mContext).isEnabled()) {
      postSendWindowContentChangedCallback(mView);
    }
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    insets.reset();
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  boolean skipDraw=false;
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
    }
    if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0) {
      mWindowsAnimating=true;
    }
  }
 else   if (mWindowsAnimating) {
    skipDraw=true;
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE;
  if (!cancelDraw && !newSurface) {
    if (!skipDraw || mReportNextDraw) {
      if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
        for (int i=0; i < mPendingTransitions.size(); ++i) {
          mPendingTransitions.get(i).startChangingAnimations();
        }
        mPendingTransitions.clear();
      }
      performDraw();
    }
  }
 else {
    if (viewVisibility == View.VISIBLE) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}"
2042,"private void animateInIconOfFirstTask(){
  if (mItemToAnimateInWhenWindowAnimationIsFinished != null && !mRecentTasksLoader.isFirstScreenful()) {
    int timeSinceWindowAnimation=(int)(System.currentTimeMillis() - mWindowAnimationStartTime);
    final int minStartDelay=125;
    final int startDelay=Math.max(0,Math.min(minStartDelay - timeSinceWindowAnimation,minStartDelay));
    final int duration=250;
    final ViewHolder holder=mItemToAnimateInWhenWindowAnimationIsFinished;
    final TimeInterpolator cubic=new DecelerateInterpolator(1.5f);
    FirstFrameAnimatorHelper.initializeDrawListener(holder.iconView);
    for (    View v : new View[]{holder.iconView,holder.labelView,holder.calloutLine}) {
      if (v != null) {
        ViewPropertyAnimator vpa=v.animate().translationX(0).translationY(0).alpha(1f).setStartDelay(startDelay).setDuration(duration).setInterpolator(cubic);
        FirstFrameAnimatorHelper h=new FirstFrameAnimatorHelper(vpa,v);
      }
    }
    mItemToAnimateInWhenWindowAnimationIsFinished=null;
    mAnimateIconOfFirstTask=false;
  }
}","private void animateInIconOfFirstTask(){
  if (mItemToAnimateInWhenWindowAnimationIsFinished != null && !mRecentTasksLoader.isFirstScreenful()) {
    int timeSinceWindowAnimation=(int)(System.currentTimeMillis() - mWindowAnimationStartTime);
    final int minStartDelay=150;
    final int startDelay=Math.max(0,Math.min(minStartDelay - timeSinceWindowAnimation,minStartDelay));
    final int duration=250;
    final ViewHolder holder=mItemToAnimateInWhenWindowAnimationIsFinished;
    final TimeInterpolator cubic=new DecelerateInterpolator(1.5f);
    FirstFrameAnimatorHelper.initializeDrawListener(holder.iconView);
    for (    View v : new View[]{holder.iconView,holder.labelView,holder.calloutLine}) {
      if (v != null) {
        ViewPropertyAnimator vpa=v.animate().translationX(0).translationY(0).alpha(1f).setStartDelay(startDelay).setDuration(duration).setInterpolator(cubic);
        FirstFrameAnimatorHelper h=new FirstFrameAnimatorHelper(vpa,v);
      }
    }
    mItemToAnimateInWhenWindowAnimationIsFinished=null;
    mAnimateIconOfFirstTask=false;
  }
}"
2043,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mCompatibilityInfo.get();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.flags&=~WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
      desiredWindowWidth=packageMetrics.widthPixels;
      desiredWindowHeight=packageMetrics.heightPixels;
    }
    attachInfo.mSurface=mSurface;
    attachInfo.mUse32BitDrawingCache=true;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(attachInfo,0);
    attachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  getRunQueue().executeActions(attachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && !mStopped;
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          DisplayMetrics packageMetrics=res.getDisplayMetrics();
          desiredWindowWidth=packageMetrics.widthPixels;
          desiredWindowHeight=packageMetrics.heightPixels;
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (attachInfo.mForceReportNewAttributes) {
    attachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mFitSystemWindowsRequested) {
    mFitSystemWindowsRequested=false;
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    host.fitSystemWindows(mFitSystemWindowsInsets);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      mWindowsAnimating|=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        if (mWidth > 0 && mHeight > 0 && lp != null && ((lp.systemUiVisibility | lp.subtreeSystemUiVisibility) & View.SYSTEM_UI_LAYOUT_FLAGS) == 0 && mSurface != null && mSurface.isValid() && !mAttachInfo.mTurnOffWindowResizeAnim && mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled() && mAttachInfo.mHardwareRenderer.validate() && lp != null && !PixelFormat.formatHasAlpha(lp.format)) {
          disposeResizeBuffer();
          boolean completed=false;
          HardwareCanvas hwRendererCanvas=mAttachInfo.mHardwareRenderer.getCanvas();
          HardwareCanvas layerCanvas=null;
          try {
            if (mResizeBuffer == null) {
              mResizeBuffer=mAttachInfo.mHardwareRenderer.createHardwareLayer(mWidth,mHeight,false);
            }
 else             if (mResizeBuffer.getWidth() != mWidth || mResizeBuffer.getHeight() != mHeight) {
              mResizeBuffer.resize(mWidth,mHeight);
            }
            layerCanvas=mResizeBuffer.start(hwRendererCanvas);
            final int restoreCount=layerCanvas.save();
            int yoff;
            final boolean scrolling=mScroller != null && mScroller.computeScrollOffset();
            if (scrolling) {
              yoff=mScroller.getCurrY();
              mScroller.abortAnimation();
            }
 else {
              yoff=mScrollY;
            }
            layerCanvas.translate(0,-yoff);
            if (mTranslator != null) {
              mTranslator.translateCanvas(layerCanvas);
            }
            DisplayList displayList=mView.mDisplayList;
            if (displayList != null) {
              layerCanvas.drawDisplayList(displayList,null,DisplayList.FLAG_CLIP_CHILDREN);
            }
 else {
              mView.draw(layerCanvas);
            }
            drawAccessibilityFocusedDrawableIfNeeded(layerCanvas);
            mResizeBufferStartTime=SystemClock.uptimeMillis();
            mResizeBufferDuration=mView.getResources().getInteger(com.android.internal.R.integer.config_mediumAnimTime);
            completed=true;
            layerCanvas.restoreToCount(restoreCount);
          }
 catch (          OutOfMemoryError e) {
            Log.w(TAG,""String_Node_Str"",e);
          }
 finally {
            if (mResizeBuffer != null) {
              mResizeBuffer.end(hwRendererCanvas);
              if (!completed) {
                mResizeBuffer.destroy();
                mResizeBuffer=null;
              }
            }
          }
        }
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mFitSystemWindowsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mFitSystemWindowsRequested=false;
        mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
        host.fitSystemWindows(mFitSystemWindowsInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mHolder.getSurface());
            }
 catch (            Surface.OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        disposeResizeBuffer();
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy(true);
        }
      }
 else       if (surfaceGenerationId != mSurface.getGenerationId() && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mHolder.getSurface());
        }
 catch (        Surface.OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      if (hwInitialized || windowShouldResize || mWidth != mAttachInfo.mHardwareRenderer.getWidth() || mHeight != mAttachInfo.mHardwareRenderer.getHeight()) {
        mAttachInfo.mHardwareRenderer.setup(mWidth,mHeight);
        if (!hwInitialized) {
          mAttachInfo.mHardwareRenderer.invalidate(mHolder.getSurface());
          mFullRedrawNeeded=true;
        }
      }
    }
    if (!mStopped) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    final boolean windowMoved=(attachInfo.mWindowLeft != frame.left || attachInfo.mWindowTop != frame.top);
    if (windowMoved) {
      if (mTranslator != null) {
        mTranslator.translateRectInScreenToAppWinFrame(frame);
      }
      attachInfo.mWindowLeft=frame.left;
      attachInfo.mWindowTop=frame.top;
    }
  }
  final boolean didLayout=layoutRequested && !mStopped;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,desiredWindowWidth,desiredWindowHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
    if (AccessibilityManager.getInstance(host.mContext).isEnabled()) {
      postSendWindowContentChangedCallback(mView);
    }
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    insets.reset();
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  boolean skipDraw=false;
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
    }
    if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0) {
      mWindowsAnimating=true;
    }
  }
 else   if (mWindowsAnimating) {
    skipDraw=true;
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE;
  if (!cancelDraw && !newSurface) {
    if (!skipDraw || mReportNextDraw) {
      if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
        for (int i=0; i < mPendingTransitions.size(); ++i) {
          mPendingTransitions.get(i).startChangingAnimations();
        }
        mPendingTransitions.clear();
      }
      performDraw();
    }
  }
 else {
    if (viewVisibility == View.VISIBLE) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mCompatibilityInfo.get();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.flags&=~WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
      desiredWindowWidth=packageMetrics.widthPixels;
      desiredWindowHeight=packageMetrics.heightPixels;
    }
    attachInfo.mSurface=mSurface;
    attachInfo.mUse32BitDrawingCache=true;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(attachInfo,0);
    attachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  getRunQueue().executeActions(attachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && !mStopped;
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          DisplayMetrics packageMetrics=res.getDisplayMetrics();
          desiredWindowWidth=packageMetrics.widthPixels;
          desiredWindowHeight=packageMetrics.heightPixels;
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (attachInfo.mForceReportNewAttributes) {
    attachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mFitSystemWindowsRequested) {
    mFitSystemWindowsRequested=false;
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    host.fitSystemWindows(mFitSystemWindowsInsets);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (!mDrawDuringWindowsAnimating) {
        mWindowsAnimating|=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        if (mWidth > 0 && mHeight > 0 && lp != null && ((lp.systemUiVisibility | lp.subtreeSystemUiVisibility) & View.SYSTEM_UI_LAYOUT_FLAGS) == 0 && mSurface != null && mSurface.isValid() && !mAttachInfo.mTurnOffWindowResizeAnim && mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled() && mAttachInfo.mHardwareRenderer.validate() && lp != null && !PixelFormat.formatHasAlpha(lp.format)) {
          disposeResizeBuffer();
          boolean completed=false;
          HardwareCanvas hwRendererCanvas=mAttachInfo.mHardwareRenderer.getCanvas();
          HardwareCanvas layerCanvas=null;
          try {
            if (mResizeBuffer == null) {
              mResizeBuffer=mAttachInfo.mHardwareRenderer.createHardwareLayer(mWidth,mHeight,false);
            }
 else             if (mResizeBuffer.getWidth() != mWidth || mResizeBuffer.getHeight() != mHeight) {
              mResizeBuffer.resize(mWidth,mHeight);
            }
            layerCanvas=mResizeBuffer.start(hwRendererCanvas);
            final int restoreCount=layerCanvas.save();
            int yoff;
            final boolean scrolling=mScroller != null && mScroller.computeScrollOffset();
            if (scrolling) {
              yoff=mScroller.getCurrY();
              mScroller.abortAnimation();
            }
 else {
              yoff=mScrollY;
            }
            layerCanvas.translate(0,-yoff);
            if (mTranslator != null) {
              mTranslator.translateCanvas(layerCanvas);
            }
            DisplayList displayList=mView.mDisplayList;
            if (displayList != null) {
              layerCanvas.drawDisplayList(displayList,null,DisplayList.FLAG_CLIP_CHILDREN);
            }
 else {
              mView.draw(layerCanvas);
            }
            drawAccessibilityFocusedDrawableIfNeeded(layerCanvas);
            mResizeBufferStartTime=SystemClock.uptimeMillis();
            mResizeBufferDuration=mView.getResources().getInteger(com.android.internal.R.integer.config_mediumAnimTime);
            completed=true;
            layerCanvas.restoreToCount(restoreCount);
          }
 catch (          OutOfMemoryError e) {
            Log.w(TAG,""String_Node_Str"",e);
          }
 finally {
            if (mResizeBuffer != null) {
              mResizeBuffer.end(hwRendererCanvas);
              if (!completed) {
                mResizeBuffer.destroy();
                mResizeBuffer=null;
              }
            }
          }
        }
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mFitSystemWindowsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mFitSystemWindowsRequested=false;
        mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
        host.fitSystemWindows(mFitSystemWindowsInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mHolder.getSurface());
            }
 catch (            Surface.OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        disposeResizeBuffer();
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy(true);
        }
      }
 else       if (surfaceGenerationId != mSurface.getGenerationId() && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mHolder.getSurface());
        }
 catch (        Surface.OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      if (hwInitialized || windowShouldResize || mWidth != mAttachInfo.mHardwareRenderer.getWidth() || mHeight != mAttachInfo.mHardwareRenderer.getHeight()) {
        mAttachInfo.mHardwareRenderer.setup(mWidth,mHeight);
        if (!hwInitialized) {
          mAttachInfo.mHardwareRenderer.invalidate(mHolder.getSurface());
          mFullRedrawNeeded=true;
        }
      }
    }
    if (!mStopped) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    final boolean windowMoved=(attachInfo.mWindowLeft != frame.left || attachInfo.mWindowTop != frame.top);
    if (windowMoved) {
      if (mTranslator != null) {
        mTranslator.translateRectInScreenToAppWinFrame(frame);
      }
      attachInfo.mWindowLeft=frame.left;
      attachInfo.mWindowTop=frame.top;
    }
  }
  final boolean didLayout=layoutRequested && !mStopped;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,desiredWindowWidth,desiredWindowHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
    if (AccessibilityManager.getInstance(host.mContext).isEnabled()) {
      postSendWindowContentChangedCallback(mView);
    }
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    insets.reset();
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  boolean skipDraw=false;
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
    }
    if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0) {
      mWindowsAnimating=true;
    }
  }
 else   if (mWindowsAnimating) {
    skipDraw=true;
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE;
  if (!cancelDraw && !newSurface) {
    if (!skipDraw || mReportNextDraw) {
      if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
        for (int i=0; i < mPendingTransitions.size(); ++i) {
          mPendingTransitions.get(i).startChangingAnimations();
        }
        mPendingTransitions.clear();
      }
      performDraw();
    }
  }
 else {
    if (viewVisibility == View.VISIBLE) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}"
2044,"private void animateInIconOfFirstTask(){
  if (mItemToAnimateInWhenWindowAnimationIsFinished != null && !mRecentTasksLoader.isFirstScreenful()) {
    int timeSinceWindowAnimation=(int)(System.currentTimeMillis() - mWindowAnimationStartTime);
    final int minStartDelay=125;
    final int startDelay=Math.max(0,Math.min(minStartDelay - timeSinceWindowAnimation,minStartDelay));
    final int duration=250;
    final ViewHolder holder=mItemToAnimateInWhenWindowAnimationIsFinished;
    final TimeInterpolator cubic=new DecelerateInterpolator(1.5f);
    FirstFrameAnimatorHelper.initializeDrawListener(holder.iconView);
    for (    View v : new View[]{holder.iconView,holder.labelView,holder.calloutLine}) {
      if (v != null) {
        ViewPropertyAnimator vpa=v.animate().translationX(0).translationY(0).alpha(1f).setStartDelay(startDelay).setDuration(duration).setInterpolator(cubic);
        FirstFrameAnimatorHelper h=new FirstFrameAnimatorHelper(vpa,v);
      }
    }
    mItemToAnimateInWhenWindowAnimationIsFinished=null;
    mAnimateIconOfFirstTask=false;
  }
}","private void animateInIconOfFirstTask(){
  if (mItemToAnimateInWhenWindowAnimationIsFinished != null && !mRecentTasksLoader.isFirstScreenful()) {
    int timeSinceWindowAnimation=(int)(System.currentTimeMillis() - mWindowAnimationStartTime);
    final int minStartDelay=150;
    final int startDelay=Math.max(0,Math.min(minStartDelay - timeSinceWindowAnimation,minStartDelay));
    final int duration=250;
    final ViewHolder holder=mItemToAnimateInWhenWindowAnimationIsFinished;
    final TimeInterpolator cubic=new DecelerateInterpolator(1.5f);
    FirstFrameAnimatorHelper.initializeDrawListener(holder.iconView);
    for (    View v : new View[]{holder.iconView,holder.labelView,holder.calloutLine}) {
      if (v != null) {
        ViewPropertyAnimator vpa=v.animate().translationX(0).translationY(0).alpha(1f).setStartDelay(startDelay).setDuration(duration).setInterpolator(cubic);
        FirstFrameAnimatorHelper h=new FirstFrameAnimatorHelper(vpa,v);
      }
    }
    mItemToAnimateInWhenWindowAnimationIsFinished=null;
    mAnimateIconOfFirstTask=false;
  }
}"
2045,"public int compare(View first,View second){
  if (first == second) {
    return 0;
  }
  getRect(first,mFirstRect);
  getRect(second,mSecondRect);
  if (mFirstRect.top < mSecondRect.top) {
    return -1;
  }
 else   if (mFirstRect.top > mSecondRect.top) {
    return 1;
  }
 else   if (mFirstRect.left < mSecondRect.left) {
    return -1;
  }
 else   if (mFirstRect.left > mSecondRect.left) {
    return 1;
  }
 else   if (mFirstRect.bottom < mSecondRect.bottom) {
    return -1;
  }
 else   if (mFirstRect.bottom > mSecondRect.bottom) {
    return 1;
  }
 else   if (mFirstRect.right < mSecondRect.right) {
    return -1;
  }
 else   if (mFirstRect.right > mSecondRect.right) {
    return 1;
  }
 else {
    return 0;
  }
}","public int compare(View first,View second){
  if (first == second) {
    return 0;
  }
  getRect(first,mFirstRect);
  getRect(second,mSecondRect);
  if (mFirstRect.top < mSecondRect.top) {
    return -1;
  }
 else   if (mFirstRect.top > mSecondRect.top) {
    return 1;
  }
 else   if (mFirstRect.left < mSecondRect.left) {
    return mIsLayoutRtl ? 1 : -1;
  }
 else   if (mFirstRect.left > mSecondRect.left) {
    return mIsLayoutRtl ? -1 : 1;
  }
 else   if (mFirstRect.bottom < mSecondRect.bottom) {
    return -1;
  }
 else   if (mFirstRect.bottom > mSecondRect.bottom) {
    return 1;
  }
 else   if (mFirstRect.right < mSecondRect.right) {
    return mIsLayoutRtl ? 1 : -1;
  }
 else   if (mFirstRect.right > mSecondRect.right) {
    return mIsLayoutRtl ? -1 : 1;
  }
 else {
    return 0;
  }
}"
2046,"private View findNextFocusInRelativeDirection(ArrayList<View> focusables,ViewGroup root,View focused,Rect focusedRect,int direction){
  try {
    mSequentialFocusComparator.setRoot(root);
    Collections.sort(focusables,mSequentialFocusComparator);
  }
  finally {
    mSequentialFocusComparator.recycle();
  }
  final int count=focusables.size();
switch (direction) {
case View.FOCUS_FORWARD:
    return getForwardFocusable(root,focused,focusables,count);
case View.FOCUS_BACKWARD:
  return getBackwardFocusable(root,focused,focusables,count);
}
return focusables.get(count - 1);
}","private View findNextFocusInRelativeDirection(ArrayList<View> focusables,ViewGroup root,View focused,Rect focusedRect,int direction){
  try {
    mSequentialFocusComparator.setRoot(root);
    mSequentialFocusComparator.setIsLayoutRtl(root.isLayoutRtl());
    Collections.sort(focusables,mSequentialFocusComparator);
  }
  finally {
    mSequentialFocusComparator.recycle();
  }
  final int count=focusables.size();
switch (direction) {
case View.FOCUS_FORWARD:
    return getNextFocusable(focused,focusables,count);
case View.FOCUS_BACKWARD:
  return getPreviousFocusable(focused,focusables,count);
}
return focusables.get(count - 1);
}"
2047,"private void apply(){
  if (mWifiGroup == null)   return;
  if (mWifiVisible) {
    mWifi.setImageDrawable(null);
    mWifiActivity.setImageDrawable(null);
    mWifi.setImageResource(mWifiStrengthId);
    mWifiActivity.setImageResource(mWifiActivityId);
    mWifiGroup.setContentDescription(mWifiDescription);
    mWifiGroup.setVisibility(View.VISIBLE);
  }
 else {
    mWifiGroup.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mWifiVisible ? ""String_Node_Str"" : ""String_Node_Str""),mWifiStrengthId,mWifiActivityId));
  if (mMobileVisible && !mIsAirplaneMode) {
    mMobile.setImageDrawable(null);
    mMobileActivity.setImageDrawable(null);
    mMobileType.setImageDrawable(null);
    mMobile.setImageResource(mMobileStrengthId);
    mMobileActivity.setImageResource(mMobileActivityId);
    mMobileType.setImageResource(mMobileTypeId);
    mMobileGroup.setContentDescription(mMobileTypeDescription + ""String_Node_Str"" + mMobileDescription);
    mMobileGroup.setVisibility(View.VISIBLE);
  }
 else {
    mMobileGroup.setVisibility(View.GONE);
  }
  if (mIsAirplaneMode) {
    mAirplane.setImageDrawable(null);
    mAirplane.setImageResource(mAirplaneIconId);
    mAirplane.setVisibility(View.VISIBLE);
  }
 else {
    mAirplane.setVisibility(View.GONE);
  }
  if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
    mSpacer.setVisibility(View.INVISIBLE);
  }
 else {
    mSpacer.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mMobileVisible ? ""String_Node_Str"" : ""String_Node_Str""),mMobileStrengthId,mMobileActivityId,mMobileTypeId));
  mMobileType.setVisibility(!mWifiVisible ? View.VISIBLE : View.GONE);
}","private void apply(){
  if (mWifiGroup == null)   return;
  if (mWifiVisible) {
    mWifi.setImageResource(mWifiStrengthId);
    mWifiActivity.setImageResource(mWifiActivityId);
    mWifiGroup.setContentDescription(mWifiDescription);
    mWifiGroup.setVisibility(View.VISIBLE);
  }
 else {
    mWifiGroup.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mWifiVisible ? ""String_Node_Str"" : ""String_Node_Str""),mWifiStrengthId,mWifiActivityId));
  if (mMobileVisible && !mIsAirplaneMode) {
    mMobile.setImageResource(mMobileStrengthId);
    mMobileActivity.setImageResource(mMobileActivityId);
    mMobileType.setImageResource(mMobileTypeId);
    mMobileGroup.setContentDescription(mMobileTypeDescription + ""String_Node_Str"" + mMobileDescription);
    mMobileGroup.setVisibility(View.VISIBLE);
  }
 else {
    mMobileGroup.setVisibility(View.GONE);
  }
  if (mIsAirplaneMode) {
    mAirplane.setImageResource(mAirplaneIconId);
    mAirplane.setVisibility(View.VISIBLE);
  }
 else {
    mAirplane.setVisibility(View.GONE);
  }
  if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
    mSpacer.setVisibility(View.INVISIBLE);
  }
 else {
    mSpacer.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mMobileVisible ? ""String_Node_Str"" : ""String_Node_Str""),mMobileStrengthId,mMobileActivityId,mMobileTypeId));
  mMobileType.setVisibility(!mWifiVisible ? View.VISIBLE : View.GONE);
}"
2048,"public int compare(View first,View second){
  if (first == second) {
    return 0;
  }
  getRect(first,mFirstRect);
  getRect(second,mSecondRect);
  if (mFirstRect.top < mSecondRect.top) {
    return -1;
  }
 else   if (mFirstRect.top > mSecondRect.top) {
    return 1;
  }
 else   if (mFirstRect.left < mSecondRect.left) {
    return -1;
  }
 else   if (mFirstRect.left > mSecondRect.left) {
    return 1;
  }
 else   if (mFirstRect.bottom < mSecondRect.bottom) {
    return -1;
  }
 else   if (mFirstRect.bottom > mSecondRect.bottom) {
    return 1;
  }
 else   if (mFirstRect.right < mSecondRect.right) {
    return -1;
  }
 else   if (mFirstRect.right > mSecondRect.right) {
    return 1;
  }
 else {
    return 0;
  }
}","public int compare(View first,View second){
  if (first == second) {
    return 0;
  }
  getRect(first,mFirstRect);
  getRect(second,mSecondRect);
  if (mFirstRect.top < mSecondRect.top) {
    return -1;
  }
 else   if (mFirstRect.top > mSecondRect.top) {
    return 1;
  }
 else   if (mFirstRect.left < mSecondRect.left) {
    return mIsLayoutRtl ? 1 : -1;
  }
 else   if (mFirstRect.left > mSecondRect.left) {
    return mIsLayoutRtl ? -1 : 1;
  }
 else   if (mFirstRect.bottom < mSecondRect.bottom) {
    return -1;
  }
 else   if (mFirstRect.bottom > mSecondRect.bottom) {
    return 1;
  }
 else   if (mFirstRect.right < mSecondRect.right) {
    return mIsLayoutRtl ? 1 : -1;
  }
 else   if (mFirstRect.right > mSecondRect.right) {
    return mIsLayoutRtl ? -1 : 1;
  }
 else {
    return 0;
  }
}"
2049,"private View findNextFocusInRelativeDirection(ArrayList<View> focusables,ViewGroup root,View focused,Rect focusedRect,int direction){
  try {
    mSequentialFocusComparator.setRoot(root);
    Collections.sort(focusables,mSequentialFocusComparator);
  }
  finally {
    mSequentialFocusComparator.recycle();
  }
  final int count=focusables.size();
switch (direction) {
case View.FOCUS_FORWARD:
    return getForwardFocusable(root,focused,focusables,count);
case View.FOCUS_BACKWARD:
  return getBackwardFocusable(root,focused,focusables,count);
}
return focusables.get(count - 1);
}","private View findNextFocusInRelativeDirection(ArrayList<View> focusables,ViewGroup root,View focused,Rect focusedRect,int direction){
  try {
    mSequentialFocusComparator.setRoot(root);
    mSequentialFocusComparator.setIsLayoutRtl(root.isLayoutRtl());
    Collections.sort(focusables,mSequentialFocusComparator);
  }
  finally {
    mSequentialFocusComparator.recycle();
  }
  final int count=focusables.size();
switch (direction) {
case View.FOCUS_FORWARD:
    return getNextFocusable(focused,focusables,count);
case View.FOCUS_BACKWARD:
  return getPreviousFocusable(focused,focusables,count);
}
return focusables.get(count - 1);
}"
2050,"/** 
 * Replace existing canvas while ensuring that the swap has occurred before the previous native canvas is unreferenced.
 */
private void safeCanvasSwap(int nativeCanvas){
  final int oldCanvas=mNativeCanvas;
  mNativeCanvas=nativeCanvas;
  mFinalizer.mNativeCanvas=nativeCanvas;
  copyNativeCanvasState(oldCanvas,mNativeCanvas);
  finalizer(oldCanvas);
}","/** 
 * Replace existing canvas while ensuring that the swap has occurred before the previous native canvas is unreferenced.
 */
private void safeCanvasSwap(int nativeCanvas,boolean copyState){
  final int oldCanvas=mNativeCanvas;
  mNativeCanvas=nativeCanvas;
  mFinalizer.mNativeCanvas=nativeCanvas;
  if (copyState) {
    copyNativeCanvasState(oldCanvas,mNativeCanvas);
  }
  finalizer(oldCanvas);
}"
2051,"/** 
 * Specify a bitmap for the canvas to draw into. As a side-effect, the canvas' target density is updated to match that of the bitmap while all other state such as the layers, filters, matrix, and clip are reset.
 * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
 * @see #setDensity(int)
 * @see #getDensity()
 */
public void setBitmap(Bitmap bitmap){
  if (isHardwareAccelerated()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (bitmap == null) {
    safeCanvasSwap(initRaster(0));
    mDensity=Bitmap.DENSITY_NONE;
  }
 else {
    if (!bitmap.isMutable()) {
      throw new IllegalStateException();
    }
    throwIfRecycled(bitmap);
    safeCanvasSwap(initRaster(bitmap.ni()));
    mDensity=bitmap.mDensity;
  }
  mBitmap=bitmap;
}","/** 
 * Specify a bitmap for the canvas to draw into. All canvas state such as  layers, filters, and the save/restore stack are reset with the exception of the current matrix and clip stack. Additionally, as a side-effect the canvas' target density is updated to match that of the bitmap.
 * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
 * @see #setDensity(int)
 * @see #getDensity()
 */
public void setBitmap(Bitmap bitmap){
  if (isHardwareAccelerated()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (bitmap == null) {
    safeCanvasSwap(initRaster(0),false);
    mDensity=Bitmap.DENSITY_NONE;
  }
 else {
    if (!bitmap.isMutable()) {
      throw new IllegalStateException();
    }
    throwIfRecycled(bitmap);
    safeCanvasSwap(initRaster(bitmap.ni()),true);
    mDensity=bitmap.mDensity;
  }
  mBitmap=bitmap;
}"
2052,"public int compare(View first,View second){
  if (first == second) {
    return 0;
  }
  getRect(first,mFirstRect);
  getRect(second,mSecondRect);
  if (mFirstRect.top < mSecondRect.top) {
    return -1;
  }
 else   if (mFirstRect.top > mSecondRect.top) {
    return 1;
  }
 else   if (mFirstRect.left < mSecondRect.left) {
    return -1;
  }
 else   if (mFirstRect.left > mSecondRect.left) {
    return 1;
  }
 else   if (mFirstRect.bottom < mSecondRect.bottom) {
    return -1;
  }
 else   if (mFirstRect.bottom > mSecondRect.bottom) {
    return 1;
  }
 else   if (mFirstRect.right < mSecondRect.right) {
    return -1;
  }
 else   if (mFirstRect.right > mSecondRect.right) {
    return 1;
  }
 else {
    return 0;
  }
}","public int compare(View first,View second){
  if (first == second) {
    return 0;
  }
  getRect(first,mFirstRect);
  getRect(second,mSecondRect);
  if (mFirstRect.top < mSecondRect.top) {
    return -1;
  }
 else   if (mFirstRect.top > mSecondRect.top) {
    return 1;
  }
 else   if (mFirstRect.left < mSecondRect.left) {
    return mIsLayoutRtl ? 1 : -1;
  }
 else   if (mFirstRect.left > mSecondRect.left) {
    return mIsLayoutRtl ? -1 : 1;
  }
 else   if (mFirstRect.bottom < mSecondRect.bottom) {
    return -1;
  }
 else   if (mFirstRect.bottom > mSecondRect.bottom) {
    return 1;
  }
 else   if (mFirstRect.right < mSecondRect.right) {
    return mIsLayoutRtl ? 1 : -1;
  }
 else   if (mFirstRect.right > mSecondRect.right) {
    return mIsLayoutRtl ? -1 : 1;
  }
 else {
    return 0;
  }
}"
2053,"private View findNextFocusInRelativeDirection(ArrayList<View> focusables,ViewGroup root,View focused,Rect focusedRect,int direction){
  try {
    mSequentialFocusComparator.setRoot(root);
    Collections.sort(focusables,mSequentialFocusComparator);
  }
  finally {
    mSequentialFocusComparator.recycle();
  }
  final int count=focusables.size();
switch (direction) {
case View.FOCUS_FORWARD:
    return getForwardFocusable(root,focused,focusables,count);
case View.FOCUS_BACKWARD:
  return getBackwardFocusable(root,focused,focusables,count);
}
return focusables.get(count - 1);
}","private View findNextFocusInRelativeDirection(ArrayList<View> focusables,ViewGroup root,View focused,Rect focusedRect,int direction){
  try {
    mSequentialFocusComparator.setRoot(root);
    mSequentialFocusComparator.setIsLayoutRtl(root.isLayoutRtl());
    Collections.sort(focusables,mSequentialFocusComparator);
  }
  finally {
    mSequentialFocusComparator.recycle();
  }
  final int count=focusables.size();
switch (direction) {
case View.FOCUS_FORWARD:
    return getNextFocusable(focused,focusables,count);
case View.FOCUS_BACKWARD:
  return getPreviousFocusable(focused,focusables,count);
}
return focusables.get(count - 1);
}"
2054,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mCompatibilityInfo.get();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.flags&=~WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
      desiredWindowWidth=packageMetrics.widthPixels;
      desiredWindowHeight=packageMetrics.heightPixels;
    }
    attachInfo.mSurface=mSurface;
    attachInfo.mUse32BitDrawingCache=true;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(attachInfo,0);
    attachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  getRunQueue().executeActions(attachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && !mStopped;
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          DisplayMetrics packageMetrics=res.getDisplayMetrics();
          desiredWindowWidth=packageMetrics.widthPixels;
          desiredWindowHeight=packageMetrics.heightPixels;
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (attachInfo.mForceReportNewAttributes) {
    attachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mFitSystemWindowsRequested) {
    mFitSystemWindowsRequested=false;
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    host.fitSystemWindows(mFitSystemWindowsInsets);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      mWindowsAnimating|=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        if (mWidth > 0 && mHeight > 0 && lp != null && ((lp.systemUiVisibility | lp.subtreeSystemUiVisibility) & View.SYSTEM_UI_LAYOUT_FLAGS) == 0 && mSurface != null && mSurface.isValid() && !mAttachInfo.mTurnOffWindowResizeAnim && mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled() && mAttachInfo.mHardwareRenderer.validate() && lp != null && !PixelFormat.formatHasAlpha(lp.format)) {
          disposeResizeBuffer();
          boolean completed=false;
          HardwareCanvas hwRendererCanvas=mAttachInfo.mHardwareRenderer.getCanvas();
          HardwareCanvas layerCanvas=null;
          try {
            if (mResizeBuffer == null) {
              mResizeBuffer=mAttachInfo.mHardwareRenderer.createHardwareLayer(mWidth,mHeight,false);
            }
 else             if (mResizeBuffer.getWidth() != mWidth || mResizeBuffer.getHeight() != mHeight) {
              mResizeBuffer.resize(mWidth,mHeight);
            }
            layerCanvas=mResizeBuffer.start(hwRendererCanvas);
            final int restoreCount=layerCanvas.save();
            int yoff;
            final boolean scrolling=mScroller != null && mScroller.computeScrollOffset();
            if (scrolling) {
              yoff=mScroller.getCurrY();
              mScroller.abortAnimation();
            }
 else {
              yoff=mScrollY;
            }
            layerCanvas.translate(0,-yoff);
            if (mTranslator != null) {
              mTranslator.translateCanvas(layerCanvas);
            }
            DisplayList displayList=mView.mDisplayList;
            if (displayList != null) {
              layerCanvas.drawDisplayList(displayList,null,DisplayList.FLAG_CLIP_CHILDREN);
            }
 else {
              mView.draw(layerCanvas);
            }
            drawAccessibilityFocusedDrawableIfNeeded(layerCanvas);
            mResizeBufferStartTime=SystemClock.uptimeMillis();
            mResizeBufferDuration=mView.getResources().getInteger(com.android.internal.R.integer.config_mediumAnimTime);
            completed=true;
            layerCanvas.restoreToCount(restoreCount);
          }
 catch (          OutOfMemoryError e) {
            Log.w(TAG,""String_Node_Str"",e);
          }
 finally {
            if (mResizeBuffer != null) {
              mResizeBuffer.end(hwRendererCanvas);
              if (!completed) {
                mResizeBuffer.destroy();
                mResizeBuffer=null;
              }
            }
          }
        }
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mFitSystemWindowsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mFitSystemWindowsRequested=false;
        mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
        host.fitSystemWindows(mFitSystemWindowsInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mHolder.getSurface());
            }
 catch (            Surface.OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        disposeResizeBuffer();
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy(true);
        }
      }
 else       if (surfaceGenerationId != mSurface.getGenerationId() && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mHolder.getSurface());
        }
 catch (        Surface.OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      if (hwInitialized || windowShouldResize || mWidth != mAttachInfo.mHardwareRenderer.getWidth() || mHeight != mAttachInfo.mHardwareRenderer.getHeight()) {
        mAttachInfo.mHardwareRenderer.setup(mWidth,mHeight);
        if (!hwInitialized) {
          mAttachInfo.mHardwareRenderer.invalidate(mHolder.getSurface());
          mFullRedrawNeeded=true;
        }
      }
    }
    if (!mStopped) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    final boolean windowMoved=(attachInfo.mWindowLeft != frame.left || attachInfo.mWindowTop != frame.top);
    if (windowMoved) {
      if (mTranslator != null) {
        mTranslator.translateRectInScreenToAppWinFrame(frame);
      }
      attachInfo.mWindowLeft=frame.left;
      attachInfo.mWindowTop=frame.top;
    }
  }
  final boolean didLayout=layoutRequested && !mStopped;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,desiredWindowWidth,desiredWindowHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
    if (AccessibilityManager.getInstance(host.mContext).isEnabled()) {
      postSendWindowContentChangedCallback(mView);
    }
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    insets.reset();
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  boolean skipDraw=false;
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
    }
    if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0) {
      mWindowsAnimating=true;
    }
  }
 else   if (mWindowsAnimating) {
    skipDraw=true;
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE;
  if (!cancelDraw && !newSurface) {
    if (!skipDraw || mReportNextDraw) {
      if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
        for (int i=0; i < mPendingTransitions.size(); ++i) {
          mPendingTransitions.get(i).startChangingAnimations();
        }
        mPendingTransitions.clear();
      }
      performDraw();
    }
  }
 else {
    if (viewVisibility == View.VISIBLE) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mCompatibilityInfo.get();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.flags&=~WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
      desiredWindowWidth=packageMetrics.widthPixels;
      desiredWindowHeight=packageMetrics.heightPixels;
    }
    attachInfo.mSurface=mSurface;
    attachInfo.mUse32BitDrawingCache=true;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(attachInfo,0);
    attachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  getRunQueue().executeActions(attachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && !mStopped;
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          DisplayMetrics packageMetrics=res.getDisplayMetrics();
          desiredWindowWidth=packageMetrics.widthPixels;
          desiredWindowHeight=packageMetrics.heightPixels;
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (attachInfo.mForceReportNewAttributes) {
    attachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mFitSystemWindowsRequested) {
    mFitSystemWindowsRequested=false;
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    host.fitSystemWindows(mFitSystemWindowsInsets);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (!mDrawDuringWindowsAnimating) {
        mWindowsAnimating|=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        if (mWidth > 0 && mHeight > 0 && lp != null && ((lp.systemUiVisibility | lp.subtreeSystemUiVisibility) & View.SYSTEM_UI_LAYOUT_FLAGS) == 0 && mSurface != null && mSurface.isValid() && !mAttachInfo.mTurnOffWindowResizeAnim && mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled() && mAttachInfo.mHardwareRenderer.validate() && lp != null && !PixelFormat.formatHasAlpha(lp.format)) {
          disposeResizeBuffer();
          boolean completed=false;
          HardwareCanvas hwRendererCanvas=mAttachInfo.mHardwareRenderer.getCanvas();
          HardwareCanvas layerCanvas=null;
          try {
            if (mResizeBuffer == null) {
              mResizeBuffer=mAttachInfo.mHardwareRenderer.createHardwareLayer(mWidth,mHeight,false);
            }
 else             if (mResizeBuffer.getWidth() != mWidth || mResizeBuffer.getHeight() != mHeight) {
              mResizeBuffer.resize(mWidth,mHeight);
            }
            layerCanvas=mResizeBuffer.start(hwRendererCanvas);
            final int restoreCount=layerCanvas.save();
            int yoff;
            final boolean scrolling=mScroller != null && mScroller.computeScrollOffset();
            if (scrolling) {
              yoff=mScroller.getCurrY();
              mScroller.abortAnimation();
            }
 else {
              yoff=mScrollY;
            }
            layerCanvas.translate(0,-yoff);
            if (mTranslator != null) {
              mTranslator.translateCanvas(layerCanvas);
            }
            DisplayList displayList=mView.mDisplayList;
            if (displayList != null) {
              layerCanvas.drawDisplayList(displayList,null,DisplayList.FLAG_CLIP_CHILDREN);
            }
 else {
              mView.draw(layerCanvas);
            }
            drawAccessibilityFocusedDrawableIfNeeded(layerCanvas);
            mResizeBufferStartTime=SystemClock.uptimeMillis();
            mResizeBufferDuration=mView.getResources().getInteger(com.android.internal.R.integer.config_mediumAnimTime);
            completed=true;
            layerCanvas.restoreToCount(restoreCount);
          }
 catch (          OutOfMemoryError e) {
            Log.w(TAG,""String_Node_Str"",e);
          }
 finally {
            if (mResizeBuffer != null) {
              mResizeBuffer.end(hwRendererCanvas);
              if (!completed) {
                mResizeBuffer.destroy();
                mResizeBuffer=null;
              }
            }
          }
        }
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mFitSystemWindowsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mFitSystemWindowsRequested=false;
        mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
        host.fitSystemWindows(mFitSystemWindowsInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mHolder.getSurface());
            }
 catch (            Surface.OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        disposeResizeBuffer();
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy(true);
        }
      }
 else       if (surfaceGenerationId != mSurface.getGenerationId() && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mHolder.getSurface());
        }
 catch (        Surface.OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      if (hwInitialized || windowShouldResize || mWidth != mAttachInfo.mHardwareRenderer.getWidth() || mHeight != mAttachInfo.mHardwareRenderer.getHeight()) {
        mAttachInfo.mHardwareRenderer.setup(mWidth,mHeight);
        if (!hwInitialized) {
          mAttachInfo.mHardwareRenderer.invalidate(mHolder.getSurface());
          mFullRedrawNeeded=true;
        }
      }
    }
    if (!mStopped) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    final boolean windowMoved=(attachInfo.mWindowLeft != frame.left || attachInfo.mWindowTop != frame.top);
    if (windowMoved) {
      if (mTranslator != null) {
        mTranslator.translateRectInScreenToAppWinFrame(frame);
      }
      attachInfo.mWindowLeft=frame.left;
      attachInfo.mWindowTop=frame.top;
    }
  }
  final boolean didLayout=layoutRequested && !mStopped;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,desiredWindowWidth,desiredWindowHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
    if (AccessibilityManager.getInstance(host.mContext).isEnabled()) {
      postSendWindowContentChangedCallback(mView);
    }
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    insets.reset();
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  boolean skipDraw=false;
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
    }
    if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0) {
      mWindowsAnimating=true;
    }
  }
 else   if (mWindowsAnimating) {
    skipDraw=true;
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE;
  if (!cancelDraw && !newSurface) {
    if (!skipDraw || mReportNextDraw) {
      if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
        for (int i=0; i < mPendingTransitions.size(); ++i) {
          mPendingTransitions.get(i).startChangingAnimations();
        }
        mPendingTransitions.clear();
      }
      performDraw();
    }
  }
 else {
    if (viewVisibility == View.VISIBLE) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}"
2055,"private void animateInIconOfFirstTask(){
  if (mItemToAnimateInWhenWindowAnimationIsFinished != null && !mRecentTasksLoader.isFirstScreenful()) {
    int timeSinceWindowAnimation=(int)(System.currentTimeMillis() - mWindowAnimationStartTime);
    final int minStartDelay=125;
    final int startDelay=Math.max(0,Math.min(minStartDelay - timeSinceWindowAnimation,minStartDelay));
    final int duration=250;
    final ViewHolder holder=mItemToAnimateInWhenWindowAnimationIsFinished;
    final TimeInterpolator cubic=new DecelerateInterpolator(1.5f);
    FirstFrameAnimatorHelper.initializeDrawListener(holder.iconView);
    for (    View v : new View[]{holder.iconView,holder.labelView,holder.calloutLine}) {
      if (v != null) {
        ViewPropertyAnimator vpa=v.animate().translationX(0).translationY(0).alpha(1f).setStartDelay(startDelay).setDuration(duration).setInterpolator(cubic);
        FirstFrameAnimatorHelper h=new FirstFrameAnimatorHelper(vpa,v);
      }
    }
    mItemToAnimateInWhenWindowAnimationIsFinished=null;
    mAnimateIconOfFirstTask=false;
  }
}","private void animateInIconOfFirstTask(){
  if (mItemToAnimateInWhenWindowAnimationIsFinished != null && !mRecentTasksLoader.isFirstScreenful()) {
    int timeSinceWindowAnimation=(int)(System.currentTimeMillis() - mWindowAnimationStartTime);
    final int minStartDelay=150;
    final int startDelay=Math.max(0,Math.min(minStartDelay - timeSinceWindowAnimation,minStartDelay));
    final int duration=250;
    final ViewHolder holder=mItemToAnimateInWhenWindowAnimationIsFinished;
    final TimeInterpolator cubic=new DecelerateInterpolator(1.5f);
    FirstFrameAnimatorHelper.initializeDrawListener(holder.iconView);
    for (    View v : new View[]{holder.iconView,holder.labelView,holder.calloutLine}) {
      if (v != null) {
        ViewPropertyAnimator vpa=v.animate().translationX(0).translationY(0).alpha(1f).setStartDelay(startDelay).setDuration(duration).setInterpolator(cubic);
        FirstFrameAnimatorHelper h=new FirstFrameAnimatorHelper(vpa,v);
      }
    }
    mItemToAnimateInWhenWindowAnimationIsFinished=null;
    mAnimateIconOfFirstTask=false;
  }
}"
2056,"private void apply(){
  if (mWifiGroup == null)   return;
  if (mWifiVisible) {
    mWifi.setImageDrawable(null);
    mWifiActivity.setImageDrawable(null);
    mWifi.setImageResource(mWifiStrengthId);
    mWifiActivity.setImageResource(mWifiActivityId);
    mWifiGroup.setContentDescription(mWifiDescription);
    mWifiGroup.setVisibility(View.VISIBLE);
  }
 else {
    mWifiGroup.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mWifiVisible ? ""String_Node_Str"" : ""String_Node_Str""),mWifiStrengthId,mWifiActivityId));
  if (mMobileVisible && !mIsAirplaneMode) {
    mMobile.setImageDrawable(null);
    mMobileActivity.setImageDrawable(null);
    mMobileType.setImageDrawable(null);
    mMobile.setImageResource(mMobileStrengthId);
    mMobileActivity.setImageResource(mMobileActivityId);
    mMobileType.setImageResource(mMobileTypeId);
    mMobileGroup.setContentDescription(mMobileTypeDescription + ""String_Node_Str"" + mMobileDescription);
    mMobileGroup.setVisibility(View.VISIBLE);
  }
 else {
    mMobileGroup.setVisibility(View.GONE);
  }
  if (mIsAirplaneMode) {
    mAirplane.setImageDrawable(null);
    mAirplane.setImageResource(mAirplaneIconId);
    mAirplane.setVisibility(View.VISIBLE);
  }
 else {
    mAirplane.setVisibility(View.GONE);
  }
  if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
    mSpacer.setVisibility(View.INVISIBLE);
  }
 else {
    mSpacer.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mMobileVisible ? ""String_Node_Str"" : ""String_Node_Str""),mMobileStrengthId,mMobileActivityId,mMobileTypeId));
  mMobileType.setVisibility(!mWifiVisible ? View.VISIBLE : View.GONE);
}","private void apply(){
  if (mWifiGroup == null)   return;
  if (mWifiVisible) {
    mWifi.setImageResource(mWifiStrengthId);
    mWifiActivity.setImageResource(mWifiActivityId);
    mWifiGroup.setContentDescription(mWifiDescription);
    mWifiGroup.setVisibility(View.VISIBLE);
  }
 else {
    mWifiGroup.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mWifiVisible ? ""String_Node_Str"" : ""String_Node_Str""),mWifiStrengthId,mWifiActivityId));
  if (mMobileVisible && !mIsAirplaneMode) {
    mMobile.setImageResource(mMobileStrengthId);
    mMobileActivity.setImageResource(mMobileActivityId);
    mMobileType.setImageResource(mMobileTypeId);
    mMobileGroup.setContentDescription(mMobileTypeDescription + ""String_Node_Str"" + mMobileDescription);
    mMobileGroup.setVisibility(View.VISIBLE);
  }
 else {
    mMobileGroup.setVisibility(View.GONE);
  }
  if (mIsAirplaneMode) {
    mAirplane.setImageResource(mAirplaneIconId);
    mAirplane.setVisibility(View.VISIBLE);
  }
 else {
    mAirplane.setVisibility(View.GONE);
  }
  if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
    mSpacer.setVisibility(View.INVISIBLE);
  }
 else {
    mSpacer.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mMobileVisible ? ""String_Node_Str"" : ""String_Node_Str""),mMobileStrengthId,mMobileActivityId,mMobileTypeId));
  mMobileType.setVisibility(!mWifiVisible ? View.VISIBLE : View.GONE);
}"
2057,"private void apply(){
  if (mWifiGroup == null)   return;
  if (mWifiVisible) {
    mWifi.setImageDrawable(null);
    mWifiActivity.setImageDrawable(null);
    mWifi.setImageResource(mWifiStrengthId);
    mWifiActivity.setImageResource(mWifiActivityId);
    mWifiGroup.setContentDescription(mWifiDescription);
    mWifiGroup.setVisibility(View.VISIBLE);
  }
 else {
    mWifiGroup.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mWifiVisible ? ""String_Node_Str"" : ""String_Node_Str""),mWifiStrengthId,mWifiActivityId));
  if (mMobileVisible && !mIsAirplaneMode) {
    mMobile.setImageDrawable(null);
    mMobileActivity.setImageDrawable(null);
    mMobileType.setImageDrawable(null);
    mMobile.setImageResource(mMobileStrengthId);
    mMobileActivity.setImageResource(mMobileActivityId);
    mMobileType.setImageResource(mMobileTypeId);
    mMobileGroup.setContentDescription(mMobileTypeDescription + ""String_Node_Str"" + mMobileDescription);
    mMobileGroup.setVisibility(View.VISIBLE);
  }
 else {
    mMobileGroup.setVisibility(View.GONE);
  }
  if (mIsAirplaneMode) {
    mAirplane.setImageDrawable(null);
    mAirplane.setImageResource(mAirplaneIconId);
    mAirplane.setVisibility(View.VISIBLE);
  }
 else {
    mAirplane.setVisibility(View.GONE);
  }
  if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
    mSpacer.setVisibility(View.INVISIBLE);
  }
 else {
    mSpacer.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mMobileVisible ? ""String_Node_Str"" : ""String_Node_Str""),mMobileStrengthId,mMobileActivityId,mMobileTypeId));
  mMobileType.setVisibility(!mWifiVisible ? View.VISIBLE : View.GONE);
}","private void apply(){
  if (mWifiGroup == null)   return;
  if (mWifiVisible) {
    mWifi.setImageResource(mWifiStrengthId);
    mWifiActivity.setImageResource(mWifiActivityId);
    mWifiGroup.setContentDescription(mWifiDescription);
    mWifiGroup.setVisibility(View.VISIBLE);
  }
 else {
    mWifiGroup.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mWifiVisible ? ""String_Node_Str"" : ""String_Node_Str""),mWifiStrengthId,mWifiActivityId));
  if (mMobileVisible && !mIsAirplaneMode) {
    mMobile.setImageResource(mMobileStrengthId);
    mMobileActivity.setImageResource(mMobileActivityId);
    mMobileType.setImageResource(mMobileTypeId);
    mMobileGroup.setContentDescription(mMobileTypeDescription + ""String_Node_Str"" + mMobileDescription);
    mMobileGroup.setVisibility(View.VISIBLE);
  }
 else {
    mMobileGroup.setVisibility(View.GONE);
  }
  if (mIsAirplaneMode) {
    mAirplane.setImageResource(mAirplaneIconId);
    mAirplane.setVisibility(View.VISIBLE);
  }
 else {
    mAirplane.setVisibility(View.GONE);
  }
  if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
    mSpacer.setVisibility(View.INVISIBLE);
  }
 else {
    mSpacer.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mMobileVisible ? ""String_Node_Str"" : ""String_Node_Str""),mMobileStrengthId,mMobileActivityId,mMobileTypeId));
  mMobileType.setVisibility(!mWifiVisible ? View.VISIBLE : View.GONE);
}"
2058,"private void apply(){
  if (mWifiGroup == null)   return;
  if (mWifiVisible) {
    mWifi.setImageDrawable(null);
    mWifiActivity.setImageDrawable(null);
    mWifi.setImageResource(mWifiStrengthId);
    mWifiActivity.setImageResource(mWifiActivityId);
    mWifiGroup.setContentDescription(mWifiDescription);
    mWifiGroup.setVisibility(View.VISIBLE);
  }
 else {
    mWifiGroup.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mWifiVisible ? ""String_Node_Str"" : ""String_Node_Str""),mWifiStrengthId,mWifiActivityId));
  if (mMobileVisible && !mIsAirplaneMode) {
    mMobile.setImageDrawable(null);
    mMobileActivity.setImageDrawable(null);
    mMobileType.setImageDrawable(null);
    mMobile.setImageResource(mMobileStrengthId);
    mMobileActivity.setImageResource(mMobileActivityId);
    mMobileType.setImageResource(mMobileTypeId);
    mMobileGroup.setContentDescription(mMobileTypeDescription + ""String_Node_Str"" + mMobileDescription);
    mMobileGroup.setVisibility(View.VISIBLE);
  }
 else {
    mMobileGroup.setVisibility(View.GONE);
  }
  if (mIsAirplaneMode) {
    mAirplane.setImageDrawable(null);
    mAirplane.setImageResource(mAirplaneIconId);
    mAirplane.setVisibility(View.VISIBLE);
  }
 else {
    mAirplane.setVisibility(View.GONE);
  }
  if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
    mSpacer.setVisibility(View.INVISIBLE);
  }
 else {
    mSpacer.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mMobileVisible ? ""String_Node_Str"" : ""String_Node_Str""),mMobileStrengthId,mMobileActivityId,mMobileTypeId));
  mMobileType.setVisibility(!mWifiVisible ? View.VISIBLE : View.GONE);
}","private void apply(){
  if (mWifiGroup == null)   return;
  if (mWifiVisible) {
    mWifi.setImageResource(mWifiStrengthId);
    mWifiActivity.setImageResource(mWifiActivityId);
    mWifiGroup.setContentDescription(mWifiDescription);
    mWifiGroup.setVisibility(View.VISIBLE);
  }
 else {
    mWifiGroup.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mWifiVisible ? ""String_Node_Str"" : ""String_Node_Str""),mWifiStrengthId,mWifiActivityId));
  if (mMobileVisible && !mIsAirplaneMode) {
    mMobile.setImageResource(mMobileStrengthId);
    mMobileActivity.setImageResource(mMobileActivityId);
    mMobileType.setImageResource(mMobileTypeId);
    mMobileGroup.setContentDescription(mMobileTypeDescription + ""String_Node_Str"" + mMobileDescription);
    mMobileGroup.setVisibility(View.VISIBLE);
  }
 else {
    mMobileGroup.setVisibility(View.GONE);
  }
  if (mIsAirplaneMode) {
    mAirplane.setImageResource(mAirplaneIconId);
    mAirplane.setVisibility(View.VISIBLE);
  }
 else {
    mAirplane.setVisibility(View.GONE);
  }
  if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
    mSpacer.setVisibility(View.INVISIBLE);
  }
 else {
    mSpacer.setVisibility(View.GONE);
  }
  if (DEBUG)   Slog.d(TAG,String.format(""String_Node_Str"",(mMobileVisible ? ""String_Node_Str"" : ""String_Node_Str""),mMobileStrengthId,mMobileActivityId,mMobileTypeId));
  mMobileType.setVisibility(!mWifiVisible ? View.VISIBLE : View.GONE);
}"
2059,"public int compare(View first,View second){
  if (first == second) {
    return 0;
  }
  getRect(first,mFirstRect);
  getRect(second,mSecondRect);
  if (mFirstRect.top < mSecondRect.top) {
    return -1;
  }
 else   if (mFirstRect.top > mSecondRect.top) {
    return 1;
  }
 else   if (mFirstRect.left < mSecondRect.left) {
    return -1;
  }
 else   if (mFirstRect.left > mSecondRect.left) {
    return 1;
  }
 else   if (mFirstRect.bottom < mSecondRect.bottom) {
    return -1;
  }
 else   if (mFirstRect.bottom > mSecondRect.bottom) {
    return 1;
  }
 else   if (mFirstRect.right < mSecondRect.right) {
    return -1;
  }
 else   if (mFirstRect.right > mSecondRect.right) {
    return 1;
  }
 else {
    return 0;
  }
}","public int compare(View first,View second){
  if (first == second) {
    return 0;
  }
  getRect(first,mFirstRect);
  getRect(second,mSecondRect);
  if (mFirstRect.top < mSecondRect.top) {
    return -1;
  }
 else   if (mFirstRect.top > mSecondRect.top) {
    return 1;
  }
 else   if (mFirstRect.left < mSecondRect.left) {
    return mIsLayoutRtl ? 1 : -1;
  }
 else   if (mFirstRect.left > mSecondRect.left) {
    return mIsLayoutRtl ? -1 : 1;
  }
 else   if (mFirstRect.bottom < mSecondRect.bottom) {
    return -1;
  }
 else   if (mFirstRect.bottom > mSecondRect.bottom) {
    return 1;
  }
 else   if (mFirstRect.right < mSecondRect.right) {
    return mIsLayoutRtl ? 1 : -1;
  }
 else   if (mFirstRect.right > mSecondRect.right) {
    return mIsLayoutRtl ? -1 : 1;
  }
 else {
    return 0;
  }
}"
2060,"private View findNextFocusInRelativeDirection(ArrayList<View> focusables,ViewGroup root,View focused,Rect focusedRect,int direction){
  try {
    mSequentialFocusComparator.setRoot(root);
    Collections.sort(focusables,mSequentialFocusComparator);
  }
  finally {
    mSequentialFocusComparator.recycle();
  }
  final int count=focusables.size();
switch (direction) {
case View.FOCUS_FORWARD:
    return getForwardFocusable(root,focused,focusables,count);
case View.FOCUS_BACKWARD:
  return getBackwardFocusable(root,focused,focusables,count);
}
return focusables.get(count - 1);
}","private View findNextFocusInRelativeDirection(ArrayList<View> focusables,ViewGroup root,View focused,Rect focusedRect,int direction){
  try {
    mSequentialFocusComparator.setRoot(root);
    mSequentialFocusComparator.setIsLayoutRtl(root.isLayoutRtl());
    Collections.sort(focusables,mSequentialFocusComparator);
  }
  finally {
    mSequentialFocusComparator.recycle();
  }
  final int count=focusables.size();
switch (direction) {
case View.FOCUS_FORWARD:
    return getNextFocusable(focused,focusables,count);
case View.FOCUS_BACKWARD:
  return getPreviousFocusable(focused,focusables,count);
}
return focusables.get(count - 1);
}"
2061,"private void cancelLoadingThumbnailsAndIcons(){
  if (mTaskLoader != null) {
    mTaskLoader.cancel(false);
    mTaskLoader=null;
  }
  if (mThumbnailLoader != null) {
    mThumbnailLoader.cancel(false);
    mThumbnailLoader=null;
  }
  mLoadedTasks=null;
  if (mRecentsPanel != null) {
    mRecentsPanel.onTaskLoadingCancelled();
  }
  mFirstScreenful=false;
  mState=State.CANCELLED;
}","private void cancelLoadingThumbnailsAndIcons(){
  if (mRecentsPanel != null && mRecentsPanel.isShowing()) {
    return;
  }
  if (mTaskLoader != null) {
    mTaskLoader.cancel(false);
    mTaskLoader=null;
  }
  if (mThumbnailLoader != null) {
    mThumbnailLoader.cancel(false);
    mThumbnailLoader=null;
  }
  mLoadedTasks=null;
  if (mRecentsPanel != null) {
    mRecentsPanel.onTaskLoadingCancelled();
  }
  mFirstScreenful=false;
  mState=State.CANCELLED;
}"
2062,"@Override public void onStart(){
  if (forceOpaqueBackground(this)) {
    updateWallpaperVisibility(false);
  }
 else {
    updateWallpaperVisibility(true);
  }
  mShowing=true;
  if (mRecentsPanel != null) {
    mRecentsPanel.refreshViews();
  }
  super.onStart();
}","@Override public void onStart(){
  if (forceOpaqueBackground(this)) {
    updateWallpaperVisibility(false);
  }
 else {
    updateWallpaperVisibility(true);
  }
  mShowing=true;
  if (mRecentsPanel != null) {
    mRecentsPanel.refreshRecentTasksList();
    mRecentsPanel.refreshViews();
  }
  super.onStart();
}"
2063,"@Override public void handleMessage(Message message){
  Object listener=getListener(message.arg2);
  boolean listenerRemove=true;
switch (message.what) {
case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
    mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
  mConnected.countDown();
break;
case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
break;
case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
Log.e(TAG,""String_Node_Str"");
break;
case DISCOVER_SERVICES_STARTED:
String s=((NsdServiceInfo)message.obj).getServiceType();
((DiscoveryListener)listener).onDiscoveryStarted(s);
listenerRemove=false;
break;
case DISCOVER_SERVICES_FAILED:
((DiscoveryListener)listener).onStartDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case SERVICE_FOUND:
((DiscoveryListener)listener).onServiceFound((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case SERVICE_LOST:
((DiscoveryListener)listener).onServiceLost((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case STOP_DISCOVERY_FAILED:
((DiscoveryListener)listener).onStopDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case STOP_DISCOVERY_SUCCEEDED:
((DiscoveryListener)listener).onDiscoveryStopped(getNsdService(message.arg2).getServiceType());
break;
case REGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onRegistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case REGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceRegistered((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case UNREGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onUnregistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case UNREGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceUnregistered(getNsdService(message.arg2));
break;
case RESOLVE_SERVICE_FAILED:
((ResolveListener)listener).onResolveFailed(getNsdService(message.arg2),message.arg1);
break;
case RESOLVE_SERVICE_SUCCEEDED:
((ResolveListener)listener).onServiceResolved((NsdServiceInfo)message.obj);
break;
default :
Log.d(TAG,""String_Node_Str"" + message);
break;
}
if (listenerRemove) {
removeListener(message.arg2);
}
}","@Override public void handleMessage(Message message){
  Object listener=getListener(message.arg2);
  boolean listenerRemove=true;
switch (message.what) {
case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
    mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
  break;
case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
mConnected.countDown();
break;
case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
Log.e(TAG,""String_Node_Str"");
break;
case DISCOVER_SERVICES_STARTED:
String s=((NsdServiceInfo)message.obj).getServiceType();
((DiscoveryListener)listener).onDiscoveryStarted(s);
listenerRemove=false;
break;
case DISCOVER_SERVICES_FAILED:
((DiscoveryListener)listener).onStartDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case SERVICE_FOUND:
((DiscoveryListener)listener).onServiceFound((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case SERVICE_LOST:
((DiscoveryListener)listener).onServiceLost((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case STOP_DISCOVERY_FAILED:
((DiscoveryListener)listener).onStopDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case STOP_DISCOVERY_SUCCEEDED:
((DiscoveryListener)listener).onDiscoveryStopped(getNsdService(message.arg2).getServiceType());
break;
case REGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onRegistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case REGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceRegistered((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case UNREGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onUnregistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case UNREGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceUnregistered(getNsdService(message.arg2));
break;
case RESOLVE_SERVICE_FAILED:
((ResolveListener)listener).onResolveFailed(getNsdService(message.arg2),message.arg1);
break;
case RESOLVE_SERVICE_SUCCEEDED:
((ResolveListener)listener).onServiceResolved((NsdServiceInfo)message.obj);
break;
default :
Log.d(TAG,""String_Node_Str"" + message);
break;
}
if (listenerRemove) {
removeListener(message.arg2);
}
}"
2064,"public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          if (foregroundNoti.icon == 0) {
            foregroundNoti.icon=appInfo.icon;
            foregroundNoti.contentView=null;
            foregroundNoti.bigContentView=null;
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContext(appInfo.packageName,0);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              foregroundNoti.setLatestEventInfo(ctx,ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName),ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName),pi);
            }
 catch (            PackageManager.NameNotFoundException e) {
              foregroundNoti.icon=0;
            }
          }
          if (foregroundNoti.icon == 0) {
            throw new RuntimeException(""String_Node_Str"");
          }
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}","public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          if (localForegroundNoti.icon == 0) {
            localForegroundNoti.icon=appInfo.icon;
            localForegroundNoti.contentView=null;
            localForegroundNoti.bigContentView=null;
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContext(appInfo.packageName,0);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              localForegroundNoti.setLatestEventInfo(ctx,ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName),ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName),pi);
            }
 catch (            PackageManager.NameNotFoundException e) {
              localForegroundNoti.icon=0;
            }
          }
          if (localForegroundNoti.icon == 0) {
            throw new RuntimeException(""String_Node_Str"");
          }
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}"
2065,"@Override public void handleMessage(Message message){
  Object listener=getListener(message.arg2);
  boolean listenerRemove=true;
switch (message.what) {
case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
    mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
  mConnected.countDown();
break;
case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
break;
case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
Log.e(TAG,""String_Node_Str"");
break;
case DISCOVER_SERVICES_STARTED:
String s=((NsdServiceInfo)message.obj).getServiceType();
((DiscoveryListener)listener).onDiscoveryStarted(s);
listenerRemove=false;
break;
case DISCOVER_SERVICES_FAILED:
((DiscoveryListener)listener).onStartDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case SERVICE_FOUND:
((DiscoveryListener)listener).onServiceFound((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case SERVICE_LOST:
((DiscoveryListener)listener).onServiceLost((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case STOP_DISCOVERY_FAILED:
((DiscoveryListener)listener).onStopDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case STOP_DISCOVERY_SUCCEEDED:
((DiscoveryListener)listener).onDiscoveryStopped(getNsdService(message.arg2).getServiceType());
break;
case REGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onRegistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case REGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceRegistered((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case UNREGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onUnregistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case UNREGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceUnregistered(getNsdService(message.arg2));
break;
case RESOLVE_SERVICE_FAILED:
((ResolveListener)listener).onResolveFailed(getNsdService(message.arg2),message.arg1);
break;
case RESOLVE_SERVICE_SUCCEEDED:
((ResolveListener)listener).onServiceResolved((NsdServiceInfo)message.obj);
break;
default :
Log.d(TAG,""String_Node_Str"" + message);
break;
}
if (listenerRemove) {
removeListener(message.arg2);
}
}","@Override public void handleMessage(Message message){
  Object listener=getListener(message.arg2);
  boolean listenerRemove=true;
switch (message.what) {
case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
    mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
  break;
case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
mConnected.countDown();
break;
case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
Log.e(TAG,""String_Node_Str"");
break;
case DISCOVER_SERVICES_STARTED:
String s=((NsdServiceInfo)message.obj).getServiceType();
((DiscoveryListener)listener).onDiscoveryStarted(s);
listenerRemove=false;
break;
case DISCOVER_SERVICES_FAILED:
((DiscoveryListener)listener).onStartDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case SERVICE_FOUND:
((DiscoveryListener)listener).onServiceFound((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case SERVICE_LOST:
((DiscoveryListener)listener).onServiceLost((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case STOP_DISCOVERY_FAILED:
((DiscoveryListener)listener).onStopDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case STOP_DISCOVERY_SUCCEEDED:
((DiscoveryListener)listener).onDiscoveryStopped(getNsdService(message.arg2).getServiceType());
break;
case REGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onRegistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case REGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceRegistered((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case UNREGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onUnregistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case UNREGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceUnregistered(getNsdService(message.arg2));
break;
case RESOLVE_SERVICE_FAILED:
((ResolveListener)listener).onResolveFailed(getNsdService(message.arg2),message.arg1);
break;
case RESOLVE_SERVICE_SUCCEEDED:
((ResolveListener)listener).onServiceResolved((NsdServiceInfo)message.obj);
break;
default :
Log.d(TAG,""String_Node_Str"" + message);
break;
}
if (listenerRemove) {
removeListener(message.arg2);
}
}"
2066,"private void cancelLoadingThumbnailsAndIcons(){
  if (mTaskLoader != null) {
    mTaskLoader.cancel(false);
    mTaskLoader=null;
  }
  if (mThumbnailLoader != null) {
    mThumbnailLoader.cancel(false);
    mThumbnailLoader=null;
  }
  mLoadedTasks=null;
  if (mRecentsPanel != null) {
    mRecentsPanel.onTaskLoadingCancelled();
  }
  mFirstScreenful=false;
  mState=State.CANCELLED;
}","private void cancelLoadingThumbnailsAndIcons(){
  if (mRecentsPanel != null && mRecentsPanel.isShowing()) {
    return;
  }
  if (mTaskLoader != null) {
    mTaskLoader.cancel(false);
    mTaskLoader=null;
  }
  if (mThumbnailLoader != null) {
    mThumbnailLoader.cancel(false);
    mThumbnailLoader=null;
  }
  mLoadedTasks=null;
  if (mRecentsPanel != null) {
    mRecentsPanel.onTaskLoadingCancelled();
  }
  mFirstScreenful=false;
  mState=State.CANCELLED;
}"
2067,"@Override public void onStart(){
  if (forceOpaqueBackground(this)) {
    updateWallpaperVisibility(false);
  }
 else {
    updateWallpaperVisibility(true);
  }
  mShowing=true;
  if (mRecentsPanel != null) {
    mRecentsPanel.refreshViews();
  }
  super.onStart();
}","@Override public void onStart(){
  if (forceOpaqueBackground(this)) {
    updateWallpaperVisibility(false);
  }
 else {
    updateWallpaperVisibility(true);
  }
  mShowing=true;
  if (mRecentsPanel != null) {
    mRecentsPanel.refreshRecentTasksList();
    mRecentsPanel.refreshViews();
  }
  super.onStart();
}"
2068,"private void cancelLoadingThumbnailsAndIcons(){
  if (mTaskLoader != null) {
    mTaskLoader.cancel(false);
    mTaskLoader=null;
  }
  if (mThumbnailLoader != null) {
    mThumbnailLoader.cancel(false);
    mThumbnailLoader=null;
  }
  mLoadedTasks=null;
  if (mRecentsPanel != null) {
    mRecentsPanel.onTaskLoadingCancelled();
  }
  mFirstScreenful=false;
  mState=State.CANCELLED;
}","private void cancelLoadingThumbnailsAndIcons(){
  if (mRecentsPanel != null && mRecentsPanel.isShowing()) {
    return;
  }
  if (mTaskLoader != null) {
    mTaskLoader.cancel(false);
    mTaskLoader=null;
  }
  if (mThumbnailLoader != null) {
    mThumbnailLoader.cancel(false);
    mThumbnailLoader=null;
  }
  mLoadedTasks=null;
  if (mRecentsPanel != null) {
    mRecentsPanel.onTaskLoadingCancelled();
  }
  mFirstScreenful=false;
  mState=State.CANCELLED;
}"
2069,"@Override public void onStart(){
  if (forceOpaqueBackground(this)) {
    updateWallpaperVisibility(false);
  }
 else {
    updateWallpaperVisibility(true);
  }
  mShowing=true;
  if (mRecentsPanel != null) {
    mRecentsPanel.refreshViews();
  }
  super.onStart();
}","@Override public void onStart(){
  if (forceOpaqueBackground(this)) {
    updateWallpaperVisibility(false);
  }
 else {
    updateWallpaperVisibility(true);
  }
  mShowing=true;
  if (mRecentsPanel != null) {
    mRecentsPanel.refreshRecentTasksList();
    mRecentsPanel.refreshViews();
  }
  super.onStart();
}"
2070,"public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          if (foregroundNoti.icon == 0) {
            foregroundNoti.icon=appInfo.icon;
            foregroundNoti.contentView=null;
            foregroundNoti.bigContentView=null;
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContext(appInfo.packageName,0);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              foregroundNoti.setLatestEventInfo(ctx,ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName),ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName),pi);
            }
 catch (            PackageManager.NameNotFoundException e) {
              foregroundNoti.icon=0;
            }
          }
          if (foregroundNoti.icon == 0) {
            throw new RuntimeException(""String_Node_Str"");
          }
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}","public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          if (localForegroundNoti.icon == 0) {
            localForegroundNoti.icon=appInfo.icon;
            localForegroundNoti.contentView=null;
            localForegroundNoti.bigContentView=null;
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContext(appInfo.packageName,0);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              localForegroundNoti.setLatestEventInfo(ctx,ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName),ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName),pi);
            }
 catch (            PackageManager.NameNotFoundException e) {
              localForegroundNoti.icon=0;
            }
          }
          if (localForegroundNoti.icon == 0) {
            throw new RuntimeException(""String_Node_Str"");
          }
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}"
2071,"@Override public void handleMessage(Message message){
  Object listener=getListener(message.arg2);
  boolean listenerRemove=true;
switch (message.what) {
case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
    mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
  mConnected.countDown();
break;
case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
break;
case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
Log.e(TAG,""String_Node_Str"");
break;
case DISCOVER_SERVICES_STARTED:
String s=((NsdServiceInfo)message.obj).getServiceType();
((DiscoveryListener)listener).onDiscoveryStarted(s);
listenerRemove=false;
break;
case DISCOVER_SERVICES_FAILED:
((DiscoveryListener)listener).onStartDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case SERVICE_FOUND:
((DiscoveryListener)listener).onServiceFound((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case SERVICE_LOST:
((DiscoveryListener)listener).onServiceLost((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case STOP_DISCOVERY_FAILED:
((DiscoveryListener)listener).onStopDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case STOP_DISCOVERY_SUCCEEDED:
((DiscoveryListener)listener).onDiscoveryStopped(getNsdService(message.arg2).getServiceType());
break;
case REGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onRegistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case REGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceRegistered((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case UNREGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onUnregistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case UNREGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceUnregistered(getNsdService(message.arg2));
break;
case RESOLVE_SERVICE_FAILED:
((ResolveListener)listener).onResolveFailed(getNsdService(message.arg2),message.arg1);
break;
case RESOLVE_SERVICE_SUCCEEDED:
((ResolveListener)listener).onServiceResolved((NsdServiceInfo)message.obj);
break;
default :
Log.d(TAG,""String_Node_Str"" + message);
break;
}
if (listenerRemove) {
removeListener(message.arg2);
}
}","@Override public void handleMessage(Message message){
  Object listener=getListener(message.arg2);
  boolean listenerRemove=true;
switch (message.what) {
case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
    mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
  break;
case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
mConnected.countDown();
break;
case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
Log.e(TAG,""String_Node_Str"");
break;
case DISCOVER_SERVICES_STARTED:
String s=((NsdServiceInfo)message.obj).getServiceType();
((DiscoveryListener)listener).onDiscoveryStarted(s);
listenerRemove=false;
break;
case DISCOVER_SERVICES_FAILED:
((DiscoveryListener)listener).onStartDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case SERVICE_FOUND:
((DiscoveryListener)listener).onServiceFound((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case SERVICE_LOST:
((DiscoveryListener)listener).onServiceLost((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case STOP_DISCOVERY_FAILED:
((DiscoveryListener)listener).onStopDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case STOP_DISCOVERY_SUCCEEDED:
((DiscoveryListener)listener).onDiscoveryStopped(getNsdService(message.arg2).getServiceType());
break;
case REGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onRegistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case REGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceRegistered((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case UNREGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onUnregistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case UNREGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceUnregistered(getNsdService(message.arg2));
break;
case RESOLVE_SERVICE_FAILED:
((ResolveListener)listener).onResolveFailed(getNsdService(message.arg2),message.arg1);
break;
case RESOLVE_SERVICE_SUCCEEDED:
((ResolveListener)listener).onServiceResolved((NsdServiceInfo)message.obj);
break;
default :
Log.d(TAG,""String_Node_Str"" + message);
break;
}
if (listenerRemove) {
removeListener(message.arg2);
}
}"
2072,"@Override public void setRequestedOrientation(IBinder token,int requestedOrientation){
synchronized (this) {
    ActivityRecord r=ActivityRecord.isInStackLocked(token);
    if (r == null) {
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    mWindowManager.setAppOrientation(r.appToken,requestedOrientation);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,r.mayFreezeScreenLocked(r.app) ? r.appToken : null);
    if (config != null) {
      r.frozenBeforeDestroy=true;
      if (!updateConfigurationLocked(config,r,false,false)) {
        r.task.stack.resumeTopActivityLocked(null);
      }
    }
    Binder.restoreCallingIdentity(origId);
  }
}","@Override public void setRequestedOrientation(IBinder token,int requestedOrientation){
synchronized (this) {
    ActivityRecord r=ActivityRecord.isInStackLocked(token);
    if (r == null) {
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    mWindowManager.setAppOrientation(r.appToken,requestedOrientation);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,r.mayFreezeScreenLocked(r.app) ? r.appToken : null);
    if (config != null) {
      r.frozenBeforeDestroy=true;
      if (!updateConfigurationLocked(config,r,false,false)) {
        mStackSupervisor.resumeTopActivitiesLocked();
      }
    }
    Binder.restoreCallingIdentity(origId);
  }
}"
2073,"final void activityStoppedLocked(ActivityRecord r,Bundle icicle,Bitmap thumbnail,CharSequence description){
  if (r.state != ActivityState.STOPPING) {
    Slog.i(TAG,""String_Node_Str"" + r);
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    return;
  }
  if (DEBUG_SAVED_STATE)   Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ icicle);
  if (icicle != null) {
    r.icicle=icicle;
    r.haveState=true;
    r.launchCount=0;
    r.updateThumbnail(thumbnail,description);
  }
  if (!r.stopped) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    r.stopped=true;
    r.state=ActivityState.STOPPED;
    if (r.finishing) {
      r.clearOptionsLocked();
    }
 else {
      if (r.configDestroy) {
        destroyActivityLocked(r,true,false,""String_Node_Str"");
        mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
      }
 else {
        ProcessRecord fgApp=null;
        if (mResumedActivity != null) {
          fgApp=mResumedActivity.app;
        }
 else         if (mPausingActivity != null) {
          fgApp=mPausingActivity.app;
        }
        if (r.app != null && fgApp != null && r.app != fgApp && r.lastVisibleTime > mService.mPreviousProcessVisibleTime && r.app != mService.mHomeProcess) {
          mService.mPreviousProcess=r.app;
          mService.mPreviousProcessVisibleTime=r.lastVisibleTime;
        }
      }
    }
  }
}","final void activityStoppedLocked(ActivityRecord r,Bundle icicle,Bitmap thumbnail,CharSequence description){
  if (r.state != ActivityState.STOPPING) {
    Slog.i(TAG,""String_Node_Str"" + r);
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    return;
  }
  if (DEBUG_SAVED_STATE)   Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ icicle);
  if (icicle != null) {
    r.icicle=icicle;
    r.haveState=true;
    r.launchCount=0;
    r.updateThumbnail(thumbnail,description);
  }
  if (!r.stopped) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    r.stopped=true;
    r.state=ActivityState.STOPPED;
    if (r.finishing) {
      r.clearOptionsLocked();
    }
 else {
      if (r.configDestroy) {
        destroyActivityLocked(r,true,false,""String_Node_Str"");
        mStackSupervisor.resumeTopActivitiesLocked();
      }
 else {
        ProcessRecord fgApp=null;
        if (mResumedActivity != null) {
          fgApp=mResumedActivity.app;
        }
 else         if (mPausingActivity != null) {
          fgApp=mPausingActivity.app;
        }
        if (r.app != null && fgApp != null && r.app != fgApp && r.lastVisibleTime > mService.mPreviousProcessVisibleTime && r.app != mService.mHomeProcess) {
          mService.mPreviousProcess=r.app;
          mService.mPreviousProcessVisibleTime=r.lastVisibleTime;
        }
      }
    }
  }
}"
2074,"final void destroyActivitiesLocked(ProcessRecord owner,boolean oomAdj,String reason){
  boolean lastIsOpaque=false;
  boolean activityRemoved=false;
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final ArrayList<ActivityRecord> activities=mTaskHistory.get(taskNdx).mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      final ActivityRecord r=activities.get(activityNdx);
      if (r.finishing) {
        continue;
      }
      if (r.fullscreen) {
        lastIsOpaque=true;
      }
      if (owner != null && r.app != owner) {
        continue;
      }
      if (!lastIsOpaque) {
        continue;
      }
      if (r.app != null && r != mResumedActivity && r != mPausingActivity && r.haveState && !r.visible && r.stopped && r.state != ActivityState.DESTROYING && r.state != ActivityState.DESTROYED) {
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.state+ ""String_Node_Str""+ mResumedActivity+ ""String_Node_Str""+ mPausingActivity);
        if (destroyActivityLocked(r,true,oomAdj,reason)) {
          activityRemoved=true;
        }
      }
    }
  }
  if (activityRemoved) {
    mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  }
}","final void destroyActivitiesLocked(ProcessRecord owner,boolean oomAdj,String reason){
  boolean lastIsOpaque=false;
  boolean activityRemoved=false;
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final ArrayList<ActivityRecord> activities=mTaskHistory.get(taskNdx).mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      final ActivityRecord r=activities.get(activityNdx);
      if (r.finishing) {
        continue;
      }
      if (r.fullscreen) {
        lastIsOpaque=true;
      }
      if (owner != null && r.app != owner) {
        continue;
      }
      if (!lastIsOpaque) {
        continue;
      }
      if (r.app != null && r != mResumedActivity && r != mPausingActivity && r.haveState && !r.visible && r.stopped && r.state != ActivityState.DESTROYING && r.state != ActivityState.DESTROYED) {
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.state+ ""String_Node_Str""+ mResumedActivity+ ""String_Node_Str""+ mPausingActivity);
        if (destroyActivityLocked(r,true,oomAdj,reason)) {
          activityRemoved=true;
        }
      }
    }
  }
  if (activityRemoved) {
    mStackSupervisor.resumeTopActivitiesLocked();
  }
}"
2075,"final ActivityRecord finishCurrentActivityLocked(ActivityRecord r,int mode,boolean oomAdj){
  if (mode == FINISH_AFTER_VISIBLE && r.nowVisible) {
    if (!mStackSupervisor.mStoppingActivities.contains(r)) {
      mStackSupervisor.mStoppingActivities.add(r);
      if (mStackSupervisor.mStoppingActivities.size() > 3 || r.frontOfTask && mTaskHistory.size() <= 1) {
        mStackSupervisor.scheduleIdleLocked();
      }
 else {
        checkReadyForSleepLocked();
      }
    }
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.STOPPING;
    if (oomAdj) {
      mService.updateOomAdjLocked();
    }
    return r;
  }
  mStackSupervisor.mStoppingActivities.remove(r);
  mGoingToSleepActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  final ActivityState prevState=r.state;
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + r);
  r.state=ActivityState.FINISHING;
  if (mode == FINISH_IMMEDIATELY || prevState == ActivityState.STOPPED || prevState == ActivityState.INITIALIZING) {
    boolean activityRemoved=destroyActivityLocked(r,true,oomAdj,""String_Node_Str"");
    if (activityRemoved) {
      mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
    }
    return activityRemoved ? null : r;
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + r);
  mStackSupervisor.mFinishingActivities.add(r);
  mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  return r;
}","final ActivityRecord finishCurrentActivityLocked(ActivityRecord r,int mode,boolean oomAdj){
  if (mode == FINISH_AFTER_VISIBLE && r.nowVisible) {
    if (!mStackSupervisor.mStoppingActivities.contains(r)) {
      mStackSupervisor.mStoppingActivities.add(r);
      if (mStackSupervisor.mStoppingActivities.size() > 3 || r.frontOfTask && mTaskHistory.size() <= 1) {
        mStackSupervisor.scheduleIdleLocked();
      }
 else {
        checkReadyForSleepLocked();
      }
    }
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.STOPPING;
    if (oomAdj) {
      mService.updateOomAdjLocked();
    }
    return r;
  }
  mStackSupervisor.mStoppingActivities.remove(r);
  mGoingToSleepActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  final ActivityState prevState=r.state;
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + r);
  r.state=ActivityState.FINISHING;
  if (mode == FINISH_IMMEDIATELY || prevState == ActivityState.STOPPED || prevState == ActivityState.INITIALIZING) {
    boolean activityRemoved=destroyActivityLocked(r,true,oomAdj,""String_Node_Str"");
    if (activityRemoved) {
      mStackSupervisor.resumeTopActivitiesLocked();
    }
    return activityRemoved ? null : r;
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + r);
  mStackSupervisor.mFinishingActivities.add(r);
  mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  return r;
}"
2076,"final void activityDestroyedLocked(IBinder token){
  final long origId=Binder.clearCallingIdentity();
  try {
    ActivityRecord r=ActivityRecord.forToken(token);
    if (r != null) {
      mHandler.removeMessages(DESTROY_TIMEOUT_MSG,r);
    }
    if (isInStackLocked(token) != null) {
      if (r.state == ActivityState.DESTROYING) {
        cleanUpActivityLocked(r,true,false);
        removeActivityFromHistoryLocked(r);
      }
    }
    mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","final void activityDestroyedLocked(IBinder token){
  final long origId=Binder.clearCallingIdentity();
  try {
    ActivityRecord r=ActivityRecord.forToken(token);
    if (r != null) {
      mHandler.removeMessages(DESTROY_TIMEOUT_MSG,r);
    }
    if (isInStackLocked(token) != null) {
      if (r.state == ActivityState.DESTROYING) {
        cleanUpActivityLocked(r,true,false);
        removeActivityFromHistoryLocked(r);
      }
    }
    mStackSupervisor.resumeTopActivitiesLocked();
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
2077,"void handleAppDiedLocked(ProcessRecord app,boolean restarting){
  if (!containsApp(app)) {
    return;
  }
  if (mPausingActivity != null && mPausingActivity.app == app) {
    if (DEBUG_PAUSE || DEBUG_CLEANUP)     Slog.v(TAG,""String_Node_Str"" + mPausingActivity);
    mPausingActivity=null;
  }
  if (mLastPausedActivity != null && mLastPausedActivity.app == app) {
    mLastPausedActivity=null;
  }
  boolean hasVisibleActivities=removeHistoryRecordsForAppLocked(app);
  if (!restarting) {
    ActivityStack stack=mStackSupervisor.getFocusedStack();
    if (stack == null) {
      mStackSupervisor.resumeHomeActivity(null);
    }
 else     if (!stack.resumeTopActivityLocked(null)) {
      if (hasVisibleActivities) {
        ensureActivitiesVisibleLocked(null,0);
      }
    }
  }
}","void handleAppDiedLocked(ProcessRecord app,boolean restarting){
  if (!containsApp(app)) {
    return;
  }
  if (mPausingActivity != null && mPausingActivity.app == app) {
    if (DEBUG_PAUSE || DEBUG_CLEANUP)     Slog.v(TAG,""String_Node_Str"" + mPausingActivity);
    mPausingActivity=null;
  }
  if (mLastPausedActivity != null && mLastPausedActivity.app == app) {
    mLastPausedActivity=null;
  }
  boolean hasVisibleActivities=removeHistoryRecordsForAppLocked(app);
  if (!restarting) {
    ActivityStack stack=mStackSupervisor.getFocusedStack();
    if (stack == null) {
      mStackSupervisor.resumeHomeActivity(null);
    }
 else     if (!mStackSupervisor.resumeTopActivitiesLocked(stack,null,null)) {
      if (hasVisibleActivities) {
        ensureActivitiesVisibleLocked(null,0);
      }
    }
  }
}"
2078,"final boolean resumeTopActivityLocked(ActivityRecord prev,Bundle options){
  ActivityRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mStackSupervisor.mUserLeaving;
  mStackSupervisor.mUserLeaving=false;
  if (next == null) {
    ActivityOptions.abort(options);
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return mStackSupervisor.resumeHomeActivity(prev);
  }
  next.delayedResume=false;
  if (mResumedActivity == next && next.state == ActivityState.RESUMED && mStackSupervisor.allResumedActivitiesComplete()) {
    mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    ActivityOptions.abort(options);
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  if (prev != null && prev.mLaunchHomeTaskNext && prev.finishing && prev.frontOfTask) {
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    final TaskRecord task=prev.task;
    if (topTask() != task) {
      final int taskNdx=mTaskHistory.indexOf(task) + 1;
      mTaskHistory.get(taskNdx).mActivities.get(0).mLaunchHomeTaskNext=true;
    }
 else {
      return mStackSupervisor.resumeHomeActivity(prev);
    }
  }
  if ((mService.isSleepingOrShuttingDown()) && mLastPausedActivity == next && mStackSupervisor.allPausedActivitiesComplete()) {
    mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    ActivityOptions.abort(options);
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  if (mService.mStartedUsers.get(next.userId) == null) {
    Slog.w(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ next.userId+ ""String_Node_Str"");
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  mStackSupervisor.mStoppingActivities.remove(next);
  mGoingToSleepActivities.remove(next);
  next.sleeping=false;
  mStackSupervisor.mWaitingVisibleActivities.remove(next);
  next.updateOptionsLocked(options);
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + next);
  if (!mStackSupervisor.allPausedActivitiesComplete()) {
    if (DEBUG_SWITCH || DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"");
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  if (false) {
    if (mLastStartedActivity != null && !mLastStartedActivity.finishing) {
      long now=SystemClock.uptimeMillis();
      final boolean inTime=mLastStartedActivity.startTime != 0 && (mLastStartedActivity.startTime + START_WARN_TIME) >= now;
      final int lastUid=mLastStartedActivity.info.applicationInfo.uid;
      final int nextUid=next.info.applicationInfo.uid;
      if (inTime && lastUid != nextUid && lastUid != next.launchedFromUid && mService.checkPermission(android.Manifest.permission.STOP_APP_SWITCHES,-1,next.launchedFromUid) != PackageManager.PERMISSION_GRANTED) {
        mService.showLaunchWarningLocked(mLastStartedActivity,next);
      }
 else {
        next.startTime=now;
        mLastStartedActivity=next;
      }
    }
 else {
      next.startTime=SystemClock.uptimeMillis();
      mLastStartedActivity=next;
    }
  }
  boolean pausing=mStackSupervisor.pauseBackStacks(userLeaving);
  if (mResumedActivity != null) {
    pausing=true;
    startPausingLocked(userLeaving,false);
  }
  if (pausing) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"");
    if (next.app != null && next.app.thread != null) {
      mService.updateLruProcessLocked(next.app,false);
    }
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return true;
  }
  final ActivityRecord last=mLastPausedActivity;
  if (mService.mSleeping && last != null && !last.finishing) {
    if ((last.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (last.info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
      if (DEBUG_STATES) {
        Slog.d(TAG,""String_Node_Str"" + last + ""String_Node_Str"");
      }
      requestFinishActivityLocked(last.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
    }
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mStackSupervisor.mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mWindowManager.setAppVisibility(prev.appToken,false);
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(next.packageName,false,next.userId);
  }
 catch (  RemoteException e1) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,""String_Node_Str"" + next.packageName + ""String_Node_Str""+ e);
  }
  boolean noAnim=false;
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(prev)) {
        noAnim=true;
        mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
      }
 else {
        mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_CLOSE : AppTransition.TRANSIT_TASK_CLOSE,false);
      }
      mWindowManager.setAppWillBeHidden(prev.appToken);
      mWindowManager.setAppVisibility(prev.appToken,false);
    }
 else {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(next)) {
        noAnim=true;
        mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
      }
 else {
        mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_OPEN : AppTransition.TRANSIT_TASK_OPEN,false);
      }
    }
    if (false) {
      mWindowManager.setAppWillBeHidden(prev.appToken);
      mWindowManager.setAppVisibility(prev.appToken,false);
    }
  }
 else {
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"");
    if (mNoAnimActivities.contains(next)) {
      noAnim=true;
      mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
    }
 else {
      mWindowManager.prepareAppTransition(AppTransition.TRANSIT_ACTIVITY_OPEN,false);
    }
  }
  if (!noAnim) {
    next.applyOptionsLocked();
  }
 else {
    next.clearOptionsLocked();
  }
  ActivityStack lastStack=mStackSupervisor.getLastStack();
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + next);
    mWindowManager.setAppVisibility(next.appToken,true);
    next.startLaunchTickingLocked();
    ActivityRecord lastResumedActivity=lastStack == null ? null : lastStack.mResumedActivity;
    ActivityState lastState=next.state;
    mService.updateCpuStats();
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str"");
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    mService.addRecentTaskLocked(next.task);
    mService.updateLruProcessLocked(next.app,true);
    updateLRUListLocked(next);
    boolean updated=false;
    if (mStackSupervisor.isFrontStack(this)) {
      Configuration config=mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,next.mayFreezeScreenLocked(next.app) ? next.appToken : null);
      if (config != null) {
        next.frozenBeforeDestroy=true;
      }
      updated=mService.updateConfigurationLocked(config,next,false,false);
    }
    if (!updated) {
      ActivityRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      if (mStackSupervisor.reportResumedActivityLocked(next)) {
        mNoAnimActivities.clear();
        if (DEBUG_STACK)         mStackSupervisor.validateTopActivitiesLocked();
        return true;
      }
      if (DEBUG_STACK)       mStackSupervisor.validateTopActivitiesLocked();
      return false;
    }
    try {
      ArrayList<ResultInfo> a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next.appToken,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next.appToken);
      }
      EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY,next.userId,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      next.sleeping=false;
      mService.showAskCompatModeDialogLocked(next);
      next.app.pendingUiClean=true;
      next.app.thread.scheduleResumeActivity(next.appToken,mService.isNextTransitionForward());
      checkReadyForSleepLocked();
    }
 catch (    Exception e) {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + lastState + ""String_Node_Str""+ next);
      next.state=lastState;
      if (lastStack != null) {
        lastStack.mResumedActivity=lastResumedActivity;
      }
      Slog.i(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else       if (SHOW_APP_STARTING_PREVIEW && lastStack != null && mStackSupervisor.isFrontStack(lastStack)) {
        mWindowManager.setAppStartingWindow(next.appToken,next.packageName,next.theme,mService.compatibilityInfoForPackageLocked(next.info.applicationInfo),next.nonLocalizedLabel,next.labelRes,next.icon,next.windowFlags,null,true);
      }
      mStackSupervisor.startSpecificActivityLocked(next,true,false);
      if (DEBUG_STACK)       mStackSupervisor.validateTopActivitiesLocked();
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",true);
      if (DEBUG_STACK)       mStackSupervisor.validateTopActivitiesLocked();
      return true;
    }
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_PREVIEW) {
        mWindowManager.setAppStartingWindow(next.appToken,next.packageName,next.theme,mService.compatibilityInfoForPackageLocked(next.info.applicationInfo),next.nonLocalizedLabel,next.labelRes,next.icon,next.windowFlags,null,true);
      }
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + next);
    }
    mStackSupervisor.startSpecificActivityLocked(next,true,true);
  }
  if (DEBUG_STACK)   mStackSupervisor.validateTopActivitiesLocked();
  return true;
}","final boolean resumeTopActivityLocked(ActivityRecord prev,Bundle options){
  ActivityRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mStackSupervisor.mUserLeaving;
  mStackSupervisor.mUserLeaving=false;
  if (next == null) {
    ActivityOptions.abort(options);
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return mStackSupervisor.resumeHomeActivity(prev);
  }
  next.delayedResume=false;
  if (mResumedActivity == next && next.state == ActivityState.RESUMED && mStackSupervisor.allResumedActivitiesComplete()) {
    mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    ActivityOptions.abort(options);
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  if (prev != null && prev.mLaunchHomeTaskNext && prev.finishing && prev.frontOfTask) {
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    final TaskRecord task=prev.task;
    if (topTask() != task) {
      final int taskNdx=mTaskHistory.indexOf(task) + 1;
      mTaskHistory.get(taskNdx).mActivities.get(0).mLaunchHomeTaskNext=true;
    }
 else {
      return mStackSupervisor.resumeHomeActivity(prev);
    }
  }
  if ((mService.isSleepingOrShuttingDown()) && mLastPausedActivity == next && mStackSupervisor.allPausedActivitiesComplete()) {
    mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    ActivityOptions.abort(options);
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  if (mService.mStartedUsers.get(next.userId) == null) {
    Slog.w(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ next.userId+ ""String_Node_Str"");
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  mStackSupervisor.mStoppingActivities.remove(next);
  mGoingToSleepActivities.remove(next);
  next.sleeping=false;
  mStackSupervisor.mWaitingVisibleActivities.remove(next);
  next.updateOptionsLocked(options);
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + next);
  if (!mStackSupervisor.allPausedActivitiesComplete()) {
    if (DEBUG_SWITCH || DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"");
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  if (false) {
    if (mLastStartedActivity != null && !mLastStartedActivity.finishing) {
      long now=SystemClock.uptimeMillis();
      final boolean inTime=mLastStartedActivity.startTime != 0 && (mLastStartedActivity.startTime + START_WARN_TIME) >= now;
      final int lastUid=mLastStartedActivity.info.applicationInfo.uid;
      final int nextUid=next.info.applicationInfo.uid;
      if (inTime && lastUid != nextUid && lastUid != next.launchedFromUid && mService.checkPermission(android.Manifest.permission.STOP_APP_SWITCHES,-1,next.launchedFromUid) != PackageManager.PERMISSION_GRANTED) {
        mService.showLaunchWarningLocked(mLastStartedActivity,next);
      }
 else {
        next.startTime=now;
        mLastStartedActivity=next;
      }
    }
 else {
      next.startTime=SystemClock.uptimeMillis();
      mLastStartedActivity=next;
    }
  }
  boolean pausing=mStackSupervisor.pauseBackStacks(userLeaving);
  if (mResumedActivity != null) {
    pausing=true;
    startPausingLocked(userLeaving,false);
  }
  if (pausing) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"");
    if (next.app != null && next.app.thread != null) {
      mService.updateLruProcessLocked(next.app,false);
    }
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return true;
  }
  final ActivityRecord last=mLastPausedActivity;
  if (mService.mSleeping && last != null && !last.finishing) {
    if ((last.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (last.info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
      if (DEBUG_STATES) {
        Slog.d(TAG,""String_Node_Str"" + last + ""String_Node_Str"");
      }
      requestFinishActivityLocked(last.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
    }
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mStackSupervisor.mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mWindowManager.setAppVisibility(prev.appToken,false);
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(next.packageName,false,next.userId);
  }
 catch (  RemoteException e1) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,""String_Node_Str"" + next.packageName + ""String_Node_Str""+ e);
  }
  boolean noAnim=false;
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(prev)) {
        noAnim=true;
        mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
      }
 else {
        mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_CLOSE : AppTransition.TRANSIT_TASK_CLOSE,false);
      }
      mWindowManager.setAppWillBeHidden(prev.appToken);
      mWindowManager.setAppVisibility(prev.appToken,false);
    }
 else {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(next)) {
        noAnim=true;
        mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
      }
 else {
        mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_OPEN : AppTransition.TRANSIT_TASK_OPEN,false);
      }
    }
    if (false) {
      mWindowManager.setAppWillBeHidden(prev.appToken);
      mWindowManager.setAppVisibility(prev.appToken,false);
    }
  }
 else {
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"");
    if (mNoAnimActivities.contains(next)) {
      noAnim=true;
      mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
    }
 else {
      mWindowManager.prepareAppTransition(AppTransition.TRANSIT_ACTIVITY_OPEN,false);
    }
  }
  if (!noAnim) {
    next.applyOptionsLocked();
  }
 else {
    next.clearOptionsLocked();
  }
  ActivityStack lastStack=mStackSupervisor.getLastStack();
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + next);
    mWindowManager.setAppVisibility(next.appToken,true);
    next.startLaunchTickingLocked();
    ActivityRecord lastResumedActivity=lastStack == null ? null : lastStack.mResumedActivity;
    ActivityState lastState=next.state;
    mService.updateCpuStats();
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str"");
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    mService.addRecentTaskLocked(next.task);
    mService.updateLruProcessLocked(next.app,true);
    updateLRUListLocked(next);
    boolean updated=false;
    if (mStackSupervisor.isFrontStack(this)) {
      Configuration config=mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,next.mayFreezeScreenLocked(next.app) ? next.appToken : null);
      if (config != null) {
        next.frozenBeforeDestroy=true;
      }
      updated=mService.updateConfigurationLocked(config,next,false,false);
    }
    if (!updated) {
      ActivityRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mStackSupervisor.scheduleResumeTopActivities();
      }
      if (mStackSupervisor.reportResumedActivityLocked(next)) {
        mNoAnimActivities.clear();
        if (DEBUG_STACK)         mStackSupervisor.validateTopActivitiesLocked();
        return true;
      }
      if (DEBUG_STACK)       mStackSupervisor.validateTopActivitiesLocked();
      return false;
    }
    try {
      ArrayList<ResultInfo> a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next.appToken,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next.appToken);
      }
      EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY,next.userId,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      next.sleeping=false;
      mService.showAskCompatModeDialogLocked(next);
      next.app.pendingUiClean=true;
      next.app.thread.scheduleResumeActivity(next.appToken,mService.isNextTransitionForward());
      checkReadyForSleepLocked();
    }
 catch (    Exception e) {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + lastState + ""String_Node_Str""+ next);
      next.state=lastState;
      if (lastStack != null) {
        lastStack.mResumedActivity=lastResumedActivity;
      }
      Slog.i(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else       if (SHOW_APP_STARTING_PREVIEW && lastStack != null && mStackSupervisor.isFrontStack(lastStack)) {
        mWindowManager.setAppStartingWindow(next.appToken,next.packageName,next.theme,mService.compatibilityInfoForPackageLocked(next.info.applicationInfo),next.nonLocalizedLabel,next.labelRes,next.icon,next.windowFlags,null,true);
      }
      mStackSupervisor.startSpecificActivityLocked(next,true,false);
      if (DEBUG_STACK)       mStackSupervisor.validateTopActivitiesLocked();
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",true);
      if (DEBUG_STACK)       mStackSupervisor.validateTopActivitiesLocked();
      return true;
    }
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_PREVIEW) {
        mWindowManager.setAppStartingWindow(next.appToken,next.packageName,next.theme,mService.compatibilityInfoForPackageLocked(next.info.applicationInfo),next.nonLocalizedLabel,next.labelRes,next.icon,next.windowFlags,null,true);
      }
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + next);
    }
    mStackSupervisor.startSpecificActivityLocked(next,true,true);
  }
  if (DEBUG_STACK)   mStackSupervisor.validateTopActivitiesLocked();
  return true;
}"
2079,"/** 
 * Worker method for rearranging history stack. Implements the function of moving all activities for a specific task (gathering them if disjoint) into a single group at the bottom of the stack. If a watcher is installed, the action is preflighted and the watcher has an opportunity to premeptively cancel the move.
 * @param task The taskId to collect and move to the bottom.
 * @return Returns true if the move completed, false if not.
 */
final boolean moveTaskToBackLocked(int task,ActivityRecord reason){
  Slog.i(TAG,""String_Node_Str"" + task);
  if (mStackSupervisor.isFrontStack(this) && mService.mController != null) {
    ActivityRecord next=topRunningActivityLocked(null,task);
    if (next == null) {
      next=topRunningActivityLocked(null,0);
    }
    if (next != null) {
      boolean moveOK=true;
      try {
        moveOK=mService.mController.activityResuming(next.packageName);
      }
 catch (      RemoteException e) {
        mService.mController=null;
      }
      if (!moveOK) {
        return false;
      }
    }
  }
  if (DEBUG_TRANSITION)   Slog.v(TAG,""String_Node_Str"" + task);
  final TaskRecord tr=taskForIdLocked(task);
  if (tr == null) {
    return false;
  }
  mTaskHistory.remove(tr);
  mTaskHistory.add(0,tr);
  if (reason != null && (reason.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
    ActivityRecord r=topRunningActivityLocked(null);
    if (r != null) {
      mNoAnimActivities.add(r);
    }
  }
 else {
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_TASK_TO_BACK,false);
  }
  mWindowManager.moveTaskToBottom(task);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
  if (mResumedActivity != null && mResumedActivity.task == tr && mResumedActivity.mLaunchHomeTaskNext) {
    mResumedActivity.mLaunchHomeTaskNext=false;
    return mStackSupervisor.resumeHomeActivity(null);
  }
  mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  return true;
}","/** 
 * Worker method for rearranging history stack. Implements the function of moving all activities for a specific task (gathering them if disjoint) into a single group at the bottom of the stack. If a watcher is installed, the action is preflighted and the watcher has an opportunity to premeptively cancel the move.
 * @param task The taskId to collect and move to the bottom.
 * @return Returns true if the move completed, false if not.
 */
final boolean moveTaskToBackLocked(int task,ActivityRecord reason){
  Slog.i(TAG,""String_Node_Str"" + task);
  if (mStackSupervisor.isFrontStack(this) && mService.mController != null) {
    ActivityRecord next=topRunningActivityLocked(null,task);
    if (next == null) {
      next=topRunningActivityLocked(null,0);
    }
    if (next != null) {
      boolean moveOK=true;
      try {
        moveOK=mService.mController.activityResuming(next.packageName);
      }
 catch (      RemoteException e) {
        mService.mController=null;
      }
      if (!moveOK) {
        return false;
      }
    }
  }
  if (DEBUG_TRANSITION)   Slog.v(TAG,""String_Node_Str"" + task);
  final TaskRecord tr=taskForIdLocked(task);
  if (tr == null) {
    return false;
  }
  mTaskHistory.remove(tr);
  mTaskHistory.add(0,tr);
  if (reason != null && (reason.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
    ActivityRecord r=topRunningActivityLocked(null);
    if (r != null) {
      mNoAnimActivities.add(r);
    }
  }
 else {
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_TASK_TO_BACK,false);
  }
  mWindowManager.moveTaskToBottom(task);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
  if (mResumedActivity != null && mResumedActivity.task == tr && mResumedActivity.mLaunchHomeTaskNext) {
    mResumedActivity.mLaunchHomeTaskNext=false;
    return mStackSupervisor.resumeHomeActivity(null);
  }
  mStackSupervisor.resumeTopActivitiesLocked();
  return true;
}"
2080,"final void moveTaskToFrontLocked(TaskRecord tr,ActivityRecord reason,Bundle options){
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + tr);
  final int numTasks=mTaskHistory.size();
  final int index=mTaskHistory.indexOf(tr);
  if (numTasks == 0 || index < 0 || index == numTasks - 1) {
    if (reason != null && (reason.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
      ActivityOptions.abort(options);
    }
 else {
      updateTransitLocked(AppTransition.TRANSIT_TASK_TO_FRONT,options);
    }
    return;
  }
  mTaskHistory.remove(tr);
  mTaskHistory.add(tr);
  if (DEBUG_TRANSITION)   Slog.v(TAG,""String_Node_Str"" + tr);
  if (reason != null && (reason.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
    ActivityRecord r=topRunningActivityLocked(null);
    if (r != null) {
      mNoAnimActivities.add(r);
    }
    ActivityOptions.abort(options);
  }
 else {
    updateTransitLocked(AppTransition.TRANSIT_TASK_TO_FRONT,options);
  }
  mWindowManager.moveTaskToTop(tr.taskId);
  mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  EventLog.writeEvent(EventLogTags.AM_TASK_TO_FRONT,tr.userId,tr.taskId);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
}","final void moveTaskToFrontLocked(TaskRecord tr,ActivityRecord reason,Bundle options){
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + tr);
  final int numTasks=mTaskHistory.size();
  final int index=mTaskHistory.indexOf(tr);
  if (numTasks == 0 || index < 0 || index == numTasks - 1) {
    if (reason != null && (reason.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
      ActivityOptions.abort(options);
    }
 else {
      updateTransitLocked(AppTransition.TRANSIT_TASK_TO_FRONT,options);
    }
    return;
  }
  mTaskHistory.remove(tr);
  mTaskHistory.add(tr);
  if (DEBUG_TRANSITION)   Slog.v(TAG,""String_Node_Str"" + tr);
  if (reason != null && (reason.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
    ActivityRecord r=topRunningActivityLocked(null);
    if (r != null) {
      mNoAnimActivities.add(r);
    }
    ActivityOptions.abort(options);
  }
 else {
    updateTransitLocked(AppTransition.TRANSIT_TASK_TO_FRONT,options);
  }
  mWindowManager.moveTaskToTop(tr.taskId);
  mStackSupervisor.resumeTopActivitiesLocked();
  EventLog.writeEvent(EventLogTags.AM_TASK_TO_FRONT,tr.userId,tr.taskId);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
}"
2081,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case SLEEP_TIMEOUT_MSG:
{
synchronized (mService) {
        if (mService.isSleepingOrShuttingDown()) {
          Slog.w(TAG,""String_Node_Str"");
          mSleepTimeout=true;
          checkReadyForSleepLocked();
        }
      }
    }
  break;
case PAUSE_TIMEOUT_MSG:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  Slog.w(TAG,""String_Node_Str"" + r);
synchronized (mService) {
    if (r.app != null) {
      mService.logAppTooSlow(r.app,r.pauseTime,""String_Node_Str"" + r);
    }
    activityPausedLocked(r != null ? r.appToken : null,true);
  }
}
break;
case LAUNCH_TICK_MSG:
{
ActivityRecord r=(ActivityRecord)msg.obj;
synchronized (mService) {
if (r.continueLaunchTickingLocked()) {
  mService.logAppTooSlow(r.app,r.launchTickTime,""String_Node_Str"" + r);
}
}
}
break;
case DESTROY_TIMEOUT_MSG:
{
ActivityRecord r=(ActivityRecord)msg.obj;
Slog.w(TAG,""String_Node_Str"" + r);
synchronized (mService) {
activityDestroyedLocked(r != null ? r.appToken : null);
}
}
break;
case LAUNCH_TIMEOUT_MSG:
{
if (mService.mDidDexOpt) {
mService.mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(LAUNCH_TIMEOUT_MSG);
mHandler.sendMessageDelayed(nmsg,LAUNCH_TIMEOUT);
return;
}
synchronized (mService) {
if (mLaunchingActivity.isHeld()) {
Slog.w(TAG,""String_Node_Str"");
mLaunchingActivity.release();
}
}
}
break;
case RESUME_TOP_ACTIVITY_MSG:
{
synchronized (mService) {
mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
}
}
break;
case STOP_TIMEOUT_MSG:
{
ActivityRecord r=(ActivityRecord)msg.obj;
Slog.w(TAG,""String_Node_Str"" + r);
synchronized (mService) {
if (r.isInHistory()) {
activityStoppedLocked(r,null,null,null);
}
}
}
break;
case DESTROY_ACTIVITIES_MSG:
{
ScheduleDestroyArgs args=(ScheduleDestroyArgs)msg.obj;
synchronized (mService) {
destroyActivitiesLocked(args.mOwner,args.mOomAdj,args.mReason);
}
}
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case SLEEP_TIMEOUT_MSG:
{
synchronized (mService) {
        if (mService.isSleepingOrShuttingDown()) {
          Slog.w(TAG,""String_Node_Str"");
          mSleepTimeout=true;
          checkReadyForSleepLocked();
        }
      }
    }
  break;
case PAUSE_TIMEOUT_MSG:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  Slog.w(TAG,""String_Node_Str"" + r);
synchronized (mService) {
    if (r.app != null) {
      mService.logAppTooSlow(r.app,r.pauseTime,""String_Node_Str"" + r);
    }
    activityPausedLocked(r != null ? r.appToken : null,true);
  }
}
break;
case LAUNCH_TICK_MSG:
{
ActivityRecord r=(ActivityRecord)msg.obj;
synchronized (mService) {
if (r.continueLaunchTickingLocked()) {
  mService.logAppTooSlow(r.app,r.launchTickTime,""String_Node_Str"" + r);
}
}
}
break;
case DESTROY_TIMEOUT_MSG:
{
ActivityRecord r=(ActivityRecord)msg.obj;
Slog.w(TAG,""String_Node_Str"" + r);
synchronized (mService) {
activityDestroyedLocked(r != null ? r.appToken : null);
}
}
break;
case LAUNCH_TIMEOUT_MSG:
{
if (mService.mDidDexOpt) {
mService.mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(LAUNCH_TIMEOUT_MSG);
mHandler.sendMessageDelayed(nmsg,LAUNCH_TIMEOUT);
return;
}
synchronized (mService) {
if (mLaunchingActivity.isHeld()) {
Slog.w(TAG,""String_Node_Str"");
mLaunchingActivity.release();
}
}
}
break;
case STOP_TIMEOUT_MSG:
{
ActivityRecord r=(ActivityRecord)msg.obj;
Slog.w(TAG,""String_Node_Str"" + r);
synchronized (mService) {
if (r.isInHistory()) {
activityStoppedLocked(r,null,null,null);
}
}
}
break;
case DESTROY_ACTIVITIES_MSG:
{
ScheduleDestroyArgs args=(ScheduleDestroyArgs)msg.obj;
synchronized (mService) {
destroyActivitiesLocked(args.mOwner,args.mOomAdj,args.mReason);
}
}
}
}"
2082,"final void startPausingLocked(boolean userLeaving,boolean uiSleeping){
  if (mPausingActivity != null) {
    Slog.e(TAG,""String_Node_Str"" + mPausingActivity,new RuntimeException(""String_Node_Str"").fillInStackTrace());
  }
  ActivityRecord prev=mResumedActivity;
  if (prev == null) {
    Slog.e(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
    return;
  }
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + prev);
 else   if (DEBUG_PAUSE)   Slog.v(TAG,""String_Node_Str"" + prev);
  mResumedActivity=null;
  mPausingActivity=prev;
  mLastPausedActivity=prev;
  prev.state=ActivityState.PAUSING;
  prev.task.touchActiveTime();
  prev.updateThumbnail(screenshotActivities(prev),null);
  mService.updateCpuStats();
  if (prev.app != null && prev.app.thread != null) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + prev);
    try {
      EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,prev.userId,System.identityHashCode(prev),prev.shortComponentName);
      mService.updateUsageStats(prev,false);
      prev.app.thread.schedulePauseActivity(prev.appToken,prev.finishing,userLeaving,prev.configChangeFlags);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"",e);
      mPausingActivity=null;
      mLastPausedActivity=null;
    }
  }
 else {
    mPausingActivity=null;
    mLastPausedActivity=null;
  }
  if (!mService.isSleepingOrShuttingDown()) {
    mLaunchingActivity.acquire();
    if (!mHandler.hasMessages(LAUNCH_TIMEOUT_MSG)) {
      Message msg=mHandler.obtainMessage(LAUNCH_TIMEOUT_MSG);
      mHandler.sendMessageDelayed(msg,LAUNCH_TIMEOUT);
    }
  }
  if (mPausingActivity != null) {
    if (!uiSleeping) {
      prev.pauseKeyDispatchingLocked();
    }
 else {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"");
    }
    Message msg=mHandler.obtainMessage(PAUSE_TIMEOUT_MSG);
    msg.obj=prev;
    prev.pauseTime=SystemClock.uptimeMillis();
    mHandler.sendMessageDelayed(msg,PAUSE_TIMEOUT);
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"");
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"");
    mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  }
}","final void startPausingLocked(boolean userLeaving,boolean uiSleeping){
  if (mPausingActivity != null) {
    Slog.e(TAG,""String_Node_Str"" + mPausingActivity,new RuntimeException(""String_Node_Str"").fillInStackTrace());
  }
  ActivityRecord prev=mResumedActivity;
  if (prev == null) {
    Slog.e(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    mStackSupervisor.resumeTopActivitiesLocked();
    return;
  }
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + prev);
 else   if (DEBUG_PAUSE)   Slog.v(TAG,""String_Node_Str"" + prev);
  mResumedActivity=null;
  mPausingActivity=prev;
  mLastPausedActivity=prev;
  prev.state=ActivityState.PAUSING;
  prev.task.touchActiveTime();
  prev.updateThumbnail(screenshotActivities(prev),null);
  mService.updateCpuStats();
  if (prev.app != null && prev.app.thread != null) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + prev);
    try {
      EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,prev.userId,System.identityHashCode(prev),prev.shortComponentName);
      mService.updateUsageStats(prev,false);
      prev.app.thread.schedulePauseActivity(prev.appToken,prev.finishing,userLeaving,prev.configChangeFlags);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"",e);
      mPausingActivity=null;
      mLastPausedActivity=null;
    }
  }
 else {
    mPausingActivity=null;
    mLastPausedActivity=null;
  }
  if (!mService.isSleepingOrShuttingDown()) {
    mLaunchingActivity.acquire();
    if (!mHandler.hasMessages(LAUNCH_TIMEOUT_MSG)) {
      Message msg=mHandler.obtainMessage(LAUNCH_TIMEOUT_MSG);
      mHandler.sendMessageDelayed(msg,LAUNCH_TIMEOUT);
    }
  }
  if (mPausingActivity != null) {
    if (!uiSleeping) {
      prev.pauseKeyDispatchingLocked();
    }
 else {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"");
    }
    Message msg=mHandler.obtainMessage(PAUSE_TIMEOUT_MSG);
    msg.obj=prev;
    prev.pauseTime=SystemClock.uptimeMillis();
    mHandler.sendMessageDelayed(msg,PAUSE_TIMEOUT);
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"");
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"");
    mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  }
}"
2083,"private final void completePauseLocked(){
  ActivityRecord prev=mPausingActivity;
  if (DEBUG_PAUSE)   Slog.v(TAG,""String_Node_Str"" + prev);
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + prev);
      prev=finishCurrentActivityLocked(prev,FINISH_AFTER_VISIBLE,false);
    }
 else     if (prev.app != null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (prev.waitingVisible) {
        prev.waitingVisible=false;
        mStackSupervisor.mWaitingVisibleActivities.remove(prev);
        if (DEBUG_SWITCH || DEBUG_PAUSE)         Slog.v(TAG,""String_Node_Str"" + prev);
      }
      if (prev.configDestroy) {
        if (DEBUG_PAUSE)         Slog.v(TAG,""String_Node_Str"" + prev);
        destroyActivityLocked(prev,true,false,""String_Node_Str"");
      }
 else {
        mStackSupervisor.mStoppingActivities.add(prev);
        if (mStackSupervisor.mStoppingActivities.size() > 3 || prev.frontOfTask && mTaskHistory.size() <= 1) {
          if (DEBUG_PAUSE)           Slog.v(TAG,""String_Node_Str"");
          mStackSupervisor.scheduleIdleLocked();
        }
 else {
          checkReadyForSleepLocked();
        }
      }
    }
 else {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + prev);
      prev=null;
    }
    mPausingActivity=null;
  }
  final ActivityStack topStack=mStackSupervisor.getFocusedStack();
  if (!mService.isSleepingOrShuttingDown()) {
    topStack.resumeTopActivityLocked(prev);
  }
 else {
    checkReadyForSleepLocked();
    ActivityRecord top=topStack.topRunningActivityLocked(null);
    if (top == null || (prev != null && top != prev)) {
      topStack.resumeTopActivityLocked(null);
    }
  }
  if (prev != null) {
    prev.resumeKeyDispatchingLocked();
  }
  if (prev.app != null && prev.cpuTimeAtResume > 0 && mService.mBatteryStatsService.isOnBattery()) {
    long diff=0;
synchronized (mService.mProcessStatsThread) {
      diff=mService.mProcessStats.getCpuTimeForPid(prev.app.pid) - prev.cpuTimeAtResume;
    }
    if (diff > 0) {
      BatteryStatsImpl bsi=mService.mBatteryStatsService.getActiveStatistics();
synchronized (bsi) {
        BatteryStatsImpl.Uid.Proc ps=bsi.getProcessStatsLocked(prev.info.applicationInfo.uid,prev.info.packageName);
        if (ps != null) {
          ps.addForegroundTimeLocked(diff);
        }
      }
    }
  }
  prev.cpuTimeAtResume=0;
}","private final void completePauseLocked(){
  ActivityRecord prev=mPausingActivity;
  if (DEBUG_PAUSE)   Slog.v(TAG,""String_Node_Str"" + prev);
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + prev);
      prev=finishCurrentActivityLocked(prev,FINISH_AFTER_VISIBLE,false);
    }
 else     if (prev.app != null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (prev.waitingVisible) {
        prev.waitingVisible=false;
        mStackSupervisor.mWaitingVisibleActivities.remove(prev);
        if (DEBUG_SWITCH || DEBUG_PAUSE)         Slog.v(TAG,""String_Node_Str"" + prev);
      }
      if (prev.configDestroy) {
        if (DEBUG_PAUSE)         Slog.v(TAG,""String_Node_Str"" + prev);
        destroyActivityLocked(prev,true,false,""String_Node_Str"");
      }
 else {
        mStackSupervisor.mStoppingActivities.add(prev);
        if (mStackSupervisor.mStoppingActivities.size() > 3 || prev.frontOfTask && mTaskHistory.size() <= 1) {
          if (DEBUG_PAUSE)           Slog.v(TAG,""String_Node_Str"");
          mStackSupervisor.scheduleIdleLocked();
        }
 else {
          checkReadyForSleepLocked();
        }
      }
    }
 else {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + prev);
      prev=null;
    }
    mPausingActivity=null;
  }
  final ActivityStack topStack=mStackSupervisor.getFocusedStack();
  if (!mService.isSleepingOrShuttingDown()) {
    mStackSupervisor.resumeTopActivitiesLocked(topStack,prev,null);
  }
 else {
    checkReadyForSleepLocked();
    ActivityRecord top=topStack.topRunningActivityLocked(null);
    if (top == null || (prev != null && top != prev)) {
      mStackSupervisor.resumeTopActivitiesLocked(topStack,null,null);
    }
  }
  if (prev != null) {
    prev.resumeKeyDispatchingLocked();
  }
  if (prev.app != null && prev.cpuTimeAtResume > 0 && mService.mBatteryStatsService.isOnBattery()) {
    long diff=0;
synchronized (mService.mProcessStatsThread) {
      diff=mService.mProcessStats.getCpuTimeForPid(prev.app.pid) - prev.cpuTimeAtResume;
    }
    if (diff > 0) {
      BatteryStatsImpl bsi=mService.mBatteryStatsService.getActiveStatistics();
synchronized (bsi) {
        BatteryStatsImpl.Uid.Proc ps=bsi.getProcessStatsLocked(prev.info.applicationInfo.uid,prev.info.packageName);
        if (ps != null) {
          ps.addForegroundTimeLocked(diff);
        }
      }
    }
  }
  prev.cpuTimeAtResume=0;
}"
2084,"final ActivityRecord activityIdleInternalLocked(final IBinder token,boolean fromTimeout,Configuration config){
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + token);
  ActivityRecord res=null;
  ArrayList<ActivityRecord> stops=null;
  ArrayList<ActivityRecord> finishes=null;
  ArrayList<UserStartedState> startingUsers=null;
  int NS=0;
  int NF=0;
  IApplicationThread sendThumbnail=null;
  boolean booting=false;
  boolean enableScreen=false;
  boolean activityRemoved=false;
  ActivityRecord r=ActivityRecord.forToken(token);
  if (r != null) {
    mHandler.removeMessages(IDLE_TIMEOUT_MSG,r);
    r.finishLaunchTickingLocked();
    res=r.task.stack.activityIdleInternalLocked(token,fromTimeout,config);
    if (res != null) {
      if (fromTimeout) {
        reportActivityLaunchedLocked(fromTimeout,r,-1,-1);
      }
      if (config != null) {
        r.configuration=config;
      }
      r.idle=true;
      if (allResumedActivitiesIdle()) {
        mService.scheduleAppGcsLocked();
      }
      if (r.thumbnailNeeded && r.app != null && r.app.thread != null) {
        sendThumbnail=r.app.thread;
        r.thumbnailNeeded=false;
      }
      if (!mService.mBooted && isFrontStack(r.task.stack)) {
        mService.mBooted=true;
        enableScreen=true;
      }
    }
 else     if (fromTimeout) {
      reportActivityLaunchedLocked(fromTimeout,null,-1,-1);
    }
  }
  stops=processStoppingActivitiesLocked(true);
  NS=stops != null ? stops.size() : 0;
  if ((NF=mFinishingActivities.size()) > 0) {
    finishes=new ArrayList<ActivityRecord>(mFinishingActivities);
    mFinishingActivities.clear();
  }
  final ArrayList<ActivityRecord> thumbnails;
  final int NT=mCancelledThumbnails.size();
  if (NT > 0) {
    thumbnails=new ArrayList<ActivityRecord>(mCancelledThumbnails);
    mCancelledThumbnails.clear();
  }
 else {
    thumbnails=null;
  }
  if (isFrontStack(mHomeStack)) {
    booting=mService.mBooting;
    mService.mBooting=false;
  }
  if (mStartingUsers.size() > 0) {
    startingUsers=new ArrayList<UserStartedState>(mStartingUsers);
    mStartingUsers.clear();
  }
  final IApplicationThread thumbnailThread=sendThumbnail;
  mHandler.post(new Runnable(){
    @Override public void run(){
      if (thumbnailThread != null) {
        try {
          thumbnailThread.requestThumbnail(token);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"",e);
          mService.sendPendingThumbnail(null,token,null,null,true);
        }
      }
      for (int i=0; i < NT; i++) {
        ActivityRecord r=thumbnails.get(i);
        mService.sendPendingThumbnail(r,null,null,null,true);
      }
    }
  }
);
  for (int i=0; i < NS; i++) {
    r=stops.get(i);
    final ActivityStack stack=r.task.stack;
    if (r.finishing) {
      stack.finishCurrentActivityLocked(r,ActivityStack.FINISH_IMMEDIATELY,false);
    }
 else {
      stack.stopActivityLocked(r);
    }
  }
  for (int i=0; i < NF; i++) {
    r=finishes.get(i);
    activityRemoved|=r.task.stack.destroyActivityLocked(r,true,false,""String_Node_Str"");
  }
  if (booting) {
    mService.finishBooting();
  }
 else   if (startingUsers != null) {
    for (int i=0; i < startingUsers.size(); i++) {
      mService.finishUserSwitch(startingUsers.get(i));
    }
  }
  mService.trimApplications();
  if (enableScreen) {
    mService.enableScreenAfterBoot();
  }
  if (activityRemoved) {
    getFocusedStack().resumeTopActivityLocked(null);
  }
  return res;
}","final ActivityRecord activityIdleInternalLocked(final IBinder token,boolean fromTimeout,Configuration config){
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + token);
  ActivityRecord res=null;
  ArrayList<ActivityRecord> stops=null;
  ArrayList<ActivityRecord> finishes=null;
  ArrayList<UserStartedState> startingUsers=null;
  int NS=0;
  int NF=0;
  IApplicationThread sendThumbnail=null;
  boolean booting=false;
  boolean enableScreen=false;
  boolean activityRemoved=false;
  ActivityRecord r=ActivityRecord.forToken(token);
  if (r != null) {
    mHandler.removeMessages(IDLE_TIMEOUT_MSG,r);
    r.finishLaunchTickingLocked();
    res=r.task.stack.activityIdleInternalLocked(token,fromTimeout,config);
    if (res != null) {
      if (fromTimeout) {
        reportActivityLaunchedLocked(fromTimeout,r,-1,-1);
      }
      if (config != null) {
        r.configuration=config;
      }
      r.idle=true;
      if (allResumedActivitiesIdle()) {
        mService.scheduleAppGcsLocked();
      }
      if (r.thumbnailNeeded && r.app != null && r.app.thread != null) {
        sendThumbnail=r.app.thread;
        r.thumbnailNeeded=false;
      }
      if (!mService.mBooted && isFrontStack(r.task.stack)) {
        mService.mBooted=true;
        enableScreen=true;
      }
    }
 else     if (fromTimeout) {
      reportActivityLaunchedLocked(fromTimeout,null,-1,-1);
    }
  }
  stops=processStoppingActivitiesLocked(true);
  NS=stops != null ? stops.size() : 0;
  if ((NF=mFinishingActivities.size()) > 0) {
    finishes=new ArrayList<ActivityRecord>(mFinishingActivities);
    mFinishingActivities.clear();
  }
  final ArrayList<ActivityRecord> thumbnails;
  final int NT=mCancelledThumbnails.size();
  if (NT > 0) {
    thumbnails=new ArrayList<ActivityRecord>(mCancelledThumbnails);
    mCancelledThumbnails.clear();
  }
 else {
    thumbnails=null;
  }
  if (isFrontStack(mHomeStack)) {
    booting=mService.mBooting;
    mService.mBooting=false;
  }
  if (mStartingUsers.size() > 0) {
    startingUsers=new ArrayList<UserStartedState>(mStartingUsers);
    mStartingUsers.clear();
  }
  final IApplicationThread thumbnailThread=sendThumbnail;
  mHandler.post(new Runnable(){
    @Override public void run(){
      if (thumbnailThread != null) {
        try {
          thumbnailThread.requestThumbnail(token);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"",e);
          mService.sendPendingThumbnail(null,token,null,null,true);
        }
      }
      for (int i=0; i < NT; i++) {
        ActivityRecord r=thumbnails.get(i);
        mService.sendPendingThumbnail(r,null,null,null,true);
      }
    }
  }
);
  for (int i=0; i < NS; i++) {
    r=stops.get(i);
    final ActivityStack stack=r.task.stack;
    if (r.finishing) {
      stack.finishCurrentActivityLocked(r,ActivityStack.FINISH_IMMEDIATELY,false);
    }
 else {
      stack.stopActivityLocked(r);
    }
  }
  for (int i=0; i < NF; i++) {
    r=finishes.get(i);
    activityRemoved|=r.task.stack.destroyActivityLocked(r,true,false,""String_Node_Str"");
  }
  if (booting) {
    mService.finishBooting();
  }
 else   if (startingUsers != null) {
    for (int i=0; i < startingUsers.size(); i++) {
      mService.finishUserSwitch(startingUsers.get(i));
    }
  }
  mService.trimApplications();
  if (enableScreen) {
    mService.enableScreenAfterBoot();
  }
  if (activityRemoved) {
    resumeTopActivitiesLocked();
  }
  return res;
}"
2085,"boolean resumeHomeActivity(ActivityRecord prev){
  moveHomeStack(true);
  if (prev != null) {
    prev.mLaunchHomeTaskNext=false;
  }
  if (mHomeStack.topRunningActivityLocked(null) != null) {
    return mHomeStack.resumeTopActivityLocked(prev);
  }
  return mService.startHomeActivityLocked(mCurrentUser);
}","boolean resumeHomeActivity(ActivityRecord prev){
  moveHomeStack(true);
  if (prev != null) {
    prev.mLaunchHomeTaskNext=false;
  }
  if (mHomeStack.topRunningActivityLocked(null) != null) {
    return resumeTopActivitiesLocked(mHomeStack,prev,null);
  }
  return mService.startHomeActivityLocked(mCurrentUser);
}"
2086,"void comeOutOfSleepIfNeededLocked(){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    final ActivityStack stack=mStacks.get(stackNdx);
    stack.awakeFromSleepingLocked();
    if (isFrontStack(stack)) {
      stack.resumeTopActivityLocked(null);
    }
  }
}","void comeOutOfSleepIfNeededLocked(){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    final ActivityStack stack=mStacks.get(stackNdx);
    stack.awakeFromSleepingLocked();
    if (isFrontStack(stack)) {
      resumeTopActivitiesLocked();
    }
  }
}"
2087,"final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  final TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(intent,r.info) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && curTop.task != intentActivity.task) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || sourceStack.topActivity() == sourceRecord) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              topStack.resumeTopActivityLocked(null);
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=getCorrectStack(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    targetStack=sourceRecord.task.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceRecord.task.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=targetStack.findActivityInHistoryLocked(r,sourceRecord.task);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceRecord.task,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    ActivityStack lastStack=getLastStack();
    targetStack=lastStack != null ? lastStack : mHomeStack;
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=lastStack == null ? null : targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  return ActivityManager.START_SUCCESS;
}","final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  final TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(intent,r.info) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && curTop.task != intentActivity.task) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || sourceStack.topActivity() == sourceRecord) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=getCorrectStack(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    targetStack=sourceRecord.task.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceRecord.task.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=targetStack.findActivityInHistoryLocked(r,sourceRecord.task);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceRecord.task,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    ActivityStack lastStack=getLastStack();
    targetStack=lastStack != null ? lastStack : mHomeStack;
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=lastStack == null ? null : targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  return ActivityManager.START_SUCCESS;
}"
2088,"void resumeTopActivitiesLocked(){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    final ActivityStack stack=mStacks.get(stackNdx);
    if (isFrontStack(stack)) {
      stack.resumeTopActivityLocked(null);
    }
  }
}","boolean resumeTopActivitiesLocked(ActivityStack targetStack,ActivityRecord target,Bundle targetOptions){
  if (targetStack == null) {
    targetStack=getFocusedStack();
  }
  boolean result=false;
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    final ActivityStack stack=mStacks.get(stackNdx);
    if (isFrontStack(stack)) {
      if (stack == targetStack) {
        result=stack.resumeTopActivityLocked(target,targetOptions);
      }
 else {
        stack.resumeTopActivityLocked(null);
      }
    }
  }
  return result;
}"
2089,"final void scheduleIdleLocked(){
  mHandler.obtainMessage(IDLE_NOW_MSG).sendToTarget();
}","final void scheduleIdleLocked(){
  mHandler.sendEmptyMessage(IDLE_NOW_MSG);
}"
2090,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case IDLE_TIMEOUT_MSG:
{
      if (mService.mDidDexOpt) {
        mService.mDidDexOpt=false;
        Message nmsg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG);
        nmsg.obj=msg.obj;
        mHandler.sendMessageDelayed(nmsg,IDLE_TIMEOUT);
        return;
      }
      activityIdleInternal((ActivityRecord)msg.obj);
    }
  break;
case IDLE_NOW_MSG:
{
  activityIdleInternal((ActivityRecord)msg.obj);
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case IDLE_TIMEOUT_MSG:
{
      if (mService.mDidDexOpt) {
        mService.mDidDexOpt=false;
        Message nmsg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG);
        nmsg.obj=msg.obj;
        mHandler.sendMessageDelayed(nmsg,IDLE_TIMEOUT);
        return;
      }
      activityIdleInternal((ActivityRecord)msg.obj);
    }
  break;
case IDLE_NOW_MSG:
{
  activityIdleInternal((ActivityRecord)msg.obj);
}
break;
case RESUME_TOP_ACTIVITY_MSG:
{
synchronized (mService) {
resumeTopActivitiesLocked();
}
}
break;
}
}"
2091,"void moveTaskToStack(int taskId,int stackId,boolean toTop){
  final ActivityStack stack=getStack(stackId);
  if (stack == null) {
    Slog.w(TAG,""String_Node_Str"" + stackId);
    return;
  }
  stack.moveTask(taskId,toTop);
  stack.resumeTopActivityLocked(null);
}","void moveTaskToStack(int taskId,int stackId,boolean toTop){
  final ActivityStack stack=getStack(stackId);
  if (stack == null) {
    Slog.w(TAG,""String_Node_Str"" + stackId);
    return;
  }
  stack.moveTask(taskId,toTop);
  resumeTopActivitiesLocked();
}"
2092,"/** 
 * Begin an animation to a new dim value. NOTE: Must be called with Surface transaction open.
 * @param layer The layer to set the surface to.
 * @param alpha The dim value to end at.
 * @param duration How long to take to get there in milliseconds.
 */
void show(int layer,float alpha,long duration){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + layer + ""String_Node_Str""+ alpha+ ""String_Node_Str""+ duration);
  if (mDimSurface == null) {
    Slog.e(TAG,""String_Node_Str"");
    mTargetAlpha=mAlpha=0;
    return;
  }
  final DisplayInfo info=mDisplayContent.getDisplayInfo();
  final int dw=(int)(info.logicalWidth * 1.5);
  final int dh=(int)(info.logicalHeight * 1.5);
  final float xPos=-1 * dw / 6;
  final float yPos=-1 * dh / 6;
  if (mLastDimWidth != dw || mLastDimHeight != dh || mLayer != layer) {
    try {
      mDimSurface.setPosition(xPos,yPos);
      mDimSurface.setSize(dw,dh);
      mDimSurface.setLayer(layer);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
    mLastDimWidth=dw;
    mLastDimHeight=dh;
    mLayer=layer;
  }
  long curTime=SystemClock.uptimeMillis();
  final boolean animating=isAnimating();
  if ((animating && (mTargetAlpha != alpha || durationEndsEarlier(duration))) || (!animating && mAlpha != alpha)) {
    if (duration <= 0) {
      setAlpha(alpha);
    }
 else {
      mStartAlpha=mAlpha;
      mStartTime=curTime;
      mDuration=duration;
    }
  }
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + mStartAlpha + ""String_Node_Str""+ mStartTime);
  mTargetAlpha=alpha;
}","/** 
 * Begin an animation to a new dim value. NOTE: Must be called with Surface transaction open.
 * @param layer The layer to set the surface to.
 * @param alpha The dim value to end at.
 * @param duration How long to take to get there in milliseconds.
 */
void show(int layer,float alpha,long duration){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + layer + ""String_Node_Str""+ alpha+ ""String_Node_Str""+ duration);
  if (mDimSurface == null) {
    Slog.e(TAG,""String_Node_Str"");
    mTargetAlpha=mAlpha=0;
    return;
  }
  if (!mLastBounds.equals(mBounds) || mLayer != layer) {
    try {
      mDimSurface.setPosition(mBounds.left,mBounds.top);
      mDimSurface.setSize(mBounds.width(),mBounds.height());
      mDimSurface.setLayer(layer);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
    mLastBounds.set(mBounds);
    mLayer=layer;
  }
  long curTime=SystemClock.uptimeMillis();
  final boolean animating=isAnimating();
  if ((animating && (mTargetAlpha != alpha || durationEndsEarlier(duration))) || (!animating && mAlpha != alpha)) {
    if (duration <= 0) {
      setAlpha(alpha);
    }
 else {
      mStartAlpha=mAlpha;
      mStartTime=curTime;
      mDuration=duration;
    }
  }
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + mStartAlpha + ""String_Node_Str""+ mStartTime);
  mTargetAlpha=alpha;
}"
2093,"public void printTo(String prefix,PrintWriter pw){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDimSurface);
  pw.print(""String_Node_Str"");
  pw.print(mLayer);
  pw.print(""String_Node_Str"");
  pw.println(mAlpha);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLastDimWidth);
  pw.print(""String_Node_Str"");
  pw.println(mLastDimHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(mDuration);
  pw.print(""String_Node_Str"");
  pw.print(mStartTime);
  pw.print(""String_Node_Str"");
  pw.println(SystemClock.uptimeMillis());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStartAlpha);
  pw.print(""String_Node_Str"");
  pw.println(mTargetAlpha);
}","public void printTo(String prefix,PrintWriter pw){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDimSurface);
  pw.print(""String_Node_Str"");
  pw.print(mLayer);
  pw.print(""String_Node_Str"");
  pw.println(mAlpha);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLastBounds.toShortString());
  pw.print(""String_Node_Str"");
  pw.println(mBounds.toShortString());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(mDuration);
  pw.print(""String_Node_Str"");
  pw.print(mStartTime);
  pw.print(""String_Node_Str"");
  pw.println(SystemClock.uptimeMillis());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStartAlpha);
  pw.print(""String_Node_Str"");
  pw.println(mTargetAlpha);
}"
2094,"public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          if (foregroundNoti.icon == 0) {
            foregroundNoti.icon=appInfo.icon;
            foregroundNoti.contentView=null;
            foregroundNoti.bigContentView=null;
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContext(appInfo.packageName,0);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              foregroundNoti.setLatestEventInfo(ctx,ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName),ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName),pi);
            }
 catch (            PackageManager.NameNotFoundException e) {
              foregroundNoti.icon=0;
            }
          }
          if (foregroundNoti.icon == 0) {
            throw new RuntimeException(""String_Node_Str"");
          }
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}","public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          if (localForegroundNoti.icon == 0) {
            localForegroundNoti.icon=appInfo.icon;
            localForegroundNoti.contentView=null;
            localForegroundNoti.bigContentView=null;
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContext(appInfo.packageName,0);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              localForegroundNoti.setLatestEventInfo(ctx,ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName),ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName),pi);
            }
 catch (            PackageManager.NameNotFoundException e) {
              localForegroundNoti.icon=0;
            }
          }
          if (localForegroundNoti.icon == 0) {
            throw new RuntimeException(""String_Node_Str"");
          }
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}"
2095,"public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          if (foregroundNoti.icon == 0) {
            foregroundNoti.icon=appInfo.icon;
            foregroundNoti.contentView=null;
            foregroundNoti.bigContentView=null;
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContext(appInfo.packageName,0);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              foregroundNoti.setLatestEventInfo(ctx,ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName),ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName),pi);
            }
 catch (            PackageManager.NameNotFoundException e) {
              foregroundNoti.icon=0;
            }
          }
          if (foregroundNoti.icon == 0) {
            throw new RuntimeException(""String_Node_Str"");
          }
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}","public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          if (localForegroundNoti.icon == 0) {
            localForegroundNoti.icon=appInfo.icon;
            localForegroundNoti.contentView=null;
            localForegroundNoti.bigContentView=null;
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContext(appInfo.packageName,0);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              localForegroundNoti.setLatestEventInfo(ctx,ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName),ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName),pi);
            }
 catch (            PackageManager.NameNotFoundException e) {
              localForegroundNoti.icon=0;
            }
          }
          if (localForegroundNoti.icon == 0) {
            throw new RuntimeException(""String_Node_Str"");
          }
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}"
2096,"private static void exportMethods(Context context,Object view,BufferedWriter out,Class<?> klass,String prefix) throws IOException {
  final Method[] methods=getExportedPropertyMethods(klass);
  int count=methods.length;
  for (int i=0; i < count; i++) {
    final Method method=methods[i];
    try {
      Object methodValue=method.invoke(view,(Object[])null);
      final Class<?> returnType=method.getReturnType();
      final ExportedProperty property=sAnnotations.get(method);
      String categoryPrefix=property.category().length() != 0 ? property.category() + ""String_Node_Str"" : ""String_Node_Str"";
      if (returnType == int.class) {
        if (property.resolveId() && context != null) {
          final int id=(Integer)methodValue;
          methodValue=resolveId(context,id);
        }
 else {
          final FlagToString[] flagsMapping=property.flagMapping();
          if (flagsMapping.length > 0) {
            final int intValue=(Integer)methodValue;
            final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
            exportUnrolledFlags(out,flagsMapping,intValue,valuePrefix);
          }
          final IntToString[] mapping=property.mapping();
          if (mapping.length > 0) {
            final int intValue=(Integer)methodValue;
            boolean mapped=false;
            int mappingCount=mapping.length;
            for (int j=0; j < mappingCount; j++) {
              final IntToString mapper=mapping[j];
              if (mapper.from() == intValue) {
                methodValue=mapper.to();
                mapped=true;
                break;
              }
            }
            if (!mapped) {
              methodValue=intValue;
            }
          }
        }
      }
 else       if (returnType == int[].class) {
        final int[] array=(int[])methodValue;
        final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
        final String suffix=""String_Node_Str"";
        exportUnrolledArray(context,out,property,array,valuePrefix,suffix);
        return;
      }
 else       if (!returnType.isPrimitive()) {
        if (property.deepExport()) {
          dumpViewProperties(context,methodValue,out,prefix + property.prefix());
          continue;
        }
      }
      writeEntry(out,categoryPrefix + prefix,method.getName(),""String_Node_Str"",methodValue);
    }
 catch (    IllegalAccessException e) {
    }
catch (    InvocationTargetException e) {
    }
  }
}","private static void exportMethods(Context context,Object view,BufferedWriter out,Class<?> klass,String prefix) throws IOException {
  final Method[] methods=getExportedPropertyMethods(klass);
  int count=methods.length;
  for (int i=0; i < count; i++) {
    final Method method=methods[i];
    try {
      Object methodValue=callMethodOnAppropriateTheadBlocking(method,view);
      final Class<?> returnType=method.getReturnType();
      final ExportedProperty property=sAnnotations.get(method);
      String categoryPrefix=property.category().length() != 0 ? property.category() + ""String_Node_Str"" : ""String_Node_Str"";
      if (returnType == int.class) {
        if (property.resolveId() && context != null) {
          final int id=(Integer)methodValue;
          methodValue=resolveId(context,id);
        }
 else {
          final FlagToString[] flagsMapping=property.flagMapping();
          if (flagsMapping.length > 0) {
            final int intValue=(Integer)methodValue;
            final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
            exportUnrolledFlags(out,flagsMapping,intValue,valuePrefix);
          }
          final IntToString[] mapping=property.mapping();
          if (mapping.length > 0) {
            final int intValue=(Integer)methodValue;
            boolean mapped=false;
            int mappingCount=mapping.length;
            for (int j=0; j < mappingCount; j++) {
              final IntToString mapper=mapping[j];
              if (mapper.from() == intValue) {
                methodValue=mapper.to();
                mapped=true;
                break;
              }
            }
            if (!mapped) {
              methodValue=intValue;
            }
          }
        }
      }
 else       if (returnType == int[].class) {
        final int[] array=(int[])methodValue;
        final String valuePrefix=categoryPrefix + prefix + method.getName()+ '_';
        final String suffix=""String_Node_Str"";
        exportUnrolledArray(context,out,property,array,valuePrefix,suffix);
        return;
      }
 else       if (!returnType.isPrimitive()) {
        if (property.deepExport()) {
          dumpViewProperties(context,methodValue,out,prefix + property.prefix());
          continue;
        }
      }
      writeEntry(out,categoryPrefix + prefix,method.getName(),""String_Node_Str"",methodValue);
    }
 catch (    IllegalAccessException e) {
    }
catch (    InvocationTargetException e) {
    }
catch (    TimeoutException e) {
    }
  }
}"
2097,"@Override public void setRequestedOrientation(IBinder token,int requestedOrientation){
synchronized (this) {
    ActivityRecord r=ActivityRecord.isInStackLocked(token);
    if (r == null) {
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    mWindowManager.setAppOrientation(r.appToken,requestedOrientation);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,r.mayFreezeScreenLocked(r.app) ? r.appToken : null);
    if (config != null) {
      r.frozenBeforeDestroy=true;
      if (!updateConfigurationLocked(config,r,false,false)) {
        r.task.stack.resumeTopActivityLocked(null);
      }
    }
    Binder.restoreCallingIdentity(origId);
  }
}","@Override public void setRequestedOrientation(IBinder token,int requestedOrientation){
synchronized (this) {
    ActivityRecord r=ActivityRecord.isInStackLocked(token);
    if (r == null) {
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    mWindowManager.setAppOrientation(r.appToken,requestedOrientation);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,r.mayFreezeScreenLocked(r.app) ? r.appToken : null);
    if (config != null) {
      r.frozenBeforeDestroy=true;
      if (!updateConfigurationLocked(config,r,false,false)) {
        mStackSupervisor.resumeTopActivitiesLocked();
      }
    }
    Binder.restoreCallingIdentity(origId);
  }
}"
2098,"final void activityStoppedLocked(ActivityRecord r,Bundle icicle,Bitmap thumbnail,CharSequence description){
  if (r.state != ActivityState.STOPPING) {
    Slog.i(TAG,""String_Node_Str"" + r);
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    return;
  }
  if (DEBUG_SAVED_STATE)   Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ icicle);
  if (icicle != null) {
    r.icicle=icicle;
    r.haveState=true;
    r.launchCount=0;
    r.updateThumbnail(thumbnail,description);
  }
  if (!r.stopped) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    r.stopped=true;
    r.state=ActivityState.STOPPED;
    if (r.finishing) {
      r.clearOptionsLocked();
    }
 else {
      if (r.configDestroy) {
        destroyActivityLocked(r,true,false,""String_Node_Str"");
        mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
      }
 else {
        ProcessRecord fgApp=null;
        if (mResumedActivity != null) {
          fgApp=mResumedActivity.app;
        }
 else         if (mPausingActivity != null) {
          fgApp=mPausingActivity.app;
        }
        if (r.app != null && fgApp != null && r.app != fgApp && r.lastVisibleTime > mService.mPreviousProcessVisibleTime && r.app != mService.mHomeProcess) {
          mService.mPreviousProcess=r.app;
          mService.mPreviousProcessVisibleTime=r.lastVisibleTime;
        }
      }
    }
  }
}","final void activityStoppedLocked(ActivityRecord r,Bundle icicle,Bitmap thumbnail,CharSequence description){
  if (r.state != ActivityState.STOPPING) {
    Slog.i(TAG,""String_Node_Str"" + r);
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    return;
  }
  if (DEBUG_SAVED_STATE)   Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ icicle);
  if (icicle != null) {
    r.icicle=icicle;
    r.haveState=true;
    r.launchCount=0;
    r.updateThumbnail(thumbnail,description);
  }
  if (!r.stopped) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    r.stopped=true;
    r.state=ActivityState.STOPPED;
    if (r.finishing) {
      r.clearOptionsLocked();
    }
 else {
      if (r.configDestroy) {
        destroyActivityLocked(r,true,false,""String_Node_Str"");
        mStackSupervisor.resumeTopActivitiesLocked();
      }
 else {
        ProcessRecord fgApp=null;
        if (mResumedActivity != null) {
          fgApp=mResumedActivity.app;
        }
 else         if (mPausingActivity != null) {
          fgApp=mPausingActivity.app;
        }
        if (r.app != null && fgApp != null && r.app != fgApp && r.lastVisibleTime > mService.mPreviousProcessVisibleTime && r.app != mService.mHomeProcess) {
          mService.mPreviousProcess=r.app;
          mService.mPreviousProcessVisibleTime=r.lastVisibleTime;
        }
      }
    }
  }
}"
2099,"final void destroyActivitiesLocked(ProcessRecord owner,boolean oomAdj,String reason){
  boolean lastIsOpaque=false;
  boolean activityRemoved=false;
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final ArrayList<ActivityRecord> activities=mTaskHistory.get(taskNdx).mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      final ActivityRecord r=activities.get(activityNdx);
      if (r.finishing) {
        continue;
      }
      if (r.fullscreen) {
        lastIsOpaque=true;
      }
      if (owner != null && r.app != owner) {
        continue;
      }
      if (!lastIsOpaque) {
        continue;
      }
      if (r.app != null && r != mResumedActivity && r != mPausingActivity && r.haveState && !r.visible && r.stopped && r.state != ActivityState.DESTROYING && r.state != ActivityState.DESTROYED) {
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.state+ ""String_Node_Str""+ mResumedActivity+ ""String_Node_Str""+ mPausingActivity);
        if (destroyActivityLocked(r,true,oomAdj,reason)) {
          activityRemoved=true;
        }
      }
    }
  }
  if (activityRemoved) {
    mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  }
}","final void destroyActivitiesLocked(ProcessRecord owner,boolean oomAdj,String reason){
  boolean lastIsOpaque=false;
  boolean activityRemoved=false;
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final ArrayList<ActivityRecord> activities=mTaskHistory.get(taskNdx).mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      final ActivityRecord r=activities.get(activityNdx);
      if (r.finishing) {
        continue;
      }
      if (r.fullscreen) {
        lastIsOpaque=true;
      }
      if (owner != null && r.app != owner) {
        continue;
      }
      if (!lastIsOpaque) {
        continue;
      }
      if (r.app != null && r != mResumedActivity && r != mPausingActivity && r.haveState && !r.visible && r.stopped && r.state != ActivityState.DESTROYING && r.state != ActivityState.DESTROYED) {
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.state+ ""String_Node_Str""+ mResumedActivity+ ""String_Node_Str""+ mPausingActivity);
        if (destroyActivityLocked(r,true,oomAdj,reason)) {
          activityRemoved=true;
        }
      }
    }
  }
  if (activityRemoved) {
    mStackSupervisor.resumeTopActivitiesLocked();
  }
}"
2100,"final ActivityRecord finishCurrentActivityLocked(ActivityRecord r,int mode,boolean oomAdj){
  if (mode == FINISH_AFTER_VISIBLE && r.nowVisible) {
    if (!mStackSupervisor.mStoppingActivities.contains(r)) {
      mStackSupervisor.mStoppingActivities.add(r);
      if (mStackSupervisor.mStoppingActivities.size() > 3 || r.frontOfTask && mTaskHistory.size() <= 1) {
        mStackSupervisor.scheduleIdleLocked();
      }
 else {
        checkReadyForSleepLocked();
      }
    }
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.STOPPING;
    if (oomAdj) {
      mService.updateOomAdjLocked();
    }
    return r;
  }
  mStackSupervisor.mStoppingActivities.remove(r);
  mGoingToSleepActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  final ActivityState prevState=r.state;
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + r);
  r.state=ActivityState.FINISHING;
  if (mode == FINISH_IMMEDIATELY || prevState == ActivityState.STOPPED || prevState == ActivityState.INITIALIZING) {
    boolean activityRemoved=destroyActivityLocked(r,true,oomAdj,""String_Node_Str"");
    if (activityRemoved) {
      mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
    }
    return activityRemoved ? null : r;
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + r);
  mStackSupervisor.mFinishingActivities.add(r);
  mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  return r;
}","final ActivityRecord finishCurrentActivityLocked(ActivityRecord r,int mode,boolean oomAdj){
  if (mode == FINISH_AFTER_VISIBLE && r.nowVisible) {
    if (!mStackSupervisor.mStoppingActivities.contains(r)) {
      mStackSupervisor.mStoppingActivities.add(r);
      if (mStackSupervisor.mStoppingActivities.size() > 3 || r.frontOfTask && mTaskHistory.size() <= 1) {
        mStackSupervisor.scheduleIdleLocked();
      }
 else {
        checkReadyForSleepLocked();
      }
    }
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.STOPPING;
    if (oomAdj) {
      mService.updateOomAdjLocked();
    }
    return r;
  }
  mStackSupervisor.mStoppingActivities.remove(r);
  mGoingToSleepActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  final ActivityState prevState=r.state;
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + r);
  r.state=ActivityState.FINISHING;
  if (mode == FINISH_IMMEDIATELY || prevState == ActivityState.STOPPED || prevState == ActivityState.INITIALIZING) {
    boolean activityRemoved=destroyActivityLocked(r,true,oomAdj,""String_Node_Str"");
    if (activityRemoved) {
      mStackSupervisor.resumeTopActivitiesLocked();
    }
    return activityRemoved ? null : r;
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + r);
  mStackSupervisor.mFinishingActivities.add(r);
  mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  return r;
}"
2101,"final void activityDestroyedLocked(IBinder token){
  final long origId=Binder.clearCallingIdentity();
  try {
    ActivityRecord r=ActivityRecord.forToken(token);
    if (r != null) {
      mHandler.removeMessages(DESTROY_TIMEOUT_MSG,r);
    }
    if (isInStackLocked(token) != null) {
      if (r.state == ActivityState.DESTROYING) {
        cleanUpActivityLocked(r,true,false);
        removeActivityFromHistoryLocked(r);
      }
    }
    mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","final void activityDestroyedLocked(IBinder token){
  final long origId=Binder.clearCallingIdentity();
  try {
    ActivityRecord r=ActivityRecord.forToken(token);
    if (r != null) {
      mHandler.removeMessages(DESTROY_TIMEOUT_MSG,r);
    }
    if (isInStackLocked(token) != null) {
      if (r.state == ActivityState.DESTROYING) {
        cleanUpActivityLocked(r,true,false);
        removeActivityFromHistoryLocked(r);
      }
    }
    mStackSupervisor.resumeTopActivitiesLocked();
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
2102,"void handleAppDiedLocked(ProcessRecord app,boolean restarting){
  if (!containsApp(app)) {
    return;
  }
  if (mPausingActivity != null && mPausingActivity.app == app) {
    if (DEBUG_PAUSE || DEBUG_CLEANUP)     Slog.v(TAG,""String_Node_Str"" + mPausingActivity);
    mPausingActivity=null;
  }
  if (mLastPausedActivity != null && mLastPausedActivity.app == app) {
    mLastPausedActivity=null;
  }
  boolean hasVisibleActivities=removeHistoryRecordsForAppLocked(app);
  if (!restarting) {
    ActivityStack stack=mStackSupervisor.getFocusedStack();
    if (stack == null) {
      mStackSupervisor.resumeHomeActivity(null);
    }
 else     if (!stack.resumeTopActivityLocked(null)) {
      if (hasVisibleActivities) {
        ensureActivitiesVisibleLocked(null,0);
      }
    }
  }
}","void handleAppDiedLocked(ProcessRecord app,boolean restarting){
  if (!containsApp(app)) {
    return;
  }
  if (mPausingActivity != null && mPausingActivity.app == app) {
    if (DEBUG_PAUSE || DEBUG_CLEANUP)     Slog.v(TAG,""String_Node_Str"" + mPausingActivity);
    mPausingActivity=null;
  }
  if (mLastPausedActivity != null && mLastPausedActivity.app == app) {
    mLastPausedActivity=null;
  }
  boolean hasVisibleActivities=removeHistoryRecordsForAppLocked(app);
  if (!restarting) {
    ActivityStack stack=mStackSupervisor.getFocusedStack();
    if (stack == null) {
      mStackSupervisor.resumeHomeActivity(null);
    }
 else     if (!mStackSupervisor.resumeTopActivitiesLocked(stack,null,null)) {
      if (hasVisibleActivities) {
        ensureActivitiesVisibleLocked(null,0);
      }
    }
  }
}"
2103,"final boolean resumeTopActivityLocked(ActivityRecord prev,Bundle options){
  ActivityRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mStackSupervisor.mUserLeaving;
  mStackSupervisor.mUserLeaving=false;
  if (next == null) {
    ActivityOptions.abort(options);
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return mStackSupervisor.resumeHomeActivity(prev);
  }
  next.delayedResume=false;
  if (mResumedActivity == next && next.state == ActivityState.RESUMED && mStackSupervisor.allResumedActivitiesComplete()) {
    mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    ActivityOptions.abort(options);
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  if (prev != null && prev.mLaunchHomeTaskNext && prev.finishing && prev.frontOfTask) {
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    final TaskRecord task=prev.task;
    if (topTask() != task) {
      final int taskNdx=mTaskHistory.indexOf(task) + 1;
      mTaskHistory.get(taskNdx).mActivities.get(0).mLaunchHomeTaskNext=true;
    }
 else {
      return mStackSupervisor.resumeHomeActivity(prev);
    }
  }
  if ((mService.isSleepingOrShuttingDown()) && mLastPausedActivity == next && mStackSupervisor.allPausedActivitiesComplete()) {
    mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    ActivityOptions.abort(options);
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  if (mService.mStartedUsers.get(next.userId) == null) {
    Slog.w(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ next.userId+ ""String_Node_Str"");
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  mStackSupervisor.mStoppingActivities.remove(next);
  mGoingToSleepActivities.remove(next);
  next.sleeping=false;
  mStackSupervisor.mWaitingVisibleActivities.remove(next);
  next.updateOptionsLocked(options);
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + next);
  if (!mStackSupervisor.allPausedActivitiesComplete()) {
    if (DEBUG_SWITCH || DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"");
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  if (false) {
    if (mLastStartedActivity != null && !mLastStartedActivity.finishing) {
      long now=SystemClock.uptimeMillis();
      final boolean inTime=mLastStartedActivity.startTime != 0 && (mLastStartedActivity.startTime + START_WARN_TIME) >= now;
      final int lastUid=mLastStartedActivity.info.applicationInfo.uid;
      final int nextUid=next.info.applicationInfo.uid;
      if (inTime && lastUid != nextUid && lastUid != next.launchedFromUid && mService.checkPermission(android.Manifest.permission.STOP_APP_SWITCHES,-1,next.launchedFromUid) != PackageManager.PERMISSION_GRANTED) {
        mService.showLaunchWarningLocked(mLastStartedActivity,next);
      }
 else {
        next.startTime=now;
        mLastStartedActivity=next;
      }
    }
 else {
      next.startTime=SystemClock.uptimeMillis();
      mLastStartedActivity=next;
    }
  }
  boolean pausing=mStackSupervisor.pauseBackStacks(userLeaving);
  if (mResumedActivity != null) {
    pausing=true;
    startPausingLocked(userLeaving,false);
  }
  if (pausing) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"");
    if (next.app != null && next.app.thread != null) {
      mService.updateLruProcessLocked(next.app,false);
    }
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return true;
  }
  final ActivityRecord last=mLastPausedActivity;
  if (mService.mSleeping && last != null && !last.finishing) {
    if ((last.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (last.info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
      if (DEBUG_STATES) {
        Slog.d(TAG,""String_Node_Str"" + last + ""String_Node_Str"");
      }
      requestFinishActivityLocked(last.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
    }
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mStackSupervisor.mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mWindowManager.setAppVisibility(prev.appToken,false);
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(next.packageName,false,next.userId);
  }
 catch (  RemoteException e1) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,""String_Node_Str"" + next.packageName + ""String_Node_Str""+ e);
  }
  boolean noAnim=false;
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(prev)) {
        noAnim=true;
        mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
      }
 else {
        mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_CLOSE : AppTransition.TRANSIT_TASK_CLOSE,false);
      }
      mWindowManager.setAppWillBeHidden(prev.appToken);
      mWindowManager.setAppVisibility(prev.appToken,false);
    }
 else {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(next)) {
        noAnim=true;
        mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
      }
 else {
        mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_OPEN : AppTransition.TRANSIT_TASK_OPEN,false);
      }
    }
    if (false) {
      mWindowManager.setAppWillBeHidden(prev.appToken);
      mWindowManager.setAppVisibility(prev.appToken,false);
    }
  }
 else {
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"");
    if (mNoAnimActivities.contains(next)) {
      noAnim=true;
      mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
    }
 else {
      mWindowManager.prepareAppTransition(AppTransition.TRANSIT_ACTIVITY_OPEN,false);
    }
  }
  if (!noAnim) {
    next.applyOptionsLocked();
  }
 else {
    next.clearOptionsLocked();
  }
  ActivityStack lastStack=mStackSupervisor.getLastStack();
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + next);
    mWindowManager.setAppVisibility(next.appToken,true);
    next.startLaunchTickingLocked();
    ActivityRecord lastResumedActivity=lastStack == null ? null : lastStack.mResumedActivity;
    ActivityState lastState=next.state;
    mService.updateCpuStats();
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str"");
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    mService.addRecentTaskLocked(next.task);
    mService.updateLruProcessLocked(next.app,true);
    updateLRUListLocked(next);
    boolean updated=false;
    if (mStackSupervisor.isFrontStack(this)) {
      Configuration config=mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,next.mayFreezeScreenLocked(next.app) ? next.appToken : null);
      if (config != null) {
        next.frozenBeforeDestroy=true;
      }
      updated=mService.updateConfigurationLocked(config,next,false,false);
    }
    if (!updated) {
      ActivityRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      if (mStackSupervisor.reportResumedActivityLocked(next)) {
        mNoAnimActivities.clear();
        if (DEBUG_STACK)         mStackSupervisor.validateTopActivitiesLocked();
        return true;
      }
      if (DEBUG_STACK)       mStackSupervisor.validateTopActivitiesLocked();
      return false;
    }
    try {
      ArrayList<ResultInfo> a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next.appToken,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next.appToken);
      }
      EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY,next.userId,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      next.sleeping=false;
      mService.showAskCompatModeDialogLocked(next);
      next.app.pendingUiClean=true;
      next.app.thread.scheduleResumeActivity(next.appToken,mService.isNextTransitionForward());
      checkReadyForSleepLocked();
    }
 catch (    Exception e) {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + lastState + ""String_Node_Str""+ next);
      next.state=lastState;
      if (lastStack != null) {
        lastStack.mResumedActivity=lastResumedActivity;
      }
      Slog.i(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else       if (SHOW_APP_STARTING_PREVIEW && lastStack != null && mStackSupervisor.isFrontStack(lastStack)) {
        mWindowManager.setAppStartingWindow(next.appToken,next.packageName,next.theme,mService.compatibilityInfoForPackageLocked(next.info.applicationInfo),next.nonLocalizedLabel,next.labelRes,next.icon,next.windowFlags,null,true);
      }
      mStackSupervisor.startSpecificActivityLocked(next,true,false);
      if (DEBUG_STACK)       mStackSupervisor.validateTopActivitiesLocked();
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",true);
      if (DEBUG_STACK)       mStackSupervisor.validateTopActivitiesLocked();
      return true;
    }
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_PREVIEW) {
        mWindowManager.setAppStartingWindow(next.appToken,next.packageName,next.theme,mService.compatibilityInfoForPackageLocked(next.info.applicationInfo),next.nonLocalizedLabel,next.labelRes,next.icon,next.windowFlags,null,true);
      }
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + next);
    }
    mStackSupervisor.startSpecificActivityLocked(next,true,true);
  }
  if (DEBUG_STACK)   mStackSupervisor.validateTopActivitiesLocked();
  return true;
}","final boolean resumeTopActivityLocked(ActivityRecord prev,Bundle options){
  ActivityRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mStackSupervisor.mUserLeaving;
  mStackSupervisor.mUserLeaving=false;
  if (next == null) {
    ActivityOptions.abort(options);
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return mStackSupervisor.resumeHomeActivity(prev);
  }
  next.delayedResume=false;
  if (mResumedActivity == next && next.state == ActivityState.RESUMED && mStackSupervisor.allResumedActivitiesComplete()) {
    mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    ActivityOptions.abort(options);
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  if (prev != null && prev.mLaunchHomeTaskNext && prev.finishing && prev.frontOfTask) {
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    final TaskRecord task=prev.task;
    if (topTask() != task) {
      final int taskNdx=mTaskHistory.indexOf(task) + 1;
      mTaskHistory.get(taskNdx).mActivities.get(0).mLaunchHomeTaskNext=true;
    }
 else {
      return mStackSupervisor.resumeHomeActivity(prev);
    }
  }
  if ((mService.isSleepingOrShuttingDown()) && mLastPausedActivity == next && mStackSupervisor.allPausedActivitiesComplete()) {
    mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    ActivityOptions.abort(options);
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  if (mService.mStartedUsers.get(next.userId) == null) {
    Slog.w(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ next.userId+ ""String_Node_Str"");
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  mStackSupervisor.mStoppingActivities.remove(next);
  mGoingToSleepActivities.remove(next);
  next.sleeping=false;
  mStackSupervisor.mWaitingVisibleActivities.remove(next);
  next.updateOptionsLocked(options);
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + next);
  if (!mStackSupervisor.allPausedActivitiesComplete()) {
    if (DEBUG_SWITCH || DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"");
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return false;
  }
  if (false) {
    if (mLastStartedActivity != null && !mLastStartedActivity.finishing) {
      long now=SystemClock.uptimeMillis();
      final boolean inTime=mLastStartedActivity.startTime != 0 && (mLastStartedActivity.startTime + START_WARN_TIME) >= now;
      final int lastUid=mLastStartedActivity.info.applicationInfo.uid;
      final int nextUid=next.info.applicationInfo.uid;
      if (inTime && lastUid != nextUid && lastUid != next.launchedFromUid && mService.checkPermission(android.Manifest.permission.STOP_APP_SWITCHES,-1,next.launchedFromUid) != PackageManager.PERMISSION_GRANTED) {
        mService.showLaunchWarningLocked(mLastStartedActivity,next);
      }
 else {
        next.startTime=now;
        mLastStartedActivity=next;
      }
    }
 else {
      next.startTime=SystemClock.uptimeMillis();
      mLastStartedActivity=next;
    }
  }
  boolean pausing=mStackSupervisor.pauseBackStacks(userLeaving);
  if (mResumedActivity != null) {
    pausing=true;
    startPausingLocked(userLeaving,false);
  }
  if (pausing) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"");
    if (next.app != null && next.app.thread != null) {
      mService.updateLruProcessLocked(next.app,false);
    }
    if (DEBUG_STACK)     mStackSupervisor.validateTopActivitiesLocked();
    return true;
  }
  final ActivityRecord last=mLastPausedActivity;
  if (mService.mSleeping && last != null && !last.finishing) {
    if ((last.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (last.info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
      if (DEBUG_STATES) {
        Slog.d(TAG,""String_Node_Str"" + last + ""String_Node_Str"");
      }
      requestFinishActivityLocked(last.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
    }
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mStackSupervisor.mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mWindowManager.setAppVisibility(prev.appToken,false);
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(next.packageName,false,next.userId);
  }
 catch (  RemoteException e1) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,""String_Node_Str"" + next.packageName + ""String_Node_Str""+ e);
  }
  boolean noAnim=false;
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(prev)) {
        noAnim=true;
        mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
      }
 else {
        mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_CLOSE : AppTransition.TRANSIT_TASK_CLOSE,false);
      }
      mWindowManager.setAppWillBeHidden(prev.appToken);
      mWindowManager.setAppVisibility(prev.appToken,false);
    }
 else {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(next)) {
        noAnim=true;
        mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
      }
 else {
        mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_OPEN : AppTransition.TRANSIT_TASK_OPEN,false);
      }
    }
    if (false) {
      mWindowManager.setAppWillBeHidden(prev.appToken);
      mWindowManager.setAppVisibility(prev.appToken,false);
    }
  }
 else {
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"");
    if (mNoAnimActivities.contains(next)) {
      noAnim=true;
      mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
    }
 else {
      mWindowManager.prepareAppTransition(AppTransition.TRANSIT_ACTIVITY_OPEN,false);
    }
  }
  if (!noAnim) {
    next.applyOptionsLocked();
  }
 else {
    next.clearOptionsLocked();
  }
  ActivityStack lastStack=mStackSupervisor.getLastStack();
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + next);
    mWindowManager.setAppVisibility(next.appToken,true);
    next.startLaunchTickingLocked();
    ActivityRecord lastResumedActivity=lastStack == null ? null : lastStack.mResumedActivity;
    ActivityState lastState=next.state;
    mService.updateCpuStats();
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str"");
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    mService.addRecentTaskLocked(next.task);
    mService.updateLruProcessLocked(next.app,true);
    updateLRUListLocked(next);
    boolean updated=false;
    if (mStackSupervisor.isFrontStack(this)) {
      Configuration config=mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,next.mayFreezeScreenLocked(next.app) ? next.appToken : null);
      if (config != null) {
        next.frozenBeforeDestroy=true;
      }
      updated=mService.updateConfigurationLocked(config,next,false,false);
    }
    if (!updated) {
      ActivityRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mStackSupervisor.scheduleResumeTopActivities();
      }
      if (mStackSupervisor.reportResumedActivityLocked(next)) {
        mNoAnimActivities.clear();
        if (DEBUG_STACK)         mStackSupervisor.validateTopActivitiesLocked();
        return true;
      }
      if (DEBUG_STACK)       mStackSupervisor.validateTopActivitiesLocked();
      return false;
    }
    try {
      ArrayList<ResultInfo> a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next.appToken,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next.appToken);
      }
      EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY,next.userId,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      next.sleeping=false;
      mService.showAskCompatModeDialogLocked(next);
      next.app.pendingUiClean=true;
      next.app.thread.scheduleResumeActivity(next.appToken,mService.isNextTransitionForward());
      checkReadyForSleepLocked();
    }
 catch (    Exception e) {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + lastState + ""String_Node_Str""+ next);
      next.state=lastState;
      if (lastStack != null) {
        lastStack.mResumedActivity=lastResumedActivity;
      }
      Slog.i(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else       if (SHOW_APP_STARTING_PREVIEW && lastStack != null && mStackSupervisor.isFrontStack(lastStack)) {
        mWindowManager.setAppStartingWindow(next.appToken,next.packageName,next.theme,mService.compatibilityInfoForPackageLocked(next.info.applicationInfo),next.nonLocalizedLabel,next.labelRes,next.icon,next.windowFlags,null,true);
      }
      mStackSupervisor.startSpecificActivityLocked(next,true,false);
      if (DEBUG_STACK)       mStackSupervisor.validateTopActivitiesLocked();
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",true);
      if (DEBUG_STACK)       mStackSupervisor.validateTopActivitiesLocked();
      return true;
    }
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_PREVIEW) {
        mWindowManager.setAppStartingWindow(next.appToken,next.packageName,next.theme,mService.compatibilityInfoForPackageLocked(next.info.applicationInfo),next.nonLocalizedLabel,next.labelRes,next.icon,next.windowFlags,null,true);
      }
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + next);
    }
    mStackSupervisor.startSpecificActivityLocked(next,true,true);
  }
  if (DEBUG_STACK)   mStackSupervisor.validateTopActivitiesLocked();
  return true;
}"
2104,"/** 
 * Worker method for rearranging history stack. Implements the function of moving all activities for a specific task (gathering them if disjoint) into a single group at the bottom of the stack. If a watcher is installed, the action is preflighted and the watcher has an opportunity to premeptively cancel the move.
 * @param task The taskId to collect and move to the bottom.
 * @return Returns true if the move completed, false if not.
 */
final boolean moveTaskToBackLocked(int task,ActivityRecord reason){
  Slog.i(TAG,""String_Node_Str"" + task);
  if (mStackSupervisor.isFrontStack(this) && mService.mController != null) {
    ActivityRecord next=topRunningActivityLocked(null,task);
    if (next == null) {
      next=topRunningActivityLocked(null,0);
    }
    if (next != null) {
      boolean moveOK=true;
      try {
        moveOK=mService.mController.activityResuming(next.packageName);
      }
 catch (      RemoteException e) {
        mService.mController=null;
      }
      if (!moveOK) {
        return false;
      }
    }
  }
  if (DEBUG_TRANSITION)   Slog.v(TAG,""String_Node_Str"" + task);
  final TaskRecord tr=taskForIdLocked(task);
  if (tr == null) {
    return false;
  }
  mTaskHistory.remove(tr);
  mTaskHistory.add(0,tr);
  if (reason != null && (reason.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
    ActivityRecord r=topRunningActivityLocked(null);
    if (r != null) {
      mNoAnimActivities.add(r);
    }
  }
 else {
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_TASK_TO_BACK,false);
  }
  mWindowManager.moveTaskToBottom(task);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
  if (mResumedActivity != null && mResumedActivity.task == tr && mResumedActivity.mLaunchHomeTaskNext) {
    mResumedActivity.mLaunchHomeTaskNext=false;
    return mStackSupervisor.resumeHomeActivity(null);
  }
  mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  return true;
}","/** 
 * Worker method for rearranging history stack. Implements the function of moving all activities for a specific task (gathering them if disjoint) into a single group at the bottom of the stack. If a watcher is installed, the action is preflighted and the watcher has an opportunity to premeptively cancel the move.
 * @param task The taskId to collect and move to the bottom.
 * @return Returns true if the move completed, false if not.
 */
final boolean moveTaskToBackLocked(int task,ActivityRecord reason){
  Slog.i(TAG,""String_Node_Str"" + task);
  if (mStackSupervisor.isFrontStack(this) && mService.mController != null) {
    ActivityRecord next=topRunningActivityLocked(null,task);
    if (next == null) {
      next=topRunningActivityLocked(null,0);
    }
    if (next != null) {
      boolean moveOK=true;
      try {
        moveOK=mService.mController.activityResuming(next.packageName);
      }
 catch (      RemoteException e) {
        mService.mController=null;
      }
      if (!moveOK) {
        return false;
      }
    }
  }
  if (DEBUG_TRANSITION)   Slog.v(TAG,""String_Node_Str"" + task);
  final TaskRecord tr=taskForIdLocked(task);
  if (tr == null) {
    return false;
  }
  mTaskHistory.remove(tr);
  mTaskHistory.add(0,tr);
  if (reason != null && (reason.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
    ActivityRecord r=topRunningActivityLocked(null);
    if (r != null) {
      mNoAnimActivities.add(r);
    }
  }
 else {
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_TASK_TO_BACK,false);
  }
  mWindowManager.moveTaskToBottom(task);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
  if (mResumedActivity != null && mResumedActivity.task == tr && mResumedActivity.mLaunchHomeTaskNext) {
    mResumedActivity.mLaunchHomeTaskNext=false;
    return mStackSupervisor.resumeHomeActivity(null);
  }
  mStackSupervisor.resumeTopActivitiesLocked();
  return true;
}"
2105,"final void moveTaskToFrontLocked(TaskRecord tr,ActivityRecord reason,Bundle options){
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + tr);
  final int numTasks=mTaskHistory.size();
  final int index=mTaskHistory.indexOf(tr);
  if (numTasks == 0 || index < 0 || index == numTasks - 1) {
    if (reason != null && (reason.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
      ActivityOptions.abort(options);
    }
 else {
      updateTransitLocked(AppTransition.TRANSIT_TASK_TO_FRONT,options);
    }
    return;
  }
  mTaskHistory.remove(tr);
  mTaskHistory.add(tr);
  if (DEBUG_TRANSITION)   Slog.v(TAG,""String_Node_Str"" + tr);
  if (reason != null && (reason.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
    ActivityRecord r=topRunningActivityLocked(null);
    if (r != null) {
      mNoAnimActivities.add(r);
    }
    ActivityOptions.abort(options);
  }
 else {
    updateTransitLocked(AppTransition.TRANSIT_TASK_TO_FRONT,options);
  }
  mWindowManager.moveTaskToTop(tr.taskId);
  mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  EventLog.writeEvent(EventLogTags.AM_TASK_TO_FRONT,tr.userId,tr.taskId);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
}","final void moveTaskToFrontLocked(TaskRecord tr,ActivityRecord reason,Bundle options){
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + tr);
  final int numTasks=mTaskHistory.size();
  final int index=mTaskHistory.indexOf(tr);
  if (numTasks == 0 || index < 0 || index == numTasks - 1) {
    if (reason != null && (reason.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
      ActivityOptions.abort(options);
    }
 else {
      updateTransitLocked(AppTransition.TRANSIT_TASK_TO_FRONT,options);
    }
    return;
  }
  mTaskHistory.remove(tr);
  mTaskHistory.add(tr);
  if (DEBUG_TRANSITION)   Slog.v(TAG,""String_Node_Str"" + tr);
  if (reason != null && (reason.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
    ActivityRecord r=topRunningActivityLocked(null);
    if (r != null) {
      mNoAnimActivities.add(r);
    }
    ActivityOptions.abort(options);
  }
 else {
    updateTransitLocked(AppTransition.TRANSIT_TASK_TO_FRONT,options);
  }
  mWindowManager.moveTaskToTop(tr.taskId);
  mStackSupervisor.resumeTopActivitiesLocked();
  EventLog.writeEvent(EventLogTags.AM_TASK_TO_FRONT,tr.userId,tr.taskId);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
}"
2106,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case SLEEP_TIMEOUT_MSG:
{
synchronized (mService) {
        if (mService.isSleepingOrShuttingDown()) {
          Slog.w(TAG,""String_Node_Str"");
          mSleepTimeout=true;
          checkReadyForSleepLocked();
        }
      }
    }
  break;
case PAUSE_TIMEOUT_MSG:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  Slog.w(TAG,""String_Node_Str"" + r);
synchronized (mService) {
    if (r.app != null) {
      mService.logAppTooSlow(r.app,r.pauseTime,""String_Node_Str"" + r);
    }
    activityPausedLocked(r != null ? r.appToken : null,true);
  }
}
break;
case LAUNCH_TICK_MSG:
{
ActivityRecord r=(ActivityRecord)msg.obj;
synchronized (mService) {
if (r.continueLaunchTickingLocked()) {
  mService.logAppTooSlow(r.app,r.launchTickTime,""String_Node_Str"" + r);
}
}
}
break;
case DESTROY_TIMEOUT_MSG:
{
ActivityRecord r=(ActivityRecord)msg.obj;
Slog.w(TAG,""String_Node_Str"" + r);
synchronized (mService) {
activityDestroyedLocked(r != null ? r.appToken : null);
}
}
break;
case LAUNCH_TIMEOUT_MSG:
{
if (mService.mDidDexOpt) {
mService.mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(LAUNCH_TIMEOUT_MSG);
mHandler.sendMessageDelayed(nmsg,LAUNCH_TIMEOUT);
return;
}
synchronized (mService) {
if (mLaunchingActivity.isHeld()) {
Slog.w(TAG,""String_Node_Str"");
mLaunchingActivity.release();
}
}
}
break;
case RESUME_TOP_ACTIVITY_MSG:
{
synchronized (mService) {
mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
}
}
break;
case STOP_TIMEOUT_MSG:
{
ActivityRecord r=(ActivityRecord)msg.obj;
Slog.w(TAG,""String_Node_Str"" + r);
synchronized (mService) {
if (r.isInHistory()) {
activityStoppedLocked(r,null,null,null);
}
}
}
break;
case DESTROY_ACTIVITIES_MSG:
{
ScheduleDestroyArgs args=(ScheduleDestroyArgs)msg.obj;
synchronized (mService) {
destroyActivitiesLocked(args.mOwner,args.mOomAdj,args.mReason);
}
}
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case SLEEP_TIMEOUT_MSG:
{
synchronized (mService) {
        if (mService.isSleepingOrShuttingDown()) {
          Slog.w(TAG,""String_Node_Str"");
          mSleepTimeout=true;
          checkReadyForSleepLocked();
        }
      }
    }
  break;
case PAUSE_TIMEOUT_MSG:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  Slog.w(TAG,""String_Node_Str"" + r);
synchronized (mService) {
    if (r.app != null) {
      mService.logAppTooSlow(r.app,r.pauseTime,""String_Node_Str"" + r);
    }
    activityPausedLocked(r != null ? r.appToken : null,true);
  }
}
break;
case LAUNCH_TICK_MSG:
{
ActivityRecord r=(ActivityRecord)msg.obj;
synchronized (mService) {
if (r.continueLaunchTickingLocked()) {
  mService.logAppTooSlow(r.app,r.launchTickTime,""String_Node_Str"" + r);
}
}
}
break;
case DESTROY_TIMEOUT_MSG:
{
ActivityRecord r=(ActivityRecord)msg.obj;
Slog.w(TAG,""String_Node_Str"" + r);
synchronized (mService) {
activityDestroyedLocked(r != null ? r.appToken : null);
}
}
break;
case LAUNCH_TIMEOUT_MSG:
{
if (mService.mDidDexOpt) {
mService.mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(LAUNCH_TIMEOUT_MSG);
mHandler.sendMessageDelayed(nmsg,LAUNCH_TIMEOUT);
return;
}
synchronized (mService) {
if (mLaunchingActivity.isHeld()) {
Slog.w(TAG,""String_Node_Str"");
mLaunchingActivity.release();
}
}
}
break;
case STOP_TIMEOUT_MSG:
{
ActivityRecord r=(ActivityRecord)msg.obj;
Slog.w(TAG,""String_Node_Str"" + r);
synchronized (mService) {
if (r.isInHistory()) {
activityStoppedLocked(r,null,null,null);
}
}
}
break;
case DESTROY_ACTIVITIES_MSG:
{
ScheduleDestroyArgs args=(ScheduleDestroyArgs)msg.obj;
synchronized (mService) {
destroyActivitiesLocked(args.mOwner,args.mOomAdj,args.mReason);
}
}
}
}"
2107,"final void startPausingLocked(boolean userLeaving,boolean uiSleeping){
  if (mPausingActivity != null) {
    Slog.e(TAG,""String_Node_Str"" + mPausingActivity,new RuntimeException(""String_Node_Str"").fillInStackTrace());
  }
  ActivityRecord prev=mResumedActivity;
  if (prev == null) {
    Slog.e(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
    return;
  }
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + prev);
 else   if (DEBUG_PAUSE)   Slog.v(TAG,""String_Node_Str"" + prev);
  mResumedActivity=null;
  mPausingActivity=prev;
  mLastPausedActivity=prev;
  prev.state=ActivityState.PAUSING;
  prev.task.touchActiveTime();
  prev.updateThumbnail(screenshotActivities(prev),null);
  mService.updateCpuStats();
  if (prev.app != null && prev.app.thread != null) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + prev);
    try {
      EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,prev.userId,System.identityHashCode(prev),prev.shortComponentName);
      mService.updateUsageStats(prev,false);
      prev.app.thread.schedulePauseActivity(prev.appToken,prev.finishing,userLeaving,prev.configChangeFlags);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"",e);
      mPausingActivity=null;
      mLastPausedActivity=null;
    }
  }
 else {
    mPausingActivity=null;
    mLastPausedActivity=null;
  }
  if (!mService.isSleepingOrShuttingDown()) {
    mLaunchingActivity.acquire();
    if (!mHandler.hasMessages(LAUNCH_TIMEOUT_MSG)) {
      Message msg=mHandler.obtainMessage(LAUNCH_TIMEOUT_MSG);
      mHandler.sendMessageDelayed(msg,LAUNCH_TIMEOUT);
    }
  }
  if (mPausingActivity != null) {
    if (!uiSleeping) {
      prev.pauseKeyDispatchingLocked();
    }
 else {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"");
    }
    Message msg=mHandler.obtainMessage(PAUSE_TIMEOUT_MSG);
    msg.obj=prev;
    prev.pauseTime=SystemClock.uptimeMillis();
    mHandler.sendMessageDelayed(msg,PAUSE_TIMEOUT);
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"");
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"");
    mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  }
}","final void startPausingLocked(boolean userLeaving,boolean uiSleeping){
  if (mPausingActivity != null) {
    Slog.e(TAG,""String_Node_Str"" + mPausingActivity,new RuntimeException(""String_Node_Str"").fillInStackTrace());
  }
  ActivityRecord prev=mResumedActivity;
  if (prev == null) {
    Slog.e(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    mStackSupervisor.resumeTopActivitiesLocked();
    return;
  }
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + prev);
 else   if (DEBUG_PAUSE)   Slog.v(TAG,""String_Node_Str"" + prev);
  mResumedActivity=null;
  mPausingActivity=prev;
  mLastPausedActivity=prev;
  prev.state=ActivityState.PAUSING;
  prev.task.touchActiveTime();
  prev.updateThumbnail(screenshotActivities(prev),null);
  mService.updateCpuStats();
  if (prev.app != null && prev.app.thread != null) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + prev);
    try {
      EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,prev.userId,System.identityHashCode(prev),prev.shortComponentName);
      mService.updateUsageStats(prev,false);
      prev.app.thread.schedulePauseActivity(prev.appToken,prev.finishing,userLeaving,prev.configChangeFlags);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"",e);
      mPausingActivity=null;
      mLastPausedActivity=null;
    }
  }
 else {
    mPausingActivity=null;
    mLastPausedActivity=null;
  }
  if (!mService.isSleepingOrShuttingDown()) {
    mLaunchingActivity.acquire();
    if (!mHandler.hasMessages(LAUNCH_TIMEOUT_MSG)) {
      Message msg=mHandler.obtainMessage(LAUNCH_TIMEOUT_MSG);
      mHandler.sendMessageDelayed(msg,LAUNCH_TIMEOUT);
    }
  }
  if (mPausingActivity != null) {
    if (!uiSleeping) {
      prev.pauseKeyDispatchingLocked();
    }
 else {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"");
    }
    Message msg=mHandler.obtainMessage(PAUSE_TIMEOUT_MSG);
    msg.obj=prev;
    prev.pauseTime=SystemClock.uptimeMillis();
    mHandler.sendMessageDelayed(msg,PAUSE_TIMEOUT);
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"");
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"");
    mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
  }
}"
2108,"private final void completePauseLocked(){
  ActivityRecord prev=mPausingActivity;
  if (DEBUG_PAUSE)   Slog.v(TAG,""String_Node_Str"" + prev);
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + prev);
      prev=finishCurrentActivityLocked(prev,FINISH_AFTER_VISIBLE,false);
    }
 else     if (prev.app != null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (prev.waitingVisible) {
        prev.waitingVisible=false;
        mStackSupervisor.mWaitingVisibleActivities.remove(prev);
        if (DEBUG_SWITCH || DEBUG_PAUSE)         Slog.v(TAG,""String_Node_Str"" + prev);
      }
      if (prev.configDestroy) {
        if (DEBUG_PAUSE)         Slog.v(TAG,""String_Node_Str"" + prev);
        destroyActivityLocked(prev,true,false,""String_Node_Str"");
      }
 else {
        mStackSupervisor.mStoppingActivities.add(prev);
        if (mStackSupervisor.mStoppingActivities.size() > 3 || prev.frontOfTask && mTaskHistory.size() <= 1) {
          if (DEBUG_PAUSE)           Slog.v(TAG,""String_Node_Str"");
          mStackSupervisor.scheduleIdleLocked();
        }
 else {
          checkReadyForSleepLocked();
        }
      }
    }
 else {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + prev);
      prev=null;
    }
    mPausingActivity=null;
  }
  final ActivityStack topStack=mStackSupervisor.getFocusedStack();
  if (!mService.isSleepingOrShuttingDown()) {
    topStack.resumeTopActivityLocked(prev);
  }
 else {
    checkReadyForSleepLocked();
    ActivityRecord top=topStack.topRunningActivityLocked(null);
    if (top == null || (prev != null && top != prev)) {
      topStack.resumeTopActivityLocked(null);
    }
  }
  if (prev != null) {
    prev.resumeKeyDispatchingLocked();
  }
  if (prev.app != null && prev.cpuTimeAtResume > 0 && mService.mBatteryStatsService.isOnBattery()) {
    long diff=0;
synchronized (mService.mProcessStatsThread) {
      diff=mService.mProcessStats.getCpuTimeForPid(prev.app.pid) - prev.cpuTimeAtResume;
    }
    if (diff > 0) {
      BatteryStatsImpl bsi=mService.mBatteryStatsService.getActiveStatistics();
synchronized (bsi) {
        BatteryStatsImpl.Uid.Proc ps=bsi.getProcessStatsLocked(prev.info.applicationInfo.uid,prev.info.packageName);
        if (ps != null) {
          ps.addForegroundTimeLocked(diff);
        }
      }
    }
  }
  prev.cpuTimeAtResume=0;
}","private final void completePauseLocked(){
  ActivityRecord prev=mPausingActivity;
  if (DEBUG_PAUSE)   Slog.v(TAG,""String_Node_Str"" + prev);
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + prev);
      prev=finishCurrentActivityLocked(prev,FINISH_AFTER_VISIBLE,false);
    }
 else     if (prev.app != null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (prev.waitingVisible) {
        prev.waitingVisible=false;
        mStackSupervisor.mWaitingVisibleActivities.remove(prev);
        if (DEBUG_SWITCH || DEBUG_PAUSE)         Slog.v(TAG,""String_Node_Str"" + prev);
      }
      if (prev.configDestroy) {
        if (DEBUG_PAUSE)         Slog.v(TAG,""String_Node_Str"" + prev);
        destroyActivityLocked(prev,true,false,""String_Node_Str"");
      }
 else {
        mStackSupervisor.mStoppingActivities.add(prev);
        if (mStackSupervisor.mStoppingActivities.size() > 3 || prev.frontOfTask && mTaskHistory.size() <= 1) {
          if (DEBUG_PAUSE)           Slog.v(TAG,""String_Node_Str"");
          mStackSupervisor.scheduleIdleLocked();
        }
 else {
          checkReadyForSleepLocked();
        }
      }
    }
 else {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + prev);
      prev=null;
    }
    mPausingActivity=null;
  }
  final ActivityStack topStack=mStackSupervisor.getFocusedStack();
  if (!mService.isSleepingOrShuttingDown()) {
    mStackSupervisor.resumeTopActivitiesLocked(topStack,prev,null);
  }
 else {
    checkReadyForSleepLocked();
    ActivityRecord top=topStack.topRunningActivityLocked(null);
    if (top == null || (prev != null && top != prev)) {
      mStackSupervisor.resumeTopActivitiesLocked(topStack,null,null);
    }
  }
  if (prev != null) {
    prev.resumeKeyDispatchingLocked();
  }
  if (prev.app != null && prev.cpuTimeAtResume > 0 && mService.mBatteryStatsService.isOnBattery()) {
    long diff=0;
synchronized (mService.mProcessStatsThread) {
      diff=mService.mProcessStats.getCpuTimeForPid(prev.app.pid) - prev.cpuTimeAtResume;
    }
    if (diff > 0) {
      BatteryStatsImpl bsi=mService.mBatteryStatsService.getActiveStatistics();
synchronized (bsi) {
        BatteryStatsImpl.Uid.Proc ps=bsi.getProcessStatsLocked(prev.info.applicationInfo.uid,prev.info.packageName);
        if (ps != null) {
          ps.addForegroundTimeLocked(diff);
        }
      }
    }
  }
  prev.cpuTimeAtResume=0;
}"
2109,"final ActivityRecord activityIdleInternalLocked(final IBinder token,boolean fromTimeout,Configuration config){
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + token);
  ActivityRecord res=null;
  ArrayList<ActivityRecord> stops=null;
  ArrayList<ActivityRecord> finishes=null;
  ArrayList<UserStartedState> startingUsers=null;
  int NS=0;
  int NF=0;
  IApplicationThread sendThumbnail=null;
  boolean booting=false;
  boolean enableScreen=false;
  boolean activityRemoved=false;
  ActivityRecord r=ActivityRecord.forToken(token);
  if (r != null) {
    mHandler.removeMessages(IDLE_TIMEOUT_MSG,r);
    r.finishLaunchTickingLocked();
    res=r.task.stack.activityIdleInternalLocked(token,fromTimeout,config);
    if (res != null) {
      if (fromTimeout) {
        reportActivityLaunchedLocked(fromTimeout,r,-1,-1);
      }
      if (config != null) {
        r.configuration=config;
      }
      r.idle=true;
      if (allResumedActivitiesIdle()) {
        mService.scheduleAppGcsLocked();
      }
      if (r.thumbnailNeeded && r.app != null && r.app.thread != null) {
        sendThumbnail=r.app.thread;
        r.thumbnailNeeded=false;
      }
      if (!mService.mBooted && isFrontStack(r.task.stack)) {
        mService.mBooted=true;
        enableScreen=true;
      }
    }
 else     if (fromTimeout) {
      reportActivityLaunchedLocked(fromTimeout,null,-1,-1);
    }
  }
  stops=processStoppingActivitiesLocked(true);
  NS=stops != null ? stops.size() : 0;
  if ((NF=mFinishingActivities.size()) > 0) {
    finishes=new ArrayList<ActivityRecord>(mFinishingActivities);
    mFinishingActivities.clear();
  }
  final ArrayList<ActivityRecord> thumbnails;
  final int NT=mCancelledThumbnails.size();
  if (NT > 0) {
    thumbnails=new ArrayList<ActivityRecord>(mCancelledThumbnails);
    mCancelledThumbnails.clear();
  }
 else {
    thumbnails=null;
  }
  if (isFrontStack(mHomeStack)) {
    booting=mService.mBooting;
    mService.mBooting=false;
  }
  if (mStartingUsers.size() > 0) {
    startingUsers=new ArrayList<UserStartedState>(mStartingUsers);
    mStartingUsers.clear();
  }
  final IApplicationThread thumbnailThread=sendThumbnail;
  mHandler.post(new Runnable(){
    @Override public void run(){
      if (thumbnailThread != null) {
        try {
          thumbnailThread.requestThumbnail(token);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"",e);
          mService.sendPendingThumbnail(null,token,null,null,true);
        }
      }
      for (int i=0; i < NT; i++) {
        ActivityRecord r=thumbnails.get(i);
        mService.sendPendingThumbnail(r,null,null,null,true);
      }
    }
  }
);
  for (int i=0; i < NS; i++) {
    r=stops.get(i);
    final ActivityStack stack=r.task.stack;
    if (r.finishing) {
      stack.finishCurrentActivityLocked(r,ActivityStack.FINISH_IMMEDIATELY,false);
    }
 else {
      stack.stopActivityLocked(r);
    }
  }
  for (int i=0; i < NF; i++) {
    r=finishes.get(i);
    activityRemoved|=r.task.stack.destroyActivityLocked(r,true,false,""String_Node_Str"");
  }
  if (booting) {
    mService.finishBooting();
  }
 else   if (startingUsers != null) {
    for (int i=0; i < startingUsers.size(); i++) {
      mService.finishUserSwitch(startingUsers.get(i));
    }
  }
  mService.trimApplications();
  if (enableScreen) {
    mService.enableScreenAfterBoot();
  }
  if (activityRemoved) {
    getFocusedStack().resumeTopActivityLocked(null);
  }
  return res;
}","final ActivityRecord activityIdleInternalLocked(final IBinder token,boolean fromTimeout,Configuration config){
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + token);
  ActivityRecord res=null;
  ArrayList<ActivityRecord> stops=null;
  ArrayList<ActivityRecord> finishes=null;
  ArrayList<UserStartedState> startingUsers=null;
  int NS=0;
  int NF=0;
  IApplicationThread sendThumbnail=null;
  boolean booting=false;
  boolean enableScreen=false;
  boolean activityRemoved=false;
  ActivityRecord r=ActivityRecord.forToken(token);
  if (r != null) {
    mHandler.removeMessages(IDLE_TIMEOUT_MSG,r);
    r.finishLaunchTickingLocked();
    res=r.task.stack.activityIdleInternalLocked(token,fromTimeout,config);
    if (res != null) {
      if (fromTimeout) {
        reportActivityLaunchedLocked(fromTimeout,r,-1,-1);
      }
      if (config != null) {
        r.configuration=config;
      }
      r.idle=true;
      if (allResumedActivitiesIdle()) {
        mService.scheduleAppGcsLocked();
      }
      if (r.thumbnailNeeded && r.app != null && r.app.thread != null) {
        sendThumbnail=r.app.thread;
        r.thumbnailNeeded=false;
      }
      if (!mService.mBooted && isFrontStack(r.task.stack)) {
        mService.mBooted=true;
        enableScreen=true;
      }
    }
 else     if (fromTimeout) {
      reportActivityLaunchedLocked(fromTimeout,null,-1,-1);
    }
  }
  stops=processStoppingActivitiesLocked(true);
  NS=stops != null ? stops.size() : 0;
  if ((NF=mFinishingActivities.size()) > 0) {
    finishes=new ArrayList<ActivityRecord>(mFinishingActivities);
    mFinishingActivities.clear();
  }
  final ArrayList<ActivityRecord> thumbnails;
  final int NT=mCancelledThumbnails.size();
  if (NT > 0) {
    thumbnails=new ArrayList<ActivityRecord>(mCancelledThumbnails);
    mCancelledThumbnails.clear();
  }
 else {
    thumbnails=null;
  }
  if (isFrontStack(mHomeStack)) {
    booting=mService.mBooting;
    mService.mBooting=false;
  }
  if (mStartingUsers.size() > 0) {
    startingUsers=new ArrayList<UserStartedState>(mStartingUsers);
    mStartingUsers.clear();
  }
  final IApplicationThread thumbnailThread=sendThumbnail;
  mHandler.post(new Runnable(){
    @Override public void run(){
      if (thumbnailThread != null) {
        try {
          thumbnailThread.requestThumbnail(token);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"",e);
          mService.sendPendingThumbnail(null,token,null,null,true);
        }
      }
      for (int i=0; i < NT; i++) {
        ActivityRecord r=thumbnails.get(i);
        mService.sendPendingThumbnail(r,null,null,null,true);
      }
    }
  }
);
  for (int i=0; i < NS; i++) {
    r=stops.get(i);
    final ActivityStack stack=r.task.stack;
    if (r.finishing) {
      stack.finishCurrentActivityLocked(r,ActivityStack.FINISH_IMMEDIATELY,false);
    }
 else {
      stack.stopActivityLocked(r);
    }
  }
  for (int i=0; i < NF; i++) {
    r=finishes.get(i);
    activityRemoved|=r.task.stack.destroyActivityLocked(r,true,false,""String_Node_Str"");
  }
  if (booting) {
    mService.finishBooting();
  }
 else   if (startingUsers != null) {
    for (int i=0; i < startingUsers.size(); i++) {
      mService.finishUserSwitch(startingUsers.get(i));
    }
  }
  mService.trimApplications();
  if (enableScreen) {
    mService.enableScreenAfterBoot();
  }
  if (activityRemoved) {
    resumeTopActivitiesLocked();
  }
  return res;
}"
2110,"boolean resumeHomeActivity(ActivityRecord prev){
  moveHomeStack(true);
  if (prev != null) {
    prev.mLaunchHomeTaskNext=false;
  }
  if (mHomeStack.topRunningActivityLocked(null) != null) {
    return mHomeStack.resumeTopActivityLocked(prev);
  }
  return mService.startHomeActivityLocked(mCurrentUser);
}","boolean resumeHomeActivity(ActivityRecord prev){
  moveHomeStack(true);
  if (prev != null) {
    prev.mLaunchHomeTaskNext=false;
  }
  if (mHomeStack.topRunningActivityLocked(null) != null) {
    return resumeTopActivitiesLocked(mHomeStack,prev,null);
  }
  return mService.startHomeActivityLocked(mCurrentUser);
}"
2111,"void comeOutOfSleepIfNeededLocked(){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    final ActivityStack stack=mStacks.get(stackNdx);
    stack.awakeFromSleepingLocked();
    if (isFrontStack(stack)) {
      stack.resumeTopActivityLocked(null);
    }
  }
}","void comeOutOfSleepIfNeededLocked(){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    final ActivityStack stack=mStacks.get(stackNdx);
    stack.awakeFromSleepingLocked();
    if (isFrontStack(stack)) {
      resumeTopActivitiesLocked();
    }
  }
}"
2112,"final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  final TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(intent,r.info) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && curTop.task != intentActivity.task) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || sourceStack.topActivity() == sourceRecord) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              topStack.resumeTopActivityLocked(null);
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=getCorrectStack(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    targetStack=sourceRecord.task.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceRecord.task.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=targetStack.findActivityInHistoryLocked(r,sourceRecord.task);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceRecord.task,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    ActivityStack lastStack=getLastStack();
    targetStack=lastStack != null ? lastStack : mHomeStack;
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=lastStack == null ? null : targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  return ActivityManager.START_SUCCESS;
}","final int startActivityUncheckedLocked(ActivityRecord r,ActivityRecord sourceRecord,int startFlags,boolean doResume,Bundle options){
  final Intent intent=r.intent;
  final int callingUid=r.launchedFromUid;
  int launchFlags=intent.getFlags();
  mUserLeaving=(launchFlags & Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
  if (DEBUG_USER_LEAVING)   Slog.v(TAG,""String_Node_Str"" + mUserLeaving);
  if (!doResume) {
    r.delayedResume=true;
  }
  ActivityRecord notTop=(launchFlags & Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;
  if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
    ActivityRecord checkedCaller=sourceRecord;
    if (checkedCaller == null) {
      checkedCaller=getFocusedStack().topRunningNonDelayedActivityLocked(notTop);
    }
    if (!checkedCaller.realActivity.equals(r.realActivity)) {
      startFlags&=~ActivityManager.START_FLAG_ONLY_IF_NEEDED;
    }
  }
  if (sourceRecord == null) {
    if ((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
      Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + intent);
      launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
    }
  }
 else   if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
 else   if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    launchFlags|=Intent.FLAG_ACTIVITY_NEW_TASK;
  }
  final ActivityStack sourceStack;
  final TaskRecord sourceTask;
  if (sourceRecord != null) {
    sourceTask=sourceRecord.task;
    sourceStack=sourceTask.stack;
  }
 else {
    sourceTask=null;
    sourceStack=null;
  }
  if (r.resultTo != null && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    Slog.w(TAG,""String_Node_Str"");
    r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    r.resultTo=null;
  }
  boolean addingToTask=false;
  boolean movedHome=false;
  TaskRecord reuseTask=null;
  ActivityStack targetStack;
  if (((launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (launchFlags & Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    if (r.resultTo == null) {
      ActivityRecord intentActivity=r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE ? findTaskLocked(intent,r.info) : findActivityLocked(intent,r.info);
      if (intentActivity != null) {
        if (r.task == null) {
          r.task=intentActivity.task;
        }
        targetStack=intentActivity.task.stack;
        moveHomeStack(targetStack.isHomeStack());
        if (intentActivity.task.intent == null) {
          intentActivity.task.setIntent(intent,r.info);
        }
        final ActivityStack lastStack=getLastStack();
        ActivityRecord curTop=lastStack == null ? null : lastStack.topRunningNonDelayedActivityLocked(notTop);
        if (curTop != null && curTop.task != intentActivity.task) {
          r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
          if (sourceRecord == null || sourceStack.topActivity() == sourceRecord) {
            movedHome=true;
            if ((launchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
              r.mLaunchHomeTaskNext=true;
            }
            targetStack.moveTaskToFrontLocked(intentActivity.task,r,options);
            options=null;
          }
        }
        if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
          intentActivity=targetStack.resetTaskIfNeededLocked(intentActivity,r);
        }
        if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
            resumeTopActivitiesLocked(targetStack,null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }
        if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
          reuseTask=intentActivity.task;
          reuseTask.performClearTaskLocked();
          reuseTask.setIntent(r.intent,r.info);
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          ActivityRecord top=intentActivity.task.performClearTaskLocked(r,launchFlags);
          if (top != null) {
            if (top.frontOfTask) {
              top.task.setIntent(r.intent,r.info);
            }
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
            top.deliverNewIntentLocked(callingUid,r.intent);
          }
 else {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if (r.realActivity.equals(intentActivity.task.realActivity)) {
          if (((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) && intentActivity.realActivity.equals(r.realActivity)) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,intentActivity.task);
            if (intentActivity.frontOfTask) {
              intentActivity.task.setIntent(r.intent,r.info);
            }
            intentActivity.deliverNewIntentLocked(callingUid,r.intent);
          }
 else           if (!r.intent.filterEquals(intentActivity.task.intent)) {
            addingToTask=true;
            sourceRecord=intentActivity;
          }
        }
 else         if ((launchFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
          addingToTask=true;
          sourceRecord=intentActivity;
        }
 else         if (!intentActivity.task.rootWasReset) {
          intentActivity.task.setIntent(r.intent,r.info);
        }
        if (!addingToTask && reuseTask == null) {
          if (doResume) {
            setLaunchHomeTaskNextFlag(sourceRecord,intentActivity,targetStack);
            targetStack.resumeTopActivityLocked(null,options);
          }
 else {
            ActivityOptions.abort(options);
          }
          if (r.task == null)           Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
          return ActivityManager.START_TASK_TO_FRONT;
        }
      }
    }
  }
  if (r.packageName != null) {
    ActivityStack topStack=getFocusedStack();
    ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(notTop);
    if (top != null && r.resultTo == null) {
      if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
        if (top.app != null && top.app.thread != null) {
          if ((launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,top,top.task);
            if (doResume) {
              setLaunchHomeTaskNextFlag(sourceRecord,null,topStack);
              resumeTopActivitiesLocked();
            }
            ActivityOptions.abort(options);
            if ((startFlags & ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
              if (r.task == null)               Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
              return ActivityManager.START_RETURN_INTENT_TO_CALLER;
            }
            top.deliverNewIntentLocked(callingUid,r.intent);
            if (r.task == null)             Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
            return ActivityManager.START_DELIVERED_TO_TOP;
          }
        }
      }
    }
  }
 else {
    if (r.resultTo != null) {
      r.resultTo.task.stack.sendActivityResultLocked(-1,r.resultTo,r.resultWho,r.requestCode,Activity.RESULT_CANCELED,null);
    }
    ActivityOptions.abort(options);
    if (r.task == null)     Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
    return ActivityManager.START_CLASS_NOT_FOUND;
  }
  boolean newTask=false;
  boolean keepCurTransition=false;
  if (r.resultTo == null && !addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    targetStack=getCorrectStack(r);
    moveHomeStack(targetStack.isHomeStack());
    if (reuseTask == null) {
      r.setTask(targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
      if (DEBUG_TASKS)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
    }
 else {
      r.setTask(reuseTask,reuseTask,true);
    }
    newTask=true;
    if (!movedHome) {
      if ((launchFlags & (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {
        r.mLaunchHomeTaskNext=true;
      }
    }
  }
 else   if (sourceRecord != null) {
    targetStack=sourceRecord.task.stack;
    moveHomeStack(targetStack.isHomeStack());
    if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
      ActivityRecord top=sourceRecord.task.performClearTaskLocked(r,launchFlags);
      keepCurTransition=true;
      if (top != null) {
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,top.task);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        ActivityOptions.abort(options);
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
 else     if (!addingToTask && (launchFlags & Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
      final ActivityRecord top=targetStack.findActivityInHistoryLocked(r,sourceRecord.task);
      if (top != null) {
        final TaskRecord task=top.task;
        task.moveActivityToFrontLocked(top);
        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,r,task);
        top.updateOptionsLocked(options);
        top.deliverNewIntentLocked(callingUid,r.intent);
        if (doResume) {
          setLaunchHomeTaskNextFlag(sourceRecord,null,targetStack);
          targetStack.resumeTopActivityLocked(null);
        }
        if (r.task == null)         Slog.v(TAG,""String_Node_Str"",new RuntimeException(""String_Node_Str"").fillInStackTrace());
        return ActivityManager.START_DELIVERED_TO_TOP;
      }
    }
    r.setTask(sourceRecord.task,sourceRecord.thumbHolder,false);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
 else {
    ActivityStack lastStack=getLastStack();
    targetStack=lastStack != null ? lastStack : mHomeStack;
    moveHomeStack(targetStack.isHomeStack());
    ActivityRecord prev=lastStack == null ? null : targetStack.topActivity();
    r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(),r.info,intent,true),null,true);
    if (DEBUG_TASKS)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.task);
  }
  mService.grantUriPermissionFromIntentLocked(callingUid,r.packageName,intent,r.getUriPermissionsLocked());
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,r.userId,r.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,r,r.task);
  setLaunchHomeTaskNextFlag(sourceRecord,r,targetStack);
  targetStack.startActivityLocked(r,newTask,doResume,keepCurTransition,options);
  return ActivityManager.START_SUCCESS;
}"
2113,"void resumeTopActivitiesLocked(){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    final ActivityStack stack=mStacks.get(stackNdx);
    if (isFrontStack(stack)) {
      stack.resumeTopActivityLocked(null);
    }
  }
}","boolean resumeTopActivitiesLocked(ActivityStack targetStack,ActivityRecord target,Bundle targetOptions){
  if (targetStack == null) {
    targetStack=getFocusedStack();
  }
  boolean result=false;
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    final ActivityStack stack=mStacks.get(stackNdx);
    if (isFrontStack(stack)) {
      if (stack == targetStack) {
        result=stack.resumeTopActivityLocked(target,targetOptions);
      }
 else {
        stack.resumeTopActivityLocked(null);
      }
    }
  }
  return result;
}"
2114,"final void scheduleIdleLocked(){
  mHandler.obtainMessage(IDLE_NOW_MSG).sendToTarget();
}","final void scheduleIdleLocked(){
  mHandler.sendEmptyMessage(IDLE_NOW_MSG);
}"
2115,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case IDLE_TIMEOUT_MSG:
{
      if (mService.mDidDexOpt) {
        mService.mDidDexOpt=false;
        Message nmsg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG);
        nmsg.obj=msg.obj;
        mHandler.sendMessageDelayed(nmsg,IDLE_TIMEOUT);
        return;
      }
      activityIdleInternal((ActivityRecord)msg.obj);
    }
  break;
case IDLE_NOW_MSG:
{
  activityIdleInternal((ActivityRecord)msg.obj);
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case IDLE_TIMEOUT_MSG:
{
      if (mService.mDidDexOpt) {
        mService.mDidDexOpt=false;
        Message nmsg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG);
        nmsg.obj=msg.obj;
        mHandler.sendMessageDelayed(nmsg,IDLE_TIMEOUT);
        return;
      }
      activityIdleInternal((ActivityRecord)msg.obj);
    }
  break;
case IDLE_NOW_MSG:
{
  activityIdleInternal((ActivityRecord)msg.obj);
}
break;
case RESUME_TOP_ACTIVITY_MSG:
{
synchronized (mService) {
resumeTopActivitiesLocked();
}
}
break;
}
}"
2116,"void moveTaskToStack(int taskId,int stackId,boolean toTop){
  final ActivityStack stack=getStack(stackId);
  if (stack == null) {
    Slog.w(TAG,""String_Node_Str"" + stackId);
    return;
  }
  stack.moveTask(taskId,toTop);
  stack.resumeTopActivityLocked(null);
}","void moveTaskToStack(int taskId,int stackId,boolean toTop){
  final ActivityStack stack=getStack(stackId);
  if (stack == null) {
    Slog.w(TAG,""String_Node_Str"" + stackId);
    return;
  }
  stack.moveTask(taskId,toTop);
  resumeTopActivitiesLocked();
}"
2117,"/** 
 * Begin an animation to a new dim value. NOTE: Must be called with Surface transaction open.
 * @param layer The layer to set the surface to.
 * @param alpha The dim value to end at.
 * @param duration How long to take to get there in milliseconds.
 */
void show(int layer,float alpha,long duration){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + layer + ""String_Node_Str""+ alpha+ ""String_Node_Str""+ duration);
  if (mDimSurface == null) {
    Slog.e(TAG,""String_Node_Str"");
    mTargetAlpha=mAlpha=0;
    return;
  }
  final DisplayInfo info=mDisplayContent.getDisplayInfo();
  final int dw=(int)(info.logicalWidth * 1.5);
  final int dh=(int)(info.logicalHeight * 1.5);
  final float xPos=-1 * dw / 6;
  final float yPos=-1 * dh / 6;
  if (mLastDimWidth != dw || mLastDimHeight != dh || mLayer != layer) {
    try {
      mDimSurface.setPosition(xPos,yPos);
      mDimSurface.setSize(dw,dh);
      mDimSurface.setLayer(layer);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
    mLastDimWidth=dw;
    mLastDimHeight=dh;
    mLayer=layer;
  }
  long curTime=SystemClock.uptimeMillis();
  final boolean animating=isAnimating();
  if ((animating && (mTargetAlpha != alpha || durationEndsEarlier(duration))) || (!animating && mAlpha != alpha)) {
    if (duration <= 0) {
      setAlpha(alpha);
    }
 else {
      mStartAlpha=mAlpha;
      mStartTime=curTime;
      mDuration=duration;
    }
  }
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + mStartAlpha + ""String_Node_Str""+ mStartTime);
  mTargetAlpha=alpha;
}","/** 
 * Begin an animation to a new dim value. NOTE: Must be called with Surface transaction open.
 * @param layer The layer to set the surface to.
 * @param alpha The dim value to end at.
 * @param duration How long to take to get there in milliseconds.
 */
void show(int layer,float alpha,long duration){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + layer + ""String_Node_Str""+ alpha+ ""String_Node_Str""+ duration);
  if (mDimSurface == null) {
    Slog.e(TAG,""String_Node_Str"");
    mTargetAlpha=mAlpha=0;
    return;
  }
  if (!mLastBounds.equals(mBounds) || mLayer != layer) {
    try {
      mDimSurface.setPosition(mBounds.left,mBounds.top);
      mDimSurface.setSize(mBounds.width(),mBounds.height());
      mDimSurface.setLayer(layer);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
    mLastBounds.set(mBounds);
    mLayer=layer;
  }
  long curTime=SystemClock.uptimeMillis();
  final boolean animating=isAnimating();
  if ((animating && (mTargetAlpha != alpha || durationEndsEarlier(duration))) || (!animating && mAlpha != alpha)) {
    if (duration <= 0) {
      setAlpha(alpha);
    }
 else {
      mStartAlpha=mAlpha;
      mStartTime=curTime;
      mDuration=duration;
    }
  }
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + mStartAlpha + ""String_Node_Str""+ mStartTime);
  mTargetAlpha=alpha;
}"
2118,"public void printTo(String prefix,PrintWriter pw){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDimSurface);
  pw.print(""String_Node_Str"");
  pw.print(mLayer);
  pw.print(""String_Node_Str"");
  pw.println(mAlpha);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLastDimWidth);
  pw.print(""String_Node_Str"");
  pw.println(mLastDimHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(mDuration);
  pw.print(""String_Node_Str"");
  pw.print(mStartTime);
  pw.print(""String_Node_Str"");
  pw.println(SystemClock.uptimeMillis());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStartAlpha);
  pw.print(""String_Node_Str"");
  pw.println(mTargetAlpha);
}","public void printTo(String prefix,PrintWriter pw){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDimSurface);
  pw.print(""String_Node_Str"");
  pw.print(mLayer);
  pw.print(""String_Node_Str"");
  pw.println(mAlpha);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLastBounds.toShortString());
  pw.print(""String_Node_Str"");
  pw.println(mBounds.toShortString());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(mDuration);
  pw.print(""String_Node_Str"");
  pw.print(mStartTime);
  pw.print(""String_Node_Str"");
  pw.println(SystemClock.uptimeMillis());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStartAlpha);
  pw.print(""String_Node_Str"");
  pw.println(mTargetAlpha);
}"
2119,"public int getSizeInfo(String pkgName,int persona,String apkPath,String fwdLockApkPath,String asecPath,PackageStats pStats){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  builder.append(' ');
  builder.append(pkgName);
  builder.append(' ');
  builder.append(persona);
  builder.append(' ');
  builder.append(apkPath);
  builder.append(' ');
  builder.append(fwdLockApkPath != null ? fwdLockApkPath : ""String_Node_Str"");
  builder.append(' ');
  builder.append(asecPath != null ? asecPath : ""String_Node_Str"");
  String s=transaction(builder.toString());
  String res[]=s.split(""String_Node_Str"");
  if ((res == null) || (res.length != 5)) {
    return -1;
  }
  try {
    pStats.codeSize=Long.parseLong(res[1]);
    pStats.dataSize=Long.parseLong(res[2]);
    pStats.cacheSize=Long.parseLong(res[3]);
    pStats.externalCodeSize=Long.parseLong(res[4]);
    return Integer.parseInt(res[0]);
  }
 catch (  NumberFormatException e) {
    return -1;
  }
}","public int getSizeInfo(String pkgName,int persona,String apkPath,String libDirPath,String fwdLockApkPath,String asecPath,PackageStats pStats){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  builder.append(' ');
  builder.append(pkgName);
  builder.append(' ');
  builder.append(persona);
  builder.append(' ');
  builder.append(apkPath);
  builder.append(' ');
  builder.append(libDirPath != null ? libDirPath : ""String_Node_Str"");
  builder.append(' ');
  builder.append(fwdLockApkPath != null ? fwdLockApkPath : ""String_Node_Str"");
  builder.append(' ');
  builder.append(asecPath != null ? asecPath : ""String_Node_Str"");
  String s=transaction(builder.toString());
  String res[]=s.split(""String_Node_Str"");
  if ((res == null) || (res.length != 5)) {
    return -1;
  }
  try {
    pStats.codeSize=Long.parseLong(res[1]);
    pStats.dataSize=Long.parseLong(res[2]);
    pStats.cacheSize=Long.parseLong(res[3]);
    pStats.externalCodeSize=Long.parseLong(res[4]);
    return Integer.parseInt(res[0]);
  }
 catch (  NumberFormatException e) {
    return -1;
  }
}"
2120,"private boolean getPackageSizeInfoLI(String packageName,int userHandle,PackageStats pStats){
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return false;
  }
  PackageParser.Package p;
  boolean dataOnly=false;
  String asecPath=null;
synchronized (mPackages) {
    p=mPackages.get(packageName);
    if (p == null) {
      dataOnly=true;
      PackageSetting ps=mSettings.mPackages.get(packageName);
      if ((ps == null) || (ps.pkg == null)) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
        return false;
      }
      p=ps.pkg;
    }
    if (p != null && (isExternal(p) || isForwardLocked(p))) {
      String secureContainerId=cidFromCodePath(p.applicationInfo.sourceDir);
      if (secureContainerId != null) {
        asecPath=PackageHelper.getSdFilesystem(secureContainerId);
      }
    }
  }
  String publicSrcDir=null;
  if (!dataOnly) {
    final ApplicationInfo applicationInfo=p.applicationInfo;
    if (applicationInfo == null) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
    if (isForwardLocked(p)) {
      publicSrcDir=applicationInfo.publicSourceDir;
    }
  }
  int res=mInstaller.getSizeInfo(packageName,userHandle,p.mPath,publicSrcDir,asecPath,pStats);
  if (res < 0) {
    return false;
  }
  if (!isExternal(p)) {
    pStats.codeSize+=pStats.externalCodeSize;
    pStats.externalCodeSize=0L;
  }
  return true;
}","private boolean getPackageSizeInfoLI(String packageName,int userHandle,PackageStats pStats){
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return false;
  }
  PackageParser.Package p;
  boolean dataOnly=false;
  String libDirPath=null;
  String asecPath=null;
synchronized (mPackages) {
    p=mPackages.get(packageName);
    PackageSetting ps=mSettings.mPackages.get(packageName);
    if (p == null) {
      dataOnly=true;
      if ((ps == null) || (ps.pkg == null)) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
        return false;
      }
      p=ps.pkg;
    }
    if (ps != null) {
      libDirPath=ps.nativeLibraryPathString;
    }
    if (p != null && (isExternal(p) || isForwardLocked(p))) {
      String secureContainerId=cidFromCodePath(p.applicationInfo.sourceDir);
      if (secureContainerId != null) {
        asecPath=PackageHelper.getSdFilesystem(secureContainerId);
      }
    }
  }
  String publicSrcDir=null;
  if (!dataOnly) {
    final ApplicationInfo applicationInfo=p.applicationInfo;
    if (applicationInfo == null) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
    if (isForwardLocked(p)) {
      publicSrcDir=applicationInfo.publicSourceDir;
    }
  }
  int res=mInstaller.getSizeInfo(packageName,userHandle,p.mPath,libDirPath,publicSrcDir,asecPath,pStats);
  if (res < 0) {
    return false;
  }
  if (!isExternal(p)) {
    pStats.codeSize+=pStats.externalCodeSize;
    pStats.externalCodeSize=0L;
  }
  return true;
}"
2121,"private void cancelLoadingThumbnailsAndIcons(){
  if (mTaskLoader != null) {
    mTaskLoader.cancel(false);
    mTaskLoader=null;
  }
  if (mThumbnailLoader != null) {
    mThumbnailLoader.cancel(false);
    mThumbnailLoader=null;
  }
  mLoadedTasks=null;
  if (mRecentsPanel != null) {
    mRecentsPanel.onTaskLoadingCancelled();
  }
  mFirstScreenful=false;
  mState=State.CANCELLED;
}","private void cancelLoadingThumbnailsAndIcons(){
  if (mRecentsPanel != null && mRecentsPanel.isShowing()) {
    return;
  }
  if (mTaskLoader != null) {
    mTaskLoader.cancel(false);
    mTaskLoader=null;
  }
  if (mThumbnailLoader != null) {
    mThumbnailLoader.cancel(false);
    mThumbnailLoader=null;
  }
  mLoadedTasks=null;
  if (mRecentsPanel != null) {
    mRecentsPanel.onTaskLoadingCancelled();
  }
  mFirstScreenful=false;
  mState=State.CANCELLED;
}"
2122,"@Override public void onStart(){
  if (forceOpaqueBackground(this)) {
    updateWallpaperVisibility(false);
  }
 else {
    updateWallpaperVisibility(true);
  }
  mShowing=true;
  if (mRecentsPanel != null) {
    mRecentsPanel.refreshViews();
  }
  super.onStart();
}","@Override public void onStart(){
  if (forceOpaqueBackground(this)) {
    updateWallpaperVisibility(false);
  }
 else {
    updateWallpaperVisibility(true);
  }
  mShowing=true;
  if (mRecentsPanel != null) {
    mRecentsPanel.refreshRecentTasksList();
    mRecentsPanel.refreshViews();
  }
  super.onStart();
}"
2123,"public int getSizeInfo(String pkgName,int persona,String apkPath,String fwdLockApkPath,String asecPath,PackageStats pStats){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  builder.append(' ');
  builder.append(pkgName);
  builder.append(' ');
  builder.append(persona);
  builder.append(' ');
  builder.append(apkPath);
  builder.append(' ');
  builder.append(fwdLockApkPath != null ? fwdLockApkPath : ""String_Node_Str"");
  builder.append(' ');
  builder.append(asecPath != null ? asecPath : ""String_Node_Str"");
  String s=transaction(builder.toString());
  String res[]=s.split(""String_Node_Str"");
  if ((res == null) || (res.length != 5)) {
    return -1;
  }
  try {
    pStats.codeSize=Long.parseLong(res[1]);
    pStats.dataSize=Long.parseLong(res[2]);
    pStats.cacheSize=Long.parseLong(res[3]);
    pStats.externalCodeSize=Long.parseLong(res[4]);
    return Integer.parseInt(res[0]);
  }
 catch (  NumberFormatException e) {
    return -1;
  }
}","public int getSizeInfo(String pkgName,int persona,String apkPath,String libDirPath,String fwdLockApkPath,String asecPath,PackageStats pStats){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  builder.append(' ');
  builder.append(pkgName);
  builder.append(' ');
  builder.append(persona);
  builder.append(' ');
  builder.append(apkPath);
  builder.append(' ');
  builder.append(libDirPath != null ? libDirPath : ""String_Node_Str"");
  builder.append(' ');
  builder.append(fwdLockApkPath != null ? fwdLockApkPath : ""String_Node_Str"");
  builder.append(' ');
  builder.append(asecPath != null ? asecPath : ""String_Node_Str"");
  String s=transaction(builder.toString());
  String res[]=s.split(""String_Node_Str"");
  if ((res == null) || (res.length != 5)) {
    return -1;
  }
  try {
    pStats.codeSize=Long.parseLong(res[1]);
    pStats.dataSize=Long.parseLong(res[2]);
    pStats.cacheSize=Long.parseLong(res[3]);
    pStats.externalCodeSize=Long.parseLong(res[4]);
    return Integer.parseInt(res[0]);
  }
 catch (  NumberFormatException e) {
    return -1;
  }
}"
2124,"private boolean getPackageSizeInfoLI(String packageName,int userHandle,PackageStats pStats){
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return false;
  }
  PackageParser.Package p;
  boolean dataOnly=false;
  String asecPath=null;
synchronized (mPackages) {
    p=mPackages.get(packageName);
    if (p == null) {
      dataOnly=true;
      PackageSetting ps=mSettings.mPackages.get(packageName);
      if ((ps == null) || (ps.pkg == null)) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
        return false;
      }
      p=ps.pkg;
    }
    if (p != null && (isExternal(p) || isForwardLocked(p))) {
      String secureContainerId=cidFromCodePath(p.applicationInfo.sourceDir);
      if (secureContainerId != null) {
        asecPath=PackageHelper.getSdFilesystem(secureContainerId);
      }
    }
  }
  String publicSrcDir=null;
  if (!dataOnly) {
    final ApplicationInfo applicationInfo=p.applicationInfo;
    if (applicationInfo == null) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
    if (isForwardLocked(p)) {
      publicSrcDir=applicationInfo.publicSourceDir;
    }
  }
  int res=mInstaller.getSizeInfo(packageName,userHandle,p.mPath,publicSrcDir,asecPath,pStats);
  if (res < 0) {
    return false;
  }
  if (!isExternal(p)) {
    pStats.codeSize+=pStats.externalCodeSize;
    pStats.externalCodeSize=0L;
  }
  return true;
}","private boolean getPackageSizeInfoLI(String packageName,int userHandle,PackageStats pStats){
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return false;
  }
  PackageParser.Package p;
  boolean dataOnly=false;
  String libDirPath=null;
  String asecPath=null;
synchronized (mPackages) {
    p=mPackages.get(packageName);
    PackageSetting ps=mSettings.mPackages.get(packageName);
    if (p == null) {
      dataOnly=true;
      if ((ps == null) || (ps.pkg == null)) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
        return false;
      }
      p=ps.pkg;
    }
    if (ps != null) {
      libDirPath=ps.nativeLibraryPathString;
    }
    if (p != null && (isExternal(p) || isForwardLocked(p))) {
      String secureContainerId=cidFromCodePath(p.applicationInfo.sourceDir);
      if (secureContainerId != null) {
        asecPath=PackageHelper.getSdFilesystem(secureContainerId);
      }
    }
  }
  String publicSrcDir=null;
  if (!dataOnly) {
    final ApplicationInfo applicationInfo=p.applicationInfo;
    if (applicationInfo == null) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
    if (isForwardLocked(p)) {
      publicSrcDir=applicationInfo.publicSourceDir;
    }
  }
  int res=mInstaller.getSizeInfo(packageName,userHandle,p.mPath,libDirPath,publicSrcDir,asecPath,pStats);
  if (res < 0) {
    return false;
  }
  if (!isExternal(p)) {
    pStats.codeSize+=pStats.externalCodeSize;
    pStats.externalCodeSize=0L;
  }
  return true;
}"
2125,"@Override public void handleMessage(Message message){
  Object listener=getListener(message.arg2);
  boolean listenerRemove=true;
switch (message.what) {
case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
    mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
  mConnected.countDown();
break;
case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
break;
case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
Log.e(TAG,""String_Node_Str"");
break;
case DISCOVER_SERVICES_STARTED:
String s=((NsdServiceInfo)message.obj).getServiceType();
((DiscoveryListener)listener).onDiscoveryStarted(s);
listenerRemove=false;
break;
case DISCOVER_SERVICES_FAILED:
((DiscoveryListener)listener).onStartDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case SERVICE_FOUND:
((DiscoveryListener)listener).onServiceFound((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case SERVICE_LOST:
((DiscoveryListener)listener).onServiceLost((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case STOP_DISCOVERY_FAILED:
((DiscoveryListener)listener).onStopDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case STOP_DISCOVERY_SUCCEEDED:
((DiscoveryListener)listener).onDiscoveryStopped(getNsdService(message.arg2).getServiceType());
break;
case REGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onRegistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case REGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceRegistered((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case UNREGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onUnregistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case UNREGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceUnregistered(getNsdService(message.arg2));
break;
case RESOLVE_SERVICE_FAILED:
((ResolveListener)listener).onResolveFailed(getNsdService(message.arg2),message.arg1);
break;
case RESOLVE_SERVICE_SUCCEEDED:
((ResolveListener)listener).onServiceResolved((NsdServiceInfo)message.obj);
break;
default :
Log.d(TAG,""String_Node_Str"" + message);
break;
}
if (listenerRemove) {
removeListener(message.arg2);
}
}","@Override public void handleMessage(Message message){
  Object listener=getListener(message.arg2);
  boolean listenerRemove=true;
switch (message.what) {
case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
    mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
  break;
case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
mConnected.countDown();
break;
case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
Log.e(TAG,""String_Node_Str"");
break;
case DISCOVER_SERVICES_STARTED:
String s=((NsdServiceInfo)message.obj).getServiceType();
((DiscoveryListener)listener).onDiscoveryStarted(s);
listenerRemove=false;
break;
case DISCOVER_SERVICES_FAILED:
((DiscoveryListener)listener).onStartDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case SERVICE_FOUND:
((DiscoveryListener)listener).onServiceFound((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case SERVICE_LOST:
((DiscoveryListener)listener).onServiceLost((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case STOP_DISCOVERY_FAILED:
((DiscoveryListener)listener).onStopDiscoveryFailed(getNsdService(message.arg2).getServiceType(),message.arg1);
break;
case STOP_DISCOVERY_SUCCEEDED:
((DiscoveryListener)listener).onDiscoveryStopped(getNsdService(message.arg2).getServiceType());
break;
case REGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onRegistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case REGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceRegistered((NsdServiceInfo)message.obj);
listenerRemove=false;
break;
case UNREGISTER_SERVICE_FAILED:
((RegistrationListener)listener).onUnregistrationFailed(getNsdService(message.arg2),message.arg1);
break;
case UNREGISTER_SERVICE_SUCCEEDED:
((RegistrationListener)listener).onServiceUnregistered(getNsdService(message.arg2));
break;
case RESOLVE_SERVICE_FAILED:
((ResolveListener)listener).onResolveFailed(getNsdService(message.arg2),message.arg1);
break;
case RESOLVE_SERVICE_SUCCEEDED:
((ResolveListener)listener).onServiceResolved((NsdServiceInfo)message.obj);
break;
default :
Log.d(TAG,""String_Node_Str"" + message);
break;
}
if (listenerRemove) {
removeListener(message.arg2);
}
}"
2126,"public int getSizeInfo(String pkgName,int persona,String apkPath,String fwdLockApkPath,String asecPath,PackageStats pStats){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  builder.append(' ');
  builder.append(pkgName);
  builder.append(' ');
  builder.append(persona);
  builder.append(' ');
  builder.append(apkPath);
  builder.append(' ');
  builder.append(fwdLockApkPath != null ? fwdLockApkPath : ""String_Node_Str"");
  builder.append(' ');
  builder.append(asecPath != null ? asecPath : ""String_Node_Str"");
  String s=transaction(builder.toString());
  String res[]=s.split(""String_Node_Str"");
  if ((res == null) || (res.length != 5)) {
    return -1;
  }
  try {
    pStats.codeSize=Long.parseLong(res[1]);
    pStats.dataSize=Long.parseLong(res[2]);
    pStats.cacheSize=Long.parseLong(res[3]);
    pStats.externalCodeSize=Long.parseLong(res[4]);
    return Integer.parseInt(res[0]);
  }
 catch (  NumberFormatException e) {
    return -1;
  }
}","public int getSizeInfo(String pkgName,int persona,String apkPath,String libDirPath,String fwdLockApkPath,String asecPath,PackageStats pStats){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  builder.append(' ');
  builder.append(pkgName);
  builder.append(' ');
  builder.append(persona);
  builder.append(' ');
  builder.append(apkPath);
  builder.append(' ');
  builder.append(libDirPath != null ? libDirPath : ""String_Node_Str"");
  builder.append(' ');
  builder.append(fwdLockApkPath != null ? fwdLockApkPath : ""String_Node_Str"");
  builder.append(' ');
  builder.append(asecPath != null ? asecPath : ""String_Node_Str"");
  String s=transaction(builder.toString());
  String res[]=s.split(""String_Node_Str"");
  if ((res == null) || (res.length != 5)) {
    return -1;
  }
  try {
    pStats.codeSize=Long.parseLong(res[1]);
    pStats.dataSize=Long.parseLong(res[2]);
    pStats.cacheSize=Long.parseLong(res[3]);
    pStats.externalCodeSize=Long.parseLong(res[4]);
    return Integer.parseInt(res[0]);
  }
 catch (  NumberFormatException e) {
    return -1;
  }
}"
2127,"private boolean getPackageSizeInfoLI(String packageName,int userHandle,PackageStats pStats){
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return false;
  }
  PackageParser.Package p;
  boolean dataOnly=false;
  String asecPath=null;
synchronized (mPackages) {
    p=mPackages.get(packageName);
    if (p == null) {
      dataOnly=true;
      PackageSetting ps=mSettings.mPackages.get(packageName);
      if ((ps == null) || (ps.pkg == null)) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
        return false;
      }
      p=ps.pkg;
    }
    if (p != null && (isExternal(p) || isForwardLocked(p))) {
      String secureContainerId=cidFromCodePath(p.applicationInfo.sourceDir);
      if (secureContainerId != null) {
        asecPath=PackageHelper.getSdFilesystem(secureContainerId);
      }
    }
  }
  String publicSrcDir=null;
  if (!dataOnly) {
    final ApplicationInfo applicationInfo=p.applicationInfo;
    if (applicationInfo == null) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
    if (isForwardLocked(p)) {
      publicSrcDir=applicationInfo.publicSourceDir;
    }
  }
  int res=mInstaller.getSizeInfo(packageName,userHandle,p.mPath,publicSrcDir,asecPath,pStats);
  if (res < 0) {
    return false;
  }
  if (!isExternal(p)) {
    pStats.codeSize+=pStats.externalCodeSize;
    pStats.externalCodeSize=0L;
  }
  return true;
}","private boolean getPackageSizeInfoLI(String packageName,int userHandle,PackageStats pStats){
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return false;
  }
  PackageParser.Package p;
  boolean dataOnly=false;
  String libDirPath=null;
  String asecPath=null;
synchronized (mPackages) {
    p=mPackages.get(packageName);
    PackageSetting ps=mSettings.mPackages.get(packageName);
    if (p == null) {
      dataOnly=true;
      if ((ps == null) || (ps.pkg == null)) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
        return false;
      }
      p=ps.pkg;
    }
    if (ps != null) {
      libDirPath=ps.nativeLibraryPathString;
    }
    if (p != null && (isExternal(p) || isForwardLocked(p))) {
      String secureContainerId=cidFromCodePath(p.applicationInfo.sourceDir);
      if (secureContainerId != null) {
        asecPath=PackageHelper.getSdFilesystem(secureContainerId);
      }
    }
  }
  String publicSrcDir=null;
  if (!dataOnly) {
    final ApplicationInfo applicationInfo=p.applicationInfo;
    if (applicationInfo == null) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
    if (isForwardLocked(p)) {
      publicSrcDir=applicationInfo.publicSourceDir;
    }
  }
  int res=mInstaller.getSizeInfo(packageName,userHandle,p.mPath,libDirPath,publicSrcDir,asecPath,pStats);
  if (res < 0) {
    return false;
  }
  if (!isExternal(p)) {
    pStats.codeSize+=pStats.externalCodeSize;
    pStats.externalCodeSize=0L;
  }
  return true;
}"
2128,"public int getSizeInfo(String pkgName,int persona,String apkPath,String fwdLockApkPath,String asecPath,PackageStats pStats){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  builder.append(' ');
  builder.append(pkgName);
  builder.append(' ');
  builder.append(persona);
  builder.append(' ');
  builder.append(apkPath);
  builder.append(' ');
  builder.append(fwdLockApkPath != null ? fwdLockApkPath : ""String_Node_Str"");
  builder.append(' ');
  builder.append(asecPath != null ? asecPath : ""String_Node_Str"");
  String s=transaction(builder.toString());
  String res[]=s.split(""String_Node_Str"");
  if ((res == null) || (res.length != 5)) {
    return -1;
  }
  try {
    pStats.codeSize=Long.parseLong(res[1]);
    pStats.dataSize=Long.parseLong(res[2]);
    pStats.cacheSize=Long.parseLong(res[3]);
    pStats.externalCodeSize=Long.parseLong(res[4]);
    return Integer.parseInt(res[0]);
  }
 catch (  NumberFormatException e) {
    return -1;
  }
}","public int getSizeInfo(String pkgName,int persona,String apkPath,String libDirPath,String fwdLockApkPath,String asecPath,PackageStats pStats){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  builder.append(' ');
  builder.append(pkgName);
  builder.append(' ');
  builder.append(persona);
  builder.append(' ');
  builder.append(apkPath);
  builder.append(' ');
  builder.append(libDirPath != null ? libDirPath : ""String_Node_Str"");
  builder.append(' ');
  builder.append(fwdLockApkPath != null ? fwdLockApkPath : ""String_Node_Str"");
  builder.append(' ');
  builder.append(asecPath != null ? asecPath : ""String_Node_Str"");
  String s=transaction(builder.toString());
  String res[]=s.split(""String_Node_Str"");
  if ((res == null) || (res.length != 5)) {
    return -1;
  }
  try {
    pStats.codeSize=Long.parseLong(res[1]);
    pStats.dataSize=Long.parseLong(res[2]);
    pStats.cacheSize=Long.parseLong(res[3]);
    pStats.externalCodeSize=Long.parseLong(res[4]);
    return Integer.parseInt(res[0]);
  }
 catch (  NumberFormatException e) {
    return -1;
  }
}"
2129,"private boolean getPackageSizeInfoLI(String packageName,int userHandle,PackageStats pStats){
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return false;
  }
  PackageParser.Package p;
  boolean dataOnly=false;
  String asecPath=null;
synchronized (mPackages) {
    p=mPackages.get(packageName);
    if (p == null) {
      dataOnly=true;
      PackageSetting ps=mSettings.mPackages.get(packageName);
      if ((ps == null) || (ps.pkg == null)) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
        return false;
      }
      p=ps.pkg;
    }
    if (p != null && (isExternal(p) || isForwardLocked(p))) {
      String secureContainerId=cidFromCodePath(p.applicationInfo.sourceDir);
      if (secureContainerId != null) {
        asecPath=PackageHelper.getSdFilesystem(secureContainerId);
      }
    }
  }
  String publicSrcDir=null;
  if (!dataOnly) {
    final ApplicationInfo applicationInfo=p.applicationInfo;
    if (applicationInfo == null) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
    if (isForwardLocked(p)) {
      publicSrcDir=applicationInfo.publicSourceDir;
    }
  }
  int res=mInstaller.getSizeInfo(packageName,userHandle,p.mPath,publicSrcDir,asecPath,pStats);
  if (res < 0) {
    return false;
  }
  if (!isExternal(p)) {
    pStats.codeSize+=pStats.externalCodeSize;
    pStats.externalCodeSize=0L;
  }
  return true;
}","private boolean getPackageSizeInfoLI(String packageName,int userHandle,PackageStats pStats){
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return false;
  }
  PackageParser.Package p;
  boolean dataOnly=false;
  String libDirPath=null;
  String asecPath=null;
synchronized (mPackages) {
    p=mPackages.get(packageName);
    PackageSetting ps=mSettings.mPackages.get(packageName);
    if (p == null) {
      dataOnly=true;
      if ((ps == null) || (ps.pkg == null)) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
        return false;
      }
      p=ps.pkg;
    }
    if (ps != null) {
      libDirPath=ps.nativeLibraryPathString;
    }
    if (p != null && (isExternal(p) || isForwardLocked(p))) {
      String secureContainerId=cidFromCodePath(p.applicationInfo.sourceDir);
      if (secureContainerId != null) {
        asecPath=PackageHelper.getSdFilesystem(secureContainerId);
      }
    }
  }
  String publicSrcDir=null;
  if (!dataOnly) {
    final ApplicationInfo applicationInfo=p.applicationInfo;
    if (applicationInfo == null) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
    if (isForwardLocked(p)) {
      publicSrcDir=applicationInfo.publicSourceDir;
    }
  }
  int res=mInstaller.getSizeInfo(packageName,userHandle,p.mPath,libDirPath,publicSrcDir,asecPath,pStats);
  if (res < 0) {
    return false;
  }
  if (!isExternal(p)) {
    pStats.codeSize+=pStats.externalCodeSize;
    pStats.externalCodeSize=0L;
  }
  return true;
}"
2130,"@Override public boolean isGoneForLayoutLw(){
  final AppWindowToken atoken=mAppToken;
  return mViewVisibility == View.GONE || !mRelayoutCalled || (atoken == null && mRootToken.hidden) || (atoken != null && (atoken.hiddenRequested || atoken.hidden)) || mAttachedHidden || mExiting || mDestroying;
}","@Override public boolean isGoneForLayoutLw(){
  final AppWindowToken atoken=mAppToken;
  return mViewVisibility == View.GONE || !mRelayoutCalled || (atoken == null && mRootToken.hidden) || (atoken != null && (atoken.hiddenRequested || atoken.hidden)) || mAttachedHidden || (mExiting && !isAnimatingLw()) || mDestroying;
}"
2131,"/** 
 * Specifies the formatting pattern used to display the date and/or time in 24-hour mode. The formatting pattern syntax is described in  {@link DateFormat}. If this pattern is set to null,   {@link #getFormat12Hour()} will be usedeven in 24-hour mode. If both 24-hour and 12-hour formatting patterns are set to null,  {@link #DEFAULT_FORMAT_24_HOUR} and{@link #DEFAULT_FORMAT_12_HOUR} will be used instead.
 * @param format A date/time formatting pattern as described in {@link DateFormat}
 * @see #getFormat24Hour()
 * @see #is24HourModeEnabled()
 * @see #DEFAULT_FORMAT_24_HOUR
 * @see DateFormat
 * @attr ref android.R.styleable#TextClock_format24Hour
 */
@RemotableViewMethod public void setFormat24Hour(CharSequence format){
  mFormat24=format;
  chooseFormat();
  onTimeChanged();
}","/** 
 * <p>Specifies the formatting pattern used to display the date and/or time in 24-hour mode. The formatting pattern syntax is described in  {@link DateFormat}.</p> <p>If this pattern is set to null,   {@link #getFormat24Hour()} will be usedeven in 12-hour mode. If both 24-hour and 12-hour formatting patterns are set to null, the default pattern for the current locale will be used instead.</p> <p><strong>Note:</strong> if styling is not needed, it is highly recommended you supply a format string generated by {@link DateFormat#getBestDateTimePattern(java.util.Locale,String)}. This method takes care of generating a format string adapted to the desired locale.</p>
 * @param format A date/time formatting pattern as described in {@link DateFormat}
 * @see #getFormat24Hour()
 * @see #is24HourModeEnabled()
 * @see DateFormat#getBestDateTimePattern(java.util.Locale,String)
 * @see DateFormat
 * @attr ref android.R.styleable#TextClock_format24Hour
 */
@RemotableViewMethod public void setFormat24Hour(CharSequence format){
  mFormat24=format;
  chooseFormat();
  onTimeChanged();
}"
2132,"/** 
 * Specifies the formatting pattern used to display the date and/or time in 12-hour mode. The formatting pattern syntax is described in  {@link DateFormat}. If this pattern is set to null,   {@link #getFormat24Hour()} will be usedeven in 12-hour mode. If both 24-hour and 12-hour formatting patterns are set to null,  {@link #DEFAULT_FORMAT_24_HOUR} and{@link #DEFAULT_FORMAT_12_HOUR} will be used instead.
 * @param format A date/time formatting pattern as described in {@link DateFormat}
 * @see #getFormat12Hour()
 * @see #is24HourModeEnabled()
 * @see #DEFAULT_FORMAT_12_HOUR
 * @see DateFormat
 * @attr ref android.R.styleable#TextClock_format12Hour
 */
@RemotableViewMethod public void setFormat12Hour(CharSequence format){
  mFormat12=format;
  chooseFormat();
  onTimeChanged();
}","/** 
 * <p>Specifies the formatting pattern used to display the date and/or time in 12-hour mode. The formatting pattern syntax is described in  {@link DateFormat}.</p> <p>If this pattern is set to null,   {@link #getFormat24Hour()} will be usedeven in 12-hour mode. If both 24-hour and 12-hour formatting patterns are set to null, the default pattern for the current locale will be used instead.</p> <p><strong>Note:</strong> if styling is not needed, it is highly recommended you supply a format string generated by {@link DateFormat#getBestDateTimePattern(java.util.Locale,String)}. This method takes care of generating a format string adapted to the desired locale.</p>
 * @param format A date/time formatting pattern as described in {@link DateFormat}
 * @see #getFormat12Hour()
 * @see #is24HourModeEnabled()
 * @see DateFormat#getBestDateTimePattern(java.util.Locale,String)
 * @see DateFormat
 * @attr ref android.R.styleable#TextClock_format12Hour
 */
@RemotableViewMethod public void setFormat12Hour(CharSequence format){
  mFormat12=format;
  chooseFormat();
  onTimeChanged();
}"
2133,"/** 
 * Indicates whether the system is currently using the 24-hour mode. When the system is in 24-hour mode, this view will use the pattern returned by   {@link #getFormat24Hour()}. In 12-hour mode, the pattern returned by   {@link #getFormat12Hour()} is used instead.If either one of the formats is null, the other format is used. If both formats are null, the default values  {@link #DEFAULT_FORMAT_12_HOUR}and   {@link #DEFAULT_FORMAT_24_HOUR} are used instead.
 * @return true if time should be displayed in 24-hour format, false if itshould be displayed in 12-hour format.
 * @see #setFormat12Hour(CharSequence)
 * @see #getFormat12Hour()
 * @see #setFormat24Hour(CharSequence)
 * @see #getFormat24Hour()
 */
public boolean is24HourModeEnabled(){
  return DateFormat.is24HourFormat(getContext());
}","/** 
 * Indicates whether the system is currently using the 24-hour mode. When the system is in 24-hour mode, this view will use the pattern returned by   {@link #getFormat24Hour()}. In 12-hour mode, the pattern returned by   {@link #getFormat12Hour()} is used instead.If either one of the formats is null, the other format is used. If both formats are null, the default formats for the current locale are used.
 * @return true if time should be displayed in 24-hour format, false if itshould be displayed in 12-hour format.
 * @see #setFormat12Hour(CharSequence)
 * @see #getFormat12Hour()
 * @see #setFormat24Hour(CharSequence)
 * @see #getFormat24Hour()
 */
public boolean is24HourModeEnabled(){
  return DateFormat.is24HourFormat(getContext());
}"
2134,"/** 
 * Returns whether DRM ringtones will be included.
 * @return Whether DRM ringtones will be included.
 * @see #setIncludeDrm(boolean) Obsolete - always returns false
 * @deprecated
 */
@Deprecated public boolean getIncludeDrm(){
  return false;
}","/** 
 * Returns whether DRM ringtones will be included.
 * @return Whether DRM ringtones will be included.
 * @see #setIncludeDrm(boolean) Obsolete - always returns false
 * @deprecated DRM ringtones are no longer supported
 */
@Deprecated public boolean getIncludeDrm(){
  return false;
}"
2135,"/** 
 * Sets whether to include DRM ringtones.
 * @param includeDrm Whether to include DRM ringtones.Obsolete - no longer does anything
 * @deprecated
 */
@Deprecated public void setIncludeDrm(boolean includeDrm){
  if (includeDrm) {
    Log.w(TAG,""String_Node_Str"");
  }
}","/** 
 * Sets whether to include DRM ringtones.
 * @param includeDrm Whether to include DRM ringtones.Obsolete - no longer has any effect
 * @deprecated DRM ringtones are no longer supported
 */
@Deprecated public void setIncludeDrm(boolean includeDrm){
  if (includeDrm) {
    Log.w(TAG,""String_Node_Str"");
  }
}"
2136,"/** 
 * Returns whether DRM ringtones will be included.
 * @return Whether DRM ringtones will be included.
 * @see #setIncludeDrm(boolean) Obsolete - always returns false
 * @deprecated
 */
@Deprecated public boolean getIncludeDrm(){
  return false;
}","/** 
 * Returns whether DRM ringtones will be included.
 * @return Whether DRM ringtones will be included.
 * @see #setIncludeDrm(boolean) Obsolete - always returns false
 * @deprecated DRM ringtones are no longer supported
 */
@Deprecated public boolean getIncludeDrm(){
  return false;
}"
2137,"/** 
 * Sets whether to include DRM ringtones.
 * @param includeDrm Whether to include DRM ringtones.Obsolete - no longer does anything
 * @deprecated
 */
@Deprecated public void setIncludeDrm(boolean includeDrm){
  if (includeDrm) {
    Log.w(TAG,""String_Node_Str"");
  }
}","/** 
 * Sets whether to include DRM ringtones.
 * @param includeDrm Whether to include DRM ringtones.Obsolete - no longer has any effect
 * @deprecated DRM ringtones are no longer supported
 */
@Deprecated public void setIncludeDrm(boolean includeDrm){
  if (includeDrm) {
    Log.w(TAG,""String_Node_Str"");
  }
}"
2138,"@Override public boolean isGoneForLayoutLw(){
  final AppWindowToken atoken=mAppToken;
  return mViewVisibility == View.GONE || !mRelayoutCalled || (atoken == null && mRootToken.hidden) || (atoken != null && (atoken.hiddenRequested || atoken.hidden)) || mAttachedHidden || mExiting || mDestroying;
}","@Override public boolean isGoneForLayoutLw(){
  final AppWindowToken atoken=mAppToken;
  return mViewVisibility == View.GONE || !mRelayoutCalled || (atoken == null && mRootToken.hidden) || (atoken != null && (atoken.hiddenRequested || atoken.hidden)) || mAttachedHidden || (mExiting && !isAnimatingLw()) || mDestroying;
}"
2139,"void reportActivityLaunchedLocked(boolean timeout,ActivityRecord r,long thisTime,long totalTime){
  for (int i=mWaitingActivityLaunched.size() - 1; i >= 0; i--) {
    WaitResult w=mWaitingActivityLaunched.get(i);
    w.timeout=timeout;
    if (r != null) {
      w.who=new ComponentName(r.info.packageName,r.info.name);
    }
    w.thisTime=thisTime;
    w.totalTime=totalTime;
  }
  mService.notifyAll();
}","void reportActivityLaunchedLocked(boolean timeout,ActivityRecord r,long thisTime,long totalTime){
  for (int i=mWaitingActivityLaunched.size() - 1; i >= 0; i--) {
    WaitResult w=mWaitingActivityLaunched.remove(i);
    w.timeout=timeout;
    if (r != null) {
      w.who=new ComponentName(r.info.packageName,r.info.name);
    }
    w.thisTime=thisTime;
    w.totalTime=totalTime;
  }
  mService.notifyAll();
}"
2140,"void scheduleIdleTimeoutLocked(ActivityRecord next){
  mHandler.obtainMessage(IDLE_TIMEOUT_MSG,next).sendToTarget();
}","void scheduleIdleTimeoutLocked(ActivityRecord next){
  Message msg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG,next);
  mHandler.sendMessageDelayed(msg,IDLE_TIMEOUT);
}"
2141,"void reportActivityLaunchedLocked(boolean timeout,ActivityRecord r,long thisTime,long totalTime){
  for (int i=mWaitingActivityLaunched.size() - 1; i >= 0; i--) {
    WaitResult w=mWaitingActivityLaunched.get(i);
    w.timeout=timeout;
    if (r != null) {
      w.who=new ComponentName(r.info.packageName,r.info.name);
    }
    w.thisTime=thisTime;
    w.totalTime=totalTime;
  }
  mService.notifyAll();
}","void reportActivityLaunchedLocked(boolean timeout,ActivityRecord r,long thisTime,long totalTime){
  for (int i=mWaitingActivityLaunched.size() - 1; i >= 0; i--) {
    WaitResult w=mWaitingActivityLaunched.remove(i);
    w.timeout=timeout;
    if (r != null) {
      w.who=new ComponentName(r.info.packageName,r.info.name);
    }
    w.thisTime=thisTime;
    w.totalTime=totalTime;
  }
  mService.notifyAll();
}"
2142,"void scheduleIdleTimeoutLocked(ActivityRecord next){
  mHandler.obtainMessage(IDLE_TIMEOUT_MSG,next).sendToTarget();
}","void scheduleIdleTimeoutLocked(ActivityRecord next){
  Message msg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG,next);
  mHandler.sendMessageDelayed(msg,IDLE_TIMEOUT);
}"
2143,"/** 
 * Executes a command and waits for a specific accessibility event up to a given wait timeout. To detect a sequence of events one can implement a filter that keeps track of seen events of the expected sequence and returns true after the last event of that sequence is received. <p> <strong>Note:</strong> It is caller's responsibility to recycle the returned event. </p>
 * @param command The command to execute.
 * @param filter Filter that recognizes the expected event.
 * @param timeoutMillis The wait timeout in milliseconds.
 * @throws TimeoutException If the expected event is not received within the timeout.
 */
public AccessibilityEvent executeAndWaitForEvent(Runnable command,AccessibilityEventFilter filter,long timeoutMillis) throws TimeoutException {
synchronized (mLock) {
    throwIfNotConnectedLocked();
    mEventQueue.clear();
    mWaitingForEventDelivery=true;
    final long executionStartTimeMillis=SystemClock.uptimeMillis();
    command.run();
    try {
      final long startTimeMillis=SystemClock.uptimeMillis();
      while (true) {
        while (!mEventQueue.isEmpty()) {
          AccessibilityEvent event=mEventQueue.remove(0);
          if (event.getEventTime() <= executionStartTimeMillis) {
            continue;
          }
          if (filter.accept(event)) {
            return event;
          }
          event.recycle();
        }
        final long elapsedTimeMillis=SystemClock.uptimeMillis() - startTimeMillis;
        final long remainingTimeMillis=timeoutMillis - elapsedTimeMillis;
        if (remainingTimeMillis <= 0) {
          throw new TimeoutException(""String_Node_Str"" + timeoutMillis + ""String_Node_Str"");
        }
        try {
          mLock.wait(remainingTimeMillis);
        }
 catch (        InterruptedException ie) {
        }
      }
    }
  finally {
      mWaitingForEventDelivery=false;
      mEventQueue.clear();
      mLock.notifyAll();
    }
  }
}","/** 
 * Executes a command and waits for a specific accessibility event up to a given wait timeout. To detect a sequence of events one can implement a filter that keeps track of seen events of the expected sequence and returns true after the last event of that sequence is received. <p> <strong>Note:</strong> It is caller's responsibility to recycle the returned event. </p>
 * @param command The command to execute.
 * @param filter Filter that recognizes the expected event.
 * @param timeoutMillis The wait timeout in milliseconds.
 * @throws TimeoutException If the expected event is not received within the timeout.
 */
public AccessibilityEvent executeAndWaitForEvent(Runnable command,AccessibilityEventFilter filter,long timeoutMillis) throws TimeoutException {
synchronized (mLock) {
    throwIfNotConnectedLocked();
    mEventQueue.clear();
    mWaitingForEventDelivery=true;
  }
  final long executionStartTimeMillis=SystemClock.uptimeMillis();
  command.run();
synchronized (mLock) {
    try {
      final long startTimeMillis=SystemClock.uptimeMillis();
      while (true) {
        while (!mEventQueue.isEmpty()) {
          AccessibilityEvent event=mEventQueue.remove(0);
          if (event.getEventTime() < executionStartTimeMillis) {
            continue;
          }
          if (filter.accept(event)) {
            return event;
          }
          event.recycle();
        }
        final long elapsedTimeMillis=SystemClock.uptimeMillis() - startTimeMillis;
        final long remainingTimeMillis=timeoutMillis - elapsedTimeMillis;
        if (remainingTimeMillis <= 0) {
          throw new TimeoutException(""String_Node_Str"" + timeoutMillis + ""String_Node_Str"");
        }
        try {
          mLock.wait(remainingTimeMillis);
        }
 catch (        InterruptedException ie) {
        }
      }
    }
  finally {
      mWaitingForEventDelivery=false;
      mEventQueue.clear();
      mLock.notifyAll();
    }
  }
}"
2144,"private void registerUiTestAutomationServiceLocked(IAccessibilityServiceClient client){
  IAccessibilityManager manager=IAccessibilityManager.Stub.asInterface(ServiceManager.getService(Context.ACCESSIBILITY_SERVICE));
  AccessibilityServiceInfo info=new AccessibilityServiceInfo();
  info.eventTypes=AccessibilityEvent.TYPES_ALL_MASK;
  info.feedbackType=AccessibilityServiceInfo.FEEDBACK_GENERIC;
  info.flags|=AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS | AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS;
  try {
    manager.registerUiTestAutomationService(mToken,client,info);
    mClient=client;
  }
 catch (  RemoteException re) {
    throw new IllegalStateException(""String_Node_Str"",re);
  }
}","private void registerUiTestAutomationServiceLocked(IAccessibilityServiceClient client){
  IAccessibilityManager manager=IAccessibilityManager.Stub.asInterface(ServiceManager.getService(Context.ACCESSIBILITY_SERVICE));
  AccessibilityServiceInfo info=new AccessibilityServiceInfo(true);
  info.eventTypes=AccessibilityEvent.TYPES_ALL_MASK;
  info.feedbackType=AccessibilityServiceInfo.FEEDBACK_GENERIC;
  info.flags|=AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS | AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS;
  try {
    manager.registerUiTestAutomationService(mToken,client,info);
    mClient=client;
  }
 catch (  RemoteException re) {
    throw new IllegalStateException(""String_Node_Str"",re);
  }
}"
2145,"/** 
 * The cache keeps track of   {@link AccessibilityEvent}s and invalidates cached nodes as appropriate.
 * @param event An event.
 */
public void onAccessibilityEvent(AccessibilityEvent event){
  if (ENABLED) {
    final int eventType=event.getEventType();
switch (eventType) {
case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:
{
        mWindowId=event.getWindowId();
        clear();
      }
    break;
case AccessibilityEvent.TYPE_VIEW_HOVER_ENTER:
case AccessibilityEvent.TYPE_VIEW_HOVER_EXIT:
{
    final int windowId=event.getWindowId();
    if (mWindowId != windowId) {
      mWindowId=windowId;
      clear();
    }
  }
break;
case AccessibilityEvent.TYPE_VIEW_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_SELECTED:
case AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED:
{
synchronized (mLock) {
  final long sourceId=event.getSourceNodeId();
  clearSubTreeLocked(sourceId);
  if (eventType == AccessibilityEvent.TYPE_VIEW_FOCUSED) {
    clearSubtreeWithOldInputFocusLocked(sourceId);
  }
  if (eventType == AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED) {
    clearSubtreeWithOldAccessibilityFocusLocked(sourceId);
  }
}
}
break;
case AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_SCROLLED:
{
synchronized (mLock) {
final long accessibilityNodeId=event.getSourceNodeId();
clearSubTreeLocked(accessibilityNodeId);
}
}
break;
}
if (Build.IS_DEBUGGABLE && CHECK_INTEGRITY) {
checkIntegrity();
}
}
}","/** 
 * The cache keeps track of   {@link AccessibilityEvent}s and invalidates cached nodes as appropriate.
 * @param event An event.
 */
public void onAccessibilityEvent(AccessibilityEvent event){
  if (ENABLED) {
    final int eventType=event.getEventType();
switch (eventType) {
case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:
{
        mWindowId=event.getWindowId();
        clear();
      }
    break;
case AccessibilityEvent.TYPE_VIEW_HOVER_ENTER:
case AccessibilityEvent.TYPE_VIEW_HOVER_EXIT:
{
    final int windowId=event.getWindowId();
    if (mWindowId != windowId) {
      mWindowId=windowId;
      clear();
    }
  }
break;
case AccessibilityEvent.TYPE_VIEW_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
case AccessibilityEvent.TYPE_VIEW_SELECTED:
case AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED:
{
synchronized (mLock) {
  final long sourceId=event.getSourceNodeId();
  clearSubTreeLocked(sourceId);
  if (eventType == AccessibilityEvent.TYPE_VIEW_FOCUSED) {
    clearSubtreeWithOldInputFocusLocked(sourceId);
  }
  if (eventType == AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED) {
    clearSubtreeWithOldAccessibilityFocusLocked(sourceId);
  }
}
}
break;
case AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_SCROLLED:
{
synchronized (mLock) {
final long accessibilityNodeId=event.getSourceNodeId();
clearSubTreeLocked(accessibilityNodeId);
}
}
break;
}
if (Build.IS_DEBUGGABLE && CHECK_INTEGRITY) {
checkIntegrity();
}
}
}"
2146,"@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  info.setClassName(TextView.class.getName());
  final boolean isPassword=hasPasswordTransformationMethod();
  info.setPassword(isPassword);
  if (!isPassword) {
    info.setText(getTextForAccessibility());
  }
  if (mBufferType == BufferType.EDITABLE) {
    info.setEditable(true);
  }
  if (TextUtils.isEmpty(getContentDescription()) && !TextUtils.isEmpty(mText)) {
    info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
    info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
    info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PAGE);
  }
  if (isFocused()) {
    if (canSelectText()) {
      info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
    }
    if (canCopy()) {
      info.addAction(AccessibilityNodeInfo.ACTION_COPY);
    }
    if (canPaste()) {
      info.addAction(AccessibilityNodeInfo.ACTION_PASTE);
    }
    if (canCut()) {
      info.addAction(AccessibilityNodeInfo.ACTION_CUT);
    }
  }
}","@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  info.setClassName(TextView.class.getName());
  final boolean isPassword=hasPasswordTransformationMethod();
  info.setPassword(isPassword);
  if (!isPassword) {
    info.setText(getTextForAccessibility());
  }
  if (mBufferType == BufferType.EDITABLE) {
    info.setEditable(true);
  }
  if (!TextUtils.isEmpty(mText)) {
    info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
    info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
    info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PAGE);
  }
  if (isFocused()) {
    if (canSelectText()) {
      info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
    }
    if (canCopy()) {
      info.addAction(AccessibilityNodeInfo.ACTION_COPY);
    }
    if (canPaste()) {
      info.addAction(AccessibilityNodeInfo.ACTION_PASTE);
    }
    if (canCut()) {
      info.addAction(AccessibilityNodeInfo.ACTION_CUT);
    }
  }
}"
2147,"/** 
 * @hide
 */
@Override public int getAccessibilitySelectionStart(){
  if (TextUtils.isEmpty(getContentDescription())) {
    final int selectionStart=getSelectionStart();
    if (selectionStart >= 0) {
      return selectionStart;
    }
  }
  return ACCESSIBILITY_CURSOR_POSITION_UNDEFINED;
}","/** 
 * @hide
 */
@Override public int getAccessibilitySelectionStart(){
  return getSelectionStart();
}"
2148,"/** 
 * @hide
 */
@Override public CharSequence getIterableTextForAccessibility(){
  if (!TextUtils.isEmpty(mText)) {
    if (!(mText instanceof Spannable)) {
      setText(mText,BufferType.SPANNABLE);
    }
    return mText;
  }
  return super.getIterableTextForAccessibility();
}","/** 
 * @hide
 */
@Override public CharSequence getIterableTextForAccessibility(){
  if (!(mText instanceof Spannable)) {
    setText(mText,BufferType.SPANNABLE);
  }
  return mText;
}"
2149,"/** 
 * @hide
 */
@Override public int getAccessibilitySelectionEnd(){
  if (TextUtils.isEmpty(getContentDescription())) {
    final int selectionEnd=getSelectionEnd();
    if (selectionEnd >= 0) {
      return selectionEnd;
    }
  }
  return ACCESSIBILITY_CURSOR_POSITION_UNDEFINED;
}","/** 
 * @hide
 */
@Override public int getAccessibilitySelectionEnd(){
  return getSelectionEnd();
}"
2150,"public void setDynamicallyConfigurableProperties(AccessibilityServiceInfo info){
  mEventTypes=info.eventTypes;
  mFeedbackType=info.feedbackType;
  String[] packageNames=info.packageNames;
  if (packageNames != null) {
    mPackageNames.addAll(Arrays.asList(packageNames));
  }
  mNotificationTimeout=info.notificationTimeout;
  mIsDefault=(info.flags & DEFAULT) != 0;
  if (mIsAutomation || info.getResolveInfo().serviceInfo.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
    if ((info.flags & AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS) != 0) {
      mFetchFlags|=AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
 else {
      mFetchFlags&=~AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
  }
  if ((info.flags & AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS) != 0) {
    mFetchFlags|=AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
 else {
    mFetchFlags&=~AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
  if (mResolveInfo != null) {
    mRequestTouchExplorationMode=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE) != 0;
    mRequestEnhancedWebAccessibility=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY) != 0;
    mRequestFilterKeyEvents=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_FILTER_KEY_EVENTS) != 0;
  }
}","public void setDynamicallyConfigurableProperties(AccessibilityServiceInfo info){
  mEventTypes=info.eventTypes;
  mFeedbackType=info.feedbackType;
  String[] packageNames=info.packageNames;
  if (packageNames != null) {
    mPackageNames.addAll(Arrays.asList(packageNames));
  }
  mNotificationTimeout=info.notificationTimeout;
  mIsDefault=(info.flags & DEFAULT) != 0;
  if (mIsAutomation || info.getResolveInfo().serviceInfo.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
    if ((info.flags & AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS) != 0) {
      mFetchFlags|=AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
 else {
      mFetchFlags&=~AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
  }
  if ((info.flags & AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS) != 0) {
    mFetchFlags|=AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
 else {
    mFetchFlags&=~AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
  mRequestTouchExplorationMode=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE) != 0;
  mRequestEnhancedWebAccessibility=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY) != 0;
  mRequestFilterKeyEvents=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_FILTER_KEY_EVENTS) != 0;
}"
2151,"private void migrateOldData(){
  try {
    if (getString(""String_Node_Str"",null,0) == null) {
      final ContentResolver cr=mContext.getContentResolver();
      for (      String validSetting : VALID_SETTINGS) {
        String value=Settings.Secure.getString(cr,validSetting);
        if (value != null) {
          setString(validSetting,value,0);
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final ContentResolver cr=mContext.getContentResolver();
      List<UserInfo> users=um.getUsers();
      for (int user=0; user < users.size(); user++) {
        int userId=users.get(user).getUserHandle().getIdentifier();
        for (        String perUserSetting : MIGRATE_SETTINGS_PER_USER) {
          String value=Settings.Secure.getStringForUser(cr,perUserSetting,userId);
          if (value != null) {
            setString(perUserSetting,value,userId);
            Settings.Secure.putStringForUser(cr,perUserSetting,""String_Node_Str"",userId);
            continue;
          }
          try {
            int ivalue=Settings.Secure.getIntForUser(cr,perUserSetting,userId);
            setLong(perUserSetting,ivalue,userId);
            Settings.Secure.putIntForUser(cr,perUserSetting,0,userId);
          }
 catch (          SettingNotFoundException e) {
          }
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
  }
 catch (  RemoteException re) {
    Slog.e(TAG,""String_Node_Str"",re);
  }
}","private void migrateOldData(){
  try {
    if (getString(""String_Node_Str"",null,0) == null) {
      final ContentResolver cr=mContext.getContentResolver();
      for (      String validSetting : VALID_SETTINGS) {
        String value=Settings.Secure.getString(cr,validSetting);
        if (value != null) {
          setString(validSetting,value,0);
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final ContentResolver cr=mContext.getContentResolver();
      List<UserInfo> users=um.getUsers();
      for (int user=0; user < users.size(); user++) {
        final int userId=users.get(user).id;
        final String OWNER_INFO=Secure.LOCK_SCREEN_OWNER_INFO;
        String ownerInfo=Settings.Secure.getStringForUser(cr,OWNER_INFO,userId);
        if (ownerInfo != null) {
          setString(OWNER_INFO,ownerInfo,userId);
          Settings.Secure.putStringForUser(cr,ownerInfo,""String_Node_Str"",userId);
        }
        final String OWNER_INFO_ENABLED=Secure.LOCK_SCREEN_OWNER_INFO_ENABLED;
        boolean enabled;
        try {
          int ivalue=Settings.Secure.getIntForUser(cr,OWNER_INFO_ENABLED,userId);
          enabled=ivalue != 0;
          setLong(OWNER_INFO_ENABLED,enabled ? 1 : 0,userId);
        }
 catch (        SettingNotFoundException e) {
          if (!TextUtils.isEmpty(ownerInfo)) {
            setLong(OWNER_INFO_ENABLED,1,userId);
          }
        }
        Settings.Secure.putIntForUser(cr,OWNER_INFO_ENABLED,0,userId);
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
  }
 catch (  RemoteException re) {
    Slog.e(TAG,""String_Node_Str"",re);
  }
}"
2152,"/** 
 * Executes a command and waits for a specific accessibility event up to a given wait timeout. To detect a sequence of events one can implement a filter that keeps track of seen events of the expected sequence and returns true after the last event of that sequence is received. <p> <strong>Note:</strong> It is caller's responsibility to recycle the returned event. </p>
 * @param command The command to execute.
 * @param filter Filter that recognizes the expected event.
 * @param timeoutMillis The wait timeout in milliseconds.
 * @throws TimeoutException If the expected event is not received within the timeout.
 */
public AccessibilityEvent executeAndWaitForEvent(Runnable command,AccessibilityEventFilter filter,long timeoutMillis) throws TimeoutException {
synchronized (mLock) {
    throwIfNotConnectedLocked();
    mEventQueue.clear();
    mWaitingForEventDelivery=true;
    final long executionStartTimeMillis=SystemClock.uptimeMillis();
    command.run();
    try {
      final long startTimeMillis=SystemClock.uptimeMillis();
      while (true) {
        while (!mEventQueue.isEmpty()) {
          AccessibilityEvent event=mEventQueue.remove(0);
          if (event.getEventTime() <= executionStartTimeMillis) {
            continue;
          }
          if (filter.accept(event)) {
            return event;
          }
          event.recycle();
        }
        final long elapsedTimeMillis=SystemClock.uptimeMillis() - startTimeMillis;
        final long remainingTimeMillis=timeoutMillis - elapsedTimeMillis;
        if (remainingTimeMillis <= 0) {
          throw new TimeoutException(""String_Node_Str"" + timeoutMillis + ""String_Node_Str"");
        }
        try {
          mLock.wait(remainingTimeMillis);
        }
 catch (        InterruptedException ie) {
        }
      }
    }
  finally {
      mWaitingForEventDelivery=false;
      mEventQueue.clear();
      mLock.notifyAll();
    }
  }
}","/** 
 * Executes a command and waits for a specific accessibility event up to a given wait timeout. To detect a sequence of events one can implement a filter that keeps track of seen events of the expected sequence and returns true after the last event of that sequence is received. <p> <strong>Note:</strong> It is caller's responsibility to recycle the returned event. </p>
 * @param command The command to execute.
 * @param filter Filter that recognizes the expected event.
 * @param timeoutMillis The wait timeout in milliseconds.
 * @throws TimeoutException If the expected event is not received within the timeout.
 */
public AccessibilityEvent executeAndWaitForEvent(Runnable command,AccessibilityEventFilter filter,long timeoutMillis) throws TimeoutException {
synchronized (mLock) {
    throwIfNotConnectedLocked();
    mEventQueue.clear();
    mWaitingForEventDelivery=true;
  }
  final long executionStartTimeMillis=SystemClock.uptimeMillis();
  command.run();
synchronized (mLock) {
    try {
      final long startTimeMillis=SystemClock.uptimeMillis();
      while (true) {
        while (!mEventQueue.isEmpty()) {
          AccessibilityEvent event=mEventQueue.remove(0);
          if (event.getEventTime() < executionStartTimeMillis) {
            continue;
          }
          if (filter.accept(event)) {
            return event;
          }
          event.recycle();
        }
        final long elapsedTimeMillis=SystemClock.uptimeMillis() - startTimeMillis;
        final long remainingTimeMillis=timeoutMillis - elapsedTimeMillis;
        if (remainingTimeMillis <= 0) {
          throw new TimeoutException(""String_Node_Str"" + timeoutMillis + ""String_Node_Str"");
        }
        try {
          mLock.wait(remainingTimeMillis);
        }
 catch (        InterruptedException ie) {
        }
      }
    }
  finally {
      mWaitingForEventDelivery=false;
      mEventQueue.clear();
      mLock.notifyAll();
    }
  }
}"
2153,"private void registerUiTestAutomationServiceLocked(IAccessibilityServiceClient client){
  IAccessibilityManager manager=IAccessibilityManager.Stub.asInterface(ServiceManager.getService(Context.ACCESSIBILITY_SERVICE));
  AccessibilityServiceInfo info=new AccessibilityServiceInfo();
  info.eventTypes=AccessibilityEvent.TYPES_ALL_MASK;
  info.feedbackType=AccessibilityServiceInfo.FEEDBACK_GENERIC;
  info.flags|=AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS | AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS;
  try {
    manager.registerUiTestAutomationService(mToken,client,info);
    mClient=client;
  }
 catch (  RemoteException re) {
    throw new IllegalStateException(""String_Node_Str"",re);
  }
}","private void registerUiTestAutomationServiceLocked(IAccessibilityServiceClient client){
  IAccessibilityManager manager=IAccessibilityManager.Stub.asInterface(ServiceManager.getService(Context.ACCESSIBILITY_SERVICE));
  AccessibilityServiceInfo info=new AccessibilityServiceInfo(true);
  info.eventTypes=AccessibilityEvent.TYPES_ALL_MASK;
  info.feedbackType=AccessibilityServiceInfo.FEEDBACK_GENERIC;
  info.flags|=AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS | AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS;
  try {
    manager.registerUiTestAutomationService(mToken,client,info);
    mClient=client;
  }
 catch (  RemoteException re) {
    throw new IllegalStateException(""String_Node_Str"",re);
  }
}"
2154,"/** 
 * The cache keeps track of   {@link AccessibilityEvent}s and invalidates cached nodes as appropriate.
 * @param event An event.
 */
public void onAccessibilityEvent(AccessibilityEvent event){
  if (ENABLED) {
    final int eventType=event.getEventType();
switch (eventType) {
case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:
{
        mWindowId=event.getWindowId();
        clear();
      }
    break;
case AccessibilityEvent.TYPE_VIEW_HOVER_ENTER:
case AccessibilityEvent.TYPE_VIEW_HOVER_EXIT:
{
    final int windowId=event.getWindowId();
    if (mWindowId != windowId) {
      mWindowId=windowId;
      clear();
    }
  }
break;
case AccessibilityEvent.TYPE_VIEW_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_SELECTED:
case AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED:
{
synchronized (mLock) {
  final long sourceId=event.getSourceNodeId();
  clearSubTreeLocked(sourceId);
  if (eventType == AccessibilityEvent.TYPE_VIEW_FOCUSED) {
    clearSubtreeWithOldInputFocusLocked(sourceId);
  }
  if (eventType == AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED) {
    clearSubtreeWithOldAccessibilityFocusLocked(sourceId);
  }
}
}
break;
case AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_SCROLLED:
{
synchronized (mLock) {
final long accessibilityNodeId=event.getSourceNodeId();
clearSubTreeLocked(accessibilityNodeId);
}
}
break;
}
if (Build.IS_DEBUGGABLE && CHECK_INTEGRITY) {
checkIntegrity();
}
}
}","/** 
 * The cache keeps track of   {@link AccessibilityEvent}s and invalidates cached nodes as appropriate.
 * @param event An event.
 */
public void onAccessibilityEvent(AccessibilityEvent event){
  if (ENABLED) {
    final int eventType=event.getEventType();
switch (eventType) {
case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:
{
        mWindowId=event.getWindowId();
        clear();
      }
    break;
case AccessibilityEvent.TYPE_VIEW_HOVER_ENTER:
case AccessibilityEvent.TYPE_VIEW_HOVER_EXIT:
{
    final int windowId=event.getWindowId();
    if (mWindowId != windowId) {
      mWindowId=windowId;
      clear();
    }
  }
break;
case AccessibilityEvent.TYPE_VIEW_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
case AccessibilityEvent.TYPE_VIEW_SELECTED:
case AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED:
{
synchronized (mLock) {
  final long sourceId=event.getSourceNodeId();
  clearSubTreeLocked(sourceId);
  if (eventType == AccessibilityEvent.TYPE_VIEW_FOCUSED) {
    clearSubtreeWithOldInputFocusLocked(sourceId);
  }
  if (eventType == AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED) {
    clearSubtreeWithOldAccessibilityFocusLocked(sourceId);
  }
}
}
break;
case AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_SCROLLED:
{
synchronized (mLock) {
final long accessibilityNodeId=event.getSourceNodeId();
clearSubTreeLocked(accessibilityNodeId);
}
}
break;
}
if (Build.IS_DEBUGGABLE && CHECK_INTEGRITY) {
checkIntegrity();
}
}
}"
2155,"@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  info.setClassName(TextView.class.getName());
  final boolean isPassword=hasPasswordTransformationMethod();
  info.setPassword(isPassword);
  if (!isPassword) {
    info.setText(getTextForAccessibility());
  }
  if (mBufferType == BufferType.EDITABLE) {
    info.setEditable(true);
  }
  if (TextUtils.isEmpty(getContentDescription()) && !TextUtils.isEmpty(mText)) {
    info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
    info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
    info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PAGE);
  }
  if (isFocused()) {
    if (canSelectText()) {
      info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
    }
    if (canCopy()) {
      info.addAction(AccessibilityNodeInfo.ACTION_COPY);
    }
    if (canPaste()) {
      info.addAction(AccessibilityNodeInfo.ACTION_PASTE);
    }
    if (canCut()) {
      info.addAction(AccessibilityNodeInfo.ACTION_CUT);
    }
  }
}","@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  info.setClassName(TextView.class.getName());
  final boolean isPassword=hasPasswordTransformationMethod();
  info.setPassword(isPassword);
  if (!isPassword) {
    info.setText(getTextForAccessibility());
  }
  if (mBufferType == BufferType.EDITABLE) {
    info.setEditable(true);
  }
  if (!TextUtils.isEmpty(mText)) {
    info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
    info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
    info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PAGE);
  }
  if (isFocused()) {
    if (canSelectText()) {
      info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
    }
    if (canCopy()) {
      info.addAction(AccessibilityNodeInfo.ACTION_COPY);
    }
    if (canPaste()) {
      info.addAction(AccessibilityNodeInfo.ACTION_PASTE);
    }
    if (canCut()) {
      info.addAction(AccessibilityNodeInfo.ACTION_CUT);
    }
  }
}"
2156,"/** 
 * @hide
 */
@Override public int getAccessibilitySelectionStart(){
  if (TextUtils.isEmpty(getContentDescription())) {
    final int selectionStart=getSelectionStart();
    if (selectionStart >= 0) {
      return selectionStart;
    }
  }
  return ACCESSIBILITY_CURSOR_POSITION_UNDEFINED;
}","/** 
 * @hide
 */
@Override public int getAccessibilitySelectionStart(){
  return getSelectionStart();
}"
2157,"/** 
 * @hide
 */
@Override public CharSequence getIterableTextForAccessibility(){
  if (!TextUtils.isEmpty(mText)) {
    if (!(mText instanceof Spannable)) {
      setText(mText,BufferType.SPANNABLE);
    }
    return mText;
  }
  return super.getIterableTextForAccessibility();
}","/** 
 * @hide
 */
@Override public CharSequence getIterableTextForAccessibility(){
  if (!(mText instanceof Spannable)) {
    setText(mText,BufferType.SPANNABLE);
  }
  return mText;
}"
2158,"/** 
 * @hide
 */
@Override public int getAccessibilitySelectionEnd(){
  if (TextUtils.isEmpty(getContentDescription())) {
    final int selectionEnd=getSelectionEnd();
    if (selectionEnd >= 0) {
      return selectionEnd;
    }
  }
  return ACCESSIBILITY_CURSOR_POSITION_UNDEFINED;
}","/** 
 * @hide
 */
@Override public int getAccessibilitySelectionEnd(){
  return getSelectionEnd();
}"
2159,"public void setDynamicallyConfigurableProperties(AccessibilityServiceInfo info){
  mEventTypes=info.eventTypes;
  mFeedbackType=info.feedbackType;
  String[] packageNames=info.packageNames;
  if (packageNames != null) {
    mPackageNames.addAll(Arrays.asList(packageNames));
  }
  mNotificationTimeout=info.notificationTimeout;
  mIsDefault=(info.flags & DEFAULT) != 0;
  if (mIsAutomation || info.getResolveInfo().serviceInfo.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
    if ((info.flags & AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS) != 0) {
      mFetchFlags|=AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
 else {
      mFetchFlags&=~AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
  }
  if ((info.flags & AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS) != 0) {
    mFetchFlags|=AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
 else {
    mFetchFlags&=~AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
  if (mResolveInfo != null) {
    mRequestTouchExplorationMode=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE) != 0;
    mRequestEnhancedWebAccessibility=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY) != 0;
    mRequestFilterKeyEvents=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_FILTER_KEY_EVENTS) != 0;
  }
}","public void setDynamicallyConfigurableProperties(AccessibilityServiceInfo info){
  mEventTypes=info.eventTypes;
  mFeedbackType=info.feedbackType;
  String[] packageNames=info.packageNames;
  if (packageNames != null) {
    mPackageNames.addAll(Arrays.asList(packageNames));
  }
  mNotificationTimeout=info.notificationTimeout;
  mIsDefault=(info.flags & DEFAULT) != 0;
  if (mIsAutomation || info.getResolveInfo().serviceInfo.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
    if ((info.flags & AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS) != 0) {
      mFetchFlags|=AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
 else {
      mFetchFlags&=~AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
  }
  if ((info.flags & AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS) != 0) {
    mFetchFlags|=AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
 else {
    mFetchFlags&=~AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
  mRequestTouchExplorationMode=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE) != 0;
  mRequestEnhancedWebAccessibility=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY) != 0;
  mRequestFilterKeyEvents=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_FILTER_KEY_EVENTS) != 0;
}"
2160,"private void migrateOldData(){
  try {
    if (getString(""String_Node_Str"",null,0) == null) {
      final ContentResolver cr=mContext.getContentResolver();
      for (      String validSetting : VALID_SETTINGS) {
        String value=Settings.Secure.getString(cr,validSetting);
        if (value != null) {
          setString(validSetting,value,0);
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final ContentResolver cr=mContext.getContentResolver();
      List<UserInfo> users=um.getUsers();
      for (int user=0; user < users.size(); user++) {
        int userId=users.get(user).getUserHandle().getIdentifier();
        for (        String perUserSetting : MIGRATE_SETTINGS_PER_USER) {
          String value=Settings.Secure.getStringForUser(cr,perUserSetting,userId);
          if (value != null) {
            setString(perUserSetting,value,userId);
            Settings.Secure.putStringForUser(cr,perUserSetting,""String_Node_Str"",userId);
            continue;
          }
          try {
            int ivalue=Settings.Secure.getIntForUser(cr,perUserSetting,userId);
            setLong(perUserSetting,ivalue,userId);
            Settings.Secure.putIntForUser(cr,perUserSetting,0,userId);
          }
 catch (          SettingNotFoundException e) {
          }
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
  }
 catch (  RemoteException re) {
    Slog.e(TAG,""String_Node_Str"",re);
  }
}","private void migrateOldData(){
  try {
    if (getString(""String_Node_Str"",null,0) == null) {
      final ContentResolver cr=mContext.getContentResolver();
      for (      String validSetting : VALID_SETTINGS) {
        String value=Settings.Secure.getString(cr,validSetting);
        if (value != null) {
          setString(validSetting,value,0);
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final ContentResolver cr=mContext.getContentResolver();
      List<UserInfo> users=um.getUsers();
      for (int user=0; user < users.size(); user++) {
        final int userId=users.get(user).id;
        final String OWNER_INFO=Secure.LOCK_SCREEN_OWNER_INFO;
        String ownerInfo=Settings.Secure.getStringForUser(cr,OWNER_INFO,userId);
        if (ownerInfo != null) {
          setString(OWNER_INFO,ownerInfo,userId);
          Settings.Secure.putStringForUser(cr,ownerInfo,""String_Node_Str"",userId);
        }
        final String OWNER_INFO_ENABLED=Secure.LOCK_SCREEN_OWNER_INFO_ENABLED;
        boolean enabled;
        try {
          int ivalue=Settings.Secure.getIntForUser(cr,OWNER_INFO_ENABLED,userId);
          enabled=ivalue != 0;
          setLong(OWNER_INFO_ENABLED,enabled ? 1 : 0,userId);
        }
 catch (        SettingNotFoundException e) {
          if (!TextUtils.isEmpty(ownerInfo)) {
            setLong(OWNER_INFO_ENABLED,1,userId);
          }
        }
        Settings.Secure.putIntForUser(cr,OWNER_INFO_ENABLED,0,userId);
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
  }
 catch (  RemoteException re) {
    Slog.e(TAG,""String_Node_Str"",re);
  }
}"
2161,"/** 
 * Executes a command and waits for a specific accessibility event up to a given wait timeout. To detect a sequence of events one can implement a filter that keeps track of seen events of the expected sequence and returns true after the last event of that sequence is received. <p> <strong>Note:</strong> It is caller's responsibility to recycle the returned event. </p>
 * @param command The command to execute.
 * @param filter Filter that recognizes the expected event.
 * @param timeoutMillis The wait timeout in milliseconds.
 * @throws TimeoutException If the expected event is not received within the timeout.
 */
public AccessibilityEvent executeAndWaitForEvent(Runnable command,AccessibilityEventFilter filter,long timeoutMillis) throws TimeoutException {
synchronized (mLock) {
    throwIfNotConnectedLocked();
    mEventQueue.clear();
    mWaitingForEventDelivery=true;
    final long executionStartTimeMillis=SystemClock.uptimeMillis();
    command.run();
    try {
      final long startTimeMillis=SystemClock.uptimeMillis();
      while (true) {
        while (!mEventQueue.isEmpty()) {
          AccessibilityEvent event=mEventQueue.remove(0);
          if (event.getEventTime() <= executionStartTimeMillis) {
            continue;
          }
          if (filter.accept(event)) {
            return event;
          }
          event.recycle();
        }
        final long elapsedTimeMillis=SystemClock.uptimeMillis() - startTimeMillis;
        final long remainingTimeMillis=timeoutMillis - elapsedTimeMillis;
        if (remainingTimeMillis <= 0) {
          throw new TimeoutException(""String_Node_Str"" + timeoutMillis + ""String_Node_Str"");
        }
        try {
          mLock.wait(remainingTimeMillis);
        }
 catch (        InterruptedException ie) {
        }
      }
    }
  finally {
      mWaitingForEventDelivery=false;
      mEventQueue.clear();
      mLock.notifyAll();
    }
  }
}","/** 
 * Executes a command and waits for a specific accessibility event up to a given wait timeout. To detect a sequence of events one can implement a filter that keeps track of seen events of the expected sequence and returns true after the last event of that sequence is received. <p> <strong>Note:</strong> It is caller's responsibility to recycle the returned event. </p>
 * @param command The command to execute.
 * @param filter Filter that recognizes the expected event.
 * @param timeoutMillis The wait timeout in milliseconds.
 * @throws TimeoutException If the expected event is not received within the timeout.
 */
public AccessibilityEvent executeAndWaitForEvent(Runnable command,AccessibilityEventFilter filter,long timeoutMillis) throws TimeoutException {
synchronized (mLock) {
    throwIfNotConnectedLocked();
    mEventQueue.clear();
    mWaitingForEventDelivery=true;
  }
  final long executionStartTimeMillis=SystemClock.uptimeMillis();
  command.run();
synchronized (mLock) {
    try {
      final long startTimeMillis=SystemClock.uptimeMillis();
      while (true) {
        while (!mEventQueue.isEmpty()) {
          AccessibilityEvent event=mEventQueue.remove(0);
          if (event.getEventTime() < executionStartTimeMillis) {
            continue;
          }
          if (filter.accept(event)) {
            return event;
          }
          event.recycle();
        }
        final long elapsedTimeMillis=SystemClock.uptimeMillis() - startTimeMillis;
        final long remainingTimeMillis=timeoutMillis - elapsedTimeMillis;
        if (remainingTimeMillis <= 0) {
          throw new TimeoutException(""String_Node_Str"" + timeoutMillis + ""String_Node_Str"");
        }
        try {
          mLock.wait(remainingTimeMillis);
        }
 catch (        InterruptedException ie) {
        }
      }
    }
  finally {
      mWaitingForEventDelivery=false;
      mEventQueue.clear();
      mLock.notifyAll();
    }
  }
}"
2162,"private void registerUiTestAutomationServiceLocked(IAccessibilityServiceClient client){
  IAccessibilityManager manager=IAccessibilityManager.Stub.asInterface(ServiceManager.getService(Context.ACCESSIBILITY_SERVICE));
  AccessibilityServiceInfo info=new AccessibilityServiceInfo();
  info.eventTypes=AccessibilityEvent.TYPES_ALL_MASK;
  info.feedbackType=AccessibilityServiceInfo.FEEDBACK_GENERIC;
  info.flags|=AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS | AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS;
  try {
    manager.registerUiTestAutomationService(mToken,client,info);
    mClient=client;
  }
 catch (  RemoteException re) {
    throw new IllegalStateException(""String_Node_Str"",re);
  }
}","private void registerUiTestAutomationServiceLocked(IAccessibilityServiceClient client){
  IAccessibilityManager manager=IAccessibilityManager.Stub.asInterface(ServiceManager.getService(Context.ACCESSIBILITY_SERVICE));
  AccessibilityServiceInfo info=new AccessibilityServiceInfo(true);
  info.eventTypes=AccessibilityEvent.TYPES_ALL_MASK;
  info.feedbackType=AccessibilityServiceInfo.FEEDBACK_GENERIC;
  info.flags|=AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS | AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS;
  try {
    manager.registerUiTestAutomationService(mToken,client,info);
    mClient=client;
  }
 catch (  RemoteException re) {
    throw new IllegalStateException(""String_Node_Str"",re);
  }
}"
2163,"/** 
 * The cache keeps track of   {@link AccessibilityEvent}s and invalidates cached nodes as appropriate.
 * @param event An event.
 */
public void onAccessibilityEvent(AccessibilityEvent event){
  if (ENABLED) {
    final int eventType=event.getEventType();
switch (eventType) {
case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:
{
        mWindowId=event.getWindowId();
        clear();
      }
    break;
case AccessibilityEvent.TYPE_VIEW_HOVER_ENTER:
case AccessibilityEvent.TYPE_VIEW_HOVER_EXIT:
{
    final int windowId=event.getWindowId();
    if (mWindowId != windowId) {
      mWindowId=windowId;
      clear();
    }
  }
break;
case AccessibilityEvent.TYPE_VIEW_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_SELECTED:
case AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED:
{
synchronized (mLock) {
  final long sourceId=event.getSourceNodeId();
  clearSubTreeLocked(sourceId);
  if (eventType == AccessibilityEvent.TYPE_VIEW_FOCUSED) {
    clearSubtreeWithOldInputFocusLocked(sourceId);
  }
  if (eventType == AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED) {
    clearSubtreeWithOldAccessibilityFocusLocked(sourceId);
  }
}
}
break;
case AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_SCROLLED:
{
synchronized (mLock) {
final long accessibilityNodeId=event.getSourceNodeId();
clearSubTreeLocked(accessibilityNodeId);
}
}
break;
}
if (Build.IS_DEBUGGABLE && CHECK_INTEGRITY) {
checkIntegrity();
}
}
}","/** 
 * The cache keeps track of   {@link AccessibilityEvent}s and invalidates cached nodes as appropriate.
 * @param event An event.
 */
public void onAccessibilityEvent(AccessibilityEvent event){
  if (ENABLED) {
    final int eventType=event.getEventType();
switch (eventType) {
case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:
{
        mWindowId=event.getWindowId();
        clear();
      }
    break;
case AccessibilityEvent.TYPE_VIEW_HOVER_ENTER:
case AccessibilityEvent.TYPE_VIEW_HOVER_EXIT:
{
    final int windowId=event.getWindowId();
    if (mWindowId != windowId) {
      mWindowId=windowId;
      clear();
    }
  }
break;
case AccessibilityEvent.TYPE_VIEW_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
case AccessibilityEvent.TYPE_VIEW_SELECTED:
case AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED:
{
synchronized (mLock) {
  final long sourceId=event.getSourceNodeId();
  clearSubTreeLocked(sourceId);
  if (eventType == AccessibilityEvent.TYPE_VIEW_FOCUSED) {
    clearSubtreeWithOldInputFocusLocked(sourceId);
  }
  if (eventType == AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED) {
    clearSubtreeWithOldAccessibilityFocusLocked(sourceId);
  }
}
}
break;
case AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_SCROLLED:
{
synchronized (mLock) {
final long accessibilityNodeId=event.getSourceNodeId();
clearSubTreeLocked(accessibilityNodeId);
}
}
break;
}
if (Build.IS_DEBUGGABLE && CHECK_INTEGRITY) {
checkIntegrity();
}
}
}"
2164,"@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  info.setClassName(TextView.class.getName());
  final boolean isPassword=hasPasswordTransformationMethod();
  info.setPassword(isPassword);
  if (!isPassword) {
    info.setText(getTextForAccessibility());
  }
  if (mBufferType == BufferType.EDITABLE) {
    info.setEditable(true);
  }
  if (TextUtils.isEmpty(getContentDescription()) && !TextUtils.isEmpty(mText)) {
    info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
    info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
    info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PAGE);
  }
  if (isFocused()) {
    if (canSelectText()) {
      info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
    }
    if (canCopy()) {
      info.addAction(AccessibilityNodeInfo.ACTION_COPY);
    }
    if (canPaste()) {
      info.addAction(AccessibilityNodeInfo.ACTION_PASTE);
    }
    if (canCut()) {
      info.addAction(AccessibilityNodeInfo.ACTION_CUT);
    }
  }
}","@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  info.setClassName(TextView.class.getName());
  final boolean isPassword=hasPasswordTransformationMethod();
  info.setPassword(isPassword);
  if (!isPassword) {
    info.setText(getTextForAccessibility());
  }
  if (mBufferType == BufferType.EDITABLE) {
    info.setEditable(true);
  }
  if (!TextUtils.isEmpty(mText)) {
    info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
    info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
    info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PAGE);
  }
  if (isFocused()) {
    if (canSelectText()) {
      info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
    }
    if (canCopy()) {
      info.addAction(AccessibilityNodeInfo.ACTION_COPY);
    }
    if (canPaste()) {
      info.addAction(AccessibilityNodeInfo.ACTION_PASTE);
    }
    if (canCut()) {
      info.addAction(AccessibilityNodeInfo.ACTION_CUT);
    }
  }
}"
2165,"/** 
 * @hide
 */
@Override public int getAccessibilitySelectionStart(){
  if (TextUtils.isEmpty(getContentDescription())) {
    final int selectionStart=getSelectionStart();
    if (selectionStart >= 0) {
      return selectionStart;
    }
  }
  return ACCESSIBILITY_CURSOR_POSITION_UNDEFINED;
}","/** 
 * @hide
 */
@Override public int getAccessibilitySelectionStart(){
  return getSelectionStart();
}"
2166,"/** 
 * @hide
 */
@Override public CharSequence getIterableTextForAccessibility(){
  if (!TextUtils.isEmpty(mText)) {
    if (!(mText instanceof Spannable)) {
      setText(mText,BufferType.SPANNABLE);
    }
    return mText;
  }
  return super.getIterableTextForAccessibility();
}","/** 
 * @hide
 */
@Override public CharSequence getIterableTextForAccessibility(){
  if (!(mText instanceof Spannable)) {
    setText(mText,BufferType.SPANNABLE);
  }
  return mText;
}"
2167,"/** 
 * @hide
 */
@Override public int getAccessibilitySelectionEnd(){
  if (TextUtils.isEmpty(getContentDescription())) {
    final int selectionEnd=getSelectionEnd();
    if (selectionEnd >= 0) {
      return selectionEnd;
    }
  }
  return ACCESSIBILITY_CURSOR_POSITION_UNDEFINED;
}","/** 
 * @hide
 */
@Override public int getAccessibilitySelectionEnd(){
  return getSelectionEnd();
}"
2168,"public void setDynamicallyConfigurableProperties(AccessibilityServiceInfo info){
  mEventTypes=info.eventTypes;
  mFeedbackType=info.feedbackType;
  String[] packageNames=info.packageNames;
  if (packageNames != null) {
    mPackageNames.addAll(Arrays.asList(packageNames));
  }
  mNotificationTimeout=info.notificationTimeout;
  mIsDefault=(info.flags & DEFAULT) != 0;
  if (mIsAutomation || info.getResolveInfo().serviceInfo.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
    if ((info.flags & AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS) != 0) {
      mFetchFlags|=AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
 else {
      mFetchFlags&=~AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
  }
  if ((info.flags & AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS) != 0) {
    mFetchFlags|=AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
 else {
    mFetchFlags&=~AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
  if (mResolveInfo != null) {
    mRequestTouchExplorationMode=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE) != 0;
    mRequestEnhancedWebAccessibility=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY) != 0;
    mRequestFilterKeyEvents=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_FILTER_KEY_EVENTS) != 0;
  }
}","public void setDynamicallyConfigurableProperties(AccessibilityServiceInfo info){
  mEventTypes=info.eventTypes;
  mFeedbackType=info.feedbackType;
  String[] packageNames=info.packageNames;
  if (packageNames != null) {
    mPackageNames.addAll(Arrays.asList(packageNames));
  }
  mNotificationTimeout=info.notificationTimeout;
  mIsDefault=(info.flags & DEFAULT) != 0;
  if (mIsAutomation || info.getResolveInfo().serviceInfo.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
    if ((info.flags & AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS) != 0) {
      mFetchFlags|=AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
 else {
      mFetchFlags&=~AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
  }
  if ((info.flags & AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS) != 0) {
    mFetchFlags|=AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
 else {
    mFetchFlags&=~AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
  mRequestTouchExplorationMode=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE) != 0;
  mRequestEnhancedWebAccessibility=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY) != 0;
  mRequestFilterKeyEvents=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_FILTER_KEY_EVENTS) != 0;
}"
2169,"private void migrateOldData(){
  try {
    if (getString(""String_Node_Str"",null,0) == null) {
      final ContentResolver cr=mContext.getContentResolver();
      for (      String validSetting : VALID_SETTINGS) {
        String value=Settings.Secure.getString(cr,validSetting);
        if (value != null) {
          setString(validSetting,value,0);
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final ContentResolver cr=mContext.getContentResolver();
      List<UserInfo> users=um.getUsers();
      for (int user=0; user < users.size(); user++) {
        int userId=users.get(user).getUserHandle().getIdentifier();
        for (        String perUserSetting : MIGRATE_SETTINGS_PER_USER) {
          String value=Settings.Secure.getStringForUser(cr,perUserSetting,userId);
          if (value != null) {
            setString(perUserSetting,value,userId);
            Settings.Secure.putStringForUser(cr,perUserSetting,""String_Node_Str"",userId);
            continue;
          }
          try {
            int ivalue=Settings.Secure.getIntForUser(cr,perUserSetting,userId);
            setLong(perUserSetting,ivalue,userId);
            Settings.Secure.putIntForUser(cr,perUserSetting,0,userId);
          }
 catch (          SettingNotFoundException e) {
          }
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
  }
 catch (  RemoteException re) {
    Slog.e(TAG,""String_Node_Str"",re);
  }
}","private void migrateOldData(){
  try {
    if (getString(""String_Node_Str"",null,0) == null) {
      final ContentResolver cr=mContext.getContentResolver();
      for (      String validSetting : VALID_SETTINGS) {
        String value=Settings.Secure.getString(cr,validSetting);
        if (value != null) {
          setString(validSetting,value,0);
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final ContentResolver cr=mContext.getContentResolver();
      List<UserInfo> users=um.getUsers();
      for (int user=0; user < users.size(); user++) {
        final int userId=users.get(user).id;
        final String OWNER_INFO=Secure.LOCK_SCREEN_OWNER_INFO;
        String ownerInfo=Settings.Secure.getStringForUser(cr,OWNER_INFO,userId);
        if (ownerInfo != null) {
          setString(OWNER_INFO,ownerInfo,userId);
          Settings.Secure.putStringForUser(cr,ownerInfo,""String_Node_Str"",userId);
        }
        final String OWNER_INFO_ENABLED=Secure.LOCK_SCREEN_OWNER_INFO_ENABLED;
        boolean enabled;
        try {
          int ivalue=Settings.Secure.getIntForUser(cr,OWNER_INFO_ENABLED,userId);
          enabled=ivalue != 0;
          setLong(OWNER_INFO_ENABLED,enabled ? 1 : 0,userId);
        }
 catch (        SettingNotFoundException e) {
          if (!TextUtils.isEmpty(ownerInfo)) {
            setLong(OWNER_INFO_ENABLED,1,userId);
          }
        }
        Settings.Secure.putIntForUser(cr,OWNER_INFO_ENABLED,0,userId);
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
  }
 catch (  RemoteException re) {
    Slog.e(TAG,""String_Node_Str"",re);
  }
}"
2170,"/** 
 * Executes a command and waits for a specific accessibility event up to a given wait timeout. To detect a sequence of events one can implement a filter that keeps track of seen events of the expected sequence and returns true after the last event of that sequence is received. <p> <strong>Note:</strong> It is caller's responsibility to recycle the returned event. </p>
 * @param command The command to execute.
 * @param filter Filter that recognizes the expected event.
 * @param timeoutMillis The wait timeout in milliseconds.
 * @throws TimeoutException If the expected event is not received within the timeout.
 */
public AccessibilityEvent executeAndWaitForEvent(Runnable command,AccessibilityEventFilter filter,long timeoutMillis) throws TimeoutException {
synchronized (mLock) {
    throwIfNotConnectedLocked();
    mEventQueue.clear();
    mWaitingForEventDelivery=true;
    final long executionStartTimeMillis=SystemClock.uptimeMillis();
    command.run();
    try {
      final long startTimeMillis=SystemClock.uptimeMillis();
      while (true) {
        while (!mEventQueue.isEmpty()) {
          AccessibilityEvent event=mEventQueue.remove(0);
          if (event.getEventTime() <= executionStartTimeMillis) {
            continue;
          }
          if (filter.accept(event)) {
            return event;
          }
          event.recycle();
        }
        final long elapsedTimeMillis=SystemClock.uptimeMillis() - startTimeMillis;
        final long remainingTimeMillis=timeoutMillis - elapsedTimeMillis;
        if (remainingTimeMillis <= 0) {
          throw new TimeoutException(""String_Node_Str"" + timeoutMillis + ""String_Node_Str"");
        }
        try {
          mLock.wait(remainingTimeMillis);
        }
 catch (        InterruptedException ie) {
        }
      }
    }
  finally {
      mWaitingForEventDelivery=false;
      mEventQueue.clear();
      mLock.notifyAll();
    }
  }
}","/** 
 * Executes a command and waits for a specific accessibility event up to a given wait timeout. To detect a sequence of events one can implement a filter that keeps track of seen events of the expected sequence and returns true after the last event of that sequence is received. <p> <strong>Note:</strong> It is caller's responsibility to recycle the returned event. </p>
 * @param command The command to execute.
 * @param filter Filter that recognizes the expected event.
 * @param timeoutMillis The wait timeout in milliseconds.
 * @throws TimeoutException If the expected event is not received within the timeout.
 */
public AccessibilityEvent executeAndWaitForEvent(Runnable command,AccessibilityEventFilter filter,long timeoutMillis) throws TimeoutException {
synchronized (mLock) {
    throwIfNotConnectedLocked();
    mEventQueue.clear();
    mWaitingForEventDelivery=true;
  }
  final long executionStartTimeMillis=SystemClock.uptimeMillis();
  command.run();
synchronized (mLock) {
    try {
      final long startTimeMillis=SystemClock.uptimeMillis();
      while (true) {
        while (!mEventQueue.isEmpty()) {
          AccessibilityEvent event=mEventQueue.remove(0);
          if (event.getEventTime() < executionStartTimeMillis) {
            continue;
          }
          if (filter.accept(event)) {
            return event;
          }
          event.recycle();
        }
        final long elapsedTimeMillis=SystemClock.uptimeMillis() - startTimeMillis;
        final long remainingTimeMillis=timeoutMillis - elapsedTimeMillis;
        if (remainingTimeMillis <= 0) {
          throw new TimeoutException(""String_Node_Str"" + timeoutMillis + ""String_Node_Str"");
        }
        try {
          mLock.wait(remainingTimeMillis);
        }
 catch (        InterruptedException ie) {
        }
      }
    }
  finally {
      mWaitingForEventDelivery=false;
      mEventQueue.clear();
      mLock.notifyAll();
    }
  }
}"
2171,"private void registerUiTestAutomationServiceLocked(IAccessibilityServiceClient client){
  IAccessibilityManager manager=IAccessibilityManager.Stub.asInterface(ServiceManager.getService(Context.ACCESSIBILITY_SERVICE));
  AccessibilityServiceInfo info=new AccessibilityServiceInfo();
  info.eventTypes=AccessibilityEvent.TYPES_ALL_MASK;
  info.feedbackType=AccessibilityServiceInfo.FEEDBACK_GENERIC;
  info.flags|=AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS | AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS;
  try {
    manager.registerUiTestAutomationService(mToken,client,info);
    mClient=client;
  }
 catch (  RemoteException re) {
    throw new IllegalStateException(""String_Node_Str"",re);
  }
}","private void registerUiTestAutomationServiceLocked(IAccessibilityServiceClient client){
  IAccessibilityManager manager=IAccessibilityManager.Stub.asInterface(ServiceManager.getService(Context.ACCESSIBILITY_SERVICE));
  AccessibilityServiceInfo info=new AccessibilityServiceInfo(true);
  info.eventTypes=AccessibilityEvent.TYPES_ALL_MASK;
  info.feedbackType=AccessibilityServiceInfo.FEEDBACK_GENERIC;
  info.flags|=AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS | AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS;
  try {
    manager.registerUiTestAutomationService(mToken,client,info);
    mClient=client;
  }
 catch (  RemoteException re) {
    throw new IllegalStateException(""String_Node_Str"",re);
  }
}"
2172,"/** 
 * The cache keeps track of   {@link AccessibilityEvent}s and invalidates cached nodes as appropriate.
 * @param event An event.
 */
public void onAccessibilityEvent(AccessibilityEvent event){
  if (ENABLED) {
    final int eventType=event.getEventType();
switch (eventType) {
case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:
{
        mWindowId=event.getWindowId();
        clear();
      }
    break;
case AccessibilityEvent.TYPE_VIEW_HOVER_ENTER:
case AccessibilityEvent.TYPE_VIEW_HOVER_EXIT:
{
    final int windowId=event.getWindowId();
    if (mWindowId != windowId) {
      mWindowId=windowId;
      clear();
    }
  }
break;
case AccessibilityEvent.TYPE_VIEW_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_SELECTED:
case AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED:
{
synchronized (mLock) {
  final long sourceId=event.getSourceNodeId();
  clearSubTreeLocked(sourceId);
  if (eventType == AccessibilityEvent.TYPE_VIEW_FOCUSED) {
    clearSubtreeWithOldInputFocusLocked(sourceId);
  }
  if (eventType == AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED) {
    clearSubtreeWithOldAccessibilityFocusLocked(sourceId);
  }
}
}
break;
case AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_SCROLLED:
{
synchronized (mLock) {
final long accessibilityNodeId=event.getSourceNodeId();
clearSubTreeLocked(accessibilityNodeId);
}
}
break;
}
if (Build.IS_DEBUGGABLE && CHECK_INTEGRITY) {
checkIntegrity();
}
}
}","/** 
 * The cache keeps track of   {@link AccessibilityEvent}s and invalidates cached nodes as appropriate.
 * @param event An event.
 */
public void onAccessibilityEvent(AccessibilityEvent event){
  if (ENABLED) {
    final int eventType=event.getEventType();
switch (eventType) {
case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:
{
        mWindowId=event.getWindowId();
        clear();
      }
    break;
case AccessibilityEvent.TYPE_VIEW_HOVER_ENTER:
case AccessibilityEvent.TYPE_VIEW_HOVER_EXIT:
{
    final int windowId=event.getWindowId();
    if (mWindowId != windowId) {
      mWindowId=windowId;
      clear();
    }
  }
break;
case AccessibilityEvent.TYPE_VIEW_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED:
case AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
case AccessibilityEvent.TYPE_VIEW_SELECTED:
case AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED:
{
synchronized (mLock) {
  final long sourceId=event.getSourceNodeId();
  clearSubTreeLocked(sourceId);
  if (eventType == AccessibilityEvent.TYPE_VIEW_FOCUSED) {
    clearSubtreeWithOldInputFocusLocked(sourceId);
  }
  if (eventType == AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED) {
    clearSubtreeWithOldAccessibilityFocusLocked(sourceId);
  }
}
}
break;
case AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED:
case AccessibilityEvent.TYPE_VIEW_SCROLLED:
{
synchronized (mLock) {
final long accessibilityNodeId=event.getSourceNodeId();
clearSubTreeLocked(accessibilityNodeId);
}
}
break;
}
if (Build.IS_DEBUGGABLE && CHECK_INTEGRITY) {
checkIntegrity();
}
}
}"
2173,"@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  info.setClassName(TextView.class.getName());
  final boolean isPassword=hasPasswordTransformationMethod();
  info.setPassword(isPassword);
  if (!isPassword) {
    info.setText(getTextForAccessibility());
  }
  if (mBufferType == BufferType.EDITABLE) {
    info.setEditable(true);
  }
  if (TextUtils.isEmpty(getContentDescription()) && !TextUtils.isEmpty(mText)) {
    info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
    info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
    info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PAGE);
  }
  if (isFocused()) {
    if (canSelectText()) {
      info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
    }
    if (canCopy()) {
      info.addAction(AccessibilityNodeInfo.ACTION_COPY);
    }
    if (canPaste()) {
      info.addAction(AccessibilityNodeInfo.ACTION_PASTE);
    }
    if (canCut()) {
      info.addAction(AccessibilityNodeInfo.ACTION_CUT);
    }
  }
}","@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  info.setClassName(TextView.class.getName());
  final boolean isPassword=hasPasswordTransformationMethod();
  info.setPassword(isPassword);
  if (!isPassword) {
    info.setText(getTextForAccessibility());
  }
  if (mBufferType == BufferType.EDITABLE) {
    info.setEditable(true);
  }
  if (!TextUtils.isEmpty(mText)) {
    info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
    info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
    info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH| AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PAGE);
  }
  if (isFocused()) {
    if (canSelectText()) {
      info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
    }
    if (canCopy()) {
      info.addAction(AccessibilityNodeInfo.ACTION_COPY);
    }
    if (canPaste()) {
      info.addAction(AccessibilityNodeInfo.ACTION_PASTE);
    }
    if (canCut()) {
      info.addAction(AccessibilityNodeInfo.ACTION_CUT);
    }
  }
}"
2174,"/** 
 * @hide
 */
@Override public int getAccessibilitySelectionStart(){
  if (TextUtils.isEmpty(getContentDescription())) {
    final int selectionStart=getSelectionStart();
    if (selectionStart >= 0) {
      return selectionStart;
    }
  }
  return ACCESSIBILITY_CURSOR_POSITION_UNDEFINED;
}","/** 
 * @hide
 */
@Override public int getAccessibilitySelectionStart(){
  return getSelectionStart();
}"
2175,"/** 
 * @hide
 */
@Override public CharSequence getIterableTextForAccessibility(){
  if (!TextUtils.isEmpty(mText)) {
    if (!(mText instanceof Spannable)) {
      setText(mText,BufferType.SPANNABLE);
    }
    return mText;
  }
  return super.getIterableTextForAccessibility();
}","/** 
 * @hide
 */
@Override public CharSequence getIterableTextForAccessibility(){
  if (!(mText instanceof Spannable)) {
    setText(mText,BufferType.SPANNABLE);
  }
  return mText;
}"
2176,"/** 
 * @hide
 */
@Override public int getAccessibilitySelectionEnd(){
  if (TextUtils.isEmpty(getContentDescription())) {
    final int selectionEnd=getSelectionEnd();
    if (selectionEnd >= 0) {
      return selectionEnd;
    }
  }
  return ACCESSIBILITY_CURSOR_POSITION_UNDEFINED;
}","/** 
 * @hide
 */
@Override public int getAccessibilitySelectionEnd(){
  return getSelectionEnd();
}"
2177,"public void setDynamicallyConfigurableProperties(AccessibilityServiceInfo info){
  mEventTypes=info.eventTypes;
  mFeedbackType=info.feedbackType;
  String[] packageNames=info.packageNames;
  if (packageNames != null) {
    mPackageNames.addAll(Arrays.asList(packageNames));
  }
  mNotificationTimeout=info.notificationTimeout;
  mIsDefault=(info.flags & DEFAULT) != 0;
  if (mIsAutomation || info.getResolveInfo().serviceInfo.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
    if ((info.flags & AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS) != 0) {
      mFetchFlags|=AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
 else {
      mFetchFlags&=~AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
  }
  if ((info.flags & AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS) != 0) {
    mFetchFlags|=AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
 else {
    mFetchFlags&=~AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
  if (mResolveInfo != null) {
    mRequestTouchExplorationMode=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE) != 0;
    mRequestEnhancedWebAccessibility=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY) != 0;
    mRequestFilterKeyEvents=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_FILTER_KEY_EVENTS) != 0;
  }
}","public void setDynamicallyConfigurableProperties(AccessibilityServiceInfo info){
  mEventTypes=info.eventTypes;
  mFeedbackType=info.feedbackType;
  String[] packageNames=info.packageNames;
  if (packageNames != null) {
    mPackageNames.addAll(Arrays.asList(packageNames));
  }
  mNotificationTimeout=info.notificationTimeout;
  mIsDefault=(info.flags & DEFAULT) != 0;
  if (mIsAutomation || info.getResolveInfo().serviceInfo.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
    if ((info.flags & AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS) != 0) {
      mFetchFlags|=AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
 else {
      mFetchFlags&=~AccessibilityNodeInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;
    }
  }
  if ((info.flags & AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS) != 0) {
    mFetchFlags|=AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
 else {
    mFetchFlags&=~AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS;
  }
  mRequestTouchExplorationMode=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE) != 0;
  mRequestEnhancedWebAccessibility=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY) != 0;
  mRequestFilterKeyEvents=(info.flags & AccessibilityServiceInfo.FLAG_REQUEST_FILTER_KEY_EVENTS) != 0;
}"
2178,"private void migrateOldData(){
  try {
    if (getString(""String_Node_Str"",null,0) == null) {
      final ContentResolver cr=mContext.getContentResolver();
      for (      String validSetting : VALID_SETTINGS) {
        String value=Settings.Secure.getString(cr,validSetting);
        if (value != null) {
          setString(validSetting,value,0);
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final ContentResolver cr=mContext.getContentResolver();
      List<UserInfo> users=um.getUsers();
      for (int user=0; user < users.size(); user++) {
        int userId=users.get(user).getUserHandle().getIdentifier();
        for (        String perUserSetting : MIGRATE_SETTINGS_PER_USER) {
          String value=Settings.Secure.getStringForUser(cr,perUserSetting,userId);
          if (value != null) {
            setString(perUserSetting,value,userId);
            Settings.Secure.putStringForUser(cr,perUserSetting,""String_Node_Str"",userId);
            continue;
          }
          try {
            int ivalue=Settings.Secure.getIntForUser(cr,perUserSetting,userId);
            setLong(perUserSetting,ivalue,userId);
            Settings.Secure.putIntForUser(cr,perUserSetting,0,userId);
          }
 catch (          SettingNotFoundException e) {
          }
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
  }
 catch (  RemoteException re) {
    Slog.e(TAG,""String_Node_Str"",re);
  }
}","private void migrateOldData(){
  try {
    if (getString(""String_Node_Str"",null,0) == null) {
      final ContentResolver cr=mContext.getContentResolver();
      for (      String validSetting : VALID_SETTINGS) {
        String value=Settings.Secure.getString(cr,validSetting);
        if (value != null) {
          setString(validSetting,value,0);
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final ContentResolver cr=mContext.getContentResolver();
      List<UserInfo> users=um.getUsers();
      for (int user=0; user < users.size(); user++) {
        final int userId=users.get(user).id;
        final String OWNER_INFO=Secure.LOCK_SCREEN_OWNER_INFO;
        String ownerInfo=Settings.Secure.getStringForUser(cr,OWNER_INFO,userId);
        if (ownerInfo != null) {
          setString(OWNER_INFO,ownerInfo,userId);
          Settings.Secure.putStringForUser(cr,ownerInfo,""String_Node_Str"",userId);
        }
        final String OWNER_INFO_ENABLED=Secure.LOCK_SCREEN_OWNER_INFO_ENABLED;
        boolean enabled;
        try {
          int ivalue=Settings.Secure.getIntForUser(cr,OWNER_INFO_ENABLED,userId);
          enabled=ivalue != 0;
          setLong(OWNER_INFO_ENABLED,enabled ? 1 : 0,userId);
        }
 catch (        SettingNotFoundException e) {
          if (!TextUtils.isEmpty(ownerInfo)) {
            setLong(OWNER_INFO_ENABLED,1,userId);
          }
        }
        Settings.Secure.putIntForUser(cr,OWNER_INFO_ENABLED,0,userId);
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
  }
 catch (  RemoteException re) {
    Slog.e(TAG,""String_Node_Str"",re);
  }
}"
2179,"/** 
 * Apply this Builder to an existing   {@link Notification} object.
 * @hide
 */
public Notification buildInto(Notification n){
  build().cloneInto(n);
  return n;
}","/** 
 * Apply this Builder to an existing   {@link Notification} object.
 * @hide
 */
public Notification buildInto(Notification n){
  build().cloneInto(n,true);
  return n;
}"
2180,"private void cloneInto(Notification that){
  that.when=this.when;
  that.icon=this.icon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (this.largeIcon != null) {
    that.largeIcon=Bitmap.createBitmap(this.largeIcon);
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  final String[] thiskind=this.kind;
  if (thiskind != null) {
    final int N=thiskind.length;
    final String[] thatkind=that.kind=new String[N];
    System.arraycopy(thiskind,0,thatkind,0,N);
  }
  if (this.extras != null) {
    that.extras=new Bundle(this.extras);
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
}","/** 
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members of this into that.
 * @hide
 */
public void cloneInto(Notification that,boolean heavy){
  that.when=this.when;
  that.icon=this.icon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (heavy && this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (heavy && this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (heavy && this.largeIcon != null) {
    that.largeIcon=Bitmap.createBitmap(this.largeIcon);
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  final String[] thiskind=this.kind;
  if (thiskind != null) {
    final int N=thiskind.length;
    final String[] thatkind=that.kind=new String[N];
    System.arraycopy(thiskind,0,thatkind,0,N);
  }
  if (this.extras != null) {
    that.extras=new Bundle(this.extras);
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (heavy && this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
  if (!heavy) {
    that.lightenPayload();
  }
}"
2181,"@Override public Notification clone(){
  Notification that=new Notification();
  cloneInto(that);
  return that;
}","@Override public Notification clone(){
  Notification that=new Notification();
  cloneInto(that,true);
  return that;
}"
2182,"@Override public void run(){
  info.notifyRemovedIfUserMatch(sbn);
}","@Override public void run(){
  info.notifyRemovedIfUserMatch(sbn_light);
}"
2183,"public void record(StatusBarNotification nr){
  nr.notification.tickerView=null;
  nr.notification.contentView=null;
  nr.notification.bigContentView=null;
  nr.notification.largeIcon=null;
  final Bundle extras=nr.notification.extras;
  extras.remove(Notification.EXTRA_LARGE_ICON);
  extras.remove(Notification.EXTRA_LARGE_ICON_BIG);
  extras.remove(Notification.EXTRA_PICTURE);
  if (mBuffer.size() == BUFFER_SIZE) {
    mBuffer.removeFirst();
  }
  mBuffer.addLast(nr);
}","public void record(StatusBarNotification nr){
  nr.notification.lightenPayload();
  if (mBuffer.size() == BUFFER_SIZE) {
    mBuffer.removeFirst();
  }
  mBuffer.addLast(nr);
}"
2184,"public void notifyRemovedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn))   return;
  try {
    listener.onNotificationRemoved(sbn);
  }
 catch (  RemoteException ex) {
  }
}","public void notifyRemovedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn))   return;
  try {
    listener.onNotificationRemoved(sbn);
  }
 catch (  RemoteException ex) {
    Log.e(TAG,""String_Node_Str"" + listener,ex);
  }
}"
2185,"/** 
 * asynchronously notify all listeners about a new notification
 */
private void notifyPostedLocked(NotificationRecord n){
  final StatusBarNotification sbn=n.sbn;
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyPostedIfUserMatch(sbn);
      }
    }
);
  }
}","/** 
 * asynchronously notify all listeners about a new notification
 */
private void notifyPostedLocked(NotificationRecord n){
  final StatusBarNotification sbn=n.sbn.clone();
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyPostedIfUserMatch(sbn);
      }
    }
);
  }
}"
2186,"/** 
 * asynchronously notify all listeners about a removed notification
 */
private void notifyRemovedLocked(NotificationRecord n){
  final StatusBarNotification sbn=n.sbn;
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyRemovedIfUserMatch(sbn);
      }
    }
);
  }
}","/** 
 * asynchronously notify all listeners about a removed notification
 */
private void notifyRemovedLocked(NotificationRecord n){
  final StatusBarNotification sbn_light=n.sbn.cloneLight();
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyRemovedIfUserMatch(sbn_light);
      }
    }
);
  }
}"
2187,"public void notifyPostedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn)) {
    return;
  }
  try {
    listener.onNotificationPosted(sbn);
  }
 catch (  RemoteException ex) {
  }
}","public void notifyPostedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn)) {
    return;
  }
  try {
    listener.onNotificationPosted(sbn);
  }
 catch (  RemoteException ex) {
    Log.e(TAG,""String_Node_Str"" + listener,ex);
  }
}"
2188,"/** 
 * Apply this Builder to an existing   {@link Notification} object.
 * @hide
 */
public Notification buildInto(Notification n){
  build().cloneInto(n);
  return n;
}","/** 
 * Apply this Builder to an existing   {@link Notification} object.
 * @hide
 */
public Notification buildInto(Notification n){
  build().cloneInto(n,true);
  return n;
}"
2189,"private void cloneInto(Notification that){
  that.when=this.when;
  that.icon=this.icon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (this.largeIcon != null) {
    that.largeIcon=Bitmap.createBitmap(this.largeIcon);
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  final String[] thiskind=this.kind;
  if (thiskind != null) {
    final int N=thiskind.length;
    final String[] thatkind=that.kind=new String[N];
    System.arraycopy(thiskind,0,thatkind,0,N);
  }
  if (this.extras != null) {
    that.extras=new Bundle(this.extras);
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
}","/** 
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members of this into that.
 * @hide
 */
public void cloneInto(Notification that,boolean heavy){
  that.when=this.when;
  that.icon=this.icon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (heavy && this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (heavy && this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (heavy && this.largeIcon != null) {
    that.largeIcon=Bitmap.createBitmap(this.largeIcon);
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  final String[] thiskind=this.kind;
  if (thiskind != null) {
    final int N=thiskind.length;
    final String[] thatkind=that.kind=new String[N];
    System.arraycopy(thiskind,0,thatkind,0,N);
  }
  if (this.extras != null) {
    that.extras=new Bundle(this.extras);
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (heavy && this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
  if (!heavy) {
    that.lightenPayload();
  }
}"
2190,"@Override public Notification clone(){
  Notification that=new Notification();
  cloneInto(that);
  return that;
}","@Override public Notification clone(){
  Notification that=new Notification();
  cloneInto(that,true);
  return that;
}"
2191,"@Override public void run(){
  info.notifyRemovedIfUserMatch(sbn);
}","@Override public void run(){
  info.notifyRemovedIfUserMatch(sbn_light);
}"
2192,"public void record(StatusBarNotification nr){
  nr.notification.tickerView=null;
  nr.notification.contentView=null;
  nr.notification.bigContentView=null;
  nr.notification.largeIcon=null;
  final Bundle extras=nr.notification.extras;
  extras.remove(Notification.EXTRA_LARGE_ICON);
  extras.remove(Notification.EXTRA_LARGE_ICON_BIG);
  extras.remove(Notification.EXTRA_PICTURE);
  if (mBuffer.size() == BUFFER_SIZE) {
    mBuffer.removeFirst();
  }
  mBuffer.addLast(nr);
}","public void record(StatusBarNotification nr){
  nr.notification.lightenPayload();
  if (mBuffer.size() == BUFFER_SIZE) {
    mBuffer.removeFirst();
  }
  mBuffer.addLast(nr);
}"
2193,"public void notifyRemovedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn))   return;
  try {
    listener.onNotificationRemoved(sbn);
  }
 catch (  RemoteException ex) {
  }
}","public void notifyRemovedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn))   return;
  try {
    listener.onNotificationRemoved(sbn);
  }
 catch (  RemoteException ex) {
    Log.e(TAG,""String_Node_Str"" + listener,ex);
  }
}"
2194,"/** 
 * asynchronously notify all listeners about a new notification
 */
private void notifyPostedLocked(NotificationRecord n){
  final StatusBarNotification sbn=n.sbn;
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyPostedIfUserMatch(sbn);
      }
    }
);
  }
}","/** 
 * asynchronously notify all listeners about a new notification
 */
private void notifyPostedLocked(NotificationRecord n){
  final StatusBarNotification sbn=n.sbn.clone();
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyPostedIfUserMatch(sbn);
      }
    }
);
  }
}"
2195,"/** 
 * asynchronously notify all listeners about a removed notification
 */
private void notifyRemovedLocked(NotificationRecord n){
  final StatusBarNotification sbn=n.sbn;
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyRemovedIfUserMatch(sbn);
      }
    }
);
  }
}","/** 
 * asynchronously notify all listeners about a removed notification
 */
private void notifyRemovedLocked(NotificationRecord n){
  final StatusBarNotification sbn_light=n.sbn.cloneLight();
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyRemovedIfUserMatch(sbn_light);
      }
    }
);
  }
}"
2196,"public void notifyPostedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn)) {
    return;
  }
  try {
    listener.onNotificationPosted(sbn);
  }
 catch (  RemoteException ex) {
  }
}","public void notifyPostedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn)) {
    return;
  }
  try {
    listener.onNotificationPosted(sbn);
  }
 catch (  RemoteException ex) {
    Log.e(TAG,""String_Node_Str"" + listener,ex);
  }
}"
2197,"/** 
 * Apply this Builder to an existing   {@link Notification} object.
 * @hide
 */
public Notification buildInto(Notification n){
  build().cloneInto(n);
  return n;
}","/** 
 * Apply this Builder to an existing   {@link Notification} object.
 * @hide
 */
public Notification buildInto(Notification n){
  build().cloneInto(n,true);
  return n;
}"
2198,"private void cloneInto(Notification that){
  that.when=this.when;
  that.icon=this.icon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (this.largeIcon != null) {
    that.largeIcon=Bitmap.createBitmap(this.largeIcon);
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  final String[] thiskind=this.kind;
  if (thiskind != null) {
    final int N=thiskind.length;
    final String[] thatkind=that.kind=new String[N];
    System.arraycopy(thiskind,0,thatkind,0,N);
  }
  if (this.extras != null) {
    that.extras=new Bundle(this.extras);
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
}","/** 
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members of this into that.
 * @hide
 */
public void cloneInto(Notification that,boolean heavy){
  that.when=this.when;
  that.icon=this.icon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (heavy && this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (heavy && this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (heavy && this.largeIcon != null) {
    that.largeIcon=Bitmap.createBitmap(this.largeIcon);
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  final String[] thiskind=this.kind;
  if (thiskind != null) {
    final int N=thiskind.length;
    final String[] thatkind=that.kind=new String[N];
    System.arraycopy(thiskind,0,thatkind,0,N);
  }
  if (this.extras != null) {
    that.extras=new Bundle(this.extras);
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (heavy && this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
  if (!heavy) {
    that.lightenPayload();
  }
}"
2199,"@Override public Notification clone(){
  Notification that=new Notification();
  cloneInto(that);
  return that;
}","@Override public Notification clone(){
  Notification that=new Notification();
  cloneInto(that,true);
  return that;
}"
2200,"@Override public void run(){
  info.notifyRemovedIfUserMatch(sbn);
}","@Override public void run(){
  info.notifyRemovedIfUserMatch(sbn_light);
}"
2201,"public void record(StatusBarNotification nr){
  nr.notification.tickerView=null;
  nr.notification.contentView=null;
  nr.notification.bigContentView=null;
  nr.notification.largeIcon=null;
  final Bundle extras=nr.notification.extras;
  extras.remove(Notification.EXTRA_LARGE_ICON);
  extras.remove(Notification.EXTRA_LARGE_ICON_BIG);
  extras.remove(Notification.EXTRA_PICTURE);
  if (mBuffer.size() == BUFFER_SIZE) {
    mBuffer.removeFirst();
  }
  mBuffer.addLast(nr);
}","public void record(StatusBarNotification nr){
  nr.notification.lightenPayload();
  if (mBuffer.size() == BUFFER_SIZE) {
    mBuffer.removeFirst();
  }
  mBuffer.addLast(nr);
}"
2202,"public void notifyRemovedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn))   return;
  try {
    listener.onNotificationRemoved(sbn);
  }
 catch (  RemoteException ex) {
  }
}","public void notifyRemovedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn))   return;
  try {
    listener.onNotificationRemoved(sbn);
  }
 catch (  RemoteException ex) {
    Log.e(TAG,""String_Node_Str"" + listener,ex);
  }
}"
2203,"/** 
 * asynchronously notify all listeners about a new notification
 */
private void notifyPostedLocked(NotificationRecord n){
  final StatusBarNotification sbn=n.sbn;
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyPostedIfUserMatch(sbn);
      }
    }
);
  }
}","/** 
 * asynchronously notify all listeners about a new notification
 */
private void notifyPostedLocked(NotificationRecord n){
  final StatusBarNotification sbn=n.sbn.clone();
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyPostedIfUserMatch(sbn);
      }
    }
);
  }
}"
2204,"/** 
 * asynchronously notify all listeners about a removed notification
 */
private void notifyRemovedLocked(NotificationRecord n){
  final StatusBarNotification sbn=n.sbn;
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyRemovedIfUserMatch(sbn);
      }
    }
);
  }
}","/** 
 * asynchronously notify all listeners about a removed notification
 */
private void notifyRemovedLocked(NotificationRecord n){
  final StatusBarNotification sbn_light=n.sbn.cloneLight();
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyRemovedIfUserMatch(sbn_light);
      }
    }
);
  }
}"
2205,"public void notifyPostedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn)) {
    return;
  }
  try {
    listener.onNotificationPosted(sbn);
  }
 catch (  RemoteException ex) {
  }
}","public void notifyPostedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn)) {
    return;
  }
  try {
    listener.onNotificationPosted(sbn);
  }
 catch (  RemoteException ex) {
    Log.e(TAG,""String_Node_Str"" + listener,ex);
  }
}"
2206,"/** 
 * Apply this Builder to an existing   {@link Notification} object.
 * @hide
 */
public Notification buildInto(Notification n){
  build().cloneInto(n);
  return n;
}","/** 
 * Apply this Builder to an existing   {@link Notification} object.
 * @hide
 */
public Notification buildInto(Notification n){
  build().cloneInto(n,true);
  return n;
}"
2207,"private void cloneInto(Notification that){
  that.when=this.when;
  that.icon=this.icon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (this.largeIcon != null) {
    that.largeIcon=Bitmap.createBitmap(this.largeIcon);
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  final String[] thiskind=this.kind;
  if (thiskind != null) {
    final int N=thiskind.length;
    final String[] thatkind=that.kind=new String[N];
    System.arraycopy(thiskind,0,thatkind,0,N);
  }
  if (this.extras != null) {
    that.extras=new Bundle(this.extras);
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
}","/** 
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members of this into that.
 * @hide
 */
public void cloneInto(Notification that,boolean heavy){
  that.when=this.when;
  that.icon=this.icon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (heavy && this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (heavy && this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (heavy && this.largeIcon != null) {
    that.largeIcon=Bitmap.createBitmap(this.largeIcon);
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  final String[] thiskind=this.kind;
  if (thiskind != null) {
    final int N=thiskind.length;
    final String[] thatkind=that.kind=new String[N];
    System.arraycopy(thiskind,0,thatkind,0,N);
  }
  if (this.extras != null) {
    that.extras=new Bundle(this.extras);
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (heavy && this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
  if (!heavy) {
    that.lightenPayload();
  }
}"
2208,"@Override public Notification clone(){
  Notification that=new Notification();
  cloneInto(that);
  return that;
}","@Override public Notification clone(){
  Notification that=new Notification();
  cloneInto(that,true);
  return that;
}"
2209,"@Override public void run(){
  info.notifyRemovedIfUserMatch(sbn);
}","@Override public void run(){
  info.notifyRemovedIfUserMatch(sbn_light);
}"
2210,"public void record(StatusBarNotification nr){
  nr.notification.tickerView=null;
  nr.notification.contentView=null;
  nr.notification.bigContentView=null;
  nr.notification.largeIcon=null;
  final Bundle extras=nr.notification.extras;
  extras.remove(Notification.EXTRA_LARGE_ICON);
  extras.remove(Notification.EXTRA_LARGE_ICON_BIG);
  extras.remove(Notification.EXTRA_PICTURE);
  if (mBuffer.size() == BUFFER_SIZE) {
    mBuffer.removeFirst();
  }
  mBuffer.addLast(nr);
}","public void record(StatusBarNotification nr){
  nr.notification.lightenPayload();
  if (mBuffer.size() == BUFFER_SIZE) {
    mBuffer.removeFirst();
  }
  mBuffer.addLast(nr);
}"
2211,"public void notifyRemovedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn))   return;
  try {
    listener.onNotificationRemoved(sbn);
  }
 catch (  RemoteException ex) {
  }
}","public void notifyRemovedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn))   return;
  try {
    listener.onNotificationRemoved(sbn);
  }
 catch (  RemoteException ex) {
    Log.e(TAG,""String_Node_Str"" + listener,ex);
  }
}"
2212,"/** 
 * asynchronously notify all listeners about a new notification
 */
private void notifyPostedLocked(NotificationRecord n){
  final StatusBarNotification sbn=n.sbn;
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyPostedIfUserMatch(sbn);
      }
    }
);
  }
}","/** 
 * asynchronously notify all listeners about a new notification
 */
private void notifyPostedLocked(NotificationRecord n){
  final StatusBarNotification sbn=n.sbn.clone();
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyPostedIfUserMatch(sbn);
      }
    }
);
  }
}"
2213,"/** 
 * asynchronously notify all listeners about a removed notification
 */
private void notifyRemovedLocked(NotificationRecord n){
  final StatusBarNotification sbn=n.sbn;
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyRemovedIfUserMatch(sbn);
      }
    }
);
  }
}","/** 
 * asynchronously notify all listeners about a removed notification
 */
private void notifyRemovedLocked(NotificationRecord n){
  final StatusBarNotification sbn_light=n.sbn.cloneLight();
  for (  final NotificationListenerInfo info : mListeners) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        info.notifyRemovedIfUserMatch(sbn_light);
      }
    }
);
  }
}"
2214,"public void notifyPostedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn)) {
    return;
  }
  try {
    listener.onNotificationPosted(sbn);
  }
 catch (  RemoteException ex) {
  }
}","public void notifyPostedIfUserMatch(StatusBarNotification sbn){
  if (!enabledAndUserMatches(sbn)) {
    return;
  }
  try {
    listener.onNotificationPosted(sbn);
  }
 catch (  RemoteException ex) {
    Log.e(TAG,""String_Node_Str"" + listener,ex);
  }
}"
2215,"/** 
 * Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). In streaming mode, will block until all data has been written to the audio sink. In static buffer mode, copies the data to the buffer starting at offset 0. Note that the actual playback of this data might occur after this function returns. This function is thread safe with respect to   {@link #stop} calls,in which case all of the specified data might not be written to the audio sink.
 * @param audioData the array that holds the data to play.
 * @param offsetInShorts the offset expressed in shorts in audioData where the data to playstarts.
 * @param sizeInShorts the number of bytes to read in audioData after the offset.
 * @return the number of shorts that were written or {@link #ERROR_INVALID_OPERATION}if the object wasn't properly initialized, or   {@link #ERROR_BAD_VALUE} ifthe parameters don't resolve to valid data and indexes.
 */
public int write(short[] audioData,int offsetInShorts,int sizeInShorts){
  if (mState == STATE_UNINITIALIZED) {
    return ERROR_INVALID_OPERATION;
  }
  if ((audioData == null) || (offsetInShorts < 0) || (sizeInShorts < 0)|| (offsetInShorts + sizeInShorts < 0)|| (offsetInShorts + sizeInShorts > audioData.length)) {
    return ERROR_BAD_VALUE;
  }
  int ret=native_write_short(audioData,offsetInShorts,sizeInShorts,mAudioFormat);
  if ((mDataLoadMode == MODE_STATIC) && (mState == STATE_NO_STATIC_DATA) && (ret > 0)) {
    mState=STATE_INITIALIZED;
  }
  return ret;
}","/** 
 * Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). In streaming mode, will block until all data has been written to the audio sink. In static buffer mode, copies the data to the buffer starting at offset 0. Note that the actual playback of this data might occur after this function returns. This function is thread safe with respect to   {@link #stop} calls,in which case all of the specified data might not be written to the audio sink.
 * @param audioData the array that holds the data to play.
 * @param offsetInShorts the offset expressed in shorts in audioData where the data to playstarts.
 * @param sizeInShorts the number of shorts to read in audioData after the offset.
 * @return the number of shorts that were written or {@link #ERROR_INVALID_OPERATION}if the object wasn't properly initialized, or   {@link #ERROR_BAD_VALUE} ifthe parameters don't resolve to valid data and indexes.
 */
public int write(short[] audioData,int offsetInShorts,int sizeInShorts){
  if (mState == STATE_UNINITIALIZED) {
    return ERROR_INVALID_OPERATION;
  }
  if ((audioData == null) || (offsetInShorts < 0) || (sizeInShorts < 0)|| (offsetInShorts + sizeInShorts < 0)|| (offsetInShorts + sizeInShorts > audioData.length)) {
    return ERROR_BAD_VALUE;
  }
  int ret=native_write_short(audioData,offsetInShorts,sizeInShorts,mAudioFormat);
  if ((mDataLoadMode == MODE_STATIC) && (mState == STATE_NO_STATIC_DATA) && (ret > 0)) {
    mState=STATE_INITIALIZED;
  }
  return ret;
}"
2216,"/** 
 * Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). In streaming mode, will block until all data has been written to the audio sink. In static buffer mode, copies the data to the buffer starting at offset 0. Note that the actual playback of this data might occur after this function returns. This function is thread safe with respect to   {@link #stop} calls,in which case all of the specified data might not be written to the audio sink.
 * @param audioData the array that holds the data to play.
 * @param offsetInShorts the offset expressed in shorts in audioData where the data to playstarts.
 * @param sizeInShorts the number of bytes to read in audioData after the offset.
 * @return the number of shorts that were written or {@link #ERROR_INVALID_OPERATION}if the object wasn't properly initialized, or   {@link #ERROR_BAD_VALUE} ifthe parameters don't resolve to valid data and indexes.
 */
public int write(short[] audioData,int offsetInShorts,int sizeInShorts){
  if (mState == STATE_UNINITIALIZED) {
    return ERROR_INVALID_OPERATION;
  }
  if ((audioData == null) || (offsetInShorts < 0) || (sizeInShorts < 0)|| (offsetInShorts + sizeInShorts < 0)|| (offsetInShorts + sizeInShorts > audioData.length)) {
    return ERROR_BAD_VALUE;
  }
  int ret=native_write_short(audioData,offsetInShorts,sizeInShorts,mAudioFormat);
  if ((mDataLoadMode == MODE_STATIC) && (mState == STATE_NO_STATIC_DATA) && (ret > 0)) {
    mState=STATE_INITIALIZED;
  }
  return ret;
}","/** 
 * Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). In streaming mode, will block until all data has been written to the audio sink. In static buffer mode, copies the data to the buffer starting at offset 0. Note that the actual playback of this data might occur after this function returns. This function is thread safe with respect to   {@link #stop} calls,in which case all of the specified data might not be written to the audio sink.
 * @param audioData the array that holds the data to play.
 * @param offsetInShorts the offset expressed in shorts in audioData where the data to playstarts.
 * @param sizeInShorts the number of shorts to read in audioData after the offset.
 * @return the number of shorts that were written or {@link #ERROR_INVALID_OPERATION}if the object wasn't properly initialized, or   {@link #ERROR_BAD_VALUE} ifthe parameters don't resolve to valid data and indexes.
 */
public int write(short[] audioData,int offsetInShorts,int sizeInShorts){
  if (mState == STATE_UNINITIALIZED) {
    return ERROR_INVALID_OPERATION;
  }
  if ((audioData == null) || (offsetInShorts < 0) || (sizeInShorts < 0)|| (offsetInShorts + sizeInShorts < 0)|| (offsetInShorts + sizeInShorts > audioData.length)) {
    return ERROR_BAD_VALUE;
  }
  int ret=native_write_short(audioData,offsetInShorts,sizeInShorts,mAudioFormat);
  if ((mDataLoadMode == MODE_STATIC) && (mState == STATE_NO_STATIC_DATA) && (ret > 0)) {
    mState=STATE_INITIALIZED;
  }
  return ret;
}"
2217,"private boolean verifyPreloadConfig(int changingConfigurations,int resourceId,String name){
  if (((changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) & VARYING_CONFIGS) != 0) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  return true;
}","private boolean verifyPreloadConfig(int changingConfigurations,int resourceId,String name){
  if (((changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) & VARYING_CONFIGS) != 0) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  if (TRACE_FOR_PRELOAD) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
  }
  return true;
}"
2218,"Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
 else {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(cs.getChangingConfigurations(),value.resourceId,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables.put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}","Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  final int layoutDirection=mConfiguration.getLayoutDirection();
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables[layoutDirection].get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
 else {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(cs.getChangingConfigurations(),value.resourceId,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables[layoutDirection].put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}"
2219,"private boolean verifyPreloadConfig(int changingConfigurations,int resourceId,String name){
  if (((changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) & VARYING_CONFIGS) != 0) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  return true;
}","private boolean verifyPreloadConfig(int changingConfigurations,int resourceId,String name){
  if (((changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) & VARYING_CONFIGS) != 0) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  if (TRACE_FOR_PRELOAD) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
  }
  return true;
}"
2220,"Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
 else {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(cs.getChangingConfigurations(),value.resourceId,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables.put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}","Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  final int layoutDirection=mConfiguration.getLayoutDirection();
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables[layoutDirection].get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
 else {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(cs.getChangingConfigurations(),value.resourceId,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables[layoutDirection].put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}"
2221,"/** 
 * Specify a X.509 certificate that identifies the server. <p>A default name is automatically assigned to the certificate and used with this configuration. The framework takes care of installing the certificate when the config is saved and removing the certificate when the config is removed.
 * @param cert X.509 CA certificate
 * @throws IllegalArgumentException if not a CA certificate
 */
public void setCaCertificate(X509Certificate cert){
  if (cert.getBasicConstraints() >= 0) {
    mCaCert=cert;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * Specify a X.509 certificate that identifies the server. <p>A default name is automatically assigned to the certificate and used with this configuration. The framework takes care of installing the certificate when the config is saved and removing the certificate when the config is removed.
 * @param cert X.509 CA certificate
 * @throws IllegalArgumentException if not a CA certificate
 */
public void setCaCertificate(X509Certificate cert){
  if (cert != null) {
    if (cert.getBasicConstraints() >= 0) {
      mCaCert=cert;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else {
    mCaCert=null;
  }
}"
2222,"private String removeDoubleQuotes(String string){
  int length=string.length();
  if ((length > 1) && (string.charAt(0) == '""') && (string.charAt(length - 1) == '""')) {
    return string.substring(1,length - 1);
  }
  return string;
}","private String removeDoubleQuotes(String string){
  if (TextUtils.isEmpty(string))   return ""String_Node_Str"";
  int length=string.length();
  if ((length > 1) && (string.charAt(0) == '""') && (string.charAt(length - 1) == '""')) {
    return string.substring(1,length - 1);
  }
  return string;
}"
2223,"/** 
 * Specify a X.509 certificate that identifies the server. <p>A default name is automatically assigned to the certificate and used with this configuration. The framework takes care of installing the certificate when the config is saved and removing the certificate when the config is removed.
 * @param cert X.509 CA certificate
 * @throws IllegalArgumentException if not a CA certificate
 */
public void setCaCertificate(X509Certificate cert){
  if (cert.getBasicConstraints() >= 0) {
    mCaCert=cert;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * Specify a X.509 certificate that identifies the server. <p>A default name is automatically assigned to the certificate and used with this configuration. The framework takes care of installing the certificate when the config is saved and removing the certificate when the config is removed.
 * @param cert X.509 CA certificate
 * @throws IllegalArgumentException if not a CA certificate
 */
public void setCaCertificate(X509Certificate cert){
  if (cert != null) {
    if (cert.getBasicConstraints() >= 0) {
      mCaCert=cert;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else {
    mCaCert=null;
  }
}"
2224,"private String removeDoubleQuotes(String string){
  int length=string.length();
  if ((length > 1) && (string.charAt(0) == '""') && (string.charAt(length - 1) == '""')) {
    return string.substring(1,length - 1);
  }
  return string;
}","private String removeDoubleQuotes(String string){
  if (TextUtils.isEmpty(string))   return ""String_Node_Str"";
  int length=string.length();
  if ((length > 1) && (string.charAt(0) == '""') && (string.charAt(length - 1) == '""')) {
    return string.substring(1,length - 1);
  }
  return string;
}"
2225,"/** 
 * Specify a X.509 certificate that identifies the server. <p>A default name is automatically assigned to the certificate and used with this configuration. The framework takes care of installing the certificate when the config is saved and removing the certificate when the config is removed.
 * @param cert X.509 CA certificate
 * @throws IllegalArgumentException if not a CA certificate
 */
public void setCaCertificate(X509Certificate cert){
  if (cert.getBasicConstraints() >= 0) {
    mCaCert=cert;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * Specify a X.509 certificate that identifies the server. <p>A default name is automatically assigned to the certificate and used with this configuration. The framework takes care of installing the certificate when the config is saved and removing the certificate when the config is removed.
 * @param cert X.509 CA certificate
 * @throws IllegalArgumentException if not a CA certificate
 */
public void setCaCertificate(X509Certificate cert){
  if (cert != null) {
    if (cert.getBasicConstraints() >= 0) {
      mCaCert=cert;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else {
    mCaCert=null;
  }
}"
2226,"private String removeDoubleQuotes(String string){
  int length=string.length();
  if ((length > 1) && (string.charAt(0) == '""') && (string.charAt(length - 1) == '""')) {
    return string.substring(1,length - 1);
  }
  return string;
}","private String removeDoubleQuotes(String string){
  if (TextUtils.isEmpty(string))   return ""String_Node_Str"";
  int length=string.length();
  if ((length > 1) && (string.charAt(0) == '""') && (string.charAt(length - 1) == '""')) {
    return string.substring(1,length - 1);
  }
  return string;
}"
2227,"/** 
 * Specify a X.509 certificate that identifies the server. <p>A default name is automatically assigned to the certificate and used with this configuration. The framework takes care of installing the certificate when the config is saved and removing the certificate when the config is removed.
 * @param cert X.509 CA certificate
 * @throws IllegalArgumentException if not a CA certificate
 */
public void setCaCertificate(X509Certificate cert){
  if (cert.getBasicConstraints() >= 0) {
    mCaCert=cert;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * Specify a X.509 certificate that identifies the server. <p>A default name is automatically assigned to the certificate and used with this configuration. The framework takes care of installing the certificate when the config is saved and removing the certificate when the config is removed.
 * @param cert X.509 CA certificate
 * @throws IllegalArgumentException if not a CA certificate
 */
public void setCaCertificate(X509Certificate cert){
  if (cert != null) {
    if (cert.getBasicConstraints() >= 0) {
      mCaCert=cert;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else {
    mCaCert=null;
  }
}"
2228,"private String removeDoubleQuotes(String string){
  int length=string.length();
  if ((length > 1) && (string.charAt(0) == '""') && (string.charAt(length - 1) == '""')) {
    return string.substring(1,length - 1);
  }
  return string;
}","private String removeDoubleQuotes(String string){
  if (TextUtils.isEmpty(string))   return ""String_Node_Str"";
  int length=string.length();
  if ((length > 1) && (string.charAt(0) == '""') && (string.charAt(length - 1) == '""')) {
    return string.substring(1,length - 1);
  }
  return string;
}"
2229,"private boolean verifyPreloadConfig(int changingConfigurations,int resourceId,String name){
  if (((changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) & VARYING_CONFIGS) != 0) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  return true;
}","private boolean verifyPreloadConfig(int changingConfigurations,int resourceId,String name){
  if (((changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) & VARYING_CONFIGS) != 0) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  if (TRACE_FOR_PRELOAD) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
  }
  return true;
}"
2230,"Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
 else {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(cs.getChangingConfigurations(),value.resourceId,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables.put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}","Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  final int layoutDirection=mConfiguration.getLayoutDirection();
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables[layoutDirection].get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
 else {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(cs.getChangingConfigurations(),value.resourceId,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables[layoutDirection].put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}"
2231,"/** 
 * Resolve padding depending on layout direction.
 * @hide
 */
public void resolvePadding(){
  if (!isRtlCompatibilityMode()) {
    int resolvedLayoutDirection=getLayoutDirection();
    mUserPaddingLeft=mUserPaddingLeftInitial;
    mUserPaddingRight=mUserPaddingRightInitial;
switch (resolvedLayoutDirection) {
case LAYOUT_DIRECTION_RTL:
      if (mUserPaddingStart != UNDEFINED_PADDING) {
        mUserPaddingRight=mUserPaddingStart;
      }
    if (mUserPaddingEnd != UNDEFINED_PADDING) {
      mUserPaddingLeft=mUserPaddingEnd;
    }
  break;
case LAYOUT_DIRECTION_LTR:
default :
if (mUserPaddingStart != UNDEFINED_PADDING) {
  mUserPaddingLeft=mUserPaddingStart;
}
if (mUserPaddingEnd != UNDEFINED_PADDING) {
mUserPaddingRight=mUserPaddingEnd;
}
}
mUserPaddingBottom=(mUserPaddingBottom >= 0) ? mUserPaddingBottom : mPaddingBottom;
internalSetPadding(mUserPaddingLeft,mPaddingTop,mUserPaddingRight,mUserPaddingBottom);
onRtlPropertiesChanged(resolvedLayoutDirection);
}
mPrivateFlags2|=PFLAG2_PADDING_RESOLVED;
}","/** 
 * Resolve padding depending on layout direction.
 * @hide
 */
public void resolvePadding(){
  if (!isRtlCompatibilityMode()) {
    int resolvedLayoutDirection=getLayoutDirection();
switch (resolvedLayoutDirection) {
case LAYOUT_DIRECTION_RTL:
      if (mUserPaddingStart != UNDEFINED_PADDING) {
        mUserPaddingRight=mUserPaddingStart;
      }
 else {
        mUserPaddingRight=mUserPaddingRightInitial;
      }
    if (mUserPaddingEnd != UNDEFINED_PADDING) {
      mUserPaddingLeft=mUserPaddingEnd;
    }
 else {
      mUserPaddingLeft=mUserPaddingLeftInitial;
    }
  break;
case LAYOUT_DIRECTION_LTR:
default :
if (mUserPaddingStart != UNDEFINED_PADDING) {
  mUserPaddingLeft=mUserPaddingStart;
}
 else {
  mUserPaddingLeft=mUserPaddingLeftInitial;
}
if (mUserPaddingEnd != UNDEFINED_PADDING) {
mUserPaddingRight=mUserPaddingEnd;
}
 else {
mUserPaddingRight=mUserPaddingRightInitial;
}
}
mUserPaddingBottom=(mUserPaddingBottom >= 0) ? mUserPaddingBottom : mPaddingBottom;
internalSetPadding(mUserPaddingLeft,mPaddingTop,mUserPaddingRight,mUserPaddingBottom);
onRtlPropertiesChanged(resolvedLayoutDirection);
}
mPrivateFlags2|=PFLAG2_PADDING_RESOLVED;
}"
2232,"/** 
 * Resolve padding depending on layout direction.
 * @hide
 */
public void resolvePadding(){
  if (!isRtlCompatibilityMode()) {
    int resolvedLayoutDirection=getLayoutDirection();
    mUserPaddingLeft=mUserPaddingLeftInitial;
    mUserPaddingRight=mUserPaddingRightInitial;
switch (resolvedLayoutDirection) {
case LAYOUT_DIRECTION_RTL:
      if (mUserPaddingStart != UNDEFINED_PADDING) {
        mUserPaddingRight=mUserPaddingStart;
      }
    if (mUserPaddingEnd != UNDEFINED_PADDING) {
      mUserPaddingLeft=mUserPaddingEnd;
    }
  break;
case LAYOUT_DIRECTION_LTR:
default :
if (mUserPaddingStart != UNDEFINED_PADDING) {
  mUserPaddingLeft=mUserPaddingStart;
}
if (mUserPaddingEnd != UNDEFINED_PADDING) {
mUserPaddingRight=mUserPaddingEnd;
}
}
mUserPaddingBottom=(mUserPaddingBottom >= 0) ? mUserPaddingBottom : mPaddingBottom;
internalSetPadding(mUserPaddingLeft,mPaddingTop,mUserPaddingRight,mUserPaddingBottom);
onRtlPropertiesChanged(resolvedLayoutDirection);
}
mPrivateFlags2|=PFLAG2_PADDING_RESOLVED;
}","/** 
 * Resolve padding depending on layout direction.
 * @hide
 */
public void resolvePadding(){
  if (!isRtlCompatibilityMode()) {
    int resolvedLayoutDirection=getLayoutDirection();
switch (resolvedLayoutDirection) {
case LAYOUT_DIRECTION_RTL:
      if (mUserPaddingStart != UNDEFINED_PADDING) {
        mUserPaddingRight=mUserPaddingStart;
      }
 else {
        mUserPaddingRight=mUserPaddingRightInitial;
      }
    if (mUserPaddingEnd != UNDEFINED_PADDING) {
      mUserPaddingLeft=mUserPaddingEnd;
    }
 else {
      mUserPaddingLeft=mUserPaddingLeftInitial;
    }
  break;
case LAYOUT_DIRECTION_LTR:
default :
if (mUserPaddingStart != UNDEFINED_PADDING) {
  mUserPaddingLeft=mUserPaddingStart;
}
 else {
  mUserPaddingLeft=mUserPaddingLeftInitial;
}
if (mUserPaddingEnd != UNDEFINED_PADDING) {
mUserPaddingRight=mUserPaddingEnd;
}
 else {
mUserPaddingRight=mUserPaddingRightInitial;
}
}
mUserPaddingBottom=(mUserPaddingBottom >= 0) ? mUserPaddingBottom : mPaddingBottom;
internalSetPadding(mUserPaddingLeft,mPaddingTop,mUserPaddingRight,mUserPaddingBottom);
onRtlPropertiesChanged(resolvedLayoutDirection);
}
mPrivateFlags2|=PFLAG2_PADDING_RESOLVED;
}"
2233,"/** 
 * Resolve padding depending on layout direction.
 * @hide
 */
public void resolvePadding(){
  if (!isRtlCompatibilityMode()) {
    int resolvedLayoutDirection=getLayoutDirection();
    mUserPaddingLeft=mUserPaddingLeftInitial;
    mUserPaddingRight=mUserPaddingRightInitial;
switch (resolvedLayoutDirection) {
case LAYOUT_DIRECTION_RTL:
      if (mUserPaddingStart != UNDEFINED_PADDING) {
        mUserPaddingRight=mUserPaddingStart;
      }
    if (mUserPaddingEnd != UNDEFINED_PADDING) {
      mUserPaddingLeft=mUserPaddingEnd;
    }
  break;
case LAYOUT_DIRECTION_LTR:
default :
if (mUserPaddingStart != UNDEFINED_PADDING) {
  mUserPaddingLeft=mUserPaddingStart;
}
if (mUserPaddingEnd != UNDEFINED_PADDING) {
mUserPaddingRight=mUserPaddingEnd;
}
}
mUserPaddingBottom=(mUserPaddingBottom >= 0) ? mUserPaddingBottom : mPaddingBottom;
internalSetPadding(mUserPaddingLeft,mPaddingTop,mUserPaddingRight,mUserPaddingBottom);
onRtlPropertiesChanged(resolvedLayoutDirection);
}
mPrivateFlags2|=PFLAG2_PADDING_RESOLVED;
}","/** 
 * Resolve padding depending on layout direction.
 * @hide
 */
public void resolvePadding(){
  if (!isRtlCompatibilityMode()) {
    int resolvedLayoutDirection=getLayoutDirection();
switch (resolvedLayoutDirection) {
case LAYOUT_DIRECTION_RTL:
      if (mUserPaddingStart != UNDEFINED_PADDING) {
        mUserPaddingRight=mUserPaddingStart;
      }
 else {
        mUserPaddingRight=mUserPaddingRightInitial;
      }
    if (mUserPaddingEnd != UNDEFINED_PADDING) {
      mUserPaddingLeft=mUserPaddingEnd;
    }
 else {
      mUserPaddingLeft=mUserPaddingLeftInitial;
    }
  break;
case LAYOUT_DIRECTION_LTR:
default :
if (mUserPaddingStart != UNDEFINED_PADDING) {
  mUserPaddingLeft=mUserPaddingStart;
}
 else {
  mUserPaddingLeft=mUserPaddingLeftInitial;
}
if (mUserPaddingEnd != UNDEFINED_PADDING) {
mUserPaddingRight=mUserPaddingEnd;
}
 else {
mUserPaddingRight=mUserPaddingRightInitial;
}
}
mUserPaddingBottom=(mUserPaddingBottom >= 0) ? mUserPaddingBottom : mPaddingBottom;
internalSetPadding(mUserPaddingLeft,mPaddingTop,mUserPaddingRight,mUserPaddingBottom);
onRtlPropertiesChanged(resolvedLayoutDirection);
}
mPrivateFlags2|=PFLAG2_PADDING_RESOLVED;
}"
2234,"/** 
 * Resolve padding depending on layout direction.
 * @hide
 */
public void resolvePadding(){
  if (!isRtlCompatibilityMode()) {
    int resolvedLayoutDirection=getLayoutDirection();
    mUserPaddingLeft=mUserPaddingLeftInitial;
    mUserPaddingRight=mUserPaddingRightInitial;
switch (resolvedLayoutDirection) {
case LAYOUT_DIRECTION_RTL:
      if (mUserPaddingStart != UNDEFINED_PADDING) {
        mUserPaddingRight=mUserPaddingStart;
      }
    if (mUserPaddingEnd != UNDEFINED_PADDING) {
      mUserPaddingLeft=mUserPaddingEnd;
    }
  break;
case LAYOUT_DIRECTION_LTR:
default :
if (mUserPaddingStart != UNDEFINED_PADDING) {
  mUserPaddingLeft=mUserPaddingStart;
}
if (mUserPaddingEnd != UNDEFINED_PADDING) {
mUserPaddingRight=mUserPaddingEnd;
}
}
mUserPaddingBottom=(mUserPaddingBottom >= 0) ? mUserPaddingBottom : mPaddingBottom;
internalSetPadding(mUserPaddingLeft,mPaddingTop,mUserPaddingRight,mUserPaddingBottom);
onRtlPropertiesChanged(resolvedLayoutDirection);
}
mPrivateFlags2|=PFLAG2_PADDING_RESOLVED;
}","/** 
 * Resolve padding depending on layout direction.
 * @hide
 */
public void resolvePadding(){
  if (!isRtlCompatibilityMode()) {
    int resolvedLayoutDirection=getLayoutDirection();
switch (resolvedLayoutDirection) {
case LAYOUT_DIRECTION_RTL:
      if (mUserPaddingStart != UNDEFINED_PADDING) {
        mUserPaddingRight=mUserPaddingStart;
      }
 else {
        mUserPaddingRight=mUserPaddingRightInitial;
      }
    if (mUserPaddingEnd != UNDEFINED_PADDING) {
      mUserPaddingLeft=mUserPaddingEnd;
    }
 else {
      mUserPaddingLeft=mUserPaddingLeftInitial;
    }
  break;
case LAYOUT_DIRECTION_LTR:
default :
if (mUserPaddingStart != UNDEFINED_PADDING) {
  mUserPaddingLeft=mUserPaddingStart;
}
 else {
  mUserPaddingLeft=mUserPaddingLeftInitial;
}
if (mUserPaddingEnd != UNDEFINED_PADDING) {
mUserPaddingRight=mUserPaddingEnd;
}
 else {
mUserPaddingRight=mUserPaddingRightInitial;
}
}
mUserPaddingBottom=(mUserPaddingBottom >= 0) ? mUserPaddingBottom : mPaddingBottom;
internalSetPadding(mUserPaddingLeft,mPaddingTop,mUserPaddingRight,mUserPaddingBottom);
onRtlPropertiesChanged(resolvedLayoutDirection);
}
mPrivateFlags2|=PFLAG2_PADDING_RESOLVED;
}"
2235,"private boolean verifyPreloadConfig(int changingConfigurations,int resourceId,String name){
  if (((changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) & VARYING_CONFIGS) != 0) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  return true;
}","private boolean verifyPreloadConfig(int changingConfigurations,int resourceId,String name){
  if (((changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) & VARYING_CONFIGS) != 0) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  if (TRACE_FOR_PRELOAD) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
  }
  return true;
}"
2236,"Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
 else {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(cs.getChangingConfigurations(),value.resourceId,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables.put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}","Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  final int layoutDirection=mConfiguration.getLayoutDirection();
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables[layoutDirection].get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
 else {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,file);
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(cs.getChangingConfigurations(),value.resourceId,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables[layoutDirection].put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}"
2237,"/** 
 * Handle a request by the system to show the soft input area.
 */
public void showSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  if (onShowInputRequested(flags,false)) {
    try {
      showWindow(true);
    }
 catch (    BadTokenException e) {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mWindowVisible=false;
      mWindowAdded=false;
    }
  }
  boolean showing=onEvaluateInputViewShown();
  mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}","/** 
 * Handle a request by the system to show the soft input area.
 */
public void showSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  if (onShowInputRequested(flags,false)) {
    try {
      showWindow(true);
    }
 catch (    BadTokenException e) {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mWindowVisible=false;
      mWindowAdded=false;
    }
  }
  boolean showing=isInputViewShown();
  mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}"
2238,"@SuppressWarnings(""String_Node_Str"") @Override public void setImeWindowStatus(IBinder token,int vis,int backDisposition){
  final long ident=Binder.clearCallingIdentity();
  try {
    if (token == null || mCurToken != token) {
      int uid=Binder.getCallingUid();
      Slog.w(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ token);
      return;
    }
synchronized (mMethodMap) {
      mImeWindowVis=vis;
      mBackDisposition=backDisposition;
      if (mStatusBar != null) {
        mStatusBar.setImeWindowStatus(token,vis,backDisposition);
      }
      final boolean iconVisibility=(vis & InputMethodService.IME_ACTIVE) != 0;
      final InputMethodInfo imi=mMethodMap.get(mCurMethodId);
      if (imi != null && iconVisibility && needsToShowImeSwitchOngoingNotification()) {
        final PackageManager pm=mContext.getPackageManager();
        final CharSequence title=mRes.getText(com.android.internal.R.string.select_input_method);
        final CharSequence imiLabel=imi.loadLabel(pm);
        final CharSequence summary=mCurrentSubtype != null ? TextUtils.concat(mCurrentSubtype.getDisplayName(mContext,imi.getPackageName(),imi.getServiceInfo().applicationInfo),(TextUtils.isEmpty(imiLabel) ? ""String_Node_Str"" : ""String_Node_Str"" + imiLabel)) : imiLabel;
        mImeSwitcherNotification.setLatestEventInfo(mContext,title,summary,mImeSwitchPendingIntent);
        if (mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"" + imiLabel + ""String_Node_Str""+ summary);
          }
          mNotificationManager.notifyAsUser(null,com.android.internal.R.string.select_input_method,mImeSwitcherNotification,UserHandle.ALL);
          mNotificationShown=true;
        }
      }
 else {
        if (mNotificationShown && mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"");
          }
          mNotificationManager.cancelAsUser(null,com.android.internal.R.string.select_input_method,UserHandle.ALL);
          mNotificationShown=false;
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void setImeWindowStatus(IBinder token,int vis,int backDisposition){
  final long ident=Binder.clearCallingIdentity();
  try {
    if (token == null || mCurToken != token) {
      int uid=Binder.getCallingUid();
      Slog.w(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ token);
      return;
    }
synchronized (mMethodMap) {
      mImeWindowVis=vis;
      mBackDisposition=backDisposition;
      if (mStatusBar != null) {
        mStatusBar.setImeWindowStatus(token,vis,backDisposition);
      }
      final boolean iconVisibility=((vis & (InputMethodService.IME_ACTIVE)) != 0) && (mWindowManagerService.isHardKeyboardAvailable() || (vis & (InputMethodService.IME_VISIBLE)) != 0);
      final InputMethodInfo imi=mMethodMap.get(mCurMethodId);
      if (imi != null && iconVisibility && needsToShowImeSwitchOngoingNotification()) {
        final PackageManager pm=mContext.getPackageManager();
        final CharSequence title=mRes.getText(com.android.internal.R.string.select_input_method);
        final CharSequence imiLabel=imi.loadLabel(pm);
        final CharSequence summary=mCurrentSubtype != null ? TextUtils.concat(mCurrentSubtype.getDisplayName(mContext,imi.getPackageName(),imi.getServiceInfo().applicationInfo),(TextUtils.isEmpty(imiLabel) ? ""String_Node_Str"" : ""String_Node_Str"" + imiLabel)) : imiLabel;
        mImeSwitcherNotification.setLatestEventInfo(mContext,title,summary,mImeSwitchPendingIntent);
        if (mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"" + imiLabel + ""String_Node_Str""+ summary);
          }
          mNotificationManager.notifyAsUser(null,com.android.internal.R.string.select_input_method,mImeSwitcherNotification,UserHandle.ALL);
          mNotificationShown=true;
        }
      }
 else {
        if (mNotificationShown && mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"");
          }
          mNotificationManager.cancelAsUser(null,com.android.internal.R.string.select_input_method,UserHandle.ALL);
          mNotificationShown=false;
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
2239,"/** 
 * Handle a request by the system to show the soft input area.
 */
public void showSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  if (onShowInputRequested(flags,false)) {
    try {
      showWindow(true);
    }
 catch (    BadTokenException e) {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mWindowVisible=false;
      mWindowAdded=false;
    }
  }
  boolean showing=onEvaluateInputViewShown();
  mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}","/** 
 * Handle a request by the system to show the soft input area.
 */
public void showSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  if (onShowInputRequested(flags,false)) {
    try {
      showWindow(true);
    }
 catch (    BadTokenException e) {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mWindowVisible=false;
      mWindowAdded=false;
    }
  }
  boolean showing=isInputViewShown();
  mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}"
2240,"@SuppressWarnings(""String_Node_Str"") @Override public void setImeWindowStatus(IBinder token,int vis,int backDisposition){
  final long ident=Binder.clearCallingIdentity();
  try {
    if (token == null || mCurToken != token) {
      int uid=Binder.getCallingUid();
      Slog.w(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ token);
      return;
    }
synchronized (mMethodMap) {
      mImeWindowVis=vis;
      mBackDisposition=backDisposition;
      if (mStatusBar != null) {
        mStatusBar.setImeWindowStatus(token,vis,backDisposition);
      }
      final boolean iconVisibility=(vis & InputMethodService.IME_ACTIVE) != 0;
      final InputMethodInfo imi=mMethodMap.get(mCurMethodId);
      if (imi != null && iconVisibility && needsToShowImeSwitchOngoingNotification()) {
        final PackageManager pm=mContext.getPackageManager();
        final CharSequence title=mRes.getText(com.android.internal.R.string.select_input_method);
        final CharSequence imiLabel=imi.loadLabel(pm);
        final CharSequence summary=mCurrentSubtype != null ? TextUtils.concat(mCurrentSubtype.getDisplayName(mContext,imi.getPackageName(),imi.getServiceInfo().applicationInfo),(TextUtils.isEmpty(imiLabel) ? ""String_Node_Str"" : ""String_Node_Str"" + imiLabel)) : imiLabel;
        mImeSwitcherNotification.setLatestEventInfo(mContext,title,summary,mImeSwitchPendingIntent);
        if (mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"" + imiLabel + ""String_Node_Str""+ summary);
          }
          mNotificationManager.notifyAsUser(null,com.android.internal.R.string.select_input_method,mImeSwitcherNotification,UserHandle.ALL);
          mNotificationShown=true;
        }
      }
 else {
        if (mNotificationShown && mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"");
          }
          mNotificationManager.cancelAsUser(null,com.android.internal.R.string.select_input_method,UserHandle.ALL);
          mNotificationShown=false;
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void setImeWindowStatus(IBinder token,int vis,int backDisposition){
  final long ident=Binder.clearCallingIdentity();
  try {
    if (token == null || mCurToken != token) {
      int uid=Binder.getCallingUid();
      Slog.w(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ token);
      return;
    }
synchronized (mMethodMap) {
      mImeWindowVis=vis;
      mBackDisposition=backDisposition;
      if (mStatusBar != null) {
        mStatusBar.setImeWindowStatus(token,vis,backDisposition);
      }
      final boolean iconVisibility=((vis & (InputMethodService.IME_ACTIVE)) != 0) && (mWindowManagerService.isHardKeyboardAvailable() || (vis & (InputMethodService.IME_VISIBLE)) != 0);
      final InputMethodInfo imi=mMethodMap.get(mCurMethodId);
      if (imi != null && iconVisibility && needsToShowImeSwitchOngoingNotification()) {
        final PackageManager pm=mContext.getPackageManager();
        final CharSequence title=mRes.getText(com.android.internal.R.string.select_input_method);
        final CharSequence imiLabel=imi.loadLabel(pm);
        final CharSequence summary=mCurrentSubtype != null ? TextUtils.concat(mCurrentSubtype.getDisplayName(mContext,imi.getPackageName(),imi.getServiceInfo().applicationInfo),(TextUtils.isEmpty(imiLabel) ? ""String_Node_Str"" : ""String_Node_Str"" + imiLabel)) : imiLabel;
        mImeSwitcherNotification.setLatestEventInfo(mContext,title,summary,mImeSwitchPendingIntent);
        if (mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"" + imiLabel + ""String_Node_Str""+ summary);
          }
          mNotificationManager.notifyAsUser(null,com.android.internal.R.string.select_input_method,mImeSwitcherNotification,UserHandle.ALL);
          mNotificationShown=true;
        }
      }
 else {
        if (mNotificationShown && mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"");
          }
          mNotificationManager.cancelAsUser(null,com.android.internal.R.string.select_input_method,UserHandle.ALL);
          mNotificationShown=false;
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
2241,"/** 
 * Handle a request by the system to show the soft input area.
 */
public void showSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  if (onShowInputRequested(flags,false)) {
    showWindow(true);
  }
  boolean showing=onEvaluateInputViewShown();
  mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}","/** 
 * Handle a request by the system to show the soft input area.
 */
public void showSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  if (onShowInputRequested(flags,false)) {
    showWindow(true);
  }
  boolean showing=isInputViewShown();
  mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}"
2242,"@SuppressWarnings(""String_Node_Str"") @Override public void setImeWindowStatus(IBinder token,int vis,int backDisposition){
  final long ident=Binder.clearCallingIdentity();
  try {
    if (token == null || mCurToken != token) {
      int uid=Binder.getCallingUid();
      Slog.w(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ token);
      return;
    }
synchronized (mMethodMap) {
      mImeWindowVis=vis;
      mBackDisposition=backDisposition;
      if (mStatusBar != null) {
        mStatusBar.setImeWindowStatus(token,vis,backDisposition);
      }
      final boolean iconVisibility=(vis & InputMethodService.IME_ACTIVE) != 0;
      final InputMethodInfo imi=mMethodMap.get(mCurMethodId);
      if (imi != null && iconVisibility && needsToShowImeSwitchOngoingNotification()) {
        final PackageManager pm=mContext.getPackageManager();
        final CharSequence title=mRes.getText(com.android.internal.R.string.select_input_method);
        final CharSequence imiLabel=imi.loadLabel(pm);
        final CharSequence summary=mCurrentSubtype != null ? TextUtils.concat(mCurrentSubtype.getDisplayName(mContext,imi.getPackageName(),imi.getServiceInfo().applicationInfo),(TextUtils.isEmpty(imiLabel) ? ""String_Node_Str"" : ""String_Node_Str"" + imiLabel)) : imiLabel;
        mImeSwitcherNotification.setLatestEventInfo(mContext,title,summary,mImeSwitchPendingIntent);
        if (mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"" + imiLabel + ""String_Node_Str""+ summary);
          }
          mNotificationManager.notifyAsUser(null,com.android.internal.R.string.select_input_method,mImeSwitcherNotification,UserHandle.ALL);
          mNotificationShown=true;
        }
      }
 else {
        if (mNotificationShown && mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"");
          }
          mNotificationManager.cancelAsUser(null,com.android.internal.R.string.select_input_method,UserHandle.ALL);
          mNotificationShown=false;
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void setImeWindowStatus(IBinder token,int vis,int backDisposition){
  final long ident=Binder.clearCallingIdentity();
  try {
    if (token == null || mCurToken != token) {
      int uid=Binder.getCallingUid();
      Slog.w(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ token);
      return;
    }
synchronized (mMethodMap) {
      mImeWindowVis=vis;
      mBackDisposition=backDisposition;
      if (mStatusBar != null) {
        mStatusBar.setImeWindowStatus(token,vis,backDisposition);
      }
      final boolean iconVisibility=((vis & (InputMethodService.IME_ACTIVE)) != 0) && (mWindowManagerService.isHardKeyboardAvailable() || (vis & (InputMethodService.IME_VISIBLE)) != 0);
      final InputMethodInfo imi=mMethodMap.get(mCurMethodId);
      if (imi != null && iconVisibility && needsToShowImeSwitchOngoingNotification()) {
        final PackageManager pm=mContext.getPackageManager();
        final CharSequence title=mRes.getText(com.android.internal.R.string.select_input_method);
        final CharSequence imiLabel=imi.loadLabel(pm);
        final CharSequence summary=mCurrentSubtype != null ? TextUtils.concat(mCurrentSubtype.getDisplayName(mContext,imi.getPackageName(),imi.getServiceInfo().applicationInfo),(TextUtils.isEmpty(imiLabel) ? ""String_Node_Str"" : ""String_Node_Str"" + imiLabel)) : imiLabel;
        mImeSwitcherNotification.setLatestEventInfo(mContext,title,summary,mImeSwitchPendingIntent);
        if (mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"" + imiLabel + ""String_Node_Str""+ summary);
          }
          mNotificationManager.notifyAsUser(null,com.android.internal.R.string.select_input_method,mImeSwitcherNotification,UserHandle.ALL);
          mNotificationShown=true;
        }
      }
 else {
        if (mNotificationShown && mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"");
          }
          mNotificationManager.cancelAsUser(null,com.android.internal.R.string.select_input_method,UserHandle.ALL);
          mNotificationShown=false;
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
2243,"@Override public void onCreate(Bundle icicle){
  super.onCreate(icicle);
  mDisconnectedReceiver=new UsbDisconnectedReceiver(this);
  Intent intent=getIntent();
  String fingerprints=intent.getStringExtra(""String_Node_Str"");
  mKey=intent.getStringExtra(""String_Node_Str"");
  if (fingerprints == null || mKey == null) {
    finish();
    return;
  }
  final AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=getString(R.string.usb_debugging_title);
  ap.mIconId=com.android.internal.R.drawable.ic_dialog_usb;
  ap.mMessage=getString(R.string.usb_debugging_message,fingerprints);
  ap.mPositiveButtonText=getString(android.R.string.ok);
  ap.mNegativeButtonText=getString(android.R.string.cancel);
  ap.mPositiveButtonListener=this;
  ap.mNegativeButtonListener=this;
  LayoutInflater inflater=LayoutInflater.from(ap.mContext);
  View checkbox=inflater.inflate(com.android.internal.R.layout.always_use_checkbox,null);
  mAlwaysAllow=(CheckBox)checkbox.findViewById(com.android.internal.R.id.alwaysUse);
  mAlwaysAllow.setText(getString(R.string.usb_debugging_always));
  ap.mView=checkbox;
  setupAlert();
}","@Override public void onCreate(Bundle icicle){
  super.onCreate(icicle);
  if (SystemProperties.getInt(""String_Node_Str"",0) == 0) {
    mDisconnectedReceiver=new UsbDisconnectedReceiver(this);
  }
  Intent intent=getIntent();
  String fingerprints=intent.getStringExtra(""String_Node_Str"");
  mKey=intent.getStringExtra(""String_Node_Str"");
  if (fingerprints == null || mKey == null) {
    finish();
    return;
  }
  final AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=getString(R.string.usb_debugging_title);
  ap.mIconId=com.android.internal.R.drawable.ic_dialog_usb;
  ap.mMessage=getString(R.string.usb_debugging_message,fingerprints);
  ap.mPositiveButtonText=getString(android.R.string.ok);
  ap.mNegativeButtonText=getString(android.R.string.cancel);
  ap.mPositiveButtonListener=this;
  ap.mNegativeButtonListener=this;
  LayoutInflater inflater=LayoutInflater.from(ap.mContext);
  View checkbox=inflater.inflate(com.android.internal.R.layout.always_use_checkbox,null);
  mAlwaysAllow=(CheckBox)checkbox.findViewById(com.android.internal.R.id.alwaysUse);
  mAlwaysAllow.setText(getString(R.string.usb_debugging_always));
  ap.mView=checkbox;
  setupAlert();
}"
2244,"@Override public void onCreate(Bundle icicle){
  super.onCreate(icicle);
  mDisconnectedReceiver=new UsbDisconnectedReceiver(this);
  Intent intent=getIntent();
  String fingerprints=intent.getStringExtra(""String_Node_Str"");
  mKey=intent.getStringExtra(""String_Node_Str"");
  if (fingerprints == null || mKey == null) {
    finish();
    return;
  }
  final AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=getString(R.string.usb_debugging_title);
  ap.mIconId=com.android.internal.R.drawable.ic_dialog_usb;
  ap.mMessage=getString(R.string.usb_debugging_message,fingerprints);
  ap.mPositiveButtonText=getString(android.R.string.ok);
  ap.mNegativeButtonText=getString(android.R.string.cancel);
  ap.mPositiveButtonListener=this;
  ap.mNegativeButtonListener=this;
  LayoutInflater inflater=LayoutInflater.from(ap.mContext);
  View checkbox=inflater.inflate(com.android.internal.R.layout.always_use_checkbox,null);
  mAlwaysAllow=(CheckBox)checkbox.findViewById(com.android.internal.R.id.alwaysUse);
  mAlwaysAllow.setText(getString(R.string.usb_debugging_always));
  ap.mView=checkbox;
  setupAlert();
}","@Override public void onCreate(Bundle icicle){
  super.onCreate(icicle);
  if (SystemProperties.getInt(""String_Node_Str"",0) == 0) {
    mDisconnectedReceiver=new UsbDisconnectedReceiver(this);
  }
  Intent intent=getIntent();
  String fingerprints=intent.getStringExtra(""String_Node_Str"");
  mKey=intent.getStringExtra(""String_Node_Str"");
  if (fingerprints == null || mKey == null) {
    finish();
    return;
  }
  final AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=getString(R.string.usb_debugging_title);
  ap.mIconId=com.android.internal.R.drawable.ic_dialog_usb;
  ap.mMessage=getString(R.string.usb_debugging_message,fingerprints);
  ap.mPositiveButtonText=getString(android.R.string.ok);
  ap.mNegativeButtonText=getString(android.R.string.cancel);
  ap.mPositiveButtonListener=this;
  ap.mNegativeButtonListener=this;
  LayoutInflater inflater=LayoutInflater.from(ap.mContext);
  View checkbox=inflater.inflate(com.android.internal.R.layout.always_use_checkbox,null);
  mAlwaysAllow=(CheckBox)checkbox.findViewById(com.android.internal.R.id.alwaysUse);
  mAlwaysAllow.setText(getString(R.string.usb_debugging_always));
  ap.mView=checkbox;
  setupAlert();
}"
2245,"/** 
 * Takes a snapshot of the screen.  In landscape mode this grabs the whole screen. In portrait mode, it grabs the upper region of the screen based on the vertical dimension of the target image.
 * @param displayId the Display to take a screenshot of.
 * @param width the width of the target bitmap
 * @param height the height of the target bitmap
 */
@Override public Bitmap screenshotApplications(IBinder appToken,int displayId,int width,int height){
  if (!checkCallingPermission(android.Manifest.permission.READ_FRAME_BUFFER,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  Bitmap rawss=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  float scale=0;
  int dw, dh;
  int rot=Surface.ROTATION_0;
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  int retryCount=0;
  WindowState appWin=null;
  do {
    if (retryCount++ > 0) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
      }
    }
synchronized (mWindowMap) {
      final DisplayContent displayContent=getDisplayContentLocked(displayId);
      if (displayContent == null) {
        return null;
      }
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      dw=displayInfo.logicalWidth;
      dh=displayInfo.logicalHeight;
      int aboveAppLayer=mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
      aboveAppLayer+=TYPE_LAYER_MULTIPLIER;
      boolean isImeTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
      boolean including=false;
      appWin=null;
      final WindowList windows=displayContent.getWindowList();
      for (int i=windows.size() - 1; i >= 0; i--) {
        WindowState ws=windows.get(i);
        if (!ws.mHasSurface) {
          continue;
        }
        if (ws.mLayer >= aboveAppLayer) {
          continue;
        }
        if (!including && appToken != null) {
          if (!ws.mIsImWindow || !isImeTarget) {
            if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
              continue;
            }
            appWin=ws;
          }
        }
        boolean fullscreen=ws.isFullscreen(dw,dh);
        including=!ws.mIsImWindow && !fullscreen;
        final WindowStateAnimator winAnim=ws.mWinAnimator;
        if (maxLayer < winAnim.mSurfaceLayer) {
          maxLayer=winAnim.mSurfaceLayer;
        }
        if (minLayer > winAnim.mSurfaceLayer) {
          minLayer=winAnim.mSurfaceLayer;
        }
        if (!ws.mIsWallpaper) {
          final Rect wf=ws.mFrame;
          final Rect cr=ws.mContentInsets;
          int left=wf.left + cr.left;
          int top=wf.top + cr.top;
          int right=wf.right - cr.right;
          int bottom=wf.bottom - cr.bottom;
          frame.union(left,top,right,bottom);
        }
        if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw()) {
          screenshotReady=true;
        }
        if (fullscreen) {
          break;
        }
      }
      if (appToken != null && appWin == null) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken);
        return null;
      }
      if (!screenshotReady) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ appWin+ ""String_Node_Str""+ appWin.mWinAnimator.mDrawState);
        continue;
      }
      frame.intersect(0,0,dw,dh);
      if (frame.isEmpty() || maxLayer == 0) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ frame.toShortString()+ ""String_Node_Str""+ maxLayer);
        return null;
      }
      rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
      int fw=frame.width();
      int fh=frame.height();
      float targetWidthScale=width / (float)fw;
      float targetHeightScale=height / (float)fh;
      if (dw <= dh) {
        scale=targetWidthScale;
        if (targetHeightScale > scale && (int)(targetHeightScale * fw) == width) {
          scale=targetHeightScale;
        }
      }
 else {
        scale=targetHeightScale;
        if (targetWidthScale > scale && (int)(targetWidthScale * fh) == height) {
          scale=targetWidthScale;
        }
      }
      dw=(int)(dw * scale);
      dh=(int)(dh * scale);
      if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
        int tmp=dw;
        dw=dh;
        dh=tmp;
        rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
      }
      if (DEBUG_SCREENSHOT) {
        Slog.i(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
        for (int i=0; i < windows.size(); i++) {
          WindowState win=windows.get(i);
          Slog.i(TAG,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ win.mWinAnimator.mSurfaceLayer);
        }
      }
      rawss=SurfaceControl.screenshot(dw,dh,minLayer,maxLayer);
    }
  }
 while (!screenshotReady && retryCount <= MAX_SCREENSHOT_RETRIES);
  if (retryCount > MAX_SCREENSHOT_RETRIES)   Slog.i(TAG,""String_Node_Str"" + retryCount + ""String_Node_Str""+ appToken+ ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
  if (rawss == null) {
    Slog.w(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
    return null;
  }
  Bitmap bm=Bitmap.createBitmap(width,height,rawss.getConfig());
  Matrix matrix=new Matrix();
  ScreenRotationAnimation.createRotationMatrix(rot,dw,dh,matrix);
  matrix.postTranslate(-FloatMath.ceil(frame.left * scale),-FloatMath.ceil(frame.top * scale));
  Canvas canvas=new Canvas(bm);
  canvas.drawBitmap(rawss,matrix,null);
  canvas.setBitmap(null);
  if (true || DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != Color.BLACK) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG,""String_Node_Str"" + appWin + ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  rawss.recycle();
  return bm;
}","/** 
 * Takes a snapshot of the screen.  In landscape mode this grabs the whole screen. In portrait mode, it grabs the upper region of the screen based on the vertical dimension of the target image.
 * @param displayId the Display to take a screenshot of.
 * @param width the width of the target bitmap
 * @param height the height of the target bitmap
 */
@Override public Bitmap screenshotApplications(IBinder appToken,int displayId,int width,int height){
  if (!checkCallingPermission(android.Manifest.permission.READ_FRAME_BUFFER,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  Bitmap rawss=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  float scale=0;
  int dw, dh;
  int rot=Surface.ROTATION_0;
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  int retryCount=0;
  WindowState appWin=null;
  do {
    if (retryCount++ > 0) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
      }
    }
synchronized (mWindowMap) {
      final DisplayContent displayContent=getDisplayContentLocked(displayId);
      if (displayContent == null) {
        return null;
      }
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      dw=displayInfo.logicalWidth;
      dh=displayInfo.logicalHeight;
      int aboveAppLayer=mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
      aboveAppLayer+=TYPE_LAYER_MULTIPLIER;
      boolean isImeTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
      boolean including=false;
      appWin=null;
      final WindowList windows=displayContent.getWindowList();
      for (int i=windows.size() - 1; i >= 0; i--) {
        WindowState ws=windows.get(i);
        if (!ws.mHasSurface) {
          continue;
        }
        if (ws.mLayer >= aboveAppLayer) {
          continue;
        }
        if (!including && appToken != null) {
          if (!ws.mIsImWindow || !isImeTarget) {
            if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
              continue;
            }
            appWin=ws;
          }
        }
        boolean fullscreen=ws.isFullscreen(dw,dh);
        including=!ws.mIsImWindow && !fullscreen;
        final WindowStateAnimator winAnim=ws.mWinAnimator;
        if (maxLayer < winAnim.mSurfaceLayer) {
          maxLayer=winAnim.mSurfaceLayer;
        }
        if (minLayer > winAnim.mSurfaceLayer) {
          minLayer=winAnim.mSurfaceLayer;
        }
        if (!ws.mIsWallpaper) {
          final Rect wf=ws.mFrame;
          final Rect cr=ws.mContentInsets;
          int left=wf.left + cr.left;
          int top=wf.top + cr.top;
          int right=wf.right - cr.right;
          int bottom=wf.bottom - cr.bottom;
          frame.union(left,top,right,bottom);
        }
        if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw()) {
          screenshotReady=true;
        }
        if (fullscreen) {
          break;
        }
      }
      if (appToken != null && appWin == null) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken);
        return null;
      }
      if (!screenshotReady) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ appWin+ ""String_Node_Str""+ appWin.mWinAnimator.mDrawState);
        continue;
      }
      frame.intersect(0,0,dw,dh);
      if (frame.isEmpty() || maxLayer == 0) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ frame.toShortString()+ ""String_Node_Str""+ maxLayer);
        return null;
      }
      rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
      int fw=frame.width();
      int fh=frame.height();
      float targetWidthScale=width / (float)fw;
      float targetHeightScale=height / (float)fh;
      if (dw <= dh) {
        scale=targetWidthScale;
        if (targetHeightScale > scale && (int)(targetHeightScale * fw) == width) {
          scale=targetHeightScale;
        }
      }
 else {
        scale=targetHeightScale;
        if (targetWidthScale > scale && (int)(targetWidthScale * fh) == height) {
          scale=targetWidthScale;
        }
      }
      dw=(int)(dw * scale);
      dh=(int)(dh * scale);
      if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
        int tmp=dw;
        dw=dh;
        dh=tmp;
        rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
      }
      if (DEBUG_SCREENSHOT) {
        Slog.i(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
        for (int i=0; i < windows.size(); i++) {
          WindowState win=windows.get(i);
          Slog.i(TAG,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ win.mWinAnimator.mSurfaceLayer);
        }
      }
      rawss=SurfaceControl.screenshot(dw,dh,minLayer,maxLayer);
    }
  }
 while (!screenshotReady && retryCount <= MAX_SCREENSHOT_RETRIES);
  if (retryCount > MAX_SCREENSHOT_RETRIES)   Slog.i(TAG,""String_Node_Str"" + retryCount + ""String_Node_Str""+ appToken+ ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
  if (rawss == null) {
    Slog.w(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
    return null;
  }
  Bitmap bm=Bitmap.createBitmap(width,height,rawss.getConfig());
  Matrix matrix=new Matrix();
  ScreenRotationAnimation.createRotationMatrix(rot,dw,dh,matrix);
  matrix.postTranslate(-FloatMath.ceil(frame.left * scale),-FloatMath.ceil(frame.top * scale));
  Canvas canvas=new Canvas(bm);
  canvas.drawColor(0xFF000000);
  canvas.drawBitmap(rawss,matrix,null);
  canvas.setBitmap(null);
  if (true || DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != Color.BLACK) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG,""String_Node_Str"" + appWin + ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  rawss.recycle();
  return bm;
}"
2246,"@Override public void onCreate(Bundle icicle){
  super.onCreate(icicle);
  mDisconnectedReceiver=new UsbDisconnectedReceiver(this);
  Intent intent=getIntent();
  String fingerprints=intent.getStringExtra(""String_Node_Str"");
  mKey=intent.getStringExtra(""String_Node_Str"");
  if (fingerprints == null || mKey == null) {
    finish();
    return;
  }
  final AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=getString(R.string.usb_debugging_title);
  ap.mIconId=com.android.internal.R.drawable.ic_dialog_usb;
  ap.mMessage=getString(R.string.usb_debugging_message,fingerprints);
  ap.mPositiveButtonText=getString(android.R.string.ok);
  ap.mNegativeButtonText=getString(android.R.string.cancel);
  ap.mPositiveButtonListener=this;
  ap.mNegativeButtonListener=this;
  LayoutInflater inflater=LayoutInflater.from(ap.mContext);
  View checkbox=inflater.inflate(com.android.internal.R.layout.always_use_checkbox,null);
  mAlwaysAllow=(CheckBox)checkbox.findViewById(com.android.internal.R.id.alwaysUse);
  mAlwaysAllow.setText(getString(R.string.usb_debugging_always));
  ap.mView=checkbox;
  setupAlert();
}","@Override public void onCreate(Bundle icicle){
  super.onCreate(icicle);
  if (SystemProperties.getInt(""String_Node_Str"",0) == 0) {
    mDisconnectedReceiver=new UsbDisconnectedReceiver(this);
  }
  Intent intent=getIntent();
  String fingerprints=intent.getStringExtra(""String_Node_Str"");
  mKey=intent.getStringExtra(""String_Node_Str"");
  if (fingerprints == null || mKey == null) {
    finish();
    return;
  }
  final AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=getString(R.string.usb_debugging_title);
  ap.mIconId=com.android.internal.R.drawable.ic_dialog_usb;
  ap.mMessage=getString(R.string.usb_debugging_message,fingerprints);
  ap.mPositiveButtonText=getString(android.R.string.ok);
  ap.mNegativeButtonText=getString(android.R.string.cancel);
  ap.mPositiveButtonListener=this;
  ap.mNegativeButtonListener=this;
  LayoutInflater inflater=LayoutInflater.from(ap.mContext);
  View checkbox=inflater.inflate(com.android.internal.R.layout.always_use_checkbox,null);
  mAlwaysAllow=(CheckBox)checkbox.findViewById(com.android.internal.R.id.alwaysUse);
  mAlwaysAllow.setText(getString(R.string.usb_debugging_always));
  ap.mView=checkbox;
  setupAlert();
}"
2247,"/** 
 * Takes a snapshot of the screen.  In landscape mode this grabs the whole screen. In portrait mode, it grabs the upper region of the screen based on the vertical dimension of the target image.
 * @param displayId the Display to take a screenshot of.
 * @param width the width of the target bitmap
 * @param height the height of the target bitmap
 */
@Override public Bitmap screenshotApplications(IBinder appToken,int displayId,int width,int height){
  if (!checkCallingPermission(android.Manifest.permission.READ_FRAME_BUFFER,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  Bitmap rawss=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  float scale=0;
  int dw, dh;
  int rot=Surface.ROTATION_0;
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  int retryCount=0;
  WindowState appWin=null;
  do {
    if (retryCount++ > 0) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
      }
    }
synchronized (mWindowMap) {
      final DisplayContent displayContent=getDisplayContentLocked(displayId);
      if (displayContent == null) {
        return null;
      }
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      dw=displayInfo.logicalWidth;
      dh=displayInfo.logicalHeight;
      int aboveAppLayer=mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
      aboveAppLayer+=TYPE_LAYER_MULTIPLIER;
      boolean isImeTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
      boolean including=false;
      appWin=null;
      final WindowList windows=displayContent.getWindowList();
      for (int i=windows.size() - 1; i >= 0; i--) {
        WindowState ws=windows.get(i);
        if (!ws.mHasSurface) {
          continue;
        }
        if (ws.mLayer >= aboveAppLayer) {
          continue;
        }
        if (!including && appToken != null) {
          if (!ws.mIsImWindow || !isImeTarget) {
            if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
              continue;
            }
            appWin=ws;
          }
        }
        boolean fullscreen=ws.isFullscreen(dw,dh);
        including=!ws.mIsImWindow && !fullscreen;
        final WindowStateAnimator winAnim=ws.mWinAnimator;
        if (maxLayer < winAnim.mSurfaceLayer) {
          maxLayer=winAnim.mSurfaceLayer;
        }
        if (minLayer > winAnim.mSurfaceLayer) {
          minLayer=winAnim.mSurfaceLayer;
        }
        if (!ws.mIsWallpaper) {
          final Rect wf=ws.mFrame;
          final Rect cr=ws.mContentInsets;
          int left=wf.left + cr.left;
          int top=wf.top + cr.top;
          int right=wf.right - cr.right;
          int bottom=wf.bottom - cr.bottom;
          frame.union(left,top,right,bottom);
        }
        if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw()) {
          screenshotReady=true;
        }
        if (fullscreen) {
          break;
        }
      }
      if (appToken != null && appWin == null) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken);
        return null;
      }
      if (!screenshotReady) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ appWin+ ""String_Node_Str""+ appWin.mWinAnimator.mDrawState);
        continue;
      }
      frame.intersect(0,0,dw,dh);
      if (frame.isEmpty() || maxLayer == 0) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ frame.toShortString()+ ""String_Node_Str""+ maxLayer);
        return null;
      }
      rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
      int fw=frame.width();
      int fh=frame.height();
      float targetWidthScale=width / (float)fw;
      float targetHeightScale=height / (float)fh;
      if (dw <= dh) {
        scale=targetWidthScale;
        if (targetHeightScale > scale && (int)(targetHeightScale * fw) == width) {
          scale=targetHeightScale;
        }
      }
 else {
        scale=targetHeightScale;
        if (targetWidthScale > scale && (int)(targetWidthScale * fh) == height) {
          scale=targetWidthScale;
        }
      }
      dw=(int)(dw * scale);
      dh=(int)(dh * scale);
      if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
        int tmp=dw;
        dw=dh;
        dh=tmp;
        rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
      }
      if (DEBUG_SCREENSHOT) {
        Slog.i(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
        for (int i=0; i < windows.size(); i++) {
          WindowState win=windows.get(i);
          Slog.i(TAG,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ win.mWinAnimator.mSurfaceLayer);
        }
      }
      rawss=SurfaceControl.screenshot(dw,dh,minLayer,maxLayer);
    }
  }
 while (!screenshotReady && retryCount <= MAX_SCREENSHOT_RETRIES);
  if (retryCount > MAX_SCREENSHOT_RETRIES)   Slog.i(TAG,""String_Node_Str"" + retryCount + ""String_Node_Str""+ appToken+ ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
  if (rawss == null) {
    Slog.w(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
    return null;
  }
  Bitmap bm=Bitmap.createBitmap(width,height,rawss.getConfig());
  Matrix matrix=new Matrix();
  ScreenRotationAnimation.createRotationMatrix(rot,dw,dh,matrix);
  matrix.postTranslate(-FloatMath.ceil(frame.left * scale),-FloatMath.ceil(frame.top * scale));
  Canvas canvas=new Canvas(bm);
  canvas.drawBitmap(rawss,matrix,null);
  canvas.setBitmap(null);
  if (true || DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != Color.BLACK) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG,""String_Node_Str"" + appWin + ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  rawss.recycle();
  return bm;
}","/** 
 * Takes a snapshot of the screen.  In landscape mode this grabs the whole screen. In portrait mode, it grabs the upper region of the screen based on the vertical dimension of the target image.
 * @param displayId the Display to take a screenshot of.
 * @param width the width of the target bitmap
 * @param height the height of the target bitmap
 */
@Override public Bitmap screenshotApplications(IBinder appToken,int displayId,int width,int height){
  if (!checkCallingPermission(android.Manifest.permission.READ_FRAME_BUFFER,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  Bitmap rawss=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  float scale=0;
  int dw, dh;
  int rot=Surface.ROTATION_0;
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  int retryCount=0;
  WindowState appWin=null;
  do {
    if (retryCount++ > 0) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
      }
    }
synchronized (mWindowMap) {
      final DisplayContent displayContent=getDisplayContentLocked(displayId);
      if (displayContent == null) {
        return null;
      }
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      dw=displayInfo.logicalWidth;
      dh=displayInfo.logicalHeight;
      int aboveAppLayer=mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
      aboveAppLayer+=TYPE_LAYER_MULTIPLIER;
      boolean isImeTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
      boolean including=false;
      appWin=null;
      final WindowList windows=displayContent.getWindowList();
      for (int i=windows.size() - 1; i >= 0; i--) {
        WindowState ws=windows.get(i);
        if (!ws.mHasSurface) {
          continue;
        }
        if (ws.mLayer >= aboveAppLayer) {
          continue;
        }
        if (!including && appToken != null) {
          if (!ws.mIsImWindow || !isImeTarget) {
            if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
              continue;
            }
            appWin=ws;
          }
        }
        boolean fullscreen=ws.isFullscreen(dw,dh);
        including=!ws.mIsImWindow && !fullscreen;
        final WindowStateAnimator winAnim=ws.mWinAnimator;
        if (maxLayer < winAnim.mSurfaceLayer) {
          maxLayer=winAnim.mSurfaceLayer;
        }
        if (minLayer > winAnim.mSurfaceLayer) {
          minLayer=winAnim.mSurfaceLayer;
        }
        if (!ws.mIsWallpaper) {
          final Rect wf=ws.mFrame;
          final Rect cr=ws.mContentInsets;
          int left=wf.left + cr.left;
          int top=wf.top + cr.top;
          int right=wf.right - cr.right;
          int bottom=wf.bottom - cr.bottom;
          frame.union(left,top,right,bottom);
        }
        if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw()) {
          screenshotReady=true;
        }
        if (fullscreen) {
          break;
        }
      }
      if (appToken != null && appWin == null) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken);
        return null;
      }
      if (!screenshotReady) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ appWin+ ""String_Node_Str""+ appWin.mWinAnimator.mDrawState);
        continue;
      }
      frame.intersect(0,0,dw,dh);
      if (frame.isEmpty() || maxLayer == 0) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ frame.toShortString()+ ""String_Node_Str""+ maxLayer);
        return null;
      }
      rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
      int fw=frame.width();
      int fh=frame.height();
      float targetWidthScale=width / (float)fw;
      float targetHeightScale=height / (float)fh;
      if (dw <= dh) {
        scale=targetWidthScale;
        if (targetHeightScale > scale && (int)(targetHeightScale * fw) == width) {
          scale=targetHeightScale;
        }
      }
 else {
        scale=targetHeightScale;
        if (targetWidthScale > scale && (int)(targetWidthScale * fh) == height) {
          scale=targetWidthScale;
        }
      }
      dw=(int)(dw * scale);
      dh=(int)(dh * scale);
      if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
        int tmp=dw;
        dw=dh;
        dh=tmp;
        rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
      }
      if (DEBUG_SCREENSHOT) {
        Slog.i(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
        for (int i=0; i < windows.size(); i++) {
          WindowState win=windows.get(i);
          Slog.i(TAG,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ win.mWinAnimator.mSurfaceLayer);
        }
      }
      rawss=SurfaceControl.screenshot(dw,dh,minLayer,maxLayer);
    }
  }
 while (!screenshotReady && retryCount <= MAX_SCREENSHOT_RETRIES);
  if (retryCount > MAX_SCREENSHOT_RETRIES)   Slog.i(TAG,""String_Node_Str"" + retryCount + ""String_Node_Str""+ appToken+ ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
  if (rawss == null) {
    Slog.w(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
    return null;
  }
  Bitmap bm=Bitmap.createBitmap(width,height,rawss.getConfig());
  Matrix matrix=new Matrix();
  ScreenRotationAnimation.createRotationMatrix(rot,dw,dh,matrix);
  matrix.postTranslate(-FloatMath.ceil(frame.left * scale),-FloatMath.ceil(frame.top * scale));
  Canvas canvas=new Canvas(bm);
  canvas.drawColor(0xFF000000);
  canvas.drawBitmap(rawss,matrix,null);
  canvas.setBitmap(null);
  if (true || DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != Color.BLACK) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG,""String_Node_Str"" + appWin + ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  rawss.recycle();
  return bm;
}"
2248,"/** 
 * Takes a snapshot of the screen.  In landscape mode this grabs the whole screen. In portrait mode, it grabs the upper region of the screen based on the vertical dimension of the target image.
 * @param displayId the Display to take a screenshot of.
 * @param width the width of the target bitmap
 * @param height the height of the target bitmap
 */
@Override public Bitmap screenshotApplications(IBinder appToken,int displayId,int width,int height){
  if (!checkCallingPermission(android.Manifest.permission.READ_FRAME_BUFFER,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  Bitmap rawss=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  float scale=0;
  int dw, dh;
  int rot=Surface.ROTATION_0;
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  int retryCount=0;
  WindowState appWin=null;
  do {
    if (retryCount++ > 0) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
      }
    }
synchronized (mWindowMap) {
      final DisplayContent displayContent=getDisplayContentLocked(displayId);
      if (displayContent == null) {
        return null;
      }
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      dw=displayInfo.logicalWidth;
      dh=displayInfo.logicalHeight;
      int aboveAppLayer=mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
      aboveAppLayer+=TYPE_LAYER_MULTIPLIER;
      boolean isImeTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
      boolean including=false;
      appWin=null;
      final WindowList windows=displayContent.getWindowList();
      for (int i=windows.size() - 1; i >= 0; i--) {
        WindowState ws=windows.get(i);
        if (!ws.mHasSurface) {
          continue;
        }
        if (ws.mLayer >= aboveAppLayer) {
          continue;
        }
        if (!including && appToken != null) {
          if (!ws.mIsImWindow || !isImeTarget) {
            if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
              continue;
            }
            appWin=ws;
          }
        }
        boolean fullscreen=ws.isFullscreen(dw,dh);
        including=!ws.mIsImWindow && !fullscreen;
        final WindowStateAnimator winAnim=ws.mWinAnimator;
        if (maxLayer < winAnim.mSurfaceLayer) {
          maxLayer=winAnim.mSurfaceLayer;
        }
        if (minLayer > winAnim.mSurfaceLayer) {
          minLayer=winAnim.mSurfaceLayer;
        }
        if (!ws.mIsWallpaper) {
          final Rect wf=ws.mFrame;
          final Rect cr=ws.mContentInsets;
          int left=wf.left + cr.left;
          int top=wf.top + cr.top;
          int right=wf.right - cr.right;
          int bottom=wf.bottom - cr.bottom;
          frame.union(left,top,right,bottom);
        }
        if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw()) {
          screenshotReady=true;
        }
        if (fullscreen) {
          break;
        }
      }
      if (appToken != null && appWin == null) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken);
        return null;
      }
      if (!screenshotReady) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ appWin+ ""String_Node_Str""+ appWin.mWinAnimator.mDrawState);
        continue;
      }
      frame.intersect(0,0,dw,dh);
      if (frame.isEmpty() || maxLayer == 0) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ frame.toShortString()+ ""String_Node_Str""+ maxLayer);
        return null;
      }
      rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
      int fw=frame.width();
      int fh=frame.height();
      float targetWidthScale=width / (float)fw;
      float targetHeightScale=height / (float)fh;
      if (dw <= dh) {
        scale=targetWidthScale;
        if (targetHeightScale > scale && (int)(targetHeightScale * fw) == width) {
          scale=targetHeightScale;
        }
      }
 else {
        scale=targetHeightScale;
        if (targetWidthScale > scale && (int)(targetWidthScale * fh) == height) {
          scale=targetWidthScale;
        }
      }
      dw=(int)(dw * scale);
      dh=(int)(dh * scale);
      if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
        int tmp=dw;
        dw=dh;
        dh=tmp;
        rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
      }
      if (DEBUG_SCREENSHOT) {
        Slog.i(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
        for (int i=0; i < windows.size(); i++) {
          WindowState win=windows.get(i);
          Slog.i(TAG,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ win.mWinAnimator.mSurfaceLayer);
        }
      }
      rawss=SurfaceControl.screenshot(dw,dh,minLayer,maxLayer);
    }
  }
 while (!screenshotReady && retryCount <= MAX_SCREENSHOT_RETRIES);
  if (retryCount > MAX_SCREENSHOT_RETRIES)   Slog.i(TAG,""String_Node_Str"" + retryCount + ""String_Node_Str""+ appToken+ ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
  if (rawss == null) {
    Slog.w(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
    return null;
  }
  Bitmap bm=Bitmap.createBitmap(width,height,rawss.getConfig());
  Matrix matrix=new Matrix();
  ScreenRotationAnimation.createRotationMatrix(rot,dw,dh,matrix);
  matrix.postTranslate(-FloatMath.ceil(frame.left * scale),-FloatMath.ceil(frame.top * scale));
  Canvas canvas=new Canvas(bm);
  canvas.drawBitmap(rawss,matrix,null);
  canvas.setBitmap(null);
  if (true || DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != Color.BLACK) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG,""String_Node_Str"" + appWin + ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  rawss.recycle();
  return bm;
}","/** 
 * Takes a snapshot of the screen.  In landscape mode this grabs the whole screen. In portrait mode, it grabs the upper region of the screen based on the vertical dimension of the target image.
 * @param displayId the Display to take a screenshot of.
 * @param width the width of the target bitmap
 * @param height the height of the target bitmap
 */
@Override public Bitmap screenshotApplications(IBinder appToken,int displayId,int width,int height){
  if (!checkCallingPermission(android.Manifest.permission.READ_FRAME_BUFFER,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  Bitmap rawss=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  float scale=0;
  int dw, dh;
  int rot=Surface.ROTATION_0;
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  int retryCount=0;
  WindowState appWin=null;
  do {
    if (retryCount++ > 0) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
      }
    }
synchronized (mWindowMap) {
      final DisplayContent displayContent=getDisplayContentLocked(displayId);
      if (displayContent == null) {
        return null;
      }
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      dw=displayInfo.logicalWidth;
      dh=displayInfo.logicalHeight;
      int aboveAppLayer=mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
      aboveAppLayer+=TYPE_LAYER_MULTIPLIER;
      boolean isImeTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
      boolean including=false;
      appWin=null;
      final WindowList windows=displayContent.getWindowList();
      for (int i=windows.size() - 1; i >= 0; i--) {
        WindowState ws=windows.get(i);
        if (!ws.mHasSurface) {
          continue;
        }
        if (ws.mLayer >= aboveAppLayer) {
          continue;
        }
        if (!including && appToken != null) {
          if (!ws.mIsImWindow || !isImeTarget) {
            if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
              continue;
            }
            appWin=ws;
          }
        }
        boolean fullscreen=ws.isFullscreen(dw,dh);
        including=!ws.mIsImWindow && !fullscreen;
        final WindowStateAnimator winAnim=ws.mWinAnimator;
        if (maxLayer < winAnim.mSurfaceLayer) {
          maxLayer=winAnim.mSurfaceLayer;
        }
        if (minLayer > winAnim.mSurfaceLayer) {
          minLayer=winAnim.mSurfaceLayer;
        }
        if (!ws.mIsWallpaper) {
          final Rect wf=ws.mFrame;
          final Rect cr=ws.mContentInsets;
          int left=wf.left + cr.left;
          int top=wf.top + cr.top;
          int right=wf.right - cr.right;
          int bottom=wf.bottom - cr.bottom;
          frame.union(left,top,right,bottom);
        }
        if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw()) {
          screenshotReady=true;
        }
        if (fullscreen) {
          break;
        }
      }
      if (appToken != null && appWin == null) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken);
        return null;
      }
      if (!screenshotReady) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ appWin+ ""String_Node_Str""+ appWin.mWinAnimator.mDrawState);
        continue;
      }
      frame.intersect(0,0,dw,dh);
      if (frame.isEmpty() || maxLayer == 0) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ frame.toShortString()+ ""String_Node_Str""+ maxLayer);
        return null;
      }
      rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
      int fw=frame.width();
      int fh=frame.height();
      float targetWidthScale=width / (float)fw;
      float targetHeightScale=height / (float)fh;
      if (dw <= dh) {
        scale=targetWidthScale;
        if (targetHeightScale > scale && (int)(targetHeightScale * fw) == width) {
          scale=targetHeightScale;
        }
      }
 else {
        scale=targetHeightScale;
        if (targetWidthScale > scale && (int)(targetWidthScale * fh) == height) {
          scale=targetWidthScale;
        }
      }
      dw=(int)(dw * scale);
      dh=(int)(dh * scale);
      if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
        int tmp=dw;
        dw=dh;
        dh=tmp;
        rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
      }
      if (DEBUG_SCREENSHOT) {
        Slog.i(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
        for (int i=0; i < windows.size(); i++) {
          WindowState win=windows.get(i);
          Slog.i(TAG,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ win.mWinAnimator.mSurfaceLayer);
        }
      }
      rawss=SurfaceControl.screenshot(dw,dh,minLayer,maxLayer);
    }
  }
 while (!screenshotReady && retryCount <= MAX_SCREENSHOT_RETRIES);
  if (retryCount > MAX_SCREENSHOT_RETRIES)   Slog.i(TAG,""String_Node_Str"" + retryCount + ""String_Node_Str""+ appToken+ ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
  if (rawss == null) {
    Slog.w(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
    return null;
  }
  Bitmap bm=Bitmap.createBitmap(width,height,rawss.getConfig());
  Matrix matrix=new Matrix();
  ScreenRotationAnimation.createRotationMatrix(rot,dw,dh,matrix);
  matrix.postTranslate(-FloatMath.ceil(frame.left * scale),-FloatMath.ceil(frame.top * scale));
  Canvas canvas=new Canvas(bm);
  canvas.drawColor(0xFF000000);
  canvas.drawBitmap(rawss,matrix,null);
  canvas.setBitmap(null);
  if (true || DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != Color.BLACK) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG,""String_Node_Str"" + appWin + ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  rawss.recycle();
  return bm;
}"
2249,"@Override public void onCreate(Bundle icicle){
  super.onCreate(icicle);
  mDisconnectedReceiver=new UsbDisconnectedReceiver(this);
  Intent intent=getIntent();
  String fingerprints=intent.getStringExtra(""String_Node_Str"");
  mKey=intent.getStringExtra(""String_Node_Str"");
  if (fingerprints == null || mKey == null) {
    finish();
    return;
  }
  final AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=getString(R.string.usb_debugging_title);
  ap.mIconId=com.android.internal.R.drawable.ic_dialog_usb;
  ap.mMessage=getString(R.string.usb_debugging_message,fingerprints);
  ap.mPositiveButtonText=getString(android.R.string.ok);
  ap.mNegativeButtonText=getString(android.R.string.cancel);
  ap.mPositiveButtonListener=this;
  ap.mNegativeButtonListener=this;
  LayoutInflater inflater=LayoutInflater.from(ap.mContext);
  View checkbox=inflater.inflate(com.android.internal.R.layout.always_use_checkbox,null);
  mAlwaysAllow=(CheckBox)checkbox.findViewById(com.android.internal.R.id.alwaysUse);
  mAlwaysAllow.setText(getString(R.string.usb_debugging_always));
  ap.mView=checkbox;
  setupAlert();
}","@Override public void onCreate(Bundle icicle){
  super.onCreate(icicle);
  if (SystemProperties.getInt(""String_Node_Str"",0) == 0) {
    mDisconnectedReceiver=new UsbDisconnectedReceiver(this);
  }
  Intent intent=getIntent();
  String fingerprints=intent.getStringExtra(""String_Node_Str"");
  mKey=intent.getStringExtra(""String_Node_Str"");
  if (fingerprints == null || mKey == null) {
    finish();
    return;
  }
  final AlertController.AlertParams ap=mAlertParams;
  ap.mTitle=getString(R.string.usb_debugging_title);
  ap.mIconId=com.android.internal.R.drawable.ic_dialog_usb;
  ap.mMessage=getString(R.string.usb_debugging_message,fingerprints);
  ap.mPositiveButtonText=getString(android.R.string.ok);
  ap.mNegativeButtonText=getString(android.R.string.cancel);
  ap.mPositiveButtonListener=this;
  ap.mNegativeButtonListener=this;
  LayoutInflater inflater=LayoutInflater.from(ap.mContext);
  View checkbox=inflater.inflate(com.android.internal.R.layout.always_use_checkbox,null);
  mAlwaysAllow=(CheckBox)checkbox.findViewById(com.android.internal.R.id.alwaysUse);
  mAlwaysAllow.setText(getString(R.string.usb_debugging_always));
  ap.mView=checkbox;
  setupAlert();
}"
2250,"/** 
 * Takes a snapshot of the screen.  In landscape mode this grabs the whole screen. In portrait mode, it grabs the upper region of the screen based on the vertical dimension of the target image.
 * @param displayId the Display to take a screenshot of.
 * @param width the width of the target bitmap
 * @param height the height of the target bitmap
 */
@Override public Bitmap screenshotApplications(IBinder appToken,int displayId,int width,int height){
  if (!checkCallingPermission(android.Manifest.permission.READ_FRAME_BUFFER,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  Bitmap rawss=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  float scale=0;
  int dw, dh;
  int rot=Surface.ROTATION_0;
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  int retryCount=0;
  WindowState appWin=null;
  do {
    if (retryCount++ > 0) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
      }
    }
synchronized (mWindowMap) {
      final DisplayContent displayContent=getDisplayContentLocked(displayId);
      if (displayContent == null) {
        return null;
      }
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      dw=displayInfo.logicalWidth;
      dh=displayInfo.logicalHeight;
      int aboveAppLayer=mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
      aboveAppLayer+=TYPE_LAYER_MULTIPLIER;
      boolean isImeTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
      boolean including=false;
      appWin=null;
      final WindowList windows=displayContent.getWindowList();
      for (int i=windows.size() - 1; i >= 0; i--) {
        WindowState ws=windows.get(i);
        if (!ws.mHasSurface) {
          continue;
        }
        if (ws.mLayer >= aboveAppLayer) {
          continue;
        }
        if (!including && appToken != null) {
          if (!ws.mIsImWindow || !isImeTarget) {
            if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
              continue;
            }
            appWin=ws;
          }
        }
        boolean fullscreen=ws.isFullscreen(dw,dh);
        including=!ws.mIsImWindow && !fullscreen;
        final WindowStateAnimator winAnim=ws.mWinAnimator;
        if (maxLayer < winAnim.mSurfaceLayer) {
          maxLayer=winAnim.mSurfaceLayer;
        }
        if (minLayer > winAnim.mSurfaceLayer) {
          minLayer=winAnim.mSurfaceLayer;
        }
        if (!ws.mIsWallpaper) {
          final Rect wf=ws.mFrame;
          final Rect cr=ws.mContentInsets;
          int left=wf.left + cr.left;
          int top=wf.top + cr.top;
          int right=wf.right - cr.right;
          int bottom=wf.bottom - cr.bottom;
          frame.union(left,top,right,bottom);
        }
        if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw()) {
          screenshotReady=true;
        }
        if (fullscreen) {
          break;
        }
      }
      if (appToken != null && appWin == null) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken);
        return null;
      }
      if (!screenshotReady) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ appWin+ ""String_Node_Str""+ appWin.mWinAnimator.mDrawState);
        continue;
      }
      frame.intersect(0,0,dw,dh);
      if (frame.isEmpty() || maxLayer == 0) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ frame.toShortString()+ ""String_Node_Str""+ maxLayer);
        return null;
      }
      rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
      int fw=frame.width();
      int fh=frame.height();
      float targetWidthScale=width / (float)fw;
      float targetHeightScale=height / (float)fh;
      if (dw <= dh) {
        scale=targetWidthScale;
        if (targetHeightScale > scale && (int)(targetHeightScale * fw) == width) {
          scale=targetHeightScale;
        }
      }
 else {
        scale=targetHeightScale;
        if (targetWidthScale > scale && (int)(targetWidthScale * fh) == height) {
          scale=targetWidthScale;
        }
      }
      dw=(int)(dw * scale);
      dh=(int)(dh * scale);
      if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
        int tmp=dw;
        dw=dh;
        dh=tmp;
        rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
      }
      if (DEBUG_SCREENSHOT) {
        Slog.i(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
        for (int i=0; i < windows.size(); i++) {
          WindowState win=windows.get(i);
          Slog.i(TAG,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ win.mWinAnimator.mSurfaceLayer);
        }
      }
      rawss=SurfaceControl.screenshot(dw,dh,minLayer,maxLayer);
    }
  }
 while (!screenshotReady && retryCount <= MAX_SCREENSHOT_RETRIES);
  if (retryCount > MAX_SCREENSHOT_RETRIES)   Slog.i(TAG,""String_Node_Str"" + retryCount + ""String_Node_Str""+ appToken+ ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
  if (rawss == null) {
    Slog.w(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
    return null;
  }
  Bitmap bm=Bitmap.createBitmap(width,height,rawss.getConfig());
  Matrix matrix=new Matrix();
  ScreenRotationAnimation.createRotationMatrix(rot,dw,dh,matrix);
  matrix.postTranslate(-FloatMath.ceil(frame.left * scale),-FloatMath.ceil(frame.top * scale));
  Canvas canvas=new Canvas(bm);
  canvas.drawBitmap(rawss,matrix,null);
  canvas.setBitmap(null);
  if (true || DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != Color.BLACK) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG,""String_Node_Str"" + appWin + ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  rawss.recycle();
  return bm;
}","/** 
 * Takes a snapshot of the screen.  In landscape mode this grabs the whole screen. In portrait mode, it grabs the upper region of the screen based on the vertical dimension of the target image.
 * @param displayId the Display to take a screenshot of.
 * @param width the width of the target bitmap
 * @param height the height of the target bitmap
 */
@Override public Bitmap screenshotApplications(IBinder appToken,int displayId,int width,int height){
  if (!checkCallingPermission(android.Manifest.permission.READ_FRAME_BUFFER,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  Bitmap rawss=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  float scale=0;
  int dw, dh;
  int rot=Surface.ROTATION_0;
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  int retryCount=0;
  WindowState appWin=null;
  do {
    if (retryCount++ > 0) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
      }
    }
synchronized (mWindowMap) {
      final DisplayContent displayContent=getDisplayContentLocked(displayId);
      if (displayContent == null) {
        return null;
      }
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      dw=displayInfo.logicalWidth;
      dh=displayInfo.logicalHeight;
      int aboveAppLayer=mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
      aboveAppLayer+=TYPE_LAYER_MULTIPLIER;
      boolean isImeTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
      boolean including=false;
      appWin=null;
      final WindowList windows=displayContent.getWindowList();
      for (int i=windows.size() - 1; i >= 0; i--) {
        WindowState ws=windows.get(i);
        if (!ws.mHasSurface) {
          continue;
        }
        if (ws.mLayer >= aboveAppLayer) {
          continue;
        }
        if (!including && appToken != null) {
          if (!ws.mIsImWindow || !isImeTarget) {
            if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
              continue;
            }
            appWin=ws;
          }
        }
        boolean fullscreen=ws.isFullscreen(dw,dh);
        including=!ws.mIsImWindow && !fullscreen;
        final WindowStateAnimator winAnim=ws.mWinAnimator;
        if (maxLayer < winAnim.mSurfaceLayer) {
          maxLayer=winAnim.mSurfaceLayer;
        }
        if (minLayer > winAnim.mSurfaceLayer) {
          minLayer=winAnim.mSurfaceLayer;
        }
        if (!ws.mIsWallpaper) {
          final Rect wf=ws.mFrame;
          final Rect cr=ws.mContentInsets;
          int left=wf.left + cr.left;
          int top=wf.top + cr.top;
          int right=wf.right - cr.right;
          int bottom=wf.bottom - cr.bottom;
          frame.union(left,top,right,bottom);
        }
        if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw()) {
          screenshotReady=true;
        }
        if (fullscreen) {
          break;
        }
      }
      if (appToken != null && appWin == null) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken);
        return null;
      }
      if (!screenshotReady) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ appWin+ ""String_Node_Str""+ appWin.mWinAnimator.mDrawState);
        continue;
      }
      frame.intersect(0,0,dw,dh);
      if (frame.isEmpty() || maxLayer == 0) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,""String_Node_Str"" + appToken + ""String_Node_Str""+ frame.toShortString()+ ""String_Node_Str""+ maxLayer);
        return null;
      }
      rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
      int fw=frame.width();
      int fh=frame.height();
      float targetWidthScale=width / (float)fw;
      float targetHeightScale=height / (float)fh;
      if (dw <= dh) {
        scale=targetWidthScale;
        if (targetHeightScale > scale && (int)(targetHeightScale * fw) == width) {
          scale=targetHeightScale;
        }
      }
 else {
        scale=targetHeightScale;
        if (targetWidthScale > scale && (int)(targetWidthScale * fh) == height) {
          scale=targetWidthScale;
        }
      }
      dw=(int)(dw * scale);
      dh=(int)(dh * scale);
      if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
        int tmp=dw;
        dw=dh;
        dh=tmp;
        rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
      }
      if (DEBUG_SCREENSHOT) {
        Slog.i(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
        for (int i=0; i < windows.size(); i++) {
          WindowState win=windows.get(i);
          Slog.i(TAG,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ win.mWinAnimator.mSurfaceLayer);
        }
      }
      rawss=SurfaceControl.screenshot(dw,dh,minLayer,maxLayer);
    }
  }
 while (!screenshotReady && retryCount <= MAX_SCREENSHOT_RETRIES);
  if (retryCount > MAX_SCREENSHOT_RETRIES)   Slog.i(TAG,""String_Node_Str"" + retryCount + ""String_Node_Str""+ appToken+ ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
  if (rawss == null) {
    Slog.w(TAG,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
    return null;
  }
  Bitmap bm=Bitmap.createBitmap(width,height,rawss.getConfig());
  Matrix matrix=new Matrix();
  ScreenRotationAnimation.createRotationMatrix(rot,dw,dh,matrix);
  matrix.postTranslate(-FloatMath.ceil(frame.left * scale),-FloatMath.ceil(frame.top * scale));
  Canvas canvas=new Canvas(bm);
  canvas.drawColor(0xFF000000);
  canvas.drawBitmap(rawss,matrix,null);
  canvas.setBitmap(null);
  if (true || DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != Color.BLACK) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG,""String_Node_Str"" + appWin + ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  rawss.recycle();
  return bm;
}"
2251,"/** 
 * See   {@link WebView#destroy()}
 */
@Override public void destroy(){
  if (mWebView.getViewRootImpl() != null) {
    Log.e(LOGTAG,""String_Node_Str"");
  }
  ensureFunctorDetached();
  destroyJava();
  destroyNative();
}","/** 
 * See   {@link WebView#destroy()}
 */
@Override public void destroy(){
  if (mWebView.getViewRootImpl() != null) {
    Log.e(LOGTAG,Log.getStackTraceString(new Throwable(""String_Node_Str"")));
  }
  ensureFunctorDetached();
  destroyJava();
  destroyNative();
}"
2252,"/** 
 * See   {@link WebView#destroy()}
 */
@Override public void destroy(){
  if (mWebView.getViewRootImpl() != null) {
    Log.e(LOGTAG,""String_Node_Str"");
  }
  ensureFunctorDetached();
  destroyJava();
  destroyNative();
}","/** 
 * See   {@link WebView#destroy()}
 */
@Override public void destroy(){
  if (mWebView.getViewRootImpl() != null) {
    Log.e(LOGTAG,Log.getStackTraceString(new Throwable(""String_Node_Str"")));
  }
  ensureFunctorDetached();
  destroyJava();
  destroyNative();
}"
2253,"/** 
 * See   {@link WebView#destroy()}
 */
@Override public void destroy(){
  if (mWebView.getViewRootImpl() != null) {
    Log.e(LOGTAG,""String_Node_Str"");
  }
  ensureFunctorDetached();
  destroyJava();
  destroyNative();
}","/** 
 * See   {@link WebView#destroy()}
 */
@Override public void destroy(){
  if (mWebView.getViewRootImpl() != null) {
    Log.e(LOGTAG,Log.getStackTraceString(new Throwable(""String_Node_Str"")));
  }
  ensureFunctorDetached();
  destroyJava();
  destroyNative();
}"
2254,"private void measureChildWithMargins2(View child,int parentWidthSpec,int parentHeightSpec,int childWidth,int childHeight){
  int childWidthSpec=getChildMeasureSpec(parentWidthSpec,mPaddingLeft + mPaddingRight + getTotalMargin(child,true),childWidth);
  int childHeightSpec=getChildMeasureSpec(parentHeightSpec,mPaddingTop + mPaddingBottom + getTotalMargin(child,false),childHeight);
  child.measure(childWidthSpec,childHeightSpec);
}","private void measureChildWithMargins2(View child,int parentWidthSpec,int parentHeightSpec,int childWidth,int childHeight){
  int childWidthSpec=getChildMeasureSpec(parentWidthSpec,getTotalMargin(child,true),childWidth);
  int childHeightSpec=getChildMeasureSpec(parentHeightSpec,getTotalMargin(child,false),childHeight);
  child.measure(childWidthSpec,childHeightSpec);
}"
2255,"@Override protected void onMeasure(int widthSpec,int heightSpec){
  consistencyCheck();
  invalidateValues();
  measureChildrenWithMargins(widthSpec,heightSpec,true);
  int width, height;
  if (orientation == HORIZONTAL) {
    width=horizontalAxis.getMeasure(widthSpec);
    measureChildrenWithMargins(widthSpec,heightSpec,false);
    height=verticalAxis.getMeasure(heightSpec);
  }
 else {
    height=verticalAxis.getMeasure(heightSpec);
    measureChildrenWithMargins(widthSpec,heightSpec,false);
    width=horizontalAxis.getMeasure(widthSpec);
  }
  int hPadding=getPaddingLeft() + getPaddingRight();
  int vPadding=getPaddingTop() + getPaddingBottom();
  int measuredWidth=Math.max(hPadding + width,getSuggestedMinimumWidth());
  int measuredHeight=Math.max(vPadding + height,getSuggestedMinimumHeight());
  setMeasuredDimension(resolveSizeAndState(measuredWidth,widthSpec,0),resolveSizeAndState(measuredHeight,heightSpec,0));
}","@Override protected void onMeasure(int widthSpec,int heightSpec){
  consistencyCheck();
  invalidateValues();
  int hPadding=getPaddingLeft() + getPaddingRight();
  int vPadding=getPaddingTop() + getPaddingBottom();
  int widthSpecSansPadding=adjust(widthSpec,-hPadding);
  int heightSpecSansPadding=adjust(heightSpec,-vPadding);
  measureChildrenWithMargins(widthSpecSansPadding,heightSpecSansPadding,true);
  int widthSansPadding;
  int heightSansPadding;
  if (orientation == HORIZONTAL) {
    widthSansPadding=horizontalAxis.getMeasure(widthSpecSansPadding);
    measureChildrenWithMargins(widthSpecSansPadding,heightSpecSansPadding,false);
    heightSansPadding=verticalAxis.getMeasure(heightSpecSansPadding);
  }
 else {
    heightSansPadding=verticalAxis.getMeasure(heightSpecSansPadding);
    measureChildrenWithMargins(widthSpecSansPadding,heightSpecSansPadding,false);
    widthSansPadding=horizontalAxis.getMeasure(widthSpecSansPadding);
  }
  int measuredWidth=Math.max(widthSansPadding + hPadding,getSuggestedMinimumWidth());
  int measuredHeight=Math.max(heightSansPadding + vPadding,getSuggestedMinimumHeight());
  setMeasuredDimension(resolveSizeAndState(measuredWidth,widthSpec,0),resolveSizeAndState(measuredHeight,heightSpec,0));
}"
2256,"private void measureChildWithMargins2(View child,int parentWidthSpec,int parentHeightSpec,int childWidth,int childHeight){
  int childWidthSpec=getChildMeasureSpec(parentWidthSpec,mPaddingLeft + mPaddingRight + getTotalMargin(child,true),childWidth);
  int childHeightSpec=getChildMeasureSpec(parentHeightSpec,mPaddingTop + mPaddingBottom + getTotalMargin(child,false),childHeight);
  child.measure(childWidthSpec,childHeightSpec);
}","private void measureChildWithMargins2(View child,int parentWidthSpec,int parentHeightSpec,int childWidth,int childHeight){
  int childWidthSpec=getChildMeasureSpec(parentWidthSpec,getTotalMargin(child,true),childWidth);
  int childHeightSpec=getChildMeasureSpec(parentHeightSpec,getTotalMargin(child,false),childHeight);
  child.measure(childWidthSpec,childHeightSpec);
}"
2257,"@Override protected void onMeasure(int widthSpec,int heightSpec){
  consistencyCheck();
  invalidateValues();
  measureChildrenWithMargins(widthSpec,heightSpec,true);
  int width, height;
  if (orientation == HORIZONTAL) {
    width=horizontalAxis.getMeasure(widthSpec);
    measureChildrenWithMargins(widthSpec,heightSpec,false);
    height=verticalAxis.getMeasure(heightSpec);
  }
 else {
    height=verticalAxis.getMeasure(heightSpec);
    measureChildrenWithMargins(widthSpec,heightSpec,false);
    width=horizontalAxis.getMeasure(widthSpec);
  }
  int hPadding=getPaddingLeft() + getPaddingRight();
  int vPadding=getPaddingTop() + getPaddingBottom();
  int measuredWidth=Math.max(hPadding + width,getSuggestedMinimumWidth());
  int measuredHeight=Math.max(vPadding + height,getSuggestedMinimumHeight());
  setMeasuredDimension(resolveSizeAndState(measuredWidth,widthSpec,0),resolveSizeAndState(measuredHeight,heightSpec,0));
}","@Override protected void onMeasure(int widthSpec,int heightSpec){
  consistencyCheck();
  invalidateValues();
  int hPadding=getPaddingLeft() + getPaddingRight();
  int vPadding=getPaddingTop() + getPaddingBottom();
  int widthSpecSansPadding=adjust(widthSpec,-hPadding);
  int heightSpecSansPadding=adjust(heightSpec,-vPadding);
  measureChildrenWithMargins(widthSpecSansPadding,heightSpecSansPadding,true);
  int widthSansPadding;
  int heightSansPadding;
  if (orientation == HORIZONTAL) {
    widthSansPadding=horizontalAxis.getMeasure(widthSpecSansPadding);
    measureChildrenWithMargins(widthSpecSansPadding,heightSpecSansPadding,false);
    heightSansPadding=verticalAxis.getMeasure(heightSpecSansPadding);
  }
 else {
    heightSansPadding=verticalAxis.getMeasure(heightSpecSansPadding);
    measureChildrenWithMargins(widthSpecSansPadding,heightSpecSansPadding,false);
    widthSansPadding=horizontalAxis.getMeasure(widthSpecSansPadding);
  }
  int measuredWidth=Math.max(widthSansPadding + hPadding,getSuggestedMinimumWidth());
  int measuredHeight=Math.max(heightSansPadding + vPadding,getSuggestedMinimumHeight());
  setMeasuredDimension(resolveSizeAndState(measuredWidth,widthSpec,0),resolveSizeAndState(measuredHeight,heightSpec,0));
}"
2258,"private void measureChildWithMargins2(View child,int parentWidthSpec,int parentHeightSpec,int childWidth,int childHeight){
  int childWidthSpec=getChildMeasureSpec(parentWidthSpec,mPaddingLeft + mPaddingRight + getTotalMargin(child,true),childWidth);
  int childHeightSpec=getChildMeasureSpec(parentHeightSpec,mPaddingTop + mPaddingBottom + getTotalMargin(child,false),childHeight);
  child.measure(childWidthSpec,childHeightSpec);
}","private void measureChildWithMargins2(View child,int parentWidthSpec,int parentHeightSpec,int childWidth,int childHeight){
  int childWidthSpec=getChildMeasureSpec(parentWidthSpec,getTotalMargin(child,true),childWidth);
  int childHeightSpec=getChildMeasureSpec(parentHeightSpec,getTotalMargin(child,false),childHeight);
  child.measure(childWidthSpec,childHeightSpec);
}"
2259,"@Override protected void onMeasure(int widthSpec,int heightSpec){
  consistencyCheck();
  invalidateValues();
  measureChildrenWithMargins(widthSpec,heightSpec,true);
  int width, height;
  if (orientation == HORIZONTAL) {
    width=horizontalAxis.getMeasure(widthSpec);
    measureChildrenWithMargins(widthSpec,heightSpec,false);
    height=verticalAxis.getMeasure(heightSpec);
  }
 else {
    height=verticalAxis.getMeasure(heightSpec);
    measureChildrenWithMargins(widthSpec,heightSpec,false);
    width=horizontalAxis.getMeasure(widthSpec);
  }
  int hPadding=getPaddingLeft() + getPaddingRight();
  int vPadding=getPaddingTop() + getPaddingBottom();
  int measuredWidth=Math.max(hPadding + width,getSuggestedMinimumWidth());
  int measuredHeight=Math.max(vPadding + height,getSuggestedMinimumHeight());
  setMeasuredDimension(resolveSizeAndState(measuredWidth,widthSpec,0),resolveSizeAndState(measuredHeight,heightSpec,0));
}","@Override protected void onMeasure(int widthSpec,int heightSpec){
  consistencyCheck();
  invalidateValues();
  int hPadding=getPaddingLeft() + getPaddingRight();
  int vPadding=getPaddingTop() + getPaddingBottom();
  int widthSpecSansPadding=adjust(widthSpec,-hPadding);
  int heightSpecSansPadding=adjust(heightSpec,-vPadding);
  measureChildrenWithMargins(widthSpecSansPadding,heightSpecSansPadding,true);
  int widthSansPadding;
  int heightSansPadding;
  if (orientation == HORIZONTAL) {
    widthSansPadding=horizontalAxis.getMeasure(widthSpecSansPadding);
    measureChildrenWithMargins(widthSpecSansPadding,heightSpecSansPadding,false);
    heightSansPadding=verticalAxis.getMeasure(heightSpecSansPadding);
  }
 else {
    heightSansPadding=verticalAxis.getMeasure(heightSpecSansPadding);
    measureChildrenWithMargins(widthSpecSansPadding,heightSpecSansPadding,false);
    widthSansPadding=horizontalAxis.getMeasure(widthSpecSansPadding);
  }
  int measuredWidth=Math.max(widthSansPadding + hPadding,getSuggestedMinimumWidth());
  int measuredHeight=Math.max(heightSansPadding + vPadding,getSuggestedMinimumHeight());
  setMeasuredDimension(resolveSizeAndState(measuredWidth,widthSpec,0),resolveSizeAndState(measuredHeight,heightSpec,0));
}"
2260,"/** 
 * See   {@link WebView#destroy()}
 */
@Override public void destroy(){
  if (mWebView.getViewRootImpl() != null) {
    Log.e(LOGTAG,""String_Node_Str"");
  }
  ensureFunctorDetached();
  destroyJava();
  destroyNative();
}","/** 
 * See   {@link WebView#destroy()}
 */
@Override public void destroy(){
  if (mWebView.getViewRootImpl() != null) {
    Log.e(LOGTAG,Log.getStackTraceString(new Throwable(""String_Node_Str"")));
  }
  ensureFunctorDetached();
  destroyJava();
  destroyNative();
}"
2261,"public void draw(Canvas canvas){
  if (mState == STATE_NONE) {
    return;
  }
  final int y=mThumbY;
  final int viewWidth=mList.getWidth();
  final FastScroller.ScrollFade scrollFade=mScrollFade;
  int alpha=-1;
  if (mState == STATE_EXIT) {
    alpha=scrollFade.getAlpha();
    if (alpha < ScrollFade.ALPHA_MAX / 2) {
      mThumbDrawable.setAlpha(alpha * 2);
    }
    int left=0;
switch (mPosition) {
case View.SCROLLBAR_POSITION_RIGHT:
      left=viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
    break;
case View.SCROLLBAR_POSITION_LEFT:
  left=-mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
break;
}
mThumbDrawable.setBounds(left,0,left + mThumbW,mThumbH);
mChangedBounds=true;
}
if (mTrackDrawable != null) {
final Rect thumbBounds=mThumbDrawable.getBounds();
final int left=thumbBounds.left;
final int halfThumbHeight=(thumbBounds.bottom - thumbBounds.top) / 2;
final int trackWidth=mTrackDrawable.getIntrinsicWidth();
final int trackLeft=(left + mThumbW / 2) - trackWidth / 2;
mTrackDrawable.setBounds(trackLeft,halfThumbHeight,trackLeft + trackWidth,mList.getHeight() - halfThumbHeight);
mTrackDrawable.draw(canvas);
}
canvas.translate(0,y);
mThumbDrawable.draw(canvas);
canvas.translate(0,-y);
if (mState == STATE_DRAGGING && mDrawOverlay) {
if (mOverlayPosition == OVERLAY_AT_THUMB) {
int left=0;
switch (mPosition) {
default :
case View.SCROLLBAR_POSITION_RIGHT:
left=Math.max(0,mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
break;
case View.SCROLLBAR_POSITION_LEFT:
left=Math.min(mThumbDrawable.getBounds().right + mThumbW,mList.getWidth() - mOverlaySize);
break;
}
int top=Math.max(0,Math.min(y + (mThumbH - mOverlaySize) / 2,mList.getHeight() - mOverlaySize));
final RectF pos=mOverlayPos;
pos.left=left;
pos.right=pos.left + mOverlaySize;
pos.top=top;
pos.bottom=pos.top + mOverlaySize;
if (mOverlayDrawable != null) {
mOverlayDrawable.setBounds((int)pos.left,(int)pos.top,(int)pos.right,(int)pos.bottom);
}
}
mOverlayDrawable.draw(canvas);
final Paint paint=mPaint;
float descent=paint.descent();
final RectF rectF=mOverlayPos;
final Rect tmpRect=mTmpRect;
mOverlayDrawable.getPadding(tmpRect);
final int hOff=(tmpRect.right - tmpRect.left) / 2;
final int vOff=(tmpRect.bottom - tmpRect.top) / 2;
canvas.drawText(mSectionText,(int)(rectF.left + rectF.right) / 2 - hOff,(int)(rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff,paint);
}
 else if (mState == STATE_EXIT) {
if (alpha == 0) {
setState(STATE_NONE);
}
 else if (mTrackDrawable != null) {
mList.invalidate(viewWidth - mThumbW,0,viewWidth,mList.getHeight());
}
 else {
mList.invalidate(viewWidth - mThumbW,y,viewWidth,y + mThumbH);
}
}
}","public void draw(Canvas canvas){
  if (mState == STATE_NONE) {
    return;
  }
  final int y=mThumbY;
  final int viewWidth=mList.getWidth();
  final FastScroller.ScrollFade scrollFade=mScrollFade;
  int alpha=-1;
  if (mState == STATE_EXIT) {
    alpha=scrollFade.getAlpha();
    if (alpha < ScrollFade.ALPHA_MAX / 2) {
      mThumbDrawable.setAlpha(alpha * 2);
    }
    int left=0;
switch (mPosition) {
case View.SCROLLBAR_POSITION_RIGHT:
      left=viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
    break;
case View.SCROLLBAR_POSITION_LEFT:
  left=-mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
break;
}
mThumbDrawable.setBounds(left,0,left + mThumbW,mThumbH);
mChangedBounds=true;
}
if (mTrackDrawable != null) {
final Rect thumbBounds=mThumbDrawable.getBounds();
final int left=thumbBounds.left;
final int halfThumbHeight=(thumbBounds.bottom - thumbBounds.top) / 2;
final int trackWidth=mTrackDrawable.getIntrinsicWidth();
final int trackLeft=(left + mThumbW / 2) - trackWidth / 2;
mTrackDrawable.setBounds(trackLeft,halfThumbHeight,trackLeft + trackWidth,mList.getHeight() - halfThumbHeight);
mTrackDrawable.draw(canvas);
}
canvas.translate(0,y);
mThumbDrawable.draw(canvas);
canvas.translate(0,-y);
if (mState == STATE_DRAGGING && mDrawOverlay) {
if (mOverlayPosition == OVERLAY_AT_THUMB) {
int left=0;
switch (mPosition) {
default :
case View.SCROLLBAR_POSITION_RIGHT:
left=Math.max(0,mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
break;
case View.SCROLLBAR_POSITION_LEFT:
left=Math.min(mThumbDrawable.getBounds().right + mThumbW,mList.getWidth() - mOverlaySize);
break;
}
int top=Math.max(0,Math.min(y + (mThumbH - mOverlaySize) / 2,mList.getHeight() - mOverlaySize));
final RectF pos=mOverlayPos;
pos.left=left;
pos.right=pos.left + mOverlaySize;
pos.top=top;
pos.bottom=pos.top + mOverlaySize;
if (mOverlayDrawable != null) {
mOverlayDrawable.setBounds((int)pos.left,(int)pos.top,(int)pos.right,(int)pos.bottom);
}
}
mOverlayDrawable.draw(canvas);
final Paint paint=mPaint;
float descent=paint.descent();
final RectF rectF=mOverlayPos;
final Rect tmpRect=mTmpRect;
mOverlayDrawable.getPadding(tmpRect);
final int hOff=(tmpRect.right - tmpRect.left) / 2;
final int vOff=(tmpRect.bottom - tmpRect.top) / 2;
canvas.drawText(mSectionText,(int)(rectF.left + rectF.right) / 2 - hOff,(int)(rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff,paint);
}
 else if (mState == STATE_EXIT) {
if (alpha == 0) {
setState(STATE_NONE);
}
 else {
final int left, right, top, bottom;
if (mTrackDrawable != null) {
top=0;
bottom=mList.getHeight();
}
 else {
top=y;
bottom=y + mThumbH;
}
switch (mList.getLayoutDirection()) {
case View.LAYOUT_DIRECTION_RTL:
left=0;
right=mThumbW;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
left=viewWidth - mThumbW;
right=viewWidth;
}
mList.invalidate(left,top,right,bottom);
}
}
}"
2262,"public void setState(int state){
switch (state) {
case STATE_NONE:
    mHandler.removeCallbacks(mScrollFade);
  mList.invalidate();
break;
case STATE_VISIBLE:
if (mState != STATE_VISIBLE) {
resetThumbPos();
}
case STATE_DRAGGING:
mHandler.removeCallbacks(mScrollFade);
break;
case STATE_EXIT:
int viewWidth=mList.getWidth();
mList.invalidate(viewWidth - mThumbW,mThumbY,viewWidth,mThumbY + mThumbH);
break;
}
mState=state;
refreshDrawableState();
}","public void setState(int state){
switch (state) {
case STATE_NONE:
    mHandler.removeCallbacks(mScrollFade);
  mList.invalidate();
break;
case STATE_VISIBLE:
if (mState != STATE_VISIBLE) {
resetThumbPos();
}
case STATE_DRAGGING:
mHandler.removeCallbacks(mScrollFade);
break;
case STATE_EXIT:
final int viewWidth=mList.getWidth();
final int top=mThumbY;
final int bottom=mThumbY + mThumbH;
final int left;
final int right;
switch (mList.getLayoutDirection()) {
case View.LAYOUT_DIRECTION_RTL:
left=0;
right=mThumbW;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
left=viewWidth - mThumbW;
right=viewWidth;
}
mList.invalidate(left,top,right,bottom);
break;
}
mState=state;
refreshDrawableState();
}"
2263,"private void measureChildWithMargins2(View child,int parentWidthSpec,int parentHeightSpec,int childWidth,int childHeight){
  int childWidthSpec=getChildMeasureSpec(parentWidthSpec,mPaddingLeft + mPaddingRight + getTotalMargin(child,true),childWidth);
  int childHeightSpec=getChildMeasureSpec(parentHeightSpec,mPaddingTop + mPaddingBottom + getTotalMargin(child,false),childHeight);
  child.measure(childWidthSpec,childHeightSpec);
}","private void measureChildWithMargins2(View child,int parentWidthSpec,int parentHeightSpec,int childWidth,int childHeight){
  int childWidthSpec=getChildMeasureSpec(parentWidthSpec,getTotalMargin(child,true),childWidth);
  int childHeightSpec=getChildMeasureSpec(parentHeightSpec,getTotalMargin(child,false),childHeight);
  child.measure(childWidthSpec,childHeightSpec);
}"
2264,"@Override protected void onMeasure(int widthSpec,int heightSpec){
  consistencyCheck();
  invalidateValues();
  measureChildrenWithMargins(widthSpec,heightSpec,true);
  int width, height;
  if (orientation == HORIZONTAL) {
    width=horizontalAxis.getMeasure(widthSpec);
    measureChildrenWithMargins(widthSpec,heightSpec,false);
    height=verticalAxis.getMeasure(heightSpec);
  }
 else {
    height=verticalAxis.getMeasure(heightSpec);
    measureChildrenWithMargins(widthSpec,heightSpec,false);
    width=horizontalAxis.getMeasure(widthSpec);
  }
  int hPadding=getPaddingLeft() + getPaddingRight();
  int vPadding=getPaddingTop() + getPaddingBottom();
  int measuredWidth=Math.max(hPadding + width,getSuggestedMinimumWidth());
  int measuredHeight=Math.max(vPadding + height,getSuggestedMinimumHeight());
  setMeasuredDimension(resolveSizeAndState(measuredWidth,widthSpec,0),resolveSizeAndState(measuredHeight,heightSpec,0));
}","@Override protected void onMeasure(int widthSpec,int heightSpec){
  consistencyCheck();
  invalidateValues();
  int hPadding=getPaddingLeft() + getPaddingRight();
  int vPadding=getPaddingTop() + getPaddingBottom();
  int widthSpecSansPadding=adjust(widthSpec,-hPadding);
  int heightSpecSansPadding=adjust(heightSpec,-vPadding);
  measureChildrenWithMargins(widthSpecSansPadding,heightSpecSansPadding,true);
  int widthSansPadding;
  int heightSansPadding;
  if (orientation == HORIZONTAL) {
    widthSansPadding=horizontalAxis.getMeasure(widthSpecSansPadding);
    measureChildrenWithMargins(widthSpecSansPadding,heightSpecSansPadding,false);
    heightSansPadding=verticalAxis.getMeasure(heightSpecSansPadding);
  }
 else {
    heightSansPadding=verticalAxis.getMeasure(heightSpecSansPadding);
    measureChildrenWithMargins(widthSpecSansPadding,heightSpecSansPadding,false);
    widthSansPadding=horizontalAxis.getMeasure(widthSpecSansPadding);
  }
  int measuredWidth=Math.max(widthSansPadding + hPadding,getSuggestedMinimumWidth());
  int measuredHeight=Math.max(heightSansPadding + vPadding,getSuggestedMinimumHeight());
  setMeasuredDimension(resolveSizeAndState(measuredWidth,widthSpec,0),resolveSizeAndState(measuredHeight,heightSpec,0));
}"
2265,"public void draw(Canvas canvas){
  if (mState == STATE_NONE) {
    return;
  }
  final int y=mThumbY;
  final int viewWidth=mList.getWidth();
  final FastScroller.ScrollFade scrollFade=mScrollFade;
  int alpha=-1;
  if (mState == STATE_EXIT) {
    alpha=scrollFade.getAlpha();
    if (alpha < ScrollFade.ALPHA_MAX / 2) {
      mThumbDrawable.setAlpha(alpha * 2);
    }
    int left=0;
switch (mPosition) {
case View.SCROLLBAR_POSITION_RIGHT:
      left=viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
    break;
case View.SCROLLBAR_POSITION_LEFT:
  left=-mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
break;
}
mThumbDrawable.setBounds(left,0,left + mThumbW,mThumbH);
mChangedBounds=true;
}
if (mTrackDrawable != null) {
final Rect thumbBounds=mThumbDrawable.getBounds();
final int left=thumbBounds.left;
final int halfThumbHeight=(thumbBounds.bottom - thumbBounds.top) / 2;
final int trackWidth=mTrackDrawable.getIntrinsicWidth();
final int trackLeft=(left + mThumbW / 2) - trackWidth / 2;
mTrackDrawable.setBounds(trackLeft,halfThumbHeight,trackLeft + trackWidth,mList.getHeight() - halfThumbHeight);
mTrackDrawable.draw(canvas);
}
canvas.translate(0,y);
mThumbDrawable.draw(canvas);
canvas.translate(0,-y);
if (mState == STATE_DRAGGING && mDrawOverlay) {
if (mOverlayPosition == OVERLAY_AT_THUMB) {
int left=0;
switch (mPosition) {
default :
case View.SCROLLBAR_POSITION_RIGHT:
left=Math.max(0,mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
break;
case View.SCROLLBAR_POSITION_LEFT:
left=Math.min(mThumbDrawable.getBounds().right + mThumbW,mList.getWidth() - mOverlaySize);
break;
}
int top=Math.max(0,Math.min(y + (mThumbH - mOverlaySize) / 2,mList.getHeight() - mOverlaySize));
final RectF pos=mOverlayPos;
pos.left=left;
pos.right=pos.left + mOverlaySize;
pos.top=top;
pos.bottom=pos.top + mOverlaySize;
if (mOverlayDrawable != null) {
mOverlayDrawable.setBounds((int)pos.left,(int)pos.top,(int)pos.right,(int)pos.bottom);
}
}
mOverlayDrawable.draw(canvas);
final Paint paint=mPaint;
float descent=paint.descent();
final RectF rectF=mOverlayPos;
final Rect tmpRect=mTmpRect;
mOverlayDrawable.getPadding(tmpRect);
final int hOff=(tmpRect.right - tmpRect.left) / 2;
final int vOff=(tmpRect.bottom - tmpRect.top) / 2;
canvas.drawText(mSectionText,(int)(rectF.left + rectF.right) / 2 - hOff,(int)(rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff,paint);
}
 else if (mState == STATE_EXIT) {
if (alpha == 0) {
setState(STATE_NONE);
}
 else if (mTrackDrawable != null) {
mList.invalidate(viewWidth - mThumbW,0,viewWidth,mList.getHeight());
}
 else {
mList.invalidate(viewWidth - mThumbW,y,viewWidth,y + mThumbH);
}
}
}","public void draw(Canvas canvas){
  if (mState == STATE_NONE) {
    return;
  }
  final int y=mThumbY;
  final int viewWidth=mList.getWidth();
  final FastScroller.ScrollFade scrollFade=mScrollFade;
  int alpha=-1;
  if (mState == STATE_EXIT) {
    alpha=scrollFade.getAlpha();
    if (alpha < ScrollFade.ALPHA_MAX / 2) {
      mThumbDrawable.setAlpha(alpha * 2);
    }
    int left=0;
switch (mPosition) {
case View.SCROLLBAR_POSITION_RIGHT:
      left=viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
    break;
case View.SCROLLBAR_POSITION_LEFT:
  left=-mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
break;
}
mThumbDrawable.setBounds(left,0,left + mThumbW,mThumbH);
mChangedBounds=true;
}
if (mTrackDrawable != null) {
final Rect thumbBounds=mThumbDrawable.getBounds();
final int left=thumbBounds.left;
final int halfThumbHeight=(thumbBounds.bottom - thumbBounds.top) / 2;
final int trackWidth=mTrackDrawable.getIntrinsicWidth();
final int trackLeft=(left + mThumbW / 2) - trackWidth / 2;
mTrackDrawable.setBounds(trackLeft,halfThumbHeight,trackLeft + trackWidth,mList.getHeight() - halfThumbHeight);
mTrackDrawable.draw(canvas);
}
canvas.translate(0,y);
mThumbDrawable.draw(canvas);
canvas.translate(0,-y);
if (mState == STATE_DRAGGING && mDrawOverlay) {
if (mOverlayPosition == OVERLAY_AT_THUMB) {
int left=0;
switch (mPosition) {
default :
case View.SCROLLBAR_POSITION_RIGHT:
left=Math.max(0,mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
break;
case View.SCROLLBAR_POSITION_LEFT:
left=Math.min(mThumbDrawable.getBounds().right + mThumbW,mList.getWidth() - mOverlaySize);
break;
}
int top=Math.max(0,Math.min(y + (mThumbH - mOverlaySize) / 2,mList.getHeight() - mOverlaySize));
final RectF pos=mOverlayPos;
pos.left=left;
pos.right=pos.left + mOverlaySize;
pos.top=top;
pos.bottom=pos.top + mOverlaySize;
if (mOverlayDrawable != null) {
mOverlayDrawable.setBounds((int)pos.left,(int)pos.top,(int)pos.right,(int)pos.bottom);
}
}
mOverlayDrawable.draw(canvas);
final Paint paint=mPaint;
float descent=paint.descent();
final RectF rectF=mOverlayPos;
final Rect tmpRect=mTmpRect;
mOverlayDrawable.getPadding(tmpRect);
final int hOff=(tmpRect.right - tmpRect.left) / 2;
final int vOff=(tmpRect.bottom - tmpRect.top) / 2;
canvas.drawText(mSectionText,(int)(rectF.left + rectF.right) / 2 - hOff,(int)(rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff,paint);
}
 else if (mState == STATE_EXIT) {
if (alpha == 0) {
setState(STATE_NONE);
}
 else {
final int left, right, top, bottom;
if (mTrackDrawable != null) {
top=0;
bottom=mList.getHeight();
}
 else {
top=y;
bottom=y + mThumbH;
}
switch (mList.getLayoutDirection()) {
case View.LAYOUT_DIRECTION_RTL:
left=0;
right=mThumbW;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
left=viewWidth - mThumbW;
right=viewWidth;
}
mList.invalidate(left,top,right,bottom);
}
}
}"
2266,"public void setState(int state){
switch (state) {
case STATE_NONE:
    mHandler.removeCallbacks(mScrollFade);
  mList.invalidate();
break;
case STATE_VISIBLE:
if (mState != STATE_VISIBLE) {
resetThumbPos();
}
case STATE_DRAGGING:
mHandler.removeCallbacks(mScrollFade);
break;
case STATE_EXIT:
int viewWidth=mList.getWidth();
mList.invalidate(viewWidth - mThumbW,mThumbY,viewWidth,mThumbY + mThumbH);
break;
}
mState=state;
refreshDrawableState();
}","public void setState(int state){
switch (state) {
case STATE_NONE:
    mHandler.removeCallbacks(mScrollFade);
  mList.invalidate();
break;
case STATE_VISIBLE:
if (mState != STATE_VISIBLE) {
resetThumbPos();
}
case STATE_DRAGGING:
mHandler.removeCallbacks(mScrollFade);
break;
case STATE_EXIT:
final int viewWidth=mList.getWidth();
final int top=mThumbY;
final int bottom=mThumbY + mThumbH;
final int left;
final int right;
switch (mList.getLayoutDirection()) {
case View.LAYOUT_DIRECTION_RTL:
left=0;
right=mThumbW;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
left=viewWidth - mThumbW;
right=viewWidth;
}
mList.invalidate(left,top,right,bottom);
break;
}
mState=state;
refreshDrawableState();
}"
2267,"public void draw(Canvas canvas){
  if (mState == STATE_NONE) {
    return;
  }
  final int y=mThumbY;
  final int viewWidth=mList.getWidth();
  final FastScroller.ScrollFade scrollFade=mScrollFade;
  int alpha=-1;
  if (mState == STATE_EXIT) {
    alpha=scrollFade.getAlpha();
    if (alpha < ScrollFade.ALPHA_MAX / 2) {
      mThumbDrawable.setAlpha(alpha * 2);
    }
    int left=0;
switch (mPosition) {
case View.SCROLLBAR_POSITION_RIGHT:
      left=viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
    break;
case View.SCROLLBAR_POSITION_LEFT:
  left=-mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
break;
}
mThumbDrawable.setBounds(left,0,left + mThumbW,mThumbH);
mChangedBounds=true;
}
if (mTrackDrawable != null) {
final Rect thumbBounds=mThumbDrawable.getBounds();
final int left=thumbBounds.left;
final int halfThumbHeight=(thumbBounds.bottom - thumbBounds.top) / 2;
final int trackWidth=mTrackDrawable.getIntrinsicWidth();
final int trackLeft=(left + mThumbW / 2) - trackWidth / 2;
mTrackDrawable.setBounds(trackLeft,halfThumbHeight,trackLeft + trackWidth,mList.getHeight() - halfThumbHeight);
mTrackDrawable.draw(canvas);
}
canvas.translate(0,y);
mThumbDrawable.draw(canvas);
canvas.translate(0,-y);
if (mState == STATE_DRAGGING && mDrawOverlay) {
if (mOverlayPosition == OVERLAY_AT_THUMB) {
int left=0;
switch (mPosition) {
default :
case View.SCROLLBAR_POSITION_RIGHT:
left=Math.max(0,mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
break;
case View.SCROLLBAR_POSITION_LEFT:
left=Math.min(mThumbDrawable.getBounds().right + mThumbW,mList.getWidth() - mOverlaySize);
break;
}
int top=Math.max(0,Math.min(y + (mThumbH - mOverlaySize) / 2,mList.getHeight() - mOverlaySize));
final RectF pos=mOverlayPos;
pos.left=left;
pos.right=pos.left + mOverlaySize;
pos.top=top;
pos.bottom=pos.top + mOverlaySize;
if (mOverlayDrawable != null) {
mOverlayDrawable.setBounds((int)pos.left,(int)pos.top,(int)pos.right,(int)pos.bottom);
}
}
mOverlayDrawable.draw(canvas);
final Paint paint=mPaint;
float descent=paint.descent();
final RectF rectF=mOverlayPos;
final Rect tmpRect=mTmpRect;
mOverlayDrawable.getPadding(tmpRect);
final int hOff=(tmpRect.right - tmpRect.left) / 2;
final int vOff=(tmpRect.bottom - tmpRect.top) / 2;
canvas.drawText(mSectionText,(int)(rectF.left + rectF.right) / 2 - hOff,(int)(rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff,paint);
}
 else if (mState == STATE_EXIT) {
if (alpha == 0) {
setState(STATE_NONE);
}
 else if (mTrackDrawable != null) {
mList.invalidate(viewWidth - mThumbW,0,viewWidth,mList.getHeight());
}
 else {
mList.invalidate(viewWidth - mThumbW,y,viewWidth,y + mThumbH);
}
}
}","public void draw(Canvas canvas){
  if (mState == STATE_NONE) {
    return;
  }
  final int y=mThumbY;
  final int viewWidth=mList.getWidth();
  final FastScroller.ScrollFade scrollFade=mScrollFade;
  int alpha=-1;
  if (mState == STATE_EXIT) {
    alpha=scrollFade.getAlpha();
    if (alpha < ScrollFade.ALPHA_MAX / 2) {
      mThumbDrawable.setAlpha(alpha * 2);
    }
    int left=0;
switch (mPosition) {
case View.SCROLLBAR_POSITION_RIGHT:
      left=viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
    break;
case View.SCROLLBAR_POSITION_LEFT:
  left=-mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
break;
}
mThumbDrawable.setBounds(left,0,left + mThumbW,mThumbH);
mChangedBounds=true;
}
if (mTrackDrawable != null) {
final Rect thumbBounds=mThumbDrawable.getBounds();
final int left=thumbBounds.left;
final int halfThumbHeight=(thumbBounds.bottom - thumbBounds.top) / 2;
final int trackWidth=mTrackDrawable.getIntrinsicWidth();
final int trackLeft=(left + mThumbW / 2) - trackWidth / 2;
mTrackDrawable.setBounds(trackLeft,halfThumbHeight,trackLeft + trackWidth,mList.getHeight() - halfThumbHeight);
mTrackDrawable.draw(canvas);
}
canvas.translate(0,y);
mThumbDrawable.draw(canvas);
canvas.translate(0,-y);
if (mState == STATE_DRAGGING && mDrawOverlay) {
if (mOverlayPosition == OVERLAY_AT_THUMB) {
int left=0;
switch (mPosition) {
default :
case View.SCROLLBAR_POSITION_RIGHT:
left=Math.max(0,mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
break;
case View.SCROLLBAR_POSITION_LEFT:
left=Math.min(mThumbDrawable.getBounds().right + mThumbW,mList.getWidth() - mOverlaySize);
break;
}
int top=Math.max(0,Math.min(y + (mThumbH - mOverlaySize) / 2,mList.getHeight() - mOverlaySize));
final RectF pos=mOverlayPos;
pos.left=left;
pos.right=pos.left + mOverlaySize;
pos.top=top;
pos.bottom=pos.top + mOverlaySize;
if (mOverlayDrawable != null) {
mOverlayDrawable.setBounds((int)pos.left,(int)pos.top,(int)pos.right,(int)pos.bottom);
}
}
mOverlayDrawable.draw(canvas);
final Paint paint=mPaint;
float descent=paint.descent();
final RectF rectF=mOverlayPos;
final Rect tmpRect=mTmpRect;
mOverlayDrawable.getPadding(tmpRect);
final int hOff=(tmpRect.right - tmpRect.left) / 2;
final int vOff=(tmpRect.bottom - tmpRect.top) / 2;
canvas.drawText(mSectionText,(int)(rectF.left + rectF.right) / 2 - hOff,(int)(rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff,paint);
}
 else if (mState == STATE_EXIT) {
if (alpha == 0) {
setState(STATE_NONE);
}
 else {
final int left, right, top, bottom;
if (mTrackDrawable != null) {
top=0;
bottom=mList.getHeight();
}
 else {
top=y;
bottom=y + mThumbH;
}
switch (mList.getLayoutDirection()) {
case View.LAYOUT_DIRECTION_RTL:
left=0;
right=mThumbW;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
left=viewWidth - mThumbW;
right=viewWidth;
}
mList.invalidate(left,top,right,bottom);
}
}
}"
2268,"public void setState(int state){
switch (state) {
case STATE_NONE:
    mHandler.removeCallbacks(mScrollFade);
  mList.invalidate();
break;
case STATE_VISIBLE:
if (mState != STATE_VISIBLE) {
resetThumbPos();
}
case STATE_DRAGGING:
mHandler.removeCallbacks(mScrollFade);
break;
case STATE_EXIT:
int viewWidth=mList.getWidth();
mList.invalidate(viewWidth - mThumbW,mThumbY,viewWidth,mThumbY + mThumbH);
break;
}
mState=state;
refreshDrawableState();
}","public void setState(int state){
switch (state) {
case STATE_NONE:
    mHandler.removeCallbacks(mScrollFade);
  mList.invalidate();
break;
case STATE_VISIBLE:
if (mState != STATE_VISIBLE) {
resetThumbPos();
}
case STATE_DRAGGING:
mHandler.removeCallbacks(mScrollFade);
break;
case STATE_EXIT:
final int viewWidth=mList.getWidth();
final int top=mThumbY;
final int bottom=mThumbY + mThumbH;
final int left;
final int right;
switch (mList.getLayoutDirection()) {
case View.LAYOUT_DIRECTION_RTL:
left=0;
right=mThumbW;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
left=viewWidth - mThumbW;
right=viewWidth;
}
mList.invalidate(left,top,right,bottom);
break;
}
mState=state;
refreshDrawableState();
}"
2269,"public void draw(Canvas canvas){
  if (mState == STATE_NONE) {
    return;
  }
  final int y=mThumbY;
  final int viewWidth=mList.getWidth();
  final FastScroller.ScrollFade scrollFade=mScrollFade;
  int alpha=-1;
  if (mState == STATE_EXIT) {
    alpha=scrollFade.getAlpha();
    if (alpha < ScrollFade.ALPHA_MAX / 2) {
      mThumbDrawable.setAlpha(alpha * 2);
    }
    int left=0;
switch (mPosition) {
case View.SCROLLBAR_POSITION_RIGHT:
      left=viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
    break;
case View.SCROLLBAR_POSITION_LEFT:
  left=-mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
break;
}
mThumbDrawable.setBounds(left,0,left + mThumbW,mThumbH);
mChangedBounds=true;
}
if (mTrackDrawable != null) {
final Rect thumbBounds=mThumbDrawable.getBounds();
final int left=thumbBounds.left;
final int halfThumbHeight=(thumbBounds.bottom - thumbBounds.top) / 2;
final int trackWidth=mTrackDrawable.getIntrinsicWidth();
final int trackLeft=(left + mThumbW / 2) - trackWidth / 2;
mTrackDrawable.setBounds(trackLeft,halfThumbHeight,trackLeft + trackWidth,mList.getHeight() - halfThumbHeight);
mTrackDrawable.draw(canvas);
}
canvas.translate(0,y);
mThumbDrawable.draw(canvas);
canvas.translate(0,-y);
if (mState == STATE_DRAGGING && mDrawOverlay) {
if (mOverlayPosition == OVERLAY_AT_THUMB) {
int left=0;
switch (mPosition) {
default :
case View.SCROLLBAR_POSITION_RIGHT:
left=Math.max(0,mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
break;
case View.SCROLLBAR_POSITION_LEFT:
left=Math.min(mThumbDrawable.getBounds().right + mThumbW,mList.getWidth() - mOverlaySize);
break;
}
int top=Math.max(0,Math.min(y + (mThumbH - mOverlaySize) / 2,mList.getHeight() - mOverlaySize));
final RectF pos=mOverlayPos;
pos.left=left;
pos.right=pos.left + mOverlaySize;
pos.top=top;
pos.bottom=pos.top + mOverlaySize;
if (mOverlayDrawable != null) {
mOverlayDrawable.setBounds((int)pos.left,(int)pos.top,(int)pos.right,(int)pos.bottom);
}
}
mOverlayDrawable.draw(canvas);
final Paint paint=mPaint;
float descent=paint.descent();
final RectF rectF=mOverlayPos;
final Rect tmpRect=mTmpRect;
mOverlayDrawable.getPadding(tmpRect);
final int hOff=(tmpRect.right - tmpRect.left) / 2;
final int vOff=(tmpRect.bottom - tmpRect.top) / 2;
canvas.drawText(mSectionText,(int)(rectF.left + rectF.right) / 2 - hOff,(int)(rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff,paint);
}
 else if (mState == STATE_EXIT) {
if (alpha == 0) {
setState(STATE_NONE);
}
 else if (mTrackDrawable != null) {
mList.invalidate(viewWidth - mThumbW,0,viewWidth,mList.getHeight());
}
 else {
mList.invalidate(viewWidth - mThumbW,y,viewWidth,y + mThumbH);
}
}
}","public void draw(Canvas canvas){
  if (mState == STATE_NONE) {
    return;
  }
  final int y=mThumbY;
  final int viewWidth=mList.getWidth();
  final FastScroller.ScrollFade scrollFade=mScrollFade;
  int alpha=-1;
  if (mState == STATE_EXIT) {
    alpha=scrollFade.getAlpha();
    if (alpha < ScrollFade.ALPHA_MAX / 2) {
      mThumbDrawable.setAlpha(alpha * 2);
    }
    int left=0;
switch (mPosition) {
case View.SCROLLBAR_POSITION_RIGHT:
      left=viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
    break;
case View.SCROLLBAR_POSITION_LEFT:
  left=-mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
break;
}
mThumbDrawable.setBounds(left,0,left + mThumbW,mThumbH);
mChangedBounds=true;
}
if (mTrackDrawable != null) {
final Rect thumbBounds=mThumbDrawable.getBounds();
final int left=thumbBounds.left;
final int halfThumbHeight=(thumbBounds.bottom - thumbBounds.top) / 2;
final int trackWidth=mTrackDrawable.getIntrinsicWidth();
final int trackLeft=(left + mThumbW / 2) - trackWidth / 2;
mTrackDrawable.setBounds(trackLeft,halfThumbHeight,trackLeft + trackWidth,mList.getHeight() - halfThumbHeight);
mTrackDrawable.draw(canvas);
}
canvas.translate(0,y);
mThumbDrawable.draw(canvas);
canvas.translate(0,-y);
if (mState == STATE_DRAGGING && mDrawOverlay) {
if (mOverlayPosition == OVERLAY_AT_THUMB) {
int left=0;
switch (mPosition) {
default :
case View.SCROLLBAR_POSITION_RIGHT:
left=Math.max(0,mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
break;
case View.SCROLLBAR_POSITION_LEFT:
left=Math.min(mThumbDrawable.getBounds().right + mThumbW,mList.getWidth() - mOverlaySize);
break;
}
int top=Math.max(0,Math.min(y + (mThumbH - mOverlaySize) / 2,mList.getHeight() - mOverlaySize));
final RectF pos=mOverlayPos;
pos.left=left;
pos.right=pos.left + mOverlaySize;
pos.top=top;
pos.bottom=pos.top + mOverlaySize;
if (mOverlayDrawable != null) {
mOverlayDrawable.setBounds((int)pos.left,(int)pos.top,(int)pos.right,(int)pos.bottom);
}
}
mOverlayDrawable.draw(canvas);
final Paint paint=mPaint;
float descent=paint.descent();
final RectF rectF=mOverlayPos;
final Rect tmpRect=mTmpRect;
mOverlayDrawable.getPadding(tmpRect);
final int hOff=(tmpRect.right - tmpRect.left) / 2;
final int vOff=(tmpRect.bottom - tmpRect.top) / 2;
canvas.drawText(mSectionText,(int)(rectF.left + rectF.right) / 2 - hOff,(int)(rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff,paint);
}
 else if (mState == STATE_EXIT) {
if (alpha == 0) {
setState(STATE_NONE);
}
 else {
final int left, right, top, bottom;
if (mTrackDrawable != null) {
top=0;
bottom=mList.getHeight();
}
 else {
top=y;
bottom=y + mThumbH;
}
switch (mList.getLayoutDirection()) {
case View.LAYOUT_DIRECTION_RTL:
left=0;
right=mThumbW;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
left=viewWidth - mThumbW;
right=viewWidth;
}
mList.invalidate(left,top,right,bottom);
}
}
}"
2270,"public void setState(int state){
switch (state) {
case STATE_NONE:
    mHandler.removeCallbacks(mScrollFade);
  mList.invalidate();
break;
case STATE_VISIBLE:
if (mState != STATE_VISIBLE) {
resetThumbPos();
}
case STATE_DRAGGING:
mHandler.removeCallbacks(mScrollFade);
break;
case STATE_EXIT:
int viewWidth=mList.getWidth();
mList.invalidate(viewWidth - mThumbW,mThumbY,viewWidth,mThumbY + mThumbH);
break;
}
mState=state;
refreshDrawableState();
}","public void setState(int state){
switch (state) {
case STATE_NONE:
    mHandler.removeCallbacks(mScrollFade);
  mList.invalidate();
break;
case STATE_VISIBLE:
if (mState != STATE_VISIBLE) {
resetThumbPos();
}
case STATE_DRAGGING:
mHandler.removeCallbacks(mScrollFade);
break;
case STATE_EXIT:
final int viewWidth=mList.getWidth();
final int top=mThumbY;
final int bottom=mThumbY + mThumbH;
final int left;
final int right;
switch (mList.getLayoutDirection()) {
case View.LAYOUT_DIRECTION_RTL:
left=0;
right=mThumbW;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
left=viewWidth - mThumbW;
right=viewWidth;
}
mList.invalidate(left,top,right,bottom);
break;
}
mState=state;
refreshDrawableState();
}"
2271,"public boolean onJsConfirm(String url,String message){
  if (mWebChromeClient == null) {
    return false;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message confirm=obtainMessage(JS_CONFIRM,result);
  confirm.getData().putString(""String_Node_Str"",message);
  confirm.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(confirm);
  return result.mJsResult.getResult();
}","public boolean onJsConfirm(String url,String message){
  if (mWebChromeClient == null) {
    return false;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message confirm=obtainMessage(JS_DIALOG,result);
  confirm.getData().putString(""String_Node_Str"",message);
  confirm.getData().putString(""String_Node_Str"",url);
  confirm.getData().putInt(""String_Node_Str"",JsDialogHelper.CONFIRM);
  sendMessageToUiThreadSync(confirm);
  return result.mJsResult.getResult();
}"
2272,"public void onJsAlert(String url,String message){
  if (mWebChromeClient == null) {
    return;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message alert=obtainMessage(JS_ALERT,result);
  alert.getData().putString(""String_Node_Str"",message);
  alert.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(alert);
}","public void onJsAlert(String url,String message){
  if (mWebChromeClient == null) {
    return;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message alert=obtainMessage(JS_DIALOG,result);
  alert.getData().putString(""String_Node_Str"",message);
  alert.getData().putString(""String_Node_Str"",url);
  alert.getData().putInt(""String_Node_Str"",JsDialogHelper.ALERT);
  sendMessageToUiThreadSync(alert);
}"
2273,"public String onJsPrompt(String url,String message,String defaultValue){
  if (mWebChromeClient == null) {
    return null;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message prompt=obtainMessage(JS_PROMPT,result);
  prompt.getData().putString(""String_Node_Str"",message);
  prompt.getData().putString(""String_Node_Str"",defaultValue);
  prompt.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(prompt);
  return result.mJsResult.getStringResult();
}","public String onJsPrompt(String url,String message,String defaultValue){
  if (mWebChromeClient == null) {
    return null;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message prompt=obtainMessage(JS_DIALOG,result);
  prompt.getData().putString(""String_Node_Str"",message);
  prompt.getData().putString(""String_Node_Str"",defaultValue);
  prompt.getData().putString(""String_Node_Str"",url);
  prompt.getData().putInt(""String_Node_Str"",JsDialogHelper.PROMPT);
  sendMessageToUiThreadSync(prompt);
  return result.mJsResult.getStringResult();
}"
2274,"public boolean onJsBeforeUnload(String url,String message){
  if (mWebChromeClient == null) {
    return true;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message confirm=obtainMessage(JS_UNLOAD,result);
  confirm.getData().putString(""String_Node_Str"",message);
  confirm.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(confirm);
  return result.mJsResult.getResult();
}","public boolean onJsBeforeUnload(String url,String message){
  if (mWebChromeClient == null) {
    return true;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message unload=obtainMessage(JS_DIALOG,result);
  unload.getData().putString(""String_Node_Str"",message);
  unload.getData().putString(""String_Node_Str"",url);
  unload.getData().putInt(""String_Node_Str"",JsDialogHelper.UNLOAD);
  sendMessageToUiThreadSync(unload);
  return result.mJsResult.getResult();
}"
2275,"@Override public void handleMessage(Message msg){
  if (messagesBlocked())   return;
switch (msg.what) {
case PAGE_STARTED:
    String startedUrl=msg.getData().getString(""String_Node_Str"");
  mWebView.onPageStarted(startedUrl);
if (mWebViewClient != null) {
  mWebViewClient.onPageStarted(mWebView.getWebView(),startedUrl,(Bitmap)msg.obj);
}
break;
case PAGE_FINISHED:
String finishedUrl=(String)msg.obj;
mWebView.onPageFinished(finishedUrl);
if (mWebViewClient != null) {
mWebViewClient.onPageFinished(mWebView.getWebView(),finishedUrl);
}
break;
case RECEIVED_ICON:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedIcon(mWebView.getWebView(),(Bitmap)msg.obj);
}
break;
case RECEIVED_TOUCH_ICON_URL:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(),(String)msg.obj,msg.arg1 == 1);
}
break;
case RECEIVED_TITLE:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTitle(mWebView.getWebView(),(String)msg.obj);
}
break;
case REPORT_ERROR:
if (mWebViewClient != null) {
int reasonCode=msg.arg1;
final String description=msg.getData().getString(""String_Node_Str"");
final String failUrl=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedError(mWebView.getWebView(),reasonCode,description,failUrl);
}
break;
case RESEND_POST_DATA:
Message resend=(Message)msg.getData().getParcelable(""String_Node_Str"");
Message dontResend=(Message)msg.getData().getParcelable(""String_Node_Str"");
if (mWebViewClient != null) {
mWebViewClient.onFormResubmission(mWebView.getWebView(),dontResend,resend);
}
 else {
dontResend.sendToTarget();
}
break;
case OVERRIDE_URL:
String overrideUrl=msg.getData().getString(""String_Node_Str"");
boolean override=uiOverrideUrlLoading(overrideUrl);
ResultTransport<Boolean> result=(ResultTransport<Boolean>)msg.obj;
synchronized (this) {
result.setResult(override);
notify();
}
break;
case AUTH_REQUEST:
if (mWebViewClient != null) {
HttpAuthHandler handler=(HttpAuthHandler)msg.obj;
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(),handler,host,realm);
}
break;
case SSL_ERROR:
if (mWebViewClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
mWebViewClient.onReceivedSslError(mWebView.getWebView(),(SslErrorHandler)map.get(""String_Node_Str""),(SslError)map.get(""String_Node_Str""));
}
break;
case PROCEEDED_AFTER_SSL_ERROR:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
((WebViewClientClassicExt)mWebViewClient).onProceededAfterSslError(mWebView.getWebView(),(SslError)msg.obj);
}
break;
case CLIENT_CERT_REQUEST:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
((WebViewClientClassicExt)mWebViewClient).onReceivedClientCertRequest(mWebView.getWebView(),(ClientCertRequestHandler)map.get(""String_Node_Str""),(String)map.get(""String_Node_Str""));
}
break;
case PROGRESS:
synchronized (this) {
if (mWebChromeClient != null) {
mWebChromeClient.onProgressChanged(mWebView.getWebView(),mLatestProgress);
}
mProgressUpdatePending=false;
}
break;
case UPDATE_VISITED:
if (mWebViewClient != null) {
mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(),(String)msg.obj,msg.arg1 != 0);
}
break;
case LOAD_RESOURCE:
if (mWebViewClient != null) {
mWebViewClient.onLoadResource(mWebView.getWebView(),(String)msg.obj);
}
break;
case DOWNLOAD_FILE:
if (mDownloadListener != null) {
String url=msg.getData().getString(""String_Node_Str"");
String userAgent=msg.getData().getString(""String_Node_Str"");
String contentDisposition=msg.getData().getString(""String_Node_Str"");
String mimetype=msg.getData().getString(""String_Node_Str"");
String referer=msg.getData().getString(""String_Node_Str"");
Long contentLength=msg.getData().getLong(""String_Node_Str"");
if (mDownloadListener instanceof BrowserDownloadListener) {
((BrowserDownloadListener)mDownloadListener).onDownloadStart(url,userAgent,contentDisposition,mimetype,referer,contentLength);
}
 else {
mDownloadListener.onDownloadStart(url,userAgent,contentDisposition,mimetype,contentLength);
}
}
break;
case CREATE_WINDOW:
if (mWebChromeClient != null) {
if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(),msg.arg1 == 1,msg.arg2 == 1,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
mWebView.dismissZoomControl();
}
break;
case REQUEST_FOCUS:
if (mWebChromeClient != null) {
mWebChromeClient.onRequestFocus(mWebView.getWebView());
}
break;
case CLOSE_WINDOW:
if (mWebChromeClient != null) {
mWebChromeClient.onCloseWindow(((WebViewClassic)msg.obj).getWebView());
}
break;
case SAVE_PASSWORD:
Bundle bundle=msg.getData();
String schemePlusHost=bundle.getString(""String_Node_Str"");
String username=bundle.getString(""String_Node_Str"");
String password=bundle.getString(""String_Node_Str"");
if (!mWebView.onSavePassword(schemePlusHost,username,password,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
break;
case ASYNC_KEYEVENTS:
if (mWebViewClient != null) {
mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(),(KeyEvent)msg.obj);
}
break;
case EXCEEDED_DATABASE_QUOTA:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String databaseIdentifier=(String)map.get(""String_Node_Str"");
String url=(String)map.get(""String_Node_Str"");
long quota=((Long)map.get(""String_Node_Str"")).longValue();
long totalQuota=((Long)map.get(""String_Node_Str"")).longValue();
long estimatedDatabaseSize=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onExceededDatabaseQuota(url,databaseIdentifier,quota,estimatedDatabaseSize,totalQuota,quotaUpdater);
}
break;
case REACHED_APPCACHE_MAXSIZE:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
long requiredStorage=((Long)map.get(""String_Node_Str"")).longValue();
long quota=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage,quota,quotaUpdater);
}
break;
case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String origin=(String)map.get(""String_Node_Str"");
GeolocationPermissions.Callback callback=(GeolocationPermissions.Callback)map.get(""String_Node_Str"");
mWebChromeClient.onGeolocationPermissionsShowPrompt(origin,callback);
}
break;
case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
if (mWebChromeClient != null) {
mWebChromeClient.onGeolocationPermissionsHidePrompt();
}
break;
case JS_ALERT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsAlert(mWebView.getWebView(),url,message,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.confirm();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_CONFIRM:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsConfirm(mWebView.getWebView(),url,message,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.confirm();
}
}
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.cancel();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_PROMPT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsPromptResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String defaultVal=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsPrompt(mWebView.getWebView(),url,message,defaultVal,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
final LayoutInflater factory=LayoutInflater.from(mContext);
final View view=factory.inflate(R.layout.js_prompt,null);
final EditText v=(EditText)view.findViewById(R.id.value);
v.setText(defaultVal);
((TextView)view.findViewById(R.id.message)).setText(message);
new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setView(view).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
res.confirm(v.getText().toString());
}
}
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
res.cancel();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_UNLOAD:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsBeforeUnload(mWebView.getWebView(),url,message,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
final String m=mContext.getString(R.string.js_dialog_before_unload,message);
new AlertDialog.Builder(mContext).setMessage(m).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.confirm();
}
}
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.cancel();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
@Override public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_TIMEOUT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
if (mWebChromeClient.onJsTimeout()) {
res.confirm();
}
 else {
res.cancel();
}
receiver.setReady();
}
break;
case RECEIVED_CERTIFICATE:
mWebView.setCertificate((SslCertificate)msg.obj);
break;
case NOTIFY:
synchronized (this) {
notify();
}
break;
case SCALE_CHANGED:
if (mWebViewClient != null) {
mWebViewClient.onScaleChanged(mWebView.getWebView(),msg.getData().getFloat(""String_Node_Str""),msg.getData().getFloat(""String_Node_Str""));
}
break;
case SWITCH_OUT_HISTORY:
mWebView.switchOutDrawHistory();
break;
case ADD_MESSAGE_TO_CONSOLE:
if (mWebChromeClient == null) {
break;
}
String message=msg.getData().getString(""String_Node_Str"");
String sourceID=msg.getData().getString(""String_Node_Str"");
int lineNumber=msg.getData().getInt(""String_Node_Str"");
int msgLevel=msg.getData().getInt(""String_Node_Str"");
int numberOfMessageLevels=ConsoleMessage.MessageLevel.values().length;
if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
msgLevel=0;
}
ConsoleMessage.MessageLevel messageLevel=ConsoleMessage.MessageLevel.values()[msgLevel];
if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message,sourceID,lineNumber,messageLevel))) {
String logTag=""String_Node_Str"";
String logMessage=message + ""String_Node_Str"" + sourceID+ ""String_Node_Str""+ lineNumber;
switch (messageLevel) {
case TIP:
Log.v(logTag,logMessage);
break;
case LOG:
Log.i(logTag,logMessage);
break;
case WARNING:
Log.w(logTag,logMessage);
break;
case ERROR:
Log.e(logTag,logMessage);
break;
case DEBUG:
Log.d(logTag,logMessage);
break;
}
}
break;
case GET_VISITED_HISTORY:
if (mWebChromeClient != null) {
mWebChromeClient.getVisitedHistory((ValueCallback<String[]>)msg.obj);
}
break;
case OPEN_FILE_CHOOSER:
if (mWebChromeClient != null) {
UploadFileMessageData data=(UploadFileMessageData)msg.obj;
mWebChromeClient.openFileChooser(data.getUploadFile(),data.getAcceptType(),data.getCapture());
}
break;
case ADD_HISTORY_ITEM:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem)msg.obj);
}
break;
case HISTORY_INDEX_CHANGED:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onIndexChanged((WebHistoryItem)msg.obj,msg.arg1);
}
break;
case AUTH_CREDENTIALS:
{
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
username=msg.getData().getString(""String_Node_Str"");
password=msg.getData().getString(""String_Node_Str"");
mWebView.setHttpAuthUsernamePassword(host,realm,username,password);
break;
}
case AUTO_LOGIN:
{
if (mWebViewClient != null) {
String realm=msg.getData().getString(""String_Node_Str"");
String account=msg.getData().getString(""String_Node_Str"");
String args=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(),realm,account,args);
}
break;
}
}
}","@Override public void handleMessage(Message msg){
  if (messagesBlocked())   return;
switch (msg.what) {
case PAGE_STARTED:
    String startedUrl=msg.getData().getString(""String_Node_Str"");
  mWebView.onPageStarted(startedUrl);
if (mWebViewClient != null) {
  mWebViewClient.onPageStarted(mWebView.getWebView(),startedUrl,(Bitmap)msg.obj);
}
break;
case PAGE_FINISHED:
String finishedUrl=(String)msg.obj;
mWebView.onPageFinished(finishedUrl);
if (mWebViewClient != null) {
mWebViewClient.onPageFinished(mWebView.getWebView(),finishedUrl);
}
break;
case RECEIVED_ICON:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedIcon(mWebView.getWebView(),(Bitmap)msg.obj);
}
break;
case RECEIVED_TOUCH_ICON_URL:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(),(String)msg.obj,msg.arg1 == 1);
}
break;
case RECEIVED_TITLE:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTitle(mWebView.getWebView(),(String)msg.obj);
}
break;
case REPORT_ERROR:
if (mWebViewClient != null) {
int reasonCode=msg.arg1;
final String description=msg.getData().getString(""String_Node_Str"");
final String failUrl=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedError(mWebView.getWebView(),reasonCode,description,failUrl);
}
break;
case RESEND_POST_DATA:
Message resend=(Message)msg.getData().getParcelable(""String_Node_Str"");
Message dontResend=(Message)msg.getData().getParcelable(""String_Node_Str"");
if (mWebViewClient != null) {
mWebViewClient.onFormResubmission(mWebView.getWebView(),dontResend,resend);
}
 else {
dontResend.sendToTarget();
}
break;
case OVERRIDE_URL:
String overrideUrl=msg.getData().getString(""String_Node_Str"");
boolean override=uiOverrideUrlLoading(overrideUrl);
ResultTransport<Boolean> result=(ResultTransport<Boolean>)msg.obj;
synchronized (this) {
result.setResult(override);
notify();
}
break;
case AUTH_REQUEST:
if (mWebViewClient != null) {
HttpAuthHandler handler=(HttpAuthHandler)msg.obj;
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(),handler,host,realm);
}
break;
case SSL_ERROR:
if (mWebViewClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
mWebViewClient.onReceivedSslError(mWebView.getWebView(),(SslErrorHandler)map.get(""String_Node_Str""),(SslError)map.get(""String_Node_Str""));
}
break;
case PROCEEDED_AFTER_SSL_ERROR:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
((WebViewClientClassicExt)mWebViewClient).onProceededAfterSslError(mWebView.getWebView(),(SslError)msg.obj);
}
break;
case CLIENT_CERT_REQUEST:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
((WebViewClientClassicExt)mWebViewClient).onReceivedClientCertRequest(mWebView.getWebView(),(ClientCertRequestHandler)map.get(""String_Node_Str""),(String)map.get(""String_Node_Str""));
}
break;
case PROGRESS:
synchronized (this) {
if (mWebChromeClient != null) {
mWebChromeClient.onProgressChanged(mWebView.getWebView(),mLatestProgress);
}
mProgressUpdatePending=false;
}
break;
case UPDATE_VISITED:
if (mWebViewClient != null) {
mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(),(String)msg.obj,msg.arg1 != 0);
}
break;
case LOAD_RESOURCE:
if (mWebViewClient != null) {
mWebViewClient.onLoadResource(mWebView.getWebView(),(String)msg.obj);
}
break;
case DOWNLOAD_FILE:
if (mDownloadListener != null) {
String url=msg.getData().getString(""String_Node_Str"");
String userAgent=msg.getData().getString(""String_Node_Str"");
String contentDisposition=msg.getData().getString(""String_Node_Str"");
String mimetype=msg.getData().getString(""String_Node_Str"");
String referer=msg.getData().getString(""String_Node_Str"");
Long contentLength=msg.getData().getLong(""String_Node_Str"");
if (mDownloadListener instanceof BrowserDownloadListener) {
((BrowserDownloadListener)mDownloadListener).onDownloadStart(url,userAgent,contentDisposition,mimetype,referer,contentLength);
}
 else {
mDownloadListener.onDownloadStart(url,userAgent,contentDisposition,mimetype,contentLength);
}
}
break;
case CREATE_WINDOW:
if (mWebChromeClient != null) {
if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(),msg.arg1 == 1,msg.arg2 == 1,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
mWebView.dismissZoomControl();
}
break;
case REQUEST_FOCUS:
if (mWebChromeClient != null) {
mWebChromeClient.onRequestFocus(mWebView.getWebView());
}
break;
case CLOSE_WINDOW:
if (mWebChromeClient != null) {
mWebChromeClient.onCloseWindow(((WebViewClassic)msg.obj).getWebView());
}
break;
case SAVE_PASSWORD:
Bundle bundle=msg.getData();
String schemePlusHost=bundle.getString(""String_Node_Str"");
String username=bundle.getString(""String_Node_Str"");
String password=bundle.getString(""String_Node_Str"");
if (!mWebView.onSavePassword(schemePlusHost,username,password,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
break;
case ASYNC_KEYEVENTS:
if (mWebViewClient != null) {
mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(),(KeyEvent)msg.obj);
}
break;
case EXCEEDED_DATABASE_QUOTA:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String databaseIdentifier=(String)map.get(""String_Node_Str"");
String url=(String)map.get(""String_Node_Str"");
long quota=((Long)map.get(""String_Node_Str"")).longValue();
long totalQuota=((Long)map.get(""String_Node_Str"")).longValue();
long estimatedDatabaseSize=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onExceededDatabaseQuota(url,databaseIdentifier,quota,estimatedDatabaseSize,totalQuota,quotaUpdater);
}
break;
case REACHED_APPCACHE_MAXSIZE:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
long requiredStorage=((Long)map.get(""String_Node_Str"")).longValue();
long quota=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage,quota,quotaUpdater);
}
break;
case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String origin=(String)map.get(""String_Node_Str"");
GeolocationPermissions.Callback callback=(GeolocationPermissions.Callback)map.get(""String_Node_Str"");
mWebChromeClient.onGeolocationPermissionsShowPrompt(origin,callback);
}
break;
case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
if (mWebChromeClient != null) {
mWebChromeClient.onGeolocationPermissionsHidePrompt();
}
break;
case JS_DIALOG:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
JsDialogHelper helper=new JsDialogHelper(receiver.mJsResult,msg);
if (!helper.invokeCallback(mWebChromeClient,mWebView.getWebView())) {
helper.showDialog(mContext);
}
receiver.setReady();
}
break;
case JS_TIMEOUT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
if (mWebChromeClient.onJsTimeout()) {
res.confirm();
}
 else {
res.cancel();
}
receiver.setReady();
}
break;
case RECEIVED_CERTIFICATE:
mWebView.setCertificate((SslCertificate)msg.obj);
break;
case NOTIFY:
synchronized (this) {
notify();
}
break;
case SCALE_CHANGED:
if (mWebViewClient != null) {
mWebViewClient.onScaleChanged(mWebView.getWebView(),msg.getData().getFloat(""String_Node_Str""),msg.getData().getFloat(""String_Node_Str""));
}
break;
case SWITCH_OUT_HISTORY:
mWebView.switchOutDrawHistory();
break;
case ADD_MESSAGE_TO_CONSOLE:
if (mWebChromeClient == null) {
break;
}
String message=msg.getData().getString(""String_Node_Str"");
String sourceID=msg.getData().getString(""String_Node_Str"");
int lineNumber=msg.getData().getInt(""String_Node_Str"");
int msgLevel=msg.getData().getInt(""String_Node_Str"");
int numberOfMessageLevels=ConsoleMessage.MessageLevel.values().length;
if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
msgLevel=0;
}
ConsoleMessage.MessageLevel messageLevel=ConsoleMessage.MessageLevel.values()[msgLevel];
if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message,sourceID,lineNumber,messageLevel))) {
String logTag=""String_Node_Str"";
String logMessage=message + ""String_Node_Str"" + sourceID+ ""String_Node_Str""+ lineNumber;
switch (messageLevel) {
case TIP:
Log.v(logTag,logMessage);
break;
case LOG:
Log.i(logTag,logMessage);
break;
case WARNING:
Log.w(logTag,logMessage);
break;
case ERROR:
Log.e(logTag,logMessage);
break;
case DEBUG:
Log.d(logTag,logMessage);
break;
}
}
break;
case GET_VISITED_HISTORY:
if (mWebChromeClient != null) {
mWebChromeClient.getVisitedHistory((ValueCallback<String[]>)msg.obj);
}
break;
case OPEN_FILE_CHOOSER:
if (mWebChromeClient != null) {
UploadFileMessageData data=(UploadFileMessageData)msg.obj;
mWebChromeClient.openFileChooser(data.getUploadFile(),data.getAcceptType(),data.getCapture());
}
break;
case ADD_HISTORY_ITEM:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem)msg.obj);
}
break;
case HISTORY_INDEX_CHANGED:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onIndexChanged((WebHistoryItem)msg.obj,msg.arg1);
}
break;
case AUTH_CREDENTIALS:
{
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
username=msg.getData().getString(""String_Node_Str"");
password=msg.getData().getString(""String_Node_Str"");
mWebView.setHttpAuthUsernamePassword(host,realm,username,password);
break;
}
case AUTO_LOGIN:
{
if (mWebViewClient != null) {
String realm=msg.getData().getString(""String_Node_Str"");
String account=msg.getData().getString(""String_Node_Str"");
String args=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(),realm,account,args);
}
break;
}
}
}"
2276,"@Override public void addTestProvider(String name,ProviderProperties properties){
  checkMockPermissionsSafe();
  if (LocationManager.PASSIVE_PROVIDER.equals(name)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  long identity=Binder.clearCallingIdentity();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,properties);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name) || LocationManager.FUSED_PROVIDER.equals(name)) {
      LocationProviderInterface p=mProvidersByName.get(name);
      if (p != null) {
        removeProviderLocked(p);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProviderLocked(provider);
    mMockProviders.put(name,provider);
    mLastLocation.put(name,null);
    updateProvidersLocked();
  }
  Binder.restoreCallingIdentity(identity);
}","@Override public void addTestProvider(String name,ProviderProperties properties){
  checkMockPermissionsSafe();
  if (LocationManager.PASSIVE_PROVIDER.equals(name)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  long identity=Binder.clearCallingIdentity();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,properties);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name) || LocationManager.FUSED_PROVIDER.equals(name)) {
      LocationProviderInterface p=mProvidersByName.get(name);
      if (p != null) {
        removeProviderLocked(p);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProviderLocked(provider);
    mMockProviders.put(name,provider);
    mLastLocation.put(name,null);
    mLastLocationCoarseInterval.put(name,null);
    updateProvidersLocked();
  }
  Binder.restoreCallingIdentity(identity);
}"
2277,"private void handleLocationChangedLocked(Location location,boolean passive){
  if (D)   Log.d(TAG,""String_Node_Str"" + location);
  long now=SystemClock.elapsedRealtime();
  String provider=(passive ? LocationManager.PASSIVE_PROVIDER : location.getProvider());
  LocationProviderInterface p=mProvidersByName.get(provider);
  if (p == null)   return;
  Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
  Location lastNoGPSLocation=null;
  Location lastLocation=mLastLocation.get(provider);
  if (lastLocation == null) {
    lastLocation=new Location(provider);
    mLastLocation.put(provider,lastLocation);
  }
 else {
    lastNoGPSLocation=lastLocation.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
    if (noGPSLocation == null && lastNoGPSLocation != null) {
      location.setExtraLocation(Location.EXTRA_NO_GPS_LOCATION,lastNoGPSLocation);
    }
  }
  lastLocation.set(location);
  ArrayList<UpdateRecord> records=mRecordsByProvider.get(provider);
  if (records == null || records.size() == 0)   return;
  Location coarseLocation=null;
  if (noGPSLocation != null && !noGPSLocation.equals(lastNoGPSLocation)) {
    coarseLocation=mLocationFudger.getOrCreate(noGPSLocation);
  }
  long newStatusUpdateTime=p.getStatusUpdateTime();
  Bundle extras=new Bundle();
  int status=p.getStatus(extras);
  ArrayList<Receiver> deadReceivers=null;
  ArrayList<UpdateRecord> deadUpdateRecords=null;
  for (  UpdateRecord r : records) {
    Receiver receiver=r.mReceiver;
    boolean receiverDead=false;
    int receiverUserId=UserHandle.getUserId(receiver.mUid);
    if (receiverUserId != mCurrentUserId) {
      if (D) {
        Log.d(TAG,""String_Node_Str"" + receiverUserId + ""String_Node_Str""+ mCurrentUserId+ ""String_Node_Str""+ receiver.mPackageName+ ""String_Node_Str"");
      }
      continue;
    }
    if (mBlacklist.isBlacklisted(receiver.mPackageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    if (!reportLocationAccessNoThrow(receiver.mUid,receiver.mPackageName,receiver.mAllowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    Location notifyLocation=null;
    if (receiver.mAllowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
      notifyLocation=coarseLocation;
    }
 else {
      notifyLocation=lastLocation;
    }
    if (notifyLocation != null) {
      Location lastLoc=r.mLastFixBroadcast;
      if ((lastLoc == null) || shouldBroadcastSafe(notifyLocation,lastLoc,r,now)) {
        if (lastLoc == null) {
          lastLoc=new Location(notifyLocation);
          r.mLastFixBroadcast=lastLoc;
        }
 else {
          lastLoc.set(notifyLocation);
        }
        if (!receiver.callLocationChangedLocked(notifyLocation)) {
          Slog.w(TAG,""String_Node_Str"" + receiver);
          receiverDead=true;
        }
        r.mRequest.decrementNumUpdates();
      }
    }
    long prevStatusUpdateTime=r.mLastStatusBroadcast;
    if ((newStatusUpdateTime > prevStatusUpdateTime) && (prevStatusUpdateTime != 0 || status != LocationProvider.AVAILABLE)) {
      r.mLastStatusBroadcast=newStatusUpdateTime;
      if (!receiver.callStatusChangedLocked(provider,status,extras)) {
        receiverDead=true;
        Slog.w(TAG,""String_Node_Str"" + receiver);
      }
    }
    if (r.mRequest.getNumUpdates() <= 0 || r.mRequest.getExpireAt() < now) {
      if (deadUpdateRecords == null) {
        deadUpdateRecords=new ArrayList<UpdateRecord>();
      }
      deadUpdateRecords.add(r);
    }
    if (receiverDead) {
      if (deadReceivers == null) {
        deadReceivers=new ArrayList<Receiver>();
      }
      if (!deadReceivers.contains(receiver)) {
        deadReceivers.add(receiver);
      }
    }
  }
  if (deadReceivers != null) {
    for (    Receiver receiver : deadReceivers) {
      removeUpdatesLocked(receiver);
    }
  }
  if (deadUpdateRecords != null) {
    for (    UpdateRecord r : deadUpdateRecords) {
      r.disposeLocked(true);
    }
    applyRequirementsLocked(provider);
  }
}","private void handleLocationChangedLocked(Location location,boolean passive){
  if (D)   Log.d(TAG,""String_Node_Str"" + location);
  long now=SystemClock.elapsedRealtime();
  String provider=(passive ? LocationManager.PASSIVE_PROVIDER : location.getProvider());
  LocationProviderInterface p=mProvidersByName.get(provider);
  if (p == null)   return;
  Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
  Location lastNoGPSLocation=null;
  Location lastLocation=mLastLocation.get(provider);
  if (lastLocation == null) {
    lastLocation=new Location(provider);
    mLastLocation.put(provider,lastLocation);
  }
 else {
    lastNoGPSLocation=lastLocation.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
    if (noGPSLocation == null && lastNoGPSLocation != null) {
      location.setExtraLocation(Location.EXTRA_NO_GPS_LOCATION,lastNoGPSLocation);
    }
  }
  lastLocation.set(location);
  Location lastLocationCoarseInterval=mLastLocationCoarseInterval.get(provider);
  if (lastLocationCoarseInterval == null) {
    lastLocationCoarseInterval=new Location(location);
    mLastLocationCoarseInterval.put(provider,lastLocationCoarseInterval);
  }
  long timeDiffNanos=location.getElapsedRealtimeNanos() - lastLocationCoarseInterval.getElapsedRealtimeNanos();
  if (timeDiffNanos > LocationFudger.FASTEST_INTERVAL_MS * NANOS_PER_MILLI) {
    lastLocationCoarseInterval.set(location);
  }
  noGPSLocation=lastLocationCoarseInterval.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
  ArrayList<UpdateRecord> records=mRecordsByProvider.get(provider);
  if (records == null || records.size() == 0)   return;
  Location coarseLocation=null;
  if (noGPSLocation != null) {
    coarseLocation=mLocationFudger.getOrCreate(noGPSLocation);
  }
  long newStatusUpdateTime=p.getStatusUpdateTime();
  Bundle extras=new Bundle();
  int status=p.getStatus(extras);
  ArrayList<Receiver> deadReceivers=null;
  ArrayList<UpdateRecord> deadUpdateRecords=null;
  for (  UpdateRecord r : records) {
    Receiver receiver=r.mReceiver;
    boolean receiverDead=false;
    int receiverUserId=UserHandle.getUserId(receiver.mUid);
    if (receiverUserId != mCurrentUserId) {
      if (D) {
        Log.d(TAG,""String_Node_Str"" + receiverUserId + ""String_Node_Str""+ mCurrentUserId+ ""String_Node_Str""+ receiver.mPackageName+ ""String_Node_Str"");
      }
      continue;
    }
    if (mBlacklist.isBlacklisted(receiver.mPackageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    if (!reportLocationAccessNoThrow(receiver.mUid,receiver.mPackageName,receiver.mAllowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    Location notifyLocation=null;
    if (receiver.mAllowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
      notifyLocation=coarseLocation;
    }
 else {
      notifyLocation=lastLocation;
    }
    if (notifyLocation != null) {
      Location lastLoc=r.mLastFixBroadcast;
      if ((lastLoc == null) || shouldBroadcastSafe(notifyLocation,lastLoc,r,now)) {
        if (lastLoc == null) {
          lastLoc=new Location(notifyLocation);
          r.mLastFixBroadcast=lastLoc;
        }
 else {
          lastLoc.set(notifyLocation);
        }
        if (!receiver.callLocationChangedLocked(notifyLocation)) {
          Slog.w(TAG,""String_Node_Str"" + receiver);
          receiverDead=true;
        }
        r.mRequest.decrementNumUpdates();
      }
    }
    long prevStatusUpdateTime=r.mLastStatusBroadcast;
    if ((newStatusUpdateTime > prevStatusUpdateTime) && (prevStatusUpdateTime != 0 || status != LocationProvider.AVAILABLE)) {
      r.mLastStatusBroadcast=newStatusUpdateTime;
      if (!receiver.callStatusChangedLocked(provider,status,extras)) {
        receiverDead=true;
        Slog.w(TAG,""String_Node_Str"" + receiver);
      }
    }
    if (r.mRequest.getNumUpdates() <= 0 || r.mRequest.getExpireAt() < now) {
      if (deadUpdateRecords == null) {
        deadUpdateRecords=new ArrayList<UpdateRecord>();
      }
      deadUpdateRecords.add(r);
    }
    if (receiverDead) {
      if (deadReceivers == null) {
        deadReceivers=new ArrayList<Receiver>();
      }
      if (!deadReceivers.contains(receiver)) {
        deadReceivers.add(receiver);
      }
    }
  }
  if (deadReceivers != null) {
    for (    Receiver receiver : deadReceivers) {
      removeUpdatesLocked(receiver);
    }
  }
  if (deadUpdateRecords != null) {
    for (    UpdateRecord r : deadUpdateRecords) {
      r.disposeLocked(true);
    }
    applyRequirementsLocked(provider);
  }
}"
2278,"/** 
 * Called when the device's active user changes.
 * @param userId the new active user's UserId
 */
private void switchUser(int userId){
  mBlacklist.switchUser(userId);
  mLocationHandler.removeMessages(MSG_LOCATION_CHANGED);
synchronized (mLock) {
    mLastLocation.clear();
    for (    LocationProviderInterface p : mProviders) {
      updateProviderListenersLocked(p.getName(),false,mCurrentUserId);
    }
    mCurrentUserId=userId;
    updateProvidersLocked();
  }
}","/** 
 * Called when the device's active user changes.
 * @param userId the new active user's UserId
 */
private void switchUser(int userId){
  mBlacklist.switchUser(userId);
  mLocationHandler.removeMessages(MSG_LOCATION_CHANGED);
synchronized (mLock) {
    mLastLocation.clear();
    mLastLocationCoarseInterval.clear();
    for (    LocationProviderInterface p : mProviders) {
      updateProviderListenersLocked(p.getName(),false,mCurrentUserId);
    }
    mCurrentUserId=userId;
    updateProvidersLocked();
  }
}"
2279,"@Override public Location getLastLocation(LocationRequest request,String packageName){
  if (D)   Log.d(TAG,""String_Node_Str"" + request);
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkPackageName(packageName);
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  final int uid=Binder.getCallingUid();
  final long identity=Binder.clearCallingIdentity();
  try {
    if (mBlacklist.isBlacklisted(packageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
    if (!reportLocationAccessNoThrow(uid,packageName,allowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
synchronized (mLock) {
      String name=request.getProvider();
      if (name == null)       name=LocationManager.FUSED_PROVIDER;
      LocationProviderInterface provider=mProvidersByName.get(name);
      if (provider == null)       return null;
      if (!isAllowedByUserSettingsLocked(name,uid))       return null;
      Location location=mLastLocation.get(name);
      if (location == null) {
        return null;
      }
      if (allowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
        Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
        if (noGPSLocation != null) {
          return new Location(mLocationFudger.getOrCreate(noGPSLocation));
        }
      }
 else {
        return new Location(location);
      }
    }
    return null;
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public Location getLastLocation(LocationRequest request,String packageName){
  if (D)   Log.d(TAG,""String_Node_Str"" + request);
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkPackageName(packageName);
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  final int uid=Binder.getCallingUid();
  final long identity=Binder.clearCallingIdentity();
  try {
    if (mBlacklist.isBlacklisted(packageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
    if (!reportLocationAccessNoThrow(uid,packageName,allowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
synchronized (mLock) {
      String name=request.getProvider();
      if (name == null)       name=LocationManager.FUSED_PROVIDER;
      LocationProviderInterface provider=mProvidersByName.get(name);
      if (provider == null)       return null;
      if (!isAllowedByUserSettingsLocked(name,uid))       return null;
      Location location;
      if (allowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
        location=mLastLocationCoarseInterval.get(name);
      }
 else {
        location=mLastLocation.get(name);
      }
      if (location == null) {
        return null;
      }
      if (allowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
        Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
        if (noGPSLocation != null) {
          return new Location(mLocationFudger.getOrCreate(noGPSLocation));
        }
      }
 else {
        return new Location(location);
      }
    }
    return null;
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}"
2280,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
synchronized (mLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (    Receiver receiver : mReceivers.values()) {
      pw.println(""String_Node_Str"" + receiver);
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,ArrayList<UpdateRecord>> entry : mRecordsByProvider.entrySet()) {
      pw.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      for (      UpdateRecord record : entry.getValue()) {
        pw.println(""String_Node_Str"" + record);
      }
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,Location> entry : mLastLocation.entrySet()) {
      String provider=entry.getKey();
      Location location=entry.getValue();
      pw.println(""String_Node_Str"" + provider + ""String_Node_Str""+ location);
    }
    mGeofenceManager.dump(pw);
    if (mEnabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mEnabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    if (mDisabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mDisabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    pw.append(""String_Node_Str"");
    mBlacklist.dump(pw);
    if (mMockProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      Map.Entry<String,MockProvider> i : mMockProviders.entrySet()) {
        i.getValue().dump(pw,""String_Node_Str"");
      }
    }
    pw.append(""String_Node_Str"");
    mLocationFudger.dump(fd,pw,args);
    if (args.length > 0 && ""String_Node_Str"".equals(args[0])) {
      return;
    }
    for (    LocationProviderInterface provider : mProviders) {
      pw.print(provider.getName() + ""String_Node_Str"");
      if (provider instanceof LocationProviderProxy) {
        LocationProviderProxy proxy=(LocationProviderProxy)provider;
        pw.print(""String_Node_Str"" + proxy.getConnectedPackageName() + ""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      provider.dump(fd,pw,args);
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
synchronized (mLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (    Receiver receiver : mReceivers.values()) {
      pw.println(""String_Node_Str"" + receiver);
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,ArrayList<UpdateRecord>> entry : mRecordsByProvider.entrySet()) {
      pw.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      for (      UpdateRecord record : entry.getValue()) {
        pw.println(""String_Node_Str"" + record);
      }
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,Location> entry : mLastLocation.entrySet()) {
      String provider=entry.getKey();
      Location location=entry.getValue();
      pw.println(""String_Node_Str"" + provider + ""String_Node_Str""+ location);
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,Location> entry : mLastLocationCoarseInterval.entrySet()) {
      String provider=entry.getKey();
      Location location=entry.getValue();
      pw.println(""String_Node_Str"" + provider + ""String_Node_Str""+ location);
    }
    mGeofenceManager.dump(pw);
    if (mEnabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mEnabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    if (mDisabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mDisabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    pw.append(""String_Node_Str"");
    mBlacklist.dump(pw);
    if (mMockProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      Map.Entry<String,MockProvider> i : mMockProviders.entrySet()) {
        i.getValue().dump(pw,""String_Node_Str"");
      }
    }
    pw.append(""String_Node_Str"");
    mLocationFudger.dump(fd,pw,args);
    if (args.length > 0 && ""String_Node_Str"".equals(args[0])) {
      return;
    }
    for (    LocationProviderInterface provider : mProviders) {
      pw.print(provider.getName() + ""String_Node_Str"");
      if (provider instanceof LocationProviderProxy) {
        LocationProviderProxy proxy=(LocationProviderProxy)provider;
        pw.print(""String_Node_Str"" + proxy.getConnectedPackageName() + ""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      provider.dump(fd,pw,args);
    }
  }
}"
2281,"@Override public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.remove(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    removeProviderLocked(mProvidersByName.get(provider));
    LocationProviderInterface realProvider=mRealProviders.get(provider);
    if (realProvider != null) {
      addProviderLocked(realProvider);
    }
    mLastLocation.put(provider,null);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.remove(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    removeProviderLocked(mProvidersByName.get(provider));
    LocationProviderInterface realProvider=mRealProviders.get(provider);
    if (realProvider != null) {
      addProviderLocked(realProvider);
    }
    mLastLocation.put(provider,null);
    mLastLocationCoarseInterval.put(provider,null);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}"
2282,"private static boolean shouldBroadcastSafe(Location loc,Location lastLoc,UpdateRecord record,long now){
  if (lastLoc == null) {
    return true;
  }
  long minTime=record.mRequest.getFastestInterval();
  long delta=(loc.getElapsedRealtimeNanos() - lastLoc.getElapsedRealtimeNanos()) / 1000000L;
  if (delta < minTime - MAX_PROVIDER_SCHEDULING_JITTER_MS) {
    return false;
  }
  double minDistance=record.mRequest.getSmallestDisplacement();
  if (minDistance > 0.0) {
    if (loc.distanceTo(lastLoc) <= minDistance) {
      return false;
    }
  }
  if (record.mRequest.getNumUpdates() <= 0) {
    return false;
  }
  if (record.mRequest.getExpireAt() < now) {
    return false;
  }
  return true;
}","private static boolean shouldBroadcastSafe(Location loc,Location lastLoc,UpdateRecord record,long now){
  if (lastLoc == null) {
    return true;
  }
  long minTime=record.mRequest.getFastestInterval();
  long delta=(loc.getElapsedRealtimeNanos() - lastLoc.getElapsedRealtimeNanos()) / NANOS_PER_MILLI;
  if (delta < minTime - MAX_PROVIDER_SCHEDULING_JITTER_MS) {
    return false;
  }
  double minDistance=record.mRequest.getSmallestDisplacement();
  if (minDistance > 0.0) {
    if (loc.distanceTo(lastLoc) <= minDistance) {
      return false;
    }
  }
  if (record.mRequest.getNumUpdates() <= 0) {
    return false;
  }
  if (record.mRequest.getExpireAt() < now) {
    return false;
  }
  return true;
}"
2283,"private void updateWindow(boolean force,boolean redrawNeeded){
  if (!mHaveFrame) {
    return;
  }
  ViewRootImpl viewRoot=getViewRootImpl();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  if (mTranslator != null) {
    mSurface.setCompatibilityTranslator(mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
    if (DEBUG)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      if (mWindow == null) {
        Display display=getDisplay();
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.START | Gravity.TOP;
        mSession.addToDisplayWithoutInputChannel(mWindow,mWindow.mSeq,mLayout,mVisible ? VISIBLE : GONE,display.getDisplayId(),mContentInsets);
      }
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      int relayoutResult;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mSurface);
        relayoutResult=mSession.relayout(mWindow,mWindow.mSeq,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY,mWinFrame,mOverscanInsets,mContentInsets,mVisibleInsets,mConfiguration,mNewSurface);
        if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mNewSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        redrawNeeded|=creating | reportDrawNeeded;
        SurfaceHolder.Callback callbacks[]=null;
        final boolean surfaceChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
        if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
          mSurfaceCreated=false;
          if (mSurface.isValid()) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            callbacks=getSurfaceCallbacks();
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceDestroyed(mSurfaceHolder);
            }
          }
        }
        mSurface.transferFrom(mNewSurface);
        if (visible && mSurface.isValid()) {
          if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
            mSurfaceCreated=true;
            mIsCreating=true;
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"" + mFormat + ""String_Node_Str""+ myWidth+ ""String_Node_Str""+ myHeight);
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
          if (redrawNeeded) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              if (c instanceof SurfaceHolder.Callback2) {
                ((SurfaceHolder.Callback2)c).surfaceRedrawNeeded(mSurfaceHolder);
              }
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (redrawNeeded) {
          if (DEBUG)           Log.i(TAG,""String_Node_Str"");
          mSession.finishDrawing(mWindow);
        }
        mSession.performDeferredDestroy(mWindow);
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force,boolean redrawNeeded){
  if (!mHaveFrame) {
    return;
  }
  ViewRootImpl viewRoot=getViewRootImpl();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  if (mTranslator != null) {
    mSurface.setCompatibilityTranslator(mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
    if (DEBUG)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION;
      if (mWindow == null) {
        Display display=getDisplay();
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.START | Gravity.TOP;
        mSession.addToDisplayWithoutInputChannel(mWindow,mWindow.mSeq,mLayout,mVisible ? VISIBLE : GONE,display.getDisplayId(),mContentInsets);
      }
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      int relayoutResult;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mSurface);
        relayoutResult=mSession.relayout(mWindow,mWindow.mSeq,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY,mWinFrame,mOverscanInsets,mContentInsets,mVisibleInsets,mConfiguration,mNewSurface);
        if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mNewSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        redrawNeeded|=creating | reportDrawNeeded;
        SurfaceHolder.Callback callbacks[]=null;
        final boolean surfaceChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
        if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
          mSurfaceCreated=false;
          if (mSurface.isValid()) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            callbacks=getSurfaceCallbacks();
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceDestroyed(mSurfaceHolder);
            }
          }
        }
        mSurface.transferFrom(mNewSurface);
        if (visible && mSurface.isValid()) {
          if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
            mSurfaceCreated=true;
            mIsCreating=true;
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"" + mFormat + ""String_Node_Str""+ myWidth+ ""String_Node_Str""+ myHeight);
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
          if (redrawNeeded) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              if (c instanceof SurfaceHolder.Callback2) {
                ((SurfaceHolder.Callback2)c).surfaceRedrawNeeded(mSurfaceHolder);
              }
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (redrawNeeded) {
          if (DEBUG)           Log.i(TAG,""String_Node_Str"");
          mSession.finishDrawing(mWindow);
        }
        mSession.performDeferredDestroy(mWindow);
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}"
2284,"/** 
 * Return whether this window is wanting to have a translation animation applied to it for an in-progress move.  (Only makes sense to call from performLayoutAndPlaceSurfacesLockedInner().)
 */
boolean shouldAnimateMove(){
  return mContentChanged && !mExiting && !mWinAnimator.mLastHidden&& mService.okToDisplay()&& (mFrame.top != mLastFrame.top || mFrame.left != mLastFrame.left)&& (mAttachedWindow == null || !mAttachedWindow.shouldAnimateMove());
}","/** 
 * Return whether this window is wanting to have a translation animation applied to it for an in-progress move.  (Only makes sense to call from performLayoutAndPlaceSurfacesLockedInner().)
 */
boolean shouldAnimateMove(){
  return mContentChanged && !mExiting && !mWinAnimator.mLastHidden&& mService.okToDisplay()&& (mFrame.top != mLastFrame.top || mFrame.left != mLastFrame.left)&& (mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0 && (mAttachedWindow == null || !mAttachedWindow.shouldAnimateMove());
}"
2285,"public boolean onJsConfirm(String url,String message){
  if (mWebChromeClient == null) {
    return false;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message confirm=obtainMessage(JS_CONFIRM,result);
  confirm.getData().putString(""String_Node_Str"",message);
  confirm.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(confirm);
  return result.mJsResult.getResult();
}","public boolean onJsConfirm(String url,String message){
  if (mWebChromeClient == null) {
    return false;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message confirm=obtainMessage(JS_DIALOG,result);
  confirm.getData().putString(""String_Node_Str"",message);
  confirm.getData().putString(""String_Node_Str"",url);
  confirm.getData().putInt(""String_Node_Str"",JsDialogHelper.CONFIRM);
  sendMessageToUiThreadSync(confirm);
  return result.mJsResult.getResult();
}"
2286,"public void onJsAlert(String url,String message){
  if (mWebChromeClient == null) {
    return;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message alert=obtainMessage(JS_ALERT,result);
  alert.getData().putString(""String_Node_Str"",message);
  alert.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(alert);
}","public void onJsAlert(String url,String message){
  if (mWebChromeClient == null) {
    return;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message alert=obtainMessage(JS_DIALOG,result);
  alert.getData().putString(""String_Node_Str"",message);
  alert.getData().putString(""String_Node_Str"",url);
  alert.getData().putInt(""String_Node_Str"",JsDialogHelper.ALERT);
  sendMessageToUiThreadSync(alert);
}"
2287,"public String onJsPrompt(String url,String message,String defaultValue){
  if (mWebChromeClient == null) {
    return null;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message prompt=obtainMessage(JS_PROMPT,result);
  prompt.getData().putString(""String_Node_Str"",message);
  prompt.getData().putString(""String_Node_Str"",defaultValue);
  prompt.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(prompt);
  return result.mJsResult.getStringResult();
}","public String onJsPrompt(String url,String message,String defaultValue){
  if (mWebChromeClient == null) {
    return null;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message prompt=obtainMessage(JS_DIALOG,result);
  prompt.getData().putString(""String_Node_Str"",message);
  prompt.getData().putString(""String_Node_Str"",defaultValue);
  prompt.getData().putString(""String_Node_Str"",url);
  prompt.getData().putInt(""String_Node_Str"",JsDialogHelper.PROMPT);
  sendMessageToUiThreadSync(prompt);
  return result.mJsResult.getStringResult();
}"
2288,"public boolean onJsBeforeUnload(String url,String message){
  if (mWebChromeClient == null) {
    return true;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message confirm=obtainMessage(JS_UNLOAD,result);
  confirm.getData().putString(""String_Node_Str"",message);
  confirm.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(confirm);
  return result.mJsResult.getResult();
}","public boolean onJsBeforeUnload(String url,String message){
  if (mWebChromeClient == null) {
    return true;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message unload=obtainMessage(JS_DIALOG,result);
  unload.getData().putString(""String_Node_Str"",message);
  unload.getData().putString(""String_Node_Str"",url);
  unload.getData().putInt(""String_Node_Str"",JsDialogHelper.UNLOAD);
  sendMessageToUiThreadSync(unload);
  return result.mJsResult.getResult();
}"
2289,"@Override public void handleMessage(Message msg){
  if (messagesBlocked())   return;
switch (msg.what) {
case PAGE_STARTED:
    String startedUrl=msg.getData().getString(""String_Node_Str"");
  mWebView.onPageStarted(startedUrl);
if (mWebViewClient != null) {
  mWebViewClient.onPageStarted(mWebView.getWebView(),startedUrl,(Bitmap)msg.obj);
}
break;
case PAGE_FINISHED:
String finishedUrl=(String)msg.obj;
mWebView.onPageFinished(finishedUrl);
if (mWebViewClient != null) {
mWebViewClient.onPageFinished(mWebView.getWebView(),finishedUrl);
}
break;
case RECEIVED_ICON:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedIcon(mWebView.getWebView(),(Bitmap)msg.obj);
}
break;
case RECEIVED_TOUCH_ICON_URL:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(),(String)msg.obj,msg.arg1 == 1);
}
break;
case RECEIVED_TITLE:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTitle(mWebView.getWebView(),(String)msg.obj);
}
break;
case REPORT_ERROR:
if (mWebViewClient != null) {
int reasonCode=msg.arg1;
final String description=msg.getData().getString(""String_Node_Str"");
final String failUrl=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedError(mWebView.getWebView(),reasonCode,description,failUrl);
}
break;
case RESEND_POST_DATA:
Message resend=(Message)msg.getData().getParcelable(""String_Node_Str"");
Message dontResend=(Message)msg.getData().getParcelable(""String_Node_Str"");
if (mWebViewClient != null) {
mWebViewClient.onFormResubmission(mWebView.getWebView(),dontResend,resend);
}
 else {
dontResend.sendToTarget();
}
break;
case OVERRIDE_URL:
String overrideUrl=msg.getData().getString(""String_Node_Str"");
boolean override=uiOverrideUrlLoading(overrideUrl);
ResultTransport<Boolean> result=(ResultTransport<Boolean>)msg.obj;
synchronized (this) {
result.setResult(override);
notify();
}
break;
case AUTH_REQUEST:
if (mWebViewClient != null) {
HttpAuthHandler handler=(HttpAuthHandler)msg.obj;
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(),handler,host,realm);
}
break;
case SSL_ERROR:
if (mWebViewClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
mWebViewClient.onReceivedSslError(mWebView.getWebView(),(SslErrorHandler)map.get(""String_Node_Str""),(SslError)map.get(""String_Node_Str""));
}
break;
case PROCEEDED_AFTER_SSL_ERROR:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
((WebViewClientClassicExt)mWebViewClient).onProceededAfterSslError(mWebView.getWebView(),(SslError)msg.obj);
}
break;
case CLIENT_CERT_REQUEST:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
((WebViewClientClassicExt)mWebViewClient).onReceivedClientCertRequest(mWebView.getWebView(),(ClientCertRequestHandler)map.get(""String_Node_Str""),(String)map.get(""String_Node_Str""));
}
break;
case PROGRESS:
synchronized (this) {
if (mWebChromeClient != null) {
mWebChromeClient.onProgressChanged(mWebView.getWebView(),mLatestProgress);
}
mProgressUpdatePending=false;
}
break;
case UPDATE_VISITED:
if (mWebViewClient != null) {
mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(),(String)msg.obj,msg.arg1 != 0);
}
break;
case LOAD_RESOURCE:
if (mWebViewClient != null) {
mWebViewClient.onLoadResource(mWebView.getWebView(),(String)msg.obj);
}
break;
case DOWNLOAD_FILE:
if (mDownloadListener != null) {
String url=msg.getData().getString(""String_Node_Str"");
String userAgent=msg.getData().getString(""String_Node_Str"");
String contentDisposition=msg.getData().getString(""String_Node_Str"");
String mimetype=msg.getData().getString(""String_Node_Str"");
String referer=msg.getData().getString(""String_Node_Str"");
Long contentLength=msg.getData().getLong(""String_Node_Str"");
if (mDownloadListener instanceof BrowserDownloadListener) {
((BrowserDownloadListener)mDownloadListener).onDownloadStart(url,userAgent,contentDisposition,mimetype,referer,contentLength);
}
 else {
mDownloadListener.onDownloadStart(url,userAgent,contentDisposition,mimetype,contentLength);
}
}
break;
case CREATE_WINDOW:
if (mWebChromeClient != null) {
if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(),msg.arg1 == 1,msg.arg2 == 1,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
mWebView.dismissZoomControl();
}
break;
case REQUEST_FOCUS:
if (mWebChromeClient != null) {
mWebChromeClient.onRequestFocus(mWebView.getWebView());
}
break;
case CLOSE_WINDOW:
if (mWebChromeClient != null) {
mWebChromeClient.onCloseWindow(((WebViewClassic)msg.obj).getWebView());
}
break;
case SAVE_PASSWORD:
Bundle bundle=msg.getData();
String schemePlusHost=bundle.getString(""String_Node_Str"");
String username=bundle.getString(""String_Node_Str"");
String password=bundle.getString(""String_Node_Str"");
if (!mWebView.onSavePassword(schemePlusHost,username,password,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
break;
case ASYNC_KEYEVENTS:
if (mWebViewClient != null) {
mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(),(KeyEvent)msg.obj);
}
break;
case EXCEEDED_DATABASE_QUOTA:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String databaseIdentifier=(String)map.get(""String_Node_Str"");
String url=(String)map.get(""String_Node_Str"");
long quota=((Long)map.get(""String_Node_Str"")).longValue();
long totalQuota=((Long)map.get(""String_Node_Str"")).longValue();
long estimatedDatabaseSize=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onExceededDatabaseQuota(url,databaseIdentifier,quota,estimatedDatabaseSize,totalQuota,quotaUpdater);
}
break;
case REACHED_APPCACHE_MAXSIZE:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
long requiredStorage=((Long)map.get(""String_Node_Str"")).longValue();
long quota=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage,quota,quotaUpdater);
}
break;
case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String origin=(String)map.get(""String_Node_Str"");
GeolocationPermissions.Callback callback=(GeolocationPermissions.Callback)map.get(""String_Node_Str"");
mWebChromeClient.onGeolocationPermissionsShowPrompt(origin,callback);
}
break;
case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
if (mWebChromeClient != null) {
mWebChromeClient.onGeolocationPermissionsHidePrompt();
}
break;
case JS_ALERT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsAlert(mWebView.getWebView(),url,message,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.confirm();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_CONFIRM:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsConfirm(mWebView.getWebView(),url,message,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.confirm();
}
}
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.cancel();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_PROMPT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsPromptResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String defaultVal=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsPrompt(mWebView.getWebView(),url,message,defaultVal,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
final LayoutInflater factory=LayoutInflater.from(mContext);
final View view=factory.inflate(R.layout.js_prompt,null);
final EditText v=(EditText)view.findViewById(R.id.value);
v.setText(defaultVal);
((TextView)view.findViewById(R.id.message)).setText(message);
new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setView(view).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
res.confirm(v.getText().toString());
}
}
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
res.cancel();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_UNLOAD:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsBeforeUnload(mWebView.getWebView(),url,message,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
final String m=mContext.getString(R.string.js_dialog_before_unload,message);
new AlertDialog.Builder(mContext).setMessage(m).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.confirm();
}
}
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.cancel();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
@Override public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_TIMEOUT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
if (mWebChromeClient.onJsTimeout()) {
res.confirm();
}
 else {
res.cancel();
}
receiver.setReady();
}
break;
case RECEIVED_CERTIFICATE:
mWebView.setCertificate((SslCertificate)msg.obj);
break;
case NOTIFY:
synchronized (this) {
notify();
}
break;
case SCALE_CHANGED:
if (mWebViewClient != null) {
mWebViewClient.onScaleChanged(mWebView.getWebView(),msg.getData().getFloat(""String_Node_Str""),msg.getData().getFloat(""String_Node_Str""));
}
break;
case SWITCH_OUT_HISTORY:
mWebView.switchOutDrawHistory();
break;
case ADD_MESSAGE_TO_CONSOLE:
if (mWebChromeClient == null) {
break;
}
String message=msg.getData().getString(""String_Node_Str"");
String sourceID=msg.getData().getString(""String_Node_Str"");
int lineNumber=msg.getData().getInt(""String_Node_Str"");
int msgLevel=msg.getData().getInt(""String_Node_Str"");
int numberOfMessageLevels=ConsoleMessage.MessageLevel.values().length;
if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
msgLevel=0;
}
ConsoleMessage.MessageLevel messageLevel=ConsoleMessage.MessageLevel.values()[msgLevel];
if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message,sourceID,lineNumber,messageLevel))) {
String logTag=""String_Node_Str"";
String logMessage=message + ""String_Node_Str"" + sourceID+ ""String_Node_Str""+ lineNumber;
switch (messageLevel) {
case TIP:
Log.v(logTag,logMessage);
break;
case LOG:
Log.i(logTag,logMessage);
break;
case WARNING:
Log.w(logTag,logMessage);
break;
case ERROR:
Log.e(logTag,logMessage);
break;
case DEBUG:
Log.d(logTag,logMessage);
break;
}
}
break;
case GET_VISITED_HISTORY:
if (mWebChromeClient != null) {
mWebChromeClient.getVisitedHistory((ValueCallback<String[]>)msg.obj);
}
break;
case OPEN_FILE_CHOOSER:
if (mWebChromeClient != null) {
UploadFileMessageData data=(UploadFileMessageData)msg.obj;
mWebChromeClient.openFileChooser(data.getUploadFile(),data.getAcceptType(),data.getCapture());
}
break;
case ADD_HISTORY_ITEM:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem)msg.obj);
}
break;
case HISTORY_INDEX_CHANGED:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onIndexChanged((WebHistoryItem)msg.obj,msg.arg1);
}
break;
case AUTH_CREDENTIALS:
{
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
username=msg.getData().getString(""String_Node_Str"");
password=msg.getData().getString(""String_Node_Str"");
mWebView.setHttpAuthUsernamePassword(host,realm,username,password);
break;
}
case AUTO_LOGIN:
{
if (mWebViewClient != null) {
String realm=msg.getData().getString(""String_Node_Str"");
String account=msg.getData().getString(""String_Node_Str"");
String args=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(),realm,account,args);
}
break;
}
}
}","@Override public void handleMessage(Message msg){
  if (messagesBlocked())   return;
switch (msg.what) {
case PAGE_STARTED:
    String startedUrl=msg.getData().getString(""String_Node_Str"");
  mWebView.onPageStarted(startedUrl);
if (mWebViewClient != null) {
  mWebViewClient.onPageStarted(mWebView.getWebView(),startedUrl,(Bitmap)msg.obj);
}
break;
case PAGE_FINISHED:
String finishedUrl=(String)msg.obj;
mWebView.onPageFinished(finishedUrl);
if (mWebViewClient != null) {
mWebViewClient.onPageFinished(mWebView.getWebView(),finishedUrl);
}
break;
case RECEIVED_ICON:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedIcon(mWebView.getWebView(),(Bitmap)msg.obj);
}
break;
case RECEIVED_TOUCH_ICON_URL:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(),(String)msg.obj,msg.arg1 == 1);
}
break;
case RECEIVED_TITLE:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTitle(mWebView.getWebView(),(String)msg.obj);
}
break;
case REPORT_ERROR:
if (mWebViewClient != null) {
int reasonCode=msg.arg1;
final String description=msg.getData().getString(""String_Node_Str"");
final String failUrl=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedError(mWebView.getWebView(),reasonCode,description,failUrl);
}
break;
case RESEND_POST_DATA:
Message resend=(Message)msg.getData().getParcelable(""String_Node_Str"");
Message dontResend=(Message)msg.getData().getParcelable(""String_Node_Str"");
if (mWebViewClient != null) {
mWebViewClient.onFormResubmission(mWebView.getWebView(),dontResend,resend);
}
 else {
dontResend.sendToTarget();
}
break;
case OVERRIDE_URL:
String overrideUrl=msg.getData().getString(""String_Node_Str"");
boolean override=uiOverrideUrlLoading(overrideUrl);
ResultTransport<Boolean> result=(ResultTransport<Boolean>)msg.obj;
synchronized (this) {
result.setResult(override);
notify();
}
break;
case AUTH_REQUEST:
if (mWebViewClient != null) {
HttpAuthHandler handler=(HttpAuthHandler)msg.obj;
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(),handler,host,realm);
}
break;
case SSL_ERROR:
if (mWebViewClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
mWebViewClient.onReceivedSslError(mWebView.getWebView(),(SslErrorHandler)map.get(""String_Node_Str""),(SslError)map.get(""String_Node_Str""));
}
break;
case PROCEEDED_AFTER_SSL_ERROR:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
((WebViewClientClassicExt)mWebViewClient).onProceededAfterSslError(mWebView.getWebView(),(SslError)msg.obj);
}
break;
case CLIENT_CERT_REQUEST:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
((WebViewClientClassicExt)mWebViewClient).onReceivedClientCertRequest(mWebView.getWebView(),(ClientCertRequestHandler)map.get(""String_Node_Str""),(String)map.get(""String_Node_Str""));
}
break;
case PROGRESS:
synchronized (this) {
if (mWebChromeClient != null) {
mWebChromeClient.onProgressChanged(mWebView.getWebView(),mLatestProgress);
}
mProgressUpdatePending=false;
}
break;
case UPDATE_VISITED:
if (mWebViewClient != null) {
mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(),(String)msg.obj,msg.arg1 != 0);
}
break;
case LOAD_RESOURCE:
if (mWebViewClient != null) {
mWebViewClient.onLoadResource(mWebView.getWebView(),(String)msg.obj);
}
break;
case DOWNLOAD_FILE:
if (mDownloadListener != null) {
String url=msg.getData().getString(""String_Node_Str"");
String userAgent=msg.getData().getString(""String_Node_Str"");
String contentDisposition=msg.getData().getString(""String_Node_Str"");
String mimetype=msg.getData().getString(""String_Node_Str"");
String referer=msg.getData().getString(""String_Node_Str"");
Long contentLength=msg.getData().getLong(""String_Node_Str"");
if (mDownloadListener instanceof BrowserDownloadListener) {
((BrowserDownloadListener)mDownloadListener).onDownloadStart(url,userAgent,contentDisposition,mimetype,referer,contentLength);
}
 else {
mDownloadListener.onDownloadStart(url,userAgent,contentDisposition,mimetype,contentLength);
}
}
break;
case CREATE_WINDOW:
if (mWebChromeClient != null) {
if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(),msg.arg1 == 1,msg.arg2 == 1,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
mWebView.dismissZoomControl();
}
break;
case REQUEST_FOCUS:
if (mWebChromeClient != null) {
mWebChromeClient.onRequestFocus(mWebView.getWebView());
}
break;
case CLOSE_WINDOW:
if (mWebChromeClient != null) {
mWebChromeClient.onCloseWindow(((WebViewClassic)msg.obj).getWebView());
}
break;
case SAVE_PASSWORD:
Bundle bundle=msg.getData();
String schemePlusHost=bundle.getString(""String_Node_Str"");
String username=bundle.getString(""String_Node_Str"");
String password=bundle.getString(""String_Node_Str"");
if (!mWebView.onSavePassword(schemePlusHost,username,password,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
break;
case ASYNC_KEYEVENTS:
if (mWebViewClient != null) {
mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(),(KeyEvent)msg.obj);
}
break;
case EXCEEDED_DATABASE_QUOTA:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String databaseIdentifier=(String)map.get(""String_Node_Str"");
String url=(String)map.get(""String_Node_Str"");
long quota=((Long)map.get(""String_Node_Str"")).longValue();
long totalQuota=((Long)map.get(""String_Node_Str"")).longValue();
long estimatedDatabaseSize=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onExceededDatabaseQuota(url,databaseIdentifier,quota,estimatedDatabaseSize,totalQuota,quotaUpdater);
}
break;
case REACHED_APPCACHE_MAXSIZE:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
long requiredStorage=((Long)map.get(""String_Node_Str"")).longValue();
long quota=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage,quota,quotaUpdater);
}
break;
case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String origin=(String)map.get(""String_Node_Str"");
GeolocationPermissions.Callback callback=(GeolocationPermissions.Callback)map.get(""String_Node_Str"");
mWebChromeClient.onGeolocationPermissionsShowPrompt(origin,callback);
}
break;
case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
if (mWebChromeClient != null) {
mWebChromeClient.onGeolocationPermissionsHidePrompt();
}
break;
case JS_DIALOG:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
JsDialogHelper helper=new JsDialogHelper(receiver.mJsResult,msg);
if (!helper.invokeCallback(mWebChromeClient,mWebView.getWebView())) {
helper.showDialog(mContext);
}
receiver.setReady();
}
break;
case JS_TIMEOUT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
if (mWebChromeClient.onJsTimeout()) {
res.confirm();
}
 else {
res.cancel();
}
receiver.setReady();
}
break;
case RECEIVED_CERTIFICATE:
mWebView.setCertificate((SslCertificate)msg.obj);
break;
case NOTIFY:
synchronized (this) {
notify();
}
break;
case SCALE_CHANGED:
if (mWebViewClient != null) {
mWebViewClient.onScaleChanged(mWebView.getWebView(),msg.getData().getFloat(""String_Node_Str""),msg.getData().getFloat(""String_Node_Str""));
}
break;
case SWITCH_OUT_HISTORY:
mWebView.switchOutDrawHistory();
break;
case ADD_MESSAGE_TO_CONSOLE:
if (mWebChromeClient == null) {
break;
}
String message=msg.getData().getString(""String_Node_Str"");
String sourceID=msg.getData().getString(""String_Node_Str"");
int lineNumber=msg.getData().getInt(""String_Node_Str"");
int msgLevel=msg.getData().getInt(""String_Node_Str"");
int numberOfMessageLevels=ConsoleMessage.MessageLevel.values().length;
if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
msgLevel=0;
}
ConsoleMessage.MessageLevel messageLevel=ConsoleMessage.MessageLevel.values()[msgLevel];
if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message,sourceID,lineNumber,messageLevel))) {
String logTag=""String_Node_Str"";
String logMessage=message + ""String_Node_Str"" + sourceID+ ""String_Node_Str""+ lineNumber;
switch (messageLevel) {
case TIP:
Log.v(logTag,logMessage);
break;
case LOG:
Log.i(logTag,logMessage);
break;
case WARNING:
Log.w(logTag,logMessage);
break;
case ERROR:
Log.e(logTag,logMessage);
break;
case DEBUG:
Log.d(logTag,logMessage);
break;
}
}
break;
case GET_VISITED_HISTORY:
if (mWebChromeClient != null) {
mWebChromeClient.getVisitedHistory((ValueCallback<String[]>)msg.obj);
}
break;
case OPEN_FILE_CHOOSER:
if (mWebChromeClient != null) {
UploadFileMessageData data=(UploadFileMessageData)msg.obj;
mWebChromeClient.openFileChooser(data.getUploadFile(),data.getAcceptType(),data.getCapture());
}
break;
case ADD_HISTORY_ITEM:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem)msg.obj);
}
break;
case HISTORY_INDEX_CHANGED:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onIndexChanged((WebHistoryItem)msg.obj,msg.arg1);
}
break;
case AUTH_CREDENTIALS:
{
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
username=msg.getData().getString(""String_Node_Str"");
password=msg.getData().getString(""String_Node_Str"");
mWebView.setHttpAuthUsernamePassword(host,realm,username,password);
break;
}
case AUTO_LOGIN:
{
if (mWebViewClient != null) {
String realm=msg.getData().getString(""String_Node_Str"");
String account=msg.getData().getString(""String_Node_Str"");
String args=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(),realm,account,args);
}
break;
}
}
}"
2290,"public boolean onJsConfirm(String url,String message){
  if (mWebChromeClient == null) {
    return false;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message confirm=obtainMessage(JS_CONFIRM,result);
  confirm.getData().putString(""String_Node_Str"",message);
  confirm.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(confirm);
  return result.mJsResult.getResult();
}","public boolean onJsConfirm(String url,String message){
  if (mWebChromeClient == null) {
    return false;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message confirm=obtainMessage(JS_DIALOG,result);
  confirm.getData().putString(""String_Node_Str"",message);
  confirm.getData().putString(""String_Node_Str"",url);
  confirm.getData().putInt(""String_Node_Str"",JsDialogHelper.CONFIRM);
  sendMessageToUiThreadSync(confirm);
  return result.mJsResult.getResult();
}"
2291,"public void onJsAlert(String url,String message){
  if (mWebChromeClient == null) {
    return;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message alert=obtainMessage(JS_ALERT,result);
  alert.getData().putString(""String_Node_Str"",message);
  alert.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(alert);
}","public void onJsAlert(String url,String message){
  if (mWebChromeClient == null) {
    return;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message alert=obtainMessage(JS_DIALOG,result);
  alert.getData().putString(""String_Node_Str"",message);
  alert.getData().putString(""String_Node_Str"",url);
  alert.getData().putInt(""String_Node_Str"",JsDialogHelper.ALERT);
  sendMessageToUiThreadSync(alert);
}"
2292,"public String onJsPrompt(String url,String message,String defaultValue){
  if (mWebChromeClient == null) {
    return null;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message prompt=obtainMessage(JS_PROMPT,result);
  prompt.getData().putString(""String_Node_Str"",message);
  prompt.getData().putString(""String_Node_Str"",defaultValue);
  prompt.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(prompt);
  return result.mJsResult.getStringResult();
}","public String onJsPrompt(String url,String message,String defaultValue){
  if (mWebChromeClient == null) {
    return null;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message prompt=obtainMessage(JS_DIALOG,result);
  prompt.getData().putString(""String_Node_Str"",message);
  prompt.getData().putString(""String_Node_Str"",defaultValue);
  prompt.getData().putString(""String_Node_Str"",url);
  prompt.getData().putInt(""String_Node_Str"",JsDialogHelper.PROMPT);
  sendMessageToUiThreadSync(prompt);
  return result.mJsResult.getStringResult();
}"
2293,"public boolean onJsBeforeUnload(String url,String message){
  if (mWebChromeClient == null) {
    return true;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message confirm=obtainMessage(JS_UNLOAD,result);
  confirm.getData().putString(""String_Node_Str"",message);
  confirm.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(confirm);
  return result.mJsResult.getResult();
}","public boolean onJsBeforeUnload(String url,String message){
  if (mWebChromeClient == null) {
    return true;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message unload=obtainMessage(JS_DIALOG,result);
  unload.getData().putString(""String_Node_Str"",message);
  unload.getData().putString(""String_Node_Str"",url);
  unload.getData().putInt(""String_Node_Str"",JsDialogHelper.UNLOAD);
  sendMessageToUiThreadSync(unload);
  return result.mJsResult.getResult();
}"
2294,"@Override public void handleMessage(Message msg){
  if (messagesBlocked())   return;
switch (msg.what) {
case PAGE_STARTED:
    String startedUrl=msg.getData().getString(""String_Node_Str"");
  mWebView.onPageStarted(startedUrl);
if (mWebViewClient != null) {
  mWebViewClient.onPageStarted(mWebView.getWebView(),startedUrl,(Bitmap)msg.obj);
}
break;
case PAGE_FINISHED:
String finishedUrl=(String)msg.obj;
mWebView.onPageFinished(finishedUrl);
if (mWebViewClient != null) {
mWebViewClient.onPageFinished(mWebView.getWebView(),finishedUrl);
}
break;
case RECEIVED_ICON:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedIcon(mWebView.getWebView(),(Bitmap)msg.obj);
}
break;
case RECEIVED_TOUCH_ICON_URL:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(),(String)msg.obj,msg.arg1 == 1);
}
break;
case RECEIVED_TITLE:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTitle(mWebView.getWebView(),(String)msg.obj);
}
break;
case REPORT_ERROR:
if (mWebViewClient != null) {
int reasonCode=msg.arg1;
final String description=msg.getData().getString(""String_Node_Str"");
final String failUrl=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedError(mWebView.getWebView(),reasonCode,description,failUrl);
}
break;
case RESEND_POST_DATA:
Message resend=(Message)msg.getData().getParcelable(""String_Node_Str"");
Message dontResend=(Message)msg.getData().getParcelable(""String_Node_Str"");
if (mWebViewClient != null) {
mWebViewClient.onFormResubmission(mWebView.getWebView(),dontResend,resend);
}
 else {
dontResend.sendToTarget();
}
break;
case OVERRIDE_URL:
String overrideUrl=msg.getData().getString(""String_Node_Str"");
boolean override=uiOverrideUrlLoading(overrideUrl);
ResultTransport<Boolean> result=(ResultTransport<Boolean>)msg.obj;
synchronized (this) {
result.setResult(override);
notify();
}
break;
case AUTH_REQUEST:
if (mWebViewClient != null) {
HttpAuthHandler handler=(HttpAuthHandler)msg.obj;
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(),handler,host,realm);
}
break;
case SSL_ERROR:
if (mWebViewClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
mWebViewClient.onReceivedSslError(mWebView.getWebView(),(SslErrorHandler)map.get(""String_Node_Str""),(SslError)map.get(""String_Node_Str""));
}
break;
case PROCEEDED_AFTER_SSL_ERROR:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
((WebViewClientClassicExt)mWebViewClient).onProceededAfterSslError(mWebView.getWebView(),(SslError)msg.obj);
}
break;
case CLIENT_CERT_REQUEST:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
((WebViewClientClassicExt)mWebViewClient).onReceivedClientCertRequest(mWebView.getWebView(),(ClientCertRequestHandler)map.get(""String_Node_Str""),(String)map.get(""String_Node_Str""));
}
break;
case PROGRESS:
synchronized (this) {
if (mWebChromeClient != null) {
mWebChromeClient.onProgressChanged(mWebView.getWebView(),mLatestProgress);
}
mProgressUpdatePending=false;
}
break;
case UPDATE_VISITED:
if (mWebViewClient != null) {
mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(),(String)msg.obj,msg.arg1 != 0);
}
break;
case LOAD_RESOURCE:
if (mWebViewClient != null) {
mWebViewClient.onLoadResource(mWebView.getWebView(),(String)msg.obj);
}
break;
case DOWNLOAD_FILE:
if (mDownloadListener != null) {
String url=msg.getData().getString(""String_Node_Str"");
String userAgent=msg.getData().getString(""String_Node_Str"");
String contentDisposition=msg.getData().getString(""String_Node_Str"");
String mimetype=msg.getData().getString(""String_Node_Str"");
String referer=msg.getData().getString(""String_Node_Str"");
Long contentLength=msg.getData().getLong(""String_Node_Str"");
if (mDownloadListener instanceof BrowserDownloadListener) {
((BrowserDownloadListener)mDownloadListener).onDownloadStart(url,userAgent,contentDisposition,mimetype,referer,contentLength);
}
 else {
mDownloadListener.onDownloadStart(url,userAgent,contentDisposition,mimetype,contentLength);
}
}
break;
case CREATE_WINDOW:
if (mWebChromeClient != null) {
if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(),msg.arg1 == 1,msg.arg2 == 1,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
mWebView.dismissZoomControl();
}
break;
case REQUEST_FOCUS:
if (mWebChromeClient != null) {
mWebChromeClient.onRequestFocus(mWebView.getWebView());
}
break;
case CLOSE_WINDOW:
if (mWebChromeClient != null) {
mWebChromeClient.onCloseWindow(((WebViewClassic)msg.obj).getWebView());
}
break;
case SAVE_PASSWORD:
Bundle bundle=msg.getData();
String schemePlusHost=bundle.getString(""String_Node_Str"");
String username=bundle.getString(""String_Node_Str"");
String password=bundle.getString(""String_Node_Str"");
if (!mWebView.onSavePassword(schemePlusHost,username,password,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
break;
case ASYNC_KEYEVENTS:
if (mWebViewClient != null) {
mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(),(KeyEvent)msg.obj);
}
break;
case EXCEEDED_DATABASE_QUOTA:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String databaseIdentifier=(String)map.get(""String_Node_Str"");
String url=(String)map.get(""String_Node_Str"");
long quota=((Long)map.get(""String_Node_Str"")).longValue();
long totalQuota=((Long)map.get(""String_Node_Str"")).longValue();
long estimatedDatabaseSize=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onExceededDatabaseQuota(url,databaseIdentifier,quota,estimatedDatabaseSize,totalQuota,quotaUpdater);
}
break;
case REACHED_APPCACHE_MAXSIZE:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
long requiredStorage=((Long)map.get(""String_Node_Str"")).longValue();
long quota=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage,quota,quotaUpdater);
}
break;
case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String origin=(String)map.get(""String_Node_Str"");
GeolocationPermissions.Callback callback=(GeolocationPermissions.Callback)map.get(""String_Node_Str"");
mWebChromeClient.onGeolocationPermissionsShowPrompt(origin,callback);
}
break;
case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
if (mWebChromeClient != null) {
mWebChromeClient.onGeolocationPermissionsHidePrompt();
}
break;
case JS_ALERT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsAlert(mWebView.getWebView(),url,message,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.confirm();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_CONFIRM:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsConfirm(mWebView.getWebView(),url,message,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.confirm();
}
}
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.cancel();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_PROMPT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsPromptResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String defaultVal=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsPrompt(mWebView.getWebView(),url,message,defaultVal,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
final LayoutInflater factory=LayoutInflater.from(mContext);
final View view=factory.inflate(R.layout.js_prompt,null);
final EditText v=(EditText)view.findViewById(R.id.value);
v.setText(defaultVal);
((TextView)view.findViewById(R.id.message)).setText(message);
new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setView(view).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
res.confirm(v.getText().toString());
}
}
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
res.cancel();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_UNLOAD:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsBeforeUnload(mWebView.getWebView(),url,message,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
final String m=mContext.getString(R.string.js_dialog_before_unload,message);
new AlertDialog.Builder(mContext).setMessage(m).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.confirm();
}
}
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.cancel();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
@Override public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_TIMEOUT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
if (mWebChromeClient.onJsTimeout()) {
res.confirm();
}
 else {
res.cancel();
}
receiver.setReady();
}
break;
case RECEIVED_CERTIFICATE:
mWebView.setCertificate((SslCertificate)msg.obj);
break;
case NOTIFY:
synchronized (this) {
notify();
}
break;
case SCALE_CHANGED:
if (mWebViewClient != null) {
mWebViewClient.onScaleChanged(mWebView.getWebView(),msg.getData().getFloat(""String_Node_Str""),msg.getData().getFloat(""String_Node_Str""));
}
break;
case SWITCH_OUT_HISTORY:
mWebView.switchOutDrawHistory();
break;
case ADD_MESSAGE_TO_CONSOLE:
if (mWebChromeClient == null) {
break;
}
String message=msg.getData().getString(""String_Node_Str"");
String sourceID=msg.getData().getString(""String_Node_Str"");
int lineNumber=msg.getData().getInt(""String_Node_Str"");
int msgLevel=msg.getData().getInt(""String_Node_Str"");
int numberOfMessageLevels=ConsoleMessage.MessageLevel.values().length;
if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
msgLevel=0;
}
ConsoleMessage.MessageLevel messageLevel=ConsoleMessage.MessageLevel.values()[msgLevel];
if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message,sourceID,lineNumber,messageLevel))) {
String logTag=""String_Node_Str"";
String logMessage=message + ""String_Node_Str"" + sourceID+ ""String_Node_Str""+ lineNumber;
switch (messageLevel) {
case TIP:
Log.v(logTag,logMessage);
break;
case LOG:
Log.i(logTag,logMessage);
break;
case WARNING:
Log.w(logTag,logMessage);
break;
case ERROR:
Log.e(logTag,logMessage);
break;
case DEBUG:
Log.d(logTag,logMessage);
break;
}
}
break;
case GET_VISITED_HISTORY:
if (mWebChromeClient != null) {
mWebChromeClient.getVisitedHistory((ValueCallback<String[]>)msg.obj);
}
break;
case OPEN_FILE_CHOOSER:
if (mWebChromeClient != null) {
UploadFileMessageData data=(UploadFileMessageData)msg.obj;
mWebChromeClient.openFileChooser(data.getUploadFile(),data.getAcceptType(),data.getCapture());
}
break;
case ADD_HISTORY_ITEM:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem)msg.obj);
}
break;
case HISTORY_INDEX_CHANGED:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onIndexChanged((WebHistoryItem)msg.obj,msg.arg1);
}
break;
case AUTH_CREDENTIALS:
{
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
username=msg.getData().getString(""String_Node_Str"");
password=msg.getData().getString(""String_Node_Str"");
mWebView.setHttpAuthUsernamePassword(host,realm,username,password);
break;
}
case AUTO_LOGIN:
{
if (mWebViewClient != null) {
String realm=msg.getData().getString(""String_Node_Str"");
String account=msg.getData().getString(""String_Node_Str"");
String args=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(),realm,account,args);
}
break;
}
}
}","@Override public void handleMessage(Message msg){
  if (messagesBlocked())   return;
switch (msg.what) {
case PAGE_STARTED:
    String startedUrl=msg.getData().getString(""String_Node_Str"");
  mWebView.onPageStarted(startedUrl);
if (mWebViewClient != null) {
  mWebViewClient.onPageStarted(mWebView.getWebView(),startedUrl,(Bitmap)msg.obj);
}
break;
case PAGE_FINISHED:
String finishedUrl=(String)msg.obj;
mWebView.onPageFinished(finishedUrl);
if (mWebViewClient != null) {
mWebViewClient.onPageFinished(mWebView.getWebView(),finishedUrl);
}
break;
case RECEIVED_ICON:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedIcon(mWebView.getWebView(),(Bitmap)msg.obj);
}
break;
case RECEIVED_TOUCH_ICON_URL:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(),(String)msg.obj,msg.arg1 == 1);
}
break;
case RECEIVED_TITLE:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTitle(mWebView.getWebView(),(String)msg.obj);
}
break;
case REPORT_ERROR:
if (mWebViewClient != null) {
int reasonCode=msg.arg1;
final String description=msg.getData().getString(""String_Node_Str"");
final String failUrl=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedError(mWebView.getWebView(),reasonCode,description,failUrl);
}
break;
case RESEND_POST_DATA:
Message resend=(Message)msg.getData().getParcelable(""String_Node_Str"");
Message dontResend=(Message)msg.getData().getParcelable(""String_Node_Str"");
if (mWebViewClient != null) {
mWebViewClient.onFormResubmission(mWebView.getWebView(),dontResend,resend);
}
 else {
dontResend.sendToTarget();
}
break;
case OVERRIDE_URL:
String overrideUrl=msg.getData().getString(""String_Node_Str"");
boolean override=uiOverrideUrlLoading(overrideUrl);
ResultTransport<Boolean> result=(ResultTransport<Boolean>)msg.obj;
synchronized (this) {
result.setResult(override);
notify();
}
break;
case AUTH_REQUEST:
if (mWebViewClient != null) {
HttpAuthHandler handler=(HttpAuthHandler)msg.obj;
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(),handler,host,realm);
}
break;
case SSL_ERROR:
if (mWebViewClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
mWebViewClient.onReceivedSslError(mWebView.getWebView(),(SslErrorHandler)map.get(""String_Node_Str""),(SslError)map.get(""String_Node_Str""));
}
break;
case PROCEEDED_AFTER_SSL_ERROR:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
((WebViewClientClassicExt)mWebViewClient).onProceededAfterSslError(mWebView.getWebView(),(SslError)msg.obj);
}
break;
case CLIENT_CERT_REQUEST:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
((WebViewClientClassicExt)mWebViewClient).onReceivedClientCertRequest(mWebView.getWebView(),(ClientCertRequestHandler)map.get(""String_Node_Str""),(String)map.get(""String_Node_Str""));
}
break;
case PROGRESS:
synchronized (this) {
if (mWebChromeClient != null) {
mWebChromeClient.onProgressChanged(mWebView.getWebView(),mLatestProgress);
}
mProgressUpdatePending=false;
}
break;
case UPDATE_VISITED:
if (mWebViewClient != null) {
mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(),(String)msg.obj,msg.arg1 != 0);
}
break;
case LOAD_RESOURCE:
if (mWebViewClient != null) {
mWebViewClient.onLoadResource(mWebView.getWebView(),(String)msg.obj);
}
break;
case DOWNLOAD_FILE:
if (mDownloadListener != null) {
String url=msg.getData().getString(""String_Node_Str"");
String userAgent=msg.getData().getString(""String_Node_Str"");
String contentDisposition=msg.getData().getString(""String_Node_Str"");
String mimetype=msg.getData().getString(""String_Node_Str"");
String referer=msg.getData().getString(""String_Node_Str"");
Long contentLength=msg.getData().getLong(""String_Node_Str"");
if (mDownloadListener instanceof BrowserDownloadListener) {
((BrowserDownloadListener)mDownloadListener).onDownloadStart(url,userAgent,contentDisposition,mimetype,referer,contentLength);
}
 else {
mDownloadListener.onDownloadStart(url,userAgent,contentDisposition,mimetype,contentLength);
}
}
break;
case CREATE_WINDOW:
if (mWebChromeClient != null) {
if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(),msg.arg1 == 1,msg.arg2 == 1,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
mWebView.dismissZoomControl();
}
break;
case REQUEST_FOCUS:
if (mWebChromeClient != null) {
mWebChromeClient.onRequestFocus(mWebView.getWebView());
}
break;
case CLOSE_WINDOW:
if (mWebChromeClient != null) {
mWebChromeClient.onCloseWindow(((WebViewClassic)msg.obj).getWebView());
}
break;
case SAVE_PASSWORD:
Bundle bundle=msg.getData();
String schemePlusHost=bundle.getString(""String_Node_Str"");
String username=bundle.getString(""String_Node_Str"");
String password=bundle.getString(""String_Node_Str"");
if (!mWebView.onSavePassword(schemePlusHost,username,password,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
break;
case ASYNC_KEYEVENTS:
if (mWebViewClient != null) {
mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(),(KeyEvent)msg.obj);
}
break;
case EXCEEDED_DATABASE_QUOTA:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String databaseIdentifier=(String)map.get(""String_Node_Str"");
String url=(String)map.get(""String_Node_Str"");
long quota=((Long)map.get(""String_Node_Str"")).longValue();
long totalQuota=((Long)map.get(""String_Node_Str"")).longValue();
long estimatedDatabaseSize=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onExceededDatabaseQuota(url,databaseIdentifier,quota,estimatedDatabaseSize,totalQuota,quotaUpdater);
}
break;
case REACHED_APPCACHE_MAXSIZE:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
long requiredStorage=((Long)map.get(""String_Node_Str"")).longValue();
long quota=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage,quota,quotaUpdater);
}
break;
case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String origin=(String)map.get(""String_Node_Str"");
GeolocationPermissions.Callback callback=(GeolocationPermissions.Callback)map.get(""String_Node_Str"");
mWebChromeClient.onGeolocationPermissionsShowPrompt(origin,callback);
}
break;
case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
if (mWebChromeClient != null) {
mWebChromeClient.onGeolocationPermissionsHidePrompt();
}
break;
case JS_DIALOG:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
JsDialogHelper helper=new JsDialogHelper(receiver.mJsResult,msg);
if (!helper.invokeCallback(mWebChromeClient,mWebView.getWebView())) {
helper.showDialog(mContext);
}
receiver.setReady();
}
break;
case JS_TIMEOUT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
if (mWebChromeClient.onJsTimeout()) {
res.confirm();
}
 else {
res.cancel();
}
receiver.setReady();
}
break;
case RECEIVED_CERTIFICATE:
mWebView.setCertificate((SslCertificate)msg.obj);
break;
case NOTIFY:
synchronized (this) {
notify();
}
break;
case SCALE_CHANGED:
if (mWebViewClient != null) {
mWebViewClient.onScaleChanged(mWebView.getWebView(),msg.getData().getFloat(""String_Node_Str""),msg.getData().getFloat(""String_Node_Str""));
}
break;
case SWITCH_OUT_HISTORY:
mWebView.switchOutDrawHistory();
break;
case ADD_MESSAGE_TO_CONSOLE:
if (mWebChromeClient == null) {
break;
}
String message=msg.getData().getString(""String_Node_Str"");
String sourceID=msg.getData().getString(""String_Node_Str"");
int lineNumber=msg.getData().getInt(""String_Node_Str"");
int msgLevel=msg.getData().getInt(""String_Node_Str"");
int numberOfMessageLevels=ConsoleMessage.MessageLevel.values().length;
if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
msgLevel=0;
}
ConsoleMessage.MessageLevel messageLevel=ConsoleMessage.MessageLevel.values()[msgLevel];
if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message,sourceID,lineNumber,messageLevel))) {
String logTag=""String_Node_Str"";
String logMessage=message + ""String_Node_Str"" + sourceID+ ""String_Node_Str""+ lineNumber;
switch (messageLevel) {
case TIP:
Log.v(logTag,logMessage);
break;
case LOG:
Log.i(logTag,logMessage);
break;
case WARNING:
Log.w(logTag,logMessage);
break;
case ERROR:
Log.e(logTag,logMessage);
break;
case DEBUG:
Log.d(logTag,logMessage);
break;
}
}
break;
case GET_VISITED_HISTORY:
if (mWebChromeClient != null) {
mWebChromeClient.getVisitedHistory((ValueCallback<String[]>)msg.obj);
}
break;
case OPEN_FILE_CHOOSER:
if (mWebChromeClient != null) {
UploadFileMessageData data=(UploadFileMessageData)msg.obj;
mWebChromeClient.openFileChooser(data.getUploadFile(),data.getAcceptType(),data.getCapture());
}
break;
case ADD_HISTORY_ITEM:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem)msg.obj);
}
break;
case HISTORY_INDEX_CHANGED:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onIndexChanged((WebHistoryItem)msg.obj,msg.arg1);
}
break;
case AUTH_CREDENTIALS:
{
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
username=msg.getData().getString(""String_Node_Str"");
password=msg.getData().getString(""String_Node_Str"");
mWebView.setHttpAuthUsernamePassword(host,realm,username,password);
break;
}
case AUTO_LOGIN:
{
if (mWebViewClient != null) {
String realm=msg.getData().getString(""String_Node_Str"");
String account=msg.getData().getString(""String_Node_Str"");
String args=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(),realm,account,args);
}
break;
}
}
}"
2295,"@Override public void addTestProvider(String name,ProviderProperties properties){
  checkMockPermissionsSafe();
  if (LocationManager.PASSIVE_PROVIDER.equals(name)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  long identity=Binder.clearCallingIdentity();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,properties);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name) || LocationManager.FUSED_PROVIDER.equals(name)) {
      LocationProviderInterface p=mProvidersByName.get(name);
      if (p != null) {
        removeProviderLocked(p);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProviderLocked(provider);
    mMockProviders.put(name,provider);
    mLastLocation.put(name,null);
    updateProvidersLocked();
  }
  Binder.restoreCallingIdentity(identity);
}","@Override public void addTestProvider(String name,ProviderProperties properties){
  checkMockPermissionsSafe();
  if (LocationManager.PASSIVE_PROVIDER.equals(name)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  long identity=Binder.clearCallingIdentity();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,properties);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name) || LocationManager.FUSED_PROVIDER.equals(name)) {
      LocationProviderInterface p=mProvidersByName.get(name);
      if (p != null) {
        removeProviderLocked(p);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProviderLocked(provider);
    mMockProviders.put(name,provider);
    mLastLocation.put(name,null);
    mLastLocationCoarseInterval.put(name,null);
    updateProvidersLocked();
  }
  Binder.restoreCallingIdentity(identity);
}"
2296,"private void handleLocationChangedLocked(Location location,boolean passive){
  if (D)   Log.d(TAG,""String_Node_Str"" + location);
  long now=SystemClock.elapsedRealtime();
  String provider=(passive ? LocationManager.PASSIVE_PROVIDER : location.getProvider());
  LocationProviderInterface p=mProvidersByName.get(provider);
  if (p == null)   return;
  Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
  Location lastNoGPSLocation=null;
  Location lastLocation=mLastLocation.get(provider);
  if (lastLocation == null) {
    lastLocation=new Location(provider);
    mLastLocation.put(provider,lastLocation);
  }
 else {
    lastNoGPSLocation=lastLocation.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
    if (noGPSLocation == null && lastNoGPSLocation != null) {
      location.setExtraLocation(Location.EXTRA_NO_GPS_LOCATION,lastNoGPSLocation);
    }
  }
  lastLocation.set(location);
  ArrayList<UpdateRecord> records=mRecordsByProvider.get(provider);
  if (records == null || records.size() == 0)   return;
  Location coarseLocation=null;
  if (noGPSLocation != null && !noGPSLocation.equals(lastNoGPSLocation)) {
    coarseLocation=mLocationFudger.getOrCreate(noGPSLocation);
  }
  long newStatusUpdateTime=p.getStatusUpdateTime();
  Bundle extras=new Bundle();
  int status=p.getStatus(extras);
  ArrayList<Receiver> deadReceivers=null;
  ArrayList<UpdateRecord> deadUpdateRecords=null;
  for (  UpdateRecord r : records) {
    Receiver receiver=r.mReceiver;
    boolean receiverDead=false;
    int receiverUserId=UserHandle.getUserId(receiver.mUid);
    if (receiverUserId != mCurrentUserId) {
      if (D) {
        Log.d(TAG,""String_Node_Str"" + receiverUserId + ""String_Node_Str""+ mCurrentUserId+ ""String_Node_Str""+ receiver.mPackageName+ ""String_Node_Str"");
      }
      continue;
    }
    if (mBlacklist.isBlacklisted(receiver.mPackageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    if (!reportLocationAccessNoThrow(receiver.mUid,receiver.mPackageName,receiver.mAllowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    Location notifyLocation=null;
    if (receiver.mAllowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
      notifyLocation=coarseLocation;
    }
 else {
      notifyLocation=lastLocation;
    }
    if (notifyLocation != null) {
      Location lastLoc=r.mLastFixBroadcast;
      if ((lastLoc == null) || shouldBroadcastSafe(notifyLocation,lastLoc,r,now)) {
        if (lastLoc == null) {
          lastLoc=new Location(notifyLocation);
          r.mLastFixBroadcast=lastLoc;
        }
 else {
          lastLoc.set(notifyLocation);
        }
        if (!receiver.callLocationChangedLocked(notifyLocation)) {
          Slog.w(TAG,""String_Node_Str"" + receiver);
          receiverDead=true;
        }
        r.mRequest.decrementNumUpdates();
      }
    }
    long prevStatusUpdateTime=r.mLastStatusBroadcast;
    if ((newStatusUpdateTime > prevStatusUpdateTime) && (prevStatusUpdateTime != 0 || status != LocationProvider.AVAILABLE)) {
      r.mLastStatusBroadcast=newStatusUpdateTime;
      if (!receiver.callStatusChangedLocked(provider,status,extras)) {
        receiverDead=true;
        Slog.w(TAG,""String_Node_Str"" + receiver);
      }
    }
    if (r.mRequest.getNumUpdates() <= 0 || r.mRequest.getExpireAt() < now) {
      if (deadUpdateRecords == null) {
        deadUpdateRecords=new ArrayList<UpdateRecord>();
      }
      deadUpdateRecords.add(r);
    }
    if (receiverDead) {
      if (deadReceivers == null) {
        deadReceivers=new ArrayList<Receiver>();
      }
      if (!deadReceivers.contains(receiver)) {
        deadReceivers.add(receiver);
      }
    }
  }
  if (deadReceivers != null) {
    for (    Receiver receiver : deadReceivers) {
      removeUpdatesLocked(receiver);
    }
  }
  if (deadUpdateRecords != null) {
    for (    UpdateRecord r : deadUpdateRecords) {
      r.disposeLocked(true);
    }
    applyRequirementsLocked(provider);
  }
}","private void handleLocationChangedLocked(Location location,boolean passive){
  if (D)   Log.d(TAG,""String_Node_Str"" + location);
  long now=SystemClock.elapsedRealtime();
  String provider=(passive ? LocationManager.PASSIVE_PROVIDER : location.getProvider());
  LocationProviderInterface p=mProvidersByName.get(provider);
  if (p == null)   return;
  Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
  Location lastNoGPSLocation=null;
  Location lastLocation=mLastLocation.get(provider);
  if (lastLocation == null) {
    lastLocation=new Location(provider);
    mLastLocation.put(provider,lastLocation);
  }
 else {
    lastNoGPSLocation=lastLocation.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
    if (noGPSLocation == null && lastNoGPSLocation != null) {
      location.setExtraLocation(Location.EXTRA_NO_GPS_LOCATION,lastNoGPSLocation);
    }
  }
  lastLocation.set(location);
  Location lastLocationCoarseInterval=mLastLocationCoarseInterval.get(provider);
  if (lastLocationCoarseInterval == null) {
    lastLocationCoarseInterval=new Location(location);
    mLastLocationCoarseInterval.put(provider,lastLocationCoarseInterval);
  }
  long timeDiffNanos=location.getElapsedRealtimeNanos() - lastLocationCoarseInterval.getElapsedRealtimeNanos();
  if (timeDiffNanos > LocationFudger.FASTEST_INTERVAL_MS * NANOS_PER_MILLI) {
    lastLocationCoarseInterval.set(location);
  }
  noGPSLocation=lastLocationCoarseInterval.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
  ArrayList<UpdateRecord> records=mRecordsByProvider.get(provider);
  if (records == null || records.size() == 0)   return;
  Location coarseLocation=null;
  if (noGPSLocation != null) {
    coarseLocation=mLocationFudger.getOrCreate(noGPSLocation);
  }
  long newStatusUpdateTime=p.getStatusUpdateTime();
  Bundle extras=new Bundle();
  int status=p.getStatus(extras);
  ArrayList<Receiver> deadReceivers=null;
  ArrayList<UpdateRecord> deadUpdateRecords=null;
  for (  UpdateRecord r : records) {
    Receiver receiver=r.mReceiver;
    boolean receiverDead=false;
    int receiverUserId=UserHandle.getUserId(receiver.mUid);
    if (receiverUserId != mCurrentUserId) {
      if (D) {
        Log.d(TAG,""String_Node_Str"" + receiverUserId + ""String_Node_Str""+ mCurrentUserId+ ""String_Node_Str""+ receiver.mPackageName+ ""String_Node_Str"");
      }
      continue;
    }
    if (mBlacklist.isBlacklisted(receiver.mPackageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    if (!reportLocationAccessNoThrow(receiver.mUid,receiver.mPackageName,receiver.mAllowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    Location notifyLocation=null;
    if (receiver.mAllowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
      notifyLocation=coarseLocation;
    }
 else {
      notifyLocation=lastLocation;
    }
    if (notifyLocation != null) {
      Location lastLoc=r.mLastFixBroadcast;
      if ((lastLoc == null) || shouldBroadcastSafe(notifyLocation,lastLoc,r,now)) {
        if (lastLoc == null) {
          lastLoc=new Location(notifyLocation);
          r.mLastFixBroadcast=lastLoc;
        }
 else {
          lastLoc.set(notifyLocation);
        }
        if (!receiver.callLocationChangedLocked(notifyLocation)) {
          Slog.w(TAG,""String_Node_Str"" + receiver);
          receiverDead=true;
        }
        r.mRequest.decrementNumUpdates();
      }
    }
    long prevStatusUpdateTime=r.mLastStatusBroadcast;
    if ((newStatusUpdateTime > prevStatusUpdateTime) && (prevStatusUpdateTime != 0 || status != LocationProvider.AVAILABLE)) {
      r.mLastStatusBroadcast=newStatusUpdateTime;
      if (!receiver.callStatusChangedLocked(provider,status,extras)) {
        receiverDead=true;
        Slog.w(TAG,""String_Node_Str"" + receiver);
      }
    }
    if (r.mRequest.getNumUpdates() <= 0 || r.mRequest.getExpireAt() < now) {
      if (deadUpdateRecords == null) {
        deadUpdateRecords=new ArrayList<UpdateRecord>();
      }
      deadUpdateRecords.add(r);
    }
    if (receiverDead) {
      if (deadReceivers == null) {
        deadReceivers=new ArrayList<Receiver>();
      }
      if (!deadReceivers.contains(receiver)) {
        deadReceivers.add(receiver);
      }
    }
  }
  if (deadReceivers != null) {
    for (    Receiver receiver : deadReceivers) {
      removeUpdatesLocked(receiver);
    }
  }
  if (deadUpdateRecords != null) {
    for (    UpdateRecord r : deadUpdateRecords) {
      r.disposeLocked(true);
    }
    applyRequirementsLocked(provider);
  }
}"
2297,"/** 
 * Called when the device's active user changes.
 * @param userId the new active user's UserId
 */
private void switchUser(int userId){
  mBlacklist.switchUser(userId);
  mLocationHandler.removeMessages(MSG_LOCATION_CHANGED);
synchronized (mLock) {
    mLastLocation.clear();
    for (    LocationProviderInterface p : mProviders) {
      updateProviderListenersLocked(p.getName(),false,mCurrentUserId);
    }
    mCurrentUserId=userId;
    updateProvidersLocked();
  }
}","/** 
 * Called when the device's active user changes.
 * @param userId the new active user's UserId
 */
private void switchUser(int userId){
  mBlacklist.switchUser(userId);
  mLocationHandler.removeMessages(MSG_LOCATION_CHANGED);
synchronized (mLock) {
    mLastLocation.clear();
    mLastLocationCoarseInterval.clear();
    for (    LocationProviderInterface p : mProviders) {
      updateProviderListenersLocked(p.getName(),false,mCurrentUserId);
    }
    mCurrentUserId=userId;
    updateProvidersLocked();
  }
}"
2298,"@Override public Location getLastLocation(LocationRequest request,String packageName){
  if (D)   Log.d(TAG,""String_Node_Str"" + request);
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkPackageName(packageName);
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  final int uid=Binder.getCallingUid();
  final long identity=Binder.clearCallingIdentity();
  try {
    if (mBlacklist.isBlacklisted(packageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
    if (!reportLocationAccessNoThrow(uid,packageName,allowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
synchronized (mLock) {
      String name=request.getProvider();
      if (name == null)       name=LocationManager.FUSED_PROVIDER;
      LocationProviderInterface provider=mProvidersByName.get(name);
      if (provider == null)       return null;
      if (!isAllowedByUserSettingsLocked(name,uid))       return null;
      Location location=mLastLocation.get(name);
      if (location == null) {
        return null;
      }
      if (allowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
        Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
        if (noGPSLocation != null) {
          return new Location(mLocationFudger.getOrCreate(noGPSLocation));
        }
      }
 else {
        return new Location(location);
      }
    }
    return null;
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public Location getLastLocation(LocationRequest request,String packageName){
  if (D)   Log.d(TAG,""String_Node_Str"" + request);
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkPackageName(packageName);
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  final int uid=Binder.getCallingUid();
  final long identity=Binder.clearCallingIdentity();
  try {
    if (mBlacklist.isBlacklisted(packageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
    if (!reportLocationAccessNoThrow(uid,packageName,allowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
synchronized (mLock) {
      String name=request.getProvider();
      if (name == null)       name=LocationManager.FUSED_PROVIDER;
      LocationProviderInterface provider=mProvidersByName.get(name);
      if (provider == null)       return null;
      if (!isAllowedByUserSettingsLocked(name,uid))       return null;
      Location location;
      if (allowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
        location=mLastLocationCoarseInterval.get(name);
      }
 else {
        location=mLastLocation.get(name);
      }
      if (location == null) {
        return null;
      }
      if (allowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
        Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
        if (noGPSLocation != null) {
          return new Location(mLocationFudger.getOrCreate(noGPSLocation));
        }
      }
 else {
        return new Location(location);
      }
    }
    return null;
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}"
2299,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
synchronized (mLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (    Receiver receiver : mReceivers.values()) {
      pw.println(""String_Node_Str"" + receiver);
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,ArrayList<UpdateRecord>> entry : mRecordsByProvider.entrySet()) {
      pw.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      for (      UpdateRecord record : entry.getValue()) {
        pw.println(""String_Node_Str"" + record);
      }
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,Location> entry : mLastLocation.entrySet()) {
      String provider=entry.getKey();
      Location location=entry.getValue();
      pw.println(""String_Node_Str"" + provider + ""String_Node_Str""+ location);
    }
    mGeofenceManager.dump(pw);
    if (mEnabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mEnabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    if (mDisabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mDisabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    pw.append(""String_Node_Str"");
    mBlacklist.dump(pw);
    if (mMockProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      Map.Entry<String,MockProvider> i : mMockProviders.entrySet()) {
        i.getValue().dump(pw,""String_Node_Str"");
      }
    }
    pw.append(""String_Node_Str"");
    mLocationFudger.dump(fd,pw,args);
    if (args.length > 0 && ""String_Node_Str"".equals(args[0])) {
      return;
    }
    for (    LocationProviderInterface provider : mProviders) {
      pw.print(provider.getName() + ""String_Node_Str"");
      if (provider instanceof LocationProviderProxy) {
        LocationProviderProxy proxy=(LocationProviderProxy)provider;
        pw.print(""String_Node_Str"" + proxy.getConnectedPackageName() + ""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      provider.dump(fd,pw,args);
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
synchronized (mLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (    Receiver receiver : mReceivers.values()) {
      pw.println(""String_Node_Str"" + receiver);
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,ArrayList<UpdateRecord>> entry : mRecordsByProvider.entrySet()) {
      pw.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      for (      UpdateRecord record : entry.getValue()) {
        pw.println(""String_Node_Str"" + record);
      }
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,Location> entry : mLastLocation.entrySet()) {
      String provider=entry.getKey();
      Location location=entry.getValue();
      pw.println(""String_Node_Str"" + provider + ""String_Node_Str""+ location);
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,Location> entry : mLastLocationCoarseInterval.entrySet()) {
      String provider=entry.getKey();
      Location location=entry.getValue();
      pw.println(""String_Node_Str"" + provider + ""String_Node_Str""+ location);
    }
    mGeofenceManager.dump(pw);
    if (mEnabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mEnabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    if (mDisabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mDisabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    pw.append(""String_Node_Str"");
    mBlacklist.dump(pw);
    if (mMockProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      Map.Entry<String,MockProvider> i : mMockProviders.entrySet()) {
        i.getValue().dump(pw,""String_Node_Str"");
      }
    }
    pw.append(""String_Node_Str"");
    mLocationFudger.dump(fd,pw,args);
    if (args.length > 0 && ""String_Node_Str"".equals(args[0])) {
      return;
    }
    for (    LocationProviderInterface provider : mProviders) {
      pw.print(provider.getName() + ""String_Node_Str"");
      if (provider instanceof LocationProviderProxy) {
        LocationProviderProxy proxy=(LocationProviderProxy)provider;
        pw.print(""String_Node_Str"" + proxy.getConnectedPackageName() + ""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      provider.dump(fd,pw,args);
    }
  }
}"
2300,"@Override public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.remove(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    removeProviderLocked(mProvidersByName.get(provider));
    LocationProviderInterface realProvider=mRealProviders.get(provider);
    if (realProvider != null) {
      addProviderLocked(realProvider);
    }
    mLastLocation.put(provider,null);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.remove(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    removeProviderLocked(mProvidersByName.get(provider));
    LocationProviderInterface realProvider=mRealProviders.get(provider);
    if (realProvider != null) {
      addProviderLocked(realProvider);
    }
    mLastLocation.put(provider,null);
    mLastLocationCoarseInterval.put(provider,null);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}"
2301,"private static boolean shouldBroadcastSafe(Location loc,Location lastLoc,UpdateRecord record,long now){
  if (lastLoc == null) {
    return true;
  }
  long minTime=record.mRequest.getFastestInterval();
  long delta=(loc.getElapsedRealtimeNanos() - lastLoc.getElapsedRealtimeNanos()) / 1000000L;
  if (delta < minTime - MAX_PROVIDER_SCHEDULING_JITTER_MS) {
    return false;
  }
  double minDistance=record.mRequest.getSmallestDisplacement();
  if (minDistance > 0.0) {
    if (loc.distanceTo(lastLoc) <= minDistance) {
      return false;
    }
  }
  if (record.mRequest.getNumUpdates() <= 0) {
    return false;
  }
  if (record.mRequest.getExpireAt() < now) {
    return false;
  }
  return true;
}","private static boolean shouldBroadcastSafe(Location loc,Location lastLoc,UpdateRecord record,long now){
  if (lastLoc == null) {
    return true;
  }
  long minTime=record.mRequest.getFastestInterval();
  long delta=(loc.getElapsedRealtimeNanos() - lastLoc.getElapsedRealtimeNanos()) / NANOS_PER_MILLI;
  if (delta < minTime - MAX_PROVIDER_SCHEDULING_JITTER_MS) {
    return false;
  }
  double minDistance=record.mRequest.getSmallestDisplacement();
  if (minDistance > 0.0) {
    if (loc.distanceTo(lastLoc) <= minDistance) {
      return false;
    }
  }
  if (record.mRequest.getNumUpdates() <= 0) {
    return false;
  }
  if (record.mRequest.getExpireAt() < now) {
    return false;
  }
  return true;
}"
2302,"private void updateWindow(boolean force,boolean redrawNeeded){
  if (!mHaveFrame) {
    return;
  }
  ViewRootImpl viewRoot=getViewRootImpl();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  if (mTranslator != null) {
    mSurface.setCompatibilityTranslator(mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
    if (DEBUG)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      if (mWindow == null) {
        Display display=getDisplay();
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.START | Gravity.TOP;
        mSession.addToDisplayWithoutInputChannel(mWindow,mWindow.mSeq,mLayout,mVisible ? VISIBLE : GONE,display.getDisplayId(),mContentInsets);
      }
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      int relayoutResult;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mSurface);
        relayoutResult=mSession.relayout(mWindow,mWindow.mSeq,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY,mWinFrame,mOverscanInsets,mContentInsets,mVisibleInsets,mConfiguration,mNewSurface);
        if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mNewSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        redrawNeeded|=creating | reportDrawNeeded;
        SurfaceHolder.Callback callbacks[]=null;
        final boolean surfaceChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
        if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
          mSurfaceCreated=false;
          if (mSurface.isValid()) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            callbacks=getSurfaceCallbacks();
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceDestroyed(mSurfaceHolder);
            }
          }
        }
        mSurface.transferFrom(mNewSurface);
        if (visible && mSurface.isValid()) {
          if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
            mSurfaceCreated=true;
            mIsCreating=true;
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"" + mFormat + ""String_Node_Str""+ myWidth+ ""String_Node_Str""+ myHeight);
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
          if (redrawNeeded) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              if (c instanceof SurfaceHolder.Callback2) {
                ((SurfaceHolder.Callback2)c).surfaceRedrawNeeded(mSurfaceHolder);
              }
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (redrawNeeded) {
          if (DEBUG)           Log.i(TAG,""String_Node_Str"");
          mSession.finishDrawing(mWindow);
        }
        mSession.performDeferredDestroy(mWindow);
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force,boolean redrawNeeded){
  if (!mHaveFrame) {
    return;
  }
  ViewRootImpl viewRoot=getViewRootImpl();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  if (mTranslator != null) {
    mSurface.setCompatibilityTranslator(mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
    if (DEBUG)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION;
      if (mWindow == null) {
        Display display=getDisplay();
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.START | Gravity.TOP;
        mSession.addToDisplayWithoutInputChannel(mWindow,mWindow.mSeq,mLayout,mVisible ? VISIBLE : GONE,display.getDisplayId(),mContentInsets);
      }
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      int relayoutResult;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mSurface);
        relayoutResult=mSession.relayout(mWindow,mWindow.mSeq,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY,mWinFrame,mOverscanInsets,mContentInsets,mVisibleInsets,mConfiguration,mNewSurface);
        if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mNewSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        redrawNeeded|=creating | reportDrawNeeded;
        SurfaceHolder.Callback callbacks[]=null;
        final boolean surfaceChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
        if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
          mSurfaceCreated=false;
          if (mSurface.isValid()) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            callbacks=getSurfaceCallbacks();
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceDestroyed(mSurfaceHolder);
            }
          }
        }
        mSurface.transferFrom(mNewSurface);
        if (visible && mSurface.isValid()) {
          if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
            mSurfaceCreated=true;
            mIsCreating=true;
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"" + mFormat + ""String_Node_Str""+ myWidth+ ""String_Node_Str""+ myHeight);
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
          if (redrawNeeded) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              if (c instanceof SurfaceHolder.Callback2) {
                ((SurfaceHolder.Callback2)c).surfaceRedrawNeeded(mSurfaceHolder);
              }
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (redrawNeeded) {
          if (DEBUG)           Log.i(TAG,""String_Node_Str"");
          mSession.finishDrawing(mWindow);
        }
        mSession.performDeferredDestroy(mWindow);
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}"
2303,"/** 
 * Return whether this window is wanting to have a translation animation applied to it for an in-progress move.  (Only makes sense to call from performLayoutAndPlaceSurfacesLockedInner().)
 */
boolean shouldAnimateMove(){
  return mContentChanged && !mExiting && !mWinAnimator.mLastHidden&& mService.okToDisplay()&& (mFrame.top != mLastFrame.top || mFrame.left != mLastFrame.left)&& (mAttachedWindow == null || !mAttachedWindow.shouldAnimateMove());
}","/** 
 * Return whether this window is wanting to have a translation animation applied to it for an in-progress move.  (Only makes sense to call from performLayoutAndPlaceSurfacesLockedInner().)
 */
boolean shouldAnimateMove(){
  return mContentChanged && !mExiting && !mWinAnimator.mLastHidden&& mService.okToDisplay()&& (mFrame.top != mLastFrame.top || mFrame.left != mLastFrame.left)&& (mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0 && (mAttachedWindow == null || !mAttachedWindow.shouldAnimateMove());
}"
2304,"@Override public void addTestProvider(String name,ProviderProperties properties){
  checkMockPermissionsSafe();
  if (LocationManager.PASSIVE_PROVIDER.equals(name)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  long identity=Binder.clearCallingIdentity();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,properties);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name) || LocationManager.FUSED_PROVIDER.equals(name)) {
      LocationProviderInterface p=mProvidersByName.get(name);
      if (p != null) {
        removeProviderLocked(p);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProviderLocked(provider);
    mMockProviders.put(name,provider);
    mLastLocation.put(name,null);
    updateProvidersLocked();
  }
  Binder.restoreCallingIdentity(identity);
}","@Override public void addTestProvider(String name,ProviderProperties properties){
  checkMockPermissionsSafe();
  if (LocationManager.PASSIVE_PROVIDER.equals(name)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  long identity=Binder.clearCallingIdentity();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,properties);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name) || LocationManager.FUSED_PROVIDER.equals(name)) {
      LocationProviderInterface p=mProvidersByName.get(name);
      if (p != null) {
        removeProviderLocked(p);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProviderLocked(provider);
    mMockProviders.put(name,provider);
    mLastLocation.put(name,null);
    mLastLocationCoarseInterval.put(name,null);
    updateProvidersLocked();
  }
  Binder.restoreCallingIdentity(identity);
}"
2305,"private void handleLocationChangedLocked(Location location,boolean passive){
  if (D)   Log.d(TAG,""String_Node_Str"" + location);
  long now=SystemClock.elapsedRealtime();
  String provider=(passive ? LocationManager.PASSIVE_PROVIDER : location.getProvider());
  LocationProviderInterface p=mProvidersByName.get(provider);
  if (p == null)   return;
  Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
  Location lastNoGPSLocation=null;
  Location lastLocation=mLastLocation.get(provider);
  if (lastLocation == null) {
    lastLocation=new Location(provider);
    mLastLocation.put(provider,lastLocation);
  }
 else {
    lastNoGPSLocation=lastLocation.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
    if (noGPSLocation == null && lastNoGPSLocation != null) {
      location.setExtraLocation(Location.EXTRA_NO_GPS_LOCATION,lastNoGPSLocation);
    }
  }
  lastLocation.set(location);
  ArrayList<UpdateRecord> records=mRecordsByProvider.get(provider);
  if (records == null || records.size() == 0)   return;
  Location coarseLocation=null;
  if (noGPSLocation != null && !noGPSLocation.equals(lastNoGPSLocation)) {
    coarseLocation=mLocationFudger.getOrCreate(noGPSLocation);
  }
  long newStatusUpdateTime=p.getStatusUpdateTime();
  Bundle extras=new Bundle();
  int status=p.getStatus(extras);
  ArrayList<Receiver> deadReceivers=null;
  ArrayList<UpdateRecord> deadUpdateRecords=null;
  for (  UpdateRecord r : records) {
    Receiver receiver=r.mReceiver;
    boolean receiverDead=false;
    int receiverUserId=UserHandle.getUserId(receiver.mUid);
    if (receiverUserId != mCurrentUserId) {
      if (D) {
        Log.d(TAG,""String_Node_Str"" + receiverUserId + ""String_Node_Str""+ mCurrentUserId+ ""String_Node_Str""+ receiver.mPackageName+ ""String_Node_Str"");
      }
      continue;
    }
    if (mBlacklist.isBlacklisted(receiver.mPackageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    if (!reportLocationAccessNoThrow(receiver.mUid,receiver.mPackageName,receiver.mAllowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    Location notifyLocation=null;
    if (receiver.mAllowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
      notifyLocation=coarseLocation;
    }
 else {
      notifyLocation=lastLocation;
    }
    if (notifyLocation != null) {
      Location lastLoc=r.mLastFixBroadcast;
      if ((lastLoc == null) || shouldBroadcastSafe(notifyLocation,lastLoc,r,now)) {
        if (lastLoc == null) {
          lastLoc=new Location(notifyLocation);
          r.mLastFixBroadcast=lastLoc;
        }
 else {
          lastLoc.set(notifyLocation);
        }
        if (!receiver.callLocationChangedLocked(notifyLocation)) {
          Slog.w(TAG,""String_Node_Str"" + receiver);
          receiverDead=true;
        }
        r.mRequest.decrementNumUpdates();
      }
    }
    long prevStatusUpdateTime=r.mLastStatusBroadcast;
    if ((newStatusUpdateTime > prevStatusUpdateTime) && (prevStatusUpdateTime != 0 || status != LocationProvider.AVAILABLE)) {
      r.mLastStatusBroadcast=newStatusUpdateTime;
      if (!receiver.callStatusChangedLocked(provider,status,extras)) {
        receiverDead=true;
        Slog.w(TAG,""String_Node_Str"" + receiver);
      }
    }
    if (r.mRequest.getNumUpdates() <= 0 || r.mRequest.getExpireAt() < now) {
      if (deadUpdateRecords == null) {
        deadUpdateRecords=new ArrayList<UpdateRecord>();
      }
      deadUpdateRecords.add(r);
    }
    if (receiverDead) {
      if (deadReceivers == null) {
        deadReceivers=new ArrayList<Receiver>();
      }
      if (!deadReceivers.contains(receiver)) {
        deadReceivers.add(receiver);
      }
    }
  }
  if (deadReceivers != null) {
    for (    Receiver receiver : deadReceivers) {
      removeUpdatesLocked(receiver);
    }
  }
  if (deadUpdateRecords != null) {
    for (    UpdateRecord r : deadUpdateRecords) {
      r.disposeLocked(true);
    }
    applyRequirementsLocked(provider);
  }
}","private void handleLocationChangedLocked(Location location,boolean passive){
  if (D)   Log.d(TAG,""String_Node_Str"" + location);
  long now=SystemClock.elapsedRealtime();
  String provider=(passive ? LocationManager.PASSIVE_PROVIDER : location.getProvider());
  LocationProviderInterface p=mProvidersByName.get(provider);
  if (p == null)   return;
  Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
  Location lastNoGPSLocation=null;
  Location lastLocation=mLastLocation.get(provider);
  if (lastLocation == null) {
    lastLocation=new Location(provider);
    mLastLocation.put(provider,lastLocation);
  }
 else {
    lastNoGPSLocation=lastLocation.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
    if (noGPSLocation == null && lastNoGPSLocation != null) {
      location.setExtraLocation(Location.EXTRA_NO_GPS_LOCATION,lastNoGPSLocation);
    }
  }
  lastLocation.set(location);
  Location lastLocationCoarseInterval=mLastLocationCoarseInterval.get(provider);
  if (lastLocationCoarseInterval == null) {
    lastLocationCoarseInterval=new Location(location);
    mLastLocationCoarseInterval.put(provider,lastLocationCoarseInterval);
  }
  long timeDiffNanos=location.getElapsedRealtimeNanos() - lastLocationCoarseInterval.getElapsedRealtimeNanos();
  if (timeDiffNanos > LocationFudger.FASTEST_INTERVAL_MS * NANOS_PER_MILLI) {
    lastLocationCoarseInterval.set(location);
  }
  noGPSLocation=lastLocationCoarseInterval.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
  ArrayList<UpdateRecord> records=mRecordsByProvider.get(provider);
  if (records == null || records.size() == 0)   return;
  Location coarseLocation=null;
  if (noGPSLocation != null) {
    coarseLocation=mLocationFudger.getOrCreate(noGPSLocation);
  }
  long newStatusUpdateTime=p.getStatusUpdateTime();
  Bundle extras=new Bundle();
  int status=p.getStatus(extras);
  ArrayList<Receiver> deadReceivers=null;
  ArrayList<UpdateRecord> deadUpdateRecords=null;
  for (  UpdateRecord r : records) {
    Receiver receiver=r.mReceiver;
    boolean receiverDead=false;
    int receiverUserId=UserHandle.getUserId(receiver.mUid);
    if (receiverUserId != mCurrentUserId) {
      if (D) {
        Log.d(TAG,""String_Node_Str"" + receiverUserId + ""String_Node_Str""+ mCurrentUserId+ ""String_Node_Str""+ receiver.mPackageName+ ""String_Node_Str"");
      }
      continue;
    }
    if (mBlacklist.isBlacklisted(receiver.mPackageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    if (!reportLocationAccessNoThrow(receiver.mUid,receiver.mPackageName,receiver.mAllowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    Location notifyLocation=null;
    if (receiver.mAllowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
      notifyLocation=coarseLocation;
    }
 else {
      notifyLocation=lastLocation;
    }
    if (notifyLocation != null) {
      Location lastLoc=r.mLastFixBroadcast;
      if ((lastLoc == null) || shouldBroadcastSafe(notifyLocation,lastLoc,r,now)) {
        if (lastLoc == null) {
          lastLoc=new Location(notifyLocation);
          r.mLastFixBroadcast=lastLoc;
        }
 else {
          lastLoc.set(notifyLocation);
        }
        if (!receiver.callLocationChangedLocked(notifyLocation)) {
          Slog.w(TAG,""String_Node_Str"" + receiver);
          receiverDead=true;
        }
        r.mRequest.decrementNumUpdates();
      }
    }
    long prevStatusUpdateTime=r.mLastStatusBroadcast;
    if ((newStatusUpdateTime > prevStatusUpdateTime) && (prevStatusUpdateTime != 0 || status != LocationProvider.AVAILABLE)) {
      r.mLastStatusBroadcast=newStatusUpdateTime;
      if (!receiver.callStatusChangedLocked(provider,status,extras)) {
        receiverDead=true;
        Slog.w(TAG,""String_Node_Str"" + receiver);
      }
    }
    if (r.mRequest.getNumUpdates() <= 0 || r.mRequest.getExpireAt() < now) {
      if (deadUpdateRecords == null) {
        deadUpdateRecords=new ArrayList<UpdateRecord>();
      }
      deadUpdateRecords.add(r);
    }
    if (receiverDead) {
      if (deadReceivers == null) {
        deadReceivers=new ArrayList<Receiver>();
      }
      if (!deadReceivers.contains(receiver)) {
        deadReceivers.add(receiver);
      }
    }
  }
  if (deadReceivers != null) {
    for (    Receiver receiver : deadReceivers) {
      removeUpdatesLocked(receiver);
    }
  }
  if (deadUpdateRecords != null) {
    for (    UpdateRecord r : deadUpdateRecords) {
      r.disposeLocked(true);
    }
    applyRequirementsLocked(provider);
  }
}"
2306,"/** 
 * Called when the device's active user changes.
 * @param userId the new active user's UserId
 */
private void switchUser(int userId){
  mBlacklist.switchUser(userId);
  mLocationHandler.removeMessages(MSG_LOCATION_CHANGED);
synchronized (mLock) {
    mLastLocation.clear();
    for (    LocationProviderInterface p : mProviders) {
      updateProviderListenersLocked(p.getName(),false,mCurrentUserId);
    }
    mCurrentUserId=userId;
    updateProvidersLocked();
  }
}","/** 
 * Called when the device's active user changes.
 * @param userId the new active user's UserId
 */
private void switchUser(int userId){
  mBlacklist.switchUser(userId);
  mLocationHandler.removeMessages(MSG_LOCATION_CHANGED);
synchronized (mLock) {
    mLastLocation.clear();
    mLastLocationCoarseInterval.clear();
    for (    LocationProviderInterface p : mProviders) {
      updateProviderListenersLocked(p.getName(),false,mCurrentUserId);
    }
    mCurrentUserId=userId;
    updateProvidersLocked();
  }
}"
2307,"@Override public Location getLastLocation(LocationRequest request,String packageName){
  if (D)   Log.d(TAG,""String_Node_Str"" + request);
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkPackageName(packageName);
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  final int uid=Binder.getCallingUid();
  final long identity=Binder.clearCallingIdentity();
  try {
    if (mBlacklist.isBlacklisted(packageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
    if (!reportLocationAccessNoThrow(uid,packageName,allowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
synchronized (mLock) {
      String name=request.getProvider();
      if (name == null)       name=LocationManager.FUSED_PROVIDER;
      LocationProviderInterface provider=mProvidersByName.get(name);
      if (provider == null)       return null;
      if (!isAllowedByUserSettingsLocked(name,uid))       return null;
      Location location=mLastLocation.get(name);
      if (location == null) {
        return null;
      }
      if (allowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
        Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
        if (noGPSLocation != null) {
          return new Location(mLocationFudger.getOrCreate(noGPSLocation));
        }
      }
 else {
        return new Location(location);
      }
    }
    return null;
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public Location getLastLocation(LocationRequest request,String packageName){
  if (D)   Log.d(TAG,""String_Node_Str"" + request);
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkPackageName(packageName);
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  final int uid=Binder.getCallingUid();
  final long identity=Binder.clearCallingIdentity();
  try {
    if (mBlacklist.isBlacklisted(packageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
    if (!reportLocationAccessNoThrow(uid,packageName,allowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
synchronized (mLock) {
      String name=request.getProvider();
      if (name == null)       name=LocationManager.FUSED_PROVIDER;
      LocationProviderInterface provider=mProvidersByName.get(name);
      if (provider == null)       return null;
      if (!isAllowedByUserSettingsLocked(name,uid))       return null;
      Location location;
      if (allowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
        location=mLastLocationCoarseInterval.get(name);
      }
 else {
        location=mLastLocation.get(name);
      }
      if (location == null) {
        return null;
      }
      if (allowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
        Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
        if (noGPSLocation != null) {
          return new Location(mLocationFudger.getOrCreate(noGPSLocation));
        }
      }
 else {
        return new Location(location);
      }
    }
    return null;
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}"
2308,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
synchronized (mLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (    Receiver receiver : mReceivers.values()) {
      pw.println(""String_Node_Str"" + receiver);
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,ArrayList<UpdateRecord>> entry : mRecordsByProvider.entrySet()) {
      pw.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      for (      UpdateRecord record : entry.getValue()) {
        pw.println(""String_Node_Str"" + record);
      }
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,Location> entry : mLastLocation.entrySet()) {
      String provider=entry.getKey();
      Location location=entry.getValue();
      pw.println(""String_Node_Str"" + provider + ""String_Node_Str""+ location);
    }
    mGeofenceManager.dump(pw);
    if (mEnabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mEnabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    if (mDisabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mDisabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    pw.append(""String_Node_Str"");
    mBlacklist.dump(pw);
    if (mMockProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      Map.Entry<String,MockProvider> i : mMockProviders.entrySet()) {
        i.getValue().dump(pw,""String_Node_Str"");
      }
    }
    pw.append(""String_Node_Str"");
    mLocationFudger.dump(fd,pw,args);
    if (args.length > 0 && ""String_Node_Str"".equals(args[0])) {
      return;
    }
    for (    LocationProviderInterface provider : mProviders) {
      pw.print(provider.getName() + ""String_Node_Str"");
      if (provider instanceof LocationProviderProxy) {
        LocationProviderProxy proxy=(LocationProviderProxy)provider;
        pw.print(""String_Node_Str"" + proxy.getConnectedPackageName() + ""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      provider.dump(fd,pw,args);
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
synchronized (mLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (    Receiver receiver : mReceivers.values()) {
      pw.println(""String_Node_Str"" + receiver);
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,ArrayList<UpdateRecord>> entry : mRecordsByProvider.entrySet()) {
      pw.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      for (      UpdateRecord record : entry.getValue()) {
        pw.println(""String_Node_Str"" + record);
      }
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,Location> entry : mLastLocation.entrySet()) {
      String provider=entry.getKey();
      Location location=entry.getValue();
      pw.println(""String_Node_Str"" + provider + ""String_Node_Str""+ location);
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,Location> entry : mLastLocationCoarseInterval.entrySet()) {
      String provider=entry.getKey();
      Location location=entry.getValue();
      pw.println(""String_Node_Str"" + provider + ""String_Node_Str""+ location);
    }
    mGeofenceManager.dump(pw);
    if (mEnabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mEnabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    if (mDisabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mDisabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    pw.append(""String_Node_Str"");
    mBlacklist.dump(pw);
    if (mMockProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      Map.Entry<String,MockProvider> i : mMockProviders.entrySet()) {
        i.getValue().dump(pw,""String_Node_Str"");
      }
    }
    pw.append(""String_Node_Str"");
    mLocationFudger.dump(fd,pw,args);
    if (args.length > 0 && ""String_Node_Str"".equals(args[0])) {
      return;
    }
    for (    LocationProviderInterface provider : mProviders) {
      pw.print(provider.getName() + ""String_Node_Str"");
      if (provider instanceof LocationProviderProxy) {
        LocationProviderProxy proxy=(LocationProviderProxy)provider;
        pw.print(""String_Node_Str"" + proxy.getConnectedPackageName() + ""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      provider.dump(fd,pw,args);
    }
  }
}"
2309,"@Override public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.remove(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    removeProviderLocked(mProvidersByName.get(provider));
    LocationProviderInterface realProvider=mRealProviders.get(provider);
    if (realProvider != null) {
      addProviderLocked(realProvider);
    }
    mLastLocation.put(provider,null);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.remove(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    removeProviderLocked(mProvidersByName.get(provider));
    LocationProviderInterface realProvider=mRealProviders.get(provider);
    if (realProvider != null) {
      addProviderLocked(realProvider);
    }
    mLastLocation.put(provider,null);
    mLastLocationCoarseInterval.put(provider,null);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}"
2310,"private static boolean shouldBroadcastSafe(Location loc,Location lastLoc,UpdateRecord record,long now){
  if (lastLoc == null) {
    return true;
  }
  long minTime=record.mRequest.getFastestInterval();
  long delta=(loc.getElapsedRealtimeNanos() - lastLoc.getElapsedRealtimeNanos()) / 1000000L;
  if (delta < minTime - MAX_PROVIDER_SCHEDULING_JITTER_MS) {
    return false;
  }
  double minDistance=record.mRequest.getSmallestDisplacement();
  if (minDistance > 0.0) {
    if (loc.distanceTo(lastLoc) <= minDistance) {
      return false;
    }
  }
  if (record.mRequest.getNumUpdates() <= 0) {
    return false;
  }
  if (record.mRequest.getExpireAt() < now) {
    return false;
  }
  return true;
}","private static boolean shouldBroadcastSafe(Location loc,Location lastLoc,UpdateRecord record,long now){
  if (lastLoc == null) {
    return true;
  }
  long minTime=record.mRequest.getFastestInterval();
  long delta=(loc.getElapsedRealtimeNanos() - lastLoc.getElapsedRealtimeNanos()) / NANOS_PER_MILLI;
  if (delta < minTime - MAX_PROVIDER_SCHEDULING_JITTER_MS) {
    return false;
  }
  double minDistance=record.mRequest.getSmallestDisplacement();
  if (minDistance > 0.0) {
    if (loc.distanceTo(lastLoc) <= minDistance) {
      return false;
    }
  }
  if (record.mRequest.getNumUpdates() <= 0) {
    return false;
  }
  if (record.mRequest.getExpireAt() < now) {
    return false;
  }
  return true;
}"
2311,"private void updateWindow(boolean force,boolean redrawNeeded){
  if (!mHaveFrame) {
    return;
  }
  ViewRootImpl viewRoot=getViewRootImpl();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  if (mTranslator != null) {
    mSurface.setCompatibilityTranslator(mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
    if (DEBUG)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      if (mWindow == null) {
        Display display=getDisplay();
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.START | Gravity.TOP;
        mSession.addToDisplayWithoutInputChannel(mWindow,mWindow.mSeq,mLayout,mVisible ? VISIBLE : GONE,display.getDisplayId(),mContentInsets);
      }
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      int relayoutResult;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mSurface);
        relayoutResult=mSession.relayout(mWindow,mWindow.mSeq,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY,mWinFrame,mOverscanInsets,mContentInsets,mVisibleInsets,mConfiguration,mNewSurface);
        if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mNewSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        redrawNeeded|=creating | reportDrawNeeded;
        SurfaceHolder.Callback callbacks[]=null;
        final boolean surfaceChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
        if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
          mSurfaceCreated=false;
          if (mSurface.isValid()) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            callbacks=getSurfaceCallbacks();
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceDestroyed(mSurfaceHolder);
            }
          }
        }
        mSurface.transferFrom(mNewSurface);
        if (visible && mSurface.isValid()) {
          if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
            mSurfaceCreated=true;
            mIsCreating=true;
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"" + mFormat + ""String_Node_Str""+ myWidth+ ""String_Node_Str""+ myHeight);
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
          if (redrawNeeded) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              if (c instanceof SurfaceHolder.Callback2) {
                ((SurfaceHolder.Callback2)c).surfaceRedrawNeeded(mSurfaceHolder);
              }
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (redrawNeeded) {
          if (DEBUG)           Log.i(TAG,""String_Node_Str"");
          mSession.finishDrawing(mWindow);
        }
        mSession.performDeferredDestroy(mWindow);
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force,boolean redrawNeeded){
  if (!mHaveFrame) {
    return;
  }
  ViewRootImpl viewRoot=getViewRootImpl();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  if (mTranslator != null) {
    mSurface.setCompatibilityTranslator(mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
    if (DEBUG)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION;
      if (mWindow == null) {
        Display display=getDisplay();
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.START | Gravity.TOP;
        mSession.addToDisplayWithoutInputChannel(mWindow,mWindow.mSeq,mLayout,mVisible ? VISIBLE : GONE,display.getDisplayId(),mContentInsets);
      }
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      int relayoutResult;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mSurface);
        relayoutResult=mSession.relayout(mWindow,mWindow.mSeq,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY,mWinFrame,mOverscanInsets,mContentInsets,mVisibleInsets,mConfiguration,mNewSurface);
        if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mNewSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        redrawNeeded|=creating | reportDrawNeeded;
        SurfaceHolder.Callback callbacks[]=null;
        final boolean surfaceChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
        if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
          mSurfaceCreated=false;
          if (mSurface.isValid()) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            callbacks=getSurfaceCallbacks();
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceDestroyed(mSurfaceHolder);
            }
          }
        }
        mSurface.transferFrom(mNewSurface);
        if (visible && mSurface.isValid()) {
          if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
            mSurfaceCreated=true;
            mIsCreating=true;
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"" + mFormat + ""String_Node_Str""+ myWidth+ ""String_Node_Str""+ myHeight);
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
          if (redrawNeeded) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              if (c instanceof SurfaceHolder.Callback2) {
                ((SurfaceHolder.Callback2)c).surfaceRedrawNeeded(mSurfaceHolder);
              }
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (redrawNeeded) {
          if (DEBUG)           Log.i(TAG,""String_Node_Str"");
          mSession.finishDrawing(mWindow);
        }
        mSession.performDeferredDestroy(mWindow);
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}"
2312,"/** 
 * Return whether this window is wanting to have a translation animation applied to it for an in-progress move.  (Only makes sense to call from performLayoutAndPlaceSurfacesLockedInner().)
 */
boolean shouldAnimateMove(){
  return mContentChanged && !mExiting && !mWinAnimator.mLastHidden&& mService.okToDisplay()&& (mFrame.top != mLastFrame.top || mFrame.left != mLastFrame.left)&& (mAttachedWindow == null || !mAttachedWindow.shouldAnimateMove());
}","/** 
 * Return whether this window is wanting to have a translation animation applied to it for an in-progress move.  (Only makes sense to call from performLayoutAndPlaceSurfacesLockedInner().)
 */
boolean shouldAnimateMove(){
  return mContentChanged && !mExiting && !mWinAnimator.mLastHidden&& mService.okToDisplay()&& (mFrame.top != mLastFrame.top || mFrame.left != mLastFrame.left)&& (mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0 && (mAttachedWindow == null || !mAttachedWindow.shouldAnimateMove());
}"
2313,"@Override public void addTestProvider(String name,ProviderProperties properties){
  checkMockPermissionsSafe();
  if (LocationManager.PASSIVE_PROVIDER.equals(name)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  long identity=Binder.clearCallingIdentity();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,properties);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name) || LocationManager.FUSED_PROVIDER.equals(name)) {
      LocationProviderInterface p=mProvidersByName.get(name);
      if (p != null) {
        removeProviderLocked(p);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProviderLocked(provider);
    mMockProviders.put(name,provider);
    mLastLocation.put(name,null);
    updateProvidersLocked();
  }
  Binder.restoreCallingIdentity(identity);
}","@Override public void addTestProvider(String name,ProviderProperties properties){
  checkMockPermissionsSafe();
  if (LocationManager.PASSIVE_PROVIDER.equals(name)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  long identity=Binder.clearCallingIdentity();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,properties);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name) || LocationManager.FUSED_PROVIDER.equals(name)) {
      LocationProviderInterface p=mProvidersByName.get(name);
      if (p != null) {
        removeProviderLocked(p);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProviderLocked(provider);
    mMockProviders.put(name,provider);
    mLastLocation.put(name,null);
    mLastLocationCoarseInterval.put(name,null);
    updateProvidersLocked();
  }
  Binder.restoreCallingIdentity(identity);
}"
2314,"private void handleLocationChangedLocked(Location location,boolean passive){
  if (D)   Log.d(TAG,""String_Node_Str"" + location);
  long now=SystemClock.elapsedRealtime();
  String provider=(passive ? LocationManager.PASSIVE_PROVIDER : location.getProvider());
  LocationProviderInterface p=mProvidersByName.get(provider);
  if (p == null)   return;
  Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
  Location lastNoGPSLocation=null;
  Location lastLocation=mLastLocation.get(provider);
  if (lastLocation == null) {
    lastLocation=new Location(provider);
    mLastLocation.put(provider,lastLocation);
  }
 else {
    lastNoGPSLocation=lastLocation.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
    if (noGPSLocation == null && lastNoGPSLocation != null) {
      location.setExtraLocation(Location.EXTRA_NO_GPS_LOCATION,lastNoGPSLocation);
    }
  }
  lastLocation.set(location);
  ArrayList<UpdateRecord> records=mRecordsByProvider.get(provider);
  if (records == null || records.size() == 0)   return;
  Location coarseLocation=null;
  if (noGPSLocation != null && !noGPSLocation.equals(lastNoGPSLocation)) {
    coarseLocation=mLocationFudger.getOrCreate(noGPSLocation);
  }
  long newStatusUpdateTime=p.getStatusUpdateTime();
  Bundle extras=new Bundle();
  int status=p.getStatus(extras);
  ArrayList<Receiver> deadReceivers=null;
  ArrayList<UpdateRecord> deadUpdateRecords=null;
  for (  UpdateRecord r : records) {
    Receiver receiver=r.mReceiver;
    boolean receiverDead=false;
    int receiverUserId=UserHandle.getUserId(receiver.mUid);
    if (receiverUserId != mCurrentUserId) {
      if (D) {
        Log.d(TAG,""String_Node_Str"" + receiverUserId + ""String_Node_Str""+ mCurrentUserId+ ""String_Node_Str""+ receiver.mPackageName+ ""String_Node_Str"");
      }
      continue;
    }
    if (mBlacklist.isBlacklisted(receiver.mPackageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    if (!reportLocationAccessNoThrow(receiver.mUid,receiver.mPackageName,receiver.mAllowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    Location notifyLocation=null;
    if (receiver.mAllowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
      notifyLocation=coarseLocation;
    }
 else {
      notifyLocation=lastLocation;
    }
    if (notifyLocation != null) {
      Location lastLoc=r.mLastFixBroadcast;
      if ((lastLoc == null) || shouldBroadcastSafe(notifyLocation,lastLoc,r,now)) {
        if (lastLoc == null) {
          lastLoc=new Location(notifyLocation);
          r.mLastFixBroadcast=lastLoc;
        }
 else {
          lastLoc.set(notifyLocation);
        }
        if (!receiver.callLocationChangedLocked(notifyLocation)) {
          Slog.w(TAG,""String_Node_Str"" + receiver);
          receiverDead=true;
        }
        r.mRequest.decrementNumUpdates();
      }
    }
    long prevStatusUpdateTime=r.mLastStatusBroadcast;
    if ((newStatusUpdateTime > prevStatusUpdateTime) && (prevStatusUpdateTime != 0 || status != LocationProvider.AVAILABLE)) {
      r.mLastStatusBroadcast=newStatusUpdateTime;
      if (!receiver.callStatusChangedLocked(provider,status,extras)) {
        receiverDead=true;
        Slog.w(TAG,""String_Node_Str"" + receiver);
      }
    }
    if (r.mRequest.getNumUpdates() <= 0 || r.mRequest.getExpireAt() < now) {
      if (deadUpdateRecords == null) {
        deadUpdateRecords=new ArrayList<UpdateRecord>();
      }
      deadUpdateRecords.add(r);
    }
    if (receiverDead) {
      if (deadReceivers == null) {
        deadReceivers=new ArrayList<Receiver>();
      }
      if (!deadReceivers.contains(receiver)) {
        deadReceivers.add(receiver);
      }
    }
  }
  if (deadReceivers != null) {
    for (    Receiver receiver : deadReceivers) {
      removeUpdatesLocked(receiver);
    }
  }
  if (deadUpdateRecords != null) {
    for (    UpdateRecord r : deadUpdateRecords) {
      r.disposeLocked(true);
    }
    applyRequirementsLocked(provider);
  }
}","private void handleLocationChangedLocked(Location location,boolean passive){
  if (D)   Log.d(TAG,""String_Node_Str"" + location);
  long now=SystemClock.elapsedRealtime();
  String provider=(passive ? LocationManager.PASSIVE_PROVIDER : location.getProvider());
  LocationProviderInterface p=mProvidersByName.get(provider);
  if (p == null)   return;
  Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
  Location lastNoGPSLocation=null;
  Location lastLocation=mLastLocation.get(provider);
  if (lastLocation == null) {
    lastLocation=new Location(provider);
    mLastLocation.put(provider,lastLocation);
  }
 else {
    lastNoGPSLocation=lastLocation.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
    if (noGPSLocation == null && lastNoGPSLocation != null) {
      location.setExtraLocation(Location.EXTRA_NO_GPS_LOCATION,lastNoGPSLocation);
    }
  }
  lastLocation.set(location);
  Location lastLocationCoarseInterval=mLastLocationCoarseInterval.get(provider);
  if (lastLocationCoarseInterval == null) {
    lastLocationCoarseInterval=new Location(location);
    mLastLocationCoarseInterval.put(provider,lastLocationCoarseInterval);
  }
  long timeDiffNanos=location.getElapsedRealtimeNanos() - lastLocationCoarseInterval.getElapsedRealtimeNanos();
  if (timeDiffNanos > LocationFudger.FASTEST_INTERVAL_MS * NANOS_PER_MILLI) {
    lastLocationCoarseInterval.set(location);
  }
  noGPSLocation=lastLocationCoarseInterval.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
  ArrayList<UpdateRecord> records=mRecordsByProvider.get(provider);
  if (records == null || records.size() == 0)   return;
  Location coarseLocation=null;
  if (noGPSLocation != null) {
    coarseLocation=mLocationFudger.getOrCreate(noGPSLocation);
  }
  long newStatusUpdateTime=p.getStatusUpdateTime();
  Bundle extras=new Bundle();
  int status=p.getStatus(extras);
  ArrayList<Receiver> deadReceivers=null;
  ArrayList<UpdateRecord> deadUpdateRecords=null;
  for (  UpdateRecord r : records) {
    Receiver receiver=r.mReceiver;
    boolean receiverDead=false;
    int receiverUserId=UserHandle.getUserId(receiver.mUid);
    if (receiverUserId != mCurrentUserId) {
      if (D) {
        Log.d(TAG,""String_Node_Str"" + receiverUserId + ""String_Node_Str""+ mCurrentUserId+ ""String_Node_Str""+ receiver.mPackageName+ ""String_Node_Str"");
      }
      continue;
    }
    if (mBlacklist.isBlacklisted(receiver.mPackageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    if (!reportLocationAccessNoThrow(receiver.mUid,receiver.mPackageName,receiver.mAllowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + receiver.mPackageName);
      continue;
    }
    Location notifyLocation=null;
    if (receiver.mAllowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
      notifyLocation=coarseLocation;
    }
 else {
      notifyLocation=lastLocation;
    }
    if (notifyLocation != null) {
      Location lastLoc=r.mLastFixBroadcast;
      if ((lastLoc == null) || shouldBroadcastSafe(notifyLocation,lastLoc,r,now)) {
        if (lastLoc == null) {
          lastLoc=new Location(notifyLocation);
          r.mLastFixBroadcast=lastLoc;
        }
 else {
          lastLoc.set(notifyLocation);
        }
        if (!receiver.callLocationChangedLocked(notifyLocation)) {
          Slog.w(TAG,""String_Node_Str"" + receiver);
          receiverDead=true;
        }
        r.mRequest.decrementNumUpdates();
      }
    }
    long prevStatusUpdateTime=r.mLastStatusBroadcast;
    if ((newStatusUpdateTime > prevStatusUpdateTime) && (prevStatusUpdateTime != 0 || status != LocationProvider.AVAILABLE)) {
      r.mLastStatusBroadcast=newStatusUpdateTime;
      if (!receiver.callStatusChangedLocked(provider,status,extras)) {
        receiverDead=true;
        Slog.w(TAG,""String_Node_Str"" + receiver);
      }
    }
    if (r.mRequest.getNumUpdates() <= 0 || r.mRequest.getExpireAt() < now) {
      if (deadUpdateRecords == null) {
        deadUpdateRecords=new ArrayList<UpdateRecord>();
      }
      deadUpdateRecords.add(r);
    }
    if (receiverDead) {
      if (deadReceivers == null) {
        deadReceivers=new ArrayList<Receiver>();
      }
      if (!deadReceivers.contains(receiver)) {
        deadReceivers.add(receiver);
      }
    }
  }
  if (deadReceivers != null) {
    for (    Receiver receiver : deadReceivers) {
      removeUpdatesLocked(receiver);
    }
  }
  if (deadUpdateRecords != null) {
    for (    UpdateRecord r : deadUpdateRecords) {
      r.disposeLocked(true);
    }
    applyRequirementsLocked(provider);
  }
}"
2315,"/** 
 * Called when the device's active user changes.
 * @param userId the new active user's UserId
 */
private void switchUser(int userId){
  mBlacklist.switchUser(userId);
  mLocationHandler.removeMessages(MSG_LOCATION_CHANGED);
synchronized (mLock) {
    mLastLocation.clear();
    for (    LocationProviderInterface p : mProviders) {
      updateProviderListenersLocked(p.getName(),false,mCurrentUserId);
    }
    mCurrentUserId=userId;
    updateProvidersLocked();
  }
}","/** 
 * Called when the device's active user changes.
 * @param userId the new active user's UserId
 */
private void switchUser(int userId){
  mBlacklist.switchUser(userId);
  mLocationHandler.removeMessages(MSG_LOCATION_CHANGED);
synchronized (mLock) {
    mLastLocation.clear();
    mLastLocationCoarseInterval.clear();
    for (    LocationProviderInterface p : mProviders) {
      updateProviderListenersLocked(p.getName(),false,mCurrentUserId);
    }
    mCurrentUserId=userId;
    updateProvidersLocked();
  }
}"
2316,"@Override public Location getLastLocation(LocationRequest request,String packageName){
  if (D)   Log.d(TAG,""String_Node_Str"" + request);
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkPackageName(packageName);
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  final int uid=Binder.getCallingUid();
  final long identity=Binder.clearCallingIdentity();
  try {
    if (mBlacklist.isBlacklisted(packageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
    if (!reportLocationAccessNoThrow(uid,packageName,allowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
synchronized (mLock) {
      String name=request.getProvider();
      if (name == null)       name=LocationManager.FUSED_PROVIDER;
      LocationProviderInterface provider=mProvidersByName.get(name);
      if (provider == null)       return null;
      if (!isAllowedByUserSettingsLocked(name,uid))       return null;
      Location location=mLastLocation.get(name);
      if (location == null) {
        return null;
      }
      if (allowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
        Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
        if (noGPSLocation != null) {
          return new Location(mLocationFudger.getOrCreate(noGPSLocation));
        }
      }
 else {
        return new Location(location);
      }
    }
    return null;
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public Location getLastLocation(LocationRequest request,String packageName){
  if (D)   Log.d(TAG,""String_Node_Str"" + request);
  if (request == null)   request=DEFAULT_LOCATION_REQUEST;
  int allowedResolutionLevel=getCallerAllowedResolutionLevel();
  checkPackageName(packageName);
  checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,request.getProvider());
  final int uid=Binder.getCallingUid();
  final long identity=Binder.clearCallingIdentity();
  try {
    if (mBlacklist.isBlacklisted(packageName)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
    if (!reportLocationAccessNoThrow(uid,packageName,allowedResolutionLevel)) {
      if (D)       Log.d(TAG,""String_Node_Str"" + packageName);
      return null;
    }
synchronized (mLock) {
      String name=request.getProvider();
      if (name == null)       name=LocationManager.FUSED_PROVIDER;
      LocationProviderInterface provider=mProvidersByName.get(name);
      if (provider == null)       return null;
      if (!isAllowedByUserSettingsLocked(name,uid))       return null;
      Location location;
      if (allowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
        location=mLastLocationCoarseInterval.get(name);
      }
 else {
        location=mLastLocation.get(name);
      }
      if (location == null) {
        return null;
      }
      if (allowedResolutionLevel < RESOLUTION_LEVEL_FINE) {
        Location noGPSLocation=location.getExtraLocation(Location.EXTRA_NO_GPS_LOCATION);
        if (noGPSLocation != null) {
          return new Location(mLocationFudger.getOrCreate(noGPSLocation));
        }
      }
 else {
        return new Location(location);
      }
    }
    return null;
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}"
2317,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
synchronized (mLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (    Receiver receiver : mReceivers.values()) {
      pw.println(""String_Node_Str"" + receiver);
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,ArrayList<UpdateRecord>> entry : mRecordsByProvider.entrySet()) {
      pw.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      for (      UpdateRecord record : entry.getValue()) {
        pw.println(""String_Node_Str"" + record);
      }
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,Location> entry : mLastLocation.entrySet()) {
      String provider=entry.getKey();
      Location location=entry.getValue();
      pw.println(""String_Node_Str"" + provider + ""String_Node_Str""+ location);
    }
    mGeofenceManager.dump(pw);
    if (mEnabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mEnabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    if (mDisabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mDisabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    pw.append(""String_Node_Str"");
    mBlacklist.dump(pw);
    if (mMockProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      Map.Entry<String,MockProvider> i : mMockProviders.entrySet()) {
        i.getValue().dump(pw,""String_Node_Str"");
      }
    }
    pw.append(""String_Node_Str"");
    mLocationFudger.dump(fd,pw,args);
    if (args.length > 0 && ""String_Node_Str"".equals(args[0])) {
      return;
    }
    for (    LocationProviderInterface provider : mProviders) {
      pw.print(provider.getName() + ""String_Node_Str"");
      if (provider instanceof LocationProviderProxy) {
        LocationProviderProxy proxy=(LocationProviderProxy)provider;
        pw.print(""String_Node_Str"" + proxy.getConnectedPackageName() + ""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      provider.dump(fd,pw,args);
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
synchronized (mLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    for (    Receiver receiver : mReceivers.values()) {
      pw.println(""String_Node_Str"" + receiver);
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,ArrayList<UpdateRecord>> entry : mRecordsByProvider.entrySet()) {
      pw.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      for (      UpdateRecord record : entry.getValue()) {
        pw.println(""String_Node_Str"" + record);
      }
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,Location> entry : mLastLocation.entrySet()) {
      String provider=entry.getKey();
      Location location=entry.getValue();
      pw.println(""String_Node_Str"" + provider + ""String_Node_Str""+ location);
    }
    pw.println(""String_Node_Str"");
    for (    Map.Entry<String,Location> entry : mLastLocationCoarseInterval.entrySet()) {
      String provider=entry.getKey();
      Location location=entry.getValue();
      pw.println(""String_Node_Str"" + provider + ""String_Node_Str""+ location);
    }
    mGeofenceManager.dump(pw);
    if (mEnabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mEnabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    if (mDisabledProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      String i : mDisabledProviders) {
        pw.println(""String_Node_Str"" + i);
      }
    }
    pw.append(""String_Node_Str"");
    mBlacklist.dump(pw);
    if (mMockProviders.size() > 0) {
      pw.println(""String_Node_Str"");
      for (      Map.Entry<String,MockProvider> i : mMockProviders.entrySet()) {
        i.getValue().dump(pw,""String_Node_Str"");
      }
    }
    pw.append(""String_Node_Str"");
    mLocationFudger.dump(fd,pw,args);
    if (args.length > 0 && ""String_Node_Str"".equals(args[0])) {
      return;
    }
    for (    LocationProviderInterface provider : mProviders) {
      pw.print(provider.getName() + ""String_Node_Str"");
      if (provider instanceof LocationProviderProxy) {
        LocationProviderProxy proxy=(LocationProviderProxy)provider;
        pw.print(""String_Node_Str"" + proxy.getConnectedPackageName() + ""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      provider.dump(fd,pw,args);
    }
  }
}"
2318,"@Override public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.remove(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    removeProviderLocked(mProvidersByName.get(provider));
    LocationProviderInterface realProvider=mRealProviders.get(provider);
    if (realProvider != null) {
      addProviderLocked(realProvider);
    }
    mLastLocation.put(provider,null);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","@Override public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.remove(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    removeProviderLocked(mProvidersByName.get(provider));
    LocationProviderInterface realProvider=mRealProviders.get(provider);
    if (realProvider != null) {
      addProviderLocked(realProvider);
    }
    mLastLocation.put(provider,null);
    mLastLocationCoarseInterval.put(provider,null);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}"
2319,"private static boolean shouldBroadcastSafe(Location loc,Location lastLoc,UpdateRecord record,long now){
  if (lastLoc == null) {
    return true;
  }
  long minTime=record.mRequest.getFastestInterval();
  long delta=(loc.getElapsedRealtimeNanos() - lastLoc.getElapsedRealtimeNanos()) / 1000000L;
  if (delta < minTime - MAX_PROVIDER_SCHEDULING_JITTER_MS) {
    return false;
  }
  double minDistance=record.mRequest.getSmallestDisplacement();
  if (minDistance > 0.0) {
    if (loc.distanceTo(lastLoc) <= minDistance) {
      return false;
    }
  }
  if (record.mRequest.getNumUpdates() <= 0) {
    return false;
  }
  if (record.mRequest.getExpireAt() < now) {
    return false;
  }
  return true;
}","private static boolean shouldBroadcastSafe(Location loc,Location lastLoc,UpdateRecord record,long now){
  if (lastLoc == null) {
    return true;
  }
  long minTime=record.mRequest.getFastestInterval();
  long delta=(loc.getElapsedRealtimeNanos() - lastLoc.getElapsedRealtimeNanos()) / NANOS_PER_MILLI;
  if (delta < minTime - MAX_PROVIDER_SCHEDULING_JITTER_MS) {
    return false;
  }
  double minDistance=record.mRequest.getSmallestDisplacement();
  if (minDistance > 0.0) {
    if (loc.distanceTo(lastLoc) <= minDistance) {
      return false;
    }
  }
  if (record.mRequest.getNumUpdates() <= 0) {
    return false;
  }
  if (record.mRequest.getExpireAt() < now) {
    return false;
  }
  return true;
}"
2320,"private void updateWindow(boolean force,boolean redrawNeeded){
  if (!mHaveFrame) {
    return;
  }
  ViewRootImpl viewRoot=getViewRootImpl();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  if (mTranslator != null) {
    mSurface.setCompatibilityTranslator(mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
    if (DEBUG)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      if (mWindow == null) {
        Display display=getDisplay();
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.START | Gravity.TOP;
        mSession.addToDisplayWithoutInputChannel(mWindow,mWindow.mSeq,mLayout,mVisible ? VISIBLE : GONE,display.getDisplayId(),mContentInsets);
      }
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      int relayoutResult;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mSurface);
        relayoutResult=mSession.relayout(mWindow,mWindow.mSeq,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY,mWinFrame,mOverscanInsets,mContentInsets,mVisibleInsets,mConfiguration,mNewSurface);
        if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mNewSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        redrawNeeded|=creating | reportDrawNeeded;
        SurfaceHolder.Callback callbacks[]=null;
        final boolean surfaceChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
        if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
          mSurfaceCreated=false;
          if (mSurface.isValid()) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            callbacks=getSurfaceCallbacks();
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceDestroyed(mSurfaceHolder);
            }
          }
        }
        mSurface.transferFrom(mNewSurface);
        if (visible && mSurface.isValid()) {
          if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
            mSurfaceCreated=true;
            mIsCreating=true;
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"" + mFormat + ""String_Node_Str""+ myWidth+ ""String_Node_Str""+ myHeight);
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
          if (redrawNeeded) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              if (c instanceof SurfaceHolder.Callback2) {
                ((SurfaceHolder.Callback2)c).surfaceRedrawNeeded(mSurfaceHolder);
              }
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (redrawNeeded) {
          if (DEBUG)           Log.i(TAG,""String_Node_Str"");
          mSession.finishDrawing(mWindow);
        }
        mSession.performDeferredDestroy(mWindow);
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force,boolean redrawNeeded){
  if (!mHaveFrame) {
    return;
  }
  ViewRootImpl viewRoot=getViewRootImpl();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  if (mTranslator != null) {
    mSurface.setCompatibilityTranslator(mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
    if (DEBUG)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION;
      if (mWindow == null) {
        Display display=getDisplay();
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.START | Gravity.TOP;
        mSession.addToDisplayWithoutInputChannel(mWindow,mWindow.mSeq,mLayout,mVisible ? VISIBLE : GONE,display.getDisplayId(),mContentInsets);
      }
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      int relayoutResult;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mSurface);
        relayoutResult=mSession.relayout(mWindow,mWindow.mSeq,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY,mWinFrame,mOverscanInsets,mContentInsets,mVisibleInsets,mConfiguration,mNewSurface);
        if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + mNewSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        redrawNeeded|=creating | reportDrawNeeded;
        SurfaceHolder.Callback callbacks[]=null;
        final boolean surfaceChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
        if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
          mSurfaceCreated=false;
          if (mSurface.isValid()) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            callbacks=getSurfaceCallbacks();
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceDestroyed(mSurfaceHolder);
            }
          }
        }
        mSurface.transferFrom(mNewSurface);
        if (visible && mSurface.isValid()) {
          if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
            mSurfaceCreated=true;
            mIsCreating=true;
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"" + mFormat + ""String_Node_Str""+ myWidth+ ""String_Node_Str""+ myHeight);
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
          if (redrawNeeded) {
            if (DEBUG)             Log.i(TAG,""String_Node_Str"");
            if (callbacks == null) {
              callbacks=getSurfaceCallbacks();
            }
            for (            SurfaceHolder.Callback c : callbacks) {
              if (c instanceof SurfaceHolder.Callback2) {
                ((SurfaceHolder.Callback2)c).surfaceRedrawNeeded(mSurfaceHolder);
              }
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (redrawNeeded) {
          if (DEBUG)           Log.i(TAG,""String_Node_Str"");
          mSession.finishDrawing(mWindow);
        }
        mSession.performDeferredDestroy(mWindow);
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}"
2321,"/** 
 * Return whether this window is wanting to have a translation animation applied to it for an in-progress move.  (Only makes sense to call from performLayoutAndPlaceSurfacesLockedInner().)
 */
boolean shouldAnimateMove(){
  return mContentChanged && !mExiting && !mWinAnimator.mLastHidden&& mService.okToDisplay()&& (mFrame.top != mLastFrame.top || mFrame.left != mLastFrame.left)&& (mAttachedWindow == null || !mAttachedWindow.shouldAnimateMove());
}","/** 
 * Return whether this window is wanting to have a translation animation applied to it for an in-progress move.  (Only makes sense to call from performLayoutAndPlaceSurfacesLockedInner().)
 */
boolean shouldAnimateMove(){
  return mContentChanged && !mExiting && !mWinAnimator.mLastHidden&& mService.okToDisplay()&& (mFrame.top != mLastFrame.top || mFrame.left != mLastFrame.left)&& (mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0 && (mAttachedWindow == null || !mAttachedWindow.shouldAnimateMove());
}"
2322,"public boolean onJsConfirm(String url,String message){
  if (mWebChromeClient == null) {
    return false;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message confirm=obtainMessage(JS_CONFIRM,result);
  confirm.getData().putString(""String_Node_Str"",message);
  confirm.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(confirm);
  return result.mJsResult.getResult();
}","public boolean onJsConfirm(String url,String message){
  if (mWebChromeClient == null) {
    return false;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message confirm=obtainMessage(JS_DIALOG,result);
  confirm.getData().putString(""String_Node_Str"",message);
  confirm.getData().putString(""String_Node_Str"",url);
  confirm.getData().putInt(""String_Node_Str"",JsDialogHelper.CONFIRM);
  sendMessageToUiThreadSync(confirm);
  return result.mJsResult.getResult();
}"
2323,"public void onJsAlert(String url,String message){
  if (mWebChromeClient == null) {
    return;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message alert=obtainMessage(JS_ALERT,result);
  alert.getData().putString(""String_Node_Str"",message);
  alert.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(alert);
}","public void onJsAlert(String url,String message){
  if (mWebChromeClient == null) {
    return;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message alert=obtainMessage(JS_DIALOG,result);
  alert.getData().putString(""String_Node_Str"",message);
  alert.getData().putString(""String_Node_Str"",url);
  alert.getData().putInt(""String_Node_Str"",JsDialogHelper.ALERT);
  sendMessageToUiThreadSync(alert);
}"
2324,"public String onJsPrompt(String url,String message,String defaultValue){
  if (mWebChromeClient == null) {
    return null;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message prompt=obtainMessage(JS_PROMPT,result);
  prompt.getData().putString(""String_Node_Str"",message);
  prompt.getData().putString(""String_Node_Str"",defaultValue);
  prompt.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(prompt);
  return result.mJsResult.getStringResult();
}","public String onJsPrompt(String url,String message,String defaultValue){
  if (mWebChromeClient == null) {
    return null;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message prompt=obtainMessage(JS_DIALOG,result);
  prompt.getData().putString(""String_Node_Str"",message);
  prompt.getData().putString(""String_Node_Str"",defaultValue);
  prompt.getData().putString(""String_Node_Str"",url);
  prompt.getData().putInt(""String_Node_Str"",JsDialogHelper.PROMPT);
  sendMessageToUiThreadSync(prompt);
  return result.mJsResult.getStringResult();
}"
2325,"public boolean onJsBeforeUnload(String url,String message){
  if (mWebChromeClient == null) {
    return true;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message confirm=obtainMessage(JS_UNLOAD,result);
  confirm.getData().putString(""String_Node_Str"",message);
  confirm.getData().putString(""String_Node_Str"",url);
  sendMessageToUiThreadSync(confirm);
  return result.mJsResult.getResult();
}","public boolean onJsBeforeUnload(String url,String message){
  if (mWebChromeClient == null) {
    return true;
  }
  JsResultReceiver result=new JsResultReceiver();
  Message unload=obtainMessage(JS_DIALOG,result);
  unload.getData().putString(""String_Node_Str"",message);
  unload.getData().putString(""String_Node_Str"",url);
  unload.getData().putInt(""String_Node_Str"",JsDialogHelper.UNLOAD);
  sendMessageToUiThreadSync(unload);
  return result.mJsResult.getResult();
}"
2326,"@Override public void handleMessage(Message msg){
  if (messagesBlocked())   return;
switch (msg.what) {
case PAGE_STARTED:
    String startedUrl=msg.getData().getString(""String_Node_Str"");
  mWebView.onPageStarted(startedUrl);
if (mWebViewClient != null) {
  mWebViewClient.onPageStarted(mWebView.getWebView(),startedUrl,(Bitmap)msg.obj);
}
break;
case PAGE_FINISHED:
String finishedUrl=(String)msg.obj;
mWebView.onPageFinished(finishedUrl);
if (mWebViewClient != null) {
mWebViewClient.onPageFinished(mWebView.getWebView(),finishedUrl);
}
break;
case RECEIVED_ICON:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedIcon(mWebView.getWebView(),(Bitmap)msg.obj);
}
break;
case RECEIVED_TOUCH_ICON_URL:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(),(String)msg.obj,msg.arg1 == 1);
}
break;
case RECEIVED_TITLE:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTitle(mWebView.getWebView(),(String)msg.obj);
}
break;
case REPORT_ERROR:
if (mWebViewClient != null) {
int reasonCode=msg.arg1;
final String description=msg.getData().getString(""String_Node_Str"");
final String failUrl=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedError(mWebView.getWebView(),reasonCode,description,failUrl);
}
break;
case RESEND_POST_DATA:
Message resend=(Message)msg.getData().getParcelable(""String_Node_Str"");
Message dontResend=(Message)msg.getData().getParcelable(""String_Node_Str"");
if (mWebViewClient != null) {
mWebViewClient.onFormResubmission(mWebView.getWebView(),dontResend,resend);
}
 else {
dontResend.sendToTarget();
}
break;
case OVERRIDE_URL:
String overrideUrl=msg.getData().getString(""String_Node_Str"");
boolean override=uiOverrideUrlLoading(overrideUrl);
ResultTransport<Boolean> result=(ResultTransport<Boolean>)msg.obj;
synchronized (this) {
result.setResult(override);
notify();
}
break;
case AUTH_REQUEST:
if (mWebViewClient != null) {
HttpAuthHandler handler=(HttpAuthHandler)msg.obj;
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(),handler,host,realm);
}
break;
case SSL_ERROR:
if (mWebViewClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
mWebViewClient.onReceivedSslError(mWebView.getWebView(),(SslErrorHandler)map.get(""String_Node_Str""),(SslError)map.get(""String_Node_Str""));
}
break;
case PROCEEDED_AFTER_SSL_ERROR:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
((WebViewClientClassicExt)mWebViewClient).onProceededAfterSslError(mWebView.getWebView(),(SslError)msg.obj);
}
break;
case CLIENT_CERT_REQUEST:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
((WebViewClientClassicExt)mWebViewClient).onReceivedClientCertRequest(mWebView.getWebView(),(ClientCertRequestHandler)map.get(""String_Node_Str""),(String)map.get(""String_Node_Str""));
}
break;
case PROGRESS:
synchronized (this) {
if (mWebChromeClient != null) {
mWebChromeClient.onProgressChanged(mWebView.getWebView(),mLatestProgress);
}
mProgressUpdatePending=false;
}
break;
case UPDATE_VISITED:
if (mWebViewClient != null) {
mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(),(String)msg.obj,msg.arg1 != 0);
}
break;
case LOAD_RESOURCE:
if (mWebViewClient != null) {
mWebViewClient.onLoadResource(mWebView.getWebView(),(String)msg.obj);
}
break;
case DOWNLOAD_FILE:
if (mDownloadListener != null) {
String url=msg.getData().getString(""String_Node_Str"");
String userAgent=msg.getData().getString(""String_Node_Str"");
String contentDisposition=msg.getData().getString(""String_Node_Str"");
String mimetype=msg.getData().getString(""String_Node_Str"");
String referer=msg.getData().getString(""String_Node_Str"");
Long contentLength=msg.getData().getLong(""String_Node_Str"");
if (mDownloadListener instanceof BrowserDownloadListener) {
((BrowserDownloadListener)mDownloadListener).onDownloadStart(url,userAgent,contentDisposition,mimetype,referer,contentLength);
}
 else {
mDownloadListener.onDownloadStart(url,userAgent,contentDisposition,mimetype,contentLength);
}
}
break;
case CREATE_WINDOW:
if (mWebChromeClient != null) {
if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(),msg.arg1 == 1,msg.arg2 == 1,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
mWebView.dismissZoomControl();
}
break;
case REQUEST_FOCUS:
if (mWebChromeClient != null) {
mWebChromeClient.onRequestFocus(mWebView.getWebView());
}
break;
case CLOSE_WINDOW:
if (mWebChromeClient != null) {
mWebChromeClient.onCloseWindow(((WebViewClassic)msg.obj).getWebView());
}
break;
case SAVE_PASSWORD:
Bundle bundle=msg.getData();
String schemePlusHost=bundle.getString(""String_Node_Str"");
String username=bundle.getString(""String_Node_Str"");
String password=bundle.getString(""String_Node_Str"");
if (!mWebView.onSavePassword(schemePlusHost,username,password,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
break;
case ASYNC_KEYEVENTS:
if (mWebViewClient != null) {
mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(),(KeyEvent)msg.obj);
}
break;
case EXCEEDED_DATABASE_QUOTA:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String databaseIdentifier=(String)map.get(""String_Node_Str"");
String url=(String)map.get(""String_Node_Str"");
long quota=((Long)map.get(""String_Node_Str"")).longValue();
long totalQuota=((Long)map.get(""String_Node_Str"")).longValue();
long estimatedDatabaseSize=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onExceededDatabaseQuota(url,databaseIdentifier,quota,estimatedDatabaseSize,totalQuota,quotaUpdater);
}
break;
case REACHED_APPCACHE_MAXSIZE:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
long requiredStorage=((Long)map.get(""String_Node_Str"")).longValue();
long quota=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage,quota,quotaUpdater);
}
break;
case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String origin=(String)map.get(""String_Node_Str"");
GeolocationPermissions.Callback callback=(GeolocationPermissions.Callback)map.get(""String_Node_Str"");
mWebChromeClient.onGeolocationPermissionsShowPrompt(origin,callback);
}
break;
case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
if (mWebChromeClient != null) {
mWebChromeClient.onGeolocationPermissionsHidePrompt();
}
break;
case JS_ALERT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsAlert(mWebView.getWebView(),url,message,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.confirm();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_CONFIRM:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsConfirm(mWebView.getWebView(),url,message,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.confirm();
}
}
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.cancel();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_PROMPT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsPromptResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String defaultVal=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsPrompt(mWebView.getWebView(),url,message,defaultVal,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
final LayoutInflater factory=LayoutInflater.from(mContext);
final View view=factory.inflate(R.layout.js_prompt,null);
final EditText v=(EditText)view.findViewById(R.id.value);
v.setText(defaultVal);
((TextView)view.findViewById(R.id.message)).setText(message);
new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setView(view).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
res.confirm(v.getText().toString());
}
}
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
res.cancel();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_UNLOAD:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
String message=msg.getData().getString(""String_Node_Str"");
String url=msg.getData().getString(""String_Node_Str"");
if (!mWebChromeClient.onJsBeforeUnload(mWebView.getWebView(),url,message,res)) {
if (!canShowAlertDialog()) {
res.cancel();
receiver.setReady();
break;
}
final String m=mContext.getString(R.string.js_dialog_before_unload,message);
new AlertDialog.Builder(mContext).setMessage(m).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.confirm();
}
}
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
res.cancel();
}
}
).setOnCancelListener(new DialogInterface.OnCancelListener(){
@Override public void onCancel(DialogInterface dialog){
res.cancel();
}
}
).show();
}
receiver.setReady();
}
break;
case JS_TIMEOUT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
if (mWebChromeClient.onJsTimeout()) {
res.confirm();
}
 else {
res.cancel();
}
receiver.setReady();
}
break;
case RECEIVED_CERTIFICATE:
mWebView.setCertificate((SslCertificate)msg.obj);
break;
case NOTIFY:
synchronized (this) {
notify();
}
break;
case SCALE_CHANGED:
if (mWebViewClient != null) {
mWebViewClient.onScaleChanged(mWebView.getWebView(),msg.getData().getFloat(""String_Node_Str""),msg.getData().getFloat(""String_Node_Str""));
}
break;
case SWITCH_OUT_HISTORY:
mWebView.switchOutDrawHistory();
break;
case ADD_MESSAGE_TO_CONSOLE:
if (mWebChromeClient == null) {
break;
}
String message=msg.getData().getString(""String_Node_Str"");
String sourceID=msg.getData().getString(""String_Node_Str"");
int lineNumber=msg.getData().getInt(""String_Node_Str"");
int msgLevel=msg.getData().getInt(""String_Node_Str"");
int numberOfMessageLevels=ConsoleMessage.MessageLevel.values().length;
if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
msgLevel=0;
}
ConsoleMessage.MessageLevel messageLevel=ConsoleMessage.MessageLevel.values()[msgLevel];
if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message,sourceID,lineNumber,messageLevel))) {
String logTag=""String_Node_Str"";
String logMessage=message + ""String_Node_Str"" + sourceID+ ""String_Node_Str""+ lineNumber;
switch (messageLevel) {
case TIP:
Log.v(logTag,logMessage);
break;
case LOG:
Log.i(logTag,logMessage);
break;
case WARNING:
Log.w(logTag,logMessage);
break;
case ERROR:
Log.e(logTag,logMessage);
break;
case DEBUG:
Log.d(logTag,logMessage);
break;
}
}
break;
case GET_VISITED_HISTORY:
if (mWebChromeClient != null) {
mWebChromeClient.getVisitedHistory((ValueCallback<String[]>)msg.obj);
}
break;
case OPEN_FILE_CHOOSER:
if (mWebChromeClient != null) {
UploadFileMessageData data=(UploadFileMessageData)msg.obj;
mWebChromeClient.openFileChooser(data.getUploadFile(),data.getAcceptType(),data.getCapture());
}
break;
case ADD_HISTORY_ITEM:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem)msg.obj);
}
break;
case HISTORY_INDEX_CHANGED:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onIndexChanged((WebHistoryItem)msg.obj,msg.arg1);
}
break;
case AUTH_CREDENTIALS:
{
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
username=msg.getData().getString(""String_Node_Str"");
password=msg.getData().getString(""String_Node_Str"");
mWebView.setHttpAuthUsernamePassword(host,realm,username,password);
break;
}
case AUTO_LOGIN:
{
if (mWebViewClient != null) {
String realm=msg.getData().getString(""String_Node_Str"");
String account=msg.getData().getString(""String_Node_Str"");
String args=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(),realm,account,args);
}
break;
}
}
}","@Override public void handleMessage(Message msg){
  if (messagesBlocked())   return;
switch (msg.what) {
case PAGE_STARTED:
    String startedUrl=msg.getData().getString(""String_Node_Str"");
  mWebView.onPageStarted(startedUrl);
if (mWebViewClient != null) {
  mWebViewClient.onPageStarted(mWebView.getWebView(),startedUrl,(Bitmap)msg.obj);
}
break;
case PAGE_FINISHED:
String finishedUrl=(String)msg.obj;
mWebView.onPageFinished(finishedUrl);
if (mWebViewClient != null) {
mWebViewClient.onPageFinished(mWebView.getWebView(),finishedUrl);
}
break;
case RECEIVED_ICON:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedIcon(mWebView.getWebView(),(Bitmap)msg.obj);
}
break;
case RECEIVED_TOUCH_ICON_URL:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(),(String)msg.obj,msg.arg1 == 1);
}
break;
case RECEIVED_TITLE:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTitle(mWebView.getWebView(),(String)msg.obj);
}
break;
case REPORT_ERROR:
if (mWebViewClient != null) {
int reasonCode=msg.arg1;
final String description=msg.getData().getString(""String_Node_Str"");
final String failUrl=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedError(mWebView.getWebView(),reasonCode,description,failUrl);
}
break;
case RESEND_POST_DATA:
Message resend=(Message)msg.getData().getParcelable(""String_Node_Str"");
Message dontResend=(Message)msg.getData().getParcelable(""String_Node_Str"");
if (mWebViewClient != null) {
mWebViewClient.onFormResubmission(mWebView.getWebView(),dontResend,resend);
}
 else {
dontResend.sendToTarget();
}
break;
case OVERRIDE_URL:
String overrideUrl=msg.getData().getString(""String_Node_Str"");
boolean override=uiOverrideUrlLoading(overrideUrl);
ResultTransport<Boolean> result=(ResultTransport<Boolean>)msg.obj;
synchronized (this) {
result.setResult(override);
notify();
}
break;
case AUTH_REQUEST:
if (mWebViewClient != null) {
HttpAuthHandler handler=(HttpAuthHandler)msg.obj;
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(),handler,host,realm);
}
break;
case SSL_ERROR:
if (mWebViewClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
mWebViewClient.onReceivedSslError(mWebView.getWebView(),(SslErrorHandler)map.get(""String_Node_Str""),(SslError)map.get(""String_Node_Str""));
}
break;
case PROCEEDED_AFTER_SSL_ERROR:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
((WebViewClientClassicExt)mWebViewClient).onProceededAfterSslError(mWebView.getWebView(),(SslError)msg.obj);
}
break;
case CLIENT_CERT_REQUEST:
if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
((WebViewClientClassicExt)mWebViewClient).onReceivedClientCertRequest(mWebView.getWebView(),(ClientCertRequestHandler)map.get(""String_Node_Str""),(String)map.get(""String_Node_Str""));
}
break;
case PROGRESS:
synchronized (this) {
if (mWebChromeClient != null) {
mWebChromeClient.onProgressChanged(mWebView.getWebView(),mLatestProgress);
}
mProgressUpdatePending=false;
}
break;
case UPDATE_VISITED:
if (mWebViewClient != null) {
mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(),(String)msg.obj,msg.arg1 != 0);
}
break;
case LOAD_RESOURCE:
if (mWebViewClient != null) {
mWebViewClient.onLoadResource(mWebView.getWebView(),(String)msg.obj);
}
break;
case DOWNLOAD_FILE:
if (mDownloadListener != null) {
String url=msg.getData().getString(""String_Node_Str"");
String userAgent=msg.getData().getString(""String_Node_Str"");
String contentDisposition=msg.getData().getString(""String_Node_Str"");
String mimetype=msg.getData().getString(""String_Node_Str"");
String referer=msg.getData().getString(""String_Node_Str"");
Long contentLength=msg.getData().getLong(""String_Node_Str"");
if (mDownloadListener instanceof BrowserDownloadListener) {
((BrowserDownloadListener)mDownloadListener).onDownloadStart(url,userAgent,contentDisposition,mimetype,referer,contentLength);
}
 else {
mDownloadListener.onDownloadStart(url,userAgent,contentDisposition,mimetype,contentLength);
}
}
break;
case CREATE_WINDOW:
if (mWebChromeClient != null) {
if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(),msg.arg1 == 1,msg.arg2 == 1,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
mWebView.dismissZoomControl();
}
break;
case REQUEST_FOCUS:
if (mWebChromeClient != null) {
mWebChromeClient.onRequestFocus(mWebView.getWebView());
}
break;
case CLOSE_WINDOW:
if (mWebChromeClient != null) {
mWebChromeClient.onCloseWindow(((WebViewClassic)msg.obj).getWebView());
}
break;
case SAVE_PASSWORD:
Bundle bundle=msg.getData();
String schemePlusHost=bundle.getString(""String_Node_Str"");
String username=bundle.getString(""String_Node_Str"");
String password=bundle.getString(""String_Node_Str"");
if (!mWebView.onSavePassword(schemePlusHost,username,password,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
break;
case ASYNC_KEYEVENTS:
if (mWebViewClient != null) {
mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(),(KeyEvent)msg.obj);
}
break;
case EXCEEDED_DATABASE_QUOTA:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String databaseIdentifier=(String)map.get(""String_Node_Str"");
String url=(String)map.get(""String_Node_Str"");
long quota=((Long)map.get(""String_Node_Str"")).longValue();
long totalQuota=((Long)map.get(""String_Node_Str"")).longValue();
long estimatedDatabaseSize=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onExceededDatabaseQuota(url,databaseIdentifier,quota,estimatedDatabaseSize,totalQuota,quotaUpdater);
}
break;
case REACHED_APPCACHE_MAXSIZE:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
long requiredStorage=((Long)map.get(""String_Node_Str"")).longValue();
long quota=((Long)map.get(""String_Node_Str"")).longValue();
WebStorage.QuotaUpdater quotaUpdater=(WebStorage.QuotaUpdater)map.get(""String_Node_Str"");
mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage,quota,quotaUpdater);
}
break;
case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
if (mWebChromeClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
String origin=(String)map.get(""String_Node_Str"");
GeolocationPermissions.Callback callback=(GeolocationPermissions.Callback)map.get(""String_Node_Str"");
mWebChromeClient.onGeolocationPermissionsShowPrompt(origin,callback);
}
break;
case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
if (mWebChromeClient != null) {
mWebChromeClient.onGeolocationPermissionsHidePrompt();
}
break;
case JS_DIALOG:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
JsDialogHelper helper=new JsDialogHelper(receiver.mJsResult,msg);
if (!helper.invokeCallback(mWebChromeClient,mWebView.getWebView())) {
helper.showDialog(mContext);
}
receiver.setReady();
}
break;
case JS_TIMEOUT:
if (mWebChromeClient != null) {
final JsResultReceiver receiver=(JsResultReceiver)msg.obj;
final JsResult res=receiver.mJsResult;
if (mWebChromeClient.onJsTimeout()) {
res.confirm();
}
 else {
res.cancel();
}
receiver.setReady();
}
break;
case RECEIVED_CERTIFICATE:
mWebView.setCertificate((SslCertificate)msg.obj);
break;
case NOTIFY:
synchronized (this) {
notify();
}
break;
case SCALE_CHANGED:
if (mWebViewClient != null) {
mWebViewClient.onScaleChanged(mWebView.getWebView(),msg.getData().getFloat(""String_Node_Str""),msg.getData().getFloat(""String_Node_Str""));
}
break;
case SWITCH_OUT_HISTORY:
mWebView.switchOutDrawHistory();
break;
case ADD_MESSAGE_TO_CONSOLE:
if (mWebChromeClient == null) {
break;
}
String message=msg.getData().getString(""String_Node_Str"");
String sourceID=msg.getData().getString(""String_Node_Str"");
int lineNumber=msg.getData().getInt(""String_Node_Str"");
int msgLevel=msg.getData().getInt(""String_Node_Str"");
int numberOfMessageLevels=ConsoleMessage.MessageLevel.values().length;
if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
msgLevel=0;
}
ConsoleMessage.MessageLevel messageLevel=ConsoleMessage.MessageLevel.values()[msgLevel];
if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message,sourceID,lineNumber,messageLevel))) {
String logTag=""String_Node_Str"";
String logMessage=message + ""String_Node_Str"" + sourceID+ ""String_Node_Str""+ lineNumber;
switch (messageLevel) {
case TIP:
Log.v(logTag,logMessage);
break;
case LOG:
Log.i(logTag,logMessage);
break;
case WARNING:
Log.w(logTag,logMessage);
break;
case ERROR:
Log.e(logTag,logMessage);
break;
case DEBUG:
Log.d(logTag,logMessage);
break;
}
}
break;
case GET_VISITED_HISTORY:
if (mWebChromeClient != null) {
mWebChromeClient.getVisitedHistory((ValueCallback<String[]>)msg.obj);
}
break;
case OPEN_FILE_CHOOSER:
if (mWebChromeClient != null) {
UploadFileMessageData data=(UploadFileMessageData)msg.obj;
mWebChromeClient.openFileChooser(data.getUploadFile(),data.getAcceptType(),data.getCapture());
}
break;
case ADD_HISTORY_ITEM:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem)msg.obj);
}
break;
case HISTORY_INDEX_CHANGED:
if (mWebBackForwardListClient != null) {
mWebBackForwardListClient.onIndexChanged((WebHistoryItem)msg.obj,msg.arg1);
}
break;
case AUTH_CREDENTIALS:
{
String host=msg.getData().getString(""String_Node_Str"");
String realm=msg.getData().getString(""String_Node_Str"");
username=msg.getData().getString(""String_Node_Str"");
password=msg.getData().getString(""String_Node_Str"");
mWebView.setHttpAuthUsernamePassword(host,realm,username,password);
break;
}
case AUTO_LOGIN:
{
if (mWebViewClient != null) {
String realm=msg.getData().getString(""String_Node_Str"");
String account=msg.getData().getString(""String_Node_Str"");
String args=msg.getData().getString(""String_Node_Str"");
mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(),realm,account,args);
}
break;
}
}
}"
2327,"/** 
 * The width passed in is now the desired layout width, not the full view width with padding.  {@hide}
 */
protected void makeNewLayout(int wantWidth,int hintWidth,BoringLayout.Metrics boring,BoringLayout.Metrics hintBoring,int ellipsisWidth,boolean bringIntoView){
  stopMarquee();
  mOldMaximum=mMaximum;
  mOldMaxMode=mMaxMode;
  mHighlightPathBogus=true;
  if (wantWidth < 0) {
    wantWidth=0;
  }
  if (hintWidth < 0) {
    hintWidth=0;
  }
  Layout.Alignment alignment=getLayoutAlignment();
  boolean shouldEllipsize=mEllipsize != null && getKeyListener() == null;
  final boolean switchEllipsize=mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_NORMAL;
  TruncateAt effectiveEllipsize=mEllipsize;
  if (mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
    effectiveEllipsize=TruncateAt.END_SMALL;
  }
  if (mTextDir == null) {
    mTextDir=getTextDirectionHeuristic();
  }
  mLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,effectiveEllipsize,effectiveEllipsize == mEllipsize);
  if (switchEllipsize) {
    TruncateAt oppositeEllipsize=effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE;
    mSavedMarqueeModeLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,oppositeEllipsize,effectiveEllipsize != mEllipsize);
  }
  shouldEllipsize=mEllipsize != null;
  mHintLayout=null;
  if (mHint != null) {
    if (shouldEllipsize)     hintWidth=wantWidth;
    if (hintBoring == UNKNOWN_BORING) {
      hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
      if (hintBoring != null) {
        mHintBoring=hintBoring;
      }
    }
    if (hintBoring != null) {
      if (hintBoring.width <= hintWidth && (!shouldEllipsize || hintBoring.width <= ellipsisWidth)) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
        mSavedHintLayout=(BoringLayout)mHintLayout;
      }
 else       if (shouldEllipsize && hintBoring.width <= hintWidth) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
      }
 else       if (shouldEllipsize) {
        mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
      }
 else {
        mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
      }
    }
 else     if (shouldEllipsize) {
      mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
    }
 else {
      mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
    }
  }
  if (bringIntoView) {
    registerForPreDraw();
  }
  if (mEllipsize == TextUtils.TruncateAt.MARQUEE) {
    if (!compressText(ellipsisWidth)) {
      final int height=mLayoutParams.height;
      if (height != LayoutParams.WRAP_CONTENT && height != LayoutParams.MATCH_PARENT) {
        startMarquee();
      }
 else {
        mRestartMarquee=true;
      }
    }
  }
  if (mEditor != null)   mEditor.prepareCursorControllers();
}","/** 
 * The width passed in is now the desired layout width, not the full view width with padding.  {@hide}
 */
protected void makeNewLayout(int wantWidth,int hintWidth,BoringLayout.Metrics boring,BoringLayout.Metrics hintBoring,int ellipsisWidth,boolean bringIntoView){
  stopMarquee();
  mOldMaximum=mMaximum;
  mOldMaxMode=mMaxMode;
  mHighlightPathBogus=true;
  if (wantWidth < 0) {
    wantWidth=0;
  }
  if (hintWidth < 0) {
    hintWidth=0;
  }
  Layout.Alignment alignment=getLayoutAlignment();
  final boolean testDirChange=mSingleLine && mLayout != null && (alignment == Layout.Alignment.ALIGN_NORMAL || alignment == Layout.Alignment.ALIGN_OPPOSITE);
  int oldDir=0;
  if (testDirChange)   oldDir=mLayout.getParagraphDirection(0);
  boolean shouldEllipsize=mEllipsize != null && getKeyListener() == null;
  final boolean switchEllipsize=mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_NORMAL;
  TruncateAt effectiveEllipsize=mEllipsize;
  if (mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
    effectiveEllipsize=TruncateAt.END_SMALL;
  }
  if (mTextDir == null) {
    mTextDir=getTextDirectionHeuristic();
  }
  mLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,effectiveEllipsize,effectiveEllipsize == mEllipsize);
  if (switchEllipsize) {
    TruncateAt oppositeEllipsize=effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE;
    mSavedMarqueeModeLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,oppositeEllipsize,effectiveEllipsize != mEllipsize);
  }
  shouldEllipsize=mEllipsize != null;
  mHintLayout=null;
  if (mHint != null) {
    if (shouldEllipsize)     hintWidth=wantWidth;
    if (hintBoring == UNKNOWN_BORING) {
      hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
      if (hintBoring != null) {
        mHintBoring=hintBoring;
      }
    }
    if (hintBoring != null) {
      if (hintBoring.width <= hintWidth && (!shouldEllipsize || hintBoring.width <= ellipsisWidth)) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
        mSavedHintLayout=(BoringLayout)mHintLayout;
      }
 else       if (shouldEllipsize && hintBoring.width <= hintWidth) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
      }
 else       if (shouldEllipsize) {
        mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
      }
 else {
        mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
      }
    }
 else     if (shouldEllipsize) {
      mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
    }
 else {
      mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
    }
  }
  if (bringIntoView || (testDirChange && oldDir != mLayout.getParagraphDirection(0))) {
    registerForPreDraw();
  }
  if (mEllipsize == TextUtils.TruncateAt.MARQUEE) {
    if (!compressText(ellipsisWidth)) {
      final int height=mLayoutParams.height;
      if (height != LayoutParams.WRAP_CONTENT && height != LayoutParams.MATCH_PARENT) {
        startMarquee();
      }
 else {
        mRestartMarquee=true;
      }
    }
  }
  if (mEditor != null)   mEditor.prepareCursorControllers();
}"
2328,"/** 
 * The width passed in is now the desired layout width, not the full view width with padding.  {@hide}
 */
protected void makeNewLayout(int wantWidth,int hintWidth,BoringLayout.Metrics boring,BoringLayout.Metrics hintBoring,int ellipsisWidth,boolean bringIntoView){
  stopMarquee();
  mOldMaximum=mMaximum;
  mOldMaxMode=mMaxMode;
  mHighlightPathBogus=true;
  if (wantWidth < 0) {
    wantWidth=0;
  }
  if (hintWidth < 0) {
    hintWidth=0;
  }
  Layout.Alignment alignment=getLayoutAlignment();
  boolean shouldEllipsize=mEllipsize != null && getKeyListener() == null;
  final boolean switchEllipsize=mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_NORMAL;
  TruncateAt effectiveEllipsize=mEllipsize;
  if (mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
    effectiveEllipsize=TruncateAt.END_SMALL;
  }
  if (mTextDir == null) {
    mTextDir=getTextDirectionHeuristic();
  }
  mLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,effectiveEllipsize,effectiveEllipsize == mEllipsize);
  if (switchEllipsize) {
    TruncateAt oppositeEllipsize=effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE;
    mSavedMarqueeModeLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,oppositeEllipsize,effectiveEllipsize != mEllipsize);
  }
  shouldEllipsize=mEllipsize != null;
  mHintLayout=null;
  if (mHint != null) {
    if (shouldEllipsize)     hintWidth=wantWidth;
    if (hintBoring == UNKNOWN_BORING) {
      hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
      if (hintBoring != null) {
        mHintBoring=hintBoring;
      }
    }
    if (hintBoring != null) {
      if (hintBoring.width <= hintWidth && (!shouldEllipsize || hintBoring.width <= ellipsisWidth)) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
        mSavedHintLayout=(BoringLayout)mHintLayout;
      }
 else       if (shouldEllipsize && hintBoring.width <= hintWidth) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
      }
 else       if (shouldEllipsize) {
        mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
      }
 else {
        mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
      }
    }
 else     if (shouldEllipsize) {
      mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
    }
 else {
      mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
    }
  }
  if (bringIntoView) {
    registerForPreDraw();
  }
  if (mEllipsize == TextUtils.TruncateAt.MARQUEE) {
    if (!compressText(ellipsisWidth)) {
      final int height=mLayoutParams.height;
      if (height != LayoutParams.WRAP_CONTENT && height != LayoutParams.MATCH_PARENT) {
        startMarquee();
      }
 else {
        mRestartMarquee=true;
      }
    }
  }
  if (mEditor != null)   mEditor.prepareCursorControllers();
}","/** 
 * The width passed in is now the desired layout width, not the full view width with padding.  {@hide}
 */
protected void makeNewLayout(int wantWidth,int hintWidth,BoringLayout.Metrics boring,BoringLayout.Metrics hintBoring,int ellipsisWidth,boolean bringIntoView){
  stopMarquee();
  mOldMaximum=mMaximum;
  mOldMaxMode=mMaxMode;
  mHighlightPathBogus=true;
  if (wantWidth < 0) {
    wantWidth=0;
  }
  if (hintWidth < 0) {
    hintWidth=0;
  }
  Layout.Alignment alignment=getLayoutAlignment();
  final boolean testDirChange=mSingleLine && mLayout != null && (alignment == Layout.Alignment.ALIGN_NORMAL || alignment == Layout.Alignment.ALIGN_OPPOSITE);
  int oldDir=0;
  if (testDirChange)   oldDir=mLayout.getParagraphDirection(0);
  boolean shouldEllipsize=mEllipsize != null && getKeyListener() == null;
  final boolean switchEllipsize=mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_NORMAL;
  TruncateAt effectiveEllipsize=mEllipsize;
  if (mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
    effectiveEllipsize=TruncateAt.END_SMALL;
  }
  if (mTextDir == null) {
    mTextDir=getTextDirectionHeuristic();
  }
  mLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,effectiveEllipsize,effectiveEllipsize == mEllipsize);
  if (switchEllipsize) {
    TruncateAt oppositeEllipsize=effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE;
    mSavedMarqueeModeLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,oppositeEllipsize,effectiveEllipsize != mEllipsize);
  }
  shouldEllipsize=mEllipsize != null;
  mHintLayout=null;
  if (mHint != null) {
    if (shouldEllipsize)     hintWidth=wantWidth;
    if (hintBoring == UNKNOWN_BORING) {
      hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
      if (hintBoring != null) {
        mHintBoring=hintBoring;
      }
    }
    if (hintBoring != null) {
      if (hintBoring.width <= hintWidth && (!shouldEllipsize || hintBoring.width <= ellipsisWidth)) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
        mSavedHintLayout=(BoringLayout)mHintLayout;
      }
 else       if (shouldEllipsize && hintBoring.width <= hintWidth) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
      }
 else       if (shouldEllipsize) {
        mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
      }
 else {
        mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
      }
    }
 else     if (shouldEllipsize) {
      mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
    }
 else {
      mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
    }
  }
  if (bringIntoView || (testDirChange && oldDir != mLayout.getParagraphDirection(0))) {
    registerForPreDraw();
  }
  if (mEllipsize == TextUtils.TruncateAt.MARQUEE) {
    if (!compressText(ellipsisWidth)) {
      final int height=mLayoutParams.height;
      if (height != LayoutParams.WRAP_CONTENT && height != LayoutParams.MATCH_PARENT) {
        startMarquee();
      }
 else {
        mRestartMarquee=true;
      }
    }
  }
  if (mEditor != null)   mEditor.prepareCursorControllers();
}"
2329,"/** 
 * The width passed in is now the desired layout width, not the full view width with padding.  {@hide}
 */
protected void makeNewLayout(int wantWidth,int hintWidth,BoringLayout.Metrics boring,BoringLayout.Metrics hintBoring,int ellipsisWidth,boolean bringIntoView){
  stopMarquee();
  mOldMaximum=mMaximum;
  mOldMaxMode=mMaxMode;
  mHighlightPathBogus=true;
  if (wantWidth < 0) {
    wantWidth=0;
  }
  if (hintWidth < 0) {
    hintWidth=0;
  }
  Layout.Alignment alignment=getLayoutAlignment();
  boolean shouldEllipsize=mEllipsize != null && getKeyListener() == null;
  final boolean switchEllipsize=mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_NORMAL;
  TruncateAt effectiveEllipsize=mEllipsize;
  if (mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
    effectiveEllipsize=TruncateAt.END_SMALL;
  }
  if (mTextDir == null) {
    mTextDir=getTextDirectionHeuristic();
  }
  mLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,effectiveEllipsize,effectiveEllipsize == mEllipsize);
  if (switchEllipsize) {
    TruncateAt oppositeEllipsize=effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE;
    mSavedMarqueeModeLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,oppositeEllipsize,effectiveEllipsize != mEllipsize);
  }
  shouldEllipsize=mEllipsize != null;
  mHintLayout=null;
  if (mHint != null) {
    if (shouldEllipsize)     hintWidth=wantWidth;
    if (hintBoring == UNKNOWN_BORING) {
      hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
      if (hintBoring != null) {
        mHintBoring=hintBoring;
      }
    }
    if (hintBoring != null) {
      if (hintBoring.width <= hintWidth && (!shouldEllipsize || hintBoring.width <= ellipsisWidth)) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
        mSavedHintLayout=(BoringLayout)mHintLayout;
      }
 else       if (shouldEllipsize && hintBoring.width <= hintWidth) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
      }
 else       if (shouldEllipsize) {
        mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
      }
 else {
        mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
      }
    }
 else     if (shouldEllipsize) {
      mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
    }
 else {
      mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
    }
  }
  if (bringIntoView) {
    registerForPreDraw();
  }
  if (mEllipsize == TextUtils.TruncateAt.MARQUEE) {
    if (!compressText(ellipsisWidth)) {
      final int height=mLayoutParams.height;
      if (height != LayoutParams.WRAP_CONTENT && height != LayoutParams.MATCH_PARENT) {
        startMarquee();
      }
 else {
        mRestartMarquee=true;
      }
    }
  }
  if (mEditor != null)   mEditor.prepareCursorControllers();
}","/** 
 * The width passed in is now the desired layout width, not the full view width with padding.  {@hide}
 */
protected void makeNewLayout(int wantWidth,int hintWidth,BoringLayout.Metrics boring,BoringLayout.Metrics hintBoring,int ellipsisWidth,boolean bringIntoView){
  stopMarquee();
  mOldMaximum=mMaximum;
  mOldMaxMode=mMaxMode;
  mHighlightPathBogus=true;
  if (wantWidth < 0) {
    wantWidth=0;
  }
  if (hintWidth < 0) {
    hintWidth=0;
  }
  Layout.Alignment alignment=getLayoutAlignment();
  final boolean testDirChange=mSingleLine && mLayout != null && (alignment == Layout.Alignment.ALIGN_NORMAL || alignment == Layout.Alignment.ALIGN_OPPOSITE);
  int oldDir=0;
  if (testDirChange)   oldDir=mLayout.getParagraphDirection(0);
  boolean shouldEllipsize=mEllipsize != null && getKeyListener() == null;
  final boolean switchEllipsize=mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_NORMAL;
  TruncateAt effectiveEllipsize=mEllipsize;
  if (mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
    effectiveEllipsize=TruncateAt.END_SMALL;
  }
  if (mTextDir == null) {
    mTextDir=getTextDirectionHeuristic();
  }
  mLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,effectiveEllipsize,effectiveEllipsize == mEllipsize);
  if (switchEllipsize) {
    TruncateAt oppositeEllipsize=effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE;
    mSavedMarqueeModeLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,oppositeEllipsize,effectiveEllipsize != mEllipsize);
  }
  shouldEllipsize=mEllipsize != null;
  mHintLayout=null;
  if (mHint != null) {
    if (shouldEllipsize)     hintWidth=wantWidth;
    if (hintBoring == UNKNOWN_BORING) {
      hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
      if (hintBoring != null) {
        mHintBoring=hintBoring;
      }
    }
    if (hintBoring != null) {
      if (hintBoring.width <= hintWidth && (!shouldEllipsize || hintBoring.width <= ellipsisWidth)) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
        mSavedHintLayout=(BoringLayout)mHintLayout;
      }
 else       if (shouldEllipsize && hintBoring.width <= hintWidth) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
      }
 else       if (shouldEllipsize) {
        mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
      }
 else {
        mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
      }
    }
 else     if (shouldEllipsize) {
      mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
    }
 else {
      mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
    }
  }
  if (bringIntoView || (testDirChange && oldDir != mLayout.getParagraphDirection(0))) {
    registerForPreDraw();
  }
  if (mEllipsize == TextUtils.TruncateAt.MARQUEE) {
    if (!compressText(ellipsisWidth)) {
      final int height=mLayoutParams.height;
      if (height != LayoutParams.WRAP_CONTENT && height != LayoutParams.MATCH_PARENT) {
        startMarquee();
      }
 else {
        mRestartMarquee=true;
      }
    }
  }
  if (mEditor != null)   mEditor.prepareCursorControllers();
}"
2330,"private void handleActionMove(MotionEvent event){
  final int historySize=event.getHistorySize();
  Rect invalidateRect=mInvalidate;
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float startX=getCenterXForColumn(lastCell.column);
      float startY=getCenterYForRow(lastCell.row);
      final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
      float left=Math.min(startX,x) - radius;
      float right=Math.max(startX,x) + radius;
      float top=Math.min(startY,y) - radius;
      float bottom=Math.max(startY,y) + radius;
      if (hitCell != null && patternSize >= 2) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float x2=getCenterXForColumn(hitCell.column);
        final float y2=getCenterYForRow(hitCell.row);
        left=Math.min(x2,left - width);
        right=Math.max(x2,right + width);
        top=Math.min(y2,top - height);
        bottom=Math.max(y2,bottom + height);
      }
      invalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    invalidate(invalidateRect);
    invalidateRect.setEmpty();
  }
}","private void handleActionMove(MotionEvent event){
  final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
  final int historySize=event.getHistorySize();
  mTmpInvalidateRect.setEmpty();
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float lastCellCenterX=getCenterXForColumn(lastCell.column);
      float lastCellCenterY=getCenterYForRow(lastCell.row);
      float left=Math.min(lastCellCenterX,x) - radius;
      float right=Math.max(lastCellCenterX,x) + radius;
      float top=Math.min(lastCellCenterY,y) - radius;
      float bottom=Math.max(lastCellCenterY,y) + radius;
      if (hitCell != null) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float hitCellCenterX=getCenterXForColumn(hitCell.column);
        final float hitCellCenterY=getCenterYForRow(hitCell.row);
        left=Math.min(hitCellCenterX - width,left);
        right=Math.max(hitCellCenterX + width,right);
        top=Math.min(hitCellCenterY - height,top);
        bottom=Math.max(hitCellCenterY + height,bottom);
      }
      mTmpInvalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    mInvalidate.union(mTmpInvalidateRect);
    invalidate(mInvalidate);
    mInvalidate.set(mTmpInvalidateRect);
  }
}"
2331,"/** 
 * The width passed in is now the desired layout width, not the full view width with padding.  {@hide}
 */
protected void makeNewLayout(int wantWidth,int hintWidth,BoringLayout.Metrics boring,BoringLayout.Metrics hintBoring,int ellipsisWidth,boolean bringIntoView){
  stopMarquee();
  mOldMaximum=mMaximum;
  mOldMaxMode=mMaxMode;
  mHighlightPathBogus=true;
  if (wantWidth < 0) {
    wantWidth=0;
  }
  if (hintWidth < 0) {
    hintWidth=0;
  }
  Layout.Alignment alignment=getLayoutAlignment();
  boolean shouldEllipsize=mEllipsize != null && getKeyListener() == null;
  final boolean switchEllipsize=mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_NORMAL;
  TruncateAt effectiveEllipsize=mEllipsize;
  if (mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
    effectiveEllipsize=TruncateAt.END_SMALL;
  }
  if (mTextDir == null) {
    mTextDir=getTextDirectionHeuristic();
  }
  mLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,effectiveEllipsize,effectiveEllipsize == mEllipsize);
  if (switchEllipsize) {
    TruncateAt oppositeEllipsize=effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE;
    mSavedMarqueeModeLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,oppositeEllipsize,effectiveEllipsize != mEllipsize);
  }
  shouldEllipsize=mEllipsize != null;
  mHintLayout=null;
  if (mHint != null) {
    if (shouldEllipsize)     hintWidth=wantWidth;
    if (hintBoring == UNKNOWN_BORING) {
      hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
      if (hintBoring != null) {
        mHintBoring=hintBoring;
      }
    }
    if (hintBoring != null) {
      if (hintBoring.width <= hintWidth && (!shouldEllipsize || hintBoring.width <= ellipsisWidth)) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
        mSavedHintLayout=(BoringLayout)mHintLayout;
      }
 else       if (shouldEllipsize && hintBoring.width <= hintWidth) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
      }
 else       if (shouldEllipsize) {
        mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
      }
 else {
        mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
      }
    }
 else     if (shouldEllipsize) {
      mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
    }
 else {
      mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
    }
  }
  if (bringIntoView) {
    registerForPreDraw();
  }
  if (mEllipsize == TextUtils.TruncateAt.MARQUEE) {
    if (!compressText(ellipsisWidth)) {
      final int height=mLayoutParams.height;
      if (height != LayoutParams.WRAP_CONTENT && height != LayoutParams.MATCH_PARENT) {
        startMarquee();
      }
 else {
        mRestartMarquee=true;
      }
    }
  }
  if (mEditor != null)   mEditor.prepareCursorControllers();
}","/** 
 * The width passed in is now the desired layout width, not the full view width with padding.  {@hide}
 */
protected void makeNewLayout(int wantWidth,int hintWidth,BoringLayout.Metrics boring,BoringLayout.Metrics hintBoring,int ellipsisWidth,boolean bringIntoView){
  stopMarquee();
  mOldMaximum=mMaximum;
  mOldMaxMode=mMaxMode;
  mHighlightPathBogus=true;
  if (wantWidth < 0) {
    wantWidth=0;
  }
  if (hintWidth < 0) {
    hintWidth=0;
  }
  Layout.Alignment alignment=getLayoutAlignment();
  final boolean testDirChange=mSingleLine && mLayout != null && (alignment == Layout.Alignment.ALIGN_NORMAL || alignment == Layout.Alignment.ALIGN_OPPOSITE);
  int oldDir=0;
  if (testDirChange)   oldDir=mLayout.getParagraphDirection(0);
  boolean shouldEllipsize=mEllipsize != null && getKeyListener() == null;
  final boolean switchEllipsize=mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_NORMAL;
  TruncateAt effectiveEllipsize=mEllipsize;
  if (mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
    effectiveEllipsize=TruncateAt.END_SMALL;
  }
  if (mTextDir == null) {
    mTextDir=getTextDirectionHeuristic();
  }
  mLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,effectiveEllipsize,effectiveEllipsize == mEllipsize);
  if (switchEllipsize) {
    TruncateAt oppositeEllipsize=effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE;
    mSavedMarqueeModeLayout=makeSingleLayout(wantWidth,boring,ellipsisWidth,alignment,shouldEllipsize,oppositeEllipsize,effectiveEllipsize != mEllipsize);
  }
  shouldEllipsize=mEllipsize != null;
  mHintLayout=null;
  if (mHint != null) {
    if (shouldEllipsize)     hintWidth=wantWidth;
    if (hintBoring == UNKNOWN_BORING) {
      hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mTextDir,mHintBoring);
      if (hintBoring != null) {
        mHintBoring=hintBoring;
      }
    }
    if (hintBoring != null) {
      if (hintBoring.width <= hintWidth && (!shouldEllipsize || hintBoring.width <= ellipsisWidth)) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad);
        }
        mSavedHintLayout=(BoringLayout)mHintLayout;
      }
 else       if (shouldEllipsize && hintBoring.width <= hintWidth) {
        if (mSavedHintLayout != null) {
          mHintLayout=mSavedHintLayout.replaceOrMake(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
 else {
          mHintLayout=BoringLayout.make(mHint,mTextPaint,hintWidth,alignment,mSpacingMult,mSpacingAdd,hintBoring,mIncludePad,mEllipsize,ellipsisWidth);
        }
      }
 else       if (shouldEllipsize) {
        mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
      }
 else {
        mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
      }
    }
 else     if (shouldEllipsize) {
      mHintLayout=new StaticLayout(mHint,0,mHint.length(),mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad,mEllipsize,ellipsisWidth,mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
    }
 else {
      mHintLayout=new StaticLayout(mHint,mTextPaint,hintWidth,alignment,mTextDir,mSpacingMult,mSpacingAdd,mIncludePad);
    }
  }
  if (bringIntoView || (testDirChange && oldDir != mLayout.getParagraphDirection(0))) {
    registerForPreDraw();
  }
  if (mEllipsize == TextUtils.TruncateAt.MARQUEE) {
    if (!compressText(ellipsisWidth)) {
      final int height=mLayoutParams.height;
      if (height != LayoutParams.WRAP_CONTENT && height != LayoutParams.MATCH_PARENT) {
        startMarquee();
      }
 else {
        mRestartMarquee=true;
      }
    }
  }
  if (mEditor != null)   mEditor.prepareCursorControllers();
}"
2332,"public synchronized void removeAllocSize(int bytes){
  currentSize-=bytes;
}","public synchronized void removeAllocSize(long bytes){
  currentSize-=bytes;
}"
2333,"public void run(){
  while (mRun) {
    boolean doGC=false;
synchronized (this) {
      if (currentSize >= targetSize) {
        doGC=true;
      }
    }
    if (doGC == true) {
      System.gc();
    }
    try {
      sleep(1,0);
    }
 catch (    InterruptedException e) {
    }
  }
  Log.d(LOG_TAG,""String_Node_Str"");
}","public void run(){
  ActivityManager am=(ActivityManager)mRS.getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE);
  ActivityManager.MemoryInfo meminfo=new ActivityManager.MemoryInfo();
  am.getMemoryInfo(meminfo);
  targetSize=(long)(meminfo.totalMem * .5f);
  while (mRun) {
    System.gc();
    lock.lock();
    try {
      cond.awaitUninterruptibly();
    }
  finally {
      lock.unlock();
    }
  }
  Log.d(LOG_TAG,""String_Node_Str"");
}"
2334,"/** 
 * Destroy this renderscript context.  Once this function is called its no longer legal to use this or any objects created by this context.
 */
public void destroy(){
  validate();
  nContextDeinitToClient(mContext);
  mMessageThread.mRun=false;
  mGCThread.mRun=false;
  try {
    mMessageThread.join();
    mGCThread.join();
  }
 catch (  InterruptedException e) {
  }
  nContextDestroy();
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}","/** 
 * Destroy this renderscript context.  Once this function is called its no longer legal to use this or any objects created by this context.
 */
public void destroy(){
  validate();
  nContextDeinitToClient(mContext);
  mMessageThread.mRun=false;
  mGCThread.mRun=false;
  mGCThread.addAllocSize(0);
  try {
    mMessageThread.join();
    mGCThread.join();
  }
 catch (  InterruptedException e) {
  }
  nContextDestroy();
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}"
2335,"public synchronized void addAllocSize(int bytes){
  currentSize+=bytes;
}","public synchronized void addAllocSize(long bytes){
  currentSize+=bytes;
  if (currentSize >= targetSize) {
    lock.lock();
    try {
      cond.signal();
    }
  finally {
      lock.unlock();
    }
  }
}"
2336,"/** 
 * Constructs a new WebView with layout parameters, a default style and a set of custom Javscript interfaces to be added to this WebView at initialization time. This guarantees that these interfaces will be available when the JS context is initialized.
 * @param context a Context object used to access application assets
 * @param attrs an AttributeSet passed to our parent
 * @param defStyle the default style resource ID
 * @param javaScriptInterfaces a Map of interface names, as keys, andobject implementing those interfaces, as values
 * @param privateBrowsing whether this WebView will be initialized inprivate mode
 * @hide This is used internally by dumprendertree, as it requires the javaScript interfaces tobe added synchronously, before a subsequent loadUrl call takes effect.
 */
@SuppressWarnings(""String_Node_Str"") protected WebView(Context context,AttributeSet attrs,int defStyle,Map<String,Object> javaScriptInterfaces,boolean privateBrowsing){
  super(context,attrs,defStyle);
  if (context == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkThread();
  ensureProviderCreated();
  mProvider.init(javaScriptInterfaces,privateBrowsing);
}","/** 
 * Constructs a new WebView with layout parameters, a default style and a set of custom Javscript interfaces to be added to this WebView at initialization time. This guarantees that these interfaces will be available when the JS context is initialized.
 * @param context a Context object used to access application assets
 * @param attrs an AttributeSet passed to our parent
 * @param defStyle the default style resource ID
 * @param javaScriptInterfaces a Map of interface names, as keys, andobject implementing those interfaces, as values
 * @param privateBrowsing whether this WebView will be initialized inprivate mode
 * @hide This is used internally by dumprendertree, as it requires the javaScript interfaces tobe added synchronously, before a subsequent loadUrl call takes effect.
 */
@SuppressWarnings(""String_Node_Str"") protected WebView(Context context,AttributeSet attrs,int defStyle,Map<String,Object> javaScriptInterfaces,boolean privateBrowsing){
  super(context,attrs,defStyle);
  if (context == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  sEnforceThreadChecking=context.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN_MR2;
  checkThread();
  ensureProviderCreated();
  mProvider.init(javaScriptInterfaces,privateBrowsing);
}"
2337,"private static void checkThread(){
  if (Looper.myLooper() != Looper.getMainLooper()) {
    Throwable throwable=new Throwable(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    Log.w(LOGTAG,Log.getStackTraceString(throwable));
    StrictMode.onWebViewMethodCalledOnWrongThread(throwable);
  }
}","private static void checkThread(){
  if (Looper.myLooper() != Looper.getMainLooper()) {
    Throwable throwable=new Throwable(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    Log.w(LOGTAG,Log.getStackTraceString(throwable));
    StrictMode.onWebViewMethodCalledOnWrongThread(throwable);
    if (sEnforceThreadChecking) {
      throw new RuntimeException(throwable);
    }
  }
}"
2338,"public synchronized void removeAllocSize(int bytes){
  currentSize-=bytes;
}","public synchronized void removeAllocSize(long bytes){
  currentSize-=bytes;
}"
2339,"public void run(){
  while (mRun) {
    boolean doGC=false;
synchronized (this) {
      if (currentSize >= targetSize) {
        doGC=true;
      }
    }
    if (doGC == true) {
      System.gc();
    }
    try {
      sleep(1,0);
    }
 catch (    InterruptedException e) {
    }
  }
  Log.d(LOG_TAG,""String_Node_Str"");
}","public void run(){
  ActivityManager am=(ActivityManager)mRS.getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE);
  ActivityManager.MemoryInfo meminfo=new ActivityManager.MemoryInfo();
  am.getMemoryInfo(meminfo);
  targetSize=(long)(meminfo.totalMem * .5f);
  while (mRun) {
    System.gc();
    lock.lock();
    try {
      cond.awaitUninterruptibly();
    }
  finally {
      lock.unlock();
    }
  }
  Log.d(LOG_TAG,""String_Node_Str"");
}"
2340,"/** 
 * Destroy this renderscript context.  Once this function is called its no longer legal to use this or any objects created by this context.
 */
public void destroy(){
  validate();
  nContextDeinitToClient(mContext);
  mMessageThread.mRun=false;
  mGCThread.mRun=false;
  try {
    mMessageThread.join();
    mGCThread.join();
  }
 catch (  InterruptedException e) {
  }
  nContextDestroy();
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}","/** 
 * Destroy this renderscript context.  Once this function is called its no longer legal to use this or any objects created by this context.
 */
public void destroy(){
  validate();
  nContextDeinitToClient(mContext);
  mMessageThread.mRun=false;
  mGCThread.mRun=false;
  mGCThread.addAllocSize(0);
  try {
    mMessageThread.join();
    mGCThread.join();
  }
 catch (  InterruptedException e) {
  }
  nContextDestroy();
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}"
2341,"public synchronized void addAllocSize(int bytes){
  currentSize+=bytes;
}","public synchronized void addAllocSize(long bytes){
  currentSize+=bytes;
  if (currentSize >= targetSize) {
    lock.lock();
    try {
      cond.signal();
    }
  finally {
      lock.unlock();
    }
  }
}"
2342,"/** 
 * Constructs a new WebView with layout parameters, a default style and a set of custom Javscript interfaces to be added to this WebView at initialization time. This guarantees that these interfaces will be available when the JS context is initialized.
 * @param context a Context object used to access application assets
 * @param attrs an AttributeSet passed to our parent
 * @param defStyle the default style resource ID
 * @param javaScriptInterfaces a Map of interface names, as keys, andobject implementing those interfaces, as values
 * @param privateBrowsing whether this WebView will be initialized inprivate mode
 * @hide This is used internally by dumprendertree, as it requires the javaScript interfaces tobe added synchronously, before a subsequent loadUrl call takes effect.
 */
@SuppressWarnings(""String_Node_Str"") protected WebView(Context context,AttributeSet attrs,int defStyle,Map<String,Object> javaScriptInterfaces,boolean privateBrowsing){
  super(context,attrs,defStyle);
  if (context == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkThread();
  ensureProviderCreated();
  mProvider.init(javaScriptInterfaces,privateBrowsing);
}","/** 
 * Constructs a new WebView with layout parameters, a default style and a set of custom Javscript interfaces to be added to this WebView at initialization time. This guarantees that these interfaces will be available when the JS context is initialized.
 * @param context a Context object used to access application assets
 * @param attrs an AttributeSet passed to our parent
 * @param defStyle the default style resource ID
 * @param javaScriptInterfaces a Map of interface names, as keys, andobject implementing those interfaces, as values
 * @param privateBrowsing whether this WebView will be initialized inprivate mode
 * @hide This is used internally by dumprendertree, as it requires the javaScript interfaces tobe added synchronously, before a subsequent loadUrl call takes effect.
 */
@SuppressWarnings(""String_Node_Str"") protected WebView(Context context,AttributeSet attrs,int defStyle,Map<String,Object> javaScriptInterfaces,boolean privateBrowsing){
  super(context,attrs,defStyle);
  if (context == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  sEnforceThreadChecking=context.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN_MR2;
  checkThread();
  ensureProviderCreated();
  mProvider.init(javaScriptInterfaces,privateBrowsing);
}"
2343,"private static void checkThread(){
  if (Looper.myLooper() != Looper.getMainLooper()) {
    Throwable throwable=new Throwable(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    Log.w(LOGTAG,Log.getStackTraceString(throwable));
    StrictMode.onWebViewMethodCalledOnWrongThread(throwable);
  }
}","private static void checkThread(){
  if (Looper.myLooper() != Looper.getMainLooper()) {
    Throwable throwable=new Throwable(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    Log.w(LOGTAG,Log.getStackTraceString(throwable));
    StrictMode.onWebViewMethodCalledOnWrongThread(throwable);
    if (sEnforceThreadChecking) {
      throw new RuntimeException(throwable);
    }
  }
}"
2344,"public synchronized void removeAllocSize(int bytes){
  currentSize-=bytes;
}","public synchronized void removeAllocSize(long bytes){
  currentSize-=bytes;
}"
2345,"public void run(){
  while (mRun) {
    boolean doGC=false;
synchronized (this) {
      if (currentSize >= targetSize) {
        doGC=true;
      }
    }
    if (doGC == true) {
      System.gc();
    }
    try {
      sleep(1,0);
    }
 catch (    InterruptedException e) {
    }
  }
  Log.d(LOG_TAG,""String_Node_Str"");
}","public void run(){
  ActivityManager am=(ActivityManager)mRS.getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE);
  ActivityManager.MemoryInfo meminfo=new ActivityManager.MemoryInfo();
  am.getMemoryInfo(meminfo);
  targetSize=(long)(meminfo.totalMem * .5f);
  while (mRun) {
    System.gc();
    lock.lock();
    try {
      cond.awaitUninterruptibly();
    }
  finally {
      lock.unlock();
    }
  }
  Log.d(LOG_TAG,""String_Node_Str"");
}"
2346,"/** 
 * Destroy this renderscript context.  Once this function is called its no longer legal to use this or any objects created by this context.
 */
public void destroy(){
  validate();
  nContextDeinitToClient(mContext);
  mMessageThread.mRun=false;
  mGCThread.mRun=false;
  try {
    mMessageThread.join();
    mGCThread.join();
  }
 catch (  InterruptedException e) {
  }
  nContextDestroy();
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}","/** 
 * Destroy this renderscript context.  Once this function is called its no longer legal to use this or any objects created by this context.
 */
public void destroy(){
  validate();
  nContextDeinitToClient(mContext);
  mMessageThread.mRun=false;
  mGCThread.mRun=false;
  mGCThread.addAllocSize(0);
  try {
    mMessageThread.join();
    mGCThread.join();
  }
 catch (  InterruptedException e) {
  }
  nContextDestroy();
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}"
2347,"public synchronized void addAllocSize(int bytes){
  currentSize+=bytes;
}","public synchronized void addAllocSize(long bytes){
  currentSize+=bytes;
  if (currentSize >= targetSize) {
    lock.lock();
    try {
      cond.signal();
    }
  finally {
      lock.unlock();
    }
  }
}"
2348,"/** 
 * Constructs a new WebView with layout parameters, a default style and a set of custom Javscript interfaces to be added to this WebView at initialization time. This guarantees that these interfaces will be available when the JS context is initialized.
 * @param context a Context object used to access application assets
 * @param attrs an AttributeSet passed to our parent
 * @param defStyle the default style resource ID
 * @param javaScriptInterfaces a Map of interface names, as keys, andobject implementing those interfaces, as values
 * @param privateBrowsing whether this WebView will be initialized inprivate mode
 * @hide This is used internally by dumprendertree, as it requires the javaScript interfaces tobe added synchronously, before a subsequent loadUrl call takes effect.
 */
@SuppressWarnings(""String_Node_Str"") protected WebView(Context context,AttributeSet attrs,int defStyle,Map<String,Object> javaScriptInterfaces,boolean privateBrowsing){
  super(context,attrs,defStyle);
  if (context == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkThread();
  ensureProviderCreated();
  mProvider.init(javaScriptInterfaces,privateBrowsing);
}","/** 
 * Constructs a new WebView with layout parameters, a default style and a set of custom Javscript interfaces to be added to this WebView at initialization time. This guarantees that these interfaces will be available when the JS context is initialized.
 * @param context a Context object used to access application assets
 * @param attrs an AttributeSet passed to our parent
 * @param defStyle the default style resource ID
 * @param javaScriptInterfaces a Map of interface names, as keys, andobject implementing those interfaces, as values
 * @param privateBrowsing whether this WebView will be initialized inprivate mode
 * @hide This is used internally by dumprendertree, as it requires the javaScript interfaces tobe added synchronously, before a subsequent loadUrl call takes effect.
 */
@SuppressWarnings(""String_Node_Str"") protected WebView(Context context,AttributeSet attrs,int defStyle,Map<String,Object> javaScriptInterfaces,boolean privateBrowsing){
  super(context,attrs,defStyle);
  if (context == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  sEnforceThreadChecking=context.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN_MR2;
  checkThread();
  ensureProviderCreated();
  mProvider.init(javaScriptInterfaces,privateBrowsing);
}"
2349,"private static void checkThread(){
  if (Looper.myLooper() != Looper.getMainLooper()) {
    Throwable throwable=new Throwable(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    Log.w(LOGTAG,Log.getStackTraceString(throwable));
    StrictMode.onWebViewMethodCalledOnWrongThread(throwable);
  }
}","private static void checkThread(){
  if (Looper.myLooper() != Looper.getMainLooper()) {
    Throwable throwable=new Throwable(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    Log.w(LOGTAG,Log.getStackTraceString(throwable));
    StrictMode.onWebViewMethodCalledOnWrongThread(throwable);
    if (sEnforceThreadChecking) {
      throw new RuntimeException(throwable);
    }
  }
}"
2350,"public synchronized void removeAllocSize(int bytes){
  currentSize-=bytes;
}","public synchronized void removeAllocSize(long bytes){
  currentSize-=bytes;
}"
2351,"public void run(){
  while (mRun) {
    boolean doGC=false;
synchronized (this) {
      if (currentSize >= targetSize) {
        doGC=true;
      }
    }
    if (doGC == true) {
      System.gc();
    }
    try {
      sleep(1,0);
    }
 catch (    InterruptedException e) {
    }
  }
  Log.d(LOG_TAG,""String_Node_Str"");
}","public void run(){
  ActivityManager am=(ActivityManager)mRS.getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE);
  ActivityManager.MemoryInfo meminfo=new ActivityManager.MemoryInfo();
  am.getMemoryInfo(meminfo);
  targetSize=(long)(meminfo.totalMem * .5f);
  while (mRun) {
    System.gc();
    lock.lock();
    try {
      cond.awaitUninterruptibly();
    }
  finally {
      lock.unlock();
    }
  }
  Log.d(LOG_TAG,""String_Node_Str"");
}"
2352,"/** 
 * Destroy this renderscript context.  Once this function is called its no longer legal to use this or any objects created by this context.
 */
public void destroy(){
  validate();
  nContextDeinitToClient(mContext);
  mMessageThread.mRun=false;
  mGCThread.mRun=false;
  try {
    mMessageThread.join();
    mGCThread.join();
  }
 catch (  InterruptedException e) {
  }
  nContextDestroy();
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}","/** 
 * Destroy this renderscript context.  Once this function is called its no longer legal to use this or any objects created by this context.
 */
public void destroy(){
  validate();
  nContextDeinitToClient(mContext);
  mMessageThread.mRun=false;
  mGCThread.mRun=false;
  mGCThread.addAllocSize(0);
  try {
    mMessageThread.join();
    mGCThread.join();
  }
 catch (  InterruptedException e) {
  }
  nContextDestroy();
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}"
2353,"public synchronized void addAllocSize(int bytes){
  currentSize+=bytes;
}","public synchronized void addAllocSize(long bytes){
  currentSize+=bytes;
  if (currentSize >= targetSize) {
    lock.lock();
    try {
      cond.signal();
    }
  finally {
      lock.unlock();
    }
  }
}"
2354,"/** 
 * Return the name of the activity that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  Youcan use this information to validate that the recipient is allowed to receive the data. <p>Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null. 
 * @return String The full name of the activity that will receive yourreply, or null if none.
 */
public ComponentName getCallingActivity(){
  try {
    return ActivityManagerNative.getDefault().getCallingActivity(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the name of the activity that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  Youcan use this information to validate that the recipient is allowed to receive the data. <p class=""note"">Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null. 
 * @return The ComponentName of the activity that will receive yourreply, or null if none.
 */
public ComponentName getCallingActivity(){
  try {
    return ActivityManagerNative.getDefault().getCallingActivity(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2355,"/** 
 * Return the name of the package that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  You canuse this information to validate that the recipient is allowed to receive the data. <p>Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null. 
 * @return The package of the activity that will receive yourreply, or null if none.
 */
public String getCallingPackage(){
  try {
    return ActivityManagerNative.getDefault().getCallingPackage(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the name of the package that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  You canuse this information to validate that the recipient is allowed to receive the data. <p class=""note"">Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null.</p> <p class=""note"">Note: prior to  {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, the result from this method was unstable.  If the process hosting the calling package was no longer running, it would return null instead of the proper package name.  You can use   {@link #getCallingActivity()} and retrieve the package namefrom that instead.</p>
 * @return The package of the activity that will receive yourreply, or null if none.
 */
public String getCallingPackage(){
  try {
    return ActivityManagerNative.getDefault().getCallingPackage(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2356,"public String getCallingPackage(IBinder token){
synchronized (this) {
    ActivityRecord r=getCallingRecordLocked(token);
    return r != null && r.app != null ? r.info.packageName : null;
  }
}","public String getCallingPackage(IBinder token){
synchronized (this) {
    ActivityRecord r=getCallingRecordLocked(token);
    return r != null ? r.info.packageName : null;
  }
}"
2357,"/** 
 * Return the name of the activity that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  Youcan use this information to validate that the recipient is allowed to receive the data. <p>Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null. 
 * @return String The full name of the activity that will receive yourreply, or null if none.
 */
public ComponentName getCallingActivity(){
  try {
    return ActivityManagerNative.getDefault().getCallingActivity(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the name of the activity that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  Youcan use this information to validate that the recipient is allowed to receive the data. <p class=""note"">Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null. 
 * @return The ComponentName of the activity that will receive yourreply, or null if none.
 */
public ComponentName getCallingActivity(){
  try {
    return ActivityManagerNative.getDefault().getCallingActivity(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2358,"/** 
 * Return the name of the package that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  You canuse this information to validate that the recipient is allowed to receive the data. <p>Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null. 
 * @return The package of the activity that will receive yourreply, or null if none.
 */
public String getCallingPackage(){
  try {
    return ActivityManagerNative.getDefault().getCallingPackage(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the name of the package that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  You canuse this information to validate that the recipient is allowed to receive the data. <p class=""note"">Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null.</p> <p class=""note"">Note: prior to  {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, the result from this method was unstable.  If the process hosting the calling package was no longer running, it would return null instead of the proper package name.  You can use   {@link #getCallingActivity()} and retrieve the package namefrom that instead.</p>
 * @return The package of the activity that will receive yourreply, or null if none.
 */
public String getCallingPackage(){
  try {
    return ActivityManagerNative.getDefault().getCallingPackage(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2359,"public String getCallingPackage(IBinder token){
synchronized (this) {
    ActivityRecord r=getCallingRecordLocked(token);
    return r != null && r.app != null ? r.info.packageName : null;
  }
}","public String getCallingPackage(IBinder token){
synchronized (this) {
    ActivityRecord r=getCallingRecordLocked(token);
    return r != null ? r.info.packageName : null;
  }
}"
2360,"public static String currentPackageName(){
  ActivityThread am=currentActivityThread();
  return (am != null && am.mBoundApplication != null) ? am.mBoundApplication.processName : null;
}","public static String currentPackageName(){
  ActivityThread am=currentActivityThread();
  return (am != null && am.mBoundApplication != null) ? am.mBoundApplication.appInfo.packageName : null;
}"
2361,"@Override public void onCreate(){
  String processName=ActivityThread.currentPackageName();
  Slog.i(""String_Node_Str"",""String_Node_Str"" + processName);
  if (!getApplicationInfo().packageName.equals(processName)) {
    return;
  }
  final WindowManager wm=(WindowManager)getSystemService(Context.WINDOW_SERVICE);
  final Display display=wm.getDefaultDisplay();
  if (""String_Node_Str"".equals(android.os.Build.TYPE)) {
    AlertDialog.Builder builder=new AlertDialog.Builder(this);
    builder.setTitle(""String_Node_Str"");
    builder.setMessage(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    builder.setCancelable(false);
    builder.setPositiveButton(""String_Node_Str"",null);
    Dialog dialog=builder.create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    dialog.show();
  }
  FakeView view=new FakeView(this);
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
  if (ActivityManager.isHighEndGfx()) {
    lp.flags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
  }
  lp.width=ViewGroup.LayoutParams.MATCH_PARENT;
  lp.height=ViewGroup.LayoutParams.MATCH_PARENT;
  int maxSize=display.getMaximumSizeDimension();
  maxSize*=2;
  lp.x=maxSize;
  lp.y=maxSize;
  lp.setTitle(getPackageName());
  wm.addView(view,lp);
  bindService(new Intent(this,FakeCoreService.class),mServiceConnection,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService2.class),mServiceConnection2,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService3.class),mServiceConnection3,Context.BIND_AUTO_CREATE);
  mHandler.sendEmptyMessage(MSG_TICK);
  mStuffing=new int[STUFFING_SIZE_INTS];
  for (int i=0; i < STUFFING_SIZE_BYTES / PAGE_SIZE; i++) {
    final int VAL=i * 2 + 100;
    final int OFF=(i * PAGE_SIZE) / 4;
    for (int j=0; j < (PAGE_SIZE / 4); j++) {
      mStuffing[OFF + j]=VAL;
    }
  }
}","@Override public void onCreate(){
  String processName=ActivityThread.currentProcessName();
  Slog.i(""String_Node_Str"",""String_Node_Str"" + processName);
  if (!getApplicationInfo().packageName.equals(processName)) {
    return;
  }
  final WindowManager wm=(WindowManager)getSystemService(Context.WINDOW_SERVICE);
  final Display display=wm.getDefaultDisplay();
  if (""String_Node_Str"".equals(android.os.Build.TYPE)) {
    AlertDialog.Builder builder=new AlertDialog.Builder(this);
    builder.setTitle(""String_Node_Str"");
    builder.setMessage(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    builder.setCancelable(false);
    builder.setPositiveButton(""String_Node_Str"",null);
    Dialog dialog=builder.create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    dialog.show();
  }
  FakeView view=new FakeView(this);
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
  if (ActivityManager.isHighEndGfx()) {
    lp.flags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
  }
  lp.width=ViewGroup.LayoutParams.MATCH_PARENT;
  lp.height=ViewGroup.LayoutParams.MATCH_PARENT;
  int maxSize=display.getMaximumSizeDimension();
  maxSize*=2;
  lp.x=maxSize;
  lp.y=maxSize;
  lp.setTitle(getPackageName());
  wm.addView(view,lp);
  bindService(new Intent(this,FakeCoreService.class),mServiceConnection,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService2.class),mServiceConnection2,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService3.class),mServiceConnection3,Context.BIND_AUTO_CREATE);
  mHandler.sendEmptyMessage(MSG_TICK);
  mStuffing=new int[STUFFING_SIZE_INTS];
  for (int i=0; i < STUFFING_SIZE_BYTES / PAGE_SIZE; i++) {
    final int VAL=i * 2 + 100;
    final int OFF=(i * PAGE_SIZE) / 4;
    for (int j=0; j < (PAGE_SIZE / 4); j++) {
      mStuffing[OFF + j]=VAL;
    }
  }
}"
2362,"/** 
 * Return the name of the activity that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  Youcan use this information to validate that the recipient is allowed to receive the data. <p>Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null. 
 * @return String The full name of the activity that will receive yourreply, or null if none.
 */
public ComponentName getCallingActivity(){
  try {
    return ActivityManagerNative.getDefault().getCallingActivity(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the name of the activity that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  Youcan use this information to validate that the recipient is allowed to receive the data. <p class=""note"">Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null. 
 * @return The ComponentName of the activity that will receive yourreply, or null if none.
 */
public ComponentName getCallingActivity(){
  try {
    return ActivityManagerNative.getDefault().getCallingActivity(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2363,"/** 
 * Return the name of the package that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  You canuse this information to validate that the recipient is allowed to receive the data. <p>Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null. 
 * @return The package of the activity that will receive yourreply, or null if none.
 */
public String getCallingPackage(){
  try {
    return ActivityManagerNative.getDefault().getCallingPackage(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the name of the package that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  You canuse this information to validate that the recipient is allowed to receive the data. <p class=""note"">Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null.</p> <p class=""note"">Note: prior to  {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, the result from this method was unstable.  If the process hosting the calling package was no longer running, it would return null instead of the proper package name.  You can use   {@link #getCallingActivity()} and retrieve the package namefrom that instead.</p>
 * @return The package of the activity that will receive yourreply, or null if none.
 */
public String getCallingPackage(){
  try {
    return ActivityManagerNative.getDefault().getCallingPackage(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2364,"public String getCallingPackage(IBinder token){
synchronized (this) {
    ActivityRecord r=getCallingRecordLocked(token);
    return r != null && r.app != null ? r.info.packageName : null;
  }
}","public String getCallingPackage(IBinder token){
synchronized (this) {
    ActivityRecord r=getCallingRecordLocked(token);
    return r != null ? r.info.packageName : null;
  }
}"
2365,"private boolean verifyPreloadConfig(TypedValue value,String name){
  if ((value.changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) != 0) {
    String resName;
    try {
      resName=getResourceName(value.resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(value.resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  return true;
}","private boolean verifyPreloadConfig(int changingConfigurations,int resourceId,String name){
  if (((changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) & VARYING_CONFIGS) != 0) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  return true;
}"
2366,"ColorStateList loadColorStateList(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  final long key=(((long)value.assetCookie) << 32) | value.data;
  ColorStateList csl;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    csl=sPreloadedColorStateLists.get(key);
    if (csl != null) {
      return csl;
    }
    csl=ColorStateList.valueOf(value.data);
    if (mPreloading) {
      if (verifyPreloadConfig(value,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
    return csl;
  }
  csl=getCachedColorStateList(key);
  if (csl != null) {
    return csl;
  }
  csl=sPreloadedColorStateLists.get(key);
  if (csl != null) {
    return csl;
  }
  if (value.string == null) {
    throw new NotFoundException(""String_Node_Str"" + value);
  }
  String file=value.string.toString();
  if (file.endsWith(""String_Node_Str"")) {
    try {
      XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
      csl=ColorStateList.createFromXml(this,rp);
      rp.close();
    }
 catch (    Exception e) {
      NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
      rnf.initCause(e);
      throw rnf;
    }
  }
 else {
    throw new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id)+ ""String_Node_Str"");
  }
  if (csl != null) {
    if (mPreloading) {
      if (verifyPreloadConfig(value,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
 else {
synchronized (mAccessLock) {
        mColorStateListCache.put(key,new WeakReference<ColorStateList>(csl));
      }
    }
  }
  return csl;
}","ColorStateList loadColorStateList(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  final long key=(((long)value.assetCookie) << 32) | value.data;
  ColorStateList csl;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    csl=sPreloadedColorStateLists.get(key);
    if (csl != null) {
      return csl;
    }
    csl=ColorStateList.valueOf(value.data);
    if (mPreloading) {
      if (verifyPreloadConfig(value.changingConfigurations,value.resourceId,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
    return csl;
  }
  csl=getCachedColorStateList(key);
  if (csl != null) {
    return csl;
  }
  csl=sPreloadedColorStateLists.get(key);
  if (csl != null) {
    return csl;
  }
  if (value.string == null) {
    throw new NotFoundException(""String_Node_Str"" + value);
  }
  String file=value.string.toString();
  if (file.endsWith(""String_Node_Str"")) {
    try {
      XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
      csl=ColorStateList.createFromXml(this,rp);
      rp.close();
    }
 catch (    Exception e) {
      NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
      rnf.initCause(e);
      throw rnf;
    }
  }
 else {
    throw new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id)+ ""String_Node_Str"");
  }
  if (csl != null) {
    if (mPreloading) {
      if (verifyPreloadConfig(value.changingConfigurations,value.resourceId,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
 else {
synchronized (mAccessLock) {
        mColorStateListCache.put(key,new WeakReference<ColorStateList>(csl));
      }
    }
  }
  return csl;
}"
2367,"Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
 else {
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(value,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables.put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}","Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
 else {
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(cs.getChangingConfigurations(),value.resourceId,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables.put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}"
2368,"@Override public int getChangingConfigurations(){
  return mChangingConfigurations;
}","@Override public int getChangingConfigurations(){
  return mChangingConfigurations | mChildrenChangingConfigurations;
}"
2369,"public static String currentPackageName(){
  ActivityThread am=currentActivityThread();
  return (am != null && am.mBoundApplication != null) ? am.mBoundApplication.processName : null;
}","public static String currentPackageName(){
  ActivityThread am=currentActivityThread();
  return (am != null && am.mBoundApplication != null) ? am.mBoundApplication.appInfo.packageName : null;
}"
2370,"@Override public void onCreate(){
  String processName=ActivityThread.currentPackageName();
  Slog.i(""String_Node_Str"",""String_Node_Str"" + processName);
  if (!getApplicationInfo().packageName.equals(processName)) {
    return;
  }
  final WindowManager wm=(WindowManager)getSystemService(Context.WINDOW_SERVICE);
  final Display display=wm.getDefaultDisplay();
  if (""String_Node_Str"".equals(android.os.Build.TYPE)) {
    AlertDialog.Builder builder=new AlertDialog.Builder(this);
    builder.setTitle(""String_Node_Str"");
    builder.setMessage(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    builder.setCancelable(false);
    builder.setPositiveButton(""String_Node_Str"",null);
    Dialog dialog=builder.create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    dialog.show();
  }
  FakeView view=new FakeView(this);
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
  if (ActivityManager.isHighEndGfx()) {
    lp.flags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
  }
  lp.width=ViewGroup.LayoutParams.MATCH_PARENT;
  lp.height=ViewGroup.LayoutParams.MATCH_PARENT;
  int maxSize=display.getMaximumSizeDimension();
  maxSize*=2;
  lp.x=maxSize;
  lp.y=maxSize;
  lp.setTitle(getPackageName());
  wm.addView(view,lp);
  bindService(new Intent(this,FakeCoreService.class),mServiceConnection,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService2.class),mServiceConnection2,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService3.class),mServiceConnection3,Context.BIND_AUTO_CREATE);
  mHandler.sendEmptyMessage(MSG_TICK);
  mStuffing=new int[STUFFING_SIZE_INTS];
  for (int i=0; i < STUFFING_SIZE_BYTES / PAGE_SIZE; i++) {
    final int VAL=i * 2 + 100;
    final int OFF=(i * PAGE_SIZE) / 4;
    for (int j=0; j < (PAGE_SIZE / 4); j++) {
      mStuffing[OFF + j]=VAL;
    }
  }
}","@Override public void onCreate(){
  String processName=ActivityThread.currentProcessName();
  Slog.i(""String_Node_Str"",""String_Node_Str"" + processName);
  if (!getApplicationInfo().packageName.equals(processName)) {
    return;
  }
  final WindowManager wm=(WindowManager)getSystemService(Context.WINDOW_SERVICE);
  final Display display=wm.getDefaultDisplay();
  if (""String_Node_Str"".equals(android.os.Build.TYPE)) {
    AlertDialog.Builder builder=new AlertDialog.Builder(this);
    builder.setTitle(""String_Node_Str"");
    builder.setMessage(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    builder.setCancelable(false);
    builder.setPositiveButton(""String_Node_Str"",null);
    Dialog dialog=builder.create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    dialog.show();
  }
  FakeView view=new FakeView(this);
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
  if (ActivityManager.isHighEndGfx()) {
    lp.flags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
  }
  lp.width=ViewGroup.LayoutParams.MATCH_PARENT;
  lp.height=ViewGroup.LayoutParams.MATCH_PARENT;
  int maxSize=display.getMaximumSizeDimension();
  maxSize*=2;
  lp.x=maxSize;
  lp.y=maxSize;
  lp.setTitle(getPackageName());
  wm.addView(view,lp);
  bindService(new Intent(this,FakeCoreService.class),mServiceConnection,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService2.class),mServiceConnection2,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService3.class),mServiceConnection3,Context.BIND_AUTO_CREATE);
  mHandler.sendEmptyMessage(MSG_TICK);
  mStuffing=new int[STUFFING_SIZE_INTS];
  for (int i=0; i < STUFFING_SIZE_BYTES / PAGE_SIZE; i++) {
    final int VAL=i * 2 + 100;
    final int OFF=(i * PAGE_SIZE) / 4;
    for (int j=0; j < (PAGE_SIZE / 4); j++) {
      mStuffing[OFF + j]=VAL;
    }
  }
}"
2371,"public static String currentPackageName(){
  ActivityThread am=currentActivityThread();
  return (am != null && am.mBoundApplication != null) ? am.mBoundApplication.processName : null;
}","public static String currentPackageName(){
  ActivityThread am=currentActivityThread();
  return (am != null && am.mBoundApplication != null) ? am.mBoundApplication.appInfo.packageName : null;
}"
2372,"@Override public void onCreate(){
  String processName=ActivityThread.currentPackageName();
  Slog.i(""String_Node_Str"",""String_Node_Str"" + processName);
  if (!getApplicationInfo().packageName.equals(processName)) {
    return;
  }
  final WindowManager wm=(WindowManager)getSystemService(Context.WINDOW_SERVICE);
  final Display display=wm.getDefaultDisplay();
  if (""String_Node_Str"".equals(android.os.Build.TYPE)) {
    AlertDialog.Builder builder=new AlertDialog.Builder(this);
    builder.setTitle(""String_Node_Str"");
    builder.setMessage(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    builder.setCancelable(false);
    builder.setPositiveButton(""String_Node_Str"",null);
    Dialog dialog=builder.create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    dialog.show();
  }
  FakeView view=new FakeView(this);
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
  if (ActivityManager.isHighEndGfx()) {
    lp.flags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
  }
  lp.width=ViewGroup.LayoutParams.MATCH_PARENT;
  lp.height=ViewGroup.LayoutParams.MATCH_PARENT;
  int maxSize=display.getMaximumSizeDimension();
  maxSize*=2;
  lp.x=maxSize;
  lp.y=maxSize;
  lp.setTitle(getPackageName());
  wm.addView(view,lp);
  bindService(new Intent(this,FakeCoreService.class),mServiceConnection,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService2.class),mServiceConnection2,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService3.class),mServiceConnection3,Context.BIND_AUTO_CREATE);
  mHandler.sendEmptyMessage(MSG_TICK);
  mStuffing=new int[STUFFING_SIZE_INTS];
  for (int i=0; i < STUFFING_SIZE_BYTES / PAGE_SIZE; i++) {
    final int VAL=i * 2 + 100;
    final int OFF=(i * PAGE_SIZE) / 4;
    for (int j=0; j < (PAGE_SIZE / 4); j++) {
      mStuffing[OFF + j]=VAL;
    }
  }
}","@Override public void onCreate(){
  String processName=ActivityThread.currentProcessName();
  Slog.i(""String_Node_Str"",""String_Node_Str"" + processName);
  if (!getApplicationInfo().packageName.equals(processName)) {
    return;
  }
  final WindowManager wm=(WindowManager)getSystemService(Context.WINDOW_SERVICE);
  final Display display=wm.getDefaultDisplay();
  if (""String_Node_Str"".equals(android.os.Build.TYPE)) {
    AlertDialog.Builder builder=new AlertDialog.Builder(this);
    builder.setTitle(""String_Node_Str"");
    builder.setMessage(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    builder.setCancelable(false);
    builder.setPositiveButton(""String_Node_Str"",null);
    Dialog dialog=builder.create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    dialog.show();
  }
  FakeView view=new FakeView(this);
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
  if (ActivityManager.isHighEndGfx()) {
    lp.flags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
  }
  lp.width=ViewGroup.LayoutParams.MATCH_PARENT;
  lp.height=ViewGroup.LayoutParams.MATCH_PARENT;
  int maxSize=display.getMaximumSizeDimension();
  maxSize*=2;
  lp.x=maxSize;
  lp.y=maxSize;
  lp.setTitle(getPackageName());
  wm.addView(view,lp);
  bindService(new Intent(this,FakeCoreService.class),mServiceConnection,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService2.class),mServiceConnection2,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService3.class),mServiceConnection3,Context.BIND_AUTO_CREATE);
  mHandler.sendEmptyMessage(MSG_TICK);
  mStuffing=new int[STUFFING_SIZE_INTS];
  for (int i=0; i < STUFFING_SIZE_BYTES / PAGE_SIZE; i++) {
    final int VAL=i * 2 + 100;
    final int OFF=(i * PAGE_SIZE) / 4;
    for (int j=0; j < (PAGE_SIZE / 4); j++) {
      mStuffing[OFF + j]=VAL;
    }
  }
}"
2373,"public static String currentPackageName(){
  ActivityThread am=currentActivityThread();
  return (am != null && am.mBoundApplication != null) ? am.mBoundApplication.processName : null;
}","public static String currentPackageName(){
  ActivityThread am=currentActivityThread();
  return (am != null && am.mBoundApplication != null) ? am.mBoundApplication.appInfo.packageName : null;
}"
2374,"@Override public void onCreate(){
  String processName=ActivityThread.currentPackageName();
  Slog.i(""String_Node_Str"",""String_Node_Str"" + processName);
  if (!getApplicationInfo().packageName.equals(processName)) {
    return;
  }
  final WindowManager wm=(WindowManager)getSystemService(Context.WINDOW_SERVICE);
  final Display display=wm.getDefaultDisplay();
  if (""String_Node_Str"".equals(android.os.Build.TYPE)) {
    AlertDialog.Builder builder=new AlertDialog.Builder(this);
    builder.setTitle(""String_Node_Str"");
    builder.setMessage(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    builder.setCancelable(false);
    builder.setPositiveButton(""String_Node_Str"",null);
    Dialog dialog=builder.create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    dialog.show();
  }
  FakeView view=new FakeView(this);
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
  if (ActivityManager.isHighEndGfx()) {
    lp.flags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
  }
  lp.width=ViewGroup.LayoutParams.MATCH_PARENT;
  lp.height=ViewGroup.LayoutParams.MATCH_PARENT;
  int maxSize=display.getMaximumSizeDimension();
  maxSize*=2;
  lp.x=maxSize;
  lp.y=maxSize;
  lp.setTitle(getPackageName());
  wm.addView(view,lp);
  bindService(new Intent(this,FakeCoreService.class),mServiceConnection,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService2.class),mServiceConnection2,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService3.class),mServiceConnection3,Context.BIND_AUTO_CREATE);
  mHandler.sendEmptyMessage(MSG_TICK);
  mStuffing=new int[STUFFING_SIZE_INTS];
  for (int i=0; i < STUFFING_SIZE_BYTES / PAGE_SIZE; i++) {
    final int VAL=i * 2 + 100;
    final int OFF=(i * PAGE_SIZE) / 4;
    for (int j=0; j < (PAGE_SIZE / 4); j++) {
      mStuffing[OFF + j]=VAL;
    }
  }
}","@Override public void onCreate(){
  String processName=ActivityThread.currentProcessName();
  Slog.i(""String_Node_Str"",""String_Node_Str"" + processName);
  if (!getApplicationInfo().packageName.equals(processName)) {
    return;
  }
  final WindowManager wm=(WindowManager)getSystemService(Context.WINDOW_SERVICE);
  final Display display=wm.getDefaultDisplay();
  if (""String_Node_Str"".equals(android.os.Build.TYPE)) {
    AlertDialog.Builder builder=new AlertDialog.Builder(this);
    builder.setTitle(""String_Node_Str"");
    builder.setMessage(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    builder.setCancelable(false);
    builder.setPositiveButton(""String_Node_Str"",null);
    Dialog dialog=builder.create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    dialog.show();
  }
  FakeView view=new FakeView(this);
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
  if (ActivityManager.isHighEndGfx()) {
    lp.flags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
  }
  lp.width=ViewGroup.LayoutParams.MATCH_PARENT;
  lp.height=ViewGroup.LayoutParams.MATCH_PARENT;
  int maxSize=display.getMaximumSizeDimension();
  maxSize*=2;
  lp.x=maxSize;
  lp.y=maxSize;
  lp.setTitle(getPackageName());
  wm.addView(view,lp);
  bindService(new Intent(this,FakeCoreService.class),mServiceConnection,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService2.class),mServiceConnection2,Context.BIND_AUTO_CREATE);
  bindService(new Intent(this,FakeCoreService3.class),mServiceConnection3,Context.BIND_AUTO_CREATE);
  mHandler.sendEmptyMessage(MSG_TICK);
  mStuffing=new int[STUFFING_SIZE_INTS];
  for (int i=0; i < STUFFING_SIZE_BYTES / PAGE_SIZE; i++) {
    final int VAL=i * 2 + 100;
    final int OFF=(i * PAGE_SIZE) / 4;
    for (int j=0; j < (PAGE_SIZE / 4); j++) {
      mStuffing[OFF + j]=VAL;
    }
  }
}"
2375,"/** 
 * Return the name of the activity that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  Youcan use this information to validate that the recipient is allowed to receive the data. <p>Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null. 
 * @return String The full name of the activity that will receive yourreply, or null if none.
 */
public ComponentName getCallingActivity(){
  try {
    return ActivityManagerNative.getDefault().getCallingActivity(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the name of the activity that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  Youcan use this information to validate that the recipient is allowed to receive the data. <p class=""note"">Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null. 
 * @return The ComponentName of the activity that will receive yourreply, or null if none.
 */
public ComponentName getCallingActivity(){
  try {
    return ActivityManagerNative.getDefault().getCallingActivity(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2376,"/** 
 * Return the name of the package that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  You canuse this information to validate that the recipient is allowed to receive the data. <p>Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null. 
 * @return The package of the activity that will receive yourreply, or null if none.
 */
public String getCallingPackage(){
  try {
    return ActivityManagerNative.getDefault().getCallingPackage(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the name of the package that invoked this activity.  This is who the data in   {@link #setResult setResult()} will be sent to.  You canuse this information to validate that the recipient is allowed to receive the data. <p class=""note"">Note: if the calling activity is not expecting a result (that is it did not use the  {@link #startActivityForResult} form that includes a request code), then the calling package will be  null.</p> <p class=""note"">Note: prior to  {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, the result from this method was unstable.  If the process hosting the calling package was no longer running, it would return null instead of the proper package name.  You can use   {@link #getCallingActivity()} and retrieve the package namefrom that instead.</p>
 * @return The package of the activity that will receive yourreply, or null if none.
 */
public String getCallingPackage(){
  try {
    return ActivityManagerNative.getDefault().getCallingPackage(mToken);
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2377,"public String getCallingPackage(IBinder token){
synchronized (this) {
    ActivityRecord r=getCallingRecordLocked(token);
    return r != null && r.app != null ? r.info.packageName : null;
  }
}","public String getCallingPackage(IBinder token){
synchronized (this) {
    ActivityRecord r=getCallingRecordLocked(token);
    return r != null ? r.info.packageName : null;
  }
}"
2378,"private boolean verifyPreloadConfig(TypedValue value,String name){
  if ((value.changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) != 0) {
    String resName;
    try {
      resName=getResourceName(value.resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(value.resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  return true;
}","private boolean verifyPreloadConfig(int changingConfigurations,int resourceId,String name){
  if (((changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) & VARYING_CONFIGS) != 0) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  return true;
}"
2379,"ColorStateList loadColorStateList(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  final long key=(((long)value.assetCookie) << 32) | value.data;
  ColorStateList csl;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    csl=sPreloadedColorStateLists.get(key);
    if (csl != null) {
      return csl;
    }
    csl=ColorStateList.valueOf(value.data);
    if (mPreloading) {
      if (verifyPreloadConfig(value,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
    return csl;
  }
  csl=getCachedColorStateList(key);
  if (csl != null) {
    return csl;
  }
  csl=sPreloadedColorStateLists.get(key);
  if (csl != null) {
    return csl;
  }
  if (value.string == null) {
    throw new NotFoundException(""String_Node_Str"" + value);
  }
  String file=value.string.toString();
  if (file.endsWith(""String_Node_Str"")) {
    try {
      XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
      csl=ColorStateList.createFromXml(this,rp);
      rp.close();
    }
 catch (    Exception e) {
      NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
      rnf.initCause(e);
      throw rnf;
    }
  }
 else {
    throw new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id)+ ""String_Node_Str"");
  }
  if (csl != null) {
    if (mPreloading) {
      if (verifyPreloadConfig(value,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
 else {
synchronized (mAccessLock) {
        mColorStateListCache.put(key,new WeakReference<ColorStateList>(csl));
      }
    }
  }
  return csl;
}","ColorStateList loadColorStateList(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  final long key=(((long)value.assetCookie) << 32) | value.data;
  ColorStateList csl;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    csl=sPreloadedColorStateLists.get(key);
    if (csl != null) {
      return csl;
    }
    csl=ColorStateList.valueOf(value.data);
    if (mPreloading) {
      if (verifyPreloadConfig(value.changingConfigurations,value.resourceId,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
    return csl;
  }
  csl=getCachedColorStateList(key);
  if (csl != null) {
    return csl;
  }
  csl=sPreloadedColorStateLists.get(key);
  if (csl != null) {
    return csl;
  }
  if (value.string == null) {
    throw new NotFoundException(""String_Node_Str"" + value);
  }
  String file=value.string.toString();
  if (file.endsWith(""String_Node_Str"")) {
    try {
      XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
      csl=ColorStateList.createFromXml(this,rp);
      rp.close();
    }
 catch (    Exception e) {
      NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
      rnf.initCause(e);
      throw rnf;
    }
  }
 else {
    throw new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id)+ ""String_Node_Str"");
  }
  if (csl != null) {
    if (mPreloading) {
      if (verifyPreloadConfig(value.changingConfigurations,value.resourceId,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
 else {
synchronized (mAccessLock) {
        mColorStateListCache.put(key,new WeakReference<ColorStateList>(csl));
      }
    }
  }
  return csl;
}"
2380,"Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
 else {
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(value,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables.put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}","Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
 else {
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(cs.getChangingConfigurations(),value.resourceId,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables.put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}"
2381,"@Override public int getChangingConfigurations(){
  return mChangingConfigurations;
}","@Override public int getChangingConfigurations(){
  return mChangingConfigurations | mChildrenChangingConfigurations;
}"
2382,"private boolean verifyPreloadConfig(TypedValue value,String name){
  if ((value.changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) != 0) {
    String resName;
    try {
      resName=getResourceName(value.resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(value.resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  return true;
}","private boolean verifyPreloadConfig(int changingConfigurations,int resourceId,String name){
  if (((changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) & VARYING_CONFIGS) != 0) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  return true;
}"
2383,"ColorStateList loadColorStateList(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  final long key=(((long)value.assetCookie) << 32) | value.data;
  ColorStateList csl;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    csl=sPreloadedColorStateLists.get(key);
    if (csl != null) {
      return csl;
    }
    csl=ColorStateList.valueOf(value.data);
    if (mPreloading) {
      if (verifyPreloadConfig(value,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
    return csl;
  }
  csl=getCachedColorStateList(key);
  if (csl != null) {
    return csl;
  }
  csl=sPreloadedColorStateLists.get(key);
  if (csl != null) {
    return csl;
  }
  if (value.string == null) {
    throw new NotFoundException(""String_Node_Str"" + value);
  }
  String file=value.string.toString();
  if (file.endsWith(""String_Node_Str"")) {
    try {
      XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
      csl=ColorStateList.createFromXml(this,rp);
      rp.close();
    }
 catch (    Exception e) {
      NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
      rnf.initCause(e);
      throw rnf;
    }
  }
 else {
    throw new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id)+ ""String_Node_Str"");
  }
  if (csl != null) {
    if (mPreloading) {
      if (verifyPreloadConfig(value,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
 else {
synchronized (mAccessLock) {
        mColorStateListCache.put(key,new WeakReference<ColorStateList>(csl));
      }
    }
  }
  return csl;
}","ColorStateList loadColorStateList(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  final long key=(((long)value.assetCookie) << 32) | value.data;
  ColorStateList csl;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    csl=sPreloadedColorStateLists.get(key);
    if (csl != null) {
      return csl;
    }
    csl=ColorStateList.valueOf(value.data);
    if (mPreloading) {
      if (verifyPreloadConfig(value.changingConfigurations,value.resourceId,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
    return csl;
  }
  csl=getCachedColorStateList(key);
  if (csl != null) {
    return csl;
  }
  csl=sPreloadedColorStateLists.get(key);
  if (csl != null) {
    return csl;
  }
  if (value.string == null) {
    throw new NotFoundException(""String_Node_Str"" + value);
  }
  String file=value.string.toString();
  if (file.endsWith(""String_Node_Str"")) {
    try {
      XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
      csl=ColorStateList.createFromXml(this,rp);
      rp.close();
    }
 catch (    Exception e) {
      NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
      rnf.initCause(e);
      throw rnf;
    }
  }
 else {
    throw new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id)+ ""String_Node_Str"");
  }
  if (csl != null) {
    if (mPreloading) {
      if (verifyPreloadConfig(value.changingConfigurations,value.resourceId,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
 else {
synchronized (mAccessLock) {
        mColorStateListCache.put(key,new WeakReference<ColorStateList>(csl));
      }
    }
  }
  return csl;
}"
2384,"Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
 else {
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(value,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables.put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}","Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
 else {
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(cs.getChangingConfigurations(),value.resourceId,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables.put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}"
2385,"@Override public int getChangingConfigurations(){
  return mChangingConfigurations;
}","@Override public int getChangingConfigurations(){
  return mChangingConfigurations | mChildrenChangingConfigurations;
}"
2386,"public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  Context userContext=null;
  try {
    final String packageName=""String_Node_Str"";
    userContext=mContext.createPackageContextAsUser(packageName,0,new UserHandle(mUserId));
  }
 catch (  NameNotFoundException e) {
    e.printStackTrace();
    userContext=context;
  }
  mAppWidgetHost=new AppWidgetHost(userContext,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(userContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  getInitialTransportState();
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}","public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  if (DEBUG)   Log.e(TAG,""String_Node_Str"");
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  Context userContext=null;
  try {
    final String packageName=""String_Node_Str"";
    userContext=mContext.createPackageContextAsUser(packageName,0,new UserHandle(mUserId));
  }
 catch (  NameNotFoundException e) {
    e.printStackTrace();
    userContext=context;
  }
  mAppWidgetHost=new AppWidgetHost(userContext,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(userContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  getInitialTransportState();
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}"
2387,"private void ensureTransportPresentOrRemoved(int state){
  int page=getWidgetPosition(R.id.keyguard_transport_control);
  if (state == TRANSPORT_INVISIBLE || state == TRANSPORT_VISIBLE) {
    if (page == -1) {
      if (DEBUGXPORT)       Log.v(TAG,""String_Node_Str"");
      int lastWidget=mAppWidgetContainer.getChildCount() - 1;
      int position=0;
      if (lastWidget >= 0) {
        position=mAppWidgetContainer.isCameraPage(lastWidget) ? lastWidget : lastWidget + 1;
      }
      mAppWidgetContainer.addWidget(getTransportControlView(),position);
    }
  }
 else   if (page != -1) {
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    mAppWidgetContainer.removeWidget(getTransportControlView());
    mTransportControl=null;
  }
}","/** 
 * Examines the current state and adds the transport to the widget pager when the state changes. Showing the initial transport and keeping it around is a bit tricky because the signals coming from music players aren't always clear. Here's how the states are handled:  {@link TRANSPORT_GONE} means we have no reason to show the transport - remove it if present.{@link TRANSPORT_INVISIBLE} means we have potential to show the transport because a musicplayer is registered but not currently playing music (or we don't know the state yet). The code adds it conditionally on play state. {@link #TRANSPORT_VISIBLE} means a music player is active and transport should be showing.Once the transport is showing, we always show it until keyguard is dismissed. This state is maintained by onSave/RestoreInstanceState(). This state is cleared in {@link KeyguardViewManager#hide} when keyguard is dismissed, which causes the transport to begone when keyguard is restarted until we get an update with the current state.
 * @param state
 */
private void ensureTransportPresentOrRemoved(int state){
  final boolean showing=getWidgetPosition(R.id.keyguard_transport_control) != -1;
  final boolean visible=state == TRANSPORT_VISIBLE;
  final boolean shouldBeVisible=state == TRANSPORT_INVISIBLE && isMusicPlaying(state);
  if (!showing && (visible || shouldBeVisible)) {
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    int lastWidget=mAppWidgetContainer.getChildCount() - 1;
    int position=0;
    if (lastWidget >= 0) {
      position=mAppWidgetContainer.isCameraPage(lastWidget) ? lastWidget : lastWidget + 1;
    }
    mAppWidgetContainer.addWidget(getOrCreateTransportControl(),position);
  }
 else   if (showing && state == TRANSPORT_GONE) {
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    mAppWidgetContainer.removeWidget(getOrCreateTransportControl());
    mTransportControl=null;
  }
}"
2388,"private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  mPlaybackState=dcs.playbackState;
}","private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  mPlaybackState=dcs.playbackState;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + mTransportState + ""String_Node_Str""+ mPlaybackState);
}"
2389,"@Override public Parcelable onSaveInstanceState(){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  ss.transportState=mTransportState;
  ss.appWidgetToShow=mAppWidgetToShow;
  return ss;
}","@Override public Parcelable onSaveInstanceState(){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mTransportState);
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  final boolean showing=mTransportControl != null && mAppWidgetContainer.getWidgetPageIndex(mTransportControl) >= 0;
  ss.transportState=showing ? TRANSPORT_VISIBLE : mTransportState;
  ss.appWidgetToShow=mAppWidgetToShow;
  return ss;
}"
2390,"private int getAppropriateWidgetPage(int musicTransportState){
  if (mAppWidgetToShow != AppWidgetManager.INVALID_APPWIDGET_ID) {
    final int childCount=mAppWidgetContainer.getChildCount();
    for (int i=0; i < childCount; i++) {
      if (mAppWidgetContainer.getWidgetPageAt(i).getContentAppWidgetId() == mAppWidgetToShow) {
        return i;
      }
    }
    mAppWidgetToShow=AppWidgetManager.INVALID_APPWIDGET_ID;
  }
  if (musicTransportState == TRANSPORT_VISIBLE) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    return mAppWidgetContainer.getWidgetPageIndex(getTransportControlView());
  }
  int rightMost=mAppWidgetContainer.getChildCount() - 1;
  if (mAppWidgetContainer.isCameraPage(rightMost)) {
    rightMost--;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + rightMost);
  return rightMost;
}","private int getAppropriateWidgetPage(int musicTransportState){
  if (mAppWidgetToShow != AppWidgetManager.INVALID_APPWIDGET_ID) {
    final int childCount=mAppWidgetContainer.getChildCount();
    for (int i=0; i < childCount; i++) {
      if (mAppWidgetContainer.getWidgetPageAt(i).getContentAppWidgetId() == mAppWidgetToShow) {
        return i;
      }
    }
    mAppWidgetToShow=AppWidgetManager.INVALID_APPWIDGET_ID;
  }
  if (musicTransportState == TRANSPORT_VISIBLE) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    return mAppWidgetContainer.getWidgetPageIndex(getOrCreateTransportControl());
  }
  int rightMost=mAppWidgetContainer.getChildCount() - 1;
  if (mAppWidgetContainer.isCameraPage(rightMost)) {
    rightMost--;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + rightMost);
  return rightMost;
}"
2391,"@Override public void onRestoreInstanceState(Parcelable state){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  if (!(state instanceof SavedState)) {
    super.onRestoreInstanceState(state);
    return;
  }
  SavedState ss=(SavedState)state;
  super.onRestoreInstanceState(ss.getSuperState());
  mTransportState=(ss.transportState);
  mAppWidgetToShow=ss.appWidgetToShow;
  post(mSwitchPageRunnable);
}","@Override public void onRestoreInstanceState(Parcelable state){
  if (!(state instanceof SavedState)) {
    super.onRestoreInstanceState(state);
    return;
  }
  SavedState ss=(SavedState)state;
  super.onRestoreInstanceState(ss.getSuperState());
  mTransportState=(ss.transportState);
  mAppWidgetToShow=ss.appWidgetToShow;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mTransportState);
  post(mSwitchPageRunnable);
}"
2392,"protected void handleSetPlaybackState(int generationId,int playbackState,long eventTime){
  if (generationId == mDisplayClientState.clientGeneration) {
    for (int i=0; i < mCallbacks.size(); i++) {
      KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
      if (cb != null) {
        cb.onMusicPlaybackStateChanged(playbackState,eventTime);
      }
    }
  }
 else {
    Log.w(TAG,""String_Node_Str"" + generationId + ""String_Node_Str"");
  }
}","protected void handleSetPlaybackState(int generationId,int playbackState,long eventTime){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + generationId + ""String_Node_Str""+ playbackState+ ""String_Node_Str""+ eventTime+ ""String_Node_Str"");
  mDisplayClientState.playbackState=playbackState;
  mDisplayClientState.playbackEventTime=eventTime;
  if (generationId == mDisplayClientState.clientGeneration) {
    for (int i=0; i < mCallbacks.size(); i++) {
      KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
      if (cb != null) {
        cb.onMusicPlaybackStateChanged(playbackState,eventTime);
      }
    }
  }
 else {
    Log.w(TAG,""String_Node_Str"" + generationId + ""String_Node_Str"");
  }
}"
2393,"protected void handleSetGenerationId(int clientGeneration,boolean clearing,PendingIntent p){
  mDisplayClientState.clientGeneration=clientGeneration;
  mDisplayClientState.clearing=clearing;
  mDisplayClientState.intent=p;
  for (int i=0; i < mCallbacks.size(); i++) {
    KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
    if (cb != null) {
      cb.onMusicClientIdChanged(clientGeneration,clearing,p);
    }
  }
}","protected void handleSetGenerationId(int clientGeneration,boolean clearing,PendingIntent p){
  mDisplayClientState.clientGeneration=clientGeneration;
  mDisplayClientState.clearing=clearing;
  mDisplayClientState.intent=p;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + clientGeneration + ""String_Node_Str""+ clearing+ ""String_Node_Str"");
  for (int i=0; i < mCallbacks.size(); i++) {
    KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
    if (cb != null) {
      cb.onMusicClientIdChanged(clientGeneration,clearing,p);
    }
  }
}"
2394,"/** 
 * Send message to keyguard telling it to reset its state.
 * @param options options about how to show the keyguard
 * @see #handleReset()
 */
private void resetStateLocked(Bundle options){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  Message msg=mHandler.obtainMessage(RESET,options);
  mHandler.sendMessage(msg);
}","/** 
 * Send message to keyguard telling it to reset its state.
 * @param options options about how to show the keyguard
 * @see #handleReset()
 */
private void resetStateLocked(Bundle options){
  if (DEBUG)   Log.e(TAG,""String_Node_Str"");
  Message msg=mHandler.obtainMessage(RESET,options);
  mHandler.sendMessage(msg);
}"
2395,"private void handleActionMove(MotionEvent event){
  final int historySize=event.getHistorySize();
  Rect invalidateRect=mInvalidate;
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float startX=getCenterXForColumn(lastCell.column);
      float startY=getCenterYForRow(lastCell.row);
      final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
      float left=Math.min(startX,x) - radius;
      float right=Math.max(startX,x) + radius;
      float top=Math.min(startY,y) - radius;
      float bottom=Math.max(startY,y) + radius;
      if (hitCell != null && patternSize >= 2) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float x2=getCenterXForColumn(hitCell.column);
        final float y2=getCenterYForRow(hitCell.row);
        left=Math.min(x2,left - width);
        right=Math.max(x2,right + width);
        top=Math.min(y2,top - height);
        bottom=Math.max(y2,bottom + height);
      }
      invalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    invalidate(invalidateRect);
    invalidateRect.setEmpty();
  }
}","private void handleActionMove(MotionEvent event){
  final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
  final int historySize=event.getHistorySize();
  mTmpInvalidateRect.setEmpty();
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float lastCellCenterX=getCenterXForColumn(lastCell.column);
      float lastCellCenterY=getCenterYForRow(lastCell.row);
      float left=Math.min(lastCellCenterX,x) - radius;
      float right=Math.max(lastCellCenterX,x) + radius;
      float top=Math.min(lastCellCenterY,y) - radius;
      float bottom=Math.max(lastCellCenterY,y) + radius;
      if (hitCell != null) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float hitCellCenterX=getCenterXForColumn(hitCell.column);
        final float hitCellCenterY=getCenterYForRow(hitCell.row);
        left=Math.min(hitCellCenterX - width,left);
        right=Math.max(hitCellCenterX + width,right);
        top=Math.min(hitCellCenterY - height,top);
        bottom=Math.max(hitCellCenterY + height,bottom);
      }
      mTmpInvalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    mInvalidate.union(mTmpInvalidateRect);
    invalidate(mInvalidate);
    mInvalidate.set(mTmpInvalidateRect);
  }
}"
2396,"private void handleActionMove(MotionEvent event){
  final int historySize=event.getHistorySize();
  Rect invalidateRect=mInvalidate;
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float startX=getCenterXForColumn(lastCell.column);
      float startY=getCenterYForRow(lastCell.row);
      final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
      float left=Math.min(startX,x) - radius;
      float right=Math.max(startX,x) + radius;
      float top=Math.min(startY,y) - radius;
      float bottom=Math.max(startY,y) + radius;
      if (hitCell != null && patternSize >= 2) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float x2=getCenterXForColumn(hitCell.column);
        final float y2=getCenterYForRow(hitCell.row);
        left=Math.min(x2,left - width);
        right=Math.max(x2,right + width);
        top=Math.min(y2,top - height);
        bottom=Math.max(y2,bottom + height);
      }
      invalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    invalidate(invalidateRect);
    invalidateRect.setEmpty();
  }
}","private void handleActionMove(MotionEvent event){
  final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
  final int historySize=event.getHistorySize();
  mTmpInvalidateRect.setEmpty();
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float lastCellCenterX=getCenterXForColumn(lastCell.column);
      float lastCellCenterY=getCenterYForRow(lastCell.row);
      float left=Math.min(lastCellCenterX,x) - radius;
      float right=Math.max(lastCellCenterX,x) + radius;
      float top=Math.min(lastCellCenterY,y) - radius;
      float bottom=Math.max(lastCellCenterY,y) + radius;
      if (hitCell != null) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float hitCellCenterX=getCenterXForColumn(hitCell.column);
        final float hitCellCenterY=getCenterYForRow(hitCell.row);
        left=Math.min(hitCellCenterX - width,left);
        right=Math.max(hitCellCenterX + width,right);
        top=Math.min(hitCellCenterY - height,top);
        bottom=Math.max(hitCellCenterY + height,bottom);
      }
      mTmpInvalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    mInvalidate.union(mTmpInvalidateRect);
    invalidate(mInvalidate);
    mInvalidate.set(mTmpInvalidateRect);
  }
}"
2397,"private void handleActionMove(MotionEvent event){
  final int historySize=event.getHistorySize();
  Rect invalidateRect=mInvalidate;
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float startX=getCenterXForColumn(lastCell.column);
      float startY=getCenterYForRow(lastCell.row);
      final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
      float left=Math.min(startX,x) - radius;
      float right=Math.max(startX,x) + radius;
      float top=Math.min(startY,y) - radius;
      float bottom=Math.max(startY,y) + radius;
      if (hitCell != null && patternSize >= 2) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float x2=getCenterXForColumn(hitCell.column);
        final float y2=getCenterYForRow(hitCell.row);
        left=Math.min(x2,left - width);
        right=Math.max(x2,right + width);
        top=Math.min(y2,top - height);
        bottom=Math.max(y2,bottom + height);
      }
      invalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    invalidate(invalidateRect);
    invalidateRect.setEmpty();
  }
}","private void handleActionMove(MotionEvent event){
  final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
  final int historySize=event.getHistorySize();
  mTmpInvalidateRect.setEmpty();
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float lastCellCenterX=getCenterXForColumn(lastCell.column);
      float lastCellCenterY=getCenterYForRow(lastCell.row);
      float left=Math.min(lastCellCenterX,x) - radius;
      float right=Math.max(lastCellCenterX,x) + radius;
      float top=Math.min(lastCellCenterY,y) - radius;
      float bottom=Math.max(lastCellCenterY,y) + radius;
      if (hitCell != null) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float hitCellCenterX=getCenterXForColumn(hitCell.column);
        final float hitCellCenterY=getCenterYForRow(hitCell.row);
        left=Math.min(hitCellCenterX - width,left);
        right=Math.max(hitCellCenterX + width,right);
        top=Math.min(hitCellCenterY - height,top);
        bottom=Math.max(hitCellCenterY + height,bottom);
      }
      mTmpInvalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    mInvalidate.union(mTmpInvalidateRect);
    invalidate(mInvalidate);
    mInvalidate.set(mTmpInvalidateRect);
  }
}"
2398,"public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  Context userContext=null;
  try {
    final String packageName=""String_Node_Str"";
    userContext=mContext.createPackageContextAsUser(packageName,0,new UserHandle(mUserId));
  }
 catch (  NameNotFoundException e) {
    e.printStackTrace();
    userContext=context;
  }
  mAppWidgetHost=new AppWidgetHost(userContext,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(userContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  getInitialTransportState();
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}","public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  if (DEBUG)   Log.e(TAG,""String_Node_Str"");
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  Context userContext=null;
  try {
    final String packageName=""String_Node_Str"";
    userContext=mContext.createPackageContextAsUser(packageName,0,new UserHandle(mUserId));
  }
 catch (  NameNotFoundException e) {
    e.printStackTrace();
    userContext=context;
  }
  mAppWidgetHost=new AppWidgetHost(userContext,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(userContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  getInitialTransportState();
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}"
2399,"private void ensureTransportPresentOrRemoved(int state){
  int page=getWidgetPosition(R.id.keyguard_transport_control);
  if (state == TRANSPORT_INVISIBLE || state == TRANSPORT_VISIBLE) {
    if (page == -1) {
      if (DEBUGXPORT)       Log.v(TAG,""String_Node_Str"");
      int lastWidget=mAppWidgetContainer.getChildCount() - 1;
      int position=0;
      if (lastWidget >= 0) {
        position=mAppWidgetContainer.isCameraPage(lastWidget) ? lastWidget : lastWidget + 1;
      }
      mAppWidgetContainer.addWidget(getTransportControlView(),position);
    }
  }
 else   if (page != -1) {
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    mAppWidgetContainer.removeWidget(getTransportControlView());
    mTransportControl=null;
  }
}","/** 
 * Examines the current state and adds the transport to the widget pager when the state changes. Showing the initial transport and keeping it around is a bit tricky because the signals coming from music players aren't always clear. Here's how the states are handled:  {@link TRANSPORT_GONE} means we have no reason to show the transport - remove it if present.{@link TRANSPORT_INVISIBLE} means we have potential to show the transport because a musicplayer is registered but not currently playing music (or we don't know the state yet). The code adds it conditionally on play state. {@link #TRANSPORT_VISIBLE} means a music player is active and transport should be showing.Once the transport is showing, we always show it until keyguard is dismissed. This state is maintained by onSave/RestoreInstanceState(). This state is cleared in {@link KeyguardViewManager#hide} when keyguard is dismissed, which causes the transport to begone when keyguard is restarted until we get an update with the current state.
 * @param state
 */
private void ensureTransportPresentOrRemoved(int state){
  final boolean showing=getWidgetPosition(R.id.keyguard_transport_control) != -1;
  final boolean visible=state == TRANSPORT_VISIBLE;
  final boolean shouldBeVisible=state == TRANSPORT_INVISIBLE && isMusicPlaying(state);
  if (!showing && (visible || shouldBeVisible)) {
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    int lastWidget=mAppWidgetContainer.getChildCount() - 1;
    int position=0;
    if (lastWidget >= 0) {
      position=mAppWidgetContainer.isCameraPage(lastWidget) ? lastWidget : lastWidget + 1;
    }
    mAppWidgetContainer.addWidget(getOrCreateTransportControl(),position);
  }
 else   if (showing && state == TRANSPORT_GONE) {
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    mAppWidgetContainer.removeWidget(getOrCreateTransportControl());
    mTransportControl=null;
  }
}"
2400,"private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  mPlaybackState=dcs.playbackState;
}","private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  mPlaybackState=dcs.playbackState;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + mTransportState + ""String_Node_Str""+ mPlaybackState);
}"
2401,"@Override public Parcelable onSaveInstanceState(){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  ss.transportState=mTransportState;
  ss.appWidgetToShow=mAppWidgetToShow;
  return ss;
}","@Override public Parcelable onSaveInstanceState(){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mTransportState);
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  final boolean showing=mTransportControl != null && mAppWidgetContainer.getWidgetPageIndex(mTransportControl) >= 0;
  ss.transportState=showing ? TRANSPORT_VISIBLE : mTransportState;
  ss.appWidgetToShow=mAppWidgetToShow;
  return ss;
}"
2402,"private int getAppropriateWidgetPage(int musicTransportState){
  if (mAppWidgetToShow != AppWidgetManager.INVALID_APPWIDGET_ID) {
    final int childCount=mAppWidgetContainer.getChildCount();
    for (int i=0; i < childCount; i++) {
      if (mAppWidgetContainer.getWidgetPageAt(i).getContentAppWidgetId() == mAppWidgetToShow) {
        return i;
      }
    }
    mAppWidgetToShow=AppWidgetManager.INVALID_APPWIDGET_ID;
  }
  if (musicTransportState == TRANSPORT_VISIBLE) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    return mAppWidgetContainer.getWidgetPageIndex(getTransportControlView());
  }
  int rightMost=mAppWidgetContainer.getChildCount() - 1;
  if (mAppWidgetContainer.isCameraPage(rightMost)) {
    rightMost--;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + rightMost);
  return rightMost;
}","private int getAppropriateWidgetPage(int musicTransportState){
  if (mAppWidgetToShow != AppWidgetManager.INVALID_APPWIDGET_ID) {
    final int childCount=mAppWidgetContainer.getChildCount();
    for (int i=0; i < childCount; i++) {
      if (mAppWidgetContainer.getWidgetPageAt(i).getContentAppWidgetId() == mAppWidgetToShow) {
        return i;
      }
    }
    mAppWidgetToShow=AppWidgetManager.INVALID_APPWIDGET_ID;
  }
  if (musicTransportState == TRANSPORT_VISIBLE) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    return mAppWidgetContainer.getWidgetPageIndex(getOrCreateTransportControl());
  }
  int rightMost=mAppWidgetContainer.getChildCount() - 1;
  if (mAppWidgetContainer.isCameraPage(rightMost)) {
    rightMost--;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + rightMost);
  return rightMost;
}"
2403,"@Override public void onRestoreInstanceState(Parcelable state){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  if (!(state instanceof SavedState)) {
    super.onRestoreInstanceState(state);
    return;
  }
  SavedState ss=(SavedState)state;
  super.onRestoreInstanceState(ss.getSuperState());
  mTransportState=(ss.transportState);
  mAppWidgetToShow=ss.appWidgetToShow;
  post(mSwitchPageRunnable);
}","@Override public void onRestoreInstanceState(Parcelable state){
  if (!(state instanceof SavedState)) {
    super.onRestoreInstanceState(state);
    return;
  }
  SavedState ss=(SavedState)state;
  super.onRestoreInstanceState(ss.getSuperState());
  mTransportState=(ss.transportState);
  mAppWidgetToShow=ss.appWidgetToShow;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mTransportState);
  post(mSwitchPageRunnable);
}"
2404,"protected void handleSetPlaybackState(int generationId,int playbackState,long eventTime){
  if (generationId == mDisplayClientState.clientGeneration) {
    for (int i=0; i < mCallbacks.size(); i++) {
      KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
      if (cb != null) {
        cb.onMusicPlaybackStateChanged(playbackState,eventTime);
      }
    }
  }
 else {
    Log.w(TAG,""String_Node_Str"" + generationId + ""String_Node_Str"");
  }
}","protected void handleSetPlaybackState(int generationId,int playbackState,long eventTime){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + generationId + ""String_Node_Str""+ playbackState+ ""String_Node_Str""+ eventTime+ ""String_Node_Str"");
  mDisplayClientState.playbackState=playbackState;
  mDisplayClientState.playbackEventTime=eventTime;
  if (generationId == mDisplayClientState.clientGeneration) {
    for (int i=0; i < mCallbacks.size(); i++) {
      KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
      if (cb != null) {
        cb.onMusicPlaybackStateChanged(playbackState,eventTime);
      }
    }
  }
 else {
    Log.w(TAG,""String_Node_Str"" + generationId + ""String_Node_Str"");
  }
}"
2405,"protected void handleSetGenerationId(int clientGeneration,boolean clearing,PendingIntent p){
  mDisplayClientState.clientGeneration=clientGeneration;
  mDisplayClientState.clearing=clearing;
  mDisplayClientState.intent=p;
  for (int i=0; i < mCallbacks.size(); i++) {
    KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
    if (cb != null) {
      cb.onMusicClientIdChanged(clientGeneration,clearing,p);
    }
  }
}","protected void handleSetGenerationId(int clientGeneration,boolean clearing,PendingIntent p){
  mDisplayClientState.clientGeneration=clientGeneration;
  mDisplayClientState.clearing=clearing;
  mDisplayClientState.intent=p;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + clientGeneration + ""String_Node_Str""+ clearing+ ""String_Node_Str"");
  for (int i=0; i < mCallbacks.size(); i++) {
    KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
    if (cb != null) {
      cb.onMusicClientIdChanged(clientGeneration,clearing,p);
    }
  }
}"
2406,"/** 
 * Send message to keyguard telling it to reset its state.
 * @param options options about how to show the keyguard
 * @see #handleReset()
 */
private void resetStateLocked(Bundle options){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  Message msg=mHandler.obtainMessage(RESET,options);
  mHandler.sendMessage(msg);
}","/** 
 * Send message to keyguard telling it to reset its state.
 * @param options options about how to show the keyguard
 * @see #handleReset()
 */
private void resetStateLocked(Bundle options){
  if (DEBUG)   Log.e(TAG,""String_Node_Str"");
  Message msg=mHandler.obtainMessage(RESET,options);
  mHandler.sendMessage(msg);
}"
2407,"private boolean verifyPreloadConfig(TypedValue value,String name){
  if ((value.changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) != 0) {
    String resName;
    try {
      resName=getResourceName(value.resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(value.resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  return true;
}","private boolean verifyPreloadConfig(int changingConfigurations,int resourceId,String name){
  if (((changingConfigurations & ~(ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_DENSITY)) & VARYING_CONFIGS) != 0) {
    String resName;
    try {
      resName=getResourceName(resourceId);
    }
 catch (    NotFoundException e) {
      resName=""String_Node_Str"";
    }
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ Integer.toHexString(resourceId)+ ""String_Node_Str""+ resName+ ""String_Node_Str"");
    return false;
  }
  return true;
}"
2408,"ColorStateList loadColorStateList(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  final long key=(((long)value.assetCookie) << 32) | value.data;
  ColorStateList csl;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    csl=sPreloadedColorStateLists.get(key);
    if (csl != null) {
      return csl;
    }
    csl=ColorStateList.valueOf(value.data);
    if (mPreloading) {
      if (verifyPreloadConfig(value,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
    return csl;
  }
  csl=getCachedColorStateList(key);
  if (csl != null) {
    return csl;
  }
  csl=sPreloadedColorStateLists.get(key);
  if (csl != null) {
    return csl;
  }
  if (value.string == null) {
    throw new NotFoundException(""String_Node_Str"" + value);
  }
  String file=value.string.toString();
  if (file.endsWith(""String_Node_Str"")) {
    try {
      XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
      csl=ColorStateList.createFromXml(this,rp);
      rp.close();
    }
 catch (    Exception e) {
      NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
      rnf.initCause(e);
      throw rnf;
    }
  }
 else {
    throw new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id)+ ""String_Node_Str"");
  }
  if (csl != null) {
    if (mPreloading) {
      if (verifyPreloadConfig(value,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
 else {
synchronized (mAccessLock) {
        mColorStateListCache.put(key,new WeakReference<ColorStateList>(csl));
      }
    }
  }
  return csl;
}","ColorStateList loadColorStateList(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  final long key=(((long)value.assetCookie) << 32) | value.data;
  ColorStateList csl;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    csl=sPreloadedColorStateLists.get(key);
    if (csl != null) {
      return csl;
    }
    csl=ColorStateList.valueOf(value.data);
    if (mPreloading) {
      if (verifyPreloadConfig(value.changingConfigurations,value.resourceId,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
    return csl;
  }
  csl=getCachedColorStateList(key);
  if (csl != null) {
    return csl;
  }
  csl=sPreloadedColorStateLists.get(key);
  if (csl != null) {
    return csl;
  }
  if (value.string == null) {
    throw new NotFoundException(""String_Node_Str"" + value);
  }
  String file=value.string.toString();
  if (file.endsWith(""String_Node_Str"")) {
    try {
      XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
      csl=ColorStateList.createFromXml(this,rp);
      rp.close();
    }
 catch (    Exception e) {
      NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
      rnf.initCause(e);
      throw rnf;
    }
  }
 else {
    throw new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id)+ ""String_Node_Str"");
  }
  if (csl != null) {
    if (mPreloading) {
      if (verifyPreloadConfig(value.changingConfigurations,value.resourceId,""String_Node_Str"")) {
        sPreloadedColorStateLists.put(key,csl);
      }
    }
 else {
synchronized (mAccessLock) {
        mColorStateListCache.put(key,new WeakReference<ColorStateList>(csl));
      }
    }
  }
  return csl;
}"
2409,"Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
 else {
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(value,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables.put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}","Drawable loadDrawable(TypedValue value,int id) throws NotFoundException {
  if (TRACE_FOR_PRELOAD) {
    if ((id >>> 24) == 0x1) {
      final String name=getResourceName(id);
      if (name != null)       android.util.Log.d(""String_Node_Str"",name);
    }
  }
  boolean isColorDrawable=false;
  if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
    isColorDrawable=true;
  }
  final long key=isColorDrawable ? value.data : (((long)value.assetCookie) << 32) | value.data;
  Drawable dr=getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache,key);
  if (dr != null) {
    return dr;
  }
  Drawable.ConstantState cs=isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
  if (cs != null) {
    dr=cs.newDrawable(this);
  }
 else {
    if (isColorDrawable) {
      dr=new ColorDrawable(value.data);
    }
    if (dr == null) {
      if (value.string == null) {
        throw new NotFoundException(""String_Node_Str"" + value);
      }
      String file=value.string.toString();
      if (TRACE_FOR_MISS_PRELOAD) {
        if ((id >>> 24) == 0x1) {
          final String name=getResourceName(id);
          if (name != null)           android.util.Log.d(TAG,""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ name+ ""String_Node_Str""+ file);
        }
      }
      if (DEBUG_LOAD)       Log.v(TAG,""String_Node_Str"" + value.assetCookie + ""String_Node_Str""+ file);
      if (file.endsWith(""String_Node_Str"")) {
        try {
          XmlResourceParser rp=loadXmlResourceParser(file,id,value.assetCookie,""String_Node_Str"");
          dr=Drawable.createFromXml(this,rp);
          rp.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
 else {
        try {
          InputStream is=mAssets.openNonAsset(value.assetCookie,file,AssetManager.ACCESS_STREAMING);
          dr=Drawable.createFromResourceStream(this,value,is,file,null);
          is.close();
        }
 catch (        Exception e) {
          NotFoundException rnf=new NotFoundException(""String_Node_Str"" + file + ""String_Node_Str""+ Integer.toHexString(id));
          rnf.initCause(e);
          throw rnf;
        }
      }
    }
  }
  if (dr != null) {
    dr.setChangingConfigurations(value.changingConfigurations);
    cs=dr.getConstantState();
    if (cs != null) {
      if (mPreloading) {
        if (verifyPreloadConfig(cs.getChangingConfigurations(),value.resourceId,""String_Node_Str"")) {
          if (isColorDrawable) {
            sPreloadedColorDrawables.put(key,cs);
          }
 else {
            sPreloadedDrawables.put(key,cs);
          }
        }
      }
 else {
synchronized (mAccessLock) {
          if (isColorDrawable) {
            mColorDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
 else {
            mDrawableCache.put(key,new WeakReference<Drawable.ConstantState>(cs));
          }
        }
      }
    }
  }
  return dr;
}"
2410,"@Override public int getChangingConfigurations(){
  return mChangingConfigurations;
}","@Override public int getChangingConfigurations(){
  return mChangingConfigurations | mChildrenChangingConfigurations;
}"
2411,"public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  Context userContext=null;
  try {
    final String packageName=""String_Node_Str"";
    userContext=mContext.createPackageContextAsUser(packageName,0,new UserHandle(mUserId));
  }
 catch (  NameNotFoundException e) {
    e.printStackTrace();
    userContext=context;
  }
  mAppWidgetHost=new AppWidgetHost(userContext,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(userContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  getInitialTransportState();
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}","public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  if (DEBUG)   Log.e(TAG,""String_Node_Str"");
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  Context userContext=null;
  try {
    final String packageName=""String_Node_Str"";
    userContext=mContext.createPackageContextAsUser(packageName,0,new UserHandle(mUserId));
  }
 catch (  NameNotFoundException e) {
    e.printStackTrace();
    userContext=context;
  }
  mAppWidgetHost=new AppWidgetHost(userContext,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(userContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  getInitialTransportState();
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}"
2412,"private void ensureTransportPresentOrRemoved(int state){
  int page=getWidgetPosition(R.id.keyguard_transport_control);
  if (state == TRANSPORT_INVISIBLE || state == TRANSPORT_VISIBLE) {
    if (page == -1) {
      if (DEBUGXPORT)       Log.v(TAG,""String_Node_Str"");
      int lastWidget=mAppWidgetContainer.getChildCount() - 1;
      int position=0;
      if (lastWidget >= 0) {
        position=mAppWidgetContainer.isCameraPage(lastWidget) ? lastWidget : lastWidget + 1;
      }
      mAppWidgetContainer.addWidget(getTransportControlView(),position);
    }
  }
 else   if (page != -1) {
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    mAppWidgetContainer.removeWidget(getTransportControlView());
    mTransportControl=null;
  }
}","/** 
 * Examines the current state and adds the transport to the widget pager when the state changes. Showing the initial transport and keeping it around is a bit tricky because the signals coming from music players aren't always clear. Here's how the states are handled:  {@link TRANSPORT_GONE} means we have no reason to show the transport - remove it if present.{@link TRANSPORT_INVISIBLE} means we have potential to show the transport because a musicplayer is registered but not currently playing music (or we don't know the state yet). The code adds it conditionally on play state. {@link #TRANSPORT_VISIBLE} means a music player is active and transport should be showing.Once the transport is showing, we always show it until keyguard is dismissed. This state is maintained by onSave/RestoreInstanceState(). This state is cleared in {@link KeyguardViewManager#hide} when keyguard is dismissed, which causes the transport to begone when keyguard is restarted until we get an update with the current state.
 * @param state
 */
private void ensureTransportPresentOrRemoved(int state){
  final boolean showing=getWidgetPosition(R.id.keyguard_transport_control) != -1;
  final boolean visible=state == TRANSPORT_VISIBLE;
  final boolean shouldBeVisible=state == TRANSPORT_INVISIBLE && isMusicPlaying(state);
  if (!showing && (visible || shouldBeVisible)) {
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    int lastWidget=mAppWidgetContainer.getChildCount() - 1;
    int position=0;
    if (lastWidget >= 0) {
      position=mAppWidgetContainer.isCameraPage(lastWidget) ? lastWidget : lastWidget + 1;
    }
    mAppWidgetContainer.addWidget(getOrCreateTransportControl(),position);
  }
 else   if (showing && state == TRANSPORT_GONE) {
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    mAppWidgetContainer.removeWidget(getOrCreateTransportControl());
    mTransportControl=null;
  }
}"
2413,"private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  mPlaybackState=dcs.playbackState;
}","private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  mPlaybackState=dcs.playbackState;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + mTransportState + ""String_Node_Str""+ mPlaybackState);
}"
2414,"@Override public Parcelable onSaveInstanceState(){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  ss.transportState=mTransportState;
  ss.appWidgetToShow=mAppWidgetToShow;
  return ss;
}","@Override public Parcelable onSaveInstanceState(){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mTransportState);
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  final boolean showing=mTransportControl != null && mAppWidgetContainer.getWidgetPageIndex(mTransportControl) >= 0;
  ss.transportState=showing ? TRANSPORT_VISIBLE : mTransportState;
  ss.appWidgetToShow=mAppWidgetToShow;
  return ss;
}"
2415,"private int getAppropriateWidgetPage(int musicTransportState){
  if (mAppWidgetToShow != AppWidgetManager.INVALID_APPWIDGET_ID) {
    final int childCount=mAppWidgetContainer.getChildCount();
    for (int i=0; i < childCount; i++) {
      if (mAppWidgetContainer.getWidgetPageAt(i).getContentAppWidgetId() == mAppWidgetToShow) {
        return i;
      }
    }
    mAppWidgetToShow=AppWidgetManager.INVALID_APPWIDGET_ID;
  }
  if (musicTransportState == TRANSPORT_VISIBLE) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    return mAppWidgetContainer.getWidgetPageIndex(getTransportControlView());
  }
  int rightMost=mAppWidgetContainer.getChildCount() - 1;
  if (mAppWidgetContainer.isCameraPage(rightMost)) {
    rightMost--;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + rightMost);
  return rightMost;
}","private int getAppropriateWidgetPage(int musicTransportState){
  if (mAppWidgetToShow != AppWidgetManager.INVALID_APPWIDGET_ID) {
    final int childCount=mAppWidgetContainer.getChildCount();
    for (int i=0; i < childCount; i++) {
      if (mAppWidgetContainer.getWidgetPageAt(i).getContentAppWidgetId() == mAppWidgetToShow) {
        return i;
      }
    }
    mAppWidgetToShow=AppWidgetManager.INVALID_APPWIDGET_ID;
  }
  if (musicTransportState == TRANSPORT_VISIBLE) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    return mAppWidgetContainer.getWidgetPageIndex(getOrCreateTransportControl());
  }
  int rightMost=mAppWidgetContainer.getChildCount() - 1;
  if (mAppWidgetContainer.isCameraPage(rightMost)) {
    rightMost--;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + rightMost);
  return rightMost;
}"
2416,"@Override public void onRestoreInstanceState(Parcelable state){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  if (!(state instanceof SavedState)) {
    super.onRestoreInstanceState(state);
    return;
  }
  SavedState ss=(SavedState)state;
  super.onRestoreInstanceState(ss.getSuperState());
  mTransportState=(ss.transportState);
  mAppWidgetToShow=ss.appWidgetToShow;
  post(mSwitchPageRunnable);
}","@Override public void onRestoreInstanceState(Parcelable state){
  if (!(state instanceof SavedState)) {
    super.onRestoreInstanceState(state);
    return;
  }
  SavedState ss=(SavedState)state;
  super.onRestoreInstanceState(ss.getSuperState());
  mTransportState=(ss.transportState);
  mAppWidgetToShow=ss.appWidgetToShow;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mTransportState);
  post(mSwitchPageRunnable);
}"
2417,"protected void handleSetPlaybackState(int generationId,int playbackState,long eventTime){
  if (generationId == mDisplayClientState.clientGeneration) {
    for (int i=0; i < mCallbacks.size(); i++) {
      KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
      if (cb != null) {
        cb.onMusicPlaybackStateChanged(playbackState,eventTime);
      }
    }
  }
 else {
    Log.w(TAG,""String_Node_Str"" + generationId + ""String_Node_Str"");
  }
}","protected void handleSetPlaybackState(int generationId,int playbackState,long eventTime){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + generationId + ""String_Node_Str""+ playbackState+ ""String_Node_Str""+ eventTime+ ""String_Node_Str"");
  mDisplayClientState.playbackState=playbackState;
  mDisplayClientState.playbackEventTime=eventTime;
  if (generationId == mDisplayClientState.clientGeneration) {
    for (int i=0; i < mCallbacks.size(); i++) {
      KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
      if (cb != null) {
        cb.onMusicPlaybackStateChanged(playbackState,eventTime);
      }
    }
  }
 else {
    Log.w(TAG,""String_Node_Str"" + generationId + ""String_Node_Str"");
  }
}"
2418,"protected void handleSetGenerationId(int clientGeneration,boolean clearing,PendingIntent p){
  mDisplayClientState.clientGeneration=clientGeneration;
  mDisplayClientState.clearing=clearing;
  mDisplayClientState.intent=p;
  for (int i=0; i < mCallbacks.size(); i++) {
    KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
    if (cb != null) {
      cb.onMusicClientIdChanged(clientGeneration,clearing,p);
    }
  }
}","protected void handleSetGenerationId(int clientGeneration,boolean clearing,PendingIntent p){
  mDisplayClientState.clientGeneration=clientGeneration;
  mDisplayClientState.clearing=clearing;
  mDisplayClientState.intent=p;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + clientGeneration + ""String_Node_Str""+ clearing+ ""String_Node_Str"");
  for (int i=0; i < mCallbacks.size(); i++) {
    KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
    if (cb != null) {
      cb.onMusicClientIdChanged(clientGeneration,clearing,p);
    }
  }
}"
2419,"/** 
 * Send message to keyguard telling it to reset its state.
 * @param options options about how to show the keyguard
 * @see #handleReset()
 */
private void resetStateLocked(Bundle options){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  Message msg=mHandler.obtainMessage(RESET,options);
  mHandler.sendMessage(msg);
}","/** 
 * Send message to keyguard telling it to reset its state.
 * @param options options about how to show the keyguard
 * @see #handleReset()
 */
private void resetStateLocked(Bundle options){
  if (DEBUG)   Log.e(TAG,""String_Node_Str"");
  Message msg=mHandler.obtainMessage(RESET,options);
  mHandler.sendMessage(msg);
}"
2420,"/** 
 * Constructs a new WebView with layout parameters, a default style and a set of custom Javscript interfaces to be added to this WebView at initialization time. This guarantees that these interfaces will be available when the JS context is initialized.
 * @param context a Context object used to access application assets
 * @param attrs an AttributeSet passed to our parent
 * @param defStyle the default style resource ID
 * @param javaScriptInterfaces a Map of interface names, as keys, andobject implementing those interfaces, as values
 * @param privateBrowsing whether this WebView will be initialized inprivate mode
 * @hide This is used internally by dumprendertree, as it requires the javaScript interfaces tobe added synchronously, before a subsequent loadUrl call takes effect.
 */
@SuppressWarnings(""String_Node_Str"") protected WebView(Context context,AttributeSet attrs,int defStyle,Map<String,Object> javaScriptInterfaces,boolean privateBrowsing){
  super(context,attrs,defStyle);
  if (context == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkThread();
  ensureProviderCreated();
  mProvider.init(javaScriptInterfaces,privateBrowsing);
}","/** 
 * Constructs a new WebView with layout parameters, a default style and a set of custom Javscript interfaces to be added to this WebView at initialization time. This guarantees that these interfaces will be available when the JS context is initialized.
 * @param context a Context object used to access application assets
 * @param attrs an AttributeSet passed to our parent
 * @param defStyle the default style resource ID
 * @param javaScriptInterfaces a Map of interface names, as keys, andobject implementing those interfaces, as values
 * @param privateBrowsing whether this WebView will be initialized inprivate mode
 * @hide This is used internally by dumprendertree, as it requires the javaScript interfaces tobe added synchronously, before a subsequent loadUrl call takes effect.
 */
@SuppressWarnings(""String_Node_Str"") protected WebView(Context context,AttributeSet attrs,int defStyle,Map<String,Object> javaScriptInterfaces,boolean privateBrowsing){
  super(context,attrs,defStyle);
  if (context == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  sEnforceThreadChecking=context.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN_MR2;
  checkThread();
  ensureProviderCreated();
  mProvider.init(javaScriptInterfaces,privateBrowsing);
}"
2421,"private static void checkThread(){
  if (Looper.myLooper() != Looper.getMainLooper()) {
    Throwable throwable=new Throwable(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    Log.w(LOGTAG,Log.getStackTraceString(throwable));
    StrictMode.onWebViewMethodCalledOnWrongThread(throwable);
  }
}","private static void checkThread(){
  if (Looper.myLooper() != Looper.getMainLooper()) {
    Throwable throwable=new Throwable(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    Log.w(LOGTAG,Log.getStackTraceString(throwable));
    StrictMode.onWebViewMethodCalledOnWrongThread(throwable);
    if (sEnforceThreadChecking) {
      throw new RuntimeException(throwable);
    }
  }
}"
2422,"private void handleActionMove(MotionEvent event){
  final int historySize=event.getHistorySize();
  Rect invalidateRect=mInvalidate;
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float startX=getCenterXForColumn(lastCell.column);
      float startY=getCenterYForRow(lastCell.row);
      final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
      float left=Math.min(startX,x) - radius;
      float right=Math.max(startX,x) + radius;
      float top=Math.min(startY,y) - radius;
      float bottom=Math.max(startY,y) + radius;
      if (hitCell != null && patternSize >= 2) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float x2=getCenterXForColumn(hitCell.column);
        final float y2=getCenterYForRow(hitCell.row);
        left=Math.min(x2,left - width);
        right=Math.max(x2,right + width);
        top=Math.min(y2,top - height);
        bottom=Math.max(y2,bottom + height);
      }
      invalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    invalidate(invalidateRect);
    invalidateRect.setEmpty();
  }
}","private void handleActionMove(MotionEvent event){
  final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
  final int historySize=event.getHistorySize();
  mTmpInvalidateRect.setEmpty();
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float lastCellCenterX=getCenterXForColumn(lastCell.column);
      float lastCellCenterY=getCenterYForRow(lastCell.row);
      float left=Math.min(lastCellCenterX,x) - radius;
      float right=Math.max(lastCellCenterX,x) + radius;
      float top=Math.min(lastCellCenterY,y) - radius;
      float bottom=Math.max(lastCellCenterY,y) + radius;
      if (hitCell != null) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float hitCellCenterX=getCenterXForColumn(hitCell.column);
        final float hitCellCenterY=getCenterYForRow(hitCell.row);
        left=Math.min(hitCellCenterX - width,left);
        right=Math.max(hitCellCenterX + width,right);
        top=Math.min(hitCellCenterY - height,top);
        bottom=Math.max(hitCellCenterY + height,bottom);
      }
      mTmpInvalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    mInvalidate.union(mTmpInvalidateRect);
    invalidate(mInvalidate);
    mInvalidate.set(mTmpInvalidateRect);
  }
}"
2423,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
  mIsAttached=false;
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null && mDataSetObserver != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
  mIsAttached=false;
}"
2424,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
  mIsAttached=false;
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null && mDataSetObserver != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
  mIsAttached=false;
}"
2425,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
  mIsAttached=false;
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null && mDataSetObserver != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
  mIsAttached=false;
}"
2426,"public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  Context userContext=null;
  try {
    final String packageName=""String_Node_Str"";
    userContext=mContext.createPackageContextAsUser(packageName,0,new UserHandle(mUserId));
  }
 catch (  NameNotFoundException e) {
    e.printStackTrace();
    userContext=context;
  }
  mAppWidgetHost=new AppWidgetHost(userContext,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(userContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  getInitialTransportState();
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}","public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  if (DEBUG)   Log.e(TAG,""String_Node_Str"");
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  Context userContext=null;
  try {
    final String packageName=""String_Node_Str"";
    userContext=mContext.createPackageContextAsUser(packageName,0,new UserHandle(mUserId));
  }
 catch (  NameNotFoundException e) {
    e.printStackTrace();
    userContext=context;
  }
  mAppWidgetHost=new AppWidgetHost(userContext,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(userContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  getInitialTransportState();
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}"
2427,"private void ensureTransportPresentOrRemoved(int state){
  int page=getWidgetPosition(R.id.keyguard_transport_control);
  if (state == TRANSPORT_INVISIBLE || state == TRANSPORT_VISIBLE) {
    if (page == -1) {
      if (DEBUGXPORT)       Log.v(TAG,""String_Node_Str"");
      int lastWidget=mAppWidgetContainer.getChildCount() - 1;
      int position=0;
      if (lastWidget >= 0) {
        position=mAppWidgetContainer.isCameraPage(lastWidget) ? lastWidget : lastWidget + 1;
      }
      mAppWidgetContainer.addWidget(getTransportControlView(),position);
    }
  }
 else   if (page != -1) {
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    mAppWidgetContainer.removeWidget(getTransportControlView());
    mTransportControl=null;
  }
}","/** 
 * Examines the current state and adds the transport to the widget pager when the state changes. Showing the initial transport and keeping it around is a bit tricky because the signals coming from music players aren't always clear. Here's how the states are handled:  {@link TRANSPORT_GONE} means we have no reason to show the transport - remove it if present.{@link TRANSPORT_INVISIBLE} means we have potential to show the transport because a musicplayer is registered but not currently playing music (or we don't know the state yet). The code adds it conditionally on play state. {@link #TRANSPORT_VISIBLE} means a music player is active and transport should be showing.Once the transport is showing, we always show it until keyguard is dismissed. This state is maintained by onSave/RestoreInstanceState(). This state is cleared in {@link KeyguardViewManager#hide} when keyguard is dismissed, which causes the transport to begone when keyguard is restarted until we get an update with the current state.
 * @param state
 */
private void ensureTransportPresentOrRemoved(int state){
  final boolean showing=getWidgetPosition(R.id.keyguard_transport_control) != -1;
  final boolean visible=state == TRANSPORT_VISIBLE;
  final boolean shouldBeVisible=state == TRANSPORT_INVISIBLE && isMusicPlaying(state);
  if (!showing && (visible || shouldBeVisible)) {
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    int lastWidget=mAppWidgetContainer.getChildCount() - 1;
    int position=0;
    if (lastWidget >= 0) {
      position=mAppWidgetContainer.isCameraPage(lastWidget) ? lastWidget : lastWidget + 1;
    }
    mAppWidgetContainer.addWidget(getOrCreateTransportControl(),position);
  }
 else   if (showing && state == TRANSPORT_GONE) {
    if (DEBUGXPORT)     Log.v(TAG,""String_Node_Str"");
    mAppWidgetContainer.removeWidget(getOrCreateTransportControl());
    mTransportControl=null;
  }
}"
2428,"private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  mPlaybackState=dcs.playbackState;
}","private void getInitialTransportState(){
  DisplayClientState dcs=KeyguardUpdateMonitor.getInstance(mContext).getCachedDisplayClientState();
  mTransportState=(dcs.clearing ? TRANSPORT_GONE : (isMusicPlaying(dcs.playbackState) ? TRANSPORT_VISIBLE : TRANSPORT_INVISIBLE));
  mPlaybackState=dcs.playbackState;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + mTransportState + ""String_Node_Str""+ mPlaybackState);
}"
2429,"@Override public Parcelable onSaveInstanceState(){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  ss.transportState=mTransportState;
  ss.appWidgetToShow=mAppWidgetToShow;
  return ss;
}","@Override public Parcelable onSaveInstanceState(){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mTransportState);
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  final boolean showing=mTransportControl != null && mAppWidgetContainer.getWidgetPageIndex(mTransportControl) >= 0;
  ss.transportState=showing ? TRANSPORT_VISIBLE : mTransportState;
  ss.appWidgetToShow=mAppWidgetToShow;
  return ss;
}"
2430,"private int getAppropriateWidgetPage(int musicTransportState){
  if (mAppWidgetToShow != AppWidgetManager.INVALID_APPWIDGET_ID) {
    final int childCount=mAppWidgetContainer.getChildCount();
    for (int i=0; i < childCount; i++) {
      if (mAppWidgetContainer.getWidgetPageAt(i).getContentAppWidgetId() == mAppWidgetToShow) {
        return i;
      }
    }
    mAppWidgetToShow=AppWidgetManager.INVALID_APPWIDGET_ID;
  }
  if (musicTransportState == TRANSPORT_VISIBLE) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    return mAppWidgetContainer.getWidgetPageIndex(getTransportControlView());
  }
  int rightMost=mAppWidgetContainer.getChildCount() - 1;
  if (mAppWidgetContainer.isCameraPage(rightMost)) {
    rightMost--;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + rightMost);
  return rightMost;
}","private int getAppropriateWidgetPage(int musicTransportState){
  if (mAppWidgetToShow != AppWidgetManager.INVALID_APPWIDGET_ID) {
    final int childCount=mAppWidgetContainer.getChildCount();
    for (int i=0; i < childCount; i++) {
      if (mAppWidgetContainer.getWidgetPageAt(i).getContentAppWidgetId() == mAppWidgetToShow) {
        return i;
      }
    }
    mAppWidgetToShow=AppWidgetManager.INVALID_APPWIDGET_ID;
  }
  if (musicTransportState == TRANSPORT_VISIBLE) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    return mAppWidgetContainer.getWidgetPageIndex(getOrCreateTransportControl());
  }
  int rightMost=mAppWidgetContainer.getChildCount() - 1;
  if (mAppWidgetContainer.isCameraPage(rightMost)) {
    rightMost--;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + rightMost);
  return rightMost;
}"
2431,"@Override public void onRestoreInstanceState(Parcelable state){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  if (!(state instanceof SavedState)) {
    super.onRestoreInstanceState(state);
    return;
  }
  SavedState ss=(SavedState)state;
  super.onRestoreInstanceState(ss.getSuperState());
  mTransportState=(ss.transportState);
  mAppWidgetToShow=ss.appWidgetToShow;
  post(mSwitchPageRunnable);
}","@Override public void onRestoreInstanceState(Parcelable state){
  if (!(state instanceof SavedState)) {
    super.onRestoreInstanceState(state);
    return;
  }
  SavedState ss=(SavedState)state;
  super.onRestoreInstanceState(ss.getSuperState());
  mTransportState=(ss.transportState);
  mAppWidgetToShow=ss.appWidgetToShow;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mTransportState);
  post(mSwitchPageRunnable);
}"
2432,"protected void handleSetPlaybackState(int generationId,int playbackState,long eventTime){
  if (generationId == mDisplayClientState.clientGeneration) {
    for (int i=0; i < mCallbacks.size(); i++) {
      KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
      if (cb != null) {
        cb.onMusicPlaybackStateChanged(playbackState,eventTime);
      }
    }
  }
 else {
    Log.w(TAG,""String_Node_Str"" + generationId + ""String_Node_Str"");
  }
}","protected void handleSetPlaybackState(int generationId,int playbackState,long eventTime){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + generationId + ""String_Node_Str""+ playbackState+ ""String_Node_Str""+ eventTime+ ""String_Node_Str"");
  mDisplayClientState.playbackState=playbackState;
  mDisplayClientState.playbackEventTime=eventTime;
  if (generationId == mDisplayClientState.clientGeneration) {
    for (int i=0; i < mCallbacks.size(); i++) {
      KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
      if (cb != null) {
        cb.onMusicPlaybackStateChanged(playbackState,eventTime);
      }
    }
  }
 else {
    Log.w(TAG,""String_Node_Str"" + generationId + ""String_Node_Str"");
  }
}"
2433,"protected void handleSetGenerationId(int clientGeneration,boolean clearing,PendingIntent p){
  mDisplayClientState.clientGeneration=clientGeneration;
  mDisplayClientState.clearing=clearing;
  mDisplayClientState.intent=p;
  for (int i=0; i < mCallbacks.size(); i++) {
    KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
    if (cb != null) {
      cb.onMusicClientIdChanged(clientGeneration,clearing,p);
    }
  }
}","protected void handleSetGenerationId(int clientGeneration,boolean clearing,PendingIntent p){
  mDisplayClientState.clientGeneration=clientGeneration;
  mDisplayClientState.clearing=clearing;
  mDisplayClientState.intent=p;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + clientGeneration + ""String_Node_Str""+ clearing+ ""String_Node_Str"");
  for (int i=0; i < mCallbacks.size(); i++) {
    KeyguardUpdateMonitorCallback cb=mCallbacks.get(i).get();
    if (cb != null) {
      cb.onMusicClientIdChanged(clientGeneration,clearing,p);
    }
  }
}"
2434,"/** 
 * Send message to keyguard telling it to reset its state.
 * @param options options about how to show the keyguard
 * @see #handleReset()
 */
private void resetStateLocked(Bundle options){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  Message msg=mHandler.obtainMessage(RESET,options);
  mHandler.sendMessage(msg);
}","/** 
 * Send message to keyguard telling it to reset its state.
 * @param options options about how to show the keyguard
 * @see #handleReset()
 */
private void resetStateLocked(Bundle options){
  if (DEBUG)   Log.e(TAG,""String_Node_Str"");
  Message msg=mHandler.obtainMessage(RESET,options);
  mHandler.sendMessage(msg);
}"
2435,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
  mIsAttached=false;
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  treeObserver.removeOnTouchModeChangeListener(this);
  if (mTextFilterEnabled && mPopup != null) {
    treeObserver.removeOnGlobalLayoutListener(this);
    mGlobalLayoutListenerAddedFilter=false;
  }
  if (mAdapter != null && mDataSetObserver != null) {
    mAdapter.unregisterDataSetObserver(mDataSetObserver);
    mDataSetObserver=null;
  }
  if (mScrollStrictSpan != null) {
    mScrollStrictSpan.finish();
    mScrollStrictSpan=null;
  }
  if (mFlingStrictSpan != null) {
    mFlingStrictSpan.finish();
    mFlingStrictSpan=null;
  }
  if (mFlingRunnable != null) {
    removeCallbacks(mFlingRunnable);
  }
  if (mPositionScroller != null) {
    mPositionScroller.stop();
  }
  if (mClearScrollingCache != null) {
    removeCallbacks(mClearScrollingCache);
  }
  if (mPerformClick != null) {
    removeCallbacks(mPerformClick);
  }
  if (mTouchModeReset != null) {
    removeCallbacks(mTouchModeReset);
    mTouchModeReset.run();
  }
  mIsAttached=false;
}"
2436,"private NetworkUpdateResult writeIpAndProxyConfigurationsOnChange(WifiConfiguration currentConfig,WifiConfiguration newConfig){
  boolean ipChanged=false;
  boolean proxyChanged=false;
  LinkProperties linkProperties=new LinkProperties();
switch (newConfig.ipAssignment) {
case STATIC:
    Collection<LinkAddress> currentLinkAddresses=currentConfig.linkProperties.getLinkAddresses();
  Collection<LinkAddress> newLinkAddresses=newConfig.linkProperties.getLinkAddresses();
Collection<InetAddress> currentDnses=currentConfig.linkProperties.getDnses();
Collection<InetAddress> newDnses=newConfig.linkProperties.getDnses();
Collection<RouteInfo> currentRoutes=currentConfig.linkProperties.getRoutes();
Collection<RouteInfo> newRoutes=newConfig.linkProperties.getRoutes();
boolean linkAddressesDiffer=(currentLinkAddresses.size() != newLinkAddresses.size()) || !currentLinkAddresses.containsAll(newLinkAddresses);
boolean dnsesDiffer=(currentDnses.size() != newDnses.size()) || !currentDnses.containsAll(newDnses);
boolean routesDiffer=(currentRoutes.size() != newRoutes.size()) || !currentRoutes.containsAll(newRoutes);
if ((currentConfig.ipAssignment != newConfig.ipAssignment) || linkAddressesDiffer || dnsesDiffer|| routesDiffer) {
ipChanged=true;
}
break;
case DHCP:
if (currentConfig.ipAssignment != newConfig.ipAssignment) {
ipChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
switch (newConfig.proxySettings) {
case STATIC:
ProxyProperties newHttpProxy=newConfig.linkProperties.getHttpProxy();
ProxyProperties currentHttpProxy=currentConfig.linkProperties.getHttpProxy();
if (newHttpProxy != null) {
proxyChanged=!newHttpProxy.equals(currentHttpProxy);
}
 else {
proxyChanged=(currentHttpProxy != null);
}
break;
case NONE:
if (currentConfig.proxySettings != newConfig.proxySettings) {
proxyChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
if (!ipChanged) {
addIpSettingsFromConfig(linkProperties,currentConfig);
}
 else {
currentConfig.ipAssignment=newConfig.ipAssignment;
addIpSettingsFromConfig(linkProperties,newConfig);
log(""String_Node_Str"" + currentConfig.SSID + ""String_Node_Str""+ linkProperties.toString());
}
if (!proxyChanged) {
linkProperties.setHttpProxy(currentConfig.linkProperties.getHttpProxy());
}
 else {
currentConfig.proxySettings=newConfig.proxySettings;
linkProperties.setHttpProxy(newConfig.linkProperties.getHttpProxy());
log(""String_Node_Str"" + currentConfig.SSID);
if (linkProperties.getHttpProxy() != null) {
log(""String_Node_Str"" + linkProperties.getHttpProxy().toString());
}
}
if (ipChanged || proxyChanged) {
currentConfig.linkProperties=linkProperties;
writeIpAndProxyConfigurations();
sendConfiguredNetworksChangedBroadcast(currentConfig,WifiManager.CHANGE_REASON_CONFIG_CHANGE);
}
return new NetworkUpdateResult(ipChanged,proxyChanged);
}","private NetworkUpdateResult writeIpAndProxyConfigurationsOnChange(WifiConfiguration currentConfig,WifiConfiguration newConfig){
  boolean ipChanged=false;
  boolean proxyChanged=false;
  LinkProperties linkProperties=null;
switch (newConfig.ipAssignment) {
case STATIC:
    Collection<LinkAddress> currentLinkAddresses=currentConfig.linkProperties.getLinkAddresses();
  Collection<LinkAddress> newLinkAddresses=newConfig.linkProperties.getLinkAddresses();
Collection<InetAddress> currentDnses=currentConfig.linkProperties.getDnses();
Collection<InetAddress> newDnses=newConfig.linkProperties.getDnses();
Collection<RouteInfo> currentRoutes=currentConfig.linkProperties.getRoutes();
Collection<RouteInfo> newRoutes=newConfig.linkProperties.getRoutes();
boolean linkAddressesDiffer=(currentLinkAddresses.size() != newLinkAddresses.size()) || !currentLinkAddresses.containsAll(newLinkAddresses);
boolean dnsesDiffer=(currentDnses.size() != newDnses.size()) || !currentDnses.containsAll(newDnses);
boolean routesDiffer=(currentRoutes.size() != newRoutes.size()) || !currentRoutes.containsAll(newRoutes);
if ((currentConfig.ipAssignment != newConfig.ipAssignment) || linkAddressesDiffer || dnsesDiffer|| routesDiffer) {
ipChanged=true;
}
break;
case DHCP:
if (currentConfig.ipAssignment != newConfig.ipAssignment) {
ipChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
switch (newConfig.proxySettings) {
case STATIC:
ProxyProperties newHttpProxy=newConfig.linkProperties.getHttpProxy();
ProxyProperties currentHttpProxy=currentConfig.linkProperties.getHttpProxy();
if (newHttpProxy != null) {
proxyChanged=!newHttpProxy.equals(currentHttpProxy);
}
 else {
proxyChanged=(currentHttpProxy != null);
}
break;
case NONE:
if (currentConfig.proxySettings != newConfig.proxySettings) {
proxyChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
if (!ipChanged) {
linkProperties=copyIpSettingsFromConfig(currentConfig);
}
 else {
currentConfig.ipAssignment=newConfig.ipAssignment;
linkProperties=copyIpSettingsFromConfig(newConfig);
log(""String_Node_Str"" + currentConfig.SSID + ""String_Node_Str""+ linkProperties.toString());
}
if (!proxyChanged) {
linkProperties.setHttpProxy(currentConfig.linkProperties.getHttpProxy());
}
 else {
currentConfig.proxySettings=newConfig.proxySettings;
linkProperties.setHttpProxy(newConfig.linkProperties.getHttpProxy());
log(""String_Node_Str"" + currentConfig.SSID);
if (linkProperties.getHttpProxy() != null) {
log(""String_Node_Str"" + linkProperties.getHttpProxy().toString());
}
}
if (ipChanged || proxyChanged) {
currentConfig.linkProperties=linkProperties;
writeIpAndProxyConfigurations();
sendConfiguredNetworksChangedBroadcast(currentConfig,WifiManager.CHANGE_REASON_CONFIG_CHANGE);
}
return new NetworkUpdateResult(ipChanged,proxyChanged);
}"
2437,"private NetworkUpdateResult writeIpAndProxyConfigurationsOnChange(WifiConfiguration currentConfig,WifiConfiguration newConfig){
  boolean ipChanged=false;
  boolean proxyChanged=false;
  LinkProperties linkProperties=new LinkProperties();
switch (newConfig.ipAssignment) {
case STATIC:
    Collection<LinkAddress> currentLinkAddresses=currentConfig.linkProperties.getLinkAddresses();
  Collection<LinkAddress> newLinkAddresses=newConfig.linkProperties.getLinkAddresses();
Collection<InetAddress> currentDnses=currentConfig.linkProperties.getDnses();
Collection<InetAddress> newDnses=newConfig.linkProperties.getDnses();
Collection<RouteInfo> currentRoutes=currentConfig.linkProperties.getRoutes();
Collection<RouteInfo> newRoutes=newConfig.linkProperties.getRoutes();
boolean linkAddressesDiffer=(currentLinkAddresses.size() != newLinkAddresses.size()) || !currentLinkAddresses.containsAll(newLinkAddresses);
boolean dnsesDiffer=(currentDnses.size() != newDnses.size()) || !currentDnses.containsAll(newDnses);
boolean routesDiffer=(currentRoutes.size() != newRoutes.size()) || !currentRoutes.containsAll(newRoutes);
if ((currentConfig.ipAssignment != newConfig.ipAssignment) || linkAddressesDiffer || dnsesDiffer|| routesDiffer) {
ipChanged=true;
}
break;
case DHCP:
if (currentConfig.ipAssignment != newConfig.ipAssignment) {
ipChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
switch (newConfig.proxySettings) {
case STATIC:
ProxyProperties newHttpProxy=newConfig.linkProperties.getHttpProxy();
ProxyProperties currentHttpProxy=currentConfig.linkProperties.getHttpProxy();
if (newHttpProxy != null) {
proxyChanged=!newHttpProxy.equals(currentHttpProxy);
}
 else {
proxyChanged=(currentHttpProxy != null);
}
break;
case NONE:
if (currentConfig.proxySettings != newConfig.proxySettings) {
proxyChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
if (!ipChanged) {
addIpSettingsFromConfig(linkProperties,currentConfig);
}
 else {
currentConfig.ipAssignment=newConfig.ipAssignment;
addIpSettingsFromConfig(linkProperties,newConfig);
log(""String_Node_Str"" + currentConfig.SSID + ""String_Node_Str""+ linkProperties.toString());
}
if (!proxyChanged) {
linkProperties.setHttpProxy(currentConfig.linkProperties.getHttpProxy());
}
 else {
currentConfig.proxySettings=newConfig.proxySettings;
linkProperties.setHttpProxy(newConfig.linkProperties.getHttpProxy());
log(""String_Node_Str"" + currentConfig.SSID);
if (linkProperties.getHttpProxy() != null) {
log(""String_Node_Str"" + linkProperties.getHttpProxy().toString());
}
}
if (ipChanged || proxyChanged) {
currentConfig.linkProperties=linkProperties;
writeIpAndProxyConfigurations();
sendConfiguredNetworksChangedBroadcast(currentConfig,WifiManager.CHANGE_REASON_CONFIG_CHANGE);
}
return new NetworkUpdateResult(ipChanged,proxyChanged);
}","private NetworkUpdateResult writeIpAndProxyConfigurationsOnChange(WifiConfiguration currentConfig,WifiConfiguration newConfig){
  boolean ipChanged=false;
  boolean proxyChanged=false;
  LinkProperties linkProperties=null;
switch (newConfig.ipAssignment) {
case STATIC:
    Collection<LinkAddress> currentLinkAddresses=currentConfig.linkProperties.getLinkAddresses();
  Collection<LinkAddress> newLinkAddresses=newConfig.linkProperties.getLinkAddresses();
Collection<InetAddress> currentDnses=currentConfig.linkProperties.getDnses();
Collection<InetAddress> newDnses=newConfig.linkProperties.getDnses();
Collection<RouteInfo> currentRoutes=currentConfig.linkProperties.getRoutes();
Collection<RouteInfo> newRoutes=newConfig.linkProperties.getRoutes();
boolean linkAddressesDiffer=(currentLinkAddresses.size() != newLinkAddresses.size()) || !currentLinkAddresses.containsAll(newLinkAddresses);
boolean dnsesDiffer=(currentDnses.size() != newDnses.size()) || !currentDnses.containsAll(newDnses);
boolean routesDiffer=(currentRoutes.size() != newRoutes.size()) || !currentRoutes.containsAll(newRoutes);
if ((currentConfig.ipAssignment != newConfig.ipAssignment) || linkAddressesDiffer || dnsesDiffer|| routesDiffer) {
ipChanged=true;
}
break;
case DHCP:
if (currentConfig.ipAssignment != newConfig.ipAssignment) {
ipChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
switch (newConfig.proxySettings) {
case STATIC:
ProxyProperties newHttpProxy=newConfig.linkProperties.getHttpProxy();
ProxyProperties currentHttpProxy=currentConfig.linkProperties.getHttpProxy();
if (newHttpProxy != null) {
proxyChanged=!newHttpProxy.equals(currentHttpProxy);
}
 else {
proxyChanged=(currentHttpProxy != null);
}
break;
case NONE:
if (currentConfig.proxySettings != newConfig.proxySettings) {
proxyChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
if (!ipChanged) {
linkProperties=copyIpSettingsFromConfig(currentConfig);
}
 else {
currentConfig.ipAssignment=newConfig.ipAssignment;
linkProperties=copyIpSettingsFromConfig(newConfig);
log(""String_Node_Str"" + currentConfig.SSID + ""String_Node_Str""+ linkProperties.toString());
}
if (!proxyChanged) {
linkProperties.setHttpProxy(currentConfig.linkProperties.getHttpProxy());
}
 else {
currentConfig.proxySettings=newConfig.proxySettings;
linkProperties.setHttpProxy(newConfig.linkProperties.getHttpProxy());
log(""String_Node_Str"" + currentConfig.SSID);
if (linkProperties.getHttpProxy() != null) {
log(""String_Node_Str"" + linkProperties.getHttpProxy().toString());
}
}
if (ipChanged || proxyChanged) {
currentConfig.linkProperties=linkProperties;
writeIpAndProxyConfigurations();
sendConfiguredNetworksChangedBroadcast(currentConfig,WifiManager.CHANGE_REASON_CONFIG_CHANGE);
}
return new NetworkUpdateResult(ipChanged,proxyChanged);
}"
2438,"private NetworkUpdateResult writeIpAndProxyConfigurationsOnChange(WifiConfiguration currentConfig,WifiConfiguration newConfig){
  boolean ipChanged=false;
  boolean proxyChanged=false;
  LinkProperties linkProperties=new LinkProperties();
switch (newConfig.ipAssignment) {
case STATIC:
    Collection<LinkAddress> currentLinkAddresses=currentConfig.linkProperties.getLinkAddresses();
  Collection<LinkAddress> newLinkAddresses=newConfig.linkProperties.getLinkAddresses();
Collection<InetAddress> currentDnses=currentConfig.linkProperties.getDnses();
Collection<InetAddress> newDnses=newConfig.linkProperties.getDnses();
Collection<RouteInfo> currentRoutes=currentConfig.linkProperties.getRoutes();
Collection<RouteInfo> newRoutes=newConfig.linkProperties.getRoutes();
boolean linkAddressesDiffer=(currentLinkAddresses.size() != newLinkAddresses.size()) || !currentLinkAddresses.containsAll(newLinkAddresses);
boolean dnsesDiffer=(currentDnses.size() != newDnses.size()) || !currentDnses.containsAll(newDnses);
boolean routesDiffer=(currentRoutes.size() != newRoutes.size()) || !currentRoutes.containsAll(newRoutes);
if ((currentConfig.ipAssignment != newConfig.ipAssignment) || linkAddressesDiffer || dnsesDiffer|| routesDiffer) {
ipChanged=true;
}
break;
case DHCP:
if (currentConfig.ipAssignment != newConfig.ipAssignment) {
ipChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
switch (newConfig.proxySettings) {
case STATIC:
ProxyProperties newHttpProxy=newConfig.linkProperties.getHttpProxy();
ProxyProperties currentHttpProxy=currentConfig.linkProperties.getHttpProxy();
if (newHttpProxy != null) {
proxyChanged=!newHttpProxy.equals(currentHttpProxy);
}
 else {
proxyChanged=(currentHttpProxy != null);
}
break;
case NONE:
if (currentConfig.proxySettings != newConfig.proxySettings) {
proxyChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
if (!ipChanged) {
addIpSettingsFromConfig(linkProperties,currentConfig);
}
 else {
currentConfig.ipAssignment=newConfig.ipAssignment;
addIpSettingsFromConfig(linkProperties,newConfig);
log(""String_Node_Str"" + currentConfig.SSID + ""String_Node_Str""+ linkProperties.toString());
}
if (!proxyChanged) {
linkProperties.setHttpProxy(currentConfig.linkProperties.getHttpProxy());
}
 else {
currentConfig.proxySettings=newConfig.proxySettings;
linkProperties.setHttpProxy(newConfig.linkProperties.getHttpProxy());
log(""String_Node_Str"" + currentConfig.SSID);
if (linkProperties.getHttpProxy() != null) {
log(""String_Node_Str"" + linkProperties.getHttpProxy().toString());
}
}
if (ipChanged || proxyChanged) {
currentConfig.linkProperties=linkProperties;
writeIpAndProxyConfigurations();
sendConfiguredNetworksChangedBroadcast(currentConfig,WifiManager.CHANGE_REASON_CONFIG_CHANGE);
}
return new NetworkUpdateResult(ipChanged,proxyChanged);
}","private NetworkUpdateResult writeIpAndProxyConfigurationsOnChange(WifiConfiguration currentConfig,WifiConfiguration newConfig){
  boolean ipChanged=false;
  boolean proxyChanged=false;
  LinkProperties linkProperties=null;
switch (newConfig.ipAssignment) {
case STATIC:
    Collection<LinkAddress> currentLinkAddresses=currentConfig.linkProperties.getLinkAddresses();
  Collection<LinkAddress> newLinkAddresses=newConfig.linkProperties.getLinkAddresses();
Collection<InetAddress> currentDnses=currentConfig.linkProperties.getDnses();
Collection<InetAddress> newDnses=newConfig.linkProperties.getDnses();
Collection<RouteInfo> currentRoutes=currentConfig.linkProperties.getRoutes();
Collection<RouteInfo> newRoutes=newConfig.linkProperties.getRoutes();
boolean linkAddressesDiffer=(currentLinkAddresses.size() != newLinkAddresses.size()) || !currentLinkAddresses.containsAll(newLinkAddresses);
boolean dnsesDiffer=(currentDnses.size() != newDnses.size()) || !currentDnses.containsAll(newDnses);
boolean routesDiffer=(currentRoutes.size() != newRoutes.size()) || !currentRoutes.containsAll(newRoutes);
if ((currentConfig.ipAssignment != newConfig.ipAssignment) || linkAddressesDiffer || dnsesDiffer|| routesDiffer) {
ipChanged=true;
}
break;
case DHCP:
if (currentConfig.ipAssignment != newConfig.ipAssignment) {
ipChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
switch (newConfig.proxySettings) {
case STATIC:
ProxyProperties newHttpProxy=newConfig.linkProperties.getHttpProxy();
ProxyProperties currentHttpProxy=currentConfig.linkProperties.getHttpProxy();
if (newHttpProxy != null) {
proxyChanged=!newHttpProxy.equals(currentHttpProxy);
}
 else {
proxyChanged=(currentHttpProxy != null);
}
break;
case NONE:
if (currentConfig.proxySettings != newConfig.proxySettings) {
proxyChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
if (!ipChanged) {
linkProperties=copyIpSettingsFromConfig(currentConfig);
}
 else {
currentConfig.ipAssignment=newConfig.ipAssignment;
linkProperties=copyIpSettingsFromConfig(newConfig);
log(""String_Node_Str"" + currentConfig.SSID + ""String_Node_Str""+ linkProperties.toString());
}
if (!proxyChanged) {
linkProperties.setHttpProxy(currentConfig.linkProperties.getHttpProxy());
}
 else {
currentConfig.proxySettings=newConfig.proxySettings;
linkProperties.setHttpProxy(newConfig.linkProperties.getHttpProxy());
log(""String_Node_Str"" + currentConfig.SSID);
if (linkProperties.getHttpProxy() != null) {
log(""String_Node_Str"" + linkProperties.getHttpProxy().toString());
}
}
if (ipChanged || proxyChanged) {
currentConfig.linkProperties=linkProperties;
writeIpAndProxyConfigurations();
sendConfiguredNetworksChangedBroadcast(currentConfig,WifiManager.CHANGE_REASON_CONFIG_CHANGE);
}
return new NetworkUpdateResult(ipChanged,proxyChanged);
}"
2439,"private NetworkUpdateResult writeIpAndProxyConfigurationsOnChange(WifiConfiguration currentConfig,WifiConfiguration newConfig){
  boolean ipChanged=false;
  boolean proxyChanged=false;
  LinkProperties linkProperties=new LinkProperties();
switch (newConfig.ipAssignment) {
case STATIC:
    Collection<LinkAddress> currentLinkAddresses=currentConfig.linkProperties.getLinkAddresses();
  Collection<LinkAddress> newLinkAddresses=newConfig.linkProperties.getLinkAddresses();
Collection<InetAddress> currentDnses=currentConfig.linkProperties.getDnses();
Collection<InetAddress> newDnses=newConfig.linkProperties.getDnses();
Collection<RouteInfo> currentRoutes=currentConfig.linkProperties.getRoutes();
Collection<RouteInfo> newRoutes=newConfig.linkProperties.getRoutes();
boolean linkAddressesDiffer=(currentLinkAddresses.size() != newLinkAddresses.size()) || !currentLinkAddresses.containsAll(newLinkAddresses);
boolean dnsesDiffer=(currentDnses.size() != newDnses.size()) || !currentDnses.containsAll(newDnses);
boolean routesDiffer=(currentRoutes.size() != newRoutes.size()) || !currentRoutes.containsAll(newRoutes);
if ((currentConfig.ipAssignment != newConfig.ipAssignment) || linkAddressesDiffer || dnsesDiffer|| routesDiffer) {
ipChanged=true;
}
break;
case DHCP:
if (currentConfig.ipAssignment != newConfig.ipAssignment) {
ipChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
switch (newConfig.proxySettings) {
case STATIC:
ProxyProperties newHttpProxy=newConfig.linkProperties.getHttpProxy();
ProxyProperties currentHttpProxy=currentConfig.linkProperties.getHttpProxy();
if (newHttpProxy != null) {
proxyChanged=!newHttpProxy.equals(currentHttpProxy);
}
 else {
proxyChanged=(currentHttpProxy != null);
}
break;
case NONE:
if (currentConfig.proxySettings != newConfig.proxySettings) {
proxyChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
if (!ipChanged) {
addIpSettingsFromConfig(linkProperties,currentConfig);
}
 else {
currentConfig.ipAssignment=newConfig.ipAssignment;
addIpSettingsFromConfig(linkProperties,newConfig);
log(""String_Node_Str"" + currentConfig.SSID + ""String_Node_Str""+ linkProperties.toString());
}
if (!proxyChanged) {
linkProperties.setHttpProxy(currentConfig.linkProperties.getHttpProxy());
}
 else {
currentConfig.proxySettings=newConfig.proxySettings;
linkProperties.setHttpProxy(newConfig.linkProperties.getHttpProxy());
log(""String_Node_Str"" + currentConfig.SSID);
if (linkProperties.getHttpProxy() != null) {
log(""String_Node_Str"" + linkProperties.getHttpProxy().toString());
}
}
if (ipChanged || proxyChanged) {
currentConfig.linkProperties=linkProperties;
writeIpAndProxyConfigurations();
sendConfiguredNetworksChangedBroadcast(currentConfig,WifiManager.CHANGE_REASON_CONFIG_CHANGE);
}
return new NetworkUpdateResult(ipChanged,proxyChanged);
}","private NetworkUpdateResult writeIpAndProxyConfigurationsOnChange(WifiConfiguration currentConfig,WifiConfiguration newConfig){
  boolean ipChanged=false;
  boolean proxyChanged=false;
  LinkProperties linkProperties=null;
switch (newConfig.ipAssignment) {
case STATIC:
    Collection<LinkAddress> currentLinkAddresses=currentConfig.linkProperties.getLinkAddresses();
  Collection<LinkAddress> newLinkAddresses=newConfig.linkProperties.getLinkAddresses();
Collection<InetAddress> currentDnses=currentConfig.linkProperties.getDnses();
Collection<InetAddress> newDnses=newConfig.linkProperties.getDnses();
Collection<RouteInfo> currentRoutes=currentConfig.linkProperties.getRoutes();
Collection<RouteInfo> newRoutes=newConfig.linkProperties.getRoutes();
boolean linkAddressesDiffer=(currentLinkAddresses.size() != newLinkAddresses.size()) || !currentLinkAddresses.containsAll(newLinkAddresses);
boolean dnsesDiffer=(currentDnses.size() != newDnses.size()) || !currentDnses.containsAll(newDnses);
boolean routesDiffer=(currentRoutes.size() != newRoutes.size()) || !currentRoutes.containsAll(newRoutes);
if ((currentConfig.ipAssignment != newConfig.ipAssignment) || linkAddressesDiffer || dnsesDiffer|| routesDiffer) {
ipChanged=true;
}
break;
case DHCP:
if (currentConfig.ipAssignment != newConfig.ipAssignment) {
ipChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
switch (newConfig.proxySettings) {
case STATIC:
ProxyProperties newHttpProxy=newConfig.linkProperties.getHttpProxy();
ProxyProperties currentHttpProxy=currentConfig.linkProperties.getHttpProxy();
if (newHttpProxy != null) {
proxyChanged=!newHttpProxy.equals(currentHttpProxy);
}
 else {
proxyChanged=(currentHttpProxy != null);
}
break;
case NONE:
if (currentConfig.proxySettings != newConfig.proxySettings) {
proxyChanged=true;
}
break;
case UNASSIGNED:
break;
default :
loge(""String_Node_Str"");
break;
}
if (!ipChanged) {
linkProperties=copyIpSettingsFromConfig(currentConfig);
}
 else {
currentConfig.ipAssignment=newConfig.ipAssignment;
linkProperties=copyIpSettingsFromConfig(newConfig);
log(""String_Node_Str"" + currentConfig.SSID + ""String_Node_Str""+ linkProperties.toString());
}
if (!proxyChanged) {
linkProperties.setHttpProxy(currentConfig.linkProperties.getHttpProxy());
}
 else {
currentConfig.proxySettings=newConfig.proxySettings;
linkProperties.setHttpProxy(newConfig.linkProperties.getHttpProxy());
log(""String_Node_Str"" + currentConfig.SSID);
if (linkProperties.getHttpProxy() != null) {
log(""String_Node_Str"" + linkProperties.getHttpProxy().toString());
}
}
if (ipChanged || proxyChanged) {
currentConfig.linkProperties=linkProperties;
writeIpAndProxyConfigurations();
sendConfiguredNetworksChangedBroadcast(currentConfig,WifiManager.CHANGE_REASON_CONFIG_CHANGE);
}
return new NetworkUpdateResult(ipChanged,proxyChanged);
}"
2440,"/** 
 * If this looks like a POST request (form submission) containing a username and password, give the user the option of saving them. Will either do nothing, or block until the UI interaction is complete. Called directly by WebKit.
 * @param postData The data about to be sent as the body of a POST request.
 * @param username The username entered by the user (sniffed from the DOM).
 * @param password The password entered by the user (sniffed from the DOM).
 */
private void maybeSavePassword(byte[] postData,String username,String password){
  if (postData == null || username == null || username.isEmpty() || password == null || password.isEmpty()) {
    return;
  }
  if (!mSettings.getSavePassword()) {
    return;
  }
  try {
    if (DebugFlags.BROWSER_FRAME) {
      Assert.assertNotNull(mCallbackProxy.getBackForwardList().getCurrentItem());
    }
    WebAddress uri=new WebAddress(mCallbackProxy.getBackForwardList().getCurrentItem().getUrl());
    String schemePlusHost=uri.getScheme() + SCHEME_HOST_DELIMITER + uri.getHost();
    String postString=new String(postData);
    WebViewDatabaseClassic db=WebViewDatabaseClassic.getInstance(mContext);
    if (postString.contains(URLEncoder.encode(username)) && postString.contains(URLEncoder.encode(password))) {
      String[] saved=db.getUsernamePassword(schemePlusHost);
      if (saved != null) {
        if (saved[0] != null) {
          db.setUsernamePassword(schemePlusHost,username,password);
        }
      }
 else {
        mCallbackProxy.onSavePassword(schemePlusHost,username,password,null);
      }
    }
  }
 catch (  ParseException ex) {
  }
}","/** 
 * If this looks like a POST request (form submission) containing a username and password, give the user the option of saving them. Will either do nothing, or block until the UI interaction is complete. Called directly by WebKit.
 * @param postData The data about to be sent as the body of a POST request.
 * @param username The username entered by the user (sniffed from the DOM).
 * @param password The password entered by the user (sniffed from the DOM).
 */
private void maybeSavePassword(byte[] postData,String username,String password){
  if (postData == null || username == null || username.isEmpty() || password == null || password.isEmpty()) {
    return;
  }
  if (!mSettings.getSavePassword()) {
    return;
  }
  try {
    if (DebugFlags.BROWSER_FRAME) {
      Assert.assertNotNull(mCallbackProxy.getBackForwardList().getCurrentItem());
    }
    WebAddress uri=new WebAddress(mCallbackProxy.getBackForwardList().getCurrentItem().getUrl());
    String schemePlusHost=uri.getScheme() + SCHEME_HOST_DELIMITER + uri.getHost();
    String postString=new String(postData);
    if (postString.contains(URLEncoder.encode(username)) && postString.contains(URLEncoder.encode(password))) {
      String[] saved=mDatabase.getUsernamePassword(schemePlusHost);
      if (saved != null) {
        if (saved[0] != null) {
          mDatabase.setUsernamePassword(schemePlusHost,username,password);
        }
      }
 else {
        mCallbackProxy.onSavePassword(schemePlusHost,username,password,null);
      }
    }
  }
 catch (  ParseException ex) {
  }
}"
2441,"/** 
 * Create a new BrowserFrame to be used in an application.
 * @param context An application context to use when retrieving assets.
 * @param w A WebViewCore used as the view for this frame.
 * @param proxy A CallbackProxy for posting messages to the UI thread andquerying a client for information.
 * @param settings A WebSettings object that holds all settings.XXX: Called by WebCore thread.
 */
public BrowserFrame(Context context,WebViewCore w,CallbackProxy proxy,WebSettingsClassic settings,Map<String,Object> javascriptInterfaces){
  Context appContext=context.getApplicationContext();
  if (sJavaBridge == null) {
    sJavaBridge=new JWebCoreJavaBridge();
    ActivityManager am=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
    if (am.getMemoryClass() > 16) {
      sJavaBridge.setCacheSize(8 * 1024 * 1024);
    }
 else {
      sJavaBridge.setCacheSize(4 * 1024 * 1024);
    }
    CacheManager.init(appContext);
    CookieSyncManager.createInstance(appContext);
    PluginManager.getInstance(appContext);
  }
  if (sConfigCallback == null) {
    sConfigCallback=new ConfigCallback((WindowManager)appContext.getSystemService(Context.WINDOW_SERVICE));
    ViewRootImpl.addConfigCallback(sConfigCallback);
  }
  sConfigCallback.addHandler(this);
  mJavaScriptObjects=new HashMap<String,JSObject>();
  addJavaScriptObjects(javascriptInterfaces);
  mRemovedJavaScriptObjects=new HashSet<Object>();
  mSettings=settings;
  mContext=context;
  mCallbackProxy=proxy;
  mWebViewCore=w;
  mSearchBox=new SearchBoxImpl(mWebViewCore,mCallbackProxy);
  AssetManager am=context.getAssets();
  nativeCreateFrame(w,am,proxy.getBackForwardList());
  if (DebugFlags.BROWSER_FRAME) {
    Log.v(LOGTAG,""String_Node_Str"" + this);
  }
}","/** 
 * Create a new BrowserFrame to be used in an application.
 * @param context An application context to use when retrieving assets.
 * @param w A WebViewCore used as the view for this frame.
 * @param proxy A CallbackProxy for posting messages to the UI thread andquerying a client for information.
 * @param settings A WebSettings object that holds all settings.XXX: Called by WebCore thread.
 */
public BrowserFrame(Context context,WebViewCore w,CallbackProxy proxy,WebSettingsClassic settings,Map<String,Object> javascriptInterfaces){
  Context appContext=context.getApplicationContext();
  if (sJavaBridge == null) {
    sJavaBridge=new JWebCoreJavaBridge();
    ActivityManager am=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
    if (am.getMemoryClass() > 16) {
      sJavaBridge.setCacheSize(8 * 1024 * 1024);
    }
 else {
      sJavaBridge.setCacheSize(4 * 1024 * 1024);
    }
    CacheManager.init(appContext);
    CookieSyncManager.createInstance(appContext);
    PluginManager.getInstance(appContext);
  }
  if (sConfigCallback == null) {
    sConfigCallback=new ConfigCallback((WindowManager)appContext.getSystemService(Context.WINDOW_SERVICE));
    ViewRootImpl.addConfigCallback(sConfigCallback);
  }
  sConfigCallback.addHandler(this);
  mJavaScriptObjects=new HashMap<String,JSObject>();
  addJavaScriptObjects(javascriptInterfaces);
  mRemovedJavaScriptObjects=new HashSet<Object>();
  mSettings=settings;
  mContext=context;
  mCallbackProxy=proxy;
  mDatabase=WebViewDatabaseClassic.getInstance(appContext);
  mWebViewCore=w;
  mSearchBox=new SearchBoxImpl(mWebViewCore,mCallbackProxy);
  AssetManager am=context.getAssets();
  nativeCreateFrame(w,am,proxy.getBackForwardList());
  if (DebugFlags.BROWSER_FRAME) {
    Log.v(LOGTAG,""String_Node_Str"" + this);
  }
}"
2442,"/** 
 * Sets the playback sample rate for this track. This sets the sampling rate at which the audio data will be consumed and played back, not the original sampling rate of the content. Setting it to half the sample rate of the content will cause the playback to last twice as long, but will also result in a negative pitch shift. The valid sample rate range is from 1Hz to twice the value returned by  {@link #getNativeOutputSampleRate(int)}.
 * @param sampleRateInHz the sample rate expressed in Hz
 * @return error code or success, see {@link #SUCCESS},   {@link #ERROR_BAD_VALUE},  {@link #ERROR_INVALID_OPERATION}
 */
public int setPlaybackRate(int sampleRateInHz){
  if (mState == STATE_UNINITIALIZED) {
    return ERROR_INVALID_OPERATION;
  }
  if (sampleRateInHz <= 0) {
    return ERROR_BAD_VALUE;
  }
  return native_set_playback_rate(sampleRateInHz);
}","/** 
 * Sets the playback sample rate for this track. This sets the sampling rate at which the audio data will be consumed and played back, not the original sampling rate of the content. Setting it to half the sample rate of the content will cause the playback to last twice as long, but will also result in a negative pitch shift. The valid sample rate range is from 1Hz to twice the value returned by  {@link #getNativeOutputSampleRate(int)}.
 * @param sampleRateInHz the sample rate expressed in Hz
 * @return error code or success, see {@link #SUCCESS},   {@link #ERROR_BAD_VALUE},  {@link #ERROR_INVALID_OPERATION}
 */
public int setPlaybackRate(int sampleRateInHz){
  if (mState != STATE_INITIALIZED) {
    return ERROR_INVALID_OPERATION;
  }
  if (sampleRateInHz <= 0) {
    return ERROR_BAD_VALUE;
  }
  return native_set_playback_rate(sampleRateInHz);
}"
2443,"/** 
 * Sets the playback sample rate for this track. This sets the sampling rate at which the audio data will be consumed and played back, not the original sampling rate of the content. Setting it to half the sample rate of the content will cause the playback to last twice as long, but will also result in a negative pitch shift. The valid sample rate range is from 1Hz to twice the value returned by  {@link #getNativeOutputSampleRate(int)}.
 * @param sampleRateInHz the sample rate expressed in Hz
 * @return error code or success, see {@link #SUCCESS},   {@link #ERROR_BAD_VALUE},  {@link #ERROR_INVALID_OPERATION}
 */
public int setPlaybackRate(int sampleRateInHz){
  if (mState == STATE_UNINITIALIZED) {
    return ERROR_INVALID_OPERATION;
  }
  if (sampleRateInHz <= 0) {
    return ERROR_BAD_VALUE;
  }
  return native_set_playback_rate(sampleRateInHz);
}","/** 
 * Sets the playback sample rate for this track. This sets the sampling rate at which the audio data will be consumed and played back, not the original sampling rate of the content. Setting it to half the sample rate of the content will cause the playback to last twice as long, but will also result in a negative pitch shift. The valid sample rate range is from 1Hz to twice the value returned by  {@link #getNativeOutputSampleRate(int)}.
 * @param sampleRateInHz the sample rate expressed in Hz
 * @return error code or success, see {@link #SUCCESS},   {@link #ERROR_BAD_VALUE},  {@link #ERROR_INVALID_OPERATION}
 */
public int setPlaybackRate(int sampleRateInHz){
  if (mState != STATE_INITIALIZED) {
    return ERROR_INVALID_OPERATION;
  }
  if (sampleRateInHz <= 0) {
    return ERROR_BAD_VALUE;
  }
  return native_set_playback_rate(sampleRateInHz);
}"
2444,"/** 
 * If this looks like a POST request (form submission) containing a username and password, give the user the option of saving them. Will either do nothing, or block until the UI interaction is complete. Called directly by WebKit.
 * @param postData The data about to be sent as the body of a POST request.
 * @param username The username entered by the user (sniffed from the DOM).
 * @param password The password entered by the user (sniffed from the DOM).
 */
private void maybeSavePassword(byte[] postData,String username,String password){
  if (postData == null || username == null || username.isEmpty() || password == null || password.isEmpty()) {
    return;
  }
  if (!mSettings.getSavePassword()) {
    return;
  }
  try {
    if (DebugFlags.BROWSER_FRAME) {
      Assert.assertNotNull(mCallbackProxy.getBackForwardList().getCurrentItem());
    }
    WebAddress uri=new WebAddress(mCallbackProxy.getBackForwardList().getCurrentItem().getUrl());
    String schemePlusHost=uri.getScheme() + SCHEME_HOST_DELIMITER + uri.getHost();
    String postString=new String(postData);
    WebViewDatabaseClassic db=WebViewDatabaseClassic.getInstance(mContext);
    if (postString.contains(URLEncoder.encode(username)) && postString.contains(URLEncoder.encode(password))) {
      String[] saved=db.getUsernamePassword(schemePlusHost);
      if (saved != null) {
        if (saved[0] != null) {
          db.setUsernamePassword(schemePlusHost,username,password);
        }
      }
 else {
        mCallbackProxy.onSavePassword(schemePlusHost,username,password,null);
      }
    }
  }
 catch (  ParseException ex) {
  }
}","/** 
 * If this looks like a POST request (form submission) containing a username and password, give the user the option of saving them. Will either do nothing, or block until the UI interaction is complete. Called directly by WebKit.
 * @param postData The data about to be sent as the body of a POST request.
 * @param username The username entered by the user (sniffed from the DOM).
 * @param password The password entered by the user (sniffed from the DOM).
 */
private void maybeSavePassword(byte[] postData,String username,String password){
  if (postData == null || username == null || username.isEmpty() || password == null || password.isEmpty()) {
    return;
  }
  if (!mSettings.getSavePassword()) {
    return;
  }
  try {
    if (DebugFlags.BROWSER_FRAME) {
      Assert.assertNotNull(mCallbackProxy.getBackForwardList().getCurrentItem());
    }
    WebAddress uri=new WebAddress(mCallbackProxy.getBackForwardList().getCurrentItem().getUrl());
    String schemePlusHost=uri.getScheme() + SCHEME_HOST_DELIMITER + uri.getHost();
    String postString=new String(postData);
    if (postString.contains(URLEncoder.encode(username)) && postString.contains(URLEncoder.encode(password))) {
      String[] saved=mDatabase.getUsernamePassword(schemePlusHost);
      if (saved != null) {
        if (saved[0] != null) {
          mDatabase.setUsernamePassword(schemePlusHost,username,password);
        }
      }
 else {
        mCallbackProxy.onSavePassword(schemePlusHost,username,password,null);
      }
    }
  }
 catch (  ParseException ex) {
  }
}"
2445,"/** 
 * Create a new BrowserFrame to be used in an application.
 * @param context An application context to use when retrieving assets.
 * @param w A WebViewCore used as the view for this frame.
 * @param proxy A CallbackProxy for posting messages to the UI thread andquerying a client for information.
 * @param settings A WebSettings object that holds all settings.XXX: Called by WebCore thread.
 */
public BrowserFrame(Context context,WebViewCore w,CallbackProxy proxy,WebSettingsClassic settings,Map<String,Object> javascriptInterfaces){
  Context appContext=context.getApplicationContext();
  if (sJavaBridge == null) {
    sJavaBridge=new JWebCoreJavaBridge();
    ActivityManager am=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
    if (am.getMemoryClass() > 16) {
      sJavaBridge.setCacheSize(8 * 1024 * 1024);
    }
 else {
      sJavaBridge.setCacheSize(4 * 1024 * 1024);
    }
    CacheManager.init(appContext);
    CookieSyncManager.createInstance(appContext);
    PluginManager.getInstance(appContext);
  }
  if (sConfigCallback == null) {
    sConfigCallback=new ConfigCallback((WindowManager)appContext.getSystemService(Context.WINDOW_SERVICE));
    ViewRootImpl.addConfigCallback(sConfigCallback);
  }
  sConfigCallback.addHandler(this);
  mJavaScriptObjects=new HashMap<String,JSObject>();
  addJavaScriptObjects(javascriptInterfaces);
  mRemovedJavaScriptObjects=new HashSet<Object>();
  mSettings=settings;
  mContext=context;
  mCallbackProxy=proxy;
  mWebViewCore=w;
  mSearchBox=new SearchBoxImpl(mWebViewCore,mCallbackProxy);
  AssetManager am=context.getAssets();
  nativeCreateFrame(w,am,proxy.getBackForwardList());
  if (DebugFlags.BROWSER_FRAME) {
    Log.v(LOGTAG,""String_Node_Str"" + this);
  }
}","/** 
 * Create a new BrowserFrame to be used in an application.
 * @param context An application context to use when retrieving assets.
 * @param w A WebViewCore used as the view for this frame.
 * @param proxy A CallbackProxy for posting messages to the UI thread andquerying a client for information.
 * @param settings A WebSettings object that holds all settings.XXX: Called by WebCore thread.
 */
public BrowserFrame(Context context,WebViewCore w,CallbackProxy proxy,WebSettingsClassic settings,Map<String,Object> javascriptInterfaces){
  Context appContext=context.getApplicationContext();
  if (sJavaBridge == null) {
    sJavaBridge=new JWebCoreJavaBridge();
    ActivityManager am=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
    if (am.getMemoryClass() > 16) {
      sJavaBridge.setCacheSize(8 * 1024 * 1024);
    }
 else {
      sJavaBridge.setCacheSize(4 * 1024 * 1024);
    }
    CacheManager.init(appContext);
    CookieSyncManager.createInstance(appContext);
    PluginManager.getInstance(appContext);
  }
  if (sConfigCallback == null) {
    sConfigCallback=new ConfigCallback((WindowManager)appContext.getSystemService(Context.WINDOW_SERVICE));
    ViewRootImpl.addConfigCallback(sConfigCallback);
  }
  sConfigCallback.addHandler(this);
  mJavaScriptObjects=new HashMap<String,JSObject>();
  addJavaScriptObjects(javascriptInterfaces);
  mRemovedJavaScriptObjects=new HashSet<Object>();
  mSettings=settings;
  mContext=context;
  mCallbackProxy=proxy;
  mDatabase=WebViewDatabaseClassic.getInstance(appContext);
  mWebViewCore=w;
  mSearchBox=new SearchBoxImpl(mWebViewCore,mCallbackProxy);
  AssetManager am=context.getAssets();
  nativeCreateFrame(w,am,proxy.getBackForwardList());
  if (DebugFlags.BROWSER_FRAME) {
    Log.v(LOGTAG,""String_Node_Str"" + this);
  }
}"
2446,"/** 
 * Sets the playback sample rate for this track. This sets the sampling rate at which the audio data will be consumed and played back, not the original sampling rate of the content. For example, setting it to half the sample rate of the content will cause the playback to last twice as long, but will also result in a pitch shift down by one octave. The valid sample rate range is from 1 Hz to twice the value returned by  {@link #getNativeOutputSampleRate(int)}.
 * @param sampleRateInHz the sample rate expressed in Hz
 * @return error code or success, see {@link #SUCCESS},   {@link #ERROR_BAD_VALUE},  {@link #ERROR_INVALID_OPERATION}
 */
public int setPlaybackRate(int sampleRateInHz){
  if (mState == STATE_UNINITIALIZED) {
    return ERROR_INVALID_OPERATION;
  }
  if (sampleRateInHz <= 0) {
    return ERROR_BAD_VALUE;
  }
  return native_set_playback_rate(sampleRateInHz);
}","/** 
 * Sets the playback sample rate for this track. This sets the sampling rate at which the audio data will be consumed and played back, not the original sampling rate of the content. For example, setting it to half the sample rate of the content will cause the playback to last twice as long, but will also result in a pitch shift down by one octave. The valid sample rate range is from 1 Hz to twice the value returned by  {@link #getNativeOutputSampleRate(int)}.
 * @param sampleRateInHz the sample rate expressed in Hz
 * @return error code or success, see {@link #SUCCESS},   {@link #ERROR_BAD_VALUE},  {@link #ERROR_INVALID_OPERATION}
 */
public int setPlaybackRate(int sampleRateInHz){
  if (mState != STATE_INITIALIZED) {
    return ERROR_INVALID_OPERATION;
  }
  if (sampleRateInHz <= 0) {
    return ERROR_BAD_VALUE;
  }
  return native_set_playback_rate(sampleRateInHz);
}"
2447,"final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity){
}","final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callerApp == null ? null : callerApp.info,callingPackage,callingUid,callingPid,resolvedType,aInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  if (mMainStack.mResumedActivity == null || mMainStack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,mMainStack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (mMainStack.mPausingActivity == null) {
    dismissKeyguard();
  }
  return err;
}"
2448,"/** 
 * Sets the playback sample rate for this track. This sets the sampling rate at which the audio data will be consumed and played back, not the original sampling rate of the content. Setting it to half the sample rate of the content will cause the playback to last twice as long, but will also result in a negative pitch shift. The valid sample rate range is from 1Hz to twice the value returned by  {@link #getNativeOutputSampleRate(int)}.
 * @param sampleRateInHz the sample rate expressed in Hz
 * @return error code or success, see {@link #SUCCESS},   {@link #ERROR_BAD_VALUE},  {@link #ERROR_INVALID_OPERATION}
 */
public int setPlaybackRate(int sampleRateInHz){
  if (mState == STATE_UNINITIALIZED) {
    return ERROR_INVALID_OPERATION;
  }
  if (sampleRateInHz <= 0) {
    return ERROR_BAD_VALUE;
  }
  return native_set_playback_rate(sampleRateInHz);
}","/** 
 * Sets the playback sample rate for this track. This sets the sampling rate at which the audio data will be consumed and played back, not the original sampling rate of the content. Setting it to half the sample rate of the content will cause the playback to last twice as long, but will also result in a negative pitch shift. The valid sample rate range is from 1Hz to twice the value returned by  {@link #getNativeOutputSampleRate(int)}.
 * @param sampleRateInHz the sample rate expressed in Hz
 * @return error code or success, see {@link #SUCCESS},   {@link #ERROR_BAD_VALUE},  {@link #ERROR_INVALID_OPERATION}
 */
public int setPlaybackRate(int sampleRateInHz){
  if (mState != STATE_INITIALIZED) {
    return ERROR_INVALID_OPERATION;
  }
  if (sampleRateInHz <= 0) {
    return ERROR_BAD_VALUE;
  }
  return native_set_playback_rate(sampleRateInHz);
}"
2449,"/** 
 * Add a service to the list of services to be hosted. <p>Once a service has been addded to the the list, the service and it's included characteristics will be provided by the local device. <p>If the local device has already exposed services when this function is called, a service update notification will be sent to all clients. <p>Requires   {@link android.Manifest.permission#BLUETOOTH} permission.
 * @param service Service to be added to the list of services providedby this device.
 * @return true, if the service has been added successfully
 */
public boolean addService(BluetoothGattService service){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + service.getUuid());
  if (mService == null || mServerIf == 0)   return false;
  mServices.add(service);
  try {
    mService.beginServiceDeclaration(mServerIf,service.getType(),service.getInstanceId(),service.getHandles(),new ParcelUuid(service.getUuid()));
    List<BluetoothGattService> includedServices=service.getIncludedServices();
    for (    BluetoothGattService includedService : includedServices) {
      mService.addIncludedService(mServerIf,includedService.getType(),includedService.getInstanceId(),new ParcelUuid(includedService.getUuid()));
    }
    List<BluetoothGattCharacteristic> characteristics=service.getCharacteristics();
    for (    BluetoothGattCharacteristic characteristic : characteristics) {
      int permission=((characteristic.getKeySize() - 7) << 12) + characteristic.getPermissions();
      mService.addCharacteristic(mServerIf,new ParcelUuid(characteristic.getUuid()),characteristic.getProperties(),permission);
      List<BluetoothGattDescriptor> descriptors=characteristic.getDescriptors();
      for (      BluetoothGattDescriptor descriptor : descriptors) {
        mService.addDescriptor(mServerIf,new ParcelUuid(descriptor.getUuid()),descriptor.getPermissions());
      }
    }
    mService.endServiceDeclaration(mServerIf);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
  return true;
}","/** 
 * Add a service to the list of services to be hosted. <p>Once a service has been addded to the the list, the service and it's included characteristics will be provided by the local device. <p>If the local device has already exposed services when this function is called, a service update notification will be sent to all clients. <p>Requires   {@link android.Manifest.permission#BLUETOOTH} permission.
 * @param service Service to be added to the list of services providedby this device.
 * @return true, if the service has been added successfully
 */
public boolean addService(BluetoothGattService service){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + service.getUuid());
  if (mService == null || mServerIf == 0)   return false;
  mServices.add(service);
  try {
    mService.beginServiceDeclaration(mServerIf,service.getType(),service.getInstanceId(),service.getHandles(),new ParcelUuid(service.getUuid()));
    List<BluetoothGattService> includedServices=service.getIncludedServices();
    for (    BluetoothGattService includedService : includedServices) {
      mService.addIncludedService(mServerIf,includedService.getType(),includedService.getInstanceId(),new ParcelUuid(includedService.getUuid()));
    }
    List<BluetoothGattCharacteristic> characteristics=service.getCharacteristics();
    for (    BluetoothGattCharacteristic characteristic : characteristics) {
      int permission=((characteristic.getKeySize() - 7) << 12) + characteristic.getPermissions();
      mService.addCharacteristic(mServerIf,new ParcelUuid(characteristic.getUuid()),characteristic.getProperties(),permission);
      List<BluetoothGattDescriptor> descriptors=characteristic.getDescriptors();
      for (      BluetoothGattDescriptor descriptor : descriptors) {
        permission=((characteristic.getKeySize() - 7) << 12) + descriptor.getPermissions();
        mService.addDescriptor(mServerIf,new ParcelUuid(descriptor.getUuid()),permission);
      }
    }
    mService.endServiceDeclaration(mServerIf);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
  return true;
}"
2450,"/** 
 * Add a service to the list of services to be hosted. <p>Once a service has been addded to the the list, the service and it's included characteristics will be provided by the local device. <p>If the local device has already exposed services when this function is called, a service update notification will be sent to all clients. <p>Requires   {@link android.Manifest.permission#BLUETOOTH} permission.
 * @param service Service to be added to the list of services providedby this device.
 * @return true, if the service has been added successfully
 */
public boolean addService(BluetoothGattService service){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + service.getUuid());
  if (mService == null || mServerIf == 0)   return false;
  mServices.add(service);
  try {
    mService.beginServiceDeclaration(mServerIf,service.getType(),service.getInstanceId(),service.getHandles(),new ParcelUuid(service.getUuid()));
    List<BluetoothGattService> includedServices=service.getIncludedServices();
    for (    BluetoothGattService includedService : includedServices) {
      mService.addIncludedService(mServerIf,includedService.getType(),includedService.getInstanceId(),new ParcelUuid(includedService.getUuid()));
    }
    List<BluetoothGattCharacteristic> characteristics=service.getCharacteristics();
    for (    BluetoothGattCharacteristic characteristic : characteristics) {
      int permission=((characteristic.getKeySize() - 7) << 12) + characteristic.getPermissions();
      mService.addCharacteristic(mServerIf,new ParcelUuid(characteristic.getUuid()),characteristic.getProperties(),permission);
      List<BluetoothGattDescriptor> descriptors=characteristic.getDescriptors();
      for (      BluetoothGattDescriptor descriptor : descriptors) {
        mService.addDescriptor(mServerIf,new ParcelUuid(descriptor.getUuid()),descriptor.getPermissions());
      }
    }
    mService.endServiceDeclaration(mServerIf);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
  return true;
}","/** 
 * Add a service to the list of services to be hosted. <p>Once a service has been addded to the the list, the service and it's included characteristics will be provided by the local device. <p>If the local device has already exposed services when this function is called, a service update notification will be sent to all clients. <p>Requires   {@link android.Manifest.permission#BLUETOOTH} permission.
 * @param service Service to be added to the list of services providedby this device.
 * @return true, if the service has been added successfully
 */
public boolean addService(BluetoothGattService service){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + service.getUuid());
  if (mService == null || mServerIf == 0)   return false;
  mServices.add(service);
  try {
    mService.beginServiceDeclaration(mServerIf,service.getType(),service.getInstanceId(),service.getHandles(),new ParcelUuid(service.getUuid()));
    List<BluetoothGattService> includedServices=service.getIncludedServices();
    for (    BluetoothGattService includedService : includedServices) {
      mService.addIncludedService(mServerIf,includedService.getType(),includedService.getInstanceId(),new ParcelUuid(includedService.getUuid()));
    }
    List<BluetoothGattCharacteristic> characteristics=service.getCharacteristics();
    for (    BluetoothGattCharacteristic characteristic : characteristics) {
      int permission=((characteristic.getKeySize() - 7) << 12) + characteristic.getPermissions();
      mService.addCharacteristic(mServerIf,new ParcelUuid(characteristic.getUuid()),characteristic.getProperties(),permission);
      List<BluetoothGattDescriptor> descriptors=characteristic.getDescriptors();
      for (      BluetoothGattDescriptor descriptor : descriptors) {
        permission=((characteristic.getKeySize() - 7) << 12) + descriptor.getPermissions();
        mService.addDescriptor(mServerIf,new ParcelUuid(descriptor.getUuid()),permission);
      }
    }
    mService.endServiceDeclaration(mServerIf);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
  return true;
}"
2451,"/** 
 * Add a service to the list of services to be hosted. <p>Once a service has been addded to the the list, the service and it's included characteristics will be provided by the local device. <p>If the local device has already exposed services when this function is called, a service update notification will be sent to all clients. <p>Requires   {@link android.Manifest.permission#BLUETOOTH} permission.
 * @param service Service to be added to the list of services providedby this device.
 * @return true, if the service has been added successfully
 */
public boolean addService(BluetoothGattService service){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + service.getUuid());
  if (mService == null || mServerIf == 0)   return false;
  mServices.add(service);
  try {
    mService.beginServiceDeclaration(mServerIf,service.getType(),service.getInstanceId(),service.getHandles(),new ParcelUuid(service.getUuid()));
    List<BluetoothGattService> includedServices=service.getIncludedServices();
    for (    BluetoothGattService includedService : includedServices) {
      mService.addIncludedService(mServerIf,includedService.getType(),includedService.getInstanceId(),new ParcelUuid(includedService.getUuid()));
    }
    List<BluetoothGattCharacteristic> characteristics=service.getCharacteristics();
    for (    BluetoothGattCharacteristic characteristic : characteristics) {
      int permission=((characteristic.getKeySize() - 7) << 12) + characteristic.getPermissions();
      mService.addCharacteristic(mServerIf,new ParcelUuid(characteristic.getUuid()),characteristic.getProperties(),permission);
      List<BluetoothGattDescriptor> descriptors=characteristic.getDescriptors();
      for (      BluetoothGattDescriptor descriptor : descriptors) {
        mService.addDescriptor(mServerIf,new ParcelUuid(descriptor.getUuid()),descriptor.getPermissions());
      }
    }
    mService.endServiceDeclaration(mServerIf);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
  return true;
}","/** 
 * Add a service to the list of services to be hosted. <p>Once a service has been addded to the the list, the service and it's included characteristics will be provided by the local device. <p>If the local device has already exposed services when this function is called, a service update notification will be sent to all clients. <p>Requires   {@link android.Manifest.permission#BLUETOOTH} permission.
 * @param service Service to be added to the list of services providedby this device.
 * @return true, if the service has been added successfully
 */
public boolean addService(BluetoothGattService service){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + service.getUuid());
  if (mService == null || mServerIf == 0)   return false;
  mServices.add(service);
  try {
    mService.beginServiceDeclaration(mServerIf,service.getType(),service.getInstanceId(),service.getHandles(),new ParcelUuid(service.getUuid()));
    List<BluetoothGattService> includedServices=service.getIncludedServices();
    for (    BluetoothGattService includedService : includedServices) {
      mService.addIncludedService(mServerIf,includedService.getType(),includedService.getInstanceId(),new ParcelUuid(includedService.getUuid()));
    }
    List<BluetoothGattCharacteristic> characteristics=service.getCharacteristics();
    for (    BluetoothGattCharacteristic characteristic : characteristics) {
      int permission=((characteristic.getKeySize() - 7) << 12) + characteristic.getPermissions();
      mService.addCharacteristic(mServerIf,new ParcelUuid(characteristic.getUuid()),characteristic.getProperties(),permission);
      List<BluetoothGattDescriptor> descriptors=characteristic.getDescriptors();
      for (      BluetoothGattDescriptor descriptor : descriptors) {
        permission=((characteristic.getKeySize() - 7) << 12) + descriptor.getPermissions();
        mService.addDescriptor(mServerIf,new ParcelUuid(descriptor.getUuid()),permission);
      }
    }
    mService.endServiceDeclaration(mServerIf);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
  return true;
}"
2452,"public void closeSystemDialogs(String reason){
  enforceNotIsolatedCaller(""String_Node_Str"");
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      if (uid >= Process.FIRST_APPLICATION_UID) {
        ProcessRecord proc;
synchronized (mPidsSelfLocked) {
          proc=mPidsSelfLocked.get(pid);
        }
        if (proc.curRawAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ proc);
          return;
        }
      }
      closeSystemDialogsLocked(reason);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","@Override public void closeSystemDialogs(String reason){
  enforceNotIsolatedCaller(""String_Node_Str"");
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      if (uid >= Process.FIRST_APPLICATION_UID) {
        ProcessRecord proc;
synchronized (mPidsSelfLocked) {
          proc=mPidsSelfLocked.get(pid);
        }
        if (proc.curRawAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ proc);
          return;
        }
      }
      closeSystemDialogsLocked(reason);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
2453,"public Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids) throws RemoteException {
  enforceNotIsolatedCaller(""String_Node_Str"");
  Debug.MemoryInfo[] infos=new Debug.MemoryInfo[pids.length];
  for (int i=pids.length - 1; i >= 0; i--) {
    infos[i]=new Debug.MemoryInfo();
    Debug.getMemoryInfo(pids[i],infos[i]);
  }
  return infos;
}","@Override public Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids){
  enforceNotIsolatedCaller(""String_Node_Str"");
  Debug.MemoryInfo[] infos=new Debug.MemoryInfo[pids.length];
  for (int i=pids.length - 1; i >= 0; i--) {
    infos[i]=new Debug.MemoryInfo();
    Debug.getMemoryInfo(pids[i],infos[i]);
  }
  return infos;
}"
2454,"public void forceStopPackage(final String packageName,int userId){
  if (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.FORCE_STOP_PACKAGES;
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  userId=handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,true,true,""String_Node_Str"",null);
  long callingId=Binder.clearCallingIdentity();
  try {
    IPackageManager pm=AppGlobals.getPackageManager();
synchronized (this) {
      int[] users=userId == UserHandle.USER_ALL ? getUsersLocked() : new int[]{userId};
      for (      int user : users) {
        int pkgUid=-1;
        try {
          pkgUid=pm.getPackageUid(packageName,user);
        }
 catch (        RemoteException e) {
        }
        if (pkgUid == -1) {
          Slog.w(TAG,""String_Node_Str"" + packageName);
          continue;
        }
        try {
          pm.setPackageStoppedState(packageName,true,user);
        }
 catch (        RemoteException e) {
        }
catch (        IllegalArgumentException e) {
          Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ e);
        }
        if (isUserRunningLocked(user,false)) {
          forceStopPackageLocked(packageName,pkgUid);
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingId);
  }
}","@Override public void forceStopPackage(final String packageName,int userId){
  if (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.FORCE_STOP_PACKAGES;
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  userId=handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,true,true,""String_Node_Str"",null);
  long callingId=Binder.clearCallingIdentity();
  try {
    IPackageManager pm=AppGlobals.getPackageManager();
synchronized (this) {
      int[] users=userId == UserHandle.USER_ALL ? getUsersLocked() : new int[]{userId};
      for (      int user : users) {
        int pkgUid=-1;
        try {
          pkgUid=pm.getPackageUid(packageName,user);
        }
 catch (        RemoteException e) {
        }
        if (pkgUid == -1) {
          Slog.w(TAG,""String_Node_Str"" + packageName);
          continue;
        }
        try {
          pm.setPackageStoppedState(packageName,true,user);
        }
 catch (        RemoteException e) {
        }
catch (        IllegalArgumentException e) {
          Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ e);
        }
        if (isUserRunningLocked(user,false)) {
          forceStopPackageLocked(packageName,pkgUid);
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingId);
  }
}"
2455,"public void killApplicationWithAppId(String pkg,int appid){
  if (pkg == null) {
    return;
  }
  if (appid < 0) {
    Slog.w(TAG,""String_Node_Str"" + pkg);
    return;
  }
  int callerUid=Binder.getCallingUid();
  if (callerUid == Process.SYSTEM_UID) {
    Message msg=mHandler.obtainMessage(KILL_APPLICATION_MSG);
    msg.arg1=appid;
    msg.arg2=0;
    msg.obj=pkg;
    mHandler.sendMessage(msg);
  }
 else {
    throw new SecurityException(callerUid + ""String_Node_Str"" + pkg);
  }
}","@Override public void killApplicationWithAppId(String pkg,int appid){
  if (pkg == null) {
    return;
  }
  if (appid < 0) {
    Slog.w(TAG,""String_Node_Str"" + pkg);
    return;
  }
  int callerUid=Binder.getCallingUid();
  if (callerUid == Process.SYSTEM_UID) {
    Message msg=mHandler.obtainMessage(KILL_APPLICATION_MSG);
    msg.arg1=appid;
    msg.arg2=0;
    msg.obj=pkg;
    mHandler.sendMessage(msg);
  }
 else {
    throw new SecurityException(callerUid + ""String_Node_Str"" + pkg);
  }
}"
2456,"final ActivityRecord activityIdleInternalLocked(IBinder token,boolean fromTimeout,Configuration config){
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + token);
  ActivityRecord res=null;
  ArrayList<ActivityRecord> stops=null;
  ArrayList<ActivityRecord> finishes=null;
  ArrayList<ActivityRecord> thumbnails=null;
  ArrayList<UserStartedState> startingUsers=null;
  int NS=0;
  int NF=0;
  int NT=0;
  IApplicationThread sendThumbnail=null;
  boolean booting=false;
  boolean enableScreen=false;
  boolean activityRemoved=false;
  ActivityRecord r=ActivityRecord.forToken(token);
  if (r != null) {
    mHandler.removeMessages(IDLE_TIMEOUT_MSG,r);
    r.finishLaunchTickingLocked();
  }
  if (isInStackLocked(token) != null) {
    res=r;
    if (fromTimeout) {
      reportActivityLaunchedLocked(fromTimeout,r,-1,-1);
    }
    if (config != null) {
      r.configuration=config;
    }
    if (mResumedActivity == r && mLaunchingActivity.isHeld()) {
      mHandler.removeMessages(LAUNCH_TIMEOUT_MSG);
      mLaunchingActivity.release();
    }
    r.idle=true;
    mService.scheduleAppGcsLocked();
    if (r.thumbnailNeeded && r.app != null && r.app.thread != null) {
      sendThumbnail=r.app.thread;
      r.thumbnailNeeded=false;
    }
    if (DEBUG_VISBILITY)     Slog.v(TAG,""String_Node_Str"" + r);
    ensureActivitiesVisibleLocked(null,0);
    if (mStackSupervisor.isMainStack(this)) {
      if (!mService.mBooted) {
        mService.mBooted=true;
        enableScreen=true;
      }
    }
  }
 else   if (fromTimeout) {
    reportActivityLaunchedLocked(fromTimeout,null,-1,-1);
  }
  stops=processStoppingActivitiesLocked(true);
  NS=stops != null ? stops.size() : 0;
  if ((NF=mFinishingActivities.size()) > 0) {
    finishes=new ArrayList<ActivityRecord>(mFinishingActivities);
    mFinishingActivities.clear();
  }
  if ((NT=mCancelledThumbnails.size()) > 0) {
    thumbnails=new ArrayList<ActivityRecord>(mCancelledThumbnails);
    mCancelledThumbnails.clear();
  }
  if (mStackSupervisor.isMainStack(this)) {
    booting=mService.mBooting;
    mService.mBooting=false;
  }
  if (mStartingUsers.size() > 0) {
    startingUsers=new ArrayList<UserStartedState>(mStartingUsers);
    mStartingUsers.clear();
  }
  int i;
  if (sendThumbnail != null) {
    try {
      sendThumbnail.requestThumbnail(token);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"",e);
      mService.sendPendingThumbnail(null,token,null,null,true);
    }
  }
  for (i=0; i < NS; i++) {
    r=stops.get(i);
synchronized (mService) {
      if (r.finishing) {
        finishCurrentActivityLocked(r,FINISH_IMMEDIATELY,false);
      }
 else {
        stopActivityLocked(r);
      }
    }
  }
  for (i=0; i < NF; i++) {
    r=finishes.get(i);
synchronized (mService) {
      activityRemoved=destroyActivityLocked(r,true,false,""String_Node_Str"");
    }
  }
  for (i=0; i < NT; i++) {
    r=thumbnails.get(i);
    mService.sendPendingThumbnail(r,null,null,null,true);
  }
  if (booting) {
    mService.finishBooting();
  }
 else   if (startingUsers != null) {
    for (i=0; i < startingUsers.size(); i++) {
      mService.finishUserSwitch(startingUsers.get(i));
    }
  }
  mService.trimApplications();
  if (enableScreen) {
    mService.enableScreenAfterBoot();
  }
  if (activityRemoved) {
    resumeTopActivityLocked(null);
  }
  return res;
}","final ActivityRecord activityIdleInternalLocked(final IBinder token,boolean fromTimeout,Configuration config){
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + token);
  ActivityRecord res=null;
  ArrayList<ActivityRecord> stops=null;
  ArrayList<ActivityRecord> finishes=null;
  ArrayList<UserStartedState> startingUsers=null;
  int NS=0;
  int NF=0;
  IApplicationThread sendThumbnail=null;
  boolean booting=false;
  boolean enableScreen=false;
  boolean activityRemoved=false;
  ActivityRecord r=ActivityRecord.forToken(token);
  if (r != null) {
    mHandler.removeMessages(IDLE_TIMEOUT_MSG,r);
    r.finishLaunchTickingLocked();
  }
  if (isInStackLocked(token) != null) {
    res=r;
    if (fromTimeout) {
      reportActivityLaunchedLocked(fromTimeout,r,-1,-1);
    }
    if (config != null) {
      r.configuration=config;
    }
    if (mResumedActivity == r && mLaunchingActivity.isHeld()) {
      mHandler.removeMessages(LAUNCH_TIMEOUT_MSG);
      mLaunchingActivity.release();
    }
    r.idle=true;
    if (mStackSupervisor.allResumedActivitiesIdle()) {
      mService.scheduleAppGcsLocked();
    }
    if (r.thumbnailNeeded && r.app != null && r.app.thread != null) {
      sendThumbnail=r.app.thread;
      r.thumbnailNeeded=false;
    }
    if (DEBUG_VISBILITY)     Slog.v(TAG,""String_Node_Str"" + r);
    ensureActivitiesVisibleLocked(null,0);
    if (!mService.mBooted && mStackSupervisor.isMainStack(this)) {
      mService.mBooted=true;
      enableScreen=true;
    }
  }
 else   if (fromTimeout) {
    reportActivityLaunchedLocked(fromTimeout,null,-1,-1);
  }
  stops=processStoppingActivitiesLocked(true);
  NS=stops != null ? stops.size() : 0;
  if ((NF=mFinishingActivities.size()) > 0) {
    finishes=new ArrayList<ActivityRecord>(mFinishingActivities);
    mFinishingActivities.clear();
  }
  final ArrayList<ActivityRecord> thumbnails;
  final int NT=mCancelledThumbnails.size();
  if (NT > 0) {
    thumbnails=new ArrayList<ActivityRecord>(mCancelledThumbnails);
    mCancelledThumbnails.clear();
  }
 else {
    thumbnails=null;
  }
  if (mStackSupervisor.isMainStack(this)) {
    booting=mService.mBooting;
    mService.mBooting=false;
  }
  if (mStartingUsers.size() > 0) {
    startingUsers=new ArrayList<UserStartedState>(mStartingUsers);
    mStartingUsers.clear();
  }
  final IApplicationThread thumbnailThread=sendThumbnail;
  mHandler.post(new Runnable(){
    @Override public void run(){
      if (thumbnailThread != null) {
        try {
          thumbnailThread.requestThumbnail(token);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"",e);
          mService.sendPendingThumbnail(null,token,null,null,true);
        }
      }
      for (int i=0; i < NT; i++) {
        ActivityRecord r=thumbnails.get(i);
        mService.sendPendingThumbnail(r,null,null,null,true);
      }
    }
  }
);
  for (int i=0; i < NS; i++) {
    r=stops.get(i);
    if (r.finishing) {
      finishCurrentActivityLocked(r,FINISH_IMMEDIATELY,false);
    }
 else {
      stopActivityLocked(r);
    }
  }
  for (int i=0; i < NF; i++) {
    r=finishes.get(i);
    activityRemoved|=destroyActivityLocked(r,true,false,""String_Node_Str"");
  }
  if (booting) {
    mService.finishBooting();
  }
 else   if (startingUsers != null) {
    for (int i=0; i < startingUsers.size(); i++) {
      mService.finishUserSwitch(startingUsers.get(i));
    }
  }
  mService.trimApplications();
  if (enableScreen) {
    mService.enableScreenAfterBoot();
  }
  if (activityRemoved) {
    resumeTopActivityLocked(null);
  }
  return res;
}"
2457,"void resumeTopActivityLocked(){
  final int start, end;
  if (isHomeStackMain()) {
    start=0;
    end=1;
  }
 else {
    start=1;
    end=mStacks.size();
  }
  for (int stackNdx=start; stackNdx < end; ++stackNdx) {
    mStacks.get(stackNdx).resumeTopActivityLocked(null);
  }
}","void resumeTopActivityLocked(){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    mStacks.get(stackNdx).resumeTopActivityLocked(null);
  }
}"
2458,"boolean allResumedActivitiesIdle(){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    if (mStacks.get(stackNdx).mResumedActivity == null || !mStacks.get(stackNdx).mResumedActivity.idle) {
      return false;
    }
  }
  return true;
}","boolean allResumedActivitiesIdle(){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    final ActivityRecord resumedActivity=mStacks.get(stackNdx).mResumedActivity;
    if (resumedActivity == null || !resumedActivity.idle) {
      return false;
    }
  }
  return true;
}"
2459,"public PackageManagerService(Context context,Installer installer,boolean factoryTest,boolean onlyCore){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mOnlyCore=onlyCore;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings(context);
  mSettings.addSharedUserLPw(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",RADIO_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",LOG_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",NFC_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",BLUETOOTH_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",SHELL_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  mInstaller=installer;
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      mAppLibInstallDir=new File(dataDir,""String_Node_Str"");
      mAsecInternalPath=new File(dataDir,""String_Node_Str"").getPath();
      mUserAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      sUserManager=new UserManagerService(context,this,mInstallLock,mPackages);
      readPermissions();
      mFoundPolicyFile=SELinuxMMAC.readInstallPolicy();
      mRestoredSettings=mSettings.readLPw(this,sUserManager.getUsers(false),mSdkVersion,mOnlyCore);
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX| SCAN_BOOTING;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      boolean didDexOpt=false;
      String bootClassPath=System.getProperty(""String_Node_Str"");
      if (bootClassPath != null) {
        String[] paths=splitString(bootClassPath,':');
        for (int i=0; i < paths.length; i++) {
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
              libFiles.add(paths[i]);
              mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i]);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i] + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
      if (mSharedLibraries.size() > 0) {
        Iterator<SharedLibraryEntry> libs=mSharedLibraries.values().iterator();
        while (libs.hasNext()) {
          String lib=libs.next().path;
          if (lib == null) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
              libFiles.add(lib);
              mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + lib);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + lib + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
      libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
      String[] frameworkFiles=mFrameworkDir.list();
      if (frameworkFiles != null) {
        for (int i=0; i < frameworkFiles.length; i++) {
          File libPath=new File(mFrameworkDir,frameworkFiles[i]);
          String path=libPath.getPath();
          if (libFiles.contains(path)) {
            continue;
          }
          if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(path)) {
              mInstaller.dexopt(path,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + path);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + path,e);
          }
        }
      }
      if (didDexOpt) {
        String[] files=mDalvikCacheDir.list();
        if (files != null) {
          for (int i=0; i < files.length; i++) {
            String fn=files[i];
            if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
              Slog.i(TAG,""String_Node_Str"" + fn);
              (new File(mDalvikCacheDir,fn)).delete();
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX,0);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      mVendorAppDir=new File(""String_Node_Str"");
      mVendorInstallObserver=new AppDirObserver(mVendorAppDir.getPath(),OBSERVER_EVENTS,true);
      mVendorInstallObserver.startWatching();
      scanDirLI(mVendorAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"");
      mInstaller.moveFiles();
      final List<String> possiblyDeletedUpdatedSystemApps=new ArrayList<String>();
      if (!mOnlyCore) {
        Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
        while (psit.hasNext()) {
          PackageSetting ps=psit.next();
          if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            continue;
          }
          final PackageParser.Package scannedPkg=mPackages.get(ps.name);
          if (scannedPkg != null) {
            if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
              Slog.i(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str"");
              removePackageLI(ps,true);
            }
            continue;
          }
          if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {
            psit.remove();
            String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
            reportSettingsProblem(Log.WARN,msg);
            removeDataDirsLI(ps.name);
          }
 else {
            final PackageSetting disabledPs=mSettings.getDisabledSystemPkgLPr(ps.name);
            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {
              possiblyDeletedUpdatedSystemApps.add(ps.name);
            }
          }
        }
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackagesLPr();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      if (!mOnlyCore) {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
        mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
        mAppInstallObserver.startWatching();
        scanDirLI(mAppInstallDir,0,scanMode,0);
        mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
        mDrmAppInstallObserver.startWatching();
        scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode,0);
        for (        String deletedAppName : possiblyDeletedUpdatedSystemApps) {
          PackageParser.Package deletedPkg=mPackages.get(deletedAppName);
          mSettings.removeDisabledSystemPackageLPw(deletedAppName);
          String msg;
          if (deletedPkg == null) {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str"";
            removeDataDirsLI(deletedAppName);
          }
 else {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str""+ deletedAppName;
            deletedPkg.applicationInfo.flags&=~ApplicationInfo.FLAG_SYSTEM;
            PackageSetting deletedPs=mSettings.mPackages.get(deletedAppName);
            deletedPs.pkgFlags&=~ApplicationInfo.FLAG_SYSTEM;
          }
          reportSettingsProblem(Log.WARN,msg);
        }
      }
 else {
        mAppInstallObserver=null;
        mDrmAppInstallObserver=null;
      }
      updateAllSharedLibrariesLPw();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLPw(null,null,UPDATE_PERMISSIONS_ALL | (regrantPermissions ? (UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL) : 0));
      mSettings.writeLPr();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
      mRequiredVerifierPackage=getRequiredVerifierLPr();
    }
  }
}","public PackageManagerService(Context context,Installer installer,boolean factoryTest,boolean onlyCore){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mOnlyCore=onlyCore;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings(context);
  mSettings.addSharedUserLPw(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",RADIO_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",LOG_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",NFC_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",BLUETOOTH_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",SHELL_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  mInstaller=installer;
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      mAppLibInstallDir=new File(dataDir,""String_Node_Str"");
      mAsecInternalPath=new File(dataDir,""String_Node_Str"").getPath();
      mUserAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      sUserManager=new UserManagerService(context,this,mInstallLock,mPackages);
      readPermissions();
      mFoundPolicyFile=SELinuxMMAC.readInstallPolicy();
      mRestoredSettings=mSettings.readLPw(this,sUserManager.getUsers(false),mSdkVersion,mOnlyCore);
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX| SCAN_BOOTING;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      boolean didDexOpt=false;
      String bootClassPath=System.getProperty(""String_Node_Str"");
      if (bootClassPath != null) {
        String[] paths=splitString(bootClassPath,':');
        for (int i=0; i < paths.length; i++) {
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
              libFiles.add(paths[i]);
              mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i]);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i] + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
      if (mSharedLibraries.size() > 0) {
        Iterator<SharedLibraryEntry> libs=mSharedLibraries.values().iterator();
        while (libs.hasNext()) {
          String lib=libs.next().path;
          if (lib == null) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
              libFiles.add(lib);
              mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + lib);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + lib + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
      libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
      String[] frameworkFiles=mFrameworkDir.list();
      if (frameworkFiles != null) {
        for (int i=0; i < frameworkFiles.length; i++) {
          File libPath=new File(mFrameworkDir,frameworkFiles[i]);
          String path=libPath.getPath();
          if (libFiles.contains(path)) {
            continue;
          }
          if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(path)) {
              mInstaller.dexopt(path,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + path);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + path,e);
          }
        }
      }
      if (didDexOpt) {
        String[] files=mDalvikCacheDir.list();
        if (files != null) {
          for (int i=0; i < files.length; i++) {
            String fn=files[i];
            if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
              Slog.i(TAG,""String_Node_Str"" + fn);
              (new File(mDalvikCacheDir,fn)).delete();
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX,0);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      mVendorAppDir=new File(""String_Node_Str"");
      mVendorInstallObserver=new AppDirObserver(mVendorAppDir.getPath(),OBSERVER_EVENTS,true);
      mVendorInstallObserver.startWatching();
      scanDirLI(mVendorAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"");
      mInstaller.moveFiles();
      final List<String> possiblyDeletedUpdatedSystemApps=new ArrayList<String>();
      if (!mOnlyCore) {
        Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
        while (psit.hasNext()) {
          PackageSetting ps=psit.next();
          if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            continue;
          }
          final PackageParser.Package scannedPkg=mPackages.get(ps.name);
          if (scannedPkg != null) {
            if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
              Slog.i(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str"");
              removePackageLI(ps,true);
            }
            continue;
          }
          if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {
            psit.remove();
            String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
            reportSettingsProblem(Log.WARN,msg);
            removeDataDirsLI(ps.name);
          }
 else {
            final PackageSetting disabledPs=mSettings.getDisabledSystemPkgLPr(ps.name);
            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {
              possiblyDeletedUpdatedSystemApps.add(ps.name);
            }
          }
        }
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackagesLPr();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      if (!mOnlyCore) {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
        mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
        mAppInstallObserver.startWatching();
        scanDirLI(mAppInstallDir,0,scanMode,0);
        mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
        mDrmAppInstallObserver.startWatching();
        scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode,0);
        for (        String deletedAppName : possiblyDeletedUpdatedSystemApps) {
          PackageParser.Package deletedPkg=mPackages.get(deletedAppName);
          mSettings.removeDisabledSystemPackageLPw(deletedAppName);
          String msg;
          if (deletedPkg == null) {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str"";
            removeDataDirsLI(deletedAppName);
          }
 else {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str""+ deletedAppName;
            deletedPkg.applicationInfo.flags&=~ApplicationInfo.FLAG_SYSTEM;
            PackageSetting deletedPs=mSettings.mPackages.get(deletedAppName);
            deletedPs.pkgFlags&=~ApplicationInfo.FLAG_SYSTEM;
          }
          reportSettingsProblem(Log.WARN,msg);
        }
      }
 else {
        mAppInstallObserver=null;
        mDrmAppInstallObserver=null;
      }
      updateAllSharedLibrariesLPw();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLPw(null,null,UPDATE_PERMISSIONS_ALL | (regrantPermissions ? (UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL) : 0));
      if (!mRestoredSettings && !onlyCore) {
        mSettings.readDefaultPreferredAppsLPw(this,0);
      }
      mSettings.writeLPr();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
      mRequiredVerifierPackage=getRequiredVerifierLPr();
    }
  }
}"
2460,"boolean readLPw(PackageManagerService service,List<UserInfo> users,int sdkVersion,boolean onlyCore){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPendingPackages.clear();
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
        if (!onlyCore) {
          readDefaultPreferredAppsLPw(service,0);
        }
        mInternalSdkPlatform=mExternalSdkPlatform=sdkVersion;
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"");
      Log.wtf(PackageManagerService.TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLPw(parser,0);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,ATTR_NAME);
        String userStr=parser.getAttributeValue(null,ATTR_USER);
        String codeStr=parser.getAttributeValue(null,ATTR_CODE);
        if (name != null) {
          int userId=0;
          boolean andCode=true;
          try {
            if (userStr != null) {
              userId=Integer.parseInt(userStr);
            }
          }
 catch (          NumberFormatException e) {
          }
          if (codeStr != null) {
            andCode=Boolean.parseBoolean(codeStr);
          }
          addPackageToCleanLPw(new PackageCleanItem(userId,name,andCode));
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mExternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        final String deviceIdentity=parser.getAttributeValue(null,""String_Node_Str"");
        try {
          mVerifierDeviceIdentity=VerifierDeviceIdentity.parse(deviceIdentity);
        }
 catch (        IllegalArgumentException e) {
          Slog.w(PackageManagerService.TAG,""String_Node_Str"" + e.getMessage());
        }
      }
 else       if (TAG_READ_EXTERNAL_STORAGE.equals(tagName)) {
        final String enforcement=parser.getAttributeValue(null,ATTR_ENFORCEMENT);
        mReadExternalStorageEnforced=""String_Node_Str"".equals(enforcement);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mKeySetManager.readKeySetsLPw(parser);
      }
 else {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
  final int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLPr(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLPw(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.nativeLibraryPathString,pp.versionCode,pp.pkgFlags,null,true,false);
      if (p == null) {
        PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
  }
  mPendingPackages.clear();
  if (mBackupStoppedPackagesFilename.exists() || mStoppedPackagesFilename.exists()) {
    readStoppedLPw();
    mBackupStoppedPackagesFilename.delete();
    mStoppedPackagesFilename.delete();
    writePackageRestrictionsLPr(0);
  }
 else {
    if (users == null) {
      readPackageRestrictionsLPr(0);
    }
 else {
      for (      UserInfo user : users) {
        readPackageRestrictionsLPr(user.id);
      }
    }
  }
  final Iterator<PackageSetting> disabledIt=mDisabledSysPackages.values().iterator();
  while (disabledIt.hasNext()) {
    final PackageSetting disabledPs=disabledIt.next();
    final Object id=getUserIdLPr(disabledPs.appId);
    if (id != null && id instanceof SharedUserSetting) {
      disabledPs.sharedUser=(SharedUserSetting)id;
    }
  }
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}","boolean readLPw(PackageManagerService service,List<UserInfo> users,int sdkVersion,boolean onlyCore){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPendingPackages.clear();
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
        mInternalSdkPlatform=mExternalSdkPlatform=sdkVersion;
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"");
      Log.wtf(PackageManagerService.TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLPw(parser,0);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,ATTR_NAME);
        String userStr=parser.getAttributeValue(null,ATTR_USER);
        String codeStr=parser.getAttributeValue(null,ATTR_CODE);
        if (name != null) {
          int userId=0;
          boolean andCode=true;
          try {
            if (userStr != null) {
              userId=Integer.parseInt(userStr);
            }
          }
 catch (          NumberFormatException e) {
          }
          if (codeStr != null) {
            andCode=Boolean.parseBoolean(codeStr);
          }
          addPackageToCleanLPw(new PackageCleanItem(userId,name,andCode));
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mExternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        final String deviceIdentity=parser.getAttributeValue(null,""String_Node_Str"");
        try {
          mVerifierDeviceIdentity=VerifierDeviceIdentity.parse(deviceIdentity);
        }
 catch (        IllegalArgumentException e) {
          Slog.w(PackageManagerService.TAG,""String_Node_Str"" + e.getMessage());
        }
      }
 else       if (TAG_READ_EXTERNAL_STORAGE.equals(tagName)) {
        final String enforcement=parser.getAttributeValue(null,ATTR_ENFORCEMENT);
        mReadExternalStorageEnforced=""String_Node_Str"".equals(enforcement);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mKeySetManager.readKeySetsLPw(parser);
      }
 else {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
  final int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLPr(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLPw(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.nativeLibraryPathString,pp.versionCode,pp.pkgFlags,null,true,false);
      if (p == null) {
        PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
  }
  mPendingPackages.clear();
  if (mBackupStoppedPackagesFilename.exists() || mStoppedPackagesFilename.exists()) {
    readStoppedLPw();
    mBackupStoppedPackagesFilename.delete();
    mStoppedPackagesFilename.delete();
    writePackageRestrictionsLPr(0);
  }
 else {
    if (users == null) {
      readPackageRestrictionsLPr(0);
    }
 else {
      for (      UserInfo user : users) {
        readPackageRestrictionsLPr(user.id);
      }
    }
  }
  final Iterator<PackageSetting> disabledIt=mDisabledSysPackages.values().iterator();
  while (disabledIt.hasNext()) {
    final PackageSetting disabledPs=disabledIt.next();
    final Object id=getUserIdLPr(disabledPs.appId);
    if (id != null && id instanceof SharedUserSetting) {
      disabledPs.sharedUser=(SharedUserSetting)id;
    }
  }
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}"
2461,"public PackageManagerService(Context context,Installer installer,boolean factoryTest,boolean onlyCore){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mOnlyCore=onlyCore;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings(context);
  mSettings.addSharedUserLPw(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",RADIO_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",LOG_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",NFC_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",BLUETOOTH_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",SHELL_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  mInstaller=installer;
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      mAppLibInstallDir=new File(dataDir,""String_Node_Str"");
      mAsecInternalPath=new File(dataDir,""String_Node_Str"").getPath();
      mUserAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      sUserManager=new UserManagerService(context,this,mInstallLock,mPackages);
      readPermissions();
      mFoundPolicyFile=SELinuxMMAC.readInstallPolicy();
      mRestoredSettings=mSettings.readLPw(this,sUserManager.getUsers(false),mSdkVersion,mOnlyCore);
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX| SCAN_BOOTING;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      boolean didDexOpt=false;
      String bootClassPath=System.getProperty(""String_Node_Str"");
      if (bootClassPath != null) {
        String[] paths=splitString(bootClassPath,':');
        for (int i=0; i < paths.length; i++) {
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
              libFiles.add(paths[i]);
              mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i]);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i] + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
      if (mSharedLibraries.size() > 0) {
        Iterator<SharedLibraryEntry> libs=mSharedLibraries.values().iterator();
        while (libs.hasNext()) {
          String lib=libs.next().path;
          if (lib == null) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
              libFiles.add(lib);
              mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + lib);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + lib + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
      libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
      String[] frameworkFiles=mFrameworkDir.list();
      if (frameworkFiles != null) {
        for (int i=0; i < frameworkFiles.length; i++) {
          File libPath=new File(mFrameworkDir,frameworkFiles[i]);
          String path=libPath.getPath();
          if (libFiles.contains(path)) {
            continue;
          }
          if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(path)) {
              mInstaller.dexopt(path,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + path);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + path,e);
          }
        }
      }
      if (didDexOpt) {
        String[] files=mDalvikCacheDir.list();
        if (files != null) {
          for (int i=0; i < files.length; i++) {
            String fn=files[i];
            if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
              Slog.i(TAG,""String_Node_Str"" + fn);
              (new File(mDalvikCacheDir,fn)).delete();
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX,0);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      mVendorAppDir=new File(""String_Node_Str"");
      mVendorInstallObserver=new AppDirObserver(mVendorAppDir.getPath(),OBSERVER_EVENTS,true);
      mVendorInstallObserver.startWatching();
      scanDirLI(mVendorAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"");
      mInstaller.moveFiles();
      final List<String> possiblyDeletedUpdatedSystemApps=new ArrayList<String>();
      if (!mOnlyCore) {
        Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
        while (psit.hasNext()) {
          PackageSetting ps=psit.next();
          if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            continue;
          }
          final PackageParser.Package scannedPkg=mPackages.get(ps.name);
          if (scannedPkg != null) {
            if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
              Slog.i(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str"");
              removePackageLI(ps,true);
            }
            continue;
          }
          if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {
            psit.remove();
            String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
            reportSettingsProblem(Log.WARN,msg);
            removeDataDirsLI(ps.name);
          }
 else {
            final PackageSetting disabledPs=mSettings.getDisabledSystemPkgLPr(ps.name);
            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {
              possiblyDeletedUpdatedSystemApps.add(ps.name);
            }
          }
        }
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackagesLPr();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      if (!mOnlyCore) {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
        mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
        mAppInstallObserver.startWatching();
        scanDirLI(mAppInstallDir,0,scanMode,0);
        mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
        mDrmAppInstallObserver.startWatching();
        scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode,0);
        for (        String deletedAppName : possiblyDeletedUpdatedSystemApps) {
          PackageParser.Package deletedPkg=mPackages.get(deletedAppName);
          mSettings.removeDisabledSystemPackageLPw(deletedAppName);
          String msg;
          if (deletedPkg == null) {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str"";
            removeDataDirsLI(deletedAppName);
          }
 else {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str""+ deletedAppName;
            deletedPkg.applicationInfo.flags&=~ApplicationInfo.FLAG_SYSTEM;
            PackageSetting deletedPs=mSettings.mPackages.get(deletedAppName);
            deletedPs.pkgFlags&=~ApplicationInfo.FLAG_SYSTEM;
          }
          reportSettingsProblem(Log.WARN,msg);
        }
      }
 else {
        mAppInstallObserver=null;
        mDrmAppInstallObserver=null;
      }
      updateAllSharedLibrariesLPw();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLPw(null,null,UPDATE_PERMISSIONS_ALL | (regrantPermissions ? (UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL) : 0));
      mSettings.writeLPr();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
      mRequiredVerifierPackage=getRequiredVerifierLPr();
    }
  }
}","public PackageManagerService(Context context,Installer installer,boolean factoryTest,boolean onlyCore){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mOnlyCore=onlyCore;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings(context);
  mSettings.addSharedUserLPw(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",RADIO_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",LOG_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",NFC_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",BLUETOOTH_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",SHELL_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  mInstaller=installer;
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      mAppLibInstallDir=new File(dataDir,""String_Node_Str"");
      mAsecInternalPath=new File(dataDir,""String_Node_Str"").getPath();
      mUserAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      sUserManager=new UserManagerService(context,this,mInstallLock,mPackages);
      readPermissions();
      mFoundPolicyFile=SELinuxMMAC.readInstallPolicy();
      mRestoredSettings=mSettings.readLPw(this,sUserManager.getUsers(false),mSdkVersion,mOnlyCore);
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX| SCAN_BOOTING;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      boolean didDexOpt=false;
      String bootClassPath=System.getProperty(""String_Node_Str"");
      if (bootClassPath != null) {
        String[] paths=splitString(bootClassPath,':');
        for (int i=0; i < paths.length; i++) {
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
              libFiles.add(paths[i]);
              mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i]);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i] + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
      if (mSharedLibraries.size() > 0) {
        Iterator<SharedLibraryEntry> libs=mSharedLibraries.values().iterator();
        while (libs.hasNext()) {
          String lib=libs.next().path;
          if (lib == null) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
              libFiles.add(lib);
              mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + lib);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + lib + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
      libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
      String[] frameworkFiles=mFrameworkDir.list();
      if (frameworkFiles != null) {
        for (int i=0; i < frameworkFiles.length; i++) {
          File libPath=new File(mFrameworkDir,frameworkFiles[i]);
          String path=libPath.getPath();
          if (libFiles.contains(path)) {
            continue;
          }
          if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(path)) {
              mInstaller.dexopt(path,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + path);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + path,e);
          }
        }
      }
      if (didDexOpt) {
        String[] files=mDalvikCacheDir.list();
        if (files != null) {
          for (int i=0; i < files.length; i++) {
            String fn=files[i];
            if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
              Slog.i(TAG,""String_Node_Str"" + fn);
              (new File(mDalvikCacheDir,fn)).delete();
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX,0);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      mVendorAppDir=new File(""String_Node_Str"");
      mVendorInstallObserver=new AppDirObserver(mVendorAppDir.getPath(),OBSERVER_EVENTS,true);
      mVendorInstallObserver.startWatching();
      scanDirLI(mVendorAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"");
      mInstaller.moveFiles();
      final List<String> possiblyDeletedUpdatedSystemApps=new ArrayList<String>();
      if (!mOnlyCore) {
        Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
        while (psit.hasNext()) {
          PackageSetting ps=psit.next();
          if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            continue;
          }
          final PackageParser.Package scannedPkg=mPackages.get(ps.name);
          if (scannedPkg != null) {
            if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
              Slog.i(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str"");
              removePackageLI(ps,true);
            }
            continue;
          }
          if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {
            psit.remove();
            String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
            reportSettingsProblem(Log.WARN,msg);
            removeDataDirsLI(ps.name);
          }
 else {
            final PackageSetting disabledPs=mSettings.getDisabledSystemPkgLPr(ps.name);
            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {
              possiblyDeletedUpdatedSystemApps.add(ps.name);
            }
          }
        }
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackagesLPr();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      if (!mOnlyCore) {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
        mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
        mAppInstallObserver.startWatching();
        scanDirLI(mAppInstallDir,0,scanMode,0);
        mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
        mDrmAppInstallObserver.startWatching();
        scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode,0);
        for (        String deletedAppName : possiblyDeletedUpdatedSystemApps) {
          PackageParser.Package deletedPkg=mPackages.get(deletedAppName);
          mSettings.removeDisabledSystemPackageLPw(deletedAppName);
          String msg;
          if (deletedPkg == null) {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str"";
            removeDataDirsLI(deletedAppName);
          }
 else {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str""+ deletedAppName;
            deletedPkg.applicationInfo.flags&=~ApplicationInfo.FLAG_SYSTEM;
            PackageSetting deletedPs=mSettings.mPackages.get(deletedAppName);
            deletedPs.pkgFlags&=~ApplicationInfo.FLAG_SYSTEM;
          }
          reportSettingsProblem(Log.WARN,msg);
        }
      }
 else {
        mAppInstallObserver=null;
        mDrmAppInstallObserver=null;
      }
      updateAllSharedLibrariesLPw();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLPw(null,null,UPDATE_PERMISSIONS_ALL | (regrantPermissions ? (UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL) : 0));
      if (!mRestoredSettings && !onlyCore) {
        mSettings.readDefaultPreferredAppsLPw(this,0);
      }
      mSettings.writeLPr();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
      mRequiredVerifierPackage=getRequiredVerifierLPr();
    }
  }
}"
2462,"boolean readLPw(PackageManagerService service,List<UserInfo> users,int sdkVersion,boolean onlyCore){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPendingPackages.clear();
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
        if (!onlyCore) {
          readDefaultPreferredAppsLPw(service,0);
        }
        mInternalSdkPlatform=mExternalSdkPlatform=sdkVersion;
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"");
      Log.wtf(PackageManagerService.TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLPw(parser,0);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,ATTR_NAME);
        String userStr=parser.getAttributeValue(null,ATTR_USER);
        String codeStr=parser.getAttributeValue(null,ATTR_CODE);
        if (name != null) {
          int userId=0;
          boolean andCode=true;
          try {
            if (userStr != null) {
              userId=Integer.parseInt(userStr);
            }
          }
 catch (          NumberFormatException e) {
          }
          if (codeStr != null) {
            andCode=Boolean.parseBoolean(codeStr);
          }
          addPackageToCleanLPw(new PackageCleanItem(userId,name,andCode));
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mExternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        final String deviceIdentity=parser.getAttributeValue(null,""String_Node_Str"");
        try {
          mVerifierDeviceIdentity=VerifierDeviceIdentity.parse(deviceIdentity);
        }
 catch (        IllegalArgumentException e) {
          Slog.w(PackageManagerService.TAG,""String_Node_Str"" + e.getMessage());
        }
      }
 else       if (TAG_READ_EXTERNAL_STORAGE.equals(tagName)) {
        final String enforcement=parser.getAttributeValue(null,ATTR_ENFORCEMENT);
        mReadExternalStorageEnforced=""String_Node_Str"".equals(enforcement);
      }
 else {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
  final int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLPr(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLPw(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.nativeLibraryPathString,pp.versionCode,pp.pkgFlags,null,true,false);
      if (p == null) {
        PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
  }
  mPendingPackages.clear();
  if (mBackupStoppedPackagesFilename.exists() || mStoppedPackagesFilename.exists()) {
    readStoppedLPw();
    mBackupStoppedPackagesFilename.delete();
    mStoppedPackagesFilename.delete();
    writePackageRestrictionsLPr(0);
  }
 else {
    if (users == null) {
      readPackageRestrictionsLPr(0);
    }
 else {
      for (      UserInfo user : users) {
        readPackageRestrictionsLPr(user.id);
      }
    }
  }
  final Iterator<PackageSetting> disabledIt=mDisabledSysPackages.values().iterator();
  while (disabledIt.hasNext()) {
    final PackageSetting disabledPs=disabledIt.next();
    final Object id=getUserIdLPr(disabledPs.appId);
    if (id != null && id instanceof SharedUserSetting) {
      disabledPs.sharedUser=(SharedUserSetting)id;
    }
  }
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}","boolean readLPw(PackageManagerService service,List<UserInfo> users,int sdkVersion,boolean onlyCore){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPendingPackages.clear();
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
        mInternalSdkPlatform=mExternalSdkPlatform=sdkVersion;
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"");
      Log.wtf(PackageManagerService.TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLPw(parser,0);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,ATTR_NAME);
        String userStr=parser.getAttributeValue(null,ATTR_USER);
        String codeStr=parser.getAttributeValue(null,ATTR_CODE);
        if (name != null) {
          int userId=0;
          boolean andCode=true;
          try {
            if (userStr != null) {
              userId=Integer.parseInt(userStr);
            }
          }
 catch (          NumberFormatException e) {
          }
          if (codeStr != null) {
            andCode=Boolean.parseBoolean(codeStr);
          }
          addPackageToCleanLPw(new PackageCleanItem(userId,name,andCode));
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mExternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        final String deviceIdentity=parser.getAttributeValue(null,""String_Node_Str"");
        try {
          mVerifierDeviceIdentity=VerifierDeviceIdentity.parse(deviceIdentity);
        }
 catch (        IllegalArgumentException e) {
          Slog.w(PackageManagerService.TAG,""String_Node_Str"" + e.getMessage());
        }
      }
 else       if (TAG_READ_EXTERNAL_STORAGE.equals(tagName)) {
        final String enforcement=parser.getAttributeValue(null,ATTR_ENFORCEMENT);
        mReadExternalStorageEnforced=""String_Node_Str"".equals(enforcement);
      }
 else {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
  final int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLPr(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLPw(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.nativeLibraryPathString,pp.versionCode,pp.pkgFlags,null,true,false);
      if (p == null) {
        PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
  }
  mPendingPackages.clear();
  if (mBackupStoppedPackagesFilename.exists() || mStoppedPackagesFilename.exists()) {
    readStoppedLPw();
    mBackupStoppedPackagesFilename.delete();
    mStoppedPackagesFilename.delete();
    writePackageRestrictionsLPr(0);
  }
 else {
    if (users == null) {
      readPackageRestrictionsLPr(0);
    }
 else {
      for (      UserInfo user : users) {
        readPackageRestrictionsLPr(user.id);
      }
    }
  }
  final Iterator<PackageSetting> disabledIt=mDisabledSysPackages.values().iterator();
  while (disabledIt.hasNext()) {
    final PackageSetting disabledPs=disabledIt.next();
    final Object id=getUserIdLPr(disabledPs.appId);
    if (id != null && id instanceof SharedUserSetting) {
      disabledPs.sharedUser=(SharedUserSetting)id;
    }
  }
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}"
2463,"public void closeSystemDialogs(String reason){
  enforceNotIsolatedCaller(""String_Node_Str"");
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      if (uid >= Process.FIRST_APPLICATION_UID) {
        ProcessRecord proc;
synchronized (mPidsSelfLocked) {
          proc=mPidsSelfLocked.get(pid);
        }
        if (proc.curRawAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ proc);
          return;
        }
      }
      closeSystemDialogsLocked(reason);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","@Override public void closeSystemDialogs(String reason){
  enforceNotIsolatedCaller(""String_Node_Str"");
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      if (uid >= Process.FIRST_APPLICATION_UID) {
        ProcessRecord proc;
synchronized (mPidsSelfLocked) {
          proc=mPidsSelfLocked.get(pid);
        }
        if (proc.curRawAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ proc);
          return;
        }
      }
      closeSystemDialogsLocked(reason);
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
2464,"public Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids) throws RemoteException {
  enforceNotIsolatedCaller(""String_Node_Str"");
  Debug.MemoryInfo[] infos=new Debug.MemoryInfo[pids.length];
  for (int i=pids.length - 1; i >= 0; i--) {
    infos[i]=new Debug.MemoryInfo();
    Debug.getMemoryInfo(pids[i],infos[i]);
  }
  return infos;
}","@Override public Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids){
  enforceNotIsolatedCaller(""String_Node_Str"");
  Debug.MemoryInfo[] infos=new Debug.MemoryInfo[pids.length];
  for (int i=pids.length - 1; i >= 0; i--) {
    infos[i]=new Debug.MemoryInfo();
    Debug.getMemoryInfo(pids[i],infos[i]);
  }
  return infos;
}"
2465,"public void forceStopPackage(final String packageName,int userId){
  if (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.FORCE_STOP_PACKAGES;
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  userId=handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,true,true,""String_Node_Str"",null);
  long callingId=Binder.clearCallingIdentity();
  try {
    IPackageManager pm=AppGlobals.getPackageManager();
synchronized (this) {
      int[] users=userId == UserHandle.USER_ALL ? getUsersLocked() : new int[]{userId};
      for (      int user : users) {
        int pkgUid=-1;
        try {
          pkgUid=pm.getPackageUid(packageName,user);
        }
 catch (        RemoteException e) {
        }
        if (pkgUid == -1) {
          Slog.w(TAG,""String_Node_Str"" + packageName);
          continue;
        }
        try {
          pm.setPackageStoppedState(packageName,true,user);
        }
 catch (        RemoteException e) {
        }
catch (        IllegalArgumentException e) {
          Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ e);
        }
        if (isUserRunningLocked(user,false)) {
          forceStopPackageLocked(packageName,pkgUid);
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingId);
  }
}","@Override public void forceStopPackage(final String packageName,int userId){
  if (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.FORCE_STOP_PACKAGES;
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  userId=handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,true,true,""String_Node_Str"",null);
  long callingId=Binder.clearCallingIdentity();
  try {
    IPackageManager pm=AppGlobals.getPackageManager();
synchronized (this) {
      int[] users=userId == UserHandle.USER_ALL ? getUsersLocked() : new int[]{userId};
      for (      int user : users) {
        int pkgUid=-1;
        try {
          pkgUid=pm.getPackageUid(packageName,user);
        }
 catch (        RemoteException e) {
        }
        if (pkgUid == -1) {
          Slog.w(TAG,""String_Node_Str"" + packageName);
          continue;
        }
        try {
          pm.setPackageStoppedState(packageName,true,user);
        }
 catch (        RemoteException e) {
        }
catch (        IllegalArgumentException e) {
          Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ e);
        }
        if (isUserRunningLocked(user,false)) {
          forceStopPackageLocked(packageName,pkgUid);
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingId);
  }
}"
2466,"public void killApplicationWithAppId(String pkg,int appid){
  if (pkg == null) {
    return;
  }
  if (appid < 0) {
    Slog.w(TAG,""String_Node_Str"" + pkg);
    return;
  }
  int callerUid=Binder.getCallingUid();
  if (callerUid == Process.SYSTEM_UID) {
    Message msg=mHandler.obtainMessage(KILL_APPLICATION_MSG);
    msg.arg1=appid;
    msg.arg2=0;
    msg.obj=pkg;
    mHandler.sendMessage(msg);
  }
 else {
    throw new SecurityException(callerUid + ""String_Node_Str"" + pkg);
  }
}","@Override public void killApplicationWithAppId(String pkg,int appid){
  if (pkg == null) {
    return;
  }
  if (appid < 0) {
    Slog.w(TAG,""String_Node_Str"" + pkg);
    return;
  }
  int callerUid=Binder.getCallingUid();
  if (callerUid == Process.SYSTEM_UID) {
    Message msg=mHandler.obtainMessage(KILL_APPLICATION_MSG);
    msg.arg1=appid;
    msg.arg2=0;
    msg.obj=pkg;
    mHandler.sendMessage(msg);
  }
 else {
    throw new SecurityException(callerUid + ""String_Node_Str"" + pkg);
  }
}"
2467,"final ActivityRecord activityIdleInternalLocked(IBinder token,boolean fromTimeout,Configuration config){
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + token);
  ActivityRecord res=null;
  ArrayList<ActivityRecord> stops=null;
  ArrayList<ActivityRecord> finishes=null;
  ArrayList<ActivityRecord> thumbnails=null;
  ArrayList<UserStartedState> startingUsers=null;
  int NS=0;
  int NF=0;
  int NT=0;
  IApplicationThread sendThumbnail=null;
  boolean booting=false;
  boolean enableScreen=false;
  boolean activityRemoved=false;
  ActivityRecord r=ActivityRecord.forToken(token);
  if (r != null) {
    mHandler.removeMessages(IDLE_TIMEOUT_MSG,r);
    r.finishLaunchTickingLocked();
  }
  if (isInStackLocked(token) != null) {
    res=r;
    if (fromTimeout) {
      reportActivityLaunchedLocked(fromTimeout,r,-1,-1);
    }
    if (config != null) {
      r.configuration=config;
    }
    if (mResumedActivity == r && mLaunchingActivity.isHeld()) {
      mHandler.removeMessages(LAUNCH_TIMEOUT_MSG);
      mLaunchingActivity.release();
    }
    r.idle=true;
    mService.scheduleAppGcsLocked();
    if (r.thumbnailNeeded && r.app != null && r.app.thread != null) {
      sendThumbnail=r.app.thread;
      r.thumbnailNeeded=false;
    }
    if (DEBUG_VISBILITY)     Slog.v(TAG,""String_Node_Str"" + r);
    ensureActivitiesVisibleLocked(null,0);
    if (mStackSupervisor.isMainStack(this)) {
      if (!mService.mBooted) {
        mService.mBooted=true;
        enableScreen=true;
      }
    }
  }
 else   if (fromTimeout) {
    reportActivityLaunchedLocked(fromTimeout,null,-1,-1);
  }
  stops=processStoppingActivitiesLocked(true);
  NS=stops != null ? stops.size() : 0;
  if ((NF=mFinishingActivities.size()) > 0) {
    finishes=new ArrayList<ActivityRecord>(mFinishingActivities);
    mFinishingActivities.clear();
  }
  if ((NT=mCancelledThumbnails.size()) > 0) {
    thumbnails=new ArrayList<ActivityRecord>(mCancelledThumbnails);
    mCancelledThumbnails.clear();
  }
  if (mStackSupervisor.isMainStack(this)) {
    booting=mService.mBooting;
    mService.mBooting=false;
  }
  if (mStartingUsers.size() > 0) {
    startingUsers=new ArrayList<UserStartedState>(mStartingUsers);
    mStartingUsers.clear();
  }
  int i;
  if (sendThumbnail != null) {
    try {
      sendThumbnail.requestThumbnail(token);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"",e);
      mService.sendPendingThumbnail(null,token,null,null,true);
    }
  }
  for (i=0; i < NS; i++) {
    r=stops.get(i);
synchronized (mService) {
      if (r.finishing) {
        finishCurrentActivityLocked(r,FINISH_IMMEDIATELY,false);
      }
 else {
        stopActivityLocked(r);
      }
    }
  }
  for (i=0; i < NF; i++) {
    r=finishes.get(i);
synchronized (mService) {
      activityRemoved=destroyActivityLocked(r,true,false,""String_Node_Str"");
    }
  }
  for (i=0; i < NT; i++) {
    r=thumbnails.get(i);
    mService.sendPendingThumbnail(r,null,null,null,true);
  }
  if (booting) {
    mService.finishBooting();
  }
 else   if (startingUsers != null) {
    for (i=0; i < startingUsers.size(); i++) {
      mService.finishUserSwitch(startingUsers.get(i));
    }
  }
  mService.trimApplications();
  if (enableScreen) {
    mService.enableScreenAfterBoot();
  }
  if (activityRemoved) {
    resumeTopActivityLocked(null);
  }
  return res;
}","final ActivityRecord activityIdleInternalLocked(final IBinder token,boolean fromTimeout,Configuration config){
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + token);
  ActivityRecord res=null;
  ArrayList<ActivityRecord> stops=null;
  ArrayList<ActivityRecord> finishes=null;
  ArrayList<UserStartedState> startingUsers=null;
  int NS=0;
  int NF=0;
  IApplicationThread sendThumbnail=null;
  boolean booting=false;
  boolean enableScreen=false;
  boolean activityRemoved=false;
  ActivityRecord r=ActivityRecord.forToken(token);
  if (r != null) {
    mHandler.removeMessages(IDLE_TIMEOUT_MSG,r);
    r.finishLaunchTickingLocked();
  }
  if (isInStackLocked(token) != null) {
    res=r;
    if (fromTimeout) {
      reportActivityLaunchedLocked(fromTimeout,r,-1,-1);
    }
    if (config != null) {
      r.configuration=config;
    }
    if (mResumedActivity == r && mLaunchingActivity.isHeld()) {
      mHandler.removeMessages(LAUNCH_TIMEOUT_MSG);
      mLaunchingActivity.release();
    }
    r.idle=true;
    if (mStackSupervisor.allResumedActivitiesIdle()) {
      mService.scheduleAppGcsLocked();
    }
    if (r.thumbnailNeeded && r.app != null && r.app.thread != null) {
      sendThumbnail=r.app.thread;
      r.thumbnailNeeded=false;
    }
    if (DEBUG_VISBILITY)     Slog.v(TAG,""String_Node_Str"" + r);
    ensureActivitiesVisibleLocked(null,0);
    if (!mService.mBooted && mStackSupervisor.isMainStack(this)) {
      mService.mBooted=true;
      enableScreen=true;
    }
  }
 else   if (fromTimeout) {
    reportActivityLaunchedLocked(fromTimeout,null,-1,-1);
  }
  stops=processStoppingActivitiesLocked(true);
  NS=stops != null ? stops.size() : 0;
  if ((NF=mFinishingActivities.size()) > 0) {
    finishes=new ArrayList<ActivityRecord>(mFinishingActivities);
    mFinishingActivities.clear();
  }
  final ArrayList<ActivityRecord> thumbnails;
  final int NT=mCancelledThumbnails.size();
  if (NT > 0) {
    thumbnails=new ArrayList<ActivityRecord>(mCancelledThumbnails);
    mCancelledThumbnails.clear();
  }
 else {
    thumbnails=null;
  }
  if (mStackSupervisor.isMainStack(this)) {
    booting=mService.mBooting;
    mService.mBooting=false;
  }
  if (mStartingUsers.size() > 0) {
    startingUsers=new ArrayList<UserStartedState>(mStartingUsers);
    mStartingUsers.clear();
  }
  final IApplicationThread thumbnailThread=sendThumbnail;
  mHandler.post(new Runnable(){
    @Override public void run(){
      if (thumbnailThread != null) {
        try {
          thumbnailThread.requestThumbnail(token);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"",e);
          mService.sendPendingThumbnail(null,token,null,null,true);
        }
      }
      for (int i=0; i < NT; i++) {
        ActivityRecord r=thumbnails.get(i);
        mService.sendPendingThumbnail(r,null,null,null,true);
      }
    }
  }
);
  for (int i=0; i < NS; i++) {
    r=stops.get(i);
    if (r.finishing) {
      finishCurrentActivityLocked(r,FINISH_IMMEDIATELY,false);
    }
 else {
      stopActivityLocked(r);
    }
  }
  for (int i=0; i < NF; i++) {
    r=finishes.get(i);
    activityRemoved|=destroyActivityLocked(r,true,false,""String_Node_Str"");
  }
  if (booting) {
    mService.finishBooting();
  }
 else   if (startingUsers != null) {
    for (int i=0; i < startingUsers.size(); i++) {
      mService.finishUserSwitch(startingUsers.get(i));
    }
  }
  mService.trimApplications();
  if (enableScreen) {
    mService.enableScreenAfterBoot();
  }
  if (activityRemoved) {
    resumeTopActivityLocked(null);
  }
  return res;
}"
2468,"void resumeTopActivityLocked(){
  final int start, end;
  if (isHomeStackMain()) {
    start=0;
    end=1;
  }
 else {
    start=1;
    end=mStacks.size();
  }
  for (int stackNdx=start; stackNdx < end; ++stackNdx) {
    mStacks.get(stackNdx).resumeTopActivityLocked(null);
  }
}","void resumeTopActivityLocked(){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    mStacks.get(stackNdx).resumeTopActivityLocked(null);
  }
}"
2469,"boolean allResumedActivitiesIdle(){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    if (mStacks.get(stackNdx).mResumedActivity == null || !mStacks.get(stackNdx).mResumedActivity.idle) {
      return false;
    }
  }
  return true;
}","boolean allResumedActivitiesIdle(){
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    final ActivityRecord resumedActivity=mStacks.get(stackNdx).mResumedActivity;
    if (resumedActivity == null || !resumedActivity.idle) {
      return false;
    }
  }
  return true;
}"
2470,"/** 
 * Creates a new worker thread and saves the screenshot to the media store.
 */
private void saveScreenshotInWorkerThread(Runnable finisher){
  Log.d(TAG,""String_Node_Str"");
  SaveImageInBackgroundData data=new SaveImageInBackgroundData();
  data.context=mContext;
  data.image=mScreenBitmap;
  data.iconSize=mNotificationIconSize;
  data.finisher=finisher;
  if (mSaveInBgTask != null) {
    mSaveInBgTask.cancel(false);
    Log.d(TAG,""String_Node_Str"");
  }
  mSaveInBgTask=new SaveImageInBackgroundTask(mContext,data,mNotificationManager,SCREENSHOT_NOTIFICATION_ID).execute(data);
}","/** 
 * Creates a new worker thread and saves the screenshot to the media store.
 */
private void saveScreenshotInWorkerThread(Runnable finisher){
  SaveImageInBackgroundData data=new SaveImageInBackgroundData();
  data.context=mContext;
  data.image=mScreenBitmap;
  data.iconSize=mNotificationIconSize;
  data.finisher=finisher;
  if (mSaveInBgTask != null) {
    mSaveInBgTask.cancel(false);
  }
  mSaveInBgTask=new SaveImageInBackgroundTask(mContext,data,mNotificationManager,SCREENSHOT_NOTIFICATION_ID).execute(data);
}"
2471,"static void notifyScreenshotError(Context context,NotificationManager nManager){
  Log.d(TAG,""String_Node_Str"");
  Resources r=context.getResources();
  Notification.Builder b=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_failed_title)).setContentTitle(r.getString(R.string.screenshot_failed_title)).setContentText(r.getString(R.string.screenshot_failed_text)).setSmallIcon(R.drawable.stat_notify_image_error).setWhen(System.currentTimeMillis()).setAutoCancel(true);
  Notification n=new Notification.BigTextStyle(b).bigText(r.getString(R.string.screenshot_failed_text)).build();
  nManager.notify(SCREENSHOT_NOTIFICATION_ID,n);
}","static void notifyScreenshotError(Context context,NotificationManager nManager){
  Resources r=context.getResources();
  Notification.Builder b=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_failed_title)).setContentTitle(r.getString(R.string.screenshot_failed_title)).setContentText(r.getString(R.string.screenshot_failed_text)).setSmallIcon(R.drawable.stat_notify_image_error).setWhen(System.currentTimeMillis()).setAutoCancel(true);
  Notification n=new Notification.BigTextStyle(b).bigText(r.getString(R.string.screenshot_failed_text)).build();
  nManager.notify(SCREENSHOT_NOTIFICATION_ID,n);
}"
2472,"@Override public void run(){
  mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
  mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE,null);
  mScreenshotView.buildLayer();
  mScreenshotAnimation.start();
  Log.d(TAG,""String_Node_Str"");
}","@Override public void run(){
  mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
  mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE,null);
  mScreenshotView.buildLayer();
  mScreenshotAnimation.start();
}"
2473,"/** 
 * @param context everything needs a context :(
 */
public GlobalScreenshot(Context context){
  Resources r=context.getResources();
  mContext=context;
  LayoutInflater layoutInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mDisplayMatrix=new Matrix();
  mScreenshotLayout=layoutInflater.inflate(R.layout.global_screenshot,null);
  mBackgroundView=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot_background);
  mScreenshotView=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot);
  mScreenshotFlash=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot_flash);
  mScreenshotLayout.setFocusable(true);
  mScreenshotLayout.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      return true;
    }
  }
);
  mWindowLayoutParams=new WindowManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT,0,0,WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY,WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED,PixelFormat.TRANSLUCENT);
  mWindowLayoutParams.setTitle(""String_Node_Str"");
  mWindowManager=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  mNotificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
  mDisplay=mWindowManager.getDefaultDisplay();
  mDisplayMetrics=new DisplayMetrics();
  mDisplay.getRealMetrics(mDisplayMetrics);
  mNotificationIconSize=r.getDimensionPixelSize(android.R.dimen.notification_large_icon_height);
  mBgPadding=(float)r.getDimensionPixelSize(R.dimen.global_screenshot_bg_padding);
  mBgPaddingScale=mBgPadding / mDisplayMetrics.widthPixels;
  mCameraSound=new MediaActionSound();
  mCameraSound.load(MediaActionSound.SHUTTER_CLICK);
  Log.d(TAG,""String_Node_Str"");
}","/** 
 * @param context everything needs a context :(
 */
public GlobalScreenshot(Context context){
  Resources r=context.getResources();
  mContext=context;
  LayoutInflater layoutInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mDisplayMatrix=new Matrix();
  mScreenshotLayout=layoutInflater.inflate(R.layout.global_screenshot,null);
  mBackgroundView=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot_background);
  mScreenshotView=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot);
  mScreenshotFlash=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot_flash);
  mScreenshotLayout.setFocusable(true);
  mScreenshotLayout.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      return true;
    }
  }
);
  mWindowLayoutParams=new WindowManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT,0,0,WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY,WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED,PixelFormat.TRANSLUCENT);
  mWindowLayoutParams.setTitle(""String_Node_Str"");
  mWindowManager=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  mNotificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
  mDisplay=mWindowManager.getDefaultDisplay();
  mDisplayMetrics=new DisplayMetrics();
  mDisplay.getRealMetrics(mDisplayMetrics);
  mNotificationIconSize=r.getDimensionPixelSize(android.R.dimen.notification_large_icon_height);
  mBgPadding=(float)r.getDimensionPixelSize(R.dimen.global_screenshot_bg_padding);
  mBgPaddingScale=mBgPadding / mDisplayMetrics.widthPixels;
  mCameraSound=new MediaActionSound();
  mCameraSound.load(MediaActionSound.SHUTTER_CLICK);
}"
2474,"/** 
 * Starts the animation after taking the screenshot
 */
private void startAnimation(final Runnable finisher,int w,int h,boolean statusBarVisible,boolean navBarVisible){
  Log.d(TAG,""String_Node_Str"");
  mScreenshotView.setImageBitmap(mScreenBitmap);
  mScreenshotLayout.requestFocus();
  if (mScreenshotAnimation != null) {
    mScreenshotAnimation.end();
    mScreenshotAnimation.removeAllListeners();
    Log.d(TAG,""String_Node_Str"");
  }
  mWindowManager.addView(mScreenshotLayout,mWindowLayoutParams);
  Log.d(TAG,""String_Node_Str"");
  ValueAnimator screenshotDropInAnim=createScreenshotDropInAnimation();
  ValueAnimator screenshotFadeOutAnim=createScreenshotDropOutAnimation(w,h,statusBarVisible,navBarVisible);
  mScreenshotAnimation=new AnimatorSet();
  mScreenshotAnimation.playSequentially(screenshotDropInAnim,screenshotFadeOutAnim);
  mScreenshotAnimation.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      saveScreenshotInWorkerThread(finisher);
      mWindowManager.removeView(mScreenshotLayout);
      mScreenBitmap=null;
      mScreenshotView.setImageBitmap(null);
      Log.d(TAG,""String_Node_Str"");
    }
  }
);
  mScreenshotLayout.post(new Runnable(){
    @Override public void run(){
      mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
      mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE,null);
      mScreenshotView.buildLayer();
      mScreenshotAnimation.start();
      Log.d(TAG,""String_Node_Str"");
    }
  }
);
}","/** 
 * Starts the animation after taking the screenshot
 */
private void startAnimation(final Runnable finisher,int w,int h,boolean statusBarVisible,boolean navBarVisible){
  mScreenshotView.setImageBitmap(mScreenBitmap);
  mScreenshotLayout.requestFocus();
  if (mScreenshotAnimation != null) {
    mScreenshotAnimation.end();
    mScreenshotAnimation.removeAllListeners();
  }
  mWindowManager.addView(mScreenshotLayout,mWindowLayoutParams);
  ValueAnimator screenshotDropInAnim=createScreenshotDropInAnimation();
  ValueAnimator screenshotFadeOutAnim=createScreenshotDropOutAnimation(w,h,statusBarVisible,navBarVisible);
  mScreenshotAnimation=new AnimatorSet();
  mScreenshotAnimation.playSequentially(screenshotDropInAnim,screenshotFadeOutAnim);
  mScreenshotAnimation.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      saveScreenshotInWorkerThread(finisher);
      mWindowManager.removeView(mScreenshotLayout);
      mScreenBitmap=null;
      mScreenshotView.setImageBitmap(null);
    }
  }
);
  mScreenshotLayout.post(new Runnable(){
    @Override public void run(){
      mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
      mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE,null);
      mScreenshotView.buildLayer();
      mScreenshotAnimation.start();
    }
  }
);
}"
2475,"SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  final int shortSide=mImageWidth < mImageHeight ? mImageWidth : mImageHeight;
  Bitmap preview=Bitmap.createBitmap(shortSide,shortSide,data.image.getConfig());
  Canvas c=new Canvas(preview);
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  matrix.postTranslate((shortSide - mImageWidth) / 2,(shortSide - mImageHeight) / 2);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(0x40FFFFFF);
  c.setBitmap(null);
  Bitmap croppedIcon=Bitmap.createScaledBitmap(preview,iconSize,iconSize,true);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(System.currentTimeMillis());
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(preview);
  mNotificationBuilder.setStyle(mNotificationStyle);
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(croppedIcon);
  mNotificationStyle.bigLargeIcon(null);
  Log.d(TAG,""String_Node_Str"");
}","SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  final int shortSide=mImageWidth < mImageHeight ? mImageWidth : mImageHeight;
  Bitmap preview=Bitmap.createBitmap(shortSide,shortSide,data.image.getConfig());
  Canvas c=new Canvas(preview);
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  matrix.postTranslate((shortSide - mImageWidth) / 2,(shortSide - mImageHeight) / 2);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(0x40FFFFFF);
  c.setBitmap(null);
  Bitmap croppedIcon=Bitmap.createScaledBitmap(preview,iconSize,iconSize,true);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(System.currentTimeMillis());
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(preview);
  mNotificationBuilder.setStyle(mNotificationStyle);
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(croppedIcon);
  mNotificationStyle.bigLargeIcon(null);
}"
2476,"/** 
 * Takes a screenshot of the current display and shows an animation.
 */
void takeScreenshot(Runnable finisher,boolean statusBarVisible,boolean navBarVisible){
  Log.d(TAG,""String_Node_Str"");
  mDisplay.getRealMetrics(mDisplayMetrics);
  float[] dims={mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels};
  float degrees=getDegreesForRotation(mDisplay.getRotation());
  boolean requiresRotation=(degrees > 0);
  if (requiresRotation) {
    mDisplayMatrix.reset();
    mDisplayMatrix.preRotate(-degrees);
    mDisplayMatrix.mapPoints(dims);
    dims[0]=Math.abs(dims[0]);
    dims[1]=Math.abs(dims[1]);
    Log.d(TAG,""String_Node_Str"");
  }
  mScreenBitmap=SurfaceControl.screenshot((int)dims[0],(int)dims[1]);
  if (mScreenBitmap == null) {
    notifyScreenshotError(mContext,mNotificationManager);
    finisher.run();
    Log.d(TAG,""String_Node_Str"");
    return;
  }
  if (requiresRotation) {
    Bitmap ss=Bitmap.createBitmap(mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(ss);
    c.translate(ss.getWidth() / 2,ss.getHeight() / 2);
    c.rotate(degrees);
    c.translate(-dims[0] / 2,-dims[1] / 2);
    c.drawBitmap(mScreenBitmap,0,0,null);
    c.setBitmap(null);
    mScreenBitmap.recycle();
    mScreenBitmap=ss;
    Log.d(TAG,""String_Node_Str"");
  }
  mScreenBitmap.setHasAlpha(false);
  mScreenBitmap.prepareToDraw();
  startAnimation(finisher,mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels,statusBarVisible,navBarVisible);
  Log.d(TAG,""String_Node_Str"");
}","/** 
 * Takes a screenshot of the current display and shows an animation.
 */
void takeScreenshot(Runnable finisher,boolean statusBarVisible,boolean navBarVisible){
  mDisplay.getRealMetrics(mDisplayMetrics);
  float[] dims={mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels};
  float degrees=getDegreesForRotation(mDisplay.getRotation());
  boolean requiresRotation=(degrees > 0);
  if (requiresRotation) {
    mDisplayMatrix.reset();
    mDisplayMatrix.preRotate(-degrees);
    mDisplayMatrix.mapPoints(dims);
    dims[0]=Math.abs(dims[0]);
    dims[1]=Math.abs(dims[1]);
  }
  mScreenBitmap=SurfaceControl.screenshot((int)dims[0],(int)dims[1]);
  if (mScreenBitmap == null) {
    notifyScreenshotError(mContext,mNotificationManager);
    finisher.run();
    return;
  }
  if (requiresRotation) {
    Bitmap ss=Bitmap.createBitmap(mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(ss);
    c.translate(ss.getWidth() / 2,ss.getHeight() / 2);
    c.rotate(degrees);
    c.translate(-dims[0] / 2,-dims[1] / 2);
    c.drawBitmap(mScreenBitmap,0,0,null);
    c.setBitmap(null);
    mScreenBitmap.recycle();
    mScreenBitmap=ss;
  }
  mScreenBitmap.setHasAlpha(false);
  mScreenBitmap.prepareToDraw();
  startAnimation(finisher,mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels,statusBarVisible,navBarVisible);
}"
2477,"void clearImage(){
  context=null;
  image=null;
  imageUri=null;
  iconSize=0;
}","void clearImage(){
  image=null;
  imageUri=null;
  iconSize=0;
}"
2478,"@Override protected SaveImageInBackgroundData doInBackground(SaveImageInBackgroundData... params){
  if (params.length != 1)   return null;
  if (isCancelled()) {
    params[0].clearImage();
    Log.d(TAG,""String_Node_Str"");
    return null;
  }
  Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
  Context context=params[0].context;
  Bitmap image=params[0].image;
  Resources r=context.getResources();
  try {
    mScreenshotDir.mkdirs();
    ContentValues values=new ContentValues();
    ContentResolver resolver=context.getContentResolver();
    values.put(MediaStore.Images.ImageColumns.DATA,mImageFilePath);
    values.put(MediaStore.Images.ImageColumns.TITLE,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DISPLAY_NAME,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DATE_TAKEN,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_ADDED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_MODIFIED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.MIME_TYPE,""String_Node_Str"");
    values.put(MediaStore.Images.ImageColumns.WIDTH,mImageWidth);
    values.put(MediaStore.Images.ImageColumns.HEIGHT,mImageHeight);
    Uri uri=resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,values);
    String subjectDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
    String subject=String.format(SCREENSHOT_SHARE_SUBJECT_TEMPLATE,subjectDate);
    Intent sharingIntent=new Intent(Intent.ACTION_SEND);
    sharingIntent.setType(""String_Node_Str"");
    sharingIntent.putExtra(Intent.EXTRA_STREAM,uri);
    sharingIntent.putExtra(Intent.EXTRA_SUBJECT,subject);
    Intent chooserIntent=Intent.createChooser(sharingIntent,null);
    chooserIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.addAction(R.drawable.ic_menu_share,r.getString(com.android.internal.R.string.share),PendingIntent.getActivity(context,0,chooserIntent,PendingIntent.FLAG_CANCEL_CURRENT));
    OutputStream out=resolver.openOutputStream(uri);
    image.compress(Bitmap.CompressFormat.PNG,100,out);
    out.flush();
    out.close();
    values.clear();
    values.put(MediaStore.Images.ImageColumns.SIZE,new File(mImageFilePath).length());
    resolver.update(uri,values,null,null);
    params[0].imageUri=uri;
    params[0].image=null;
    params[0].result=0;
  }
 catch (  Exception e) {
    params[0].clearImage();
    params[0].result=1;
    Log.d(TAG,""String_Node_Str"");
  }
  if (image != null) {
    image.recycle();
  }
  Log.d(TAG,""String_Node_Str"");
  return params[0];
}","@Override protected SaveImageInBackgroundData doInBackground(SaveImageInBackgroundData... params){
  if (params.length != 1)   return null;
  if (isCancelled()) {
    params[0].clearImage();
    params[0].clearContext();
    return null;
  }
  Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
  Context context=params[0].context;
  Bitmap image=params[0].image;
  Resources r=context.getResources();
  try {
    mScreenshotDir.mkdirs();
    ContentValues values=new ContentValues();
    ContentResolver resolver=context.getContentResolver();
    values.put(MediaStore.Images.ImageColumns.DATA,mImageFilePath);
    values.put(MediaStore.Images.ImageColumns.TITLE,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DISPLAY_NAME,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DATE_TAKEN,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_ADDED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_MODIFIED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.MIME_TYPE,""String_Node_Str"");
    values.put(MediaStore.Images.ImageColumns.WIDTH,mImageWidth);
    values.put(MediaStore.Images.ImageColumns.HEIGHT,mImageHeight);
    Uri uri=resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,values);
    String subjectDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
    String subject=String.format(SCREENSHOT_SHARE_SUBJECT_TEMPLATE,subjectDate);
    Intent sharingIntent=new Intent(Intent.ACTION_SEND);
    sharingIntent.setType(""String_Node_Str"");
    sharingIntent.putExtra(Intent.EXTRA_STREAM,uri);
    sharingIntent.putExtra(Intent.EXTRA_SUBJECT,subject);
    Intent chooserIntent=Intent.createChooser(sharingIntent,null);
    chooserIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.addAction(R.drawable.ic_menu_share,r.getString(com.android.internal.R.string.share),PendingIntent.getActivity(context,0,chooserIntent,PendingIntent.FLAG_CANCEL_CURRENT));
    OutputStream out=resolver.openOutputStream(uri);
    image.compress(Bitmap.CompressFormat.PNG,100,out);
    out.flush();
    out.close();
    values.clear();
    values.put(MediaStore.Images.ImageColumns.SIZE,new File(mImageFilePath).length());
    resolver.update(uri,values,null,null);
    params[0].imageUri=uri;
    params[0].image=null;
    params[0].result=0;
  }
 catch (  Exception e) {
    params[0].clearImage();
    params[0].result=1;
  }
  if (image != null) {
    image.recycle();
  }
  return params[0];
}"
2479,"@Override protected void onPostExecute(SaveImageInBackgroundData params){
  if (isCancelled()) {
    params.finisher.run();
    params.clearImage();
    Log.d(TAG,""String_Node_Str"");
    return;
  }
  if (params.result > 0) {
    GlobalScreenshot.notifyScreenshotError(params.context,mNotificationManager);
  }
 else {
    Resources r=params.context.getResources();
    Intent launchIntent=new Intent(Intent.ACTION_VIEW);
    launchIntent.setDataAndType(params.imageUri,""String_Node_Str"");
    launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.setContentTitle(r.getString(R.string.screenshot_saved_title)).setContentText(r.getString(R.string.screenshot_saved_text)).setContentIntent(PendingIntent.getActivity(params.context,0,launchIntent,0)).setWhen(System.currentTimeMillis()).setAutoCancel(true);
    Notification n=mNotificationBuilder.build();
    n.flags&=~Notification.FLAG_NO_CLEAR;
    mNotificationManager.notify(mNotificationId,n);
  }
  params.finisher.run();
  Log.d(TAG,""String_Node_Str"");
}","@Override protected void onPostExecute(SaveImageInBackgroundData params){
  if (isCancelled()) {
    params.finisher.run();
    params.clearImage();
    params.clearContext();
    return;
  }
  if (params.result > 0) {
    GlobalScreenshot.notifyScreenshotError(params.context,mNotificationManager);
  }
 else {
    Resources r=params.context.getResources();
    Intent launchIntent=new Intent(Intent.ACTION_VIEW);
    launchIntent.setDataAndType(params.imageUri,""String_Node_Str"");
    launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.setContentTitle(r.getString(R.string.screenshot_saved_title)).setContentText(r.getString(R.string.screenshot_saved_text)).setContentIntent(PendingIntent.getActivity(params.context,0,launchIntent,0)).setWhen(System.currentTimeMillis()).setAutoCancel(true);
    Notification n=mNotificationBuilder.build();
    n.flags&=~Notification.FLAG_NO_CLEAR;
    mNotificationManager.notify(mNotificationId,n);
  }
  params.finisher.run();
  params.clearContext();
}"
2480,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case 1:
    final Messenger callback=msg.replyTo;
  if (mScreenshot == null) {
    mScreenshot=new GlobalScreenshot(TakeScreenshotService.this);
    Log.d(TAG,""String_Node_Str"");
  }
Log.d(TAG,""String_Node_Str"");
mScreenshot.takeScreenshot(new Runnable(){
@Override public void run(){
  Message reply=Message.obtain(null,1);
  try {
    callback.send(reply);
    Log.d(TAG,""String_Node_Str"");
  }
 catch (  RemoteException e) {
  }
}
}
,msg.arg1 > 0,msg.arg2 > 0);
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case 1:
    final Messenger callback=msg.replyTo;
  if (mScreenshot == null) {
    mScreenshot=new GlobalScreenshot(TakeScreenshotService.this);
  }
mScreenshot.takeScreenshot(new Runnable(){
  @Override public void run(){
    Message reply=Message.obtain(null,1);
    try {
      callback.send(reply);
    }
 catch (    RemoteException e) {
    }
  }
}
,msg.arg1 > 0,msg.arg2 > 0);
}
}"
2481,"@Override public void run(){
  Message reply=Message.obtain(null,1);
  try {
    callback.send(reply);
    Log.d(TAG,""String_Node_Str"");
  }
 catch (  RemoteException e) {
  }
}","@Override public void run(){
  Message reply=Message.obtain(null,1);
  try {
    callback.send(reply);
  }
 catch (  RemoteException e) {
  }
}"
2482,"public PackageManagerService(Context context,Installer installer,boolean factoryTest,boolean onlyCore){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mOnlyCore=onlyCore;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings(context);
  mSettings.addSharedUserLPw(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",RADIO_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",LOG_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",NFC_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",BLUETOOTH_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",SHELL_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  mInstaller=installer;
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      mAppLibInstallDir=new File(dataDir,""String_Node_Str"");
      mAsecInternalPath=new File(dataDir,""String_Node_Str"").getPath();
      mUserAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      sUserManager=new UserManagerService(context,this,mInstallLock,mPackages);
      readPermissions();
      mFoundPolicyFile=SELinuxMMAC.readInstallPolicy();
      mRestoredSettings=mSettings.readLPw(this,sUserManager.getUsers(false),mSdkVersion,mOnlyCore);
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX| SCAN_BOOTING;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      boolean didDexOpt=false;
      String bootClassPath=System.getProperty(""String_Node_Str"");
      if (bootClassPath != null) {
        String[] paths=splitString(bootClassPath,':');
        for (int i=0; i < paths.length; i++) {
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
              libFiles.add(paths[i]);
              mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i]);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i] + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
      if (mSharedLibraries.size() > 0) {
        Iterator<SharedLibraryEntry> libs=mSharedLibraries.values().iterator();
        while (libs.hasNext()) {
          String lib=libs.next().path;
          if (lib == null) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
              libFiles.add(lib);
              mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + lib);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + lib + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
      libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
      String[] frameworkFiles=mFrameworkDir.list();
      if (frameworkFiles != null) {
        for (int i=0; i < frameworkFiles.length; i++) {
          File libPath=new File(mFrameworkDir,frameworkFiles[i]);
          String path=libPath.getPath();
          if (libFiles.contains(path)) {
            continue;
          }
          if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(path)) {
              mInstaller.dexopt(path,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + path);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + path,e);
          }
        }
      }
      if (didDexOpt) {
        String[] files=mDalvikCacheDir.list();
        if (files != null) {
          for (int i=0; i < files.length; i++) {
            String fn=files[i];
            if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
              Slog.i(TAG,""String_Node_Str"" + fn);
              (new File(mDalvikCacheDir,fn)).delete();
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX,0);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      mVendorAppDir=new File(""String_Node_Str"");
      mVendorInstallObserver=new AppDirObserver(mVendorAppDir.getPath(),OBSERVER_EVENTS,true);
      mVendorInstallObserver.startWatching();
      scanDirLI(mVendorAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"");
      mInstaller.moveFiles();
      final List<String> possiblyDeletedUpdatedSystemApps=new ArrayList<String>();
      if (!mOnlyCore) {
        Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
        while (psit.hasNext()) {
          PackageSetting ps=psit.next();
          if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            continue;
          }
          final PackageParser.Package scannedPkg=mPackages.get(ps.name);
          if (scannedPkg != null) {
            if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
              Slog.i(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str"");
              removePackageLI(ps,true);
            }
            continue;
          }
          if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {
            psit.remove();
            String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
            reportSettingsProblem(Log.WARN,msg);
            removeDataDirsLI(ps.name);
          }
 else {
            final PackageSetting disabledPs=mSettings.getDisabledSystemPkgLPr(ps.name);
            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {
              possiblyDeletedUpdatedSystemApps.add(ps.name);
            }
          }
        }
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackagesLPr();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      if (!mOnlyCore) {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
        mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
        mAppInstallObserver.startWatching();
        scanDirLI(mAppInstallDir,0,scanMode,0);
        mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
        mDrmAppInstallObserver.startWatching();
        scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode,0);
        for (        String deletedAppName : possiblyDeletedUpdatedSystemApps) {
          PackageParser.Package deletedPkg=mPackages.get(deletedAppName);
          mSettings.removeDisabledSystemPackageLPw(deletedAppName);
          String msg;
          if (deletedPkg == null) {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str"";
            removeDataDirsLI(deletedAppName);
          }
 else {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str""+ deletedAppName;
            deletedPkg.applicationInfo.flags&=~ApplicationInfo.FLAG_SYSTEM;
            PackageSetting deletedPs=mSettings.mPackages.get(deletedAppName);
            deletedPs.pkgFlags&=~ApplicationInfo.FLAG_SYSTEM;
          }
          reportSettingsProblem(Log.WARN,msg);
        }
      }
 else {
        mAppInstallObserver=null;
        mDrmAppInstallObserver=null;
      }
      updateAllSharedLibrariesLPw();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLPw(null,null,UPDATE_PERMISSIONS_ALL | (regrantPermissions ? (UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL) : 0));
      mSettings.writeLPr();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
      mRequiredVerifierPackage=getRequiredVerifierLPr();
    }
  }
}","public PackageManagerService(Context context,Installer installer,boolean factoryTest,boolean onlyCore){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mOnlyCore=onlyCore;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings(context);
  mSettings.addSharedUserLPw(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",RADIO_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",LOG_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",NFC_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",BLUETOOTH_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",SHELL_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  mInstaller=installer;
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      mAppLibInstallDir=new File(dataDir,""String_Node_Str"");
      mAsecInternalPath=new File(dataDir,""String_Node_Str"").getPath();
      mUserAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      sUserManager=new UserManagerService(context,this,mInstallLock,mPackages);
      readPermissions();
      mFoundPolicyFile=SELinuxMMAC.readInstallPolicy();
      mRestoredSettings=mSettings.readLPw(this,sUserManager.getUsers(false),mSdkVersion,mOnlyCore);
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX| SCAN_BOOTING;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      boolean didDexOpt=false;
      String bootClassPath=System.getProperty(""String_Node_Str"");
      if (bootClassPath != null) {
        String[] paths=splitString(bootClassPath,':');
        for (int i=0; i < paths.length; i++) {
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
              libFiles.add(paths[i]);
              mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i]);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i] + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
      if (mSharedLibraries.size() > 0) {
        Iterator<SharedLibraryEntry> libs=mSharedLibraries.values().iterator();
        while (libs.hasNext()) {
          String lib=libs.next().path;
          if (lib == null) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
              libFiles.add(lib);
              mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + lib);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + lib + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
      libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
      String[] frameworkFiles=mFrameworkDir.list();
      if (frameworkFiles != null) {
        for (int i=0; i < frameworkFiles.length; i++) {
          File libPath=new File(mFrameworkDir,frameworkFiles[i]);
          String path=libPath.getPath();
          if (libFiles.contains(path)) {
            continue;
          }
          if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(path)) {
              mInstaller.dexopt(path,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + path);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + path,e);
          }
        }
      }
      if (didDexOpt) {
        String[] files=mDalvikCacheDir.list();
        if (files != null) {
          for (int i=0; i < files.length; i++) {
            String fn=files[i];
            if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
              Slog.i(TAG,""String_Node_Str"" + fn);
              (new File(mDalvikCacheDir,fn)).delete();
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX,0);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      mVendorAppDir=new File(""String_Node_Str"");
      mVendorInstallObserver=new AppDirObserver(mVendorAppDir.getPath(),OBSERVER_EVENTS,true);
      mVendorInstallObserver.startWatching();
      scanDirLI(mVendorAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"");
      mInstaller.moveFiles();
      final List<String> possiblyDeletedUpdatedSystemApps=new ArrayList<String>();
      if (!mOnlyCore) {
        Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
        while (psit.hasNext()) {
          PackageSetting ps=psit.next();
          if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            continue;
          }
          final PackageParser.Package scannedPkg=mPackages.get(ps.name);
          if (scannedPkg != null) {
            if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
              Slog.i(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str"");
              removePackageLI(ps,true);
            }
            continue;
          }
          if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {
            psit.remove();
            String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
            reportSettingsProblem(Log.WARN,msg);
            removeDataDirsLI(ps.name);
          }
 else {
            final PackageSetting disabledPs=mSettings.getDisabledSystemPkgLPr(ps.name);
            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {
              possiblyDeletedUpdatedSystemApps.add(ps.name);
            }
          }
        }
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackagesLPr();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      if (!mOnlyCore) {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
        mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
        mAppInstallObserver.startWatching();
        scanDirLI(mAppInstallDir,0,scanMode,0);
        mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
        mDrmAppInstallObserver.startWatching();
        scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode,0);
        for (        String deletedAppName : possiblyDeletedUpdatedSystemApps) {
          PackageParser.Package deletedPkg=mPackages.get(deletedAppName);
          mSettings.removeDisabledSystemPackageLPw(deletedAppName);
          String msg;
          if (deletedPkg == null) {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str"";
            removeDataDirsLI(deletedAppName);
          }
 else {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str""+ deletedAppName;
            deletedPkg.applicationInfo.flags&=~ApplicationInfo.FLAG_SYSTEM;
            PackageSetting deletedPs=mSettings.mPackages.get(deletedAppName);
            deletedPs.pkgFlags&=~ApplicationInfo.FLAG_SYSTEM;
          }
          reportSettingsProblem(Log.WARN,msg);
        }
      }
 else {
        mAppInstallObserver=null;
        mDrmAppInstallObserver=null;
      }
      updateAllSharedLibrariesLPw();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLPw(null,null,UPDATE_PERMISSIONS_ALL | (regrantPermissions ? (UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL) : 0));
      if (!mRestoredSettings && !onlyCore) {
        mSettings.readDefaultPreferredAppsLPw(this,0);
      }
      mSettings.writeLPr();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
      mRequiredVerifierPackage=getRequiredVerifierLPr();
    }
  }
}"
2483,"boolean readLPw(PackageManagerService service,List<UserInfo> users,int sdkVersion,boolean onlyCore){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPendingPackages.clear();
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
        if (!onlyCore) {
          readDefaultPreferredAppsLPw(service,0);
        }
        mInternalSdkPlatform=mExternalSdkPlatform=sdkVersion;
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"");
      Log.wtf(PackageManagerService.TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLPw(parser,0);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,ATTR_NAME);
        String userStr=parser.getAttributeValue(null,ATTR_USER);
        String codeStr=parser.getAttributeValue(null,ATTR_CODE);
        if (name != null) {
          int userId=0;
          boolean andCode=true;
          try {
            if (userStr != null) {
              userId=Integer.parseInt(userStr);
            }
          }
 catch (          NumberFormatException e) {
          }
          if (codeStr != null) {
            andCode=Boolean.parseBoolean(codeStr);
          }
          addPackageToCleanLPw(new PackageCleanItem(userId,name,andCode));
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mExternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        final String deviceIdentity=parser.getAttributeValue(null,""String_Node_Str"");
        try {
          mVerifierDeviceIdentity=VerifierDeviceIdentity.parse(deviceIdentity);
        }
 catch (        IllegalArgumentException e) {
          Slog.w(PackageManagerService.TAG,""String_Node_Str"" + e.getMessage());
        }
      }
 else       if (TAG_READ_EXTERNAL_STORAGE.equals(tagName)) {
        final String enforcement=parser.getAttributeValue(null,ATTR_ENFORCEMENT);
        mReadExternalStorageEnforced=""String_Node_Str"".equals(enforcement);
      }
 else {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
  final int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLPr(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLPw(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.nativeLibraryPathString,pp.versionCode,pp.pkgFlags,null,true,false);
      if (p == null) {
        PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
  }
  mPendingPackages.clear();
  if (mBackupStoppedPackagesFilename.exists() || mStoppedPackagesFilename.exists()) {
    readStoppedLPw();
    mBackupStoppedPackagesFilename.delete();
    mStoppedPackagesFilename.delete();
    writePackageRestrictionsLPr(0);
  }
 else {
    if (users == null) {
      readPackageRestrictionsLPr(0);
    }
 else {
      for (      UserInfo user : users) {
        readPackageRestrictionsLPr(user.id);
      }
    }
  }
  final Iterator<PackageSetting> disabledIt=mDisabledSysPackages.values().iterator();
  while (disabledIt.hasNext()) {
    final PackageSetting disabledPs=disabledIt.next();
    final Object id=getUserIdLPr(disabledPs.appId);
    if (id != null && id instanceof SharedUserSetting) {
      disabledPs.sharedUser=(SharedUserSetting)id;
    }
  }
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}","boolean readLPw(PackageManagerService service,List<UserInfo> users,int sdkVersion,boolean onlyCore){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPendingPackages.clear();
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
        mInternalSdkPlatform=mExternalSdkPlatform=sdkVersion;
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"");
      Log.wtf(PackageManagerService.TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLPw(parser,0);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,ATTR_NAME);
        String userStr=parser.getAttributeValue(null,ATTR_USER);
        String codeStr=parser.getAttributeValue(null,ATTR_CODE);
        if (name != null) {
          int userId=0;
          boolean andCode=true;
          try {
            if (userStr != null) {
              userId=Integer.parseInt(userStr);
            }
          }
 catch (          NumberFormatException e) {
          }
          if (codeStr != null) {
            andCode=Boolean.parseBoolean(codeStr);
          }
          addPackageToCleanLPw(new PackageCleanItem(userId,name,andCode));
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mExternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        final String deviceIdentity=parser.getAttributeValue(null,""String_Node_Str"");
        try {
          mVerifierDeviceIdentity=VerifierDeviceIdentity.parse(deviceIdentity);
        }
 catch (        IllegalArgumentException e) {
          Slog.w(PackageManagerService.TAG,""String_Node_Str"" + e.getMessage());
        }
      }
 else       if (TAG_READ_EXTERNAL_STORAGE.equals(tagName)) {
        final String enforcement=parser.getAttributeValue(null,ATTR_ENFORCEMENT);
        mReadExternalStorageEnforced=""String_Node_Str"".equals(enforcement);
      }
 else {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
  final int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLPr(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLPw(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.nativeLibraryPathString,pp.versionCode,pp.pkgFlags,null,true,false);
      if (p == null) {
        PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
  }
  mPendingPackages.clear();
  if (mBackupStoppedPackagesFilename.exists() || mStoppedPackagesFilename.exists()) {
    readStoppedLPw();
    mBackupStoppedPackagesFilename.delete();
    mStoppedPackagesFilename.delete();
    writePackageRestrictionsLPr(0);
  }
 else {
    if (users == null) {
      readPackageRestrictionsLPr(0);
    }
 else {
      for (      UserInfo user : users) {
        readPackageRestrictionsLPr(user.id);
      }
    }
  }
  final Iterator<PackageSetting> disabledIt=mDisabledSysPackages.values().iterator();
  while (disabledIt.hasNext()) {
    final PackageSetting disabledPs=disabledIt.next();
    final Object id=getUserIdLPr(disabledPs.appId);
    if (id != null && id instanceof SharedUserSetting) {
      disabledPs.sharedUser=(SharedUserSetting)id;
    }
  }
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}"
2484,"public PackageManagerService(Context context,Installer installer,boolean factoryTest,boolean onlyCore){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mOnlyCore=onlyCore;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings(context);
  mSettings.addSharedUserLPw(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",RADIO_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",LOG_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",NFC_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",BLUETOOTH_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",SHELL_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  mInstaller=installer;
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      mAppLibInstallDir=new File(dataDir,""String_Node_Str"");
      mAsecInternalPath=new File(dataDir,""String_Node_Str"").getPath();
      mUserAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      sUserManager=new UserManagerService(context,this,mInstallLock,mPackages);
      readPermissions();
      mFoundPolicyFile=SELinuxMMAC.readInstallPolicy();
      mRestoredSettings=mSettings.readLPw(this,sUserManager.getUsers(false),mSdkVersion,mOnlyCore);
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX| SCAN_BOOTING;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      boolean didDexOpt=false;
      String bootClassPath=System.getProperty(""String_Node_Str"");
      if (bootClassPath != null) {
        String[] paths=splitString(bootClassPath,':');
        for (int i=0; i < paths.length; i++) {
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
              libFiles.add(paths[i]);
              mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i]);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i] + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
      if (mSharedLibraries.size() > 0) {
        Iterator<SharedLibraryEntry> libs=mSharedLibraries.values().iterator();
        while (libs.hasNext()) {
          String lib=libs.next().path;
          if (lib == null) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
              libFiles.add(lib);
              mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + lib);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + lib + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
      libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
      String[] frameworkFiles=mFrameworkDir.list();
      if (frameworkFiles != null) {
        for (int i=0; i < frameworkFiles.length; i++) {
          File libPath=new File(mFrameworkDir,frameworkFiles[i]);
          String path=libPath.getPath();
          if (libFiles.contains(path)) {
            continue;
          }
          if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(path)) {
              mInstaller.dexopt(path,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + path);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + path,e);
          }
        }
      }
      if (didDexOpt) {
        String[] files=mDalvikCacheDir.list();
        if (files != null) {
          for (int i=0; i < files.length; i++) {
            String fn=files[i];
            if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
              Slog.i(TAG,""String_Node_Str"" + fn);
              (new File(mDalvikCacheDir,fn)).delete();
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX,0);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      mVendorAppDir=new File(""String_Node_Str"");
      mVendorInstallObserver=new AppDirObserver(mVendorAppDir.getPath(),OBSERVER_EVENTS,true);
      mVendorInstallObserver.startWatching();
      scanDirLI(mVendorAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"");
      mInstaller.moveFiles();
      final List<String> possiblyDeletedUpdatedSystemApps=new ArrayList<String>();
      if (!mOnlyCore) {
        Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
        while (psit.hasNext()) {
          PackageSetting ps=psit.next();
          if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            continue;
          }
          final PackageParser.Package scannedPkg=mPackages.get(ps.name);
          if (scannedPkg != null) {
            if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
              Slog.i(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str"");
              removePackageLI(ps,true);
            }
            continue;
          }
          if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {
            psit.remove();
            String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
            reportSettingsProblem(Log.WARN,msg);
            removeDataDirsLI(ps.name);
          }
 else {
            final PackageSetting disabledPs=mSettings.getDisabledSystemPkgLPr(ps.name);
            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {
              possiblyDeletedUpdatedSystemApps.add(ps.name);
            }
          }
        }
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackagesLPr();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      if (!mOnlyCore) {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
        mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
        mAppInstallObserver.startWatching();
        scanDirLI(mAppInstallDir,0,scanMode,0);
        mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
        mDrmAppInstallObserver.startWatching();
        scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode,0);
        for (        String deletedAppName : possiblyDeletedUpdatedSystemApps) {
          PackageParser.Package deletedPkg=mPackages.get(deletedAppName);
          mSettings.removeDisabledSystemPackageLPw(deletedAppName);
          String msg;
          if (deletedPkg == null) {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str"";
            removeDataDirsLI(deletedAppName);
          }
 else {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str""+ deletedAppName;
            deletedPkg.applicationInfo.flags&=~ApplicationInfo.FLAG_SYSTEM;
            PackageSetting deletedPs=mSettings.mPackages.get(deletedAppName);
            deletedPs.pkgFlags&=~ApplicationInfo.FLAG_SYSTEM;
          }
          reportSettingsProblem(Log.WARN,msg);
        }
      }
 else {
        mAppInstallObserver=null;
        mDrmAppInstallObserver=null;
      }
      updateAllSharedLibrariesLPw();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLPw(null,null,UPDATE_PERMISSIONS_ALL | (regrantPermissions ? (UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL) : 0));
      mSettings.writeLPr();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
      mRequiredVerifierPackage=getRequiredVerifierLPr();
    }
  }
}","public PackageManagerService(Context context,Installer installer,boolean factoryTest,boolean onlyCore){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mOnlyCore=onlyCore;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings(context);
  mSettings.addSharedUserLPw(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",RADIO_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",LOG_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",NFC_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",BLUETOOTH_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw(""String_Node_Str"",SHELL_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  mInstaller=installer;
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      mAppLibInstallDir=new File(dataDir,""String_Node_Str"");
      mAsecInternalPath=new File(dataDir,""String_Node_Str"").getPath();
      mUserAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      sUserManager=new UserManagerService(context,this,mInstallLock,mPackages);
      readPermissions();
      mFoundPolicyFile=SELinuxMMAC.readInstallPolicy();
      mRestoredSettings=mSettings.readLPw(this,sUserManager.getUsers(false),mSdkVersion,mOnlyCore);
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX| SCAN_BOOTING;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      boolean didDexOpt=false;
      String bootClassPath=System.getProperty(""String_Node_Str"");
      if (bootClassPath != null) {
        String[] paths=splitString(bootClassPath,':');
        for (int i=0; i < paths.length; i++) {
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
              libFiles.add(paths[i]);
              mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i]);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + paths[i] + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
      if (mSharedLibraries.size() > 0) {
        Iterator<SharedLibraryEntry> libs=mSharedLibraries.values().iterator();
        while (libs.hasNext()) {
          String lib=libs.next().path;
          if (lib == null) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
              libFiles.add(lib);
              mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + lib);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + lib + ""String_Node_Str""+ e.getMessage());
          }
        }
      }
      libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
      String[] frameworkFiles=mFrameworkDir.list();
      if (frameworkFiles != null) {
        for (int i=0; i < frameworkFiles.length; i++) {
          File libPath=new File(mFrameworkDir,frameworkFiles[i]);
          String path=libPath.getPath();
          if (libFiles.contains(path)) {
            continue;
          }
          if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(path)) {
              mInstaller.dexopt(path,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,""String_Node_Str"" + path);
          }
catch (          IOException e) {
            Slog.w(TAG,""String_Node_Str"" + path,e);
          }
        }
      }
      if (didDexOpt) {
        String[] files=mDalvikCacheDir.list();
        if (files != null) {
          for (int i=0; i < files.length; i++) {
            String fn=files[i];
            if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
              Slog.i(TAG,""String_Node_Str"" + fn);
              (new File(mDalvikCacheDir,fn)).delete();
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX,0);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      mVendorAppDir=new File(""String_Node_Str"");
      mVendorInstallObserver=new AppDirObserver(mVendorAppDir.getPath(),OBSERVER_EVENTS,true);
      mVendorInstallObserver.startWatching();
      scanDirLI(mVendorAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"");
      mInstaller.moveFiles();
      final List<String> possiblyDeletedUpdatedSystemApps=new ArrayList<String>();
      if (!mOnlyCore) {
        Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
        while (psit.hasNext()) {
          PackageSetting ps=psit.next();
          if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            continue;
          }
          final PackageParser.Package scannedPkg=mPackages.get(ps.name);
          if (scannedPkg != null) {
            if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
              Slog.i(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str"");
              removePackageLI(ps,true);
            }
            continue;
          }
          if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {
            psit.remove();
            String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
            reportSettingsProblem(Log.WARN,msg);
            removeDataDirsLI(ps.name);
          }
 else {
            final PackageSetting disabledPs=mSettings.getDisabledSystemPkgLPr(ps.name);
            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {
              possiblyDeletedUpdatedSystemApps.add(ps.name);
            }
          }
        }
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackagesLPr();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      if (!mOnlyCore) {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
        mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
        mAppInstallObserver.startWatching();
        scanDirLI(mAppInstallDir,0,scanMode,0);
        mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
        mDrmAppInstallObserver.startWatching();
        scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode,0);
        for (        String deletedAppName : possiblyDeletedUpdatedSystemApps) {
          PackageParser.Package deletedPkg=mPackages.get(deletedAppName);
          mSettings.removeDisabledSystemPackageLPw(deletedAppName);
          String msg;
          if (deletedPkg == null) {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str"";
            removeDataDirsLI(deletedAppName);
          }
 else {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str""+ deletedAppName;
            deletedPkg.applicationInfo.flags&=~ApplicationInfo.FLAG_SYSTEM;
            PackageSetting deletedPs=mSettings.mPackages.get(deletedAppName);
            deletedPs.pkgFlags&=~ApplicationInfo.FLAG_SYSTEM;
          }
          reportSettingsProblem(Log.WARN,msg);
        }
      }
 else {
        mAppInstallObserver=null;
        mDrmAppInstallObserver=null;
      }
      updateAllSharedLibrariesLPw();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLPw(null,null,UPDATE_PERMISSIONS_ALL | (regrantPermissions ? (UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL) : 0));
      if (!mRestoredSettings && !onlyCore) {
        mSettings.readDefaultPreferredAppsLPw(this,0);
      }
      mSettings.writeLPr();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
      mRequiredVerifierPackage=getRequiredVerifierLPr();
    }
  }
}"
2485,"boolean readLPw(PackageManagerService service,List<UserInfo> users,int sdkVersion,boolean onlyCore){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPendingPackages.clear();
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
        if (!onlyCore) {
          readDefaultPreferredAppsLPw(service,0);
        }
        mInternalSdkPlatform=mExternalSdkPlatform=sdkVersion;
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"");
      Log.wtf(PackageManagerService.TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLPw(parser,0);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,ATTR_NAME);
        String userStr=parser.getAttributeValue(null,ATTR_USER);
        String codeStr=parser.getAttributeValue(null,ATTR_CODE);
        if (name != null) {
          int userId=0;
          boolean andCode=true;
          try {
            if (userStr != null) {
              userId=Integer.parseInt(userStr);
            }
          }
 catch (          NumberFormatException e) {
          }
          if (codeStr != null) {
            andCode=Boolean.parseBoolean(codeStr);
          }
          addPackageToCleanLPw(new PackageCleanItem(userId,name,andCode));
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mExternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        final String deviceIdentity=parser.getAttributeValue(null,""String_Node_Str"");
        try {
          mVerifierDeviceIdentity=VerifierDeviceIdentity.parse(deviceIdentity);
        }
 catch (        IllegalArgumentException e) {
          Slog.w(PackageManagerService.TAG,""String_Node_Str"" + e.getMessage());
        }
      }
 else       if (TAG_READ_EXTERNAL_STORAGE.equals(tagName)) {
        final String enforcement=parser.getAttributeValue(null,ATTR_ENFORCEMENT);
        mReadExternalStorageEnforced=""String_Node_Str"".equals(enforcement);
      }
 else {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
  final int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLPr(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLPw(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.nativeLibraryPathString,pp.versionCode,pp.pkgFlags,null,true,false);
      if (p == null) {
        PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
  }
  mPendingPackages.clear();
  if (mBackupStoppedPackagesFilename.exists() || mStoppedPackagesFilename.exists()) {
    readStoppedLPw();
    mBackupStoppedPackagesFilename.delete();
    mStoppedPackagesFilename.delete();
    writePackageRestrictionsLPr(0);
  }
 else {
    if (users == null) {
      readPackageRestrictionsLPr(0);
    }
 else {
      for (      UserInfo user : users) {
        readPackageRestrictionsLPr(user.id);
      }
    }
  }
  final Iterator<PackageSetting> disabledIt=mDisabledSysPackages.values().iterator();
  while (disabledIt.hasNext()) {
    final PackageSetting disabledPs=disabledIt.next();
    final Object id=getUserIdLPr(disabledPs.appId);
    if (id != null && id instanceof SharedUserSetting) {
      disabledPs.sharedUser=(SharedUserSetting)id;
    }
  }
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}","boolean readLPw(PackageManagerService service,List<UserInfo> users,int sdkVersion,boolean onlyCore){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPendingPackages.clear();
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        PackageManagerService.reportSettingsProblem(Log.INFO,""String_Node_Str"");
        mInternalSdkPlatform=mExternalSdkPlatform=sdkVersion;
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"");
      Log.wtf(PackageManagerService.TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLPw(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLPw(parser,0);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLPw(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,ATTR_NAME);
        String userStr=parser.getAttributeValue(null,ATTR_USER);
        String codeStr=parser.getAttributeValue(null,ATTR_CODE);
        if (name != null) {
          int userId=0;
          boolean andCode=true;
          try {
            if (userStr != null) {
              userId=Integer.parseInt(userStr);
            }
          }
 catch (          NumberFormatException e) {
          }
          if (codeStr != null) {
            andCode=Boolean.parseBoolean(codeStr);
          }
          addPackageToCleanLPw(new PackageCleanItem(userId,name,andCode));
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mExternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        final String deviceIdentity=parser.getAttributeValue(null,""String_Node_Str"");
        try {
          mVerifierDeviceIdentity=VerifierDeviceIdentity.parse(deviceIdentity);
        }
 catch (        IllegalArgumentException e) {
          Slog.w(PackageManagerService.TAG,""String_Node_Str"" + e.getMessage());
        }
      }
 else       if (TAG_READ_EXTERNAL_STORAGE.equals(tagName)) {
        final String enforcement=parser.getAttributeValue(null,ATTR_ENFORCEMENT);
        mReadExternalStorageEnforced=""String_Node_Str"".equals(enforcement);
      }
 else {
        Slog.w(PackageManagerService.TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,""String_Node_Str"" + e);
    Log.wtf(PackageManagerService.TAG,""String_Node_Str"",e);
  }
  final int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLPr(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLPw(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.nativeLibraryPathString,pp.versionCode,pp.pkgFlags,null,true,false);
      if (p == null) {
        PackageManagerService.reportSettingsProblem(Log.WARN,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      PackageManagerService.reportSettingsProblem(Log.ERROR,msg);
    }
  }
  mPendingPackages.clear();
  if (mBackupStoppedPackagesFilename.exists() || mStoppedPackagesFilename.exists()) {
    readStoppedLPw();
    mBackupStoppedPackagesFilename.delete();
    mStoppedPackagesFilename.delete();
    writePackageRestrictionsLPr(0);
  }
 else {
    if (users == null) {
      readPackageRestrictionsLPr(0);
    }
 else {
      for (      UserInfo user : users) {
        readPackageRestrictionsLPr(user.id);
      }
    }
  }
  final Iterator<PackageSetting> disabledIt=mDisabledSysPackages.values().iterator();
  while (disabledIt.hasNext()) {
    final PackageSetting disabledPs=disabledIt.next();
    final Object id=getUserIdLPr(disabledPs.appId);
    if (id != null && id instanceof SharedUserSetting) {
      disabledPs.sharedUser=(SharedUserSetting)id;
    }
  }
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}"
2486,"/** 
 * Creates a new worker thread and saves the screenshot to the media store.
 */
private void saveScreenshotInWorkerThread(Runnable finisher){
  Log.d(TAG,""String_Node_Str"");
  SaveImageInBackgroundData data=new SaveImageInBackgroundData();
  data.context=mContext;
  data.image=mScreenBitmap;
  data.iconSize=mNotificationIconSize;
  data.finisher=finisher;
  if (mSaveInBgTask != null) {
    mSaveInBgTask.cancel(false);
    Log.d(TAG,""String_Node_Str"");
  }
  mSaveInBgTask=new SaveImageInBackgroundTask(mContext,data,mNotificationManager,SCREENSHOT_NOTIFICATION_ID).execute(data);
}","/** 
 * Creates a new worker thread and saves the screenshot to the media store.
 */
private void saveScreenshotInWorkerThread(Runnable finisher){
  SaveImageInBackgroundData data=new SaveImageInBackgroundData();
  data.context=mContext;
  data.image=mScreenBitmap;
  data.iconSize=mNotificationIconSize;
  data.finisher=finisher;
  if (mSaveInBgTask != null) {
    mSaveInBgTask.cancel(false);
  }
  mSaveInBgTask=new SaveImageInBackgroundTask(mContext,data,mNotificationManager,SCREENSHOT_NOTIFICATION_ID).execute(data);
}"
2487,"static void notifyScreenshotError(Context context,NotificationManager nManager){
  Log.d(TAG,""String_Node_Str"");
  Resources r=context.getResources();
  Notification.Builder b=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_failed_title)).setContentTitle(r.getString(R.string.screenshot_failed_title)).setContentText(r.getString(R.string.screenshot_failed_text)).setSmallIcon(R.drawable.stat_notify_image_error).setWhen(System.currentTimeMillis()).setAutoCancel(true);
  Notification n=new Notification.BigTextStyle(b).bigText(r.getString(R.string.screenshot_failed_text)).build();
  nManager.notify(SCREENSHOT_NOTIFICATION_ID,n);
}","static void notifyScreenshotError(Context context,NotificationManager nManager){
  Resources r=context.getResources();
  Notification.Builder b=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_failed_title)).setContentTitle(r.getString(R.string.screenshot_failed_title)).setContentText(r.getString(R.string.screenshot_failed_text)).setSmallIcon(R.drawable.stat_notify_image_error).setWhen(System.currentTimeMillis()).setAutoCancel(true);
  Notification n=new Notification.BigTextStyle(b).bigText(r.getString(R.string.screenshot_failed_text)).build();
  nManager.notify(SCREENSHOT_NOTIFICATION_ID,n);
}"
2488,"@Override public void run(){
  mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
  mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE,null);
  mScreenshotView.buildLayer();
  mScreenshotAnimation.start();
  Log.d(TAG,""String_Node_Str"");
}","@Override public void run(){
  mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
  mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE,null);
  mScreenshotView.buildLayer();
  mScreenshotAnimation.start();
}"
2489,"/** 
 * @param context everything needs a context :(
 */
public GlobalScreenshot(Context context){
  Resources r=context.getResources();
  mContext=context;
  LayoutInflater layoutInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mDisplayMatrix=new Matrix();
  mScreenshotLayout=layoutInflater.inflate(R.layout.global_screenshot,null);
  mBackgroundView=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot_background);
  mScreenshotView=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot);
  mScreenshotFlash=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot_flash);
  mScreenshotLayout.setFocusable(true);
  mScreenshotLayout.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      return true;
    }
  }
);
  mWindowLayoutParams=new WindowManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT,0,0,WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY,WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED,PixelFormat.TRANSLUCENT);
  mWindowLayoutParams.setTitle(""String_Node_Str"");
  mWindowManager=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  mNotificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
  mDisplay=mWindowManager.getDefaultDisplay();
  mDisplayMetrics=new DisplayMetrics();
  mDisplay.getRealMetrics(mDisplayMetrics);
  mNotificationIconSize=r.getDimensionPixelSize(android.R.dimen.notification_large_icon_height);
  mBgPadding=(float)r.getDimensionPixelSize(R.dimen.global_screenshot_bg_padding);
  mBgPaddingScale=mBgPadding / mDisplayMetrics.widthPixels;
  mCameraSound=new MediaActionSound();
  mCameraSound.load(MediaActionSound.SHUTTER_CLICK);
  Log.d(TAG,""String_Node_Str"");
}","/** 
 * @param context everything needs a context :(
 */
public GlobalScreenshot(Context context){
  Resources r=context.getResources();
  mContext=context;
  LayoutInflater layoutInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mDisplayMatrix=new Matrix();
  mScreenshotLayout=layoutInflater.inflate(R.layout.global_screenshot,null);
  mBackgroundView=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot_background);
  mScreenshotView=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot);
  mScreenshotFlash=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot_flash);
  mScreenshotLayout.setFocusable(true);
  mScreenshotLayout.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      return true;
    }
  }
);
  mWindowLayoutParams=new WindowManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT,0,0,WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY,WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED,PixelFormat.TRANSLUCENT);
  mWindowLayoutParams.setTitle(""String_Node_Str"");
  mWindowManager=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  mNotificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
  mDisplay=mWindowManager.getDefaultDisplay();
  mDisplayMetrics=new DisplayMetrics();
  mDisplay.getRealMetrics(mDisplayMetrics);
  mNotificationIconSize=r.getDimensionPixelSize(android.R.dimen.notification_large_icon_height);
  mBgPadding=(float)r.getDimensionPixelSize(R.dimen.global_screenshot_bg_padding);
  mBgPaddingScale=mBgPadding / mDisplayMetrics.widthPixels;
  mCameraSound=new MediaActionSound();
  mCameraSound.load(MediaActionSound.SHUTTER_CLICK);
}"
2490,"/** 
 * Starts the animation after taking the screenshot
 */
private void startAnimation(final Runnable finisher,int w,int h,boolean statusBarVisible,boolean navBarVisible){
  Log.d(TAG,""String_Node_Str"");
  mScreenshotView.setImageBitmap(mScreenBitmap);
  mScreenshotLayout.requestFocus();
  if (mScreenshotAnimation != null) {
    mScreenshotAnimation.end();
    mScreenshotAnimation.removeAllListeners();
    Log.d(TAG,""String_Node_Str"");
  }
  mWindowManager.addView(mScreenshotLayout,mWindowLayoutParams);
  Log.d(TAG,""String_Node_Str"");
  ValueAnimator screenshotDropInAnim=createScreenshotDropInAnimation();
  ValueAnimator screenshotFadeOutAnim=createScreenshotDropOutAnimation(w,h,statusBarVisible,navBarVisible);
  mScreenshotAnimation=new AnimatorSet();
  mScreenshotAnimation.playSequentially(screenshotDropInAnim,screenshotFadeOutAnim);
  mScreenshotAnimation.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      saveScreenshotInWorkerThread(finisher);
      mWindowManager.removeView(mScreenshotLayout);
      mScreenBitmap=null;
      mScreenshotView.setImageBitmap(null);
      Log.d(TAG,""String_Node_Str"");
    }
  }
);
  mScreenshotLayout.post(new Runnable(){
    @Override public void run(){
      mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
      mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE,null);
      mScreenshotView.buildLayer();
      mScreenshotAnimation.start();
      Log.d(TAG,""String_Node_Str"");
    }
  }
);
}","/** 
 * Starts the animation after taking the screenshot
 */
private void startAnimation(final Runnable finisher,int w,int h,boolean statusBarVisible,boolean navBarVisible){
  mScreenshotView.setImageBitmap(mScreenBitmap);
  mScreenshotLayout.requestFocus();
  if (mScreenshotAnimation != null) {
    mScreenshotAnimation.end();
    mScreenshotAnimation.removeAllListeners();
  }
  mWindowManager.addView(mScreenshotLayout,mWindowLayoutParams);
  ValueAnimator screenshotDropInAnim=createScreenshotDropInAnimation();
  ValueAnimator screenshotFadeOutAnim=createScreenshotDropOutAnimation(w,h,statusBarVisible,navBarVisible);
  mScreenshotAnimation=new AnimatorSet();
  mScreenshotAnimation.playSequentially(screenshotDropInAnim,screenshotFadeOutAnim);
  mScreenshotAnimation.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      saveScreenshotInWorkerThread(finisher);
      mWindowManager.removeView(mScreenshotLayout);
      mScreenBitmap=null;
      mScreenshotView.setImageBitmap(null);
    }
  }
);
  mScreenshotLayout.post(new Runnable(){
    @Override public void run(){
      mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
      mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE,null);
      mScreenshotView.buildLayer();
      mScreenshotAnimation.start();
    }
  }
);
}"
2491,"SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  final int shortSide=mImageWidth < mImageHeight ? mImageWidth : mImageHeight;
  Bitmap preview=Bitmap.createBitmap(shortSide,shortSide,data.image.getConfig());
  Canvas c=new Canvas(preview);
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  matrix.postTranslate((shortSide - mImageWidth) / 2,(shortSide - mImageHeight) / 2);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(0x40FFFFFF);
  c.setBitmap(null);
  Bitmap croppedIcon=Bitmap.createScaledBitmap(preview,iconSize,iconSize,true);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(System.currentTimeMillis());
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(preview);
  mNotificationBuilder.setStyle(mNotificationStyle);
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(croppedIcon);
  mNotificationStyle.bigLargeIcon(null);
  Log.d(TAG,""String_Node_Str"");
}","SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  final int shortSide=mImageWidth < mImageHeight ? mImageWidth : mImageHeight;
  Bitmap preview=Bitmap.createBitmap(shortSide,shortSide,data.image.getConfig());
  Canvas c=new Canvas(preview);
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  matrix.postTranslate((shortSide - mImageWidth) / 2,(shortSide - mImageHeight) / 2);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(0x40FFFFFF);
  c.setBitmap(null);
  Bitmap croppedIcon=Bitmap.createScaledBitmap(preview,iconSize,iconSize,true);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(System.currentTimeMillis());
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(preview);
  mNotificationBuilder.setStyle(mNotificationStyle);
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(croppedIcon);
  mNotificationStyle.bigLargeIcon(null);
}"
2492,"/** 
 * Takes a screenshot of the current display and shows an animation.
 */
void takeScreenshot(Runnable finisher,boolean statusBarVisible,boolean navBarVisible){
  Log.d(TAG,""String_Node_Str"");
  mDisplay.getRealMetrics(mDisplayMetrics);
  float[] dims={mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels};
  float degrees=getDegreesForRotation(mDisplay.getRotation());
  boolean requiresRotation=(degrees > 0);
  if (requiresRotation) {
    mDisplayMatrix.reset();
    mDisplayMatrix.preRotate(-degrees);
    mDisplayMatrix.mapPoints(dims);
    dims[0]=Math.abs(dims[0]);
    dims[1]=Math.abs(dims[1]);
    Log.d(TAG,""String_Node_Str"");
  }
  mScreenBitmap=SurfaceControl.screenshot((int)dims[0],(int)dims[1]);
  if (mScreenBitmap == null) {
    notifyScreenshotError(mContext,mNotificationManager);
    finisher.run();
    Log.d(TAG,""String_Node_Str"");
    return;
  }
  if (requiresRotation) {
    Bitmap ss=Bitmap.createBitmap(mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(ss);
    c.translate(ss.getWidth() / 2,ss.getHeight() / 2);
    c.rotate(degrees);
    c.translate(-dims[0] / 2,-dims[1] / 2);
    c.drawBitmap(mScreenBitmap,0,0,null);
    c.setBitmap(null);
    mScreenBitmap.recycle();
    mScreenBitmap=ss;
    Log.d(TAG,""String_Node_Str"");
  }
  mScreenBitmap.setHasAlpha(false);
  mScreenBitmap.prepareToDraw();
  startAnimation(finisher,mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels,statusBarVisible,navBarVisible);
  Log.d(TAG,""String_Node_Str"");
}","/** 
 * Takes a screenshot of the current display and shows an animation.
 */
void takeScreenshot(Runnable finisher,boolean statusBarVisible,boolean navBarVisible){
  mDisplay.getRealMetrics(mDisplayMetrics);
  float[] dims={mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels};
  float degrees=getDegreesForRotation(mDisplay.getRotation());
  boolean requiresRotation=(degrees > 0);
  if (requiresRotation) {
    mDisplayMatrix.reset();
    mDisplayMatrix.preRotate(-degrees);
    mDisplayMatrix.mapPoints(dims);
    dims[0]=Math.abs(dims[0]);
    dims[1]=Math.abs(dims[1]);
  }
  mScreenBitmap=SurfaceControl.screenshot((int)dims[0],(int)dims[1]);
  if (mScreenBitmap == null) {
    notifyScreenshotError(mContext,mNotificationManager);
    finisher.run();
    return;
  }
  if (requiresRotation) {
    Bitmap ss=Bitmap.createBitmap(mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(ss);
    c.translate(ss.getWidth() / 2,ss.getHeight() / 2);
    c.rotate(degrees);
    c.translate(-dims[0] / 2,-dims[1] / 2);
    c.drawBitmap(mScreenBitmap,0,0,null);
    c.setBitmap(null);
    mScreenBitmap.recycle();
    mScreenBitmap=ss;
  }
  mScreenBitmap.setHasAlpha(false);
  mScreenBitmap.prepareToDraw();
  startAnimation(finisher,mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels,statusBarVisible,navBarVisible);
}"
2493,"void clearImage(){
  context=null;
  image=null;
  imageUri=null;
  iconSize=0;
}","void clearImage(){
  image=null;
  imageUri=null;
  iconSize=0;
}"
2494,"@Override protected SaveImageInBackgroundData doInBackground(SaveImageInBackgroundData... params){
  if (params.length != 1)   return null;
  if (isCancelled()) {
    params[0].clearImage();
    Log.d(TAG,""String_Node_Str"");
    return null;
  }
  Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
  Context context=params[0].context;
  Bitmap image=params[0].image;
  Resources r=context.getResources();
  try {
    mScreenshotDir.mkdirs();
    ContentValues values=new ContentValues();
    ContentResolver resolver=context.getContentResolver();
    values.put(MediaStore.Images.ImageColumns.DATA,mImageFilePath);
    values.put(MediaStore.Images.ImageColumns.TITLE,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DISPLAY_NAME,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DATE_TAKEN,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_ADDED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_MODIFIED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.MIME_TYPE,""String_Node_Str"");
    values.put(MediaStore.Images.ImageColumns.WIDTH,mImageWidth);
    values.put(MediaStore.Images.ImageColumns.HEIGHT,mImageHeight);
    Uri uri=resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,values);
    String subjectDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
    String subject=String.format(SCREENSHOT_SHARE_SUBJECT_TEMPLATE,subjectDate);
    Intent sharingIntent=new Intent(Intent.ACTION_SEND);
    sharingIntent.setType(""String_Node_Str"");
    sharingIntent.putExtra(Intent.EXTRA_STREAM,uri);
    sharingIntent.putExtra(Intent.EXTRA_SUBJECT,subject);
    Intent chooserIntent=Intent.createChooser(sharingIntent,null);
    chooserIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.addAction(R.drawable.ic_menu_share,r.getString(com.android.internal.R.string.share),PendingIntent.getActivity(context,0,chooserIntent,PendingIntent.FLAG_CANCEL_CURRENT));
    OutputStream out=resolver.openOutputStream(uri);
    image.compress(Bitmap.CompressFormat.PNG,100,out);
    out.flush();
    out.close();
    values.clear();
    values.put(MediaStore.Images.ImageColumns.SIZE,new File(mImageFilePath).length());
    resolver.update(uri,values,null,null);
    params[0].imageUri=uri;
    params[0].image=null;
    params[0].result=0;
  }
 catch (  Exception e) {
    params[0].clearImage();
    params[0].result=1;
    Log.d(TAG,""String_Node_Str"");
  }
  if (image != null) {
    image.recycle();
  }
  Log.d(TAG,""String_Node_Str"");
  return params[0];
}","@Override protected SaveImageInBackgroundData doInBackground(SaveImageInBackgroundData... params){
  if (params.length != 1)   return null;
  if (isCancelled()) {
    params[0].clearImage();
    params[0].clearContext();
    return null;
  }
  Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
  Context context=params[0].context;
  Bitmap image=params[0].image;
  Resources r=context.getResources();
  try {
    mScreenshotDir.mkdirs();
    ContentValues values=new ContentValues();
    ContentResolver resolver=context.getContentResolver();
    values.put(MediaStore.Images.ImageColumns.DATA,mImageFilePath);
    values.put(MediaStore.Images.ImageColumns.TITLE,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DISPLAY_NAME,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DATE_TAKEN,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_ADDED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_MODIFIED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.MIME_TYPE,""String_Node_Str"");
    values.put(MediaStore.Images.ImageColumns.WIDTH,mImageWidth);
    values.put(MediaStore.Images.ImageColumns.HEIGHT,mImageHeight);
    Uri uri=resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,values);
    String subjectDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
    String subject=String.format(SCREENSHOT_SHARE_SUBJECT_TEMPLATE,subjectDate);
    Intent sharingIntent=new Intent(Intent.ACTION_SEND);
    sharingIntent.setType(""String_Node_Str"");
    sharingIntent.putExtra(Intent.EXTRA_STREAM,uri);
    sharingIntent.putExtra(Intent.EXTRA_SUBJECT,subject);
    Intent chooserIntent=Intent.createChooser(sharingIntent,null);
    chooserIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.addAction(R.drawable.ic_menu_share,r.getString(com.android.internal.R.string.share),PendingIntent.getActivity(context,0,chooserIntent,PendingIntent.FLAG_CANCEL_CURRENT));
    OutputStream out=resolver.openOutputStream(uri);
    image.compress(Bitmap.CompressFormat.PNG,100,out);
    out.flush();
    out.close();
    values.clear();
    values.put(MediaStore.Images.ImageColumns.SIZE,new File(mImageFilePath).length());
    resolver.update(uri,values,null,null);
    params[0].imageUri=uri;
    params[0].image=null;
    params[0].result=0;
  }
 catch (  Exception e) {
    params[0].clearImage();
    params[0].result=1;
  }
  if (image != null) {
    image.recycle();
  }
  return params[0];
}"
2495,"@Override protected void onPostExecute(SaveImageInBackgroundData params){
  if (isCancelled()) {
    params.finisher.run();
    params.clearImage();
    Log.d(TAG,""String_Node_Str"");
    return;
  }
  if (params.result > 0) {
    GlobalScreenshot.notifyScreenshotError(params.context,mNotificationManager);
  }
 else {
    Resources r=params.context.getResources();
    Intent launchIntent=new Intent(Intent.ACTION_VIEW);
    launchIntent.setDataAndType(params.imageUri,""String_Node_Str"");
    launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.setContentTitle(r.getString(R.string.screenshot_saved_title)).setContentText(r.getString(R.string.screenshot_saved_text)).setContentIntent(PendingIntent.getActivity(params.context,0,launchIntent,0)).setWhen(System.currentTimeMillis()).setAutoCancel(true);
    Notification n=mNotificationBuilder.build();
    n.flags&=~Notification.FLAG_NO_CLEAR;
    mNotificationManager.notify(mNotificationId,n);
  }
  params.finisher.run();
  Log.d(TAG,""String_Node_Str"");
}","@Override protected void onPostExecute(SaveImageInBackgroundData params){
  if (isCancelled()) {
    params.finisher.run();
    params.clearImage();
    params.clearContext();
    return;
  }
  if (params.result > 0) {
    GlobalScreenshot.notifyScreenshotError(params.context,mNotificationManager);
  }
 else {
    Resources r=params.context.getResources();
    Intent launchIntent=new Intent(Intent.ACTION_VIEW);
    launchIntent.setDataAndType(params.imageUri,""String_Node_Str"");
    launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.setContentTitle(r.getString(R.string.screenshot_saved_title)).setContentText(r.getString(R.string.screenshot_saved_text)).setContentIntent(PendingIntent.getActivity(params.context,0,launchIntent,0)).setWhen(System.currentTimeMillis()).setAutoCancel(true);
    Notification n=mNotificationBuilder.build();
    n.flags&=~Notification.FLAG_NO_CLEAR;
    mNotificationManager.notify(mNotificationId,n);
  }
  params.finisher.run();
  params.clearContext();
}"
2496,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case 1:
    final Messenger callback=msg.replyTo;
  if (mScreenshot == null) {
    mScreenshot=new GlobalScreenshot(TakeScreenshotService.this);
    Log.d(TAG,""String_Node_Str"");
  }
Log.d(TAG,""String_Node_Str"");
mScreenshot.takeScreenshot(new Runnable(){
@Override public void run(){
  Message reply=Message.obtain(null,1);
  try {
    callback.send(reply);
    Log.d(TAG,""String_Node_Str"");
  }
 catch (  RemoteException e) {
  }
}
}
,msg.arg1 > 0,msg.arg2 > 0);
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case 1:
    final Messenger callback=msg.replyTo;
  if (mScreenshot == null) {
    mScreenshot=new GlobalScreenshot(TakeScreenshotService.this);
  }
mScreenshot.takeScreenshot(new Runnable(){
  @Override public void run(){
    Message reply=Message.obtain(null,1);
    try {
      callback.send(reply);
    }
 catch (    RemoteException e) {
    }
  }
}
,msg.arg1 > 0,msg.arg2 > 0);
}
}"
2497,"@Override public void run(){
  Message reply=Message.obtain(null,1);
  try {
    callback.send(reply);
    Log.d(TAG,""String_Node_Str"");
  }
 catch (  RemoteException e) {
  }
}","@Override public void run(){
  Message reply=Message.obtain(null,1);
  try {
    callback.send(reply);
  }
 catch (  RemoteException e) {
  }
}"
2498,"/** 
 * Creates a new worker thread and saves the screenshot to the media store.
 */
private void saveScreenshotInWorkerThread(Runnable finisher){
  Log.d(TAG,""String_Node_Str"");
  SaveImageInBackgroundData data=new SaveImageInBackgroundData();
  data.context=mContext;
  data.image=mScreenBitmap;
  data.iconSize=mNotificationIconSize;
  data.finisher=finisher;
  if (mSaveInBgTask != null) {
    mSaveInBgTask.cancel(false);
    Log.d(TAG,""String_Node_Str"");
  }
  mSaveInBgTask=new SaveImageInBackgroundTask(mContext,data,mNotificationManager,SCREENSHOT_NOTIFICATION_ID).execute(data);
}","/** 
 * Creates a new worker thread and saves the screenshot to the media store.
 */
private void saveScreenshotInWorkerThread(Runnable finisher){
  SaveImageInBackgroundData data=new SaveImageInBackgroundData();
  data.context=mContext;
  data.image=mScreenBitmap;
  data.iconSize=mNotificationIconSize;
  data.finisher=finisher;
  if (mSaveInBgTask != null) {
    mSaveInBgTask.cancel(false);
  }
  mSaveInBgTask=new SaveImageInBackgroundTask(mContext,data,mNotificationManager,SCREENSHOT_NOTIFICATION_ID).execute(data);
}"
2499,"static void notifyScreenshotError(Context context,NotificationManager nManager){
  Log.d(TAG,""String_Node_Str"");
  Resources r=context.getResources();
  Notification.Builder b=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_failed_title)).setContentTitle(r.getString(R.string.screenshot_failed_title)).setContentText(r.getString(R.string.screenshot_failed_text)).setSmallIcon(R.drawable.stat_notify_image_error).setWhen(System.currentTimeMillis()).setAutoCancel(true);
  Notification n=new Notification.BigTextStyle(b).bigText(r.getString(R.string.screenshot_failed_text)).build();
  nManager.notify(SCREENSHOT_NOTIFICATION_ID,n);
}","static void notifyScreenshotError(Context context,NotificationManager nManager){
  Resources r=context.getResources();
  Notification.Builder b=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_failed_title)).setContentTitle(r.getString(R.string.screenshot_failed_title)).setContentText(r.getString(R.string.screenshot_failed_text)).setSmallIcon(R.drawable.stat_notify_image_error).setWhen(System.currentTimeMillis()).setAutoCancel(true);
  Notification n=new Notification.BigTextStyle(b).bigText(r.getString(R.string.screenshot_failed_text)).build();
  nManager.notify(SCREENSHOT_NOTIFICATION_ID,n);
}"
2500,"@Override public void run(){
  mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
  mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE,null);
  mScreenshotView.buildLayer();
  mScreenshotAnimation.start();
  Log.d(TAG,""String_Node_Str"");
}","@Override public void run(){
  mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
  mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE,null);
  mScreenshotView.buildLayer();
  mScreenshotAnimation.start();
}"
2501,"/** 
 * @param context everything needs a context :(
 */
public GlobalScreenshot(Context context){
  Resources r=context.getResources();
  mContext=context;
  LayoutInflater layoutInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mDisplayMatrix=new Matrix();
  mScreenshotLayout=layoutInflater.inflate(R.layout.global_screenshot,null);
  mBackgroundView=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot_background);
  mScreenshotView=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot);
  mScreenshotFlash=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot_flash);
  mScreenshotLayout.setFocusable(true);
  mScreenshotLayout.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      return true;
    }
  }
);
  mWindowLayoutParams=new WindowManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT,0,0,WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY,WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED,PixelFormat.TRANSLUCENT);
  mWindowLayoutParams.setTitle(""String_Node_Str"");
  mWindowManager=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  mNotificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
  mDisplay=mWindowManager.getDefaultDisplay();
  mDisplayMetrics=new DisplayMetrics();
  mDisplay.getRealMetrics(mDisplayMetrics);
  mNotificationIconSize=r.getDimensionPixelSize(android.R.dimen.notification_large_icon_height);
  mBgPadding=(float)r.getDimensionPixelSize(R.dimen.global_screenshot_bg_padding);
  mBgPaddingScale=mBgPadding / mDisplayMetrics.widthPixels;
  mCameraSound=new MediaActionSound();
  mCameraSound.load(MediaActionSound.SHUTTER_CLICK);
  Log.d(TAG,""String_Node_Str"");
}","/** 
 * @param context everything needs a context :(
 */
public GlobalScreenshot(Context context){
  Resources r=context.getResources();
  mContext=context;
  LayoutInflater layoutInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mDisplayMatrix=new Matrix();
  mScreenshotLayout=layoutInflater.inflate(R.layout.global_screenshot,null);
  mBackgroundView=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot_background);
  mScreenshotView=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot);
  mScreenshotFlash=(ImageView)mScreenshotLayout.findViewById(R.id.global_screenshot_flash);
  mScreenshotLayout.setFocusable(true);
  mScreenshotLayout.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      return true;
    }
  }
);
  mWindowLayoutParams=new WindowManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT,0,0,WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY,WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED,PixelFormat.TRANSLUCENT);
  mWindowLayoutParams.setTitle(""String_Node_Str"");
  mWindowManager=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  mNotificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
  mDisplay=mWindowManager.getDefaultDisplay();
  mDisplayMetrics=new DisplayMetrics();
  mDisplay.getRealMetrics(mDisplayMetrics);
  mNotificationIconSize=r.getDimensionPixelSize(android.R.dimen.notification_large_icon_height);
  mBgPadding=(float)r.getDimensionPixelSize(R.dimen.global_screenshot_bg_padding);
  mBgPaddingScale=mBgPadding / mDisplayMetrics.widthPixels;
  mCameraSound=new MediaActionSound();
  mCameraSound.load(MediaActionSound.SHUTTER_CLICK);
}"
2502,"/** 
 * Starts the animation after taking the screenshot
 */
private void startAnimation(final Runnable finisher,int w,int h,boolean statusBarVisible,boolean navBarVisible){
  Log.d(TAG,""String_Node_Str"");
  mScreenshotView.setImageBitmap(mScreenBitmap);
  mScreenshotLayout.requestFocus();
  if (mScreenshotAnimation != null) {
    mScreenshotAnimation.end();
    mScreenshotAnimation.removeAllListeners();
    Log.d(TAG,""String_Node_Str"");
  }
  mWindowManager.addView(mScreenshotLayout,mWindowLayoutParams);
  Log.d(TAG,""String_Node_Str"");
  ValueAnimator screenshotDropInAnim=createScreenshotDropInAnimation();
  ValueAnimator screenshotFadeOutAnim=createScreenshotDropOutAnimation(w,h,statusBarVisible,navBarVisible);
  mScreenshotAnimation=new AnimatorSet();
  mScreenshotAnimation.playSequentially(screenshotDropInAnim,screenshotFadeOutAnim);
  mScreenshotAnimation.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      saveScreenshotInWorkerThread(finisher);
      mWindowManager.removeView(mScreenshotLayout);
      mScreenBitmap=null;
      mScreenshotView.setImageBitmap(null);
      Log.d(TAG,""String_Node_Str"");
    }
  }
);
  mScreenshotLayout.post(new Runnable(){
    @Override public void run(){
      mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
      mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE,null);
      mScreenshotView.buildLayer();
      mScreenshotAnimation.start();
      Log.d(TAG,""String_Node_Str"");
    }
  }
);
}","/** 
 * Starts the animation after taking the screenshot
 */
private void startAnimation(final Runnable finisher,int w,int h,boolean statusBarVisible,boolean navBarVisible){
  mScreenshotView.setImageBitmap(mScreenBitmap);
  mScreenshotLayout.requestFocus();
  if (mScreenshotAnimation != null) {
    mScreenshotAnimation.end();
    mScreenshotAnimation.removeAllListeners();
  }
  mWindowManager.addView(mScreenshotLayout,mWindowLayoutParams);
  ValueAnimator screenshotDropInAnim=createScreenshotDropInAnimation();
  ValueAnimator screenshotFadeOutAnim=createScreenshotDropOutAnimation(w,h,statusBarVisible,navBarVisible);
  mScreenshotAnimation=new AnimatorSet();
  mScreenshotAnimation.playSequentially(screenshotDropInAnim,screenshotFadeOutAnim);
  mScreenshotAnimation.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      saveScreenshotInWorkerThread(finisher);
      mWindowManager.removeView(mScreenshotLayout);
      mScreenBitmap=null;
      mScreenshotView.setImageBitmap(null);
    }
  }
);
  mScreenshotLayout.post(new Runnable(){
    @Override public void run(){
      mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
      mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE,null);
      mScreenshotView.buildLayer();
      mScreenshotAnimation.start();
    }
  }
);
}"
2503,"SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  final int shortSide=mImageWidth < mImageHeight ? mImageWidth : mImageHeight;
  Bitmap preview=Bitmap.createBitmap(shortSide,shortSide,data.image.getConfig());
  Canvas c=new Canvas(preview);
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  matrix.postTranslate((shortSide - mImageWidth) / 2,(shortSide - mImageHeight) / 2);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(0x40FFFFFF);
  c.setBitmap(null);
  Bitmap croppedIcon=Bitmap.createScaledBitmap(preview,iconSize,iconSize,true);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(System.currentTimeMillis());
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(preview);
  mNotificationBuilder.setStyle(mNotificationStyle);
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(croppedIcon);
  mNotificationStyle.bigLargeIcon(null);
  Log.d(TAG,""String_Node_Str"");
}","SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  final int shortSide=mImageWidth < mImageHeight ? mImageWidth : mImageHeight;
  Bitmap preview=Bitmap.createBitmap(shortSide,shortSide,data.image.getConfig());
  Canvas c=new Canvas(preview);
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  matrix.postTranslate((shortSide - mImageWidth) / 2,(shortSide - mImageHeight) / 2);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(0x40FFFFFF);
  c.setBitmap(null);
  Bitmap croppedIcon=Bitmap.createScaledBitmap(preview,iconSize,iconSize,true);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(System.currentTimeMillis());
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(preview);
  mNotificationBuilder.setStyle(mNotificationStyle);
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(croppedIcon);
  mNotificationStyle.bigLargeIcon(null);
}"
2504,"/** 
 * Takes a screenshot of the current display and shows an animation.
 */
void takeScreenshot(Runnable finisher,boolean statusBarVisible,boolean navBarVisible){
  Log.d(TAG,""String_Node_Str"");
  mDisplay.getRealMetrics(mDisplayMetrics);
  float[] dims={mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels};
  float degrees=getDegreesForRotation(mDisplay.getRotation());
  boolean requiresRotation=(degrees > 0);
  if (requiresRotation) {
    mDisplayMatrix.reset();
    mDisplayMatrix.preRotate(-degrees);
    mDisplayMatrix.mapPoints(dims);
    dims[0]=Math.abs(dims[0]);
    dims[1]=Math.abs(dims[1]);
    Log.d(TAG,""String_Node_Str"");
  }
  mScreenBitmap=SurfaceControl.screenshot((int)dims[0],(int)dims[1]);
  if (mScreenBitmap == null) {
    notifyScreenshotError(mContext,mNotificationManager);
    finisher.run();
    Log.d(TAG,""String_Node_Str"");
    return;
  }
  if (requiresRotation) {
    Bitmap ss=Bitmap.createBitmap(mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(ss);
    c.translate(ss.getWidth() / 2,ss.getHeight() / 2);
    c.rotate(degrees);
    c.translate(-dims[0] / 2,-dims[1] / 2);
    c.drawBitmap(mScreenBitmap,0,0,null);
    c.setBitmap(null);
    mScreenBitmap.recycle();
    mScreenBitmap=ss;
    Log.d(TAG,""String_Node_Str"");
  }
  mScreenBitmap.setHasAlpha(false);
  mScreenBitmap.prepareToDraw();
  startAnimation(finisher,mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels,statusBarVisible,navBarVisible);
  Log.d(TAG,""String_Node_Str"");
}","/** 
 * Takes a screenshot of the current display and shows an animation.
 */
void takeScreenshot(Runnable finisher,boolean statusBarVisible,boolean navBarVisible){
  mDisplay.getRealMetrics(mDisplayMetrics);
  float[] dims={mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels};
  float degrees=getDegreesForRotation(mDisplay.getRotation());
  boolean requiresRotation=(degrees > 0);
  if (requiresRotation) {
    mDisplayMatrix.reset();
    mDisplayMatrix.preRotate(-degrees);
    mDisplayMatrix.mapPoints(dims);
    dims[0]=Math.abs(dims[0]);
    dims[1]=Math.abs(dims[1]);
  }
  mScreenBitmap=SurfaceControl.screenshot((int)dims[0],(int)dims[1]);
  if (mScreenBitmap == null) {
    notifyScreenshotError(mContext,mNotificationManager);
    finisher.run();
    return;
  }
  if (requiresRotation) {
    Bitmap ss=Bitmap.createBitmap(mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(ss);
    c.translate(ss.getWidth() / 2,ss.getHeight() / 2);
    c.rotate(degrees);
    c.translate(-dims[0] / 2,-dims[1] / 2);
    c.drawBitmap(mScreenBitmap,0,0,null);
    c.setBitmap(null);
    mScreenBitmap.recycle();
    mScreenBitmap=ss;
  }
  mScreenBitmap.setHasAlpha(false);
  mScreenBitmap.prepareToDraw();
  startAnimation(finisher,mDisplayMetrics.widthPixels,mDisplayMetrics.heightPixels,statusBarVisible,navBarVisible);
}"
2505,"void clearImage(){
  context=null;
  image=null;
  imageUri=null;
  iconSize=0;
}","void clearImage(){
  image=null;
  imageUri=null;
  iconSize=0;
}"
2506,"@Override protected SaveImageInBackgroundData doInBackground(SaveImageInBackgroundData... params){
  if (params.length != 1)   return null;
  if (isCancelled()) {
    params[0].clearImage();
    Log.d(TAG,""String_Node_Str"");
    return null;
  }
  Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
  Context context=params[0].context;
  Bitmap image=params[0].image;
  Resources r=context.getResources();
  try {
    mScreenshotDir.mkdirs();
    ContentValues values=new ContentValues();
    ContentResolver resolver=context.getContentResolver();
    values.put(MediaStore.Images.ImageColumns.DATA,mImageFilePath);
    values.put(MediaStore.Images.ImageColumns.TITLE,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DISPLAY_NAME,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DATE_TAKEN,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_ADDED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_MODIFIED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.MIME_TYPE,""String_Node_Str"");
    values.put(MediaStore.Images.ImageColumns.WIDTH,mImageWidth);
    values.put(MediaStore.Images.ImageColumns.HEIGHT,mImageHeight);
    Uri uri=resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,values);
    String subjectDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
    String subject=String.format(SCREENSHOT_SHARE_SUBJECT_TEMPLATE,subjectDate);
    Intent sharingIntent=new Intent(Intent.ACTION_SEND);
    sharingIntent.setType(""String_Node_Str"");
    sharingIntent.putExtra(Intent.EXTRA_STREAM,uri);
    sharingIntent.putExtra(Intent.EXTRA_SUBJECT,subject);
    Intent chooserIntent=Intent.createChooser(sharingIntent,null);
    chooserIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.addAction(R.drawable.ic_menu_share,r.getString(com.android.internal.R.string.share),PendingIntent.getActivity(context,0,chooserIntent,PendingIntent.FLAG_CANCEL_CURRENT));
    OutputStream out=resolver.openOutputStream(uri);
    image.compress(Bitmap.CompressFormat.PNG,100,out);
    out.flush();
    out.close();
    values.clear();
    values.put(MediaStore.Images.ImageColumns.SIZE,new File(mImageFilePath).length());
    resolver.update(uri,values,null,null);
    params[0].imageUri=uri;
    params[0].image=null;
    params[0].result=0;
  }
 catch (  Exception e) {
    params[0].clearImage();
    params[0].result=1;
    Log.d(TAG,""String_Node_Str"");
  }
  if (image != null) {
    image.recycle();
  }
  Log.d(TAG,""String_Node_Str"");
  return params[0];
}","@Override protected SaveImageInBackgroundData doInBackground(SaveImageInBackgroundData... params){
  if (params.length != 1)   return null;
  if (isCancelled()) {
    params[0].clearImage();
    params[0].clearContext();
    return null;
  }
  Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
  Context context=params[0].context;
  Bitmap image=params[0].image;
  Resources r=context.getResources();
  try {
    mScreenshotDir.mkdirs();
    ContentValues values=new ContentValues();
    ContentResolver resolver=context.getContentResolver();
    values.put(MediaStore.Images.ImageColumns.DATA,mImageFilePath);
    values.put(MediaStore.Images.ImageColumns.TITLE,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DISPLAY_NAME,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DATE_TAKEN,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_ADDED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_MODIFIED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.MIME_TYPE,""String_Node_Str"");
    values.put(MediaStore.Images.ImageColumns.WIDTH,mImageWidth);
    values.put(MediaStore.Images.ImageColumns.HEIGHT,mImageHeight);
    Uri uri=resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,values);
    String subjectDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
    String subject=String.format(SCREENSHOT_SHARE_SUBJECT_TEMPLATE,subjectDate);
    Intent sharingIntent=new Intent(Intent.ACTION_SEND);
    sharingIntent.setType(""String_Node_Str"");
    sharingIntent.putExtra(Intent.EXTRA_STREAM,uri);
    sharingIntent.putExtra(Intent.EXTRA_SUBJECT,subject);
    Intent chooserIntent=Intent.createChooser(sharingIntent,null);
    chooserIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.addAction(R.drawable.ic_menu_share,r.getString(com.android.internal.R.string.share),PendingIntent.getActivity(context,0,chooserIntent,PendingIntent.FLAG_CANCEL_CURRENT));
    OutputStream out=resolver.openOutputStream(uri);
    image.compress(Bitmap.CompressFormat.PNG,100,out);
    out.flush();
    out.close();
    values.clear();
    values.put(MediaStore.Images.ImageColumns.SIZE,new File(mImageFilePath).length());
    resolver.update(uri,values,null,null);
    params[0].imageUri=uri;
    params[0].image=null;
    params[0].result=0;
  }
 catch (  Exception e) {
    params[0].clearImage();
    params[0].result=1;
  }
  if (image != null) {
    image.recycle();
  }
  return params[0];
}"
2507,"@Override protected void onPostExecute(SaveImageInBackgroundData params){
  if (isCancelled()) {
    params.finisher.run();
    params.clearImage();
    Log.d(TAG,""String_Node_Str"");
    return;
  }
  if (params.result > 0) {
    GlobalScreenshot.notifyScreenshotError(params.context,mNotificationManager);
  }
 else {
    Resources r=params.context.getResources();
    Intent launchIntent=new Intent(Intent.ACTION_VIEW);
    launchIntent.setDataAndType(params.imageUri,""String_Node_Str"");
    launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.setContentTitle(r.getString(R.string.screenshot_saved_title)).setContentText(r.getString(R.string.screenshot_saved_text)).setContentIntent(PendingIntent.getActivity(params.context,0,launchIntent,0)).setWhen(System.currentTimeMillis()).setAutoCancel(true);
    Notification n=mNotificationBuilder.build();
    n.flags&=~Notification.FLAG_NO_CLEAR;
    mNotificationManager.notify(mNotificationId,n);
  }
  params.finisher.run();
  Log.d(TAG,""String_Node_Str"");
}","@Override protected void onPostExecute(SaveImageInBackgroundData params){
  if (isCancelled()) {
    params.finisher.run();
    params.clearImage();
    params.clearContext();
    return;
  }
  if (params.result > 0) {
    GlobalScreenshot.notifyScreenshotError(params.context,mNotificationManager);
  }
 else {
    Resources r=params.context.getResources();
    Intent launchIntent=new Intent(Intent.ACTION_VIEW);
    launchIntent.setDataAndType(params.imageUri,""String_Node_Str"");
    launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.setContentTitle(r.getString(R.string.screenshot_saved_title)).setContentText(r.getString(R.string.screenshot_saved_text)).setContentIntent(PendingIntent.getActivity(params.context,0,launchIntent,0)).setWhen(System.currentTimeMillis()).setAutoCancel(true);
    Notification n=mNotificationBuilder.build();
    n.flags&=~Notification.FLAG_NO_CLEAR;
    mNotificationManager.notify(mNotificationId,n);
  }
  params.finisher.run();
  params.clearContext();
}"
2508,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case 1:
    final Messenger callback=msg.replyTo;
  if (mScreenshot == null) {
    mScreenshot=new GlobalScreenshot(TakeScreenshotService.this);
    Log.d(TAG,""String_Node_Str"");
  }
Log.d(TAG,""String_Node_Str"");
mScreenshot.takeScreenshot(new Runnable(){
@Override public void run(){
  Message reply=Message.obtain(null,1);
  try {
    callback.send(reply);
    Log.d(TAG,""String_Node_Str"");
  }
 catch (  RemoteException e) {
  }
}
}
,msg.arg1 > 0,msg.arg2 > 0);
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case 1:
    final Messenger callback=msg.replyTo;
  if (mScreenshot == null) {
    mScreenshot=new GlobalScreenshot(TakeScreenshotService.this);
  }
mScreenshot.takeScreenshot(new Runnable(){
  @Override public void run(){
    Message reply=Message.obtain(null,1);
    try {
      callback.send(reply);
    }
 catch (    RemoteException e) {
    }
  }
}
,msg.arg1 > 0,msg.arg2 > 0);
}
}"
2509,"@Override public void run(){
  Message reply=Message.obtain(null,1);
  try {
    callback.send(reply);
    Log.d(TAG,""String_Node_Str"");
  }
 catch (  RemoteException e) {
  }
}","@Override public void run(){
  Message reply=Message.obtain(null,1);
  try {
    callback.send(reply);
  }
 catch (  RemoteException e) {
  }
}"
2510,"private static void exportFields(Context context,Object view,BufferedWriter out,Class<?> klass,String prefix) throws IOException {
  final Field[] fields=getExportedPropertyFields(klass);
  int count=fields.length;
  for (int i=0; i < count; i++) {
    final Field field=fields[i];
    try {
      Object fieldValue=null;
      final Class<?> type=field.getType();
      final ExportedProperty property=sAnnotations.get(field);
      String categoryPrefix=property.category().length() != 0 ? property.category() + ""String_Node_Str"" : ""String_Node_Str"";
      if (type == int.class) {
        if (property.resolveId() && context != null) {
          final int id=field.getInt(view);
          fieldValue=resolveId(context,id);
        }
 else {
          final FlagToString[] flagsMapping=property.flagMapping();
          if (flagsMapping.length > 0) {
            final int intValue=field.getInt(view);
            final String valuePrefix=categoryPrefix + prefix + field.getName()+ '_';
            exportUnrolledFlags(out,flagsMapping,intValue,valuePrefix);
          }
          final IntToString[] mapping=property.mapping();
          if (mapping.length > 0) {
            final int intValue=field.getInt(view);
            int mappingCount=mapping.length;
            for (int j=0; j < mappingCount; j++) {
              final IntToString mapped=mapping[j];
              if (mapped.from() == intValue) {
                fieldValue=mapped.to();
                break;
              }
            }
            if (fieldValue == null) {
              fieldValue=intValue;
            }
          }
        }
      }
 else       if (type == int[].class) {
        final int[] array=(int[])field.get(view);
        final String valuePrefix=categoryPrefix + prefix + field.getName()+ '_';
        final String suffix=""String_Node_Str"";
        exportUnrolledArray(context,out,property,array,valuePrefix,suffix);
        return;
      }
 else       if (!type.isPrimitive()) {
        if (property.deepExport()) {
          dumpViewProperties(context,field.get(view),out,prefix + property.prefix());
          continue;
        }
      }
      if (fieldValue == null) {
        fieldValue=field.get(view);
      }
      writeEntry(out,categoryPrefix + prefix,field.getName(),""String_Node_Str"",fieldValue);
    }
 catch (    IllegalAccessException e) {
    }
  }
}","private static void exportFields(Context context,Object view,BufferedWriter out,Class<?> klass,String prefix) throws IOException {
  final Field[] fields=getExportedPropertyFields(klass);
  int count=fields.length;
  for (int i=0; i < count; i++) {
    final Field field=fields[i];
    try {
      Object fieldValue=null;
      final Class<?> type=field.getType();
      final ExportedProperty property=sAnnotations.get(field);
      String categoryPrefix=property.category().length() != 0 ? property.category() + ""String_Node_Str"" : ""String_Node_Str"";
      if (type == int.class || type == byte.class) {
        if (property.resolveId() && context != null) {
          final int id=field.getInt(view);
          fieldValue=resolveId(context,id);
        }
 else {
          final FlagToString[] flagsMapping=property.flagMapping();
          if (flagsMapping.length > 0) {
            final int intValue=field.getInt(view);
            final String valuePrefix=categoryPrefix + prefix + field.getName()+ '_';
            exportUnrolledFlags(out,flagsMapping,intValue,valuePrefix);
          }
          final IntToString[] mapping=property.mapping();
          if (mapping.length > 0) {
            final int intValue=field.getInt(view);
            int mappingCount=mapping.length;
            for (int j=0; j < mappingCount; j++) {
              final IntToString mapped=mapping[j];
              if (mapped.from() == intValue) {
                fieldValue=mapped.to();
                break;
              }
            }
            if (fieldValue == null) {
              fieldValue=intValue;
            }
          }
        }
      }
 else       if (type == int[].class) {
        final int[] array=(int[])field.get(view);
        final String valuePrefix=categoryPrefix + prefix + field.getName()+ '_';
        final String suffix=""String_Node_Str"";
        exportUnrolledArray(context,out,property,array,valuePrefix,suffix);
        return;
      }
 else       if (!type.isPrimitive()) {
        if (property.deepExport()) {
          dumpViewProperties(context,field.get(view),out,prefix + property.prefix());
          continue;
        }
      }
      if (fieldValue == null) {
        fieldValue=field.get(view);
      }
      writeEntry(out,categoryPrefix + prefix,field.getName(),""String_Node_Str"",fieldValue);
    }
 catch (    IllegalAccessException e) {
    }
  }
}"
2511,"/** 
 * Set the layout direction
 * @param layoutDirection the layout direction.Should be either  {@link View#LAYOUT_DIRECTION_LTR}or   {@link View#LAYOUT_DIRECTION_RTL}.
 */
public void setLayoutDirection(int layoutDirection){
  if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)   return;
  if (layoutDirection != this.mLayoutDirection) {
    this.mLayoutDirection=layoutDirection;
    this.mNeedResolution=isMarginRelative();
  }
}","/** 
 * Set the layout direction
 * @param layoutDirection the layout direction.Should be either  {@link View#LAYOUT_DIRECTION_LTR}or   {@link View#LAYOUT_DIRECTION_RTL}.
 */
public void setLayoutDirection(int layoutDirection){
  if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)   return;
  if (layoutDirection != (mMarginFlags & LAYOUT_DIRECTION_MASK)) {
    mMarginFlags&=~LAYOUT_DIRECTION_MASK;
    mMarginFlags|=(layoutDirection & LAYOUT_DIRECTION_MASK);
    if (isMarginRelative()) {
      mMarginFlags|=NEED_RESOLUTION_MASK;
    }
 else {
      mMarginFlags&=~NEED_RESOLUTION_MASK;
    }
  }
}"
2512,"/** 
 * Returns the start margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @return the start margin in pixels.
 */
public int getMarginStart(){
  if (startMargin != DEFAULT_MARGIN_RELATIVE)   return startMargin;
  if (mNeedResolution) {
    doResolveMargins();
  }
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return rightMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return leftMargin;
}
}","/** 
 * Returns the start margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @return the start margin in pixels.
 */
public int getMarginStart(){
  if (startMargin != DEFAULT_MARGIN_RELATIVE)   return startMargin;
  if ((mMarginFlags & NEED_RESOLUTION_MASK) == NEED_RESOLUTION_MASK) {
    doResolveMargins();
  }
switch (mMarginFlags & LAYOUT_DIRECTION_MASK) {
case View.LAYOUT_DIRECTION_RTL:
    return rightMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return leftMargin;
}
}"
2513,"/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mLeftMarginUndefined=false;
  mRightMarginUndefined=false;
  mNeedResolution=isMarginRelative();
}","/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mMarginFlags&=~LEFT_MARGIN_UNDEFINED_MASK;
  mMarginFlags&=~RIGHT_MARGIN_UNDEFINED_MASK;
  if (isMarginRelative()) {
    mMarginFlags|=NEED_RESOLUTION_MASK;
  }
 else {
    mMarginFlags&=~NEED_RESOLUTION_MASK;
  }
}"
2514,"/** 
 * @hide
 */
public boolean isLayoutRtl(){
  return (mLayoutDirection == View.LAYOUT_DIRECTION_RTL);
}","/** 
 * @hide
 */
public boolean isLayoutRtl(){
  return ((mMarginFlags & LAYOUT_DIRECTION_MASK) == View.LAYOUT_DIRECTION_RTL);
}"
2515,"/** 
 * Returns the end margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return the end margin in pixels.
 */
public int getMarginEnd(){
  if (endMargin != DEFAULT_MARGIN_RELATIVE)   return endMargin;
  if (mNeedResolution) {
    doResolveMargins();
  }
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return leftMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return rightMargin;
}
}","/** 
 * Returns the end margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return the end margin in pixels.
 */
public int getMarginEnd(){
  if (endMargin != DEFAULT_MARGIN_RELATIVE)   return endMargin;
  if ((mMarginFlags & NEED_RESOLUTION_MASK) == NEED_RESOLUTION_MASK) {
    doResolveMargins();
  }
switch (mMarginFlags & LAYOUT_DIRECTION_MASK) {
case View.LAYOUT_DIRECTION_RTL:
    return leftMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return rightMargin;
}
}"
2516,"/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mLeftMarginUndefined=true;
  mRightMarginUndefined=true;
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}","/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mMarginFlags|=LEFT_MARGIN_UNDEFINED_MASK;
  mMarginFlags|=RIGHT_MARGIN_UNDEFINED_MASK;
  mMarginFlags&=~NEED_RESOLUTION_MASK;
  mMarginFlags&=~RTL_COMPATIBILITY_MODE_MASK;
}"
2517,"/** 
 * Retuns the layout direction. Can be either   {@link View#LAYOUT_DIRECTION_LTR} or{@link View#LAYOUT_DIRECTION_RTL}.
 * @return the layout direction.
 */
public int getLayoutDirection(){
  return mLayoutDirection;
}","/** 
 * Retuns the layout direction. Can be either   {@link View#LAYOUT_DIRECTION_LTR} or{@link View#LAYOUT_DIRECTION_RTL}.
 * @return the layout direction.
 */
public int getLayoutDirection(){
  return (mMarginFlags & LAYOUT_DIRECTION_MASK);
}"
2518,"private void doResolveMargins(){
  if (mIsRtlCompatibilityMode) {
    if (mLeftMarginUndefined && startMargin > DEFAULT_MARGIN_RELATIVE) {
      leftMargin=startMargin;
    }
    if (mRightMarginUndefined && endMargin > DEFAULT_MARGIN_RELATIVE) {
      rightMargin=endMargin;
    }
  }
 else {
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
      leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
    rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
  break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
}
mNeedResolution=false;
}","private void doResolveMargins(){
  if ((mMarginFlags & RTL_COMPATIBILITY_MODE_MASK) == RTL_COMPATIBILITY_MODE_MASK) {
    if ((mMarginFlags & LEFT_MARGIN_UNDEFINED_MASK) == LEFT_MARGIN_UNDEFINED_MASK && startMargin > DEFAULT_MARGIN_RELATIVE) {
      leftMargin=startMargin;
    }
    if ((mMarginFlags & RIGHT_MARGIN_UNDEFINED_MASK) == RIGHT_MARGIN_UNDEFINED_MASK && endMargin > DEFAULT_MARGIN_RELATIVE) {
      rightMargin=endMargin;
    }
  }
 else {
switch (mMarginFlags & LAYOUT_DIRECTION_MASK) {
case View.LAYOUT_DIRECTION_RTL:
      leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
    rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
  break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
}
mMarginFlags&=~NEED_RESOLUTION_MASK;
}"
2519,"/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution)   return;
  doResolveMargins();
}","/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || (mMarginFlags & NEED_RESOLUTION_MASK) != NEED_RESOLUTION_MASK)   return;
  doResolveMargins();
}"
2520,"/** 
 * Sets the relative end margin.
 * @param end the end margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 */
public void setMarginEnd(int end){
  endMargin=end;
  mNeedResolution=true;
}","/** 
 * Sets the relative end margin.
 * @param end the end margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 */
public void setMarginEnd(int end){
  endMargin=end;
  mMarginFlags|=NEED_RESOLUTION_MASK;
}"
2521,"/** 
 * Sets the relative margins, in pixels. A call to   {@link android.view.View#requestLayout()}needs to be done so that the new relative margins are taken into account. Left and right margins may be overriden by   {@link android.view.View#requestLayout()} depending on layoutdirection.
 * @param start the start margin size
 * @param top the top margin size
 * @param end the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 * @hide
 */
public void setMarginsRelative(int start,int top,int end,int bottom){
  startMargin=start;
  topMargin=top;
  endMargin=end;
  bottomMargin=bottom;
  mNeedResolution=true;
}","/** 
 * Sets the relative margins, in pixels. A call to   {@link android.view.View#requestLayout()}needs to be done so that the new relative margins are taken into account. Left and right margins may be overriden by   {@link android.view.View#requestLayout()} depending on layoutdirection.
 * @param start the start margin size
 * @param top the top margin size
 * @param end the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 * @hide
 */
public void setMarginsRelative(int start,int top,int end,int bottom){
  startMargin=start;
  topMargin=top;
  endMargin=end;
  bottomMargin=bottom;
  mMarginFlags|=NEED_RESOLUTION_MASK;
}"
2522,"/** 
 * Sets the relative start margin.
 * @param start the start margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 */
public void setMarginStart(int start){
  startMargin=start;
  mNeedResolution=true;
}","/** 
 * Sets the relative start margin.
 * @param start the start margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 */
public void setMarginStart(int start){
  startMargin=start;
  mMarginFlags|=NEED_RESOLUTION_MASK;
}"
2523,"private static void exportFields(Context context,Object view,BufferedWriter out,Class<?> klass,String prefix) throws IOException {
  final Field[] fields=getExportedPropertyFields(klass);
  int count=fields.length;
  for (int i=0; i < count; i++) {
    final Field field=fields[i];
    try {
      Object fieldValue=null;
      final Class<?> type=field.getType();
      final ExportedProperty property=sAnnotations.get(field);
      String categoryPrefix=property.category().length() != 0 ? property.category() + ""String_Node_Str"" : ""String_Node_Str"";
      if (type == int.class) {
        if (property.resolveId() && context != null) {
          final int id=field.getInt(view);
          fieldValue=resolveId(context,id);
        }
 else {
          final FlagToString[] flagsMapping=property.flagMapping();
          if (flagsMapping.length > 0) {
            final int intValue=field.getInt(view);
            final String valuePrefix=categoryPrefix + prefix + field.getName()+ '_';
            exportUnrolledFlags(out,flagsMapping,intValue,valuePrefix);
          }
          final IntToString[] mapping=property.mapping();
          if (mapping.length > 0) {
            final int intValue=field.getInt(view);
            int mappingCount=mapping.length;
            for (int j=0; j < mappingCount; j++) {
              final IntToString mapped=mapping[j];
              if (mapped.from() == intValue) {
                fieldValue=mapped.to();
                break;
              }
            }
            if (fieldValue == null) {
              fieldValue=intValue;
            }
          }
        }
      }
 else       if (type == int[].class) {
        final int[] array=(int[])field.get(view);
        final String valuePrefix=categoryPrefix + prefix + field.getName()+ '_';
        final String suffix=""String_Node_Str"";
        exportUnrolledArray(context,out,property,array,valuePrefix,suffix);
        return;
      }
 else       if (!type.isPrimitive()) {
        if (property.deepExport()) {
          dumpViewProperties(context,field.get(view),out,prefix + property.prefix());
          continue;
        }
      }
      if (fieldValue == null) {
        fieldValue=field.get(view);
      }
      writeEntry(out,categoryPrefix + prefix,field.getName(),""String_Node_Str"",fieldValue);
    }
 catch (    IllegalAccessException e) {
    }
  }
}","private static void exportFields(Context context,Object view,BufferedWriter out,Class<?> klass,String prefix) throws IOException {
  final Field[] fields=getExportedPropertyFields(klass);
  int count=fields.length;
  for (int i=0; i < count; i++) {
    final Field field=fields[i];
    try {
      Object fieldValue=null;
      final Class<?> type=field.getType();
      final ExportedProperty property=sAnnotations.get(field);
      String categoryPrefix=property.category().length() != 0 ? property.category() + ""String_Node_Str"" : ""String_Node_Str"";
      if (type == int.class || type == byte.class) {
        if (property.resolveId() && context != null) {
          final int id=field.getInt(view);
          fieldValue=resolveId(context,id);
        }
 else {
          final FlagToString[] flagsMapping=property.flagMapping();
          if (flagsMapping.length > 0) {
            final int intValue=field.getInt(view);
            final String valuePrefix=categoryPrefix + prefix + field.getName()+ '_';
            exportUnrolledFlags(out,flagsMapping,intValue,valuePrefix);
          }
          final IntToString[] mapping=property.mapping();
          if (mapping.length > 0) {
            final int intValue=field.getInt(view);
            int mappingCount=mapping.length;
            for (int j=0; j < mappingCount; j++) {
              final IntToString mapped=mapping[j];
              if (mapped.from() == intValue) {
                fieldValue=mapped.to();
                break;
              }
            }
            if (fieldValue == null) {
              fieldValue=intValue;
            }
          }
        }
      }
 else       if (type == int[].class) {
        final int[] array=(int[])field.get(view);
        final String valuePrefix=categoryPrefix + prefix + field.getName()+ '_';
        final String suffix=""String_Node_Str"";
        exportUnrolledArray(context,out,property,array,valuePrefix,suffix);
        return;
      }
 else       if (!type.isPrimitive()) {
        if (property.deepExport()) {
          dumpViewProperties(context,field.get(view),out,prefix + property.prefix());
          continue;
        }
      }
      if (fieldValue == null) {
        fieldValue=field.get(view);
      }
      writeEntry(out,categoryPrefix + prefix,field.getName(),""String_Node_Str"",fieldValue);
    }
 catch (    IllegalAccessException e) {
    }
  }
}"
2524,"/** 
 * Set the layout direction
 * @param layoutDirection the layout direction.Should be either  {@link View#LAYOUT_DIRECTION_LTR}or   {@link View#LAYOUT_DIRECTION_RTL}.
 */
public void setLayoutDirection(int layoutDirection){
  if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)   return;
  if (layoutDirection != this.mLayoutDirection) {
    this.mLayoutDirection=layoutDirection;
    this.mNeedResolution=isMarginRelative();
  }
}","/** 
 * Set the layout direction
 * @param layoutDirection the layout direction.Should be either  {@link View#LAYOUT_DIRECTION_LTR}or   {@link View#LAYOUT_DIRECTION_RTL}.
 */
public void setLayoutDirection(int layoutDirection){
  if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)   return;
  if (layoutDirection != (mMarginFlags & LAYOUT_DIRECTION_MASK)) {
    mMarginFlags&=~LAYOUT_DIRECTION_MASK;
    mMarginFlags|=(layoutDirection & LAYOUT_DIRECTION_MASK);
    if (isMarginRelative()) {
      mMarginFlags|=NEED_RESOLUTION_MASK;
    }
 else {
      mMarginFlags&=~NEED_RESOLUTION_MASK;
    }
  }
}"
2525,"/** 
 * Returns the start margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @return the start margin in pixels.
 */
public int getMarginStart(){
  if (startMargin != DEFAULT_MARGIN_RELATIVE)   return startMargin;
  if (mNeedResolution) {
    doResolveMargins();
  }
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return rightMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return leftMargin;
}
}","/** 
 * Returns the start margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @return the start margin in pixels.
 */
public int getMarginStart(){
  if (startMargin != DEFAULT_MARGIN_RELATIVE)   return startMargin;
  if ((mMarginFlags & NEED_RESOLUTION_MASK) == NEED_RESOLUTION_MASK) {
    doResolveMargins();
  }
switch (mMarginFlags & LAYOUT_DIRECTION_MASK) {
case View.LAYOUT_DIRECTION_RTL:
    return rightMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return leftMargin;
}
}"
2526,"/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mLeftMarginUndefined=false;
  mRightMarginUndefined=false;
  mNeedResolution=isMarginRelative();
}","/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mMarginFlags&=~LEFT_MARGIN_UNDEFINED_MASK;
  mMarginFlags&=~RIGHT_MARGIN_UNDEFINED_MASK;
  if (isMarginRelative()) {
    mMarginFlags|=NEED_RESOLUTION_MASK;
  }
 else {
    mMarginFlags&=~NEED_RESOLUTION_MASK;
  }
}"
2527,"/** 
 * @hide
 */
public boolean isLayoutRtl(){
  return (mLayoutDirection == View.LAYOUT_DIRECTION_RTL);
}","/** 
 * @hide
 */
public boolean isLayoutRtl(){
  return ((mMarginFlags & LAYOUT_DIRECTION_MASK) == View.LAYOUT_DIRECTION_RTL);
}"
2528,"/** 
 * Returns the end margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return the end margin in pixels.
 */
public int getMarginEnd(){
  if (endMargin != DEFAULT_MARGIN_RELATIVE)   return endMargin;
  if (mNeedResolution) {
    doResolveMargins();
  }
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return leftMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return rightMargin;
}
}","/** 
 * Returns the end margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return the end margin in pixels.
 */
public int getMarginEnd(){
  if (endMargin != DEFAULT_MARGIN_RELATIVE)   return endMargin;
  if ((mMarginFlags & NEED_RESOLUTION_MASK) == NEED_RESOLUTION_MASK) {
    doResolveMargins();
  }
switch (mMarginFlags & LAYOUT_DIRECTION_MASK) {
case View.LAYOUT_DIRECTION_RTL:
    return leftMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return rightMargin;
}
}"
2529,"/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mLeftMarginUndefined=true;
  mRightMarginUndefined=true;
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}","/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mMarginFlags|=LEFT_MARGIN_UNDEFINED_MASK;
  mMarginFlags|=RIGHT_MARGIN_UNDEFINED_MASK;
  mMarginFlags&=~NEED_RESOLUTION_MASK;
  mMarginFlags&=~RTL_COMPATIBILITY_MODE_MASK;
}"
2530,"/** 
 * Retuns the layout direction. Can be either   {@link View#LAYOUT_DIRECTION_LTR} or{@link View#LAYOUT_DIRECTION_RTL}.
 * @return the layout direction.
 */
public int getLayoutDirection(){
  return mLayoutDirection;
}","/** 
 * Retuns the layout direction. Can be either   {@link View#LAYOUT_DIRECTION_LTR} or{@link View#LAYOUT_DIRECTION_RTL}.
 * @return the layout direction.
 */
public int getLayoutDirection(){
  return (mMarginFlags & LAYOUT_DIRECTION_MASK);
}"
2531,"private void doResolveMargins(){
  if (mIsRtlCompatibilityMode) {
    if (mLeftMarginUndefined && startMargin > DEFAULT_MARGIN_RELATIVE) {
      leftMargin=startMargin;
    }
    if (mRightMarginUndefined && endMargin > DEFAULT_MARGIN_RELATIVE) {
      rightMargin=endMargin;
    }
  }
 else {
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
      leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
    rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
  break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
}
mNeedResolution=false;
}","private void doResolveMargins(){
  if ((mMarginFlags & RTL_COMPATIBILITY_MODE_MASK) == RTL_COMPATIBILITY_MODE_MASK) {
    if ((mMarginFlags & LEFT_MARGIN_UNDEFINED_MASK) == LEFT_MARGIN_UNDEFINED_MASK && startMargin > DEFAULT_MARGIN_RELATIVE) {
      leftMargin=startMargin;
    }
    if ((mMarginFlags & RIGHT_MARGIN_UNDEFINED_MASK) == RIGHT_MARGIN_UNDEFINED_MASK && endMargin > DEFAULT_MARGIN_RELATIVE) {
      rightMargin=endMargin;
    }
  }
 else {
switch (mMarginFlags & LAYOUT_DIRECTION_MASK) {
case View.LAYOUT_DIRECTION_RTL:
      leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
    rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
  break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
}
mMarginFlags&=~NEED_RESOLUTION_MASK;
}"
2532,"/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution)   return;
  doResolveMargins();
}","/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || (mMarginFlags & NEED_RESOLUTION_MASK) != NEED_RESOLUTION_MASK)   return;
  doResolveMargins();
}"
2533,"/** 
 * Sets the relative end margin.
 * @param end the end margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 */
public void setMarginEnd(int end){
  endMargin=end;
  mNeedResolution=true;
}","/** 
 * Sets the relative end margin.
 * @param end the end margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 */
public void setMarginEnd(int end){
  endMargin=end;
  mMarginFlags|=NEED_RESOLUTION_MASK;
}"
2534,"/** 
 * Sets the relative margins, in pixels. A call to   {@link android.view.View#requestLayout()}needs to be done so that the new relative margins are taken into account. Left and right margins may be overriden by   {@link android.view.View#requestLayout()} depending on layoutdirection.
 * @param start the start margin size
 * @param top the top margin size
 * @param end the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 * @hide
 */
public void setMarginsRelative(int start,int top,int end,int bottom){
  startMargin=start;
  topMargin=top;
  endMargin=end;
  bottomMargin=bottom;
  mNeedResolution=true;
}","/** 
 * Sets the relative margins, in pixels. A call to   {@link android.view.View#requestLayout()}needs to be done so that the new relative margins are taken into account. Left and right margins may be overriden by   {@link android.view.View#requestLayout()} depending on layoutdirection.
 * @param start the start margin size
 * @param top the top margin size
 * @param end the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 * @hide
 */
public void setMarginsRelative(int start,int top,int end,int bottom){
  startMargin=start;
  topMargin=top;
  endMargin=end;
  bottomMargin=bottom;
  mMarginFlags|=NEED_RESOLUTION_MASK;
}"
2535,"/** 
 * Sets the relative start margin.
 * @param start the start margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 */
public void setMarginStart(int start){
  startMargin=start;
  mNeedResolution=true;
}","/** 
 * Sets the relative start margin.
 * @param start the start margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 */
public void setMarginStart(int start){
  startMargin=start;
  mMarginFlags|=NEED_RESOLUTION_MASK;
}"
2536,"/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mNeedResolution=isMarginRelative();
}","/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mLeftMarginUndefined=false;
  mRightMarginUndefined=false;
  mNeedResolution=isMarginRelative();
}"
2537,"/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}","/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mLeftMarginUndefined=true;
  mRightMarginUndefined=true;
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}"
2538,"private void doResolveMargins(){
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
  rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
mNeedResolution=false;
}","private void doResolveMargins(){
  if (mIsRtlCompatibilityMode) {
    if (mLeftMarginUndefined && startMargin > DEFAULT_MARGIN_RELATIVE) {
      leftMargin=startMargin;
    }
    if (mRightMarginUndefined && endMargin > DEFAULT_MARGIN_RELATIVE) {
      rightMargin=endMargin;
    }
  }
 else {
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
      leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
    rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
  break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
}
mNeedResolution=false;
}"
2539,"/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution || mIsRtlCompatibilityMode)   return;
  doResolveMargins();
}","/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution)   return;
  doResolveMargins();
}"
2540,"/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mNeedResolution=isMarginRelative();
}","/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mLeftMarginUndefined=false;
  mRightMarginUndefined=false;
  mNeedResolution=isMarginRelative();
}"
2541,"/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}","/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mLeftMarginUndefined=true;
  mRightMarginUndefined=true;
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}"
2542,"private void doResolveMargins(){
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
  rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
mNeedResolution=false;
}","private void doResolveMargins(){
  if (mIsRtlCompatibilityMode) {
    if (mLeftMarginUndefined && startMargin > DEFAULT_MARGIN_RELATIVE) {
      leftMargin=startMargin;
    }
    if (mRightMarginUndefined && endMargin > DEFAULT_MARGIN_RELATIVE) {
      rightMargin=endMargin;
    }
  }
 else {
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
      leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
    rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
  break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
}
mNeedResolution=false;
}"
2543,"/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution || mIsRtlCompatibilityMode)   return;
  doResolveMargins();
}","/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution)   return;
  doResolveMargins();
}"
2544,"/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mNeedResolution=isMarginRelative();
}","/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mLeftMarginUndefined=false;
  mRightMarginUndefined=false;
  mNeedResolution=isMarginRelative();
}"
2545,"/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}","/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mLeftMarginUndefined=true;
  mRightMarginUndefined=true;
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}"
2546,"private void doResolveMargins(){
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
  rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
mNeedResolution=false;
}","private void doResolveMargins(){
  if (mIsRtlCompatibilityMode) {
    if (mLeftMarginUndefined && startMargin > DEFAULT_MARGIN_RELATIVE) {
      leftMargin=startMargin;
    }
    if (mRightMarginUndefined && endMargin > DEFAULT_MARGIN_RELATIVE) {
      rightMargin=endMargin;
    }
  }
 else {
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
      leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
    rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
  break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
}
mNeedResolution=false;
}"
2547,"/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution || mIsRtlCompatibilityMode)   return;
  doResolveMargins();
}","/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution)   return;
  doResolveMargins();
}"
2548,"private void reopenMenu(boolean toggleMenuMode){
  if (mActionBar != null && mActionBar.isOverflowReserved()) {
    final Callback cb=getCallback();
    if (!mActionBar.isOverflowMenuShowing() || !toggleMenuMode) {
      if (cb != null && !isDestroyed() && mActionBar.getVisibility() == View.VISIBLE) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        if (st.menu != null && !st.refreshMenuContent && cb.onPreparePanel(FEATURE_OPTIONS_PANEL,st.createdPanelView,st.menu)) {
          cb.onMenuOpened(FEATURE_ACTION_BAR,st.menu);
          mActionBar.showOverflowMenu();
        }
      }
    }
 else {
      mActionBar.hideOverflowMenu();
      if (cb != null && !isDestroyed()) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        cb.onPanelClosed(FEATURE_ACTION_BAR,st.menu);
      }
    }
    return;
  }
  PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
  boolean newExpandedMode=toggleMenuMode ? !st.isInExpandedMode : st.isInExpandedMode;
  st.refreshDecorView=true;
  closePanel(st,false);
  st.isInExpandedMode=newExpandedMode;
  openPanel(st,null);
}","private void reopenMenu(boolean toggleMenuMode){
  if (mActionBar != null && mActionBar.isOverflowReserved()) {
    final Callback cb=getCallback();
    if (!mActionBar.isOverflowMenuShowing() || !toggleMenuMode) {
      if (cb != null && !isDestroyed() && mActionBar.getVisibility() == View.VISIBLE) {
        if (mInvalidatePanelMenuPosted && (mInvalidatePanelMenuFeatures & (1 << FEATURE_OPTIONS_PANEL)) != 0) {
          mDecor.removeCallbacks(mInvalidatePanelMenuRunnable);
          mInvalidatePanelMenuRunnable.run();
        }
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        if (st.menu != null && !st.refreshMenuContent && cb.onPreparePanel(FEATURE_OPTIONS_PANEL,st.createdPanelView,st.menu)) {
          cb.onMenuOpened(FEATURE_ACTION_BAR,st.menu);
          mActionBar.showOverflowMenu();
        }
      }
    }
 else {
      mActionBar.hideOverflowMenu();
      if (cb != null && !isDestroyed()) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        cb.onPanelClosed(FEATURE_ACTION_BAR,st.menu);
      }
    }
    return;
  }
  PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
  boolean newExpandedMode=toggleMenuMode ? !st.isInExpandedMode : st.isInExpandedMode;
  st.refreshDecorView=true;
  closePanel(st,false);
  st.isInExpandedMode=newExpandedMode;
  openPanel(st,null);
}"
2549,"private void reopenMenu(boolean toggleMenuMode){
  if (mActionBar != null && mActionBar.isOverflowReserved()) {
    final Callback cb=getCallback();
    if (!mActionBar.isOverflowMenuShowing() || !toggleMenuMode) {
      if (cb != null && !isDestroyed() && mActionBar.getVisibility() == View.VISIBLE) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        if (st.menu != null && !st.refreshMenuContent && cb.onPreparePanel(FEATURE_OPTIONS_PANEL,st.createdPanelView,st.menu)) {
          cb.onMenuOpened(FEATURE_ACTION_BAR,st.menu);
          mActionBar.showOverflowMenu();
        }
      }
    }
 else {
      mActionBar.hideOverflowMenu();
      if (cb != null && !isDestroyed()) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        cb.onPanelClosed(FEATURE_ACTION_BAR,st.menu);
      }
    }
    return;
  }
  PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
  boolean newExpandedMode=toggleMenuMode ? !st.isInExpandedMode : st.isInExpandedMode;
  st.refreshDecorView=true;
  closePanel(st,false);
  st.isInExpandedMode=newExpandedMode;
  openPanel(st,null);
}","private void reopenMenu(boolean toggleMenuMode){
  if (mActionBar != null && mActionBar.isOverflowReserved()) {
    final Callback cb=getCallback();
    if (!mActionBar.isOverflowMenuShowing() || !toggleMenuMode) {
      if (cb != null && !isDestroyed() && mActionBar.getVisibility() == View.VISIBLE) {
        if (mInvalidatePanelMenuPosted && (mInvalidatePanelMenuFeatures & (1 << FEATURE_OPTIONS_PANEL)) != 0) {
          mDecor.removeCallbacks(mInvalidatePanelMenuRunnable);
          mInvalidatePanelMenuRunnable.run();
        }
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        if (st.menu != null && !st.refreshMenuContent && cb.onPreparePanel(FEATURE_OPTIONS_PANEL,st.createdPanelView,st.menu)) {
          cb.onMenuOpened(FEATURE_ACTION_BAR,st.menu);
          mActionBar.showOverflowMenu();
        }
      }
    }
 else {
      mActionBar.hideOverflowMenu();
      if (cb != null && !isDestroyed()) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        cb.onPanelClosed(FEATURE_ACTION_BAR,st.menu);
      }
    }
    return;
  }
  PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
  boolean newExpandedMode=toggleMenuMode ? !st.isInExpandedMode : st.isInExpandedMode;
  st.refreshDecorView=true;
  closePanel(st,false);
  st.isInExpandedMode=newExpandedMode;
  openPanel(st,null);
}"
2550,"/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mNeedResolution=isMarginRelative();
}","/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mLeftMarginUndefined=false;
  mRightMarginUndefined=false;
  mNeedResolution=isMarginRelative();
}"
2551,"/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}","/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mLeftMarginUndefined=true;
  mRightMarginUndefined=true;
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}"
2552,"private void doResolveMargins(){
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
  rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
mNeedResolution=false;
}","private void doResolveMargins(){
  if (mIsRtlCompatibilityMode) {
    if (mLeftMarginUndefined && startMargin > DEFAULT_MARGIN_RELATIVE) {
      leftMargin=startMargin;
    }
    if (mRightMarginUndefined && endMargin > DEFAULT_MARGIN_RELATIVE) {
      rightMargin=endMargin;
    }
  }
 else {
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
      leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
    rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
  break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
}
mNeedResolution=false;
}"
2553,"/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution || mIsRtlCompatibilityMode)   return;
  doResolveMargins();
}","/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution)   return;
  doResolveMargins();
}"
2554,"/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mNeedResolution=isMarginRelative();
}","/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mLeftMarginUndefined=false;
  mRightMarginUndefined=false;
  mNeedResolution=isMarginRelative();
}"
2555,"/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}","/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mLeftMarginUndefined=true;
  mRightMarginUndefined=true;
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}"
2556,"private void doResolveMargins(){
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
  rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
mNeedResolution=false;
}","private void doResolveMargins(){
  if (mIsRtlCompatibilityMode) {
    if (mLeftMarginUndefined && startMargin > DEFAULT_MARGIN_RELATIVE) {
      leftMargin=startMargin;
    }
    if (mRightMarginUndefined && endMargin > DEFAULT_MARGIN_RELATIVE) {
      rightMargin=endMargin;
    }
  }
 else {
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
      leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
    rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
  break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
}
mNeedResolution=false;
}"
2557,"/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution || mIsRtlCompatibilityMode)   return;
  doResolveMargins();
}","/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution)   return;
  doResolveMargins();
}"
2558,"/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mNeedResolution=isMarginRelative();
}","/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mLeftMarginUndefined=false;
  mRightMarginUndefined=false;
  mNeedResolution=isMarginRelative();
}"
2559,"/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}","/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mLeftMarginUndefined=true;
  mRightMarginUndefined=true;
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}"
2560,"private void doResolveMargins(){
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
  rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
mNeedResolution=false;
}","private void doResolveMargins(){
  if (mIsRtlCompatibilityMode) {
    if (mLeftMarginUndefined && startMargin > DEFAULT_MARGIN_RELATIVE) {
      leftMargin=startMargin;
    }
    if (mRightMarginUndefined && endMargin > DEFAULT_MARGIN_RELATIVE) {
      rightMargin=endMargin;
    }
  }
 else {
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
      leftMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
    rightMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
  break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_MARGIN_RELATIVE) ? startMargin : DEFAULT_MARGIN_RESOLVED;
rightMargin=(endMargin > DEFAULT_MARGIN_RELATIVE) ? endMargin : DEFAULT_MARGIN_RESOLVED;
break;
}
}
mNeedResolution=false;
}"
2561,"/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution || mIsRtlCompatibilityMode)   return;
  doResolveMargins();
}","/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution)   return;
  doResolveMargins();
}"
2562,"private void reopenMenu(boolean toggleMenuMode){
  if (mActionBar != null && mActionBar.isOverflowReserved()) {
    final Callback cb=getCallback();
    if (!mActionBar.isOverflowMenuShowing() || !toggleMenuMode) {
      if (cb != null && !isDestroyed() && mActionBar.getVisibility() == View.VISIBLE) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        if (st.menu != null && !st.refreshMenuContent && cb.onPreparePanel(FEATURE_OPTIONS_PANEL,st.createdPanelView,st.menu)) {
          cb.onMenuOpened(FEATURE_ACTION_BAR,st.menu);
          mActionBar.showOverflowMenu();
        }
      }
    }
 else {
      mActionBar.hideOverflowMenu();
      if (cb != null && !isDestroyed()) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        cb.onPanelClosed(FEATURE_ACTION_BAR,st.menu);
      }
    }
    return;
  }
  PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
  boolean newExpandedMode=toggleMenuMode ? !st.isInExpandedMode : st.isInExpandedMode;
  st.refreshDecorView=true;
  closePanel(st,false);
  st.isInExpandedMode=newExpandedMode;
  openPanel(st,null);
}","private void reopenMenu(boolean toggleMenuMode){
  if (mActionBar != null && mActionBar.isOverflowReserved()) {
    final Callback cb=getCallback();
    if (!mActionBar.isOverflowMenuShowing() || !toggleMenuMode) {
      if (cb != null && !isDestroyed() && mActionBar.getVisibility() == View.VISIBLE) {
        if (mInvalidatePanelMenuPosted && (mInvalidatePanelMenuFeatures & (1 << FEATURE_OPTIONS_PANEL)) != 0) {
          mDecor.removeCallbacks(mInvalidatePanelMenuRunnable);
          mInvalidatePanelMenuRunnable.run();
        }
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        if (st.menu != null && !st.refreshMenuContent && cb.onPreparePanel(FEATURE_OPTIONS_PANEL,st.createdPanelView,st.menu)) {
          cb.onMenuOpened(FEATURE_ACTION_BAR,st.menu);
          mActionBar.showOverflowMenu();
        }
      }
    }
 else {
      mActionBar.hideOverflowMenu();
      if (cb != null && !isDestroyed()) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        cb.onPanelClosed(FEATURE_ACTION_BAR,st.menu);
      }
    }
    return;
  }
  PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
  boolean newExpandedMode=toggleMenuMode ? !st.isInExpandedMode : st.isInExpandedMode;
  st.refreshDecorView=true;
  closePanel(st,false);
  st.isInExpandedMode=newExpandedMode;
  openPanel(st,null);
}"
2563,"private void reopenMenu(boolean toggleMenuMode){
  if (mActionBar != null && mActionBar.isOverflowReserved()) {
    final Callback cb=getCallback();
    if (!mActionBar.isOverflowMenuShowing() || !toggleMenuMode) {
      if (cb != null && !isDestroyed() && mActionBar.getVisibility() == View.VISIBLE) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        if (st.menu != null && !st.refreshMenuContent && cb.onPreparePanel(FEATURE_OPTIONS_PANEL,st.createdPanelView,st.menu)) {
          cb.onMenuOpened(FEATURE_ACTION_BAR,st.menu);
          mActionBar.showOverflowMenu();
        }
      }
    }
 else {
      mActionBar.hideOverflowMenu();
      if (cb != null && !isDestroyed()) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        cb.onPanelClosed(FEATURE_ACTION_BAR,st.menu);
      }
    }
    return;
  }
  PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
  boolean newExpandedMode=toggleMenuMode ? !st.isInExpandedMode : st.isInExpandedMode;
  st.refreshDecorView=true;
  closePanel(st,false);
  st.isInExpandedMode=newExpandedMode;
  openPanel(st,null);
}","private void reopenMenu(boolean toggleMenuMode){
  if (mActionBar != null && mActionBar.isOverflowReserved()) {
    final Callback cb=getCallback();
    if (!mActionBar.isOverflowMenuShowing() || !toggleMenuMode) {
      if (cb != null && !isDestroyed() && mActionBar.getVisibility() == View.VISIBLE) {
        if (mInvalidatePanelMenuPosted && (mInvalidatePanelMenuFeatures & (1 << FEATURE_OPTIONS_PANEL)) != 0) {
          mDecor.removeCallbacks(mInvalidatePanelMenuRunnable);
          mInvalidatePanelMenuRunnable.run();
        }
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        if (st.menu != null && !st.refreshMenuContent && cb.onPreparePanel(FEATURE_OPTIONS_PANEL,st.createdPanelView,st.menu)) {
          cb.onMenuOpened(FEATURE_ACTION_BAR,st.menu);
          mActionBar.showOverflowMenu();
        }
      }
    }
 else {
      mActionBar.hideOverflowMenu();
      if (cb != null && !isDestroyed()) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        cb.onPanelClosed(FEATURE_ACTION_BAR,st.menu);
      }
    }
    return;
  }
  PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
  boolean newExpandedMode=toggleMenuMode ? !st.isInExpandedMode : st.isInExpandedMode;
  st.refreshDecorView=true;
  closePanel(st,false);
  st.isInExpandedMode=newExpandedMode;
  openPanel(st,null);
}"
2564,"private void reopenMenu(boolean toggleMenuMode){
  if (mActionBar != null && mActionBar.isOverflowReserved()) {
    final Callback cb=getCallback();
    if (!mActionBar.isOverflowMenuShowing() || !toggleMenuMode) {
      if (cb != null && !isDestroyed() && mActionBar.getVisibility() == View.VISIBLE) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        if (st.menu != null && !st.refreshMenuContent && cb.onPreparePanel(FEATURE_OPTIONS_PANEL,st.createdPanelView,st.menu)) {
          cb.onMenuOpened(FEATURE_ACTION_BAR,st.menu);
          mActionBar.showOverflowMenu();
        }
      }
    }
 else {
      mActionBar.hideOverflowMenu();
      if (cb != null && !isDestroyed()) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        cb.onPanelClosed(FEATURE_ACTION_BAR,st.menu);
      }
    }
    return;
  }
  PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
  boolean newExpandedMode=toggleMenuMode ? !st.isInExpandedMode : st.isInExpandedMode;
  st.refreshDecorView=true;
  closePanel(st,false);
  st.isInExpandedMode=newExpandedMode;
  openPanel(st,null);
}","private void reopenMenu(boolean toggleMenuMode){
  if (mActionBar != null && mActionBar.isOverflowReserved()) {
    final Callback cb=getCallback();
    if (!mActionBar.isOverflowMenuShowing() || !toggleMenuMode) {
      if (cb != null && !isDestroyed() && mActionBar.getVisibility() == View.VISIBLE) {
        if (mInvalidatePanelMenuPosted && (mInvalidatePanelMenuFeatures & (1 << FEATURE_OPTIONS_PANEL)) != 0) {
          mDecor.removeCallbacks(mInvalidatePanelMenuRunnable);
          mInvalidatePanelMenuRunnable.run();
        }
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        if (st.menu != null && !st.refreshMenuContent && cb.onPreparePanel(FEATURE_OPTIONS_PANEL,st.createdPanelView,st.menu)) {
          cb.onMenuOpened(FEATURE_ACTION_BAR,st.menu);
          mActionBar.showOverflowMenu();
        }
      }
    }
 else {
      mActionBar.hideOverflowMenu();
      if (cb != null && !isDestroyed()) {
        final PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
        cb.onPanelClosed(FEATURE_ACTION_BAR,st.menu);
      }
    }
    return;
  }
  PanelFeatureState st=getPanelState(FEATURE_OPTIONS_PANEL,true);
  boolean newExpandedMode=toggleMenuMode ? !st.isInExpandedMode : st.isInExpandedMode;
  st.refreshDecorView=true;
  closePanel(st,false);
  st.isInExpandedMode=newExpandedMode;
  openPanel(st,null);
}"
2565,"/** 
 * Set the layout direction
 * @param layoutDirection the layout direction.Should be either  {@link View#LAYOUT_DIRECTION_LTR}or   {@link View#LAYOUT_DIRECTION_RTL}.
 */
public void setLayoutDirection(int layoutDirection){
  if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)   return;
  this.layoutDirection=layoutDirection;
}","/** 
 * Set the layout direction
 * @param layoutDirection the layout direction.Should be either  {@link View#LAYOUT_DIRECTION_LTR}or   {@link View#LAYOUT_DIRECTION_RTL}.
 */
public void setLayoutDirection(int layoutDirection){
  if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)   return;
  if (layoutDirection != this.mLayoutDirection) {
    this.mLayoutDirection=layoutDirection;
    this.mNeedResolution=isMarginRelative();
  }
}"
2566,"/** 
 * Returns the start margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @return the start margin in pixels.
 */
public int getMarginStart(){
  if (startMargin != DEFAULT_RELATIVE)   return startMargin;
switch (layoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return rightMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return leftMargin;
}
}","/** 
 * Returns the start margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @return the start margin in pixels.
 */
public int getMarginStart(){
  if (startMargin != DEFAULT_MARGIN_RELATIVE)   return startMargin;
  if (mNeedResolution) {
    doResolveMargins();
  }
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return rightMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return leftMargin;
}
}"
2567,"/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  initialLeftMargin=left;
  initialRightMargin=right;
}","/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mNeedResolution=isMarginRelative();
}"
2568,"/** 
 * @hide
 */
public boolean isLayoutRtl(){
  return (layoutDirection == View.LAYOUT_DIRECTION_RTL);
}","/** 
 * @hide
 */
public boolean isLayoutRtl(){
  return (mLayoutDirection == View.LAYOUT_DIRECTION_RTL);
}"
2569,"/** 
 * Returns the end margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return the end margin in pixels.
 */
public int getMarginEnd(){
  if (endMargin != DEFAULT_RELATIVE)   return endMargin;
switch (layoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return leftMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return rightMargin;
}
}","/** 
 * Returns the end margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return the end margin in pixels.
 */
public int getMarginEnd(){
  if (endMargin != DEFAULT_MARGIN_RELATIVE)   return endMargin;
  if (mNeedResolution) {
    doResolveMargins();
  }
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return leftMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return rightMargin;
}
}"
2570,"/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
}","/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}"
2571,"/** 
 * Retuns the layout direction. Can be either   {@link View#LAYOUT_DIRECTION_LTR} or{@link View#LAYOUT_DIRECTION_RTL}.
 * @return the layout direction.
 */
public int getLayoutDirection(){
  return layoutDirection;
}","/** 
 * Retuns the layout direction. Can be either   {@link View#LAYOUT_DIRECTION_LTR} or{@link View#LAYOUT_DIRECTION_RTL}.
 * @return the layout direction.
 */
public int getLayoutDirection(){
  return mLayoutDirection;
}"
2572,"/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative())   return;
switch (layoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    leftMargin=(endMargin > DEFAULT_RELATIVE) ? endMargin : initialLeftMargin;
  rightMargin=(startMargin > DEFAULT_RELATIVE) ? startMargin : initialRightMargin;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_RELATIVE) ? startMargin : initialLeftMargin;
rightMargin=(endMargin > DEFAULT_RELATIVE) ? endMargin : initialRightMargin;
break;
}
}","/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution || mIsRtlCompatibilityMode)   return;
  doResolveMargins();
}"
2573,"/** 
 * Check if margins are relative.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return true if either marginStart or marginEnd has been set.
 */
public boolean isMarginRelative(){
  return (startMargin != DEFAULT_RELATIVE) || (endMargin != DEFAULT_RELATIVE);
}","/** 
 * Check if margins are relative.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return true if either marginStart or marginEnd has been set.
 */
public boolean isMarginRelative(){
  return (startMargin != DEFAULT_MARGIN_RELATIVE || endMargin != DEFAULT_MARGIN_RELATIVE);
}"
2574,"/** 
 * Sets the relative end margin.
 * @param end the end margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 */
public void setMarginEnd(int end){
  endMargin=end;
}","/** 
 * Sets the relative end margin.
 * @param end the end margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 */
public void setMarginEnd(int end){
  endMargin=end;
  mNeedResolution=true;
}"
2575,"/** 
 * Sets the relative margins, in pixels. A call to   {@link android.view.View#requestLayout()}needs to be done so that the new relative margins are taken into account. Left and right margins may be overriden by   {@link android.view.View#requestLayout()} depending on layoutdirection.
 * @param start the start margin size
 * @param top the top margin size
 * @param end the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 * @hide
 */
public void setMarginsRelative(int start,int top,int end,int bottom){
  startMargin=start;
  topMargin=top;
  endMargin=end;
  bottomMargin=bottom;
  initialLeftMargin=0;
  initialRightMargin=0;
}","/** 
 * Sets the relative margins, in pixels. A call to   {@link android.view.View#requestLayout()}needs to be done so that the new relative margins are taken into account. Left and right margins may be overriden by   {@link android.view.View#requestLayout()} depending on layoutdirection.
 * @param start the start margin size
 * @param top the top margin size
 * @param end the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 * @hide
 */
public void setMarginsRelative(int start,int top,int end,int bottom){
  startMargin=start;
  topMargin=top;
  endMargin=end;
  bottomMargin=bottom;
  mNeedResolution=true;
}"
2576,"/** 
 * Sets the relative start margin.
 * @param start the start margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 */
public void setMarginStart(int start){
  startMargin=start;
}","/** 
 * Sets the relative start margin.
 * @param start the start margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 */
public void setMarginStart(int start){
  startMargin=start;
  mNeedResolution=true;
}"
2577,"@Override public void resolveLayoutDirection(int layoutDirection){
  final boolean isLayoutRtl=isLayoutRtl();
  if (isLayoutRtl) {
    if (mStart != DEFAULT_RELATIVE)     mRight=mStart;
    if (mEnd != DEFAULT_RELATIVE)     mLeft=mEnd;
  }
 else {
    if (mStart != DEFAULT_RELATIVE)     mLeft=mStart;
    if (mEnd != DEFAULT_RELATIVE)     mRight=mEnd;
  }
  if (hasRelativeRules() && layoutDirection != getLayoutDirection()) {
    resolveRules(layoutDirection);
  }
  super.resolveLayoutDirection(layoutDirection);
}","@Override public void resolveLayoutDirection(int layoutDirection){
  final boolean isLayoutRtl=isLayoutRtl();
  if (isLayoutRtl) {
    if (mStart != DEFAULT_MARGIN_RELATIVE)     mRight=mStart;
    if (mEnd != DEFAULT_MARGIN_RELATIVE)     mLeft=mEnd;
  }
 else {
    if (mStart != DEFAULT_MARGIN_RELATIVE)     mLeft=mStart;
    if (mEnd != DEFAULT_MARGIN_RELATIVE)     mRight=mEnd;
  }
  if (hasRelativeRules() && layoutDirection != getLayoutDirection()) {
    resolveRules(layoutDirection);
  }
  super.resolveLayoutDirection(layoutDirection);
}"
2578,"/** 
 * Set the layout direction
 * @param layoutDirection the layout direction.Should be either  {@link View#LAYOUT_DIRECTION_LTR}or   {@link View#LAYOUT_DIRECTION_RTL}.
 */
public void setLayoutDirection(int layoutDirection){
  if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)   return;
  this.layoutDirection=layoutDirection;
}","/** 
 * Set the layout direction
 * @param layoutDirection the layout direction.Should be either  {@link View#LAYOUT_DIRECTION_LTR}or   {@link View#LAYOUT_DIRECTION_RTL}.
 */
public void setLayoutDirection(int layoutDirection){
  if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)   return;
  if (layoutDirection != this.mLayoutDirection) {
    this.mLayoutDirection=layoutDirection;
    this.mNeedResolution=isMarginRelative();
  }
}"
2579,"/** 
 * Returns the start margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @return the start margin in pixels.
 */
public int getMarginStart(){
  if (startMargin != DEFAULT_RELATIVE)   return startMargin;
switch (layoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return rightMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return leftMargin;
}
}","/** 
 * Returns the start margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @return the start margin in pixels.
 */
public int getMarginStart(){
  if (startMargin != DEFAULT_MARGIN_RELATIVE)   return startMargin;
  if (mNeedResolution) {
    doResolveMargins();
  }
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return rightMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return leftMargin;
}
}"
2580,"/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  initialLeftMargin=left;
  initialRightMargin=right;
}","/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mNeedResolution=isMarginRelative();
}"
2581,"/** 
 * @hide
 */
public boolean isLayoutRtl(){
  return (layoutDirection == View.LAYOUT_DIRECTION_RTL);
}","/** 
 * @hide
 */
public boolean isLayoutRtl(){
  return (mLayoutDirection == View.LAYOUT_DIRECTION_RTL);
}"
2582,"/** 
 * Returns the end margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return the end margin in pixels.
 */
public int getMarginEnd(){
  if (endMargin != DEFAULT_RELATIVE)   return endMargin;
switch (layoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return leftMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return rightMargin;
}
}","/** 
 * Returns the end margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return the end margin in pixels.
 */
public int getMarginEnd(){
  if (endMargin != DEFAULT_MARGIN_RELATIVE)   return endMargin;
  if (mNeedResolution) {
    doResolveMargins();
  }
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return leftMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return rightMargin;
}
}"
2583,"/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
}","/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}"
2584,"/** 
 * Retuns the layout direction. Can be either   {@link View#LAYOUT_DIRECTION_LTR} or{@link View#LAYOUT_DIRECTION_RTL}.
 * @return the layout direction.
 */
public int getLayoutDirection(){
  return layoutDirection;
}","/** 
 * Retuns the layout direction. Can be either   {@link View#LAYOUT_DIRECTION_LTR} or{@link View#LAYOUT_DIRECTION_RTL}.
 * @return the layout direction.
 */
public int getLayoutDirection(){
  return mLayoutDirection;
}"
2585,"/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative())   return;
switch (layoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    leftMargin=(endMargin > DEFAULT_RELATIVE) ? endMargin : initialLeftMargin;
  rightMargin=(startMargin > DEFAULT_RELATIVE) ? startMargin : initialRightMargin;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_RELATIVE) ? startMargin : initialLeftMargin;
rightMargin=(endMargin > DEFAULT_RELATIVE) ? endMargin : initialRightMargin;
break;
}
}","/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution || mIsRtlCompatibilityMode)   return;
  doResolveMargins();
}"
2586,"/** 
 * Check if margins are relative.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return true if either marginStart or marginEnd has been set.
 */
public boolean isMarginRelative(){
  return (startMargin != DEFAULT_RELATIVE) || (endMargin != DEFAULT_RELATIVE);
}","/** 
 * Check if margins are relative.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return true if either marginStart or marginEnd has been set.
 */
public boolean isMarginRelative(){
  return (startMargin != DEFAULT_MARGIN_RELATIVE || endMargin != DEFAULT_MARGIN_RELATIVE);
}"
2587,"/** 
 * Sets the relative end margin.
 * @param end the end margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 */
public void setMarginEnd(int end){
  endMargin=end;
}","/** 
 * Sets the relative end margin.
 * @param end the end margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 */
public void setMarginEnd(int end){
  endMargin=end;
  mNeedResolution=true;
}"
2588,"/** 
 * Sets the relative margins, in pixels. A call to   {@link android.view.View#requestLayout()}needs to be done so that the new relative margins are taken into account. Left and right margins may be overriden by   {@link android.view.View#requestLayout()} depending on layoutdirection.
 * @param start the start margin size
 * @param top the top margin size
 * @param end the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 * @hide
 */
public void setMarginsRelative(int start,int top,int end,int bottom){
  startMargin=start;
  topMargin=top;
  endMargin=end;
  bottomMargin=bottom;
  initialLeftMargin=0;
  initialRightMargin=0;
}","/** 
 * Sets the relative margins, in pixels. A call to   {@link android.view.View#requestLayout()}needs to be done so that the new relative margins are taken into account. Left and right margins may be overriden by   {@link android.view.View#requestLayout()} depending on layoutdirection.
 * @param start the start margin size
 * @param top the top margin size
 * @param end the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 * @hide
 */
public void setMarginsRelative(int start,int top,int end,int bottom){
  startMargin=start;
  topMargin=top;
  endMargin=end;
  bottomMargin=bottom;
  mNeedResolution=true;
}"
2589,"/** 
 * Sets the relative start margin.
 * @param start the start margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 */
public void setMarginStart(int start){
  startMargin=start;
}","/** 
 * Sets the relative start margin.
 * @param start the start margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 */
public void setMarginStart(int start){
  startMargin=start;
  mNeedResolution=true;
}"
2590,"@Override public void resolveLayoutDirection(int layoutDirection){
  final boolean isLayoutRtl=isLayoutRtl();
  if (isLayoutRtl) {
    if (mStart != DEFAULT_RELATIVE)     mRight=mStart;
    if (mEnd != DEFAULT_RELATIVE)     mLeft=mEnd;
  }
 else {
    if (mStart != DEFAULT_RELATIVE)     mLeft=mStart;
    if (mEnd != DEFAULT_RELATIVE)     mRight=mEnd;
  }
  if (hasRelativeRules() && layoutDirection != getLayoutDirection()) {
    resolveRules(layoutDirection);
  }
  super.resolveLayoutDirection(layoutDirection);
}","@Override public void resolveLayoutDirection(int layoutDirection){
  final boolean isLayoutRtl=isLayoutRtl();
  if (isLayoutRtl) {
    if (mStart != DEFAULT_MARGIN_RELATIVE)     mRight=mStart;
    if (mEnd != DEFAULT_MARGIN_RELATIVE)     mLeft=mEnd;
  }
 else {
    if (mStart != DEFAULT_MARGIN_RELATIVE)     mLeft=mStart;
    if (mEnd != DEFAULT_MARGIN_RELATIVE)     mRight=mEnd;
  }
  if (hasRelativeRules() && layoutDirection != getLayoutDirection()) {
    resolveRules(layoutDirection);
  }
  super.resolveLayoutDirection(layoutDirection);
}"
2591,"/** 
 * Set the layout direction
 * @param layoutDirection the layout direction.Should be either  {@link View#LAYOUT_DIRECTION_LTR}or   {@link View#LAYOUT_DIRECTION_RTL}.
 */
public void setLayoutDirection(int layoutDirection){
  if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)   return;
  this.layoutDirection=layoutDirection;
}","/** 
 * Set the layout direction
 * @param layoutDirection the layout direction.Should be either  {@link View#LAYOUT_DIRECTION_LTR}or   {@link View#LAYOUT_DIRECTION_RTL}.
 */
public void setLayoutDirection(int layoutDirection){
  if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)   return;
  if (layoutDirection != this.mLayoutDirection) {
    this.mLayoutDirection=layoutDirection;
    this.mNeedResolution=isMarginRelative();
  }
}"
2592,"/** 
 * Returns the start margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @return the start margin in pixels.
 */
public int getMarginStart(){
  if (startMargin != DEFAULT_RELATIVE)   return startMargin;
switch (layoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return rightMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return leftMargin;
}
}","/** 
 * Returns the start margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @return the start margin in pixels.
 */
public int getMarginStart(){
  if (startMargin != DEFAULT_MARGIN_RELATIVE)   return startMargin;
  if (mNeedResolution) {
    doResolveMargins();
  }
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return rightMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return leftMargin;
}
}"
2593,"/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  initialLeftMargin=left;
  initialRightMargin=right;
}","/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mNeedResolution=isMarginRelative();
}"
2594,"/** 
 * @hide
 */
public boolean isLayoutRtl(){
  return (layoutDirection == View.LAYOUT_DIRECTION_RTL);
}","/** 
 * @hide
 */
public boolean isLayoutRtl(){
  return (mLayoutDirection == View.LAYOUT_DIRECTION_RTL);
}"
2595,"/** 
 * Returns the end margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return the end margin in pixels.
 */
public int getMarginEnd(){
  if (endMargin != DEFAULT_RELATIVE)   return endMargin;
switch (layoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return leftMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return rightMargin;
}
}","/** 
 * Returns the end margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return the end margin in pixels.
 */
public int getMarginEnd(){
  if (endMargin != DEFAULT_MARGIN_RELATIVE)   return endMargin;
  if (mNeedResolution) {
    doResolveMargins();
  }
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return leftMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return rightMargin;
}
}"
2596,"/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
}","/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}"
2597,"/** 
 * Retuns the layout direction. Can be either   {@link View#LAYOUT_DIRECTION_LTR} or{@link View#LAYOUT_DIRECTION_RTL}.
 * @return the layout direction.
 */
public int getLayoutDirection(){
  return layoutDirection;
}","/** 
 * Retuns the layout direction. Can be either   {@link View#LAYOUT_DIRECTION_LTR} or{@link View#LAYOUT_DIRECTION_RTL}.
 * @return the layout direction.
 */
public int getLayoutDirection(){
  return mLayoutDirection;
}"
2598,"/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative())   return;
switch (layoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    leftMargin=(endMargin > DEFAULT_RELATIVE) ? endMargin : initialLeftMargin;
  rightMargin=(startMargin > DEFAULT_RELATIVE) ? startMargin : initialRightMargin;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_RELATIVE) ? startMargin : initialLeftMargin;
rightMargin=(endMargin > DEFAULT_RELATIVE) ? endMargin : initialRightMargin;
break;
}
}","/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution || mIsRtlCompatibilityMode)   return;
  doResolveMargins();
}"
2599,"/** 
 * Check if margins are relative.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return true if either marginStart or marginEnd has been set.
 */
public boolean isMarginRelative(){
  return (startMargin != DEFAULT_RELATIVE) || (endMargin != DEFAULT_RELATIVE);
}","/** 
 * Check if margins are relative.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return true if either marginStart or marginEnd has been set.
 */
public boolean isMarginRelative(){
  return (startMargin != DEFAULT_MARGIN_RELATIVE || endMargin != DEFAULT_MARGIN_RELATIVE);
}"
2600,"/** 
 * Sets the relative end margin.
 * @param end the end margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 */
public void setMarginEnd(int end){
  endMargin=end;
}","/** 
 * Sets the relative end margin.
 * @param end the end margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 */
public void setMarginEnd(int end){
  endMargin=end;
  mNeedResolution=true;
}"
2601,"/** 
 * Sets the relative margins, in pixels. A call to   {@link android.view.View#requestLayout()}needs to be done so that the new relative margins are taken into account. Left and right margins may be overriden by   {@link android.view.View#requestLayout()} depending on layoutdirection.
 * @param start the start margin size
 * @param top the top margin size
 * @param end the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 * @hide
 */
public void setMarginsRelative(int start,int top,int end,int bottom){
  startMargin=start;
  topMargin=top;
  endMargin=end;
  bottomMargin=bottom;
  initialLeftMargin=0;
  initialRightMargin=0;
}","/** 
 * Sets the relative margins, in pixels. A call to   {@link android.view.View#requestLayout()}needs to be done so that the new relative margins are taken into account. Left and right margins may be overriden by   {@link android.view.View#requestLayout()} depending on layoutdirection.
 * @param start the start margin size
 * @param top the top margin size
 * @param end the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 * @hide
 */
public void setMarginsRelative(int start,int top,int end,int bottom){
  startMargin=start;
  topMargin=top;
  endMargin=end;
  bottomMargin=bottom;
  mNeedResolution=true;
}"
2602,"/** 
 * Sets the relative start margin.
 * @param start the start margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 */
public void setMarginStart(int start){
  startMargin=start;
}","/** 
 * Sets the relative start margin.
 * @param start the start margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 */
public void setMarginStart(int start){
  startMargin=start;
  mNeedResolution=true;
}"
2603,"@Override public void resolveLayoutDirection(int layoutDirection){
  final boolean isLayoutRtl=isLayoutRtl();
  if (isLayoutRtl) {
    if (mStart != DEFAULT_RELATIVE)     mRight=mStart;
    if (mEnd != DEFAULT_RELATIVE)     mLeft=mEnd;
  }
 else {
    if (mStart != DEFAULT_RELATIVE)     mLeft=mStart;
    if (mEnd != DEFAULT_RELATIVE)     mRight=mEnd;
  }
  if (hasRelativeRules() && layoutDirection != getLayoutDirection()) {
    resolveRules(layoutDirection);
  }
  super.resolveLayoutDirection(layoutDirection);
}","@Override public void resolveLayoutDirection(int layoutDirection){
  final boolean isLayoutRtl=isLayoutRtl();
  if (isLayoutRtl) {
    if (mStart != DEFAULT_MARGIN_RELATIVE)     mRight=mStart;
    if (mEnd != DEFAULT_MARGIN_RELATIVE)     mLeft=mEnd;
  }
 else {
    if (mStart != DEFAULT_MARGIN_RELATIVE)     mLeft=mStart;
    if (mEnd != DEFAULT_MARGIN_RELATIVE)     mRight=mEnd;
  }
  if (hasRelativeRules() && layoutDirection != getLayoutDirection()) {
    resolveRules(layoutDirection);
  }
  super.resolveLayoutDirection(layoutDirection);
}"
2604,"/** 
 * Set the layout direction
 * @param layoutDirection the layout direction.Should be either  {@link View#LAYOUT_DIRECTION_LTR}or   {@link View#LAYOUT_DIRECTION_RTL}.
 */
public void setLayoutDirection(int layoutDirection){
  if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)   return;
  this.layoutDirection=layoutDirection;
}","/** 
 * Set the layout direction
 * @param layoutDirection the layout direction.Should be either  {@link View#LAYOUT_DIRECTION_LTR}or   {@link View#LAYOUT_DIRECTION_RTL}.
 */
public void setLayoutDirection(int layoutDirection){
  if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)   return;
  if (layoutDirection != this.mLayoutDirection) {
    this.mLayoutDirection=layoutDirection;
    this.mNeedResolution=isMarginRelative();
  }
}"
2605,"/** 
 * Returns the start margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @return the start margin in pixels.
 */
public int getMarginStart(){
  if (startMargin != DEFAULT_RELATIVE)   return startMargin;
switch (layoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return rightMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return leftMargin;
}
}","/** 
 * Returns the start margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @return the start margin in pixels.
 */
public int getMarginStart(){
  if (startMargin != DEFAULT_MARGIN_RELATIVE)   return startMargin;
  if (mNeedResolution) {
    doResolveMargins();
  }
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return rightMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return leftMargin;
}
}"
2606,"/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  initialLeftMargin=left;
  initialRightMargin=right;
}","/** 
 * Sets the margins, in pixels. A call to   {@link android.view.View#requestLayout()} needsto be done so that the new margins are taken into account. Left and right margins may be overriden by  {@link android.view.View#requestLayout()} depending on layout direction.
 * @param left the left margin size
 * @param top the top margin size
 * @param right the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginLeft
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginRight
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 */
public void setMargins(int left,int top,int right,int bottom){
  leftMargin=left;
  topMargin=top;
  rightMargin=right;
  bottomMargin=bottom;
  mNeedResolution=isMarginRelative();
}"
2607,"/** 
 * @hide
 */
public boolean isLayoutRtl(){
  return (layoutDirection == View.LAYOUT_DIRECTION_RTL);
}","/** 
 * @hide
 */
public boolean isLayoutRtl(){
  return (mLayoutDirection == View.LAYOUT_DIRECTION_RTL);
}"
2608,"/** 
 * Returns the end margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return the end margin in pixels.
 */
public int getMarginEnd(){
  if (endMargin != DEFAULT_RELATIVE)   return endMargin;
switch (layoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return leftMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return rightMargin;
}
}","/** 
 * Returns the end margin in pixels.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return the end margin in pixels.
 */
public int getMarginEnd(){
  if (endMargin != DEFAULT_MARGIN_RELATIVE)   return endMargin;
  if (mNeedResolution) {
    doResolveMargins();
  }
switch (mLayoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    return leftMargin;
case View.LAYOUT_DIRECTION_LTR:
default :
  return rightMargin;
}
}"
2609,"/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
}","/** 
 * {@inheritDoc}
 */
public MarginLayoutParams(LayoutParams source){
  super(source);
  mNeedResolution=false;
  mIsRtlCompatibilityMode=false;
}"
2610,"/** 
 * Retuns the layout direction. Can be either   {@link View#LAYOUT_DIRECTION_LTR} or{@link View#LAYOUT_DIRECTION_RTL}.
 * @return the layout direction.
 */
public int getLayoutDirection(){
  return layoutDirection;
}","/** 
 * Retuns the layout direction. Can be either   {@link View#LAYOUT_DIRECTION_LTR} or{@link View#LAYOUT_DIRECTION_RTL}.
 * @return the layout direction.
 */
public int getLayoutDirection(){
  return mLayoutDirection;
}"
2611,"/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative())   return;
switch (layoutDirection) {
case View.LAYOUT_DIRECTION_RTL:
    leftMargin=(endMargin > DEFAULT_RELATIVE) ? endMargin : initialLeftMargin;
  rightMargin=(startMargin > DEFAULT_RELATIVE) ? startMargin : initialRightMargin;
break;
case View.LAYOUT_DIRECTION_LTR:
default :
leftMargin=(startMargin > DEFAULT_RELATIVE) ? startMargin : initialLeftMargin;
rightMargin=(endMargin > DEFAULT_RELATIVE) ? endMargin : initialRightMargin;
break;
}
}","/** 
 * This will be called by   {@link android.view.View#requestLayout()}. Left and Right margins may be overridden depending on layout direction.
 */
@Override public void resolveLayoutDirection(int layoutDirection){
  setLayoutDirection(layoutDirection);
  if (!isMarginRelative() || !mNeedResolution || mIsRtlCompatibilityMode)   return;
  doResolveMargins();
}"
2612,"/** 
 * Check if margins are relative.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return true if either marginStart or marginEnd has been set.
 */
public boolean isMarginRelative(){
  return (startMargin != DEFAULT_RELATIVE) || (endMargin != DEFAULT_RELATIVE);
}","/** 
 * Check if margins are relative.
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @return true if either marginStart or marginEnd has been set.
 */
public boolean isMarginRelative(){
  return (startMargin != DEFAULT_MARGIN_RELATIVE || endMargin != DEFAULT_MARGIN_RELATIVE);
}"
2613,"/** 
 * Sets the relative end margin.
 * @param end the end margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 */
public void setMarginEnd(int end){
  endMargin=end;
}","/** 
 * Sets the relative end margin.
 * @param end the end margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 */
public void setMarginEnd(int end){
  endMargin=end;
  mNeedResolution=true;
}"
2614,"/** 
 * Sets the relative margins, in pixels. A call to   {@link android.view.View#requestLayout()}needs to be done so that the new relative margins are taken into account. Left and right margins may be overriden by   {@link android.view.View#requestLayout()} depending on layoutdirection.
 * @param start the start margin size
 * @param top the top margin size
 * @param end the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 * @hide
 */
public void setMarginsRelative(int start,int top,int end,int bottom){
  startMargin=start;
  topMargin=top;
  endMargin=end;
  bottomMargin=bottom;
  initialLeftMargin=0;
  initialRightMargin=0;
}","/** 
 * Sets the relative margins, in pixels. A call to   {@link android.view.View#requestLayout()}needs to be done so that the new relative margins are taken into account. Left and right margins may be overriden by   {@link android.view.View#requestLayout()} depending on layoutdirection.
 * @param start the start margin size
 * @param top the top margin size
 * @param end the right margin size
 * @param bottom the bottom margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginTop
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginBottom
 * @hide
 */
public void setMarginsRelative(int start,int top,int end,int bottom){
  startMargin=start;
  topMargin=top;
  endMargin=end;
  bottomMargin=bottom;
  mNeedResolution=true;
}"
2615,"/** 
 * Sets the relative start margin.
 * @param start the start margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 */
public void setMarginStart(int start){
  startMargin=start;
}","/** 
 * Sets the relative start margin.
 * @param start the start margin size
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 */
public void setMarginStart(int start){
  startMargin=start;
  mNeedResolution=true;
}"
2616,"@Override public void resolveLayoutDirection(int layoutDirection){
  final boolean isLayoutRtl=isLayoutRtl();
  if (isLayoutRtl) {
    if (mStart != DEFAULT_RELATIVE)     mRight=mStart;
    if (mEnd != DEFAULT_RELATIVE)     mLeft=mEnd;
  }
 else {
    if (mStart != DEFAULT_RELATIVE)     mLeft=mStart;
    if (mEnd != DEFAULT_RELATIVE)     mRight=mEnd;
  }
  if (hasRelativeRules() && layoutDirection != getLayoutDirection()) {
    resolveRules(layoutDirection);
  }
  super.resolveLayoutDirection(layoutDirection);
}","@Override public void resolveLayoutDirection(int layoutDirection){
  final boolean isLayoutRtl=isLayoutRtl();
  if (isLayoutRtl) {
    if (mStart != DEFAULT_MARGIN_RELATIVE)     mRight=mStart;
    if (mEnd != DEFAULT_MARGIN_RELATIVE)     mLeft=mEnd;
  }
 else {
    if (mStart != DEFAULT_MARGIN_RELATIVE)     mLeft=mStart;
    if (mEnd != DEFAULT_MARGIN_RELATIVE)     mRight=mEnd;
  }
  if (hasRelativeRules() && layoutDirection != getLayoutDirection()) {
    resolveRules(layoutDirection);
  }
  super.resolveLayoutDirection(layoutDirection);
}"
2617,"private void initTitle(){
  if (mTitleLayout == null) {
    LayoutInflater inflater=LayoutInflater.from(getContext());
    mTitleLayout=(LinearLayout)inflater.inflate(R.layout.action_bar_title_item,this,false);
    mTitleView=(TextView)mTitleLayout.findViewById(R.id.action_bar_title);
    mSubtitleView=(TextView)mTitleLayout.findViewById(R.id.action_bar_subtitle);
    mTitleUpView=(View)mTitleLayout.findViewById(R.id.up);
    if (mTitleStyleRes != 0) {
      mTitleView.setTextAppearance(mContext,mTitleStyleRes);
    }
    if (mTitle != null) {
      mTitleView.setText(mTitle);
    }
    if (mSubtitleStyleRes != 0) {
      mSubtitleView.setTextAppearance(mContext,mSubtitleStyleRes);
    }
    if (mSubtitle != null) {
      mSubtitleView.setText(mSubtitle);
      mSubtitleView.setVisibility(VISIBLE);
    }
    final boolean homeAsUp=(mDisplayOptions & ActionBar.DISPLAY_HOME_AS_UP) != 0;
    final boolean showHome=(mDisplayOptions & ActionBar.DISPLAY_SHOW_HOME) != 0;
    final boolean showTitleUp=!showHome;
    mTitleUpView.setVisibility(showTitleUp ? (homeAsUp ? VISIBLE : INVISIBLE) : GONE);
  }
  mUpGoerFive.addView(mTitleLayout);
  if (mExpandedActionView != null || (TextUtils.isEmpty(mTitle) && TextUtils.isEmpty(mSubtitle))) {
    mTitleLayout.setVisibility(GONE);
  }
}","private void initTitle(){
  if (mTitleLayout == null) {
    LayoutInflater inflater=LayoutInflater.from(getContext());
    mTitleLayout=(LinearLayout)inflater.inflate(R.layout.action_bar_title_item,this,false);
    mTitleView=(TextView)mTitleLayout.findViewById(R.id.action_bar_title);
    mSubtitleView=(TextView)mTitleLayout.findViewById(R.id.action_bar_subtitle);
    mTitleUpView=(View)mTitleLayout.findViewById(R.id.up);
    if (mTitleStyleRes != 0) {
      mTitleView.setTextAppearance(mContext,mTitleStyleRes);
    }
    if (mTitle != null) {
      mTitleView.setText(mTitle);
    }
    if (mSubtitleStyleRes != 0) {
      mSubtitleView.setTextAppearance(mContext,mSubtitleStyleRes);
    }
    if (mSubtitle != null) {
      mSubtitleView.setText(mSubtitle);
      mSubtitleView.setVisibility(VISIBLE);
    }
    final boolean homeAsUp=(mDisplayOptions & ActionBar.DISPLAY_HOME_AS_UP) != 0;
    final boolean showHome=(mDisplayOptions & ActionBar.DISPLAY_SHOW_HOME) != 0;
    final boolean showTitleUp=!showHome;
    mTitleUpView.setVisibility(showTitleUp ? (homeAsUp ? VISIBLE : INVISIBLE) : GONE);
  }
  mUpGoerFive.addView(mTitleLayout);
  if (mExpandedActionView != null || (TextUtils.isEmpty(mTitle) && TextUtils.isEmpty(mSubtitle))) {
    mTitleLayout.setVisibility(GONE);
  }
 else {
    mTitleLayout.setVisibility(VISIBLE);
  }
}"
2618,"@Override public boolean collapseItemActionView(MenuBuilder menu,MenuItemImpl item){
  if (mExpandedActionView instanceof CollapsibleActionView) {
    ((CollapsibleActionView)mExpandedActionView).onActionViewCollapsed();
  }
  removeView(mExpandedActionView);
  mUpGoerFive.removeView(mExpandedHomeLayout);
  mExpandedActionView=null;
  if ((mDisplayOptions & ActionBar.DISPLAY_SHOW_HOME) != 0) {
    mHomeLayout.setVisibility(VISIBLE);
  }
  if ((mDisplayOptions & ActionBar.DISPLAY_SHOW_TITLE) != 0) {
    if (mTitleLayout == null) {
      initTitle();
    }
 else {
      mTitleLayout.setVisibility(VISIBLE);
    }
  }
  if (mTabScrollView != null && mNavigationMode == ActionBar.NAVIGATION_MODE_TABS) {
    mTabScrollView.setVisibility(VISIBLE);
  }
  if (mSpinner != null && mNavigationMode == ActionBar.NAVIGATION_MODE_LIST) {
    mSpinner.setVisibility(VISIBLE);
  }
  if (mCustomNavView != null && (mDisplayOptions & ActionBar.DISPLAY_SHOW_CUSTOM) != 0) {
    mCustomNavView.setVisibility(VISIBLE);
  }
  mExpandedHomeLayout.setIcon(null);
  mCurrentExpandedItem=null;
  setHomeButtonEnabled(mWasHomeEnabled);
  requestLayout();
  item.setActionViewExpanded(false);
  return true;
}","@Override public boolean collapseItemActionView(MenuBuilder menu,MenuItemImpl item){
  if (mExpandedActionView instanceof CollapsibleActionView) {
    ((CollapsibleActionView)mExpandedActionView).onActionViewCollapsed();
  }
  removeView(mExpandedActionView);
  mUpGoerFive.removeView(mExpandedHomeLayout);
  mExpandedActionView=null;
  if ((mDisplayOptions & ActionBar.DISPLAY_SHOW_HOME) != 0) {
    mHomeLayout.setVisibility(VISIBLE);
  }
  if ((mDisplayOptions & ActionBar.DISPLAY_SHOW_TITLE) != 0) {
    if (mTitleLayout == null) {
      initTitle();
    }
 else {
      mTitleLayout.setVisibility(VISIBLE);
    }
  }
  if (mTabScrollView != null)   mTabScrollView.setVisibility(VISIBLE);
  if (mSpinner != null)   mSpinner.setVisibility(VISIBLE);
  if (mCustomNavView != null)   mCustomNavView.setVisibility(VISIBLE);
  mExpandedHomeLayout.setIcon(null);
  mCurrentExpandedItem=null;
  setHomeButtonEnabled(mWasHomeEnabled);
  requestLayout();
  item.setActionViewExpanded(false);
  return true;
}"
2619,"private void initTitle(){
  if (mTitleLayout == null) {
    LayoutInflater inflater=LayoutInflater.from(getContext());
    mTitleLayout=(LinearLayout)inflater.inflate(R.layout.action_bar_title_item,this,false);
    mTitleView=(TextView)mTitleLayout.findViewById(R.id.action_bar_title);
    mSubtitleView=(TextView)mTitleLayout.findViewById(R.id.action_bar_subtitle);
    mTitleUpView=(View)mTitleLayout.findViewById(R.id.up);
    if (mTitleStyleRes != 0) {
      mTitleView.setTextAppearance(mContext,mTitleStyleRes);
    }
    if (mTitle != null) {
      mTitleView.setText(mTitle);
    }
    if (mSubtitleStyleRes != 0) {
      mSubtitleView.setTextAppearance(mContext,mSubtitleStyleRes);
    }
    if (mSubtitle != null) {
      mSubtitleView.setText(mSubtitle);
      mSubtitleView.setVisibility(VISIBLE);
    }
    final boolean homeAsUp=(mDisplayOptions & ActionBar.DISPLAY_HOME_AS_UP) != 0;
    final boolean showHome=(mDisplayOptions & ActionBar.DISPLAY_SHOW_HOME) != 0;
    final boolean showTitleUp=!showHome;
    mTitleUpView.setVisibility(showTitleUp ? (homeAsUp ? VISIBLE : INVISIBLE) : GONE);
  }
  mUpGoerFive.addView(mTitleLayout);
  if (mExpandedActionView != null || (TextUtils.isEmpty(mTitle) && TextUtils.isEmpty(mSubtitle))) {
    mTitleLayout.setVisibility(GONE);
  }
}","private void initTitle(){
  if (mTitleLayout == null) {
    LayoutInflater inflater=LayoutInflater.from(getContext());
    mTitleLayout=(LinearLayout)inflater.inflate(R.layout.action_bar_title_item,this,false);
    mTitleView=(TextView)mTitleLayout.findViewById(R.id.action_bar_title);
    mSubtitleView=(TextView)mTitleLayout.findViewById(R.id.action_bar_subtitle);
    mTitleUpView=(View)mTitleLayout.findViewById(R.id.up);
    if (mTitleStyleRes != 0) {
      mTitleView.setTextAppearance(mContext,mTitleStyleRes);
    }
    if (mTitle != null) {
      mTitleView.setText(mTitle);
    }
    if (mSubtitleStyleRes != 0) {
      mSubtitleView.setTextAppearance(mContext,mSubtitleStyleRes);
    }
    if (mSubtitle != null) {
      mSubtitleView.setText(mSubtitle);
      mSubtitleView.setVisibility(VISIBLE);
    }
    final boolean homeAsUp=(mDisplayOptions & ActionBar.DISPLAY_HOME_AS_UP) != 0;
    final boolean showHome=(mDisplayOptions & ActionBar.DISPLAY_SHOW_HOME) != 0;
    final boolean showTitleUp=!showHome;
    mTitleUpView.setVisibility(showTitleUp ? (homeAsUp ? VISIBLE : INVISIBLE) : GONE);
  }
  mUpGoerFive.addView(mTitleLayout);
  if (mExpandedActionView != null || (TextUtils.isEmpty(mTitle) && TextUtils.isEmpty(mSubtitle))) {
    mTitleLayout.setVisibility(GONE);
  }
 else {
    mTitleLayout.setVisibility(VISIBLE);
  }
}"
2620,"@Override public boolean collapseItemActionView(MenuBuilder menu,MenuItemImpl item){
  if (mExpandedActionView instanceof CollapsibleActionView) {
    ((CollapsibleActionView)mExpandedActionView).onActionViewCollapsed();
  }
  removeView(mExpandedActionView);
  mUpGoerFive.removeView(mExpandedHomeLayout);
  mExpandedActionView=null;
  if ((mDisplayOptions & ActionBar.DISPLAY_SHOW_HOME) != 0) {
    mHomeLayout.setVisibility(VISIBLE);
  }
  if ((mDisplayOptions & ActionBar.DISPLAY_SHOW_TITLE) != 0) {
    if (mTitleLayout == null) {
      initTitle();
    }
 else {
      mTitleLayout.setVisibility(VISIBLE);
    }
  }
  if (mTabScrollView != null && mNavigationMode == ActionBar.NAVIGATION_MODE_TABS) {
    mTabScrollView.setVisibility(VISIBLE);
  }
  if (mSpinner != null && mNavigationMode == ActionBar.NAVIGATION_MODE_LIST) {
    mSpinner.setVisibility(VISIBLE);
  }
  if (mCustomNavView != null && (mDisplayOptions & ActionBar.DISPLAY_SHOW_CUSTOM) != 0) {
    mCustomNavView.setVisibility(VISIBLE);
  }
  mExpandedHomeLayout.setIcon(null);
  mCurrentExpandedItem=null;
  setHomeButtonEnabled(mWasHomeEnabled);
  requestLayout();
  item.setActionViewExpanded(false);
  return true;
}","@Override public boolean collapseItemActionView(MenuBuilder menu,MenuItemImpl item){
  if (mExpandedActionView instanceof CollapsibleActionView) {
    ((CollapsibleActionView)mExpandedActionView).onActionViewCollapsed();
  }
  removeView(mExpandedActionView);
  mUpGoerFive.removeView(mExpandedHomeLayout);
  mExpandedActionView=null;
  if ((mDisplayOptions & ActionBar.DISPLAY_SHOW_HOME) != 0) {
    mHomeLayout.setVisibility(VISIBLE);
  }
  if ((mDisplayOptions & ActionBar.DISPLAY_SHOW_TITLE) != 0) {
    if (mTitleLayout == null) {
      initTitle();
    }
 else {
      mTitleLayout.setVisibility(VISIBLE);
    }
  }
  if (mTabScrollView != null)   mTabScrollView.setVisibility(VISIBLE);
  if (mSpinner != null)   mSpinner.setVisibility(VISIBLE);
  if (mCustomNavView != null)   mCustomNavView.setVisibility(VISIBLE);
  mExpandedHomeLayout.setIcon(null);
  mCurrentExpandedItem=null;
  setHomeButtonEnabled(mWasHomeEnabled);
  requestLayout();
  item.setActionViewExpanded(false);
  return true;
}"
2621,"private void initTitle(){
  if (mTitleLayout == null) {
    LayoutInflater inflater=LayoutInflater.from(getContext());
    mTitleLayout=(LinearLayout)inflater.inflate(R.layout.action_bar_title_item,this,false);
    mTitleView=(TextView)mTitleLayout.findViewById(R.id.action_bar_title);
    mSubtitleView=(TextView)mTitleLayout.findViewById(R.id.action_bar_subtitle);
    mTitleUpView=(View)mTitleLayout.findViewById(R.id.up);
    if (mTitleStyleRes != 0) {
      mTitleView.setTextAppearance(mContext,mTitleStyleRes);
    }
    if (mTitle != null) {
      mTitleView.setText(mTitle);
    }
    if (mSubtitleStyleRes != 0) {
      mSubtitleView.setTextAppearance(mContext,mSubtitleStyleRes);
    }
    if (mSubtitle != null) {
      mSubtitleView.setText(mSubtitle);
      mSubtitleView.setVisibility(VISIBLE);
    }
    final boolean homeAsUp=(mDisplayOptions & ActionBar.DISPLAY_HOME_AS_UP) != 0;
    final boolean showHome=(mDisplayOptions & ActionBar.DISPLAY_SHOW_HOME) != 0;
    final boolean showTitleUp=!showHome;
    mTitleUpView.setVisibility(showTitleUp ? (homeAsUp ? VISIBLE : INVISIBLE) : GONE);
  }
  mUpGoerFive.addView(mTitleLayout);
  if (mExpandedActionView != null || (TextUtils.isEmpty(mTitle) && TextUtils.isEmpty(mSubtitle))) {
    mTitleLayout.setVisibility(GONE);
  }
}","private void initTitle(){
  if (mTitleLayout == null) {
    LayoutInflater inflater=LayoutInflater.from(getContext());
    mTitleLayout=(LinearLayout)inflater.inflate(R.layout.action_bar_title_item,this,false);
    mTitleView=(TextView)mTitleLayout.findViewById(R.id.action_bar_title);
    mSubtitleView=(TextView)mTitleLayout.findViewById(R.id.action_bar_subtitle);
    mTitleUpView=(View)mTitleLayout.findViewById(R.id.up);
    if (mTitleStyleRes != 0) {
      mTitleView.setTextAppearance(mContext,mTitleStyleRes);
    }
    if (mTitle != null) {
      mTitleView.setText(mTitle);
    }
    if (mSubtitleStyleRes != 0) {
      mSubtitleView.setTextAppearance(mContext,mSubtitleStyleRes);
    }
    if (mSubtitle != null) {
      mSubtitleView.setText(mSubtitle);
      mSubtitleView.setVisibility(VISIBLE);
    }
    final boolean homeAsUp=(mDisplayOptions & ActionBar.DISPLAY_HOME_AS_UP) != 0;
    final boolean showHome=(mDisplayOptions & ActionBar.DISPLAY_SHOW_HOME) != 0;
    final boolean showTitleUp=!showHome;
    mTitleUpView.setVisibility(showTitleUp ? (homeAsUp ? VISIBLE : INVISIBLE) : GONE);
  }
  mUpGoerFive.addView(mTitleLayout);
  if (mExpandedActionView != null || (TextUtils.isEmpty(mTitle) && TextUtils.isEmpty(mSubtitle))) {
    mTitleLayout.setVisibility(GONE);
  }
 else {
    mTitleLayout.setVisibility(VISIBLE);
  }
}"
2622,"@Override public boolean collapseItemActionView(MenuBuilder menu,MenuItemImpl item){
  if (mExpandedActionView instanceof CollapsibleActionView) {
    ((CollapsibleActionView)mExpandedActionView).onActionViewCollapsed();
  }
  removeView(mExpandedActionView);
  mUpGoerFive.removeView(mExpandedHomeLayout);
  mExpandedActionView=null;
  if ((mDisplayOptions & ActionBar.DISPLAY_SHOW_HOME) != 0) {
    mHomeLayout.setVisibility(VISIBLE);
  }
  if ((mDisplayOptions & ActionBar.DISPLAY_SHOW_TITLE) != 0) {
    if (mTitleLayout == null) {
      initTitle();
    }
 else {
      mTitleLayout.setVisibility(VISIBLE);
    }
  }
  if (mTabScrollView != null && mNavigationMode == ActionBar.NAVIGATION_MODE_TABS) {
    mTabScrollView.setVisibility(VISIBLE);
  }
  if (mSpinner != null && mNavigationMode == ActionBar.NAVIGATION_MODE_LIST) {
    mSpinner.setVisibility(VISIBLE);
  }
  if (mCustomNavView != null && (mDisplayOptions & ActionBar.DISPLAY_SHOW_CUSTOM) != 0) {
    mCustomNavView.setVisibility(VISIBLE);
  }
  mExpandedHomeLayout.setIcon(null);
  mCurrentExpandedItem=null;
  setHomeButtonEnabled(mWasHomeEnabled);
  requestLayout();
  item.setActionViewExpanded(false);
  return true;
}","@Override public boolean collapseItemActionView(MenuBuilder menu,MenuItemImpl item){
  if (mExpandedActionView instanceof CollapsibleActionView) {
    ((CollapsibleActionView)mExpandedActionView).onActionViewCollapsed();
  }
  removeView(mExpandedActionView);
  mUpGoerFive.removeView(mExpandedHomeLayout);
  mExpandedActionView=null;
  if ((mDisplayOptions & ActionBar.DISPLAY_SHOW_HOME) != 0) {
    mHomeLayout.setVisibility(VISIBLE);
  }
  if ((mDisplayOptions & ActionBar.DISPLAY_SHOW_TITLE) != 0) {
    if (mTitleLayout == null) {
      initTitle();
    }
 else {
      mTitleLayout.setVisibility(VISIBLE);
    }
  }
  if (mTabScrollView != null)   mTabScrollView.setVisibility(VISIBLE);
  if (mSpinner != null)   mSpinner.setVisibility(VISIBLE);
  if (mCustomNavView != null)   mCustomNavView.setVisibility(VISIBLE);
  mExpandedHomeLayout.setIcon(null);
  mCurrentExpandedItem=null;
  setHomeButtonEnabled(mWasHomeEnabled);
  requestLayout();
  item.setActionViewExpanded(false);
  return true;
}"
2623,"private int deliverTrackballEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  if (mView == null || !mAdded) {
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchTrackballEvent(event)) {
    ensureTouchMode(false);
    mLastTrackballTime=Integer.MIN_VALUE;
    return EVENT_HANDLED;
  }
  final TrackballAxis x=mTrackballAxisX;
  final TrackballAxis y=mTrackballAxisY;
  long curTime=SystemClock.uptimeMillis();
  if ((mLastTrackballTime + MAX_TRACKBALL_DELAY) < curTime) {
    x.reset(0);
    y.reset(0);
    mLastTrackballTime=curTime;
  }
  final int action=event.getAction();
  final int metaState=event.getMetaState();
switch (action) {
case MotionEvent.ACTION_DOWN:
    x.reset(2);
  y.reset(2);
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_DOWN,KeyEvent.KEYCODE_DPAD_CENTER,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
break;
case MotionEvent.ACTION_UP:
x.reset(2);
y.reset(2);
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_UP,KeyEvent.KEYCODE_DPAD_CENTER,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
break;
}
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + x.position + ""String_Node_Str""+ x.step+ ""String_Node_Str""+ x.dir+ ""String_Node_Str""+ x.acceleration+ ""String_Node_Str""+ event.getX()+ ""String_Node_Str""+ y.position+ ""String_Node_Str""+ y.step+ ""String_Node_Str""+ y.dir+ ""String_Node_Str""+ y.acceleration+ ""String_Node_Str""+ event.getY());
final float xOff=x.collect(event.getX(),event.getEventTime(),""String_Node_Str"");
final float yOff=y.collect(event.getY(),event.getEventTime(),""String_Node_Str"");
int keycode=0;
int movement=0;
float accel=1;
if (xOff > yOff) {
movement=x.generate((2 / event.getXPrecision()));
if (movement != 0) {
keycode=movement > 0 ? KeyEvent.KEYCODE_DPAD_RIGHT : KeyEvent.KEYCODE_DPAD_LEFT;
accel=x.acceleration;
y.reset(2);
}
}
 else if (yOff > 0) {
movement=y.generate((2 / event.getYPrecision()));
if (movement != 0) {
keycode=movement > 0 ? KeyEvent.KEYCODE_DPAD_DOWN : KeyEvent.KEYCODE_DPAD_UP;
accel=y.acceleration;
x.reset(2);
}
}
if (keycode != 0) {
if (movement < 0) movement=-movement;
int accelMovement=(int)(movement * accel);
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + movement + ""String_Node_Str""+ accelMovement+ ""String_Node_Str""+ accel);
if (accelMovement > movement) {
if (DEBUG_TRACKBALL) Log.v(""String_Node_Str"",""String_Node_Str"" + keycode);
movement--;
int repeatCount=accelMovement - movement;
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_MULTIPLE,keycode,repeatCount,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
}
while (movement > 0) {
if (DEBUG_TRACKBALL) Log.v(""String_Node_Str"",""String_Node_Str"" + keycode);
movement--;
curTime=SystemClock.uptimeMillis();
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_DOWN,keycode,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_UP,keycode,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
}
mLastTrackballTime=curTime;
}
return EVENT_HANDLED;
}","private int deliverTrackballEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  if (mView == null || !mAdded) {
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchTrackballEvent(event)) {
    ensureTouchMode(false);
    mLastTrackballTime=Integer.MIN_VALUE;
    return EVENT_HANDLED;
  }
  final TrackballAxis x=mTrackballAxisX;
  final TrackballAxis y=mTrackballAxisY;
  long curTime=SystemClock.uptimeMillis();
  if ((mLastTrackballTime + MAX_TRACKBALL_DELAY) < curTime) {
    x.reset(0);
    y.reset(0);
    mLastTrackballTime=curTime;
  }
  final int action=event.getAction();
  final int metaState=event.getMetaState();
switch (action) {
case MotionEvent.ACTION_DOWN:
    x.reset(2);
  y.reset(2);
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_DOWN,KeyEvent.KEYCODE_DPAD_CENTER,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
break;
case MotionEvent.ACTION_UP:
x.reset(2);
y.reset(2);
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_UP,KeyEvent.KEYCODE_DPAD_CENTER,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
break;
}
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + x.position + ""String_Node_Str""+ x.step+ ""String_Node_Str""+ x.dir+ ""String_Node_Str""+ x.acceleration+ ""String_Node_Str""+ event.getX()+ ""String_Node_Str""+ y.position+ ""String_Node_Str""+ y.step+ ""String_Node_Str""+ y.dir+ ""String_Node_Str""+ y.acceleration+ ""String_Node_Str""+ event.getY());
final float xOff=x.collect(event.getX(),event.getEventTime(),""String_Node_Str"");
final float yOff=y.collect(event.getY(),event.getEventTime(),""String_Node_Str"");
int keycode=0;
int movement=0;
float accel=1;
if (xOff > yOff) {
movement=x.generate((2 / event.getXPrecision()));
if (movement != 0) {
keycode=movement > 0 ? KeyEvent.KEYCODE_DPAD_RIGHT : KeyEvent.KEYCODE_DPAD_LEFT;
accel=x.acceleration;
y.reset(2);
}
}
 else if (yOff > 0) {
movement=y.generate((2 / event.getYPrecision()));
if (movement != 0) {
keycode=movement > 0 ? KeyEvent.KEYCODE_DPAD_DOWN : KeyEvent.KEYCODE_DPAD_UP;
accel=y.acceleration;
x.reset(2);
}
}
if (keycode != 0) {
if (movement < 0) movement=-movement;
int accelMovement=(int)(movement * accel);
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + movement + ""String_Node_Str""+ accelMovement+ ""String_Node_Str""+ accel);
if (accelMovement > movement) {
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + keycode);
movement--;
int repeatCount=accelMovement - movement;
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_MULTIPLE,keycode,repeatCount,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
}
while (movement > 0) {
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + keycode);
movement--;
curTime=SystemClock.uptimeMillis();
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_DOWN,keycode,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_UP,keycode,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
}
mLastTrackballTime=curTime;
}
return EVENT_HANDLED;
}"
2624,"private int deliverTrackballEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  if (mView == null || !mAdded) {
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchTrackballEvent(event)) {
    ensureTouchMode(false);
    mLastTrackballTime=Integer.MIN_VALUE;
    return EVENT_HANDLED;
  }
  final TrackballAxis x=mTrackballAxisX;
  final TrackballAxis y=mTrackballAxisY;
  long curTime=SystemClock.uptimeMillis();
  if ((mLastTrackballTime + MAX_TRACKBALL_DELAY) < curTime) {
    x.reset(0);
    y.reset(0);
    mLastTrackballTime=curTime;
  }
  final int action=event.getAction();
  final int metaState=event.getMetaState();
switch (action) {
case MotionEvent.ACTION_DOWN:
    x.reset(2);
  y.reset(2);
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_DOWN,KeyEvent.KEYCODE_DPAD_CENTER,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
break;
case MotionEvent.ACTION_UP:
x.reset(2);
y.reset(2);
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_UP,KeyEvent.KEYCODE_DPAD_CENTER,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
break;
}
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + x.position + ""String_Node_Str""+ x.step+ ""String_Node_Str""+ x.dir+ ""String_Node_Str""+ x.acceleration+ ""String_Node_Str""+ event.getX()+ ""String_Node_Str""+ y.position+ ""String_Node_Str""+ y.step+ ""String_Node_Str""+ y.dir+ ""String_Node_Str""+ y.acceleration+ ""String_Node_Str""+ event.getY());
final float xOff=x.collect(event.getX(),event.getEventTime(),""String_Node_Str"");
final float yOff=y.collect(event.getY(),event.getEventTime(),""String_Node_Str"");
int keycode=0;
int movement=0;
float accel=1;
if (xOff > yOff) {
movement=x.generate((2 / event.getXPrecision()));
if (movement != 0) {
keycode=movement > 0 ? KeyEvent.KEYCODE_DPAD_RIGHT : KeyEvent.KEYCODE_DPAD_LEFT;
accel=x.acceleration;
y.reset(2);
}
}
 else if (yOff > 0) {
movement=y.generate((2 / event.getYPrecision()));
if (movement != 0) {
keycode=movement > 0 ? KeyEvent.KEYCODE_DPAD_DOWN : KeyEvent.KEYCODE_DPAD_UP;
accel=y.acceleration;
x.reset(2);
}
}
if (keycode != 0) {
if (movement < 0) movement=-movement;
int accelMovement=(int)(movement * accel);
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + movement + ""String_Node_Str""+ accelMovement+ ""String_Node_Str""+ accel);
if (accelMovement > movement) {
if (DEBUG_TRACKBALL) Log.v(""String_Node_Str"",""String_Node_Str"" + keycode);
movement--;
int repeatCount=accelMovement - movement;
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_MULTIPLE,keycode,repeatCount,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
}
while (movement > 0) {
if (DEBUG_TRACKBALL) Log.v(""String_Node_Str"",""String_Node_Str"" + keycode);
movement--;
curTime=SystemClock.uptimeMillis();
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_DOWN,keycode,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_UP,keycode,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
}
mLastTrackballTime=curTime;
}
return EVENT_HANDLED;
}","private int deliverTrackballEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  if (mView == null || !mAdded) {
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchTrackballEvent(event)) {
    ensureTouchMode(false);
    mLastTrackballTime=Integer.MIN_VALUE;
    return EVENT_HANDLED;
  }
  final TrackballAxis x=mTrackballAxisX;
  final TrackballAxis y=mTrackballAxisY;
  long curTime=SystemClock.uptimeMillis();
  if ((mLastTrackballTime + MAX_TRACKBALL_DELAY) < curTime) {
    x.reset(0);
    y.reset(0);
    mLastTrackballTime=curTime;
  }
  final int action=event.getAction();
  final int metaState=event.getMetaState();
switch (action) {
case MotionEvent.ACTION_DOWN:
    x.reset(2);
  y.reset(2);
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_DOWN,KeyEvent.KEYCODE_DPAD_CENTER,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
break;
case MotionEvent.ACTION_UP:
x.reset(2);
y.reset(2);
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_UP,KeyEvent.KEYCODE_DPAD_CENTER,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
break;
}
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + x.position + ""String_Node_Str""+ x.step+ ""String_Node_Str""+ x.dir+ ""String_Node_Str""+ x.acceleration+ ""String_Node_Str""+ event.getX()+ ""String_Node_Str""+ y.position+ ""String_Node_Str""+ y.step+ ""String_Node_Str""+ y.dir+ ""String_Node_Str""+ y.acceleration+ ""String_Node_Str""+ event.getY());
final float xOff=x.collect(event.getX(),event.getEventTime(),""String_Node_Str"");
final float yOff=y.collect(event.getY(),event.getEventTime(),""String_Node_Str"");
int keycode=0;
int movement=0;
float accel=1;
if (xOff > yOff) {
movement=x.generate((2 / event.getXPrecision()));
if (movement != 0) {
keycode=movement > 0 ? KeyEvent.KEYCODE_DPAD_RIGHT : KeyEvent.KEYCODE_DPAD_LEFT;
accel=x.acceleration;
y.reset(2);
}
}
 else if (yOff > 0) {
movement=y.generate((2 / event.getYPrecision()));
if (movement != 0) {
keycode=movement > 0 ? KeyEvent.KEYCODE_DPAD_DOWN : KeyEvent.KEYCODE_DPAD_UP;
accel=y.acceleration;
x.reset(2);
}
}
if (keycode != 0) {
if (movement < 0) movement=-movement;
int accelMovement=(int)(movement * accel);
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + movement + ""String_Node_Str""+ accelMovement+ ""String_Node_Str""+ accel);
if (accelMovement > movement) {
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + keycode);
movement--;
int repeatCount=accelMovement - movement;
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_MULTIPLE,keycode,repeatCount,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
}
while (movement > 0) {
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + keycode);
movement--;
curTime=SystemClock.uptimeMillis();
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_DOWN,keycode,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_UP,keycode,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
}
mLastTrackballTime=curTime;
}
return EVENT_HANDLED;
}"
2625,"private int deliverTrackballEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  if (mView == null || !mAdded) {
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchTrackballEvent(event)) {
    ensureTouchMode(false);
    mLastTrackballTime=Integer.MIN_VALUE;
    return EVENT_HANDLED;
  }
  final TrackballAxis x=mTrackballAxisX;
  final TrackballAxis y=mTrackballAxisY;
  long curTime=SystemClock.uptimeMillis();
  if ((mLastTrackballTime + MAX_TRACKBALL_DELAY) < curTime) {
    x.reset(0);
    y.reset(0);
    mLastTrackballTime=curTime;
  }
  final int action=event.getAction();
  final int metaState=event.getMetaState();
switch (action) {
case MotionEvent.ACTION_DOWN:
    x.reset(2);
  y.reset(2);
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_DOWN,KeyEvent.KEYCODE_DPAD_CENTER,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
break;
case MotionEvent.ACTION_UP:
x.reset(2);
y.reset(2);
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_UP,KeyEvent.KEYCODE_DPAD_CENTER,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
break;
}
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + x.position + ""String_Node_Str""+ x.step+ ""String_Node_Str""+ x.dir+ ""String_Node_Str""+ x.acceleration+ ""String_Node_Str""+ event.getX()+ ""String_Node_Str""+ y.position+ ""String_Node_Str""+ y.step+ ""String_Node_Str""+ y.dir+ ""String_Node_Str""+ y.acceleration+ ""String_Node_Str""+ event.getY());
final float xOff=x.collect(event.getX(),event.getEventTime(),""String_Node_Str"");
final float yOff=y.collect(event.getY(),event.getEventTime(),""String_Node_Str"");
int keycode=0;
int movement=0;
float accel=1;
if (xOff > yOff) {
movement=x.generate((2 / event.getXPrecision()));
if (movement != 0) {
keycode=movement > 0 ? KeyEvent.KEYCODE_DPAD_RIGHT : KeyEvent.KEYCODE_DPAD_LEFT;
accel=x.acceleration;
y.reset(2);
}
}
 else if (yOff > 0) {
movement=y.generate((2 / event.getYPrecision()));
if (movement != 0) {
keycode=movement > 0 ? KeyEvent.KEYCODE_DPAD_DOWN : KeyEvent.KEYCODE_DPAD_UP;
accel=y.acceleration;
x.reset(2);
}
}
if (keycode != 0) {
if (movement < 0) movement=-movement;
int accelMovement=(int)(movement * accel);
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + movement + ""String_Node_Str""+ accelMovement+ ""String_Node_Str""+ accel);
if (accelMovement > movement) {
if (DEBUG_TRACKBALL) Log.v(""String_Node_Str"",""String_Node_Str"" + keycode);
movement--;
int repeatCount=accelMovement - movement;
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_MULTIPLE,keycode,repeatCount,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
}
while (movement > 0) {
if (DEBUG_TRACKBALL) Log.v(""String_Node_Str"",""String_Node_Str"" + keycode);
movement--;
curTime=SystemClock.uptimeMillis();
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_DOWN,keycode,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_UP,keycode,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
}
mLastTrackballTime=curTime;
}
return EVENT_HANDLED;
}","private int deliverTrackballEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  if (mView == null || !mAdded) {
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchTrackballEvent(event)) {
    ensureTouchMode(false);
    mLastTrackballTime=Integer.MIN_VALUE;
    return EVENT_HANDLED;
  }
  final TrackballAxis x=mTrackballAxisX;
  final TrackballAxis y=mTrackballAxisY;
  long curTime=SystemClock.uptimeMillis();
  if ((mLastTrackballTime + MAX_TRACKBALL_DELAY) < curTime) {
    x.reset(0);
    y.reset(0);
    mLastTrackballTime=curTime;
  }
  final int action=event.getAction();
  final int metaState=event.getMetaState();
switch (action) {
case MotionEvent.ACTION_DOWN:
    x.reset(2);
  y.reset(2);
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_DOWN,KeyEvent.KEYCODE_DPAD_CENTER,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
break;
case MotionEvent.ACTION_UP:
x.reset(2);
y.reset(2);
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_UP,KeyEvent.KEYCODE_DPAD_CENTER,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
break;
}
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + x.position + ""String_Node_Str""+ x.step+ ""String_Node_Str""+ x.dir+ ""String_Node_Str""+ x.acceleration+ ""String_Node_Str""+ event.getX()+ ""String_Node_Str""+ y.position+ ""String_Node_Str""+ y.step+ ""String_Node_Str""+ y.dir+ ""String_Node_Str""+ y.acceleration+ ""String_Node_Str""+ event.getY());
final float xOff=x.collect(event.getX(),event.getEventTime(),""String_Node_Str"");
final float yOff=y.collect(event.getY(),event.getEventTime(),""String_Node_Str"");
int keycode=0;
int movement=0;
float accel=1;
if (xOff > yOff) {
movement=x.generate((2 / event.getXPrecision()));
if (movement != 0) {
keycode=movement > 0 ? KeyEvent.KEYCODE_DPAD_RIGHT : KeyEvent.KEYCODE_DPAD_LEFT;
accel=x.acceleration;
y.reset(2);
}
}
 else if (yOff > 0) {
movement=y.generate((2 / event.getYPrecision()));
if (movement != 0) {
keycode=movement > 0 ? KeyEvent.KEYCODE_DPAD_DOWN : KeyEvent.KEYCODE_DPAD_UP;
accel=y.acceleration;
x.reset(2);
}
}
if (keycode != 0) {
if (movement < 0) movement=-movement;
int accelMovement=(int)(movement * accel);
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + movement + ""String_Node_Str""+ accelMovement+ ""String_Node_Str""+ accel);
if (accelMovement > movement) {
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + keycode);
movement--;
int repeatCount=accelMovement - movement;
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_MULTIPLE,keycode,repeatCount,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
}
while (movement > 0) {
if (DEBUG_TRACKBALL) Log.v(TAG,""String_Node_Str"" + keycode);
movement--;
curTime=SystemClock.uptimeMillis();
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_DOWN,keycode,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
enqueueInputEvent(new KeyEvent(curTime,curTime,KeyEvent.ACTION_UP,keycode,0,metaState,KeyCharacterMap.VIRTUAL_KEYBOARD,0,KeyEvent.FLAG_FALLBACK,InputDevice.SOURCE_KEYBOARD));
}
mLastTrackballTime=curTime;
}
return EVENT_HANDLED;
}"
2626,"@Override protected void dispatchDraw(Canvas canvas){
  super.dispatchDraw(canvas);
  if ((mChildIndicator == null) && (mGroupIndicator == null)) {
    return;
  }
  int saveCount=0;
  final boolean clipToPadding=(mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
  if (clipToPadding) {
    saveCount=canvas.save();
    final int scrollX=mScrollX;
    final int scrollY=mScrollY;
    canvas.clipRect(scrollX + mPaddingLeft,scrollY + mPaddingTop,scrollX + mRight - mLeft - mPaddingRight,scrollY + mBottom - mTop - mPaddingBottom);
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int lastChildFlPos=mItemCount - getFooterViewsCount() - headerViewsCount- 1;
  final int myB=mBottom;
  PositionMetadata pos;
  View item;
  Drawable indicator;
  int t, b;
  int lastItemType=~(ExpandableListPosition.CHILD | ExpandableListPosition.GROUP);
  final Rect indicatorRect=mIndicatorRect;
  final int childCount=getChildCount();
  for (int i=0, childFlPos=mFirstPosition - headerViewsCount; i < childCount; i++, childFlPos++) {
    if (childFlPos < 0) {
      continue;
    }
 else     if (childFlPos > lastChildFlPos) {
      break;
    }
    item=getChildAt(i);
    t=item.getTop();
    b=item.getBottom();
    if ((b < 0) || (t > myB))     continue;
    pos=mConnector.getUnflattenedPos(childFlPos);
    if (pos.position.type != lastItemType) {
      if (pos.position.type == ExpandableListPosition.CHILD) {
        indicatorRect.left=(mChildIndicatorLeft == CHILD_INDICATOR_INHERIT) ? mIndicatorLeft : mChildIndicatorLeft;
        indicatorRect.right=(mChildIndicatorRight == CHILD_INDICATOR_INHERIT) ? mIndicatorRight : mChildIndicatorRight;
      }
 else {
        indicatorRect.left=mIndicatorLeft;
        indicatorRect.right=mIndicatorRight;
      }
      indicatorRect.left+=mPaddingLeft;
      indicatorRect.right+=mPaddingLeft;
      lastItemType=pos.position.type;
    }
    if (indicatorRect.left != indicatorRect.right) {
      if (mStackFromBottom) {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
 else {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
      indicator=getIndicator(pos);
      if (indicator != null) {
        indicator.setBounds(indicatorRect);
        indicator.draw(canvas);
      }
    }
    pos.recycle();
  }
  if (clipToPadding) {
    canvas.restoreToCount(saveCount);
  }
}","@Override protected void dispatchDraw(Canvas canvas){
  super.dispatchDraw(canvas);
  if ((mChildIndicator == null) && (mGroupIndicator == null)) {
    return;
  }
  int saveCount=0;
  final boolean clipToPadding=(mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
  if (clipToPadding) {
    saveCount=canvas.save();
    final int scrollX=mScrollX;
    final int scrollY=mScrollY;
    canvas.clipRect(scrollX + mPaddingLeft,scrollY + mPaddingTop,scrollX + mRight - mLeft - mPaddingRight,scrollY + mBottom - mTop - mPaddingBottom);
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int lastChildFlPos=mItemCount - getFooterViewsCount() - headerViewsCount- 1;
  final int myB=mBottom;
  PositionMetadata pos;
  View item;
  Drawable indicator;
  int t, b;
  int lastItemType=~(ExpandableListPosition.CHILD | ExpandableListPosition.GROUP);
  final Rect indicatorRect=mIndicatorRect;
  final int childCount=getChildCount();
  for (int i=0, childFlPos=mFirstPosition - headerViewsCount; i < childCount; i++, childFlPos++) {
    if (childFlPos < 0) {
      continue;
    }
 else     if (childFlPos > lastChildFlPos) {
      break;
    }
    item=getChildAt(i);
    t=item.getTop();
    b=item.getBottom();
    if ((b < 0) || (t > myB))     continue;
    pos=mConnector.getUnflattenedPos(childFlPos);
    final boolean isLayoutRtl=isLayoutRtl();
    final int width=getWidth();
    if (pos.position.type != lastItemType) {
      if (pos.position.type == ExpandableListPosition.CHILD) {
        indicatorRect.left=(mChildIndicatorLeft == CHILD_INDICATOR_INHERIT) ? mIndicatorLeft : mChildIndicatorLeft;
        indicatorRect.right=(mChildIndicatorRight == CHILD_INDICATOR_INHERIT) ? mIndicatorRight : mChildIndicatorRight;
      }
 else {
        indicatorRect.left=mIndicatorLeft;
        indicatorRect.right=mIndicatorRight;
      }
      if (isLayoutRtl) {
        final int temp=indicatorRect.left;
        indicatorRect.left=width - indicatorRect.right;
        indicatorRect.right=width - temp;
        indicatorRect.left-=mPaddingRight;
        indicatorRect.right-=mPaddingRight;
      }
 else {
        indicatorRect.left+=mPaddingLeft;
        indicatorRect.right+=mPaddingLeft;
      }
      lastItemType=pos.position.type;
    }
    if (indicatorRect.left != indicatorRect.right) {
      if (mStackFromBottom) {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
 else {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
      indicator=getIndicator(pos);
      if (indicator != null) {
        indicator.setBounds(indicatorRect);
        indicator.draw(canvas);
      }
    }
    pos.recycle();
  }
  if (clipToPadding) {
    canvas.restoreToCount(saveCount);
  }
}"
2627,"@Override protected void dispatchDraw(Canvas canvas){
  super.dispatchDraw(canvas);
  if ((mChildIndicator == null) && (mGroupIndicator == null)) {
    return;
  }
  int saveCount=0;
  final boolean clipToPadding=(mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
  if (clipToPadding) {
    saveCount=canvas.save();
    final int scrollX=mScrollX;
    final int scrollY=mScrollY;
    canvas.clipRect(scrollX + mPaddingLeft,scrollY + mPaddingTop,scrollX + mRight - mLeft - mPaddingRight,scrollY + mBottom - mTop - mPaddingBottom);
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int lastChildFlPos=mItemCount - getFooterViewsCount() - headerViewsCount- 1;
  final int myB=mBottom;
  PositionMetadata pos;
  View item;
  Drawable indicator;
  int t, b;
  int lastItemType=~(ExpandableListPosition.CHILD | ExpandableListPosition.GROUP);
  final Rect indicatorRect=mIndicatorRect;
  final int childCount=getChildCount();
  for (int i=0, childFlPos=mFirstPosition - headerViewsCount; i < childCount; i++, childFlPos++) {
    if (childFlPos < 0) {
      continue;
    }
 else     if (childFlPos > lastChildFlPos) {
      break;
    }
    item=getChildAt(i);
    t=item.getTop();
    b=item.getBottom();
    if ((b < 0) || (t > myB))     continue;
    pos=mConnector.getUnflattenedPos(childFlPos);
    if (pos.position.type != lastItemType) {
      if (pos.position.type == ExpandableListPosition.CHILD) {
        indicatorRect.left=(mChildIndicatorLeft == CHILD_INDICATOR_INHERIT) ? mIndicatorLeft : mChildIndicatorLeft;
        indicatorRect.right=(mChildIndicatorRight == CHILD_INDICATOR_INHERIT) ? mIndicatorRight : mChildIndicatorRight;
      }
 else {
        indicatorRect.left=mIndicatorLeft;
        indicatorRect.right=mIndicatorRight;
      }
      indicatorRect.left+=mPaddingLeft;
      indicatorRect.right+=mPaddingLeft;
      lastItemType=pos.position.type;
    }
    if (indicatorRect.left != indicatorRect.right) {
      if (mStackFromBottom) {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
 else {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
      indicator=getIndicator(pos);
      if (indicator != null) {
        indicator.setBounds(indicatorRect);
        indicator.draw(canvas);
      }
    }
    pos.recycle();
  }
  if (clipToPadding) {
    canvas.restoreToCount(saveCount);
  }
}","@Override protected void dispatchDraw(Canvas canvas){
  super.dispatchDraw(canvas);
  if ((mChildIndicator == null) && (mGroupIndicator == null)) {
    return;
  }
  int saveCount=0;
  final boolean clipToPadding=(mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
  if (clipToPadding) {
    saveCount=canvas.save();
    final int scrollX=mScrollX;
    final int scrollY=mScrollY;
    canvas.clipRect(scrollX + mPaddingLeft,scrollY + mPaddingTop,scrollX + mRight - mLeft - mPaddingRight,scrollY + mBottom - mTop - mPaddingBottom);
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int lastChildFlPos=mItemCount - getFooterViewsCount() - headerViewsCount- 1;
  final int myB=mBottom;
  PositionMetadata pos;
  View item;
  Drawable indicator;
  int t, b;
  int lastItemType=~(ExpandableListPosition.CHILD | ExpandableListPosition.GROUP);
  final Rect indicatorRect=mIndicatorRect;
  final int childCount=getChildCount();
  for (int i=0, childFlPos=mFirstPosition - headerViewsCount; i < childCount; i++, childFlPos++) {
    if (childFlPos < 0) {
      continue;
    }
 else     if (childFlPos > lastChildFlPos) {
      break;
    }
    item=getChildAt(i);
    t=item.getTop();
    b=item.getBottom();
    if ((b < 0) || (t > myB))     continue;
    pos=mConnector.getUnflattenedPos(childFlPos);
    final boolean isLayoutRtl=isLayoutRtl();
    final int width=getWidth();
    if (pos.position.type != lastItemType) {
      if (pos.position.type == ExpandableListPosition.CHILD) {
        indicatorRect.left=(mChildIndicatorLeft == CHILD_INDICATOR_INHERIT) ? mIndicatorLeft : mChildIndicatorLeft;
        indicatorRect.right=(mChildIndicatorRight == CHILD_INDICATOR_INHERIT) ? mIndicatorRight : mChildIndicatorRight;
      }
 else {
        indicatorRect.left=mIndicatorLeft;
        indicatorRect.right=mIndicatorRight;
      }
      if (isLayoutRtl) {
        final int temp=indicatorRect.left;
        indicatorRect.left=width - indicatorRect.right;
        indicatorRect.right=width - temp;
        indicatorRect.left-=mPaddingRight;
        indicatorRect.right-=mPaddingRight;
      }
 else {
        indicatorRect.left+=mPaddingLeft;
        indicatorRect.right+=mPaddingLeft;
      }
      lastItemType=pos.position.type;
    }
    if (indicatorRect.left != indicatorRect.right) {
      if (mStackFromBottom) {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
 else {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
      indicator=getIndicator(pos);
      if (indicator != null) {
        indicator.setBounds(indicatorRect);
        indicator.draw(canvas);
      }
    }
    pos.recycle();
  }
  if (clipToPadding) {
    canvas.restoreToCount(saveCount);
  }
}"
2628,"@Override protected void dispatchDraw(Canvas canvas){
  super.dispatchDraw(canvas);
  if ((mChildIndicator == null) && (mGroupIndicator == null)) {
    return;
  }
  int saveCount=0;
  final boolean clipToPadding=(mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
  if (clipToPadding) {
    saveCount=canvas.save();
    final int scrollX=mScrollX;
    final int scrollY=mScrollY;
    canvas.clipRect(scrollX + mPaddingLeft,scrollY + mPaddingTop,scrollX + mRight - mLeft - mPaddingRight,scrollY + mBottom - mTop - mPaddingBottom);
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int lastChildFlPos=mItemCount - getFooterViewsCount() - headerViewsCount- 1;
  final int myB=mBottom;
  PositionMetadata pos;
  View item;
  Drawable indicator;
  int t, b;
  int lastItemType=~(ExpandableListPosition.CHILD | ExpandableListPosition.GROUP);
  final Rect indicatorRect=mIndicatorRect;
  final int childCount=getChildCount();
  for (int i=0, childFlPos=mFirstPosition - headerViewsCount; i < childCount; i++, childFlPos++) {
    if (childFlPos < 0) {
      continue;
    }
 else     if (childFlPos > lastChildFlPos) {
      break;
    }
    item=getChildAt(i);
    t=item.getTop();
    b=item.getBottom();
    if ((b < 0) || (t > myB))     continue;
    pos=mConnector.getUnflattenedPos(childFlPos);
    if (pos.position.type != lastItemType) {
      if (pos.position.type == ExpandableListPosition.CHILD) {
        indicatorRect.left=(mChildIndicatorLeft == CHILD_INDICATOR_INHERIT) ? mIndicatorLeft : mChildIndicatorLeft;
        indicatorRect.right=(mChildIndicatorRight == CHILD_INDICATOR_INHERIT) ? mIndicatorRight : mChildIndicatorRight;
      }
 else {
        indicatorRect.left=mIndicatorLeft;
        indicatorRect.right=mIndicatorRight;
      }
      indicatorRect.left+=mPaddingLeft;
      indicatorRect.right+=mPaddingLeft;
      lastItemType=pos.position.type;
    }
    if (indicatorRect.left != indicatorRect.right) {
      if (mStackFromBottom) {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
 else {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
      indicator=getIndicator(pos);
      if (indicator != null) {
        indicator.setBounds(indicatorRect);
        indicator.draw(canvas);
      }
    }
    pos.recycle();
  }
  if (clipToPadding) {
    canvas.restoreToCount(saveCount);
  }
}","@Override protected void dispatchDraw(Canvas canvas){
  super.dispatchDraw(canvas);
  if ((mChildIndicator == null) && (mGroupIndicator == null)) {
    return;
  }
  int saveCount=0;
  final boolean clipToPadding=(mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
  if (clipToPadding) {
    saveCount=canvas.save();
    final int scrollX=mScrollX;
    final int scrollY=mScrollY;
    canvas.clipRect(scrollX + mPaddingLeft,scrollY + mPaddingTop,scrollX + mRight - mLeft - mPaddingRight,scrollY + mBottom - mTop - mPaddingBottom);
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int lastChildFlPos=mItemCount - getFooterViewsCount() - headerViewsCount- 1;
  final int myB=mBottom;
  PositionMetadata pos;
  View item;
  Drawable indicator;
  int t, b;
  int lastItemType=~(ExpandableListPosition.CHILD | ExpandableListPosition.GROUP);
  final Rect indicatorRect=mIndicatorRect;
  final int childCount=getChildCount();
  for (int i=0, childFlPos=mFirstPosition - headerViewsCount; i < childCount; i++, childFlPos++) {
    if (childFlPos < 0) {
      continue;
    }
 else     if (childFlPos > lastChildFlPos) {
      break;
    }
    item=getChildAt(i);
    t=item.getTop();
    b=item.getBottom();
    if ((b < 0) || (t > myB))     continue;
    pos=mConnector.getUnflattenedPos(childFlPos);
    final boolean isLayoutRtl=isLayoutRtl();
    final int width=getWidth();
    if (pos.position.type != lastItemType) {
      if (pos.position.type == ExpandableListPosition.CHILD) {
        indicatorRect.left=(mChildIndicatorLeft == CHILD_INDICATOR_INHERIT) ? mIndicatorLeft : mChildIndicatorLeft;
        indicatorRect.right=(mChildIndicatorRight == CHILD_INDICATOR_INHERIT) ? mIndicatorRight : mChildIndicatorRight;
      }
 else {
        indicatorRect.left=mIndicatorLeft;
        indicatorRect.right=mIndicatorRight;
      }
      if (isLayoutRtl) {
        final int temp=indicatorRect.left;
        indicatorRect.left=width - indicatorRect.right;
        indicatorRect.right=width - temp;
        indicatorRect.left-=mPaddingRight;
        indicatorRect.right-=mPaddingRight;
      }
 else {
        indicatorRect.left+=mPaddingLeft;
        indicatorRect.right+=mPaddingLeft;
      }
      lastItemType=pos.position.type;
    }
    if (indicatorRect.left != indicatorRect.right) {
      if (mStackFromBottom) {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
 else {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
      indicator=getIndicator(pos);
      if (indicator != null) {
        indicator.setBounds(indicatorRect);
        indicator.draw(canvas);
      }
    }
    pos.recycle();
  }
  if (clipToPadding) {
    canvas.restoreToCount(saveCount);
  }
}"
2629,"@Override protected void dispatchDraw(Canvas canvas){
  super.dispatchDraw(canvas);
  if ((mChildIndicator == null) && (mGroupIndicator == null)) {
    return;
  }
  int saveCount=0;
  final boolean clipToPadding=(mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
  if (clipToPadding) {
    saveCount=canvas.save();
    final int scrollX=mScrollX;
    final int scrollY=mScrollY;
    canvas.clipRect(scrollX + mPaddingLeft,scrollY + mPaddingTop,scrollX + mRight - mLeft - mPaddingRight,scrollY + mBottom - mTop - mPaddingBottom);
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int lastChildFlPos=mItemCount - getFooterViewsCount() - headerViewsCount- 1;
  final int myB=mBottom;
  PositionMetadata pos;
  View item;
  Drawable indicator;
  int t, b;
  int lastItemType=~(ExpandableListPosition.CHILD | ExpandableListPosition.GROUP);
  final Rect indicatorRect=mIndicatorRect;
  final int childCount=getChildCount();
  for (int i=0, childFlPos=mFirstPosition - headerViewsCount; i < childCount; i++, childFlPos++) {
    if (childFlPos < 0) {
      continue;
    }
 else     if (childFlPos > lastChildFlPos) {
      break;
    }
    item=getChildAt(i);
    t=item.getTop();
    b=item.getBottom();
    if ((b < 0) || (t > myB))     continue;
    pos=mConnector.getUnflattenedPos(childFlPos);
    if (pos.position.type != lastItemType) {
      if (pos.position.type == ExpandableListPosition.CHILD) {
        indicatorRect.left=(mChildIndicatorLeft == CHILD_INDICATOR_INHERIT) ? mIndicatorLeft : mChildIndicatorLeft;
        indicatorRect.right=(mChildIndicatorRight == CHILD_INDICATOR_INHERIT) ? mIndicatorRight : mChildIndicatorRight;
      }
 else {
        indicatorRect.left=mIndicatorLeft;
        indicatorRect.right=mIndicatorRight;
      }
      indicatorRect.left+=mPaddingLeft;
      indicatorRect.right+=mPaddingLeft;
      lastItemType=pos.position.type;
    }
    if (indicatorRect.left != indicatorRect.right) {
      if (mStackFromBottom) {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
 else {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
      indicator=getIndicator(pos);
      if (indicator != null) {
        indicator.setBounds(indicatorRect);
        indicator.draw(canvas);
      }
    }
    pos.recycle();
  }
  if (clipToPadding) {
    canvas.restoreToCount(saveCount);
  }
}","@Override protected void dispatchDraw(Canvas canvas){
  super.dispatchDraw(canvas);
  if ((mChildIndicator == null) && (mGroupIndicator == null)) {
    return;
  }
  int saveCount=0;
  final boolean clipToPadding=(mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
  if (clipToPadding) {
    saveCount=canvas.save();
    final int scrollX=mScrollX;
    final int scrollY=mScrollY;
    canvas.clipRect(scrollX + mPaddingLeft,scrollY + mPaddingTop,scrollX + mRight - mLeft - mPaddingRight,scrollY + mBottom - mTop - mPaddingBottom);
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int lastChildFlPos=mItemCount - getFooterViewsCount() - headerViewsCount- 1;
  final int myB=mBottom;
  PositionMetadata pos;
  View item;
  Drawable indicator;
  int t, b;
  int lastItemType=~(ExpandableListPosition.CHILD | ExpandableListPosition.GROUP);
  final Rect indicatorRect=mIndicatorRect;
  final int childCount=getChildCount();
  for (int i=0, childFlPos=mFirstPosition - headerViewsCount; i < childCount; i++, childFlPos++) {
    if (childFlPos < 0) {
      continue;
    }
 else     if (childFlPos > lastChildFlPos) {
      break;
    }
    item=getChildAt(i);
    t=item.getTop();
    b=item.getBottom();
    if ((b < 0) || (t > myB))     continue;
    pos=mConnector.getUnflattenedPos(childFlPos);
    final boolean isLayoutRtl=isLayoutRtl();
    final int width=getWidth();
    if (pos.position.type != lastItemType) {
      if (pos.position.type == ExpandableListPosition.CHILD) {
        indicatorRect.left=(mChildIndicatorLeft == CHILD_INDICATOR_INHERIT) ? mIndicatorLeft : mChildIndicatorLeft;
        indicatorRect.right=(mChildIndicatorRight == CHILD_INDICATOR_INHERIT) ? mIndicatorRight : mChildIndicatorRight;
      }
 else {
        indicatorRect.left=mIndicatorLeft;
        indicatorRect.right=mIndicatorRight;
      }
      if (isLayoutRtl) {
        final int temp=indicatorRect.left;
        indicatorRect.left=width - indicatorRect.right;
        indicatorRect.right=width - temp;
        indicatorRect.left-=mPaddingRight;
        indicatorRect.right-=mPaddingRight;
      }
 else {
        indicatorRect.left+=mPaddingLeft;
        indicatorRect.right+=mPaddingLeft;
      }
      lastItemType=pos.position.type;
    }
    if (indicatorRect.left != indicatorRect.right) {
      if (mStackFromBottom) {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
 else {
        indicatorRect.top=t;
        indicatorRect.bottom=b;
      }
      indicator=getIndicator(pos);
      if (indicator != null) {
        indicator.setBounds(indicatorRect);
        indicator.draw(canvas);
      }
    }
    pos.recycle();
  }
  if (clipToPadding) {
    canvas.restoreToCount(saveCount);
  }
}"
2630,"/** 
 * Just like   {@link Paint#getTextRunAdvances}.
 * @hide
 */
float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint paint,int reserved);","/** 
 * Just like   {@link Paint#getTextRunAdvances}.
 * @hide
 */
float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint paint);"
2631,"/** 
 * Don't call this yourself -- exists for Paint to use internally.  {@hide}
 */
public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesPos,Paint p,int reserved){
  float ret;
  int contextLen=contextEnd - contextStart;
  int len=end - start;
  if (end <= mGapStart) {
    ret=p.getTextRunAdvances(mText,start,len,contextStart,contextLen,flags,advances,advancesPos,reserved);
  }
 else   if (start >= mGapStart) {
    ret=p.getTextRunAdvances(mText,start + mGapLength,len,contextStart + mGapLength,contextLen,flags,advances,advancesPos,reserved);
  }
 else {
    char[] buf=TextUtils.obtain(contextLen);
    getChars(contextStart,contextEnd,buf,0);
    ret=p.getTextRunAdvances(buf,start - contextStart,len,0,contextLen,flags,advances,advancesPos,reserved);
    TextUtils.recycle(buf);
  }
  return ret;
}","/** 
 * Don't call this yourself -- exists for Paint to use internally.  {@hide}
 */
public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesPos,Paint p){
  float ret;
  int contextLen=contextEnd - contextStart;
  int len=end - start;
  if (end <= mGapStart) {
    ret=p.getTextRunAdvances(mText,start,len,contextStart,contextLen,flags,advances,advancesPos);
  }
 else   if (start >= mGapStart) {
    ret=p.getTextRunAdvances(mText,start + mGapLength,len,contextStart + mGapLength,contextLen,flags,advances,advancesPos);
  }
 else {
    char[] buf=TextUtils.obtain(contextLen);
    getChars(contextStart,contextEnd,buf,0);
    ret=p.getTextRunAdvances(buf,start - contextStart,len,0,contextLen,flags,advances,advancesPos);
    TextUtils.recycle(buf);
  }
  return ret;
}"
2632,"public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint p,int reserved){
  int count=end - start;
  int contextCount=contextEnd - contextStart;
  return p.getTextRunAdvances(mChars,start + mStart,count,contextStart + mStart,contextCount,flags,advances,advancesIndex,reserved);
}","public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint p){
  int count=end - start;
  int contextCount=contextEnd - contextStart;
  return p.getTextRunAdvances(mChars,start + mStart,count,contextStart + mStart,contextCount,flags,advances,advancesIndex);
}"
2633,"/** 
 * Just like   {@link Paint#getTextRunAdvances}.
 * @hide
 */
float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint paint,int reserved);","/** 
 * Just like   {@link Paint#getTextRunAdvances}.
 * @hide
 */
float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint paint);"
2634,"/** 
 * Don't call this yourself -- exists for Paint to use internally.  {@hide}
 */
public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesPos,Paint p,int reserved){
  float ret;
  int contextLen=contextEnd - contextStart;
  int len=end - start;
  if (end <= mGapStart) {
    ret=p.getTextRunAdvances(mText,start,len,contextStart,contextLen,flags,advances,advancesPos,reserved);
  }
 else   if (start >= mGapStart) {
    ret=p.getTextRunAdvances(mText,start + mGapLength,len,contextStart + mGapLength,contextLen,flags,advances,advancesPos,reserved);
  }
 else {
    char[] buf=TextUtils.obtain(contextLen);
    getChars(contextStart,contextEnd,buf,0);
    ret=p.getTextRunAdvances(buf,start - contextStart,len,0,contextLen,flags,advances,advancesPos,reserved);
    TextUtils.recycle(buf);
  }
  return ret;
}","/** 
 * Don't call this yourself -- exists for Paint to use internally.  {@hide}
 */
public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesPos,Paint p){
  float ret;
  int contextLen=contextEnd - contextStart;
  int len=end - start;
  if (end <= mGapStart) {
    ret=p.getTextRunAdvances(mText,start,len,contextStart,contextLen,flags,advances,advancesPos);
  }
 else   if (start >= mGapStart) {
    ret=p.getTextRunAdvances(mText,start + mGapLength,len,contextStart + mGapLength,contextLen,flags,advances,advancesPos);
  }
 else {
    char[] buf=TextUtils.obtain(contextLen);
    getChars(contextStart,contextEnd,buf,0);
    ret=p.getTextRunAdvances(buf,start - contextStart,len,0,contextLen,flags,advances,advancesPos);
    TextUtils.recycle(buf);
  }
  return ret;
}"
2635,"public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint p,int reserved){
  int count=end - start;
  int contextCount=contextEnd - contextStart;
  return p.getTextRunAdvances(mChars,start + mStart,count,contextStart + mStart,contextCount,flags,advances,advancesIndex,reserved);
}","public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint p){
  int count=end - start;
  int contextCount=contextEnd - contextStart;
  return p.getTextRunAdvances(mChars,start + mStart,count,contextStart + mStart,contextCount,flags,advances,advancesIndex);
}"
2636,"/** 
 * Just like   {@link Paint#getTextRunAdvances}.
 * @hide
 */
float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint paint,int reserved);","/** 
 * Just like   {@link Paint#getTextRunAdvances}.
 * @hide
 */
float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint paint);"
2637,"/** 
 * Don't call this yourself -- exists for Paint to use internally.  {@hide}
 */
public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesPos,Paint p,int reserved){
  float ret;
  int contextLen=contextEnd - contextStart;
  int len=end - start;
  if (end <= mGapStart) {
    ret=p.getTextRunAdvances(mText,start,len,contextStart,contextLen,flags,advances,advancesPos,reserved);
  }
 else   if (start >= mGapStart) {
    ret=p.getTextRunAdvances(mText,start + mGapLength,len,contextStart + mGapLength,contextLen,flags,advances,advancesPos,reserved);
  }
 else {
    char[] buf=TextUtils.obtain(contextLen);
    getChars(contextStart,contextEnd,buf,0);
    ret=p.getTextRunAdvances(buf,start - contextStart,len,0,contextLen,flags,advances,advancesPos,reserved);
    TextUtils.recycle(buf);
  }
  return ret;
}","/** 
 * Don't call this yourself -- exists for Paint to use internally.  {@hide}
 */
public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesPos,Paint p){
  float ret;
  int contextLen=contextEnd - contextStart;
  int len=end - start;
  if (end <= mGapStart) {
    ret=p.getTextRunAdvances(mText,start,len,contextStart,contextLen,flags,advances,advancesPos);
  }
 else   if (start >= mGapStart) {
    ret=p.getTextRunAdvances(mText,start + mGapLength,len,contextStart + mGapLength,contextLen,flags,advances,advancesPos);
  }
 else {
    char[] buf=TextUtils.obtain(contextLen);
    getChars(contextStart,contextEnd,buf,0);
    ret=p.getTextRunAdvances(buf,start - contextStart,len,0,contextLen,flags,advances,advancesPos);
    TextUtils.recycle(buf);
  }
  return ret;
}"
2638,"public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint p,int reserved){
  int count=end - start;
  int contextCount=contextEnd - contextStart;
  return p.getTextRunAdvances(mChars,start + mStart,count,contextStart + mStart,contextCount,flags,advances,advancesIndex,reserved);
}","public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint p){
  int count=end - start;
  int contextCount=contextEnd - contextStart;
  return p.getTextRunAdvances(mChars,start + mStart,count,contextStart + mStart,contextCount,flags,advances,advancesIndex);
}"
2639,"/** 
 * Just like   {@link Paint#getTextRunAdvances}.
 * @hide
 */
float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint paint,int reserved);","/** 
 * Just like   {@link Paint#getTextRunAdvances}.
 * @hide
 */
float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint paint);"
2640,"/** 
 * Don't call this yourself -- exists for Paint to use internally.  {@hide}
 */
public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesPos,Paint p,int reserved){
  float ret;
  int contextLen=contextEnd - contextStart;
  int len=end - start;
  if (end <= mGapStart) {
    ret=p.getTextRunAdvances(mText,start,len,contextStart,contextLen,flags,advances,advancesPos,reserved);
  }
 else   if (start >= mGapStart) {
    ret=p.getTextRunAdvances(mText,start + mGapLength,len,contextStart + mGapLength,contextLen,flags,advances,advancesPos,reserved);
  }
 else {
    char[] buf=TextUtils.obtain(contextLen);
    getChars(contextStart,contextEnd,buf,0);
    ret=p.getTextRunAdvances(buf,start - contextStart,len,0,contextLen,flags,advances,advancesPos,reserved);
    TextUtils.recycle(buf);
  }
  return ret;
}","/** 
 * Don't call this yourself -- exists for Paint to use internally.  {@hide}
 */
public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesPos,Paint p){
  float ret;
  int contextLen=contextEnd - contextStart;
  int len=end - start;
  if (end <= mGapStart) {
    ret=p.getTextRunAdvances(mText,start,len,contextStart,contextLen,flags,advances,advancesPos);
  }
 else   if (start >= mGapStart) {
    ret=p.getTextRunAdvances(mText,start + mGapLength,len,contextStart + mGapLength,contextLen,flags,advances,advancesPos);
  }
 else {
    char[] buf=TextUtils.obtain(contextLen);
    getChars(contextStart,contextEnd,buf,0);
    ret=p.getTextRunAdvances(buf,start - contextStart,len,0,contextLen,flags,advances,advancesPos);
    TextUtils.recycle(buf);
  }
  return ret;
}"
2641,"public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint p,int reserved){
  int count=end - start;
  int contextCount=contextEnd - contextStart;
  return p.getTextRunAdvances(mChars,start + mStart,count,contextStart + mStart,contextCount,flags,advances,advancesIndex,reserved);
}","public float getTextRunAdvances(int start,int end,int contextStart,int contextEnd,int flags,float[] advances,int advancesIndex,Paint p){
  int count=end - start;
  int contextCount=contextEnd - contextStart;
  return p.getTextRunAdvances(mChars,start + mStart,count,contextStart + mStart,contextCount,flags,advances,advancesIndex);
}"
2642,"private void setErrorIcon(Drawable icon){
  Drawables dr=mTextView.mDrawables;
  if (dr == null) {
    mTextView.mDrawables=dr=new Drawables();
  }
  dr.setErrorDrawable(icon,mTextView);
  mTextView.resetResolvedDrawables();
  mTextView.invalidate();
  mTextView.requestLayout();
}","private void setErrorIcon(Drawable icon){
  Drawables dr=mTextView.mDrawables;
  if (dr == null) {
    mTextView.mDrawables=dr=new Drawables(mTextView.getContext());
  }
  dr.setErrorDrawable(icon,mTextView);
  mTextView.resetResolvedDrawables();
  mTextView.invalidate();
  mTextView.requestLayout();
}"
2643,"/** 
 * Sets the size of the padding between the compound drawables and the text.
 * @attr ref android.R.styleable#TextView_drawablePadding
 */
@android.view.RemotableViewMethod public void setCompoundDrawablePadding(int pad){
  Drawables dr=mDrawables;
  if (pad == 0) {
    if (dr != null) {
      dr.mDrawablePadding=pad;
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    dr.mDrawablePadding=pad;
  }
  invalidate();
  requestLayout();
}","/** 
 * Sets the size of the padding between the compound drawables and the text.
 * @attr ref android.R.styleable#TextView_drawablePadding
 */
@android.view.RemotableViewMethod public void setCompoundDrawablePadding(int pad){
  Drawables dr=mDrawables;
  if (pad == 0) {
    if (dr != null) {
      dr.mDrawablePadding=pad;
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    dr.mDrawablePadding=pad;
  }
  invalidate();
  requestLayout();
}"
2644,"/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelative(Drawable start,Drawable top,Drawable end,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=start != null || top != null || end != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableStart != null)         dr.mDrawableStart.setCallback(null);
        dr.mDrawableStart=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableEnd != null)         dr.mDrawableEnd.setCallback(null);
        dr.mDrawableEnd=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
        dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
      dr.mDrawableStart.setCallback(null);
    }
    dr.mDrawableStart=start;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
      dr.mDrawableEnd.setCallback(null);
    }
    dr.mDrawableEnd=end;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (start != null) {
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  resolveDrawables();
  invalidate();
  requestLayout();
}","/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelative(Drawable start,Drawable top,Drawable end,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=start != null || top != null || end != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableStart != null)         dr.mDrawableStart.setCallback(null);
        dr.mDrawableStart=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableEnd != null)         dr.mDrawableEnd.setCallback(null);
        dr.mDrawableEnd=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
        dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
      dr.mDrawableStart.setCallback(null);
    }
    dr.mDrawableStart=start;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
      dr.mDrawableEnd.setCallback(null);
    }
    dr.mDrawableEnd=end;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (start != null) {
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  resetResolvedDrawables();
  resolveDrawables();
  invalidate();
  requestLayout();
}"
2645,"/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there. The Drawables' bounds will be set to their intrinsic bounds.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelativeWithIntrinsicBounds(Drawable start,Drawable top,Drawable end,Drawable bottom){
  resetResolvedDrawables();
  if (start != null) {
    start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
  }
  if (end != null) {
    end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
  }
  if (top != null) {
    top.setBounds(0,0,top.getIntrinsicWidth(),top.getIntrinsicHeight());
  }
  if (bottom != null) {
    bottom.setBounds(0,0,bottom.getIntrinsicWidth(),bottom.getIntrinsicHeight());
  }
  setCompoundDrawablesRelative(start,top,end,bottom);
}","/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there. The Drawables' bounds will be set to their intrinsic bounds.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelativeWithIntrinsicBounds(Drawable start,Drawable top,Drawable end,Drawable bottom){
  if (start != null) {
    start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
  }
  if (end != null) {
    end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
  }
  if (top != null) {
    top.setBounds(0,0,top.getIntrinsicWidth(),top.getIntrinsicHeight());
  }
  if (bottom != null) {
    bottom.setBounds(0,0,bottom.getIntrinsicWidth(),bottom.getIntrinsicHeight());
  }
  setCompoundDrawablesRelative(start,top,end,bottom);
}"
2646,"public void resolveWithLayoutDirection(int layoutDirection){
switch (layoutDirection) {
case LAYOUT_DIRECTION_RTL:
    if (mDrawableStart != null) {
      mDrawableRight=mDrawableStart;
      mDrawableSizeRight=mDrawableSizeStart;
      mDrawableHeightRight=mDrawableHeightStart;
    }
  if (mDrawableEnd != null) {
    mDrawableLeft=mDrawableEnd;
    mDrawableSizeLeft=mDrawableSizeEnd;
    mDrawableHeightLeft=mDrawableHeightEnd;
  }
break;
case LAYOUT_DIRECTION_LTR:
default :
if (mDrawableStart != null) {
mDrawableLeft=mDrawableStart;
mDrawableSizeLeft=mDrawableSizeStart;
mDrawableHeightLeft=mDrawableHeightStart;
}
if (mDrawableEnd != null) {
mDrawableRight=mDrawableEnd;
mDrawableSizeRight=mDrawableSizeEnd;
mDrawableHeightRight=mDrawableHeightEnd;
}
break;
}
applyErrorDrawableIfNeeded(layoutDirection);
updateDrawablesLayoutDirection(layoutDirection);
}","public void resolveWithLayoutDirection(int layoutDirection){
  mDrawableLeft=mDrawableLeftInitial;
  mDrawableRight=mDrawableRightInitial;
  if (mIsRtlCompatibilityMode) {
    if (mDrawableStart != null && mDrawableLeft == null) {
      mDrawableLeft=mDrawableStart;
      mDrawableSizeLeft=mDrawableSizeStart;
      mDrawableHeightLeft=mDrawableHeightStart;
    }
    if (mDrawableEnd != null && mDrawableRight == null) {
      mDrawableRight=mDrawableEnd;
      mDrawableSizeRight=mDrawableSizeEnd;
      mDrawableHeightRight=mDrawableHeightEnd;
    }
  }
 else {
switch (layoutDirection) {
case LAYOUT_DIRECTION_RTL:
      if (mOverride) {
        mDrawableRight=mDrawableStart;
        mDrawableSizeRight=mDrawableSizeStart;
        mDrawableHeightRight=mDrawableHeightStart;
      }
    if (mOverride) {
      mDrawableLeft=mDrawableEnd;
      mDrawableSizeLeft=mDrawableSizeEnd;
      mDrawableHeightLeft=mDrawableHeightEnd;
    }
  break;
case LAYOUT_DIRECTION_LTR:
default :
if (mOverride) {
  mDrawableLeft=mDrawableStart;
  mDrawableSizeLeft=mDrawableSizeStart;
  mDrawableHeightLeft=mDrawableHeightStart;
}
if (mOverride) {
mDrawableRight=mDrawableEnd;
mDrawableSizeRight=mDrawableSizeEnd;
mDrawableHeightRight=mDrawableHeightEnd;
}
break;
}
}
applyErrorDrawableIfNeeded(layoutDirection);
updateDrawablesLayoutDirection(layoutDirection);
}"
2647,"/** 
 * Sets the Drawables (if any) to appear to the left of, above, to the right of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableLeft
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableRight
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawables(Drawable left,Drawable top,Drawable right,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=left != null || top != null || right != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableLeft != null)         dr.mDrawableLeft.setCallback(null);
        dr.mDrawableLeft=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableRight != null)         dr.mDrawableRight.setCallback(null);
        dr.mDrawableRight=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
        dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    if (dr.mDrawableLeft != left && dr.mDrawableLeft != null) {
      dr.mDrawableLeft.setCallback(null);
    }
    dr.mDrawableLeft=left;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableRight != right && dr.mDrawableRight != null) {
      dr.mDrawableRight.setCallback(null);
    }
    dr.mDrawableRight=right;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (left != null) {
      left.setState(state);
      left.copyBounds(compoundRect);
      left.setCallback(this);
      dr.mDrawableSizeLeft=compoundRect.width();
      dr.mDrawableHeightLeft=compoundRect.height();
    }
 else {
      dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
    }
    if (right != null) {
      right.setState(state);
      right.copyBounds(compoundRect);
      right.setCallback(this);
      dr.mDrawableSizeRight=compoundRect.width();
      dr.mDrawableHeightRight=compoundRect.height();
    }
 else {
      dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  invalidate();
  requestLayout();
}","/** 
 * Sets the Drawables (if any) to appear to the left of, above, to the right of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableLeft
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableRight
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawables(Drawable left,Drawable top,Drawable right,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=left != null || top != null || right != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableLeft != null)         dr.mDrawableLeft.setCallback(null);
        dr.mDrawableLeft=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableRight != null)         dr.mDrawableRight.setCallback(null);
        dr.mDrawableRight=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
        dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=false;
    if (dr.mDrawableLeft != left && dr.mDrawableLeft != null) {
      dr.mDrawableLeft.setCallback(null);
    }
    dr.mDrawableLeft=left;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableRight != right && dr.mDrawableRight != null) {
      dr.mDrawableRight.setCallback(null);
    }
    dr.mDrawableRight=right;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (left != null) {
      left.setState(state);
      left.copyBounds(compoundRect);
      left.setCallback(this);
      dr.mDrawableSizeLeft=compoundRect.width();
      dr.mDrawableHeightLeft=compoundRect.height();
    }
 else {
      dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
    }
    if (right != null) {
      right.setState(state);
      right.copyBounds(compoundRect);
      right.setCallback(this);
      dr.mDrawableSizeRight=compoundRect.width();
      dr.mDrawableHeightRight=compoundRect.height();
    }
 else {
      dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  if (dr != null) {
    dr.mDrawableLeftInitial=left;
    dr.mDrawableRightInitial=right;
  }
  invalidate();
  requestLayout();
}"
2648,"private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
  }
}","private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
  }
}"
2649,"private void setErrorIcon(Drawable icon){
  Drawables dr=mTextView.mDrawables;
  if (dr == null) {
    mTextView.mDrawables=dr=new Drawables();
  }
  dr.setErrorDrawable(icon,mTextView);
  mTextView.resetResolvedDrawables();
  mTextView.invalidate();
  mTextView.requestLayout();
}","private void setErrorIcon(Drawable icon){
  Drawables dr=mTextView.mDrawables;
  if (dr == null) {
    mTextView.mDrawables=dr=new Drawables(mTextView.getContext());
  }
  dr.setErrorDrawable(icon,mTextView);
  mTextView.resetResolvedDrawables();
  mTextView.invalidate();
  mTextView.requestLayout();
}"
2650,"/** 
 * Sets the size of the padding between the compound drawables and the text.
 * @attr ref android.R.styleable#TextView_drawablePadding
 */
@android.view.RemotableViewMethod public void setCompoundDrawablePadding(int pad){
  Drawables dr=mDrawables;
  if (pad == 0) {
    if (dr != null) {
      dr.mDrawablePadding=pad;
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    dr.mDrawablePadding=pad;
  }
  invalidate();
  requestLayout();
}","/** 
 * Sets the size of the padding between the compound drawables and the text.
 * @attr ref android.R.styleable#TextView_drawablePadding
 */
@android.view.RemotableViewMethod public void setCompoundDrawablePadding(int pad){
  Drawables dr=mDrawables;
  if (pad == 0) {
    if (dr != null) {
      dr.mDrawablePadding=pad;
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    dr.mDrawablePadding=pad;
  }
  invalidate();
  requestLayout();
}"
2651,"/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelative(Drawable start,Drawable top,Drawable end,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=start != null || top != null || end != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableStart != null)         dr.mDrawableStart.setCallback(null);
        dr.mDrawableStart=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableEnd != null)         dr.mDrawableEnd.setCallback(null);
        dr.mDrawableEnd=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
        dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
      dr.mDrawableStart.setCallback(null);
    }
    dr.mDrawableStart=start;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
      dr.mDrawableEnd.setCallback(null);
    }
    dr.mDrawableEnd=end;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (start != null) {
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  resolveDrawables();
  invalidate();
  requestLayout();
}","/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelative(Drawable start,Drawable top,Drawable end,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=start != null || top != null || end != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableStart != null)         dr.mDrawableStart.setCallback(null);
        dr.mDrawableStart=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableEnd != null)         dr.mDrawableEnd.setCallback(null);
        dr.mDrawableEnd=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
        dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
      dr.mDrawableStart.setCallback(null);
    }
    dr.mDrawableStart=start;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
      dr.mDrawableEnd.setCallback(null);
    }
    dr.mDrawableEnd=end;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (start != null) {
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  resetResolvedDrawables();
  resolveDrawables();
  invalidate();
  requestLayout();
}"
2652,"/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there. The Drawables' bounds will be set to their intrinsic bounds.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelativeWithIntrinsicBounds(Drawable start,Drawable top,Drawable end,Drawable bottom){
  resetResolvedDrawables();
  if (start != null) {
    start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
  }
  if (end != null) {
    end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
  }
  if (top != null) {
    top.setBounds(0,0,top.getIntrinsicWidth(),top.getIntrinsicHeight());
  }
  if (bottom != null) {
    bottom.setBounds(0,0,bottom.getIntrinsicWidth(),bottom.getIntrinsicHeight());
  }
  setCompoundDrawablesRelative(start,top,end,bottom);
}","/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there. The Drawables' bounds will be set to their intrinsic bounds.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelativeWithIntrinsicBounds(Drawable start,Drawable top,Drawable end,Drawable bottom){
  if (start != null) {
    start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
  }
  if (end != null) {
    end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
  }
  if (top != null) {
    top.setBounds(0,0,top.getIntrinsicWidth(),top.getIntrinsicHeight());
  }
  if (bottom != null) {
    bottom.setBounds(0,0,bottom.getIntrinsicWidth(),bottom.getIntrinsicHeight());
  }
  setCompoundDrawablesRelative(start,top,end,bottom);
}"
2653,"public void resolveWithLayoutDirection(int layoutDirection){
switch (layoutDirection) {
case LAYOUT_DIRECTION_RTL:
    if (mDrawableStart != null) {
      mDrawableRight=mDrawableStart;
      mDrawableSizeRight=mDrawableSizeStart;
      mDrawableHeightRight=mDrawableHeightStart;
    }
  if (mDrawableEnd != null) {
    mDrawableLeft=mDrawableEnd;
    mDrawableSizeLeft=mDrawableSizeEnd;
    mDrawableHeightLeft=mDrawableHeightEnd;
  }
break;
case LAYOUT_DIRECTION_LTR:
default :
if (mDrawableStart != null) {
mDrawableLeft=mDrawableStart;
mDrawableSizeLeft=mDrawableSizeStart;
mDrawableHeightLeft=mDrawableHeightStart;
}
if (mDrawableEnd != null) {
mDrawableRight=mDrawableEnd;
mDrawableSizeRight=mDrawableSizeEnd;
mDrawableHeightRight=mDrawableHeightEnd;
}
break;
}
applyErrorDrawableIfNeeded(layoutDirection);
updateDrawablesLayoutDirection(layoutDirection);
}","public void resolveWithLayoutDirection(int layoutDirection){
  mDrawableLeft=mDrawableLeftInitial;
  mDrawableRight=mDrawableRightInitial;
  if (mIsRtlCompatibilityMode) {
    if (mDrawableStart != null && mDrawableLeft == null) {
      mDrawableLeft=mDrawableStart;
      mDrawableSizeLeft=mDrawableSizeStart;
      mDrawableHeightLeft=mDrawableHeightStart;
    }
    if (mDrawableEnd != null && mDrawableRight == null) {
      mDrawableRight=mDrawableEnd;
      mDrawableSizeRight=mDrawableSizeEnd;
      mDrawableHeightRight=mDrawableHeightEnd;
    }
  }
 else {
switch (layoutDirection) {
case LAYOUT_DIRECTION_RTL:
      if (mOverride) {
        mDrawableRight=mDrawableStart;
        mDrawableSizeRight=mDrawableSizeStart;
        mDrawableHeightRight=mDrawableHeightStart;
      }
    if (mOverride) {
      mDrawableLeft=mDrawableEnd;
      mDrawableSizeLeft=mDrawableSizeEnd;
      mDrawableHeightLeft=mDrawableHeightEnd;
    }
  break;
case LAYOUT_DIRECTION_LTR:
default :
if (mOverride) {
  mDrawableLeft=mDrawableStart;
  mDrawableSizeLeft=mDrawableSizeStart;
  mDrawableHeightLeft=mDrawableHeightStart;
}
if (mOverride) {
mDrawableRight=mDrawableEnd;
mDrawableSizeRight=mDrawableSizeEnd;
mDrawableHeightRight=mDrawableHeightEnd;
}
break;
}
}
applyErrorDrawableIfNeeded(layoutDirection);
updateDrawablesLayoutDirection(layoutDirection);
}"
2654,"/** 
 * Sets the Drawables (if any) to appear to the left of, above, to the right of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableLeft
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableRight
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawables(Drawable left,Drawable top,Drawable right,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=left != null || top != null || right != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableLeft != null)         dr.mDrawableLeft.setCallback(null);
        dr.mDrawableLeft=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableRight != null)         dr.mDrawableRight.setCallback(null);
        dr.mDrawableRight=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
        dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    if (dr.mDrawableLeft != left && dr.mDrawableLeft != null) {
      dr.mDrawableLeft.setCallback(null);
    }
    dr.mDrawableLeft=left;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableRight != right && dr.mDrawableRight != null) {
      dr.mDrawableRight.setCallback(null);
    }
    dr.mDrawableRight=right;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (left != null) {
      left.setState(state);
      left.copyBounds(compoundRect);
      left.setCallback(this);
      dr.mDrawableSizeLeft=compoundRect.width();
      dr.mDrawableHeightLeft=compoundRect.height();
    }
 else {
      dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
    }
    if (right != null) {
      right.setState(state);
      right.copyBounds(compoundRect);
      right.setCallback(this);
      dr.mDrawableSizeRight=compoundRect.width();
      dr.mDrawableHeightRight=compoundRect.height();
    }
 else {
      dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  invalidate();
  requestLayout();
}","/** 
 * Sets the Drawables (if any) to appear to the left of, above, to the right of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableLeft
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableRight
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawables(Drawable left,Drawable top,Drawable right,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=left != null || top != null || right != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableLeft != null)         dr.mDrawableLeft.setCallback(null);
        dr.mDrawableLeft=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableRight != null)         dr.mDrawableRight.setCallback(null);
        dr.mDrawableRight=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
        dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=false;
    if (dr.mDrawableLeft != left && dr.mDrawableLeft != null) {
      dr.mDrawableLeft.setCallback(null);
    }
    dr.mDrawableLeft=left;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableRight != right && dr.mDrawableRight != null) {
      dr.mDrawableRight.setCallback(null);
    }
    dr.mDrawableRight=right;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (left != null) {
      left.setState(state);
      left.copyBounds(compoundRect);
      left.setCallback(this);
      dr.mDrawableSizeLeft=compoundRect.width();
      dr.mDrawableHeightLeft=compoundRect.height();
    }
 else {
      dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
    }
    if (right != null) {
      right.setState(state);
      right.copyBounds(compoundRect);
      right.setCallback(this);
      dr.mDrawableSizeRight=compoundRect.width();
      dr.mDrawableHeightRight=compoundRect.height();
    }
 else {
      dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  if (dr != null) {
    dr.mDrawableLeftInitial=left;
    dr.mDrawableRightInitial=right;
  }
  invalidate();
  requestLayout();
}"
2655,"private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
  }
}","private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
  }
}"
2656,"private void setErrorIcon(Drawable icon){
  Drawables dr=mTextView.mDrawables;
  if (dr == null) {
    mTextView.mDrawables=dr=new Drawables();
  }
  dr.setErrorDrawable(icon,mTextView);
  mTextView.resetResolvedDrawables();
  mTextView.invalidate();
  mTextView.requestLayout();
}","private void setErrorIcon(Drawable icon){
  Drawables dr=mTextView.mDrawables;
  if (dr == null) {
    mTextView.mDrawables=dr=new Drawables(mTextView.getContext());
  }
  dr.setErrorDrawable(icon,mTextView);
  mTextView.resetResolvedDrawables();
  mTextView.invalidate();
  mTextView.requestLayout();
}"
2657,"/** 
 * Sets the size of the padding between the compound drawables and the text.
 * @attr ref android.R.styleable#TextView_drawablePadding
 */
@android.view.RemotableViewMethod public void setCompoundDrawablePadding(int pad){
  Drawables dr=mDrawables;
  if (pad == 0) {
    if (dr != null) {
      dr.mDrawablePadding=pad;
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    dr.mDrawablePadding=pad;
  }
  invalidate();
  requestLayout();
}","/** 
 * Sets the size of the padding between the compound drawables and the text.
 * @attr ref android.R.styleable#TextView_drawablePadding
 */
@android.view.RemotableViewMethod public void setCompoundDrawablePadding(int pad){
  Drawables dr=mDrawables;
  if (pad == 0) {
    if (dr != null) {
      dr.mDrawablePadding=pad;
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    dr.mDrawablePadding=pad;
  }
  invalidate();
  requestLayout();
}"
2658,"/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelative(Drawable start,Drawable top,Drawable end,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=start != null || top != null || end != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableStart != null)         dr.mDrawableStart.setCallback(null);
        dr.mDrawableStart=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableEnd != null)         dr.mDrawableEnd.setCallback(null);
        dr.mDrawableEnd=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
        dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
      dr.mDrawableStart.setCallback(null);
    }
    dr.mDrawableStart=start;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
      dr.mDrawableEnd.setCallback(null);
    }
    dr.mDrawableEnd=end;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (start != null) {
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  resolveDrawables();
  invalidate();
  requestLayout();
}","/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelative(Drawable start,Drawable top,Drawable end,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=start != null || top != null || end != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableStart != null)         dr.mDrawableStart.setCallback(null);
        dr.mDrawableStart=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableEnd != null)         dr.mDrawableEnd.setCallback(null);
        dr.mDrawableEnd=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
        dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
      dr.mDrawableStart.setCallback(null);
    }
    dr.mDrawableStart=start;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
      dr.mDrawableEnd.setCallback(null);
    }
    dr.mDrawableEnd=end;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (start != null) {
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  resetResolvedDrawables();
  resolveDrawables();
  invalidate();
  requestLayout();
}"
2659,"/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there. The Drawables' bounds will be set to their intrinsic bounds.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelativeWithIntrinsicBounds(Drawable start,Drawable top,Drawable end,Drawable bottom){
  resetResolvedDrawables();
  if (start != null) {
    start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
  }
  if (end != null) {
    end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
  }
  if (top != null) {
    top.setBounds(0,0,top.getIntrinsicWidth(),top.getIntrinsicHeight());
  }
  if (bottom != null) {
    bottom.setBounds(0,0,bottom.getIntrinsicWidth(),bottom.getIntrinsicHeight());
  }
  setCompoundDrawablesRelative(start,top,end,bottom);
}","/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there. The Drawables' bounds will be set to their intrinsic bounds.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelativeWithIntrinsicBounds(Drawable start,Drawable top,Drawable end,Drawable bottom){
  if (start != null) {
    start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
  }
  if (end != null) {
    end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
  }
  if (top != null) {
    top.setBounds(0,0,top.getIntrinsicWidth(),top.getIntrinsicHeight());
  }
  if (bottom != null) {
    bottom.setBounds(0,0,bottom.getIntrinsicWidth(),bottom.getIntrinsicHeight());
  }
  setCompoundDrawablesRelative(start,top,end,bottom);
}"
2660,"public void resolveWithLayoutDirection(int layoutDirection){
switch (layoutDirection) {
case LAYOUT_DIRECTION_RTL:
    if (mDrawableStart != null) {
      mDrawableRight=mDrawableStart;
      mDrawableSizeRight=mDrawableSizeStart;
      mDrawableHeightRight=mDrawableHeightStart;
    }
  if (mDrawableEnd != null) {
    mDrawableLeft=mDrawableEnd;
    mDrawableSizeLeft=mDrawableSizeEnd;
    mDrawableHeightLeft=mDrawableHeightEnd;
  }
break;
case LAYOUT_DIRECTION_LTR:
default :
if (mDrawableStart != null) {
mDrawableLeft=mDrawableStart;
mDrawableSizeLeft=mDrawableSizeStart;
mDrawableHeightLeft=mDrawableHeightStart;
}
if (mDrawableEnd != null) {
mDrawableRight=mDrawableEnd;
mDrawableSizeRight=mDrawableSizeEnd;
mDrawableHeightRight=mDrawableHeightEnd;
}
break;
}
applyErrorDrawableIfNeeded(layoutDirection);
updateDrawablesLayoutDirection(layoutDirection);
}","public void resolveWithLayoutDirection(int layoutDirection){
  mDrawableLeft=mDrawableLeftInitial;
  mDrawableRight=mDrawableRightInitial;
  if (mIsRtlCompatibilityMode) {
    if (mDrawableStart != null && mDrawableLeft == null) {
      mDrawableLeft=mDrawableStart;
      mDrawableSizeLeft=mDrawableSizeStart;
      mDrawableHeightLeft=mDrawableHeightStart;
    }
    if (mDrawableEnd != null && mDrawableRight == null) {
      mDrawableRight=mDrawableEnd;
      mDrawableSizeRight=mDrawableSizeEnd;
      mDrawableHeightRight=mDrawableHeightEnd;
    }
  }
 else {
switch (layoutDirection) {
case LAYOUT_DIRECTION_RTL:
      if (mOverride) {
        mDrawableRight=mDrawableStart;
        mDrawableSizeRight=mDrawableSizeStart;
        mDrawableHeightRight=mDrawableHeightStart;
      }
    if (mOverride) {
      mDrawableLeft=mDrawableEnd;
      mDrawableSizeLeft=mDrawableSizeEnd;
      mDrawableHeightLeft=mDrawableHeightEnd;
    }
  break;
case LAYOUT_DIRECTION_LTR:
default :
if (mOverride) {
  mDrawableLeft=mDrawableStart;
  mDrawableSizeLeft=mDrawableSizeStart;
  mDrawableHeightLeft=mDrawableHeightStart;
}
if (mOverride) {
mDrawableRight=mDrawableEnd;
mDrawableSizeRight=mDrawableSizeEnd;
mDrawableHeightRight=mDrawableHeightEnd;
}
break;
}
}
applyErrorDrawableIfNeeded(layoutDirection);
updateDrawablesLayoutDirection(layoutDirection);
}"
2661,"/** 
 * Sets the Drawables (if any) to appear to the left of, above, to the right of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableLeft
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableRight
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawables(Drawable left,Drawable top,Drawable right,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=left != null || top != null || right != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableLeft != null)         dr.mDrawableLeft.setCallback(null);
        dr.mDrawableLeft=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableRight != null)         dr.mDrawableRight.setCallback(null);
        dr.mDrawableRight=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
        dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    if (dr.mDrawableLeft != left && dr.mDrawableLeft != null) {
      dr.mDrawableLeft.setCallback(null);
    }
    dr.mDrawableLeft=left;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableRight != right && dr.mDrawableRight != null) {
      dr.mDrawableRight.setCallback(null);
    }
    dr.mDrawableRight=right;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (left != null) {
      left.setState(state);
      left.copyBounds(compoundRect);
      left.setCallback(this);
      dr.mDrawableSizeLeft=compoundRect.width();
      dr.mDrawableHeightLeft=compoundRect.height();
    }
 else {
      dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
    }
    if (right != null) {
      right.setState(state);
      right.copyBounds(compoundRect);
      right.setCallback(this);
      dr.mDrawableSizeRight=compoundRect.width();
      dr.mDrawableHeightRight=compoundRect.height();
    }
 else {
      dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  invalidate();
  requestLayout();
}","/** 
 * Sets the Drawables (if any) to appear to the left of, above, to the right of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableLeft
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableRight
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawables(Drawable left,Drawable top,Drawable right,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=left != null || top != null || right != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableLeft != null)         dr.mDrawableLeft.setCallback(null);
        dr.mDrawableLeft=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableRight != null)         dr.mDrawableRight.setCallback(null);
        dr.mDrawableRight=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
        dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=false;
    if (dr.mDrawableLeft != left && dr.mDrawableLeft != null) {
      dr.mDrawableLeft.setCallback(null);
    }
    dr.mDrawableLeft=left;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableRight != right && dr.mDrawableRight != null) {
      dr.mDrawableRight.setCallback(null);
    }
    dr.mDrawableRight=right;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (left != null) {
      left.setState(state);
      left.copyBounds(compoundRect);
      left.setCallback(this);
      dr.mDrawableSizeLeft=compoundRect.width();
      dr.mDrawableHeightLeft=compoundRect.height();
    }
 else {
      dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
    }
    if (right != null) {
      right.setState(state);
      right.copyBounds(compoundRect);
      right.setCallback(this);
      dr.mDrawableSizeRight=compoundRect.width();
      dr.mDrawableHeightRight=compoundRect.height();
    }
 else {
      dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  if (dr != null) {
    dr.mDrawableLeftInitial=left;
    dr.mDrawableRightInitial=right;
  }
  invalidate();
  requestLayout();
}"
2662,"private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
  }
}","private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
  }
}"
2663,"/** 
 * Put a view into the ScrapViews list. These views are unordered.
 * @param scrap The view to add
 */
void addScrapView(View scrap,int position){
  AbsListView.LayoutParams lp=(AbsListView.LayoutParams)scrap.getLayoutParams();
  if (lp == null) {
    return;
  }
  lp.scrappedFromPosition=position;
  int viewType=lp.viewType;
  final boolean scrapHasTransientState=scrap.hasTransientState();
  if (!shouldRecycleViewType(viewType) || scrapHasTransientState) {
    if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState) {
      if (mSkippedScrap == null) {
        mSkippedScrap=new ArrayList<View>();
      }
      mSkippedScrap.add(scrap);
    }
    if (scrapHasTransientState) {
      scrap.dispatchStartTemporaryDetach();
      if (mAdapter != null && mAdapterHasStableIds) {
        if (mTransientStateViewsById == null) {
          mTransientStateViewsById=new LongSparseArray<View>();
        }
        mTransientStateViewsById.put(lp.itemId,scrap);
      }
 else {
        if (mTransientStateViews == null) {
          mTransientStateViews=new SparseArray<View>();
        }
        mTransientStateViews.put(position,scrap);
      }
    }
    return;
  }
  scrap.dispatchStartTemporaryDetach();
  if (mViewTypeCount == 1) {
    mCurrentScrap.add(scrap);
  }
 else {
    mScrapViews[viewType].add(scrap);
  }
  scrap.setAccessibilityDelegate(null);
  if (mRecyclerListener != null) {
    mRecyclerListener.onMovedToScrapHeap(scrap);
  }
}","/** 
 * Put a view into the ScrapViews list. These views are unordered.
 * @param scrap The view to add
 */
void addScrapView(View scrap,int position){
  AbsListView.LayoutParams lp=(AbsListView.LayoutParams)scrap.getLayoutParams();
  if (lp == null) {
    return;
  }
  lp.scrappedFromPosition=position;
  int viewType=lp.viewType;
  final boolean scrapHasTransientState=scrap.hasTransientState();
  if (!shouldRecycleViewType(viewType) || scrapHasTransientState) {
    if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState) {
      if (mSkippedScrap == null) {
        mSkippedScrap=new ArrayList<View>();
      }
      mSkippedScrap.add(scrap);
    }
    if (scrapHasTransientState) {
      scrap.dispatchStartTemporaryDetach();
      if (mAdapter != null && mAdapterHasStableIds) {
        if (mTransientStateViewsById == null) {
          mTransientStateViewsById=new LongSparseArray<View>();
        }
        mTransientStateViewsById.put(lp.itemId,scrap);
      }
 else       if (!mDataChanged) {
        if (mTransientStateViews == null) {
          mTransientStateViews=new SparseArray<View>();
        }
        mTransientStateViews.put(position,scrap);
      }
    }
    return;
  }
  scrap.dispatchStartTemporaryDetach();
  if (mViewTypeCount == 1) {
    mCurrentScrap.add(scrap);
  }
 else {
    mScrapViews[viewType].add(scrap);
  }
  scrap.setAccessibilityDelegate(null);
  if (mRecyclerListener != null) {
    mRecyclerListener.onMovedToScrapHeap(scrap);
  }
}"
2664,"/** 
 * Put a view into the ScrapViews list. These views are unordered.
 * @param scrap The view to add
 */
void addScrapView(View scrap,int position){
  AbsListView.LayoutParams lp=(AbsListView.LayoutParams)scrap.getLayoutParams();
  if (lp == null) {
    return;
  }
  lp.scrappedFromPosition=position;
  int viewType=lp.viewType;
  final boolean scrapHasTransientState=scrap.hasTransientState();
  if (!shouldRecycleViewType(viewType) || scrapHasTransientState) {
    if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState) {
      if (mSkippedScrap == null) {
        mSkippedScrap=new ArrayList<View>();
      }
      mSkippedScrap.add(scrap);
    }
    if (scrapHasTransientState) {
      scrap.dispatchStartTemporaryDetach();
      if (mAdapter != null && mAdapterHasStableIds) {
        if (mTransientStateViewsById == null) {
          mTransientStateViewsById=new LongSparseArray<View>();
        }
        mTransientStateViewsById.put(lp.itemId,scrap);
      }
 else {
        if (mTransientStateViews == null) {
          mTransientStateViews=new SparseArray<View>();
        }
        mTransientStateViews.put(position,scrap);
      }
    }
    return;
  }
  scrap.dispatchStartTemporaryDetach();
  if (mViewTypeCount == 1) {
    mCurrentScrap.add(scrap);
  }
 else {
    mScrapViews[viewType].add(scrap);
  }
  scrap.setAccessibilityDelegate(null);
  if (mRecyclerListener != null) {
    mRecyclerListener.onMovedToScrapHeap(scrap);
  }
}","/** 
 * Put a view into the ScrapViews list. These views are unordered.
 * @param scrap The view to add
 */
void addScrapView(View scrap,int position){
  AbsListView.LayoutParams lp=(AbsListView.LayoutParams)scrap.getLayoutParams();
  if (lp == null) {
    return;
  }
  lp.scrappedFromPosition=position;
  int viewType=lp.viewType;
  final boolean scrapHasTransientState=scrap.hasTransientState();
  if (!shouldRecycleViewType(viewType) || scrapHasTransientState) {
    if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState) {
      if (mSkippedScrap == null) {
        mSkippedScrap=new ArrayList<View>();
      }
      mSkippedScrap.add(scrap);
    }
    if (scrapHasTransientState) {
      scrap.dispatchStartTemporaryDetach();
      if (mAdapter != null && mAdapterHasStableIds) {
        if (mTransientStateViewsById == null) {
          mTransientStateViewsById=new LongSparseArray<View>();
        }
        mTransientStateViewsById.put(lp.itemId,scrap);
      }
 else       if (!mDataChanged) {
        if (mTransientStateViews == null) {
          mTransientStateViews=new SparseArray<View>();
        }
        mTransientStateViews.put(position,scrap);
      }
    }
    return;
  }
  scrap.dispatchStartTemporaryDetach();
  if (mViewTypeCount == 1) {
    mCurrentScrap.add(scrap);
  }
 else {
    mScrapViews[viewType].add(scrap);
  }
  scrap.setAccessibilityDelegate(null);
  if (mRecyclerListener != null) {
    mRecyclerListener.onMovedToScrapHeap(scrap);
  }
}"
2665,"/** 
 * Put a view into the ScrapViews list. These views are unordered.
 * @param scrap The view to add
 */
void addScrapView(View scrap,int position){
  AbsListView.LayoutParams lp=(AbsListView.LayoutParams)scrap.getLayoutParams();
  if (lp == null) {
    return;
  }
  lp.scrappedFromPosition=position;
  int viewType=lp.viewType;
  final boolean scrapHasTransientState=scrap.hasTransientState();
  if (!shouldRecycleViewType(viewType) || scrapHasTransientState) {
    if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState) {
      if (mSkippedScrap == null) {
        mSkippedScrap=new ArrayList<View>();
      }
      mSkippedScrap.add(scrap);
    }
    if (scrapHasTransientState) {
      scrap.dispatchStartTemporaryDetach();
      if (mAdapter != null && mAdapterHasStableIds) {
        if (mTransientStateViewsById == null) {
          mTransientStateViewsById=new LongSparseArray<View>();
        }
        mTransientStateViewsById.put(lp.itemId,scrap);
      }
 else {
        if (mTransientStateViews == null) {
          mTransientStateViews=new SparseArray<View>();
        }
        mTransientStateViews.put(position,scrap);
      }
    }
    return;
  }
  scrap.dispatchStartTemporaryDetach();
  if (mViewTypeCount == 1) {
    mCurrentScrap.add(scrap);
  }
 else {
    mScrapViews[viewType].add(scrap);
  }
  scrap.setAccessibilityDelegate(null);
  if (mRecyclerListener != null) {
    mRecyclerListener.onMovedToScrapHeap(scrap);
  }
}","/** 
 * Put a view into the ScrapViews list. These views are unordered.
 * @param scrap The view to add
 */
void addScrapView(View scrap,int position){
  AbsListView.LayoutParams lp=(AbsListView.LayoutParams)scrap.getLayoutParams();
  if (lp == null) {
    return;
  }
  lp.scrappedFromPosition=position;
  int viewType=lp.viewType;
  final boolean scrapHasTransientState=scrap.hasTransientState();
  if (!shouldRecycleViewType(viewType) || scrapHasTransientState) {
    if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState) {
      if (mSkippedScrap == null) {
        mSkippedScrap=new ArrayList<View>();
      }
      mSkippedScrap.add(scrap);
    }
    if (scrapHasTransientState) {
      scrap.dispatchStartTemporaryDetach();
      if (mAdapter != null && mAdapterHasStableIds) {
        if (mTransientStateViewsById == null) {
          mTransientStateViewsById=new LongSparseArray<View>();
        }
        mTransientStateViewsById.put(lp.itemId,scrap);
      }
 else       if (!mDataChanged) {
        if (mTransientStateViews == null) {
          mTransientStateViews=new SparseArray<View>();
        }
        mTransientStateViews.put(position,scrap);
      }
    }
    return;
  }
  scrap.dispatchStartTemporaryDetach();
  if (mViewTypeCount == 1) {
    mCurrentScrap.add(scrap);
  }
 else {
    mScrapViews[viewType].add(scrap);
  }
  scrap.setAccessibilityDelegate(null);
  if (mRecyclerListener != null) {
    mRecyclerListener.onMovedToScrapHeap(scrap);
  }
}"
2666,"private void setErrorIcon(Drawable icon){
  Drawables dr=mTextView.mDrawables;
  if (dr == null) {
    mTextView.mDrawables=dr=new Drawables();
  }
  dr.setErrorDrawable(icon,mTextView);
  mTextView.resetResolvedDrawables();
  mTextView.invalidate();
  mTextView.requestLayout();
}","private void setErrorIcon(Drawable icon){
  Drawables dr=mTextView.mDrawables;
  if (dr == null) {
    mTextView.mDrawables=dr=new Drawables(mTextView.getContext());
  }
  dr.setErrorDrawable(icon,mTextView);
  mTextView.resetResolvedDrawables();
  mTextView.invalidate();
  mTextView.requestLayout();
}"
2667,"/** 
 * Sets the size of the padding between the compound drawables and the text.
 * @attr ref android.R.styleable#TextView_drawablePadding
 */
@android.view.RemotableViewMethod public void setCompoundDrawablePadding(int pad){
  Drawables dr=mDrawables;
  if (pad == 0) {
    if (dr != null) {
      dr.mDrawablePadding=pad;
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    dr.mDrawablePadding=pad;
  }
  invalidate();
  requestLayout();
}","/** 
 * Sets the size of the padding between the compound drawables and the text.
 * @attr ref android.R.styleable#TextView_drawablePadding
 */
@android.view.RemotableViewMethod public void setCompoundDrawablePadding(int pad){
  Drawables dr=mDrawables;
  if (pad == 0) {
    if (dr != null) {
      dr.mDrawablePadding=pad;
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    dr.mDrawablePadding=pad;
  }
  invalidate();
  requestLayout();
}"
2668,"/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelative(Drawable start,Drawable top,Drawable end,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=start != null || top != null || end != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableStart != null)         dr.mDrawableStart.setCallback(null);
        dr.mDrawableStart=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableEnd != null)         dr.mDrawableEnd.setCallback(null);
        dr.mDrawableEnd=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
        dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
      dr.mDrawableStart.setCallback(null);
    }
    dr.mDrawableStart=start;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
      dr.mDrawableEnd.setCallback(null);
    }
    dr.mDrawableEnd=end;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (start != null) {
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  resolveDrawables();
  invalidate();
  requestLayout();
}","/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelative(Drawable start,Drawable top,Drawable end,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=start != null || top != null || end != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableStart != null)         dr.mDrawableStart.setCallback(null);
        dr.mDrawableStart=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableEnd != null)         dr.mDrawableEnd.setCallback(null);
        dr.mDrawableEnd=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
        dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
      dr.mDrawableStart.setCallback(null);
    }
    dr.mDrawableStart=start;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
      dr.mDrawableEnd.setCallback(null);
    }
    dr.mDrawableEnd=end;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (start != null) {
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  resetResolvedDrawables();
  resolveDrawables();
  invalidate();
  requestLayout();
}"
2669,"/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there. The Drawables' bounds will be set to their intrinsic bounds.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelativeWithIntrinsicBounds(Drawable start,Drawable top,Drawable end,Drawable bottom){
  resetResolvedDrawables();
  if (start != null) {
    start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
  }
  if (end != null) {
    end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
  }
  if (top != null) {
    top.setBounds(0,0,top.getIntrinsicWidth(),top.getIntrinsicHeight());
  }
  if (bottom != null) {
    bottom.setBounds(0,0,bottom.getIntrinsicWidth(),bottom.getIntrinsicHeight());
  }
  setCompoundDrawablesRelative(start,top,end,bottom);
}","/** 
 * Sets the Drawables (if any) to appear to the start of, above, to the end of, and below the text.  Use null if you do not want a Drawable there. The Drawables' bounds will be set to their intrinsic bounds.
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawablesRelativeWithIntrinsicBounds(Drawable start,Drawable top,Drawable end,Drawable bottom){
  if (start != null) {
    start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
  }
  if (end != null) {
    end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
  }
  if (top != null) {
    top.setBounds(0,0,top.getIntrinsicWidth(),top.getIntrinsicHeight());
  }
  if (bottom != null) {
    bottom.setBounds(0,0,bottom.getIntrinsicWidth(),bottom.getIntrinsicHeight());
  }
  setCompoundDrawablesRelative(start,top,end,bottom);
}"
2670,"public void resolveWithLayoutDirection(int layoutDirection){
switch (layoutDirection) {
case LAYOUT_DIRECTION_RTL:
    if (mDrawableStart != null) {
      mDrawableRight=mDrawableStart;
      mDrawableSizeRight=mDrawableSizeStart;
      mDrawableHeightRight=mDrawableHeightStart;
    }
  if (mDrawableEnd != null) {
    mDrawableLeft=mDrawableEnd;
    mDrawableSizeLeft=mDrawableSizeEnd;
    mDrawableHeightLeft=mDrawableHeightEnd;
  }
break;
case LAYOUT_DIRECTION_LTR:
default :
if (mDrawableStart != null) {
mDrawableLeft=mDrawableStart;
mDrawableSizeLeft=mDrawableSizeStart;
mDrawableHeightLeft=mDrawableHeightStart;
}
if (mDrawableEnd != null) {
mDrawableRight=mDrawableEnd;
mDrawableSizeRight=mDrawableSizeEnd;
mDrawableHeightRight=mDrawableHeightEnd;
}
break;
}
applyErrorDrawableIfNeeded(layoutDirection);
updateDrawablesLayoutDirection(layoutDirection);
}","public void resolveWithLayoutDirection(int layoutDirection){
  mDrawableLeft=mDrawableLeftInitial;
  mDrawableRight=mDrawableRightInitial;
  if (mIsRtlCompatibilityMode) {
    if (mDrawableStart != null && mDrawableLeft == null) {
      mDrawableLeft=mDrawableStart;
      mDrawableSizeLeft=mDrawableSizeStart;
      mDrawableHeightLeft=mDrawableHeightStart;
    }
    if (mDrawableEnd != null && mDrawableRight == null) {
      mDrawableRight=mDrawableEnd;
      mDrawableSizeRight=mDrawableSizeEnd;
      mDrawableHeightRight=mDrawableHeightEnd;
    }
  }
 else {
switch (layoutDirection) {
case LAYOUT_DIRECTION_RTL:
      if (mOverride) {
        mDrawableRight=mDrawableStart;
        mDrawableSizeRight=mDrawableSizeStart;
        mDrawableHeightRight=mDrawableHeightStart;
      }
    if (mOverride) {
      mDrawableLeft=mDrawableEnd;
      mDrawableSizeLeft=mDrawableSizeEnd;
      mDrawableHeightLeft=mDrawableHeightEnd;
    }
  break;
case LAYOUT_DIRECTION_LTR:
default :
if (mOverride) {
  mDrawableLeft=mDrawableStart;
  mDrawableSizeLeft=mDrawableSizeStart;
  mDrawableHeightLeft=mDrawableHeightStart;
}
if (mOverride) {
mDrawableRight=mDrawableEnd;
mDrawableSizeRight=mDrawableSizeEnd;
mDrawableHeightRight=mDrawableHeightEnd;
}
break;
}
}
applyErrorDrawableIfNeeded(layoutDirection);
updateDrawablesLayoutDirection(layoutDirection);
}"
2671,"/** 
 * Sets the Drawables (if any) to appear to the left of, above, to the right of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableLeft
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableRight
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawables(Drawable left,Drawable top,Drawable right,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=left != null || top != null || right != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableLeft != null)         dr.mDrawableLeft.setCallback(null);
        dr.mDrawableLeft=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableRight != null)         dr.mDrawableRight.setCallback(null);
        dr.mDrawableRight=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
        dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    if (dr.mDrawableLeft != left && dr.mDrawableLeft != null) {
      dr.mDrawableLeft.setCallback(null);
    }
    dr.mDrawableLeft=left;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableRight != right && dr.mDrawableRight != null) {
      dr.mDrawableRight.setCallback(null);
    }
    dr.mDrawableRight=right;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (left != null) {
      left.setState(state);
      left.copyBounds(compoundRect);
      left.setCallback(this);
      dr.mDrawableSizeLeft=compoundRect.width();
      dr.mDrawableHeightLeft=compoundRect.height();
    }
 else {
      dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
    }
    if (right != null) {
      right.setState(state);
      right.copyBounds(compoundRect);
      right.setCallback(this);
      dr.mDrawableSizeRight=compoundRect.width();
      dr.mDrawableHeightRight=compoundRect.height();
    }
 else {
      dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  invalidate();
  requestLayout();
}","/** 
 * Sets the Drawables (if any) to appear to the left of, above, to the right of, and below the text.  Use null if you do not want a Drawable there.  The Drawables must already have had  {@link Drawable#setBounds} called.
 * @attr ref android.R.styleable#TextView_drawableLeft
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableRight
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
public void setCompoundDrawables(Drawable left,Drawable top,Drawable right,Drawable bottom){
  Drawables dr=mDrawables;
  final boolean drawables=left != null || top != null || right != null || bottom != null;
  if (!drawables) {
    if (dr != null) {
      if (dr.mDrawablePadding == 0) {
        mDrawables=null;
      }
 else {
        if (dr.mDrawableLeft != null)         dr.mDrawableLeft.setCallback(null);
        dr.mDrawableLeft=null;
        if (dr.mDrawableTop != null)         dr.mDrawableTop.setCallback(null);
        dr.mDrawableTop=null;
        if (dr.mDrawableRight != null)         dr.mDrawableRight.setCallback(null);
        dr.mDrawableRight=null;
        if (dr.mDrawableBottom != null)         dr.mDrawableBottom.setCallback(null);
        dr.mDrawableBottom=null;
        dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
        dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
        dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
        dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
      }
    }
  }
 else {
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=false;
    if (dr.mDrawableLeft != left && dr.mDrawableLeft != null) {
      dr.mDrawableLeft.setCallback(null);
    }
    dr.mDrawableLeft=left;
    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
      dr.mDrawableTop.setCallback(null);
    }
    dr.mDrawableTop=top;
    if (dr.mDrawableRight != right && dr.mDrawableRight != null) {
      dr.mDrawableRight.setCallback(null);
    }
    dr.mDrawableRight=right;
    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
      dr.mDrawableBottom.setCallback(null);
    }
    dr.mDrawableBottom=bottom;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state;
    state=getDrawableState();
    if (left != null) {
      left.setState(state);
      left.copyBounds(compoundRect);
      left.setCallback(this);
      dr.mDrawableSizeLeft=compoundRect.width();
      dr.mDrawableHeightLeft=compoundRect.height();
    }
 else {
      dr.mDrawableSizeLeft=dr.mDrawableHeightLeft=0;
    }
    if (right != null) {
      right.setState(state);
      right.copyBounds(compoundRect);
      right.setCallback(this);
      dr.mDrawableSizeRight=compoundRect.width();
      dr.mDrawableHeightRight=compoundRect.height();
    }
 else {
      dr.mDrawableSizeRight=dr.mDrawableHeightRight=0;
    }
    if (top != null) {
      top.setState(state);
      top.copyBounds(compoundRect);
      top.setCallback(this);
      dr.mDrawableSizeTop=compoundRect.height();
      dr.mDrawableWidthTop=compoundRect.width();
    }
 else {
      dr.mDrawableSizeTop=dr.mDrawableWidthTop=0;
    }
    if (bottom != null) {
      bottom.setState(state);
      bottom.copyBounds(compoundRect);
      bottom.setCallback(this);
      dr.mDrawableSizeBottom=compoundRect.height();
      dr.mDrawableWidthBottom=compoundRect.width();
    }
 else {
      dr.mDrawableSizeBottom=dr.mDrawableWidthBottom=0;
    }
  }
  if (dr != null) {
    dr.mDrawableLeftInitial=left;
    dr.mDrawableRightInitial=right;
  }
  invalidate();
  requestLayout();
}"
2672,"private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables();
    }
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
  }
}","private void setRelativeDrawablesIfNeeded(Drawable start,Drawable end){
  boolean hasRelativeDrawables=(start != null) || (end != null);
  if (hasRelativeDrawables) {
    Drawables dr=mDrawables;
    if (dr == null) {
      mDrawables=dr=new Drawables(getContext());
    }
    mDrawables.mOverride=true;
    final Rect compoundRect=dr.mCompoundRect;
    int[] state=getDrawableState();
    if (start != null) {
      start.setBounds(0,0,start.getIntrinsicWidth(),start.getIntrinsicHeight());
      start.setState(state);
      start.copyBounds(compoundRect);
      start.setCallback(this);
      dr.mDrawableStart=start;
      dr.mDrawableSizeStart=compoundRect.width();
      dr.mDrawableHeightStart=compoundRect.height();
    }
 else {
      dr.mDrawableSizeStart=dr.mDrawableHeightStart=0;
    }
    if (end != null) {
      end.setBounds(0,0,end.getIntrinsicWidth(),end.getIntrinsicHeight());
      end.setState(state);
      end.copyBounds(compoundRect);
      end.setCallback(this);
      dr.mDrawableEnd=end;
      dr.mDrawableSizeEnd=compoundRect.width();
      dr.mDrawableHeightEnd=compoundRect.height();
    }
 else {
      dr.mDrawableSizeEnd=dr.mDrawableHeightEnd=0;
    }
  }
}"
2673,"/** 
 * Put a view into the ScrapViews list. These views are unordered.
 * @param scrap The view to add
 */
void addScrapView(View scrap,int position){
  AbsListView.LayoutParams lp=(AbsListView.LayoutParams)scrap.getLayoutParams();
  if (lp == null) {
    return;
  }
  lp.scrappedFromPosition=position;
  int viewType=lp.viewType;
  final boolean scrapHasTransientState=scrap.hasTransientState();
  if (!shouldRecycleViewType(viewType) || scrapHasTransientState) {
    if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState) {
      if (mSkippedScrap == null) {
        mSkippedScrap=new ArrayList<View>();
      }
      mSkippedScrap.add(scrap);
    }
    if (scrapHasTransientState) {
      scrap.dispatchStartTemporaryDetach();
      if (mAdapter != null && mAdapterHasStableIds) {
        if (mTransientStateViewsById == null) {
          mTransientStateViewsById=new LongSparseArray<View>();
        }
        mTransientStateViewsById.put(lp.itemId,scrap);
      }
 else {
        if (mTransientStateViews == null) {
          mTransientStateViews=new SparseArray<View>();
        }
        mTransientStateViews.put(position,scrap);
      }
    }
    return;
  }
  scrap.dispatchStartTemporaryDetach();
  if (mViewTypeCount == 1) {
    mCurrentScrap.add(scrap);
  }
 else {
    mScrapViews[viewType].add(scrap);
  }
  scrap.setAccessibilityDelegate(null);
  if (mRecyclerListener != null) {
    mRecyclerListener.onMovedToScrapHeap(scrap);
  }
}","/** 
 * Put a view into the ScrapViews list. These views are unordered.
 * @param scrap The view to add
 */
void addScrapView(View scrap,int position){
  AbsListView.LayoutParams lp=(AbsListView.LayoutParams)scrap.getLayoutParams();
  if (lp == null) {
    return;
  }
  lp.scrappedFromPosition=position;
  int viewType=lp.viewType;
  final boolean scrapHasTransientState=scrap.hasTransientState();
  if (!shouldRecycleViewType(viewType) || scrapHasTransientState) {
    if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState) {
      if (mSkippedScrap == null) {
        mSkippedScrap=new ArrayList<View>();
      }
      mSkippedScrap.add(scrap);
    }
    if (scrapHasTransientState) {
      scrap.dispatchStartTemporaryDetach();
      if (mAdapter != null && mAdapterHasStableIds) {
        if (mTransientStateViewsById == null) {
          mTransientStateViewsById=new LongSparseArray<View>();
        }
        mTransientStateViewsById.put(lp.itemId,scrap);
      }
 else       if (!mDataChanged) {
        if (mTransientStateViews == null) {
          mTransientStateViews=new SparseArray<View>();
        }
        mTransientStateViews.put(position,scrap);
      }
    }
    return;
  }
  scrap.dispatchStartTemporaryDetach();
  if (mViewTypeCount == 1) {
    mCurrentScrap.add(scrap);
  }
 else {
    mScrapViews[viewType].add(scrap);
  }
  scrap.setAccessibilityDelegate(null);
  if (mRecyclerListener != null) {
    mRecyclerListener.onMovedToScrapHeap(scrap);
  }
}"
2674,"public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}","public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          if (foregroundNoti.icon == 0) {
            throw new RuntimeException(""String_Node_Str"");
          }
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}"
2675,"public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}","public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          if (foregroundNoti.icon == 0) {
            throw new RuntimeException(""String_Node_Str"");
          }
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}"
2676,"public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}","public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          if (foregroundNoti.icon == 0) {
            throw new RuntimeException(""String_Node_Str"");
          }
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}"
2677,"public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}","public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerService nm=(NotificationManagerService)NotificationManager.getService();
        if (nm == null) {
          return;
        }
        try {
          if (foregroundNoti.icon == 0) {
            throw new RuntimeException(""String_Node_Str"");
          }
          int[] outId=new int[1];
          nm.enqueueNotificationInternal(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,true);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}"
2678,"/** 
 * Return true if the specified rectangle, after being transformed by the current matrix, would lie completely outside of the current clip. Call this to check if an area you intend to draw into is clipped out (and therefore you can skip making the draw calls).
 * @param left        The left side of the rectangle to compare with thecurrent clip
 * @param top         The top of the rectangle to compare with the currentclip
 * @param right       The right side of the rectangle to compare with thecurrent clip
 * @param bottom      The bottom of the rectangle to compare with thecurrent clip
 * @param type        true if the rect should be considered antialiased,since that means it may affect a larger area (more pixels) than non-antialiased.
 * @return            true if the rect (transformed by the canvas' matrix)does not intersect with the canvas' clip
 */
public boolean quickReject(float left,float top,float right,float bottom,EdgeType type){
  return native_quickReject(mNativeCanvas,left,top,right,bottom);
}","/** 
 * Return true if the specified rectangle, after being transformed by the current matrix, would lie completely outside of the current clip. Call this to check if an area you intend to draw into is clipped out (and therefore you can skip making the draw calls).
 * @param left        The left side of the rectangle to compare with thecurrent clip
 * @param top         The top of the rectangle to compare with the currentclip
 * @param right       The right side of the rectangle to compare with thecurrent clip
 * @param bottom      The bottom of the rectangle to compare with thecurrent clip
 * @param type        {@link Canvas.EdgeType#AA} if the path should be considered antialiased,since that means it may affect a larger area (more pixels) than non-antialiased ( {@link Canvas.EdgeType#BW}).
 * @return            true if the rect (transformed by the canvas' matrix)does not intersect with the canvas' clip
 */
public boolean quickReject(float left,float top,float right,float bottom,EdgeType type){
  return native_quickReject(mNativeCanvas,left,top,right,bottom);
}"
2679,"/** 
 * Return true if the specified rectangle, after being transformed by the current matrix, would lie completely outside of the current clip. Call this to check if an area you intend to draw into is clipped out (and therefore you can skip making the draw calls).
 * @param left        The left side of the rectangle to compare with thecurrent clip
 * @param top         The top of the rectangle to compare with the currentclip
 * @param right       The right side of the rectangle to compare with thecurrent clip
 * @param bottom      The bottom of the rectangle to compare with thecurrent clip
 * @param type        true if the rect should be considered antialiased,since that means it may affect a larger area (more pixels) than non-antialiased.
 * @return            true if the rect (transformed by the canvas' matrix)does not intersect with the canvas' clip
 */
public boolean quickReject(float left,float top,float right,float bottom,EdgeType type){
  return native_quickReject(mNativeCanvas,left,top,right,bottom);
}","/** 
 * Return true if the specified rectangle, after being transformed by the current matrix, would lie completely outside of the current clip. Call this to check if an area you intend to draw into is clipped out (and therefore you can skip making the draw calls).
 * @param left        The left side of the rectangle to compare with thecurrent clip
 * @param top         The top of the rectangle to compare with the currentclip
 * @param right       The right side of the rectangle to compare with thecurrent clip
 * @param bottom      The bottom of the rectangle to compare with thecurrent clip
 * @param type        {@link Canvas.EdgeType#AA} if the path should be considered antialiased,since that means it may affect a larger area (more pixels) than non-antialiased ( {@link Canvas.EdgeType#BW}).
 * @return            true if the rect (transformed by the canvas' matrix)does not intersect with the canvas' clip
 */
public boolean quickReject(float left,float top,float right,float bottom,EdgeType type){
  return native_quickReject(mNativeCanvas,left,top,right,bottom);
}"
2680,"/** 
 * Return true if the specified rectangle, after being transformed by the current matrix, would lie completely outside of the current clip. Call this to check if an area you intend to draw into is clipped out (and therefore you can skip making the draw calls).
 * @param left        The left side of the rectangle to compare with thecurrent clip
 * @param top         The top of the rectangle to compare with the currentclip
 * @param right       The right side of the rectangle to compare with thecurrent clip
 * @param bottom      The bottom of the rectangle to compare with thecurrent clip
 * @param type        true if the rect should be considered antialiased,since that means it may affect a larger area (more pixels) than non-antialiased.
 * @return            true if the rect (transformed by the canvas' matrix)does not intersect with the canvas' clip
 */
public boolean quickReject(float left,float top,float right,float bottom,EdgeType type){
  return native_quickReject(mNativeCanvas,left,top,right,bottom);
}","/** 
 * Return true if the specified rectangle, after being transformed by the current matrix, would lie completely outside of the current clip. Call this to check if an area you intend to draw into is clipped out (and therefore you can skip making the draw calls).
 * @param left        The left side of the rectangle to compare with thecurrent clip
 * @param top         The top of the rectangle to compare with the currentclip
 * @param right       The right side of the rectangle to compare with thecurrent clip
 * @param bottom      The bottom of the rectangle to compare with thecurrent clip
 * @param type        {@link Canvas.EdgeType#AA} if the path should be considered antialiased,since that means it may affect a larger area (more pixels) than non-antialiased ( {@link Canvas.EdgeType#BW}).
 * @return            true if the rect (transformed by the canvas' matrix)does not intersect with the canvas' clip
 */
public boolean quickReject(float left,float top,float right,float bottom,EdgeType type){
  return native_quickReject(mNativeCanvas,left,top,right,bottom);
}"
2681,"/** 
 * Return true if the specified rectangle, after being transformed by the current matrix, would lie completely outside of the current clip. Call this to check if an area you intend to draw into is clipped out (and therefore you can skip making the draw calls).
 * @param left        The left side of the rectangle to compare with thecurrent clip
 * @param top         The top of the rectangle to compare with the currentclip
 * @param right       The right side of the rectangle to compare with thecurrent clip
 * @param bottom      The bottom of the rectangle to compare with thecurrent clip
 * @param type        true if the rect should be considered antialiased,since that means it may affect a larger area (more pixels) than non-antialiased.
 * @return            true if the rect (transformed by the canvas' matrix)does not intersect with the canvas' clip
 */
public boolean quickReject(float left,float top,float right,float bottom,EdgeType type){
  return native_quickReject(mNativeCanvas,left,top,right,bottom);
}","/** 
 * Return true if the specified rectangle, after being transformed by the current matrix, would lie completely outside of the current clip. Call this to check if an area you intend to draw into is clipped out (and therefore you can skip making the draw calls).
 * @param left        The left side of the rectangle to compare with thecurrent clip
 * @param top         The top of the rectangle to compare with the currentclip
 * @param right       The right side of the rectangle to compare with thecurrent clip
 * @param bottom      The bottom of the rectangle to compare with thecurrent clip
 * @param type        {@link Canvas.EdgeType#AA} if the path should be considered antialiased,since that means it may affect a larger area (more pixels) than non-antialiased ( {@link Canvas.EdgeType#BW}).
 * @return            true if the rect (transformed by the canvas' matrix)does not intersect with the canvas' clip
 */
public boolean quickReject(float left,float top,float right,float bottom,EdgeType type){
  return native_quickReject(mNativeCanvas,left,top,right,bottom);
}"
2682,"/** 
 * Called by   {@link android.view.View#requestLayout()} if the view hierarchy is currentlyundergoing a layout pass. requestLayout() should not generally be called during layout, unless the container hierarchy knows what it is doing (i.e., it is fine as long as all children in that container hierarchy are measured and laid out at the end of the layout pass for that container). If requestLayout() is called anyway, we handle it correctly by registering all requesters during a frame as it proceeds. At the end of the frame, we check all of those views to see if any still have pending layout requests, which indicates that they were not correctly handled by their container hierarchy. If that is the case, we clear all such flags in the tree, to remove the buggy flag state that leads to blank containers, and force a second request/measure/layout pass in this frame. If more requestLayout() calls are received during that second layout pass, we post those requests to the next frame to avoid possible infinite loops. <p>The return value from this method indicates whether the request should proceed (if it is a request during the first layout pass) or should be skipped and posted to the next frame (if it is a request during the second layout pass).</p>
 * @param view the view that requested the layout.
 * @return true if request should proceed, false otherwise.
 */
boolean requestLayoutDuringLayout(final View view){
  if (view.mParent == null || view.mAttachInfo == null) {
    return true;
  }
  if (!mHandlingLayoutInLayoutRequest) {
    if (!mLayoutRequesters.contains(view)) {
      mLayoutRequesters.add(view);
    }
    return true;
  }
 else {
    Log.w(""String_Node_Str"",""String_Node_Str"" + view + ""String_Node_Str""+ ""String_Node_Str"");
    view.post(new Runnable(){
      @Override public void run(){
        view.requestLayout();
      }
    }
);
    return false;
  }
}","/** 
 * Called by   {@link android.view.View#requestLayout()} if the view hierarchy is currentlyundergoing a layout pass. requestLayout() should not generally be called during layout, unless the container hierarchy knows what it is doing (i.e., it is fine as long as all children in that container hierarchy are measured and laid out at the end of the layout pass for that container). If requestLayout() is called anyway, we handle it correctly by registering all requesters during a frame as it proceeds. At the end of the frame, we check all of those views to see if any still have pending layout requests, which indicates that they were not correctly handled by their container hierarchy. If that is the case, we clear all such flags in the tree, to remove the buggy flag state that leads to blank containers, and force a second request/measure/layout pass in this frame. If more requestLayout() calls are received during that second layout pass, we post those requests to the next frame to avoid possible infinite loops. <p>The return value from this method indicates whether the request should proceed (if it is a request during the first layout pass) or should be skipped and posted to the next frame (if it is a request during the second layout pass).</p>
 * @param view the view that requested the layout.
 * @return true if request should proceed, false otherwise.
 */
boolean requestLayoutDuringLayout(final View view){
  if (view.mParent == null || view.mAttachInfo == null) {
    return true;
  }
  if (!mLayoutRequesters.contains(view)) {
    mLayoutRequesters.add(view);
  }
  if (!mHandlingLayoutInLayoutRequest) {
    return true;
  }
 else {
    return false;
  }
}"
2683,"private void performLayout(WindowManager.LayoutParams lp,int desiredWindowWidth,int desiredWindowHeight){
  mLayoutRequested=false;
  mScrollMayChange=true;
  mInLayout=true;
  final View host=mView;
  if (DEBUG_ORIENTATION || DEBUG_LAYOUT) {
    Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str"");
  }
  Trace.traceBegin(Trace.TRACE_TAG_VIEW,""String_Node_Str"");
  try {
    host.layout(0,0,host.getMeasuredWidth(),host.getMeasuredHeight());
    mInLayout=false;
    int numViewsRequestingLayout=mLayoutRequesters.size();
    if (numViewsRequestingLayout > 0) {
      ArrayList<View> mValidLayoutRequesters=null;
      for (int i=0; i < numViewsRequestingLayout; ++i) {
        View view=mLayoutRequesters.get(i);
        if ((view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) == View.PFLAG_FORCE_LAYOUT) {
          while (view != null && view.mAttachInfo != null && view.mParent != null && (view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) != 0) {
            if ((view.mViewFlags & View.VISIBILITY_MASK) != View.GONE) {
              Log.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + view);
              if (mValidLayoutRequesters == null) {
                mValidLayoutRequesters=new ArrayList<View>();
              }
              mValidLayoutRequesters.add(view);
              break;
            }
            if (view.mParent instanceof View) {
              view=(View)view.mParent;
            }
 else {
              view=null;
            }
          }
        }
      }
      if (mValidLayoutRequesters != null) {
        for (int i=0; i < numViewsRequestingLayout; ++i) {
          View view=mLayoutRequesters.get(i);
          while (view != null && (view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) != 0) {
            view.mPrivateFlags&=~View.PFLAG_FORCE_LAYOUT;
            if (view.mParent instanceof View) {
              view=(View)view.mParent;
            }
 else {
              view=null;
            }
          }
        }
        mHandlingLayoutInLayoutRequest=true;
        int numValidRequests=mValidLayoutRequesters.size();
        for (int i=0; i < numValidRequests; ++i) {
          mValidLayoutRequesters.get(i).requestLayout();
        }
        measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
        mInLayout=true;
        host.layout(0,0,host.getMeasuredWidth(),host.getMeasuredHeight());
        mHandlingLayoutInLayoutRequest=false;
      }
      mLayoutRequesters.clear();
    }
  }
  finally {
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
  }
  mInLayout=false;
}","private void performLayout(WindowManager.LayoutParams lp,int desiredWindowWidth,int desiredWindowHeight){
  mLayoutRequested=false;
  mScrollMayChange=true;
  mInLayout=true;
  final View host=mView;
  if (DEBUG_ORIENTATION || DEBUG_LAYOUT) {
    Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str"");
  }
  Trace.traceBegin(Trace.TRACE_TAG_VIEW,""String_Node_Str"");
  try {
    host.layout(0,0,host.getMeasuredWidth(),host.getMeasuredHeight());
    mInLayout=false;
    int numViewsRequestingLayout=mLayoutRequesters.size();
    if (numViewsRequestingLayout > 0) {
      ArrayList<View> validLayoutRequesters=getValidLayoutRequesters(mLayoutRequesters,false);
      if (validLayoutRequesters != null) {
        mHandlingLayoutInLayoutRequest=true;
        int numValidRequests=validLayoutRequesters.size();
        for (int i=0; i < numValidRequests; ++i) {
          final View view=validLayoutRequesters.get(i);
          Log.w(""String_Node_Str"",""String_Node_Str"" + view + ""String_Node_Str"");
          view.requestLayout();
        }
        measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
        mInLayout=true;
        host.layout(0,0,host.getMeasuredWidth(),host.getMeasuredHeight());
        mHandlingLayoutInLayoutRequest=false;
        validLayoutRequesters=getValidLayoutRequesters(mLayoutRequesters,true);
        if (validLayoutRequesters != null) {
          final ArrayList<View> finalRequesters=validLayoutRequesters;
          getRunQueue().post(new Runnable(){
            @Override public void run(){
              int numValidRequests=finalRequesters.size();
              for (int i=0; i < numValidRequests; ++i) {
                final View view=finalRequesters.get(i);
                Log.w(""String_Node_Str"",""String_Node_Str"" + view + ""String_Node_Str"");
                view.requestLayout();
              }
            }
          }
);
        }
      }
    }
  }
  finally {
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
  }
  mInLayout=false;
}"
2684,"/** 
 * Called by   {@link android.view.View#requestLayout()} if the view hierarchy is currentlyundergoing a layout pass. requestLayout() should not generally be called during layout, unless the container hierarchy knows what it is doing (i.e., it is fine as long as all children in that container hierarchy are measured and laid out at the end of the layout pass for that container). If requestLayout() is called anyway, we handle it correctly by registering all requesters during a frame as it proceeds. At the end of the frame, we check all of those views to see if any still have pending layout requests, which indicates that they were not correctly handled by their container hierarchy. If that is the case, we clear all such flags in the tree, to remove the buggy flag state that leads to blank containers, and force a second request/measure/layout pass in this frame. If more requestLayout() calls are received during that second layout pass, we post those requests to the next frame to avoid possible infinite loops. <p>The return value from this method indicates whether the request should proceed (if it is a request during the first layout pass) or should be skipped and posted to the next frame (if it is a request during the second layout pass).</p>
 * @param view the view that requested the layout.
 * @return true if request should proceed, false otherwise.
 */
boolean requestLayoutDuringLayout(final View view){
  if (view.mParent == null || view.mAttachInfo == null) {
    return true;
  }
  if (!mHandlingLayoutInLayoutRequest) {
    if (!mLayoutRequesters.contains(view)) {
      mLayoutRequesters.add(view);
    }
    return true;
  }
 else {
    Log.w(""String_Node_Str"",""String_Node_Str"" + view + ""String_Node_Str""+ ""String_Node_Str"");
    view.post(new Runnable(){
      @Override public void run(){
        view.requestLayout();
      }
    }
);
    return false;
  }
}","/** 
 * Called by   {@link android.view.View#requestLayout()} if the view hierarchy is currentlyundergoing a layout pass. requestLayout() should not generally be called during layout, unless the container hierarchy knows what it is doing (i.e., it is fine as long as all children in that container hierarchy are measured and laid out at the end of the layout pass for that container). If requestLayout() is called anyway, we handle it correctly by registering all requesters during a frame as it proceeds. At the end of the frame, we check all of those views to see if any still have pending layout requests, which indicates that they were not correctly handled by their container hierarchy. If that is the case, we clear all such flags in the tree, to remove the buggy flag state that leads to blank containers, and force a second request/measure/layout pass in this frame. If more requestLayout() calls are received during that second layout pass, we post those requests to the next frame to avoid possible infinite loops. <p>The return value from this method indicates whether the request should proceed (if it is a request during the first layout pass) or should be skipped and posted to the next frame (if it is a request during the second layout pass).</p>
 * @param view the view that requested the layout.
 * @return true if request should proceed, false otherwise.
 */
boolean requestLayoutDuringLayout(final View view){
  if (view.mParent == null || view.mAttachInfo == null) {
    return true;
  }
  if (!mLayoutRequesters.contains(view)) {
    mLayoutRequesters.add(view);
  }
  if (!mHandlingLayoutInLayoutRequest) {
    return true;
  }
 else {
    return false;
  }
}"
2685,"private void performLayout(WindowManager.LayoutParams lp,int desiredWindowWidth,int desiredWindowHeight){
  mLayoutRequested=false;
  mScrollMayChange=true;
  mInLayout=true;
  final View host=mView;
  if (DEBUG_ORIENTATION || DEBUG_LAYOUT) {
    Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str"");
  }
  Trace.traceBegin(Trace.TRACE_TAG_VIEW,""String_Node_Str"");
  try {
    host.layout(0,0,host.getMeasuredWidth(),host.getMeasuredHeight());
    mInLayout=false;
    int numViewsRequestingLayout=mLayoutRequesters.size();
    if (numViewsRequestingLayout > 0) {
      ArrayList<View> mValidLayoutRequesters=null;
      for (int i=0; i < numViewsRequestingLayout; ++i) {
        View view=mLayoutRequesters.get(i);
        if ((view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) == View.PFLAG_FORCE_LAYOUT) {
          while (view != null && view.mAttachInfo != null && view.mParent != null && (view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) != 0) {
            if ((view.mViewFlags & View.VISIBILITY_MASK) != View.GONE) {
              Log.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + view);
              if (mValidLayoutRequesters == null) {
                mValidLayoutRequesters=new ArrayList<View>();
              }
              mValidLayoutRequesters.add(view);
              break;
            }
            if (view.mParent instanceof View) {
              view=(View)view.mParent;
            }
 else {
              view=null;
            }
          }
        }
      }
      if (mValidLayoutRequesters != null) {
        for (int i=0; i < numViewsRequestingLayout; ++i) {
          View view=mLayoutRequesters.get(i);
          while (view != null && (view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) != 0) {
            view.mPrivateFlags&=~View.PFLAG_FORCE_LAYOUT;
            if (view.mParent instanceof View) {
              view=(View)view.mParent;
            }
 else {
              view=null;
            }
          }
        }
        mHandlingLayoutInLayoutRequest=true;
        int numValidRequests=mValidLayoutRequesters.size();
        for (int i=0; i < numValidRequests; ++i) {
          mValidLayoutRequesters.get(i).requestLayout();
        }
        measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
        mInLayout=true;
        host.layout(0,0,host.getMeasuredWidth(),host.getMeasuredHeight());
        mHandlingLayoutInLayoutRequest=false;
      }
      mLayoutRequesters.clear();
    }
  }
  finally {
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
  }
  mInLayout=false;
}","private void performLayout(WindowManager.LayoutParams lp,int desiredWindowWidth,int desiredWindowHeight){
  mLayoutRequested=false;
  mScrollMayChange=true;
  mInLayout=true;
  final View host=mView;
  if (DEBUG_ORIENTATION || DEBUG_LAYOUT) {
    Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str"");
  }
  Trace.traceBegin(Trace.TRACE_TAG_VIEW,""String_Node_Str"");
  try {
    host.layout(0,0,host.getMeasuredWidth(),host.getMeasuredHeight());
    mInLayout=false;
    int numViewsRequestingLayout=mLayoutRequesters.size();
    if (numViewsRequestingLayout > 0) {
      ArrayList<View> validLayoutRequesters=getValidLayoutRequesters(mLayoutRequesters,false);
      if (validLayoutRequesters != null) {
        mHandlingLayoutInLayoutRequest=true;
        int numValidRequests=validLayoutRequesters.size();
        for (int i=0; i < numValidRequests; ++i) {
          final View view=validLayoutRequesters.get(i);
          Log.w(""String_Node_Str"",""String_Node_Str"" + view + ""String_Node_Str"");
          view.requestLayout();
        }
        measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
        mInLayout=true;
        host.layout(0,0,host.getMeasuredWidth(),host.getMeasuredHeight());
        mHandlingLayoutInLayoutRequest=false;
        validLayoutRequesters=getValidLayoutRequesters(mLayoutRequesters,true);
        if (validLayoutRequesters != null) {
          final ArrayList<View> finalRequesters=validLayoutRequesters;
          getRunQueue().post(new Runnable(){
            @Override public void run(){
              int numValidRequests=finalRequesters.size();
              for (int i=0; i < numValidRequests; ++i) {
                final View view=finalRequesters.get(i);
                Log.w(""String_Node_Str"",""String_Node_Str"" + view + ""String_Node_Str"");
                view.requestLayout();
              }
            }
          }
);
        }
      }
    }
  }
  finally {
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
  }
  mInLayout=false;
}"
2686,"/** 
 * Called by   {@link android.view.View#requestLayout()} if the view hierarchy is currentlyundergoing a layout pass. requestLayout() should not generally be called during layout, unless the container hierarchy knows what it is doing (i.e., it is fine as long as all children in that container hierarchy are measured and laid out at the end of the layout pass for that container). If requestLayout() is called anyway, we handle it correctly by registering all requesters during a frame as it proceeds. At the end of the frame, we check all of those views to see if any still have pending layout requests, which indicates that they were not correctly handled by their container hierarchy. If that is the case, we clear all such flags in the tree, to remove the buggy flag state that leads to blank containers, and force a second request/measure/layout pass in this frame. If more requestLayout() calls are received during that second layout pass, we post those requests to the next frame to avoid possible infinite loops. <p>The return value from this method indicates whether the request should proceed (if it is a request during the first layout pass) or should be skipped and posted to the next frame (if it is a request during the second layout pass).</p>
 * @param view the view that requested the layout.
 * @return true if request should proceed, false otherwise.
 */
boolean requestLayoutDuringLayout(final View view){
  if (view.mParent == null || view.mAttachInfo == null) {
    return true;
  }
  if (!mHandlingLayoutInLayoutRequest) {
    if (!mLayoutRequesters.contains(view)) {
      mLayoutRequesters.add(view);
    }
    return true;
  }
 else {
    Log.w(""String_Node_Str"",""String_Node_Str"" + view + ""String_Node_Str""+ ""String_Node_Str"");
    view.post(new Runnable(){
      @Override public void run(){
        view.requestLayout();
      }
    }
);
    return false;
  }
}","/** 
 * Called by   {@link android.view.View#requestLayout()} if the view hierarchy is currentlyundergoing a layout pass. requestLayout() should not generally be called during layout, unless the container hierarchy knows what it is doing (i.e., it is fine as long as all children in that container hierarchy are measured and laid out at the end of the layout pass for that container). If requestLayout() is called anyway, we handle it correctly by registering all requesters during a frame as it proceeds. At the end of the frame, we check all of those views to see if any still have pending layout requests, which indicates that they were not correctly handled by their container hierarchy. If that is the case, we clear all such flags in the tree, to remove the buggy flag state that leads to blank containers, and force a second request/measure/layout pass in this frame. If more requestLayout() calls are received during that second layout pass, we post those requests to the next frame to avoid possible infinite loops. <p>The return value from this method indicates whether the request should proceed (if it is a request during the first layout pass) or should be skipped and posted to the next frame (if it is a request during the second layout pass).</p>
 * @param view the view that requested the layout.
 * @return true if request should proceed, false otherwise.
 */
boolean requestLayoutDuringLayout(final View view){
  if (view.mParent == null || view.mAttachInfo == null) {
    return true;
  }
  if (!mLayoutRequesters.contains(view)) {
    mLayoutRequesters.add(view);
  }
  if (!mHandlingLayoutInLayoutRequest) {
    return true;
  }
 else {
    return false;
  }
}"
2687,"private void performLayout(WindowManager.LayoutParams lp,int desiredWindowWidth,int desiredWindowHeight){
  mLayoutRequested=false;
  mScrollMayChange=true;
  mInLayout=true;
  final View host=mView;
  if (DEBUG_ORIENTATION || DEBUG_LAYOUT) {
    Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str"");
  }
  Trace.traceBegin(Trace.TRACE_TAG_VIEW,""String_Node_Str"");
  try {
    host.layout(0,0,host.getMeasuredWidth(),host.getMeasuredHeight());
    mInLayout=false;
    int numViewsRequestingLayout=mLayoutRequesters.size();
    if (numViewsRequestingLayout > 0) {
      ArrayList<View> mValidLayoutRequesters=null;
      for (int i=0; i < numViewsRequestingLayout; ++i) {
        View view=mLayoutRequesters.get(i);
        if ((view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) == View.PFLAG_FORCE_LAYOUT) {
          while (view != null && view.mAttachInfo != null && view.mParent != null && (view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) != 0) {
            if ((view.mViewFlags & View.VISIBILITY_MASK) != View.GONE) {
              Log.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + view);
              if (mValidLayoutRequesters == null) {
                mValidLayoutRequesters=new ArrayList<View>();
              }
              mValidLayoutRequesters.add(view);
              break;
            }
            if (view.mParent instanceof View) {
              view=(View)view.mParent;
            }
 else {
              view=null;
            }
          }
        }
      }
      if (mValidLayoutRequesters != null) {
        for (int i=0; i < numViewsRequestingLayout; ++i) {
          View view=mLayoutRequesters.get(i);
          while (view != null && (view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) != 0) {
            view.mPrivateFlags&=~View.PFLAG_FORCE_LAYOUT;
            if (view.mParent instanceof View) {
              view=(View)view.mParent;
            }
 else {
              view=null;
            }
          }
        }
        mHandlingLayoutInLayoutRequest=true;
        int numValidRequests=mValidLayoutRequesters.size();
        for (int i=0; i < numValidRequests; ++i) {
          mValidLayoutRequesters.get(i).requestLayout();
        }
        measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
        mInLayout=true;
        host.layout(0,0,host.getMeasuredWidth(),host.getMeasuredHeight());
        mHandlingLayoutInLayoutRequest=false;
      }
      mLayoutRequesters.clear();
    }
  }
  finally {
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
  }
  mInLayout=false;
}","private void performLayout(WindowManager.LayoutParams lp,int desiredWindowWidth,int desiredWindowHeight){
  mLayoutRequested=false;
  mScrollMayChange=true;
  mInLayout=true;
  final View host=mView;
  if (DEBUG_ORIENTATION || DEBUG_LAYOUT) {
    Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str"");
  }
  Trace.traceBegin(Trace.TRACE_TAG_VIEW,""String_Node_Str"");
  try {
    host.layout(0,0,host.getMeasuredWidth(),host.getMeasuredHeight());
    mInLayout=false;
    int numViewsRequestingLayout=mLayoutRequesters.size();
    if (numViewsRequestingLayout > 0) {
      ArrayList<View> validLayoutRequesters=getValidLayoutRequesters(mLayoutRequesters,false);
      if (validLayoutRequesters != null) {
        mHandlingLayoutInLayoutRequest=true;
        int numValidRequests=validLayoutRequesters.size();
        for (int i=0; i < numValidRequests; ++i) {
          final View view=validLayoutRequesters.get(i);
          Log.w(""String_Node_Str"",""String_Node_Str"" + view + ""String_Node_Str"");
          view.requestLayout();
        }
        measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
        mInLayout=true;
        host.layout(0,0,host.getMeasuredWidth(),host.getMeasuredHeight());
        mHandlingLayoutInLayoutRequest=false;
        validLayoutRequesters=getValidLayoutRequesters(mLayoutRequesters,true);
        if (validLayoutRequesters != null) {
          final ArrayList<View> finalRequesters=validLayoutRequesters;
          getRunQueue().post(new Runnable(){
            @Override public void run(){
              int numValidRequests=finalRequesters.size();
              for (int i=0; i < numValidRequests; ++i) {
                final View view=finalRequesters.get(i);
                Log.w(""String_Node_Str"",""String_Node_Str"" + view + ""String_Node_Str"");
                view.requestLayout();
              }
            }
          }
);
        }
      }
    }
  }
  finally {
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
  }
  mInLayout=false;
}"
2688,"/** 
 * Shows the emergency dialer or returns the user to the existing call.
 */
public void takeEmergencyCallAction(){
  mPowerManager.userActivity(SystemClock.uptimeMillis(),true);
  if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
    mLockPatternUtils.resumeCall();
  }
 else {
    Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    getContext().startActivity(intent);
  }
}","/** 
 * Shows the emergency dialer or returns the user to the existing call.
 */
public void takeEmergencyCallAction(){
  mPowerManager.userActivity(SystemClock.uptimeMillis(),true);
  if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
    mLockPatternUtils.resumeCall();
  }
 else {
    Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    getContext().startActivityAsUser(intent,new UserHandle(mLockPatternUtils.getCurrentUser()));
  }
}"
2689,"/** 
 * Shows the emergency dialer or returns the user to the existing call.
 */
public void takeEmergencyCallAction(){
  mPowerManager.userActivity(SystemClock.uptimeMillis(),true);
  if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
    mLockPatternUtils.resumeCall();
  }
 else {
    Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    getContext().startActivity(intent);
  }
}","/** 
 * Shows the emergency dialer or returns the user to the existing call.
 */
public void takeEmergencyCallAction(){
  mPowerManager.userActivity(SystemClock.uptimeMillis(),true);
  if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
    mLockPatternUtils.resumeCall();
  }
 else {
    Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    getContext().startActivityAsUser(intent,new UserHandle(mLockPatternUtils.getCurrentUser()));
  }
}"
2690,"/** 
 * Shows the emergency dialer or returns the user to the existing call.
 */
public void takeEmergencyCallAction(){
  mPowerManager.userActivity(SystemClock.uptimeMillis(),true);
  if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
    mLockPatternUtils.resumeCall();
  }
 else {
    Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    getContext().startActivity(intent);
  }
}","/** 
 * Shows the emergency dialer or returns the user to the existing call.
 */
public void takeEmergencyCallAction(){
  mPowerManager.userActivity(SystemClock.uptimeMillis(),true);
  if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
    mLockPatternUtils.resumeCall();
  }
 else {
    Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    getContext().startActivityAsUser(intent,new UserHandle(mLockPatternUtils.getCurrentUser()));
  }
}"
2691,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings({""String_Node_Str""}) @Override protected boolean dispatchHoverEvent(MotionEvent event){
  final int action=event.getAction();
  final boolean interceptHover=onInterceptHoverEvent(event);
  event.setAction(action);
  MotionEvent eventNoHistory=event;
  boolean handled=false;
  HoverTarget firstOldHoverTarget=mFirstHoverTarget;
  mFirstHoverTarget=null;
  if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
    final float x=event.getX();
    final float y=event.getY();
    final int childrenCount=mChildrenCount;
    if (childrenCount != 0) {
      final View[] children=mChildren;
      HoverTarget lastHoverTarget=null;
      for (int i=childrenCount - 1; i >= 0; i--) {
        final View child=children[i];
        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x,y,child,null)) {
          continue;
        }
        HoverTarget hoverTarget=firstOldHoverTarget;
        final boolean wasHovered;
        for (HoverTarget predecessor=null; ; ) {
          if (hoverTarget == null) {
            hoverTarget=HoverTarget.obtain(child);
            wasHovered=false;
            break;
          }
          if (hoverTarget.child == child) {
            if (predecessor != null) {
              predecessor.next=hoverTarget.next;
            }
 else {
              firstOldHoverTarget=hoverTarget.next;
            }
            hoverTarget.next=null;
            wasHovered=true;
            break;
          }
          predecessor=hoverTarget;
          hoverTarget=hoverTarget.next;
        }
        if (lastHoverTarget != null) {
          lastHoverTarget.next=hoverTarget;
        }
 else {
          lastHoverTarget=hoverTarget;
          mFirstHoverTarget=hoverTarget;
        }
        if (action == MotionEvent.ACTION_HOVER_ENTER) {
          if (!wasHovered) {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
 else         if (action == MotionEvent.ACTION_HOVER_MOVE) {
          if (!wasHovered) {
            eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
            eventNoHistory.setAction(action);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
          }
 else {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
        if (handled) {
          break;
        }
      }
    }
  }
  while (firstOldHoverTarget != null) {
    final View child=firstOldHoverTarget.child;
    if (action == MotionEvent.ACTION_HOVER_EXIT) {
      handled|=dispatchTransformedGenericPointerEvent(event,child);
    }
 else {
      if (action == MotionEvent.ACTION_HOVER_MOVE) {
        dispatchTransformedGenericPointerEvent(event,child);
      }
      eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
      eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
      dispatchTransformedGenericPointerEvent(eventNoHistory,child);
      eventNoHistory.setAction(action);
    }
    final HoverTarget nextOldHoverTarget=firstOldHoverTarget.next;
    firstOldHoverTarget.recycle();
    firstOldHoverTarget=nextOldHoverTarget;
  }
  boolean newHoveredSelf=!handled;
  if (newHoveredSelf == mHoveredSelf) {
    if (newHoveredSelf) {
      handled|=super.dispatchHoverEvent(event);
    }
  }
 else {
    if (mHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_EXIT) {
        handled|=super.dispatchHoverEvent(event);
      }
 else {
        if (action == MotionEvent.ACTION_HOVER_MOVE) {
          super.dispatchHoverEvent(event);
        }
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
        super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
      }
      mHoveredSelf=false;
    }
    if (newHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_ENTER) {
        handled|=super.dispatchHoverEvent(event);
        mHoveredSelf=true;
      }
 else       if (action == MotionEvent.ACTION_HOVER_MOVE) {
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        mHoveredSelf=true;
      }
    }
  }
  if (eventNoHistory != event) {
    eventNoHistory.recycle();
  }
  return handled;
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings({""String_Node_Str""}) @Override protected boolean dispatchHoverEvent(MotionEvent event){
  final int action=event.getAction();
  final boolean interceptHover=onInterceptHoverEvent(event);
  event.setAction(action);
  MotionEvent eventNoHistory=event;
  boolean handled=false;
  HoverTarget firstOldHoverTarget=mFirstHoverTarget;
  mFirstHoverTarget=null;
  if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
    final float x=event.getX();
    final float y=event.getY();
    final int childrenCount=mChildrenCount;
    if (childrenCount != 0) {
      final View[] children=mChildren;
      HoverTarget lastHoverTarget=null;
      for (int i=childrenCount - 1; i >= 0; i--) {
        final View child=children[i];
        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x,y,child,null)) {
          continue;
        }
        HoverTarget hoverTarget=firstOldHoverTarget;
        final boolean wasHovered;
        for (HoverTarget predecessor=null; ; ) {
          if (hoverTarget == null) {
            hoverTarget=HoverTarget.obtain(child);
            wasHovered=false;
            break;
          }
          if (hoverTarget.child == child) {
            if (predecessor != null) {
              predecessor.next=hoverTarget.next;
            }
 else {
              firstOldHoverTarget=hoverTarget.next;
            }
            hoverTarget.next=null;
            wasHovered=true;
            break;
          }
          predecessor=hoverTarget;
          hoverTarget=hoverTarget.next;
        }
        if (lastHoverTarget != null) {
          lastHoverTarget.next=hoverTarget;
        }
 else {
          mFirstHoverTarget=hoverTarget;
        }
        lastHoverTarget=hoverTarget;
        if (action == MotionEvent.ACTION_HOVER_ENTER) {
          if (!wasHovered) {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
 else         if (action == MotionEvent.ACTION_HOVER_MOVE) {
          if (!wasHovered) {
            eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
            eventNoHistory.setAction(action);
            handled|=dispatchTransformedGenericPointerEvent(eventNoHistory,child);
          }
 else {
            handled|=dispatchTransformedGenericPointerEvent(event,child);
          }
        }
        if (handled) {
          break;
        }
      }
    }
  }
  while (firstOldHoverTarget != null) {
    final View child=firstOldHoverTarget.child;
    if (action == MotionEvent.ACTION_HOVER_EXIT) {
      handled|=dispatchTransformedGenericPointerEvent(event,child);
    }
 else {
      if (action == MotionEvent.ACTION_HOVER_MOVE) {
        dispatchTransformedGenericPointerEvent(event,child);
      }
      eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
      eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
      dispatchTransformedGenericPointerEvent(eventNoHistory,child);
      eventNoHistory.setAction(action);
    }
    final HoverTarget nextOldHoverTarget=firstOldHoverTarget.next;
    firstOldHoverTarget.recycle();
    firstOldHoverTarget=nextOldHoverTarget;
  }
  boolean newHoveredSelf=!handled;
  if (newHoveredSelf == mHoveredSelf) {
    if (newHoveredSelf) {
      handled|=super.dispatchHoverEvent(event);
    }
  }
 else {
    if (mHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_EXIT) {
        handled|=super.dispatchHoverEvent(event);
      }
 else {
        if (action == MotionEvent.ACTION_HOVER_MOVE) {
          super.dispatchHoverEvent(event);
        }
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
        super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
      }
      mHoveredSelf=false;
    }
    if (newHoveredSelf) {
      if (action == MotionEvent.ACTION_HOVER_ENTER) {
        handled|=super.dispatchHoverEvent(event);
        mHoveredSelf=true;
      }
 else       if (action == MotionEvent.ACTION_HOVER_MOVE) {
        eventNoHistory=obtainMotionEventNoHistoryOrSelf(eventNoHistory);
        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        eventNoHistory.setAction(action);
        handled|=super.dispatchHoverEvent(eventNoHistory);
        mHoveredSelf=true;
      }
    }
  }
  if (eventNoHistory != event) {
    eventNoHistory.recycle();
  }
  return handled;
}"
2692,"/** 
 * Shows the emergency dialer or returns the user to the existing call.
 */
public void takeEmergencyCallAction(){
  mPowerManager.userActivity(SystemClock.uptimeMillis(),true);
  if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
    mLockPatternUtils.resumeCall();
  }
 else {
    Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    getContext().startActivity(intent);
  }
}","/** 
 * Shows the emergency dialer or returns the user to the existing call.
 */
public void takeEmergencyCallAction(){
  mPowerManager.userActivity(SystemClock.uptimeMillis(),true);
  if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
    mLockPatternUtils.resumeCall();
  }
 else {
    Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    getContext().startActivityAsUser(intent,new UserHandle(mLockPatternUtils.getCurrentUser()));
  }
}"
2693,"private void handleActionMove(MotionEvent event){
  final int historySize=event.getHistorySize();
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    final int patternSizePreHitDetect=mPattern.size();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx + dy > mSquareWidth * 0.01f) {
      float oldX=mInProgressX;
      float oldY=mInProgressY;
      mInProgressX=x;
      mInProgressY=y;
      if (mPatternInProgress && patternSize > 0) {
        final ArrayList<Cell> pattern=mPattern;
        final float radius=mSquareWidth * mDiameterFactor * 0.5f;
        final Cell lastCell=pattern.get(patternSize - 1);
        float startX=getCenterXForColumn(lastCell.column);
        float startY=getCenterYForRow(lastCell.row);
        float left;
        float top;
        float right;
        float bottom;
        final Rect invalidateRect=mInvalidate;
        if (startX < x) {
          left=startX;
          right=x;
        }
 else {
          left=x;
          right=startX;
        }
        if (startY < y) {
          top=startY;
          bottom=y;
        }
 else {
          top=y;
          bottom=startY;
        }
        invalidateRect.set((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
        if (startX < oldX) {
          left=startX;
          right=oldX;
        }
 else {
          left=oldX;
          right=startX;
        }
        if (startY < oldY) {
          top=startY;
          bottom=oldY;
        }
 else {
          top=oldY;
          bottom=startY;
        }
        invalidateRect.union((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
        if (hitCell != null) {
          startX=getCenterXForColumn(hitCell.column);
          startY=getCenterYForRow(hitCell.row);
          if (patternSize >= 2) {
            hitCell=pattern.get(patternSize - 1 - (patternSize - patternSizePreHitDetect));
            oldX=getCenterXForColumn(hitCell.column);
            oldY=getCenterYForRow(hitCell.row);
            if (startX < oldX) {
              left=startX;
              right=oldX;
            }
 else {
              left=oldX;
              right=startX;
            }
            if (startY < oldY) {
              top=startY;
              bottom=oldY;
            }
 else {
              top=oldY;
              bottom=startY;
            }
          }
 else {
            left=right=startX;
            top=bottom=startY;
          }
          final float widthOffset=mSquareWidth / 2f;
          final float heightOffset=mSquareHeight / 2f;
          invalidateRect.set((int)(left - widthOffset),(int)(top - heightOffset),(int)(right + widthOffset),(int)(bottom + heightOffset));
        }
        invalidate(invalidateRect);
      }
 else {
        invalidate();
      }
    }
  }
}","private void handleActionMove(MotionEvent event){
  final int historySize=event.getHistorySize();
  Rect invalidateRect=mInvalidate;
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float startX=getCenterXForColumn(lastCell.column);
      float startY=getCenterYForRow(lastCell.row);
      final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
      float left=Math.min(startX,x) - radius;
      float right=Math.max(startX,x) + radius;
      float top=Math.min(startY,y) - radius;
      float bottom=Math.max(startY,y) + radius;
      if (hitCell != null && patternSize >= 2) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float x2=getCenterXForColumn(hitCell.column);
        final float y2=getCenterYForRow(hitCell.row);
        left=Math.min(x2,left - width);
        right=Math.max(x2,right + width);
        top=Math.min(y2,top - height);
        bottom=Math.max(y2,bottom + height);
      }
      invalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    invalidate(invalidateRect);
    invalidateRect.setEmpty();
  }
}"
2694,"private void handleActionMove(MotionEvent event){
  final int historySize=event.getHistorySize();
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    final int patternSizePreHitDetect=mPattern.size();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx + dy > mSquareWidth * 0.01f) {
      float oldX=mInProgressX;
      float oldY=mInProgressY;
      mInProgressX=x;
      mInProgressY=y;
      if (mPatternInProgress && patternSize > 0) {
        final ArrayList<Cell> pattern=mPattern;
        final float radius=mSquareWidth * mDiameterFactor * 0.5f;
        final Cell lastCell=pattern.get(patternSize - 1);
        float startX=getCenterXForColumn(lastCell.column);
        float startY=getCenterYForRow(lastCell.row);
        float left;
        float top;
        float right;
        float bottom;
        final Rect invalidateRect=mInvalidate;
        if (startX < x) {
          left=startX;
          right=x;
        }
 else {
          left=x;
          right=startX;
        }
        if (startY < y) {
          top=startY;
          bottom=y;
        }
 else {
          top=y;
          bottom=startY;
        }
        invalidateRect.set((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
        if (startX < oldX) {
          left=startX;
          right=oldX;
        }
 else {
          left=oldX;
          right=startX;
        }
        if (startY < oldY) {
          top=startY;
          bottom=oldY;
        }
 else {
          top=oldY;
          bottom=startY;
        }
        invalidateRect.union((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
        if (hitCell != null) {
          startX=getCenterXForColumn(hitCell.column);
          startY=getCenterYForRow(hitCell.row);
          if (patternSize >= 2) {
            hitCell=pattern.get(patternSize - 1 - (patternSize - patternSizePreHitDetect));
            oldX=getCenterXForColumn(hitCell.column);
            oldY=getCenterYForRow(hitCell.row);
            if (startX < oldX) {
              left=startX;
              right=oldX;
            }
 else {
              left=oldX;
              right=startX;
            }
            if (startY < oldY) {
              top=startY;
              bottom=oldY;
            }
 else {
              top=oldY;
              bottom=startY;
            }
          }
 else {
            left=right=startX;
            top=bottom=startY;
          }
          final float widthOffset=mSquareWidth / 2f;
          final float heightOffset=mSquareHeight / 2f;
          invalidateRect.set((int)(left - widthOffset),(int)(top - heightOffset),(int)(right + widthOffset),(int)(bottom + heightOffset));
        }
        invalidate(invalidateRect);
      }
 else {
        invalidate();
      }
    }
  }
}","private void handleActionMove(MotionEvent event){
  final int historySize=event.getHistorySize();
  Rect invalidateRect=mInvalidate;
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float startX=getCenterXForColumn(lastCell.column);
      float startY=getCenterYForRow(lastCell.row);
      final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
      float left=Math.min(startX,x) - radius;
      float right=Math.max(startX,x) + radius;
      float top=Math.min(startY,y) - radius;
      float bottom=Math.max(startY,y) + radius;
      if (hitCell != null && patternSize >= 2) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float x2=getCenterXForColumn(hitCell.column);
        final float y2=getCenterYForRow(hitCell.row);
        left=Math.min(x2,left - width);
        right=Math.max(x2,right + width);
        top=Math.min(y2,top - height);
        bottom=Math.max(y2,bottom + height);
      }
      invalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    invalidate(invalidateRect);
    invalidateRect.setEmpty();
  }
}"
2695,"private void handleActionMove(MotionEvent event){
  final int historySize=event.getHistorySize();
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    final int patternSizePreHitDetect=mPattern.size();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx + dy > mSquareWidth * 0.01f) {
      float oldX=mInProgressX;
      float oldY=mInProgressY;
      mInProgressX=x;
      mInProgressY=y;
      if (mPatternInProgress && patternSize > 0) {
        final ArrayList<Cell> pattern=mPattern;
        final float radius=mSquareWidth * mDiameterFactor * 0.5f;
        final Cell lastCell=pattern.get(patternSize - 1);
        float startX=getCenterXForColumn(lastCell.column);
        float startY=getCenterYForRow(lastCell.row);
        float left;
        float top;
        float right;
        float bottom;
        final Rect invalidateRect=mInvalidate;
        if (startX < x) {
          left=startX;
          right=x;
        }
 else {
          left=x;
          right=startX;
        }
        if (startY < y) {
          top=startY;
          bottom=y;
        }
 else {
          top=y;
          bottom=startY;
        }
        invalidateRect.set((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
        if (startX < oldX) {
          left=startX;
          right=oldX;
        }
 else {
          left=oldX;
          right=startX;
        }
        if (startY < oldY) {
          top=startY;
          bottom=oldY;
        }
 else {
          top=oldY;
          bottom=startY;
        }
        invalidateRect.union((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
        if (hitCell != null) {
          startX=getCenterXForColumn(hitCell.column);
          startY=getCenterYForRow(hitCell.row);
          if (patternSize >= 2) {
            hitCell=pattern.get(patternSize - 1 - (patternSize - patternSizePreHitDetect));
            oldX=getCenterXForColumn(hitCell.column);
            oldY=getCenterYForRow(hitCell.row);
            if (startX < oldX) {
              left=startX;
              right=oldX;
            }
 else {
              left=oldX;
              right=startX;
            }
            if (startY < oldY) {
              top=startY;
              bottom=oldY;
            }
 else {
              top=oldY;
              bottom=startY;
            }
          }
 else {
            left=right=startX;
            top=bottom=startY;
          }
          final float widthOffset=mSquareWidth / 2f;
          final float heightOffset=mSquareHeight / 2f;
          invalidateRect.set((int)(left - widthOffset),(int)(top - heightOffset),(int)(right + widthOffset),(int)(bottom + heightOffset));
        }
        invalidate(invalidateRect);
      }
 else {
        invalidate();
      }
    }
  }
}","private void handleActionMove(MotionEvent event){
  final int historySize=event.getHistorySize();
  Rect invalidateRect=mInvalidate;
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float startX=getCenterXForColumn(lastCell.column);
      float startY=getCenterYForRow(lastCell.row);
      final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
      float left=Math.min(startX,x) - radius;
      float right=Math.max(startX,x) + radius;
      float top=Math.min(startY,y) - radius;
      float bottom=Math.max(startY,y) + radius;
      if (hitCell != null && patternSize >= 2) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float x2=getCenterXForColumn(hitCell.column);
        final float y2=getCenterYForRow(hitCell.row);
        left=Math.min(x2,left - width);
        right=Math.max(x2,right + width);
        top=Math.min(y2,top - height);
        bottom=Math.max(y2,bottom + height);
      }
      invalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    invalidate(invalidateRect);
    invalidateRect.setEmpty();
  }
}"
2696,"private void handleActionMove(MotionEvent event){
  final int historySize=event.getHistorySize();
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    final int patternSizePreHitDetect=mPattern.size();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx + dy > mSquareWidth * 0.01f) {
      float oldX=mInProgressX;
      float oldY=mInProgressY;
      mInProgressX=x;
      mInProgressY=y;
      if (mPatternInProgress && patternSize > 0) {
        final ArrayList<Cell> pattern=mPattern;
        final float radius=mSquareWidth * mDiameterFactor * 0.5f;
        final Cell lastCell=pattern.get(patternSize - 1);
        float startX=getCenterXForColumn(lastCell.column);
        float startY=getCenterYForRow(lastCell.row);
        float left;
        float top;
        float right;
        float bottom;
        final Rect invalidateRect=mInvalidate;
        if (startX < x) {
          left=startX;
          right=x;
        }
 else {
          left=x;
          right=startX;
        }
        if (startY < y) {
          top=startY;
          bottom=y;
        }
 else {
          top=y;
          bottom=startY;
        }
        invalidateRect.set((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
        if (startX < oldX) {
          left=startX;
          right=oldX;
        }
 else {
          left=oldX;
          right=startX;
        }
        if (startY < oldY) {
          top=startY;
          bottom=oldY;
        }
 else {
          top=oldY;
          bottom=startY;
        }
        invalidateRect.union((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
        if (hitCell != null) {
          startX=getCenterXForColumn(hitCell.column);
          startY=getCenterYForRow(hitCell.row);
          if (patternSize >= 2) {
            hitCell=pattern.get(patternSize - 1 - (patternSize - patternSizePreHitDetect));
            oldX=getCenterXForColumn(hitCell.column);
            oldY=getCenterYForRow(hitCell.row);
            if (startX < oldX) {
              left=startX;
              right=oldX;
            }
 else {
              left=oldX;
              right=startX;
            }
            if (startY < oldY) {
              top=startY;
              bottom=oldY;
            }
 else {
              top=oldY;
              bottom=startY;
            }
          }
 else {
            left=right=startX;
            top=bottom=startY;
          }
          final float widthOffset=mSquareWidth / 2f;
          final float heightOffset=mSquareHeight / 2f;
          invalidateRect.set((int)(left - widthOffset),(int)(top - heightOffset),(int)(right + widthOffset),(int)(bottom + heightOffset));
        }
        invalidate(invalidateRect);
      }
 else {
        invalidate();
      }
    }
  }
}","private void handleActionMove(MotionEvent event){
  final int historySize=event.getHistorySize();
  Rect invalidateRect=mInvalidate;
  boolean invalidateNow=false;
  for (int i=0; i < historySize + 1; i++) {
    final float x=i < historySize ? event.getHistoricalX(i) : event.getX();
    final float y=i < historySize ? event.getHistoricalY(i) : event.getY();
    Cell hitCell=detectAndAddHit(x,y);
    final int patternSize=mPattern.size();
    if (hitCell != null && patternSize == 1) {
      mPatternInProgress=true;
      notifyPatternStarted();
    }
    final float dx=Math.abs(x - mInProgressX);
    final float dy=Math.abs(y - mInProgressY);
    if (dx > DRAG_THRESHHOLD || dy > DRAG_THRESHHOLD) {
      invalidateNow=true;
    }
    if (mPatternInProgress && patternSize > 0) {
      final ArrayList<Cell> pattern=mPattern;
      final Cell lastCell=pattern.get(patternSize - 1);
      float startX=getCenterXForColumn(lastCell.column);
      float startY=getCenterYForRow(lastCell.row);
      final float radius=(mSquareWidth * mDiameterFactor * 0.5f);
      float left=Math.min(startX,x) - radius;
      float right=Math.max(startX,x) + radius;
      float top=Math.min(startY,y) - radius;
      float bottom=Math.max(startY,y) + radius;
      if (hitCell != null && patternSize >= 2) {
        final float width=mSquareWidth * 0.5f;
        final float height=mSquareHeight * 0.5f;
        final float x2=getCenterXForColumn(hitCell.column);
        final float y2=getCenterYForRow(hitCell.row);
        left=Math.min(x2,left - width);
        right=Math.max(x2,right + width);
        top=Math.min(y2,top - height);
        bottom=Math.max(y2,bottom + height);
      }
      invalidateRect.union(Math.round(left),Math.round(top),Math.round(right),Math.round(bottom));
    }
  }
  mInProgressX=event.getX();
  mInProgressY=event.getY();
  if (invalidateNow) {
    invalidate(invalidateRect);
    invalidateRect.setEmpty();
  }
}"
2697,"private void resolveRules(int layoutDirection){
  final boolean isLayoutRtl=(layoutDirection == View.LAYOUT_DIRECTION_RTL);
  System.arraycopy(mInitialRules,LEFT_OF,mRules,LEFT_OF,VERB_COUNT);
  if (mRules[ALIGN_START] != 0) {
    mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT]=mRules[ALIGN_START];
  }
  if (mRules[ALIGN_END] != 0) {
    mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT]=mRules[ALIGN_END];
  }
  if (mRules[START_OF] != 0) {
    mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF]=mRules[START_OF];
  }
  if (mRules[END_OF] != 0) {
    mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF]=mRules[END_OF];
  }
  if (mRules[ALIGN_PARENT_START] != 0) {
    mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT]=mRules[ALIGN_PARENT_START];
  }
  if (mRules[ALIGN_PARENT_END] != 0) {
    mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT]=mRules[ALIGN_PARENT_END];
  }
  mRulesChanged=false;
}","private void resolveRules(int layoutDirection){
  final boolean isLayoutRtl=(layoutDirection == View.LAYOUT_DIRECTION_RTL);
  System.arraycopy(mInitialRules,LEFT_OF,mRules,LEFT_OF,VERB_COUNT);
  if (mIsRtlCompatibilityMode) {
    if (mRules[ALIGN_START] != 0) {
      if (mRules[ALIGN_LEFT] == 0) {
        mRules[ALIGN_LEFT]=mRules[ALIGN_START];
      }
      mRules[ALIGN_START]=0;
    }
    if (mRules[ALIGN_END] != 0) {
      if (mRules[ALIGN_RIGHT] == 0) {
        mRules[ALIGN_RIGHT]=mRules[ALIGN_END];
      }
      mRules[ALIGN_END]=0;
    }
    if (mRules[START_OF] != 0) {
      if (mRules[LEFT_OF] == 0) {
        mRules[LEFT_OF]=mRules[START_OF];
      }
      mRules[START_OF]=0;
    }
    if (mRules[END_OF] != 0) {
      if (mRules[RIGHT_OF] == 0) {
        mRules[RIGHT_OF]=mRules[END_OF];
      }
      mRules[END_OF]=0;
    }
    if (mRules[ALIGN_PARENT_START] != 0) {
      if (mRules[ALIGN_PARENT_LEFT] == 0) {
        mRules[ALIGN_PARENT_LEFT]=mRules[ALIGN_PARENT_START];
      }
      mRules[ALIGN_PARENT_START]=0;
    }
    if (mRules[ALIGN_PARENT_RIGHT] == 0) {
      if (mRules[ALIGN_PARENT_RIGHT] == 0) {
        mRules[ALIGN_PARENT_RIGHT]=mRules[ALIGN_PARENT_END];
      }
      mRules[ALIGN_PARENT_END]=0;
    }
  }
 else {
    if ((mRules[ALIGN_START] != 0 || mRules[ALIGN_END] != 0) && (mRules[ALIGN_LEFT] != 0 || mRules[ALIGN_RIGHT] != 0)) {
      mRules[ALIGN_LEFT]=0;
      mRules[ALIGN_RIGHT]=0;
    }
    if (mRules[ALIGN_START] != 0) {
      mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT]=mRules[ALIGN_START];
      mRules[ALIGN_START]=0;
    }
    if (mRules[ALIGN_END] != 0) {
      mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT]=mRules[ALIGN_END];
      mRules[ALIGN_END]=0;
    }
    if ((mRules[START_OF] != 0 || mRules[END_OF] != 0) && (mRules[LEFT_OF] != 0 || mRules[RIGHT_OF] != 0)) {
      mRules[LEFT_OF]=0;
      mRules[RIGHT_OF]=0;
    }
    if (mRules[START_OF] != 0) {
      mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF]=mRules[START_OF];
      mRules[START_OF]=0;
    }
    if (mRules[END_OF] != 0) {
      mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF]=mRules[END_OF];
      mRules[END_OF]=0;
    }
    if ((mRules[ALIGN_PARENT_START] != 0 || mRules[ALIGN_PARENT_END] != 0) && (mRules[ALIGN_PARENT_LEFT] != 0 || mRules[ALIGN_PARENT_RIGHT] != 0)) {
      mRules[ALIGN_PARENT_LEFT]=0;
      mRules[ALIGN_PARENT_RIGHT]=0;
    }
    if (mRules[ALIGN_PARENT_START] != 0) {
      mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT]=mRules[ALIGN_PARENT_START];
      mRules[ALIGN_PARENT_START]=0;
    }
    if (mRules[ALIGN_PARENT_END] != 0) {
      mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT]=mRules[ALIGN_PARENT_END];
      mRules[ALIGN_PARENT_END]=0;
    }
  }
  mRulesChanged=false;
}"
2698,"private void resolveRules(int layoutDirection){
  final boolean isLayoutRtl=(layoutDirection == View.LAYOUT_DIRECTION_RTL);
  System.arraycopy(mInitialRules,LEFT_OF,mRules,LEFT_OF,VERB_COUNT);
  if (mRules[ALIGN_START] != 0) {
    mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT]=mRules[ALIGN_START];
  }
  if (mRules[ALIGN_END] != 0) {
    mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT]=mRules[ALIGN_END];
  }
  if (mRules[START_OF] != 0) {
    mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF]=mRules[START_OF];
  }
  if (mRules[END_OF] != 0) {
    mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF]=mRules[END_OF];
  }
  if (mRules[ALIGN_PARENT_START] != 0) {
    mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT]=mRules[ALIGN_PARENT_START];
  }
  if (mRules[ALIGN_PARENT_END] != 0) {
    mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT]=mRules[ALIGN_PARENT_END];
  }
  mRulesChanged=false;
}","private void resolveRules(int layoutDirection){
  final boolean isLayoutRtl=(layoutDirection == View.LAYOUT_DIRECTION_RTL);
  System.arraycopy(mInitialRules,LEFT_OF,mRules,LEFT_OF,VERB_COUNT);
  if (mIsRtlCompatibilityMode) {
    if (mRules[ALIGN_START] != 0) {
      if (mRules[ALIGN_LEFT] == 0) {
        mRules[ALIGN_LEFT]=mRules[ALIGN_START];
      }
      mRules[ALIGN_START]=0;
    }
    if (mRules[ALIGN_END] != 0) {
      if (mRules[ALIGN_RIGHT] == 0) {
        mRules[ALIGN_RIGHT]=mRules[ALIGN_END];
      }
      mRules[ALIGN_END]=0;
    }
    if (mRules[START_OF] != 0) {
      if (mRules[LEFT_OF] == 0) {
        mRules[LEFT_OF]=mRules[START_OF];
      }
      mRules[START_OF]=0;
    }
    if (mRules[END_OF] != 0) {
      if (mRules[RIGHT_OF] == 0) {
        mRules[RIGHT_OF]=mRules[END_OF];
      }
      mRules[END_OF]=0;
    }
    if (mRules[ALIGN_PARENT_START] != 0) {
      if (mRules[ALIGN_PARENT_LEFT] == 0) {
        mRules[ALIGN_PARENT_LEFT]=mRules[ALIGN_PARENT_START];
      }
      mRules[ALIGN_PARENT_START]=0;
    }
    if (mRules[ALIGN_PARENT_RIGHT] == 0) {
      if (mRules[ALIGN_PARENT_RIGHT] == 0) {
        mRules[ALIGN_PARENT_RIGHT]=mRules[ALIGN_PARENT_END];
      }
      mRules[ALIGN_PARENT_END]=0;
    }
  }
 else {
    if ((mRules[ALIGN_START] != 0 || mRules[ALIGN_END] != 0) && (mRules[ALIGN_LEFT] != 0 || mRules[ALIGN_RIGHT] != 0)) {
      mRules[ALIGN_LEFT]=0;
      mRules[ALIGN_RIGHT]=0;
    }
    if (mRules[ALIGN_START] != 0) {
      mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT]=mRules[ALIGN_START];
      mRules[ALIGN_START]=0;
    }
    if (mRules[ALIGN_END] != 0) {
      mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT]=mRules[ALIGN_END];
      mRules[ALIGN_END]=0;
    }
    if ((mRules[START_OF] != 0 || mRules[END_OF] != 0) && (mRules[LEFT_OF] != 0 || mRules[RIGHT_OF] != 0)) {
      mRules[LEFT_OF]=0;
      mRules[RIGHT_OF]=0;
    }
    if (mRules[START_OF] != 0) {
      mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF]=mRules[START_OF];
      mRules[START_OF]=0;
    }
    if (mRules[END_OF] != 0) {
      mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF]=mRules[END_OF];
      mRules[END_OF]=0;
    }
    if ((mRules[ALIGN_PARENT_START] != 0 || mRules[ALIGN_PARENT_END] != 0) && (mRules[ALIGN_PARENT_LEFT] != 0 || mRules[ALIGN_PARENT_RIGHT] != 0)) {
      mRules[ALIGN_PARENT_LEFT]=0;
      mRules[ALIGN_PARENT_RIGHT]=0;
    }
    if (mRules[ALIGN_PARENT_START] != 0) {
      mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT]=mRules[ALIGN_PARENT_START];
      mRules[ALIGN_PARENT_START]=0;
    }
    if (mRules[ALIGN_PARENT_END] != 0) {
      mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT]=mRules[ALIGN_PARENT_END];
      mRules[ALIGN_PARENT_END]=0;
    }
  }
  mRulesChanged=false;
}"
2699,"private void resolveRules(int layoutDirection){
  final boolean isLayoutRtl=(layoutDirection == View.LAYOUT_DIRECTION_RTL);
  System.arraycopy(mInitialRules,LEFT_OF,mRules,LEFT_OF,VERB_COUNT);
  if (mRules[ALIGN_START] != 0) {
    mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT]=mRules[ALIGN_START];
  }
  if (mRules[ALIGN_END] != 0) {
    mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT]=mRules[ALIGN_END];
  }
  if (mRules[START_OF] != 0) {
    mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF]=mRules[START_OF];
  }
  if (mRules[END_OF] != 0) {
    mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF]=mRules[END_OF];
  }
  if (mRules[ALIGN_PARENT_START] != 0) {
    mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT]=mRules[ALIGN_PARENT_START];
  }
  if (mRules[ALIGN_PARENT_END] != 0) {
    mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT]=mRules[ALIGN_PARENT_END];
  }
  mRulesChanged=false;
}","private void resolveRules(int layoutDirection){
  final boolean isLayoutRtl=(layoutDirection == View.LAYOUT_DIRECTION_RTL);
  System.arraycopy(mInitialRules,LEFT_OF,mRules,LEFT_OF,VERB_COUNT);
  if (mIsRtlCompatibilityMode) {
    if (mRules[ALIGN_START] != 0) {
      if (mRules[ALIGN_LEFT] == 0) {
        mRules[ALIGN_LEFT]=mRules[ALIGN_START];
      }
      mRules[ALIGN_START]=0;
    }
    if (mRules[ALIGN_END] != 0) {
      if (mRules[ALIGN_RIGHT] == 0) {
        mRules[ALIGN_RIGHT]=mRules[ALIGN_END];
      }
      mRules[ALIGN_END]=0;
    }
    if (mRules[START_OF] != 0) {
      if (mRules[LEFT_OF] == 0) {
        mRules[LEFT_OF]=mRules[START_OF];
      }
      mRules[START_OF]=0;
    }
    if (mRules[END_OF] != 0) {
      if (mRules[RIGHT_OF] == 0) {
        mRules[RIGHT_OF]=mRules[END_OF];
      }
      mRules[END_OF]=0;
    }
    if (mRules[ALIGN_PARENT_START] != 0) {
      if (mRules[ALIGN_PARENT_LEFT] == 0) {
        mRules[ALIGN_PARENT_LEFT]=mRules[ALIGN_PARENT_START];
      }
      mRules[ALIGN_PARENT_START]=0;
    }
    if (mRules[ALIGN_PARENT_RIGHT] == 0) {
      if (mRules[ALIGN_PARENT_RIGHT] == 0) {
        mRules[ALIGN_PARENT_RIGHT]=mRules[ALIGN_PARENT_END];
      }
      mRules[ALIGN_PARENT_END]=0;
    }
  }
 else {
    if ((mRules[ALIGN_START] != 0 || mRules[ALIGN_END] != 0) && (mRules[ALIGN_LEFT] != 0 || mRules[ALIGN_RIGHT] != 0)) {
      mRules[ALIGN_LEFT]=0;
      mRules[ALIGN_RIGHT]=0;
    }
    if (mRules[ALIGN_START] != 0) {
      mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT]=mRules[ALIGN_START];
      mRules[ALIGN_START]=0;
    }
    if (mRules[ALIGN_END] != 0) {
      mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT]=mRules[ALIGN_END];
      mRules[ALIGN_END]=0;
    }
    if ((mRules[START_OF] != 0 || mRules[END_OF] != 0) && (mRules[LEFT_OF] != 0 || mRules[RIGHT_OF] != 0)) {
      mRules[LEFT_OF]=0;
      mRules[RIGHT_OF]=0;
    }
    if (mRules[START_OF] != 0) {
      mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF]=mRules[START_OF];
      mRules[START_OF]=0;
    }
    if (mRules[END_OF] != 0) {
      mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF]=mRules[END_OF];
      mRules[END_OF]=0;
    }
    if ((mRules[ALIGN_PARENT_START] != 0 || mRules[ALIGN_PARENT_END] != 0) && (mRules[ALIGN_PARENT_LEFT] != 0 || mRules[ALIGN_PARENT_RIGHT] != 0)) {
      mRules[ALIGN_PARENT_LEFT]=0;
      mRules[ALIGN_PARENT_RIGHT]=0;
    }
    if (mRules[ALIGN_PARENT_START] != 0) {
      mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT]=mRules[ALIGN_PARENT_START];
      mRules[ALIGN_PARENT_START]=0;
    }
    if (mRules[ALIGN_PARENT_END] != 0) {
      mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT]=mRules[ALIGN_PARENT_END];
      mRules[ALIGN_PARENT_END]=0;
    }
  }
  mRulesChanged=false;
}"
2700,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mActionBarBottom.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mContainerView.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() == VISIBLE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionView.isSplitActionBar()) {
    if (stable) {
      bottomInset=mActionBarHeight;
    }
 else {
      bottomInset=mActionBarBottom.getMeasuredHeight();
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    super.fitSystemWindows(mInnerInsets);
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  pullChildren();
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  if (mActionBarBottom != null) {
    measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
    lp=(LayoutParams)mActionBarBottom.getLayoutParams();
    maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
    maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  }
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mContainerView.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() == VISIBLE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionView.isSplitActionBar()) {
    if (mActionBarBottom != null) {
      if (stable) {
        bottomInset=mActionBarHeight;
      }
 else {
        bottomInset=mActionBarBottom.getMeasuredHeight();
      }
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    super.fitSystemWindows(mInnerInsets);
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}"
2701,"@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}","@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  if (mActionBarBottom != null) {
    changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  }
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}"
2702,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mActionBarBottom.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mContainerView.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() == VISIBLE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionView.isSplitActionBar()) {
    if (stable) {
      bottomInset=mActionBarHeight;
    }
 else {
      bottomInset=mActionBarBottom.getMeasuredHeight();
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    super.fitSystemWindows(mInnerInsets);
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  pullChildren();
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  if (mActionBarBottom != null) {
    measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
    lp=(LayoutParams)mActionBarBottom.getLayoutParams();
    maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
    maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  }
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mContainerView.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() == VISIBLE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionView.isSplitActionBar()) {
    if (mActionBarBottom != null) {
      if (stable) {
        bottomInset=mActionBarHeight;
      }
 else {
        bottomInset=mActionBarBottom.getMeasuredHeight();
      }
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    super.fitSystemWindows(mInnerInsets);
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}"
2703,"@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}","@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  if (mActionBarBottom != null) {
    changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  }
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}"
2704,"public void onUiHidden(){
  if (!mShowing && mRecentTaskDescriptions != null) {
    onAnimationEnd(null);
    clearRecentTasksList();
  }
}","public void onUiHidden(){
  mCallUiHiddenBeforeNextReload=false;
  if (!mShowing && mRecentTaskDescriptions != null) {
    onAnimationEnd(null);
    clearRecentTasksList();
  }
}"
2705,"public View getView(int position,View convertView,ViewGroup parent){
  if (convertView == null) {
    convertView=createView(parent);
  }
  final ViewHolder holder=(ViewHolder)convertView.getTag();
  final int index=mRecentTaskDescriptions.size() - position - 1;
  final TaskDescription td=mRecentTaskDescriptions.get(index);
  holder.labelView.setText(td.getLabel());
  holder.thumbnailView.setContentDescription(td.getLabel());
  holder.loadedThumbnailAndIcon=td.isLoaded();
  if (td.isLoaded()) {
    updateThumbnail(holder,td.getThumbnail(),true,false);
    updateIcon(holder,td.getIcon(),true,false);
  }
  if (index == 0) {
    if (mAnimateIconOfFirstTask) {
      if (mItemToAnimateInWhenWindowAnimationIsFinished != null) {
        holder.iconView.setAlpha(1f);
        holder.iconView.setTranslationX(0f);
        holder.iconView.setTranslationY(0f);
        holder.labelView.setAlpha(1f);
        holder.labelView.setTranslationX(0f);
        holder.labelView.setTranslationY(0f);
        if (holder.calloutLine != null) {
          holder.calloutLine.setAlpha(1f);
          holder.calloutLine.setTranslationX(0f);
          holder.calloutLine.setTranslationY(0f);
        }
      }
      mItemToAnimateInWhenWindowAnimationIsFinished=null;
      final ViewTreeObserver observer=getViewTreeObserver();
      final OnGlobalLayoutListener animateFirstIcon=new OnGlobalLayoutListener(){
        public void onGlobalLayout(){
          if (mItemToAnimateInWhenWindowAnimationIsFinished != null) {
            holder.iconView.setAlpha(1f);
            holder.iconView.setTranslationX(0f);
            holder.iconView.setTranslationY(0f);
            holder.labelView.setAlpha(1f);
            holder.labelView.setTranslationX(0f);
            holder.labelView.setTranslationY(0f);
            if (holder.calloutLine != null) {
              holder.calloutLine.setAlpha(1f);
              holder.calloutLine.setTranslationX(0f);
              holder.calloutLine.setTranslationY(0f);
            }
          }
          mItemToAnimateInWhenWindowAnimationIsFinished=holder;
          int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
          final Configuration config=getResources().getConfiguration();
          if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
            if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
              translation=-translation;
            }
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationX(translation);
            holder.labelView.setAlpha(0f);
            holder.labelView.setTranslationX(translation);
            holder.calloutLine.setAlpha(0f);
            holder.calloutLine.setTranslationX(translation);
          }
 else {
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationY(translation);
          }
          if (!mWaitingForWindowAnimation) {
            animateInIconOfFirstTask();
          }
          getViewTreeObserver().removeOnGlobalLayoutListener(this);
        }
      }
;
      observer.addOnGlobalLayoutListener(animateFirstIcon);
    }
  }
  holder.thumbnailView.setTag(td);
  holder.thumbnailView.setOnLongClickListener(new OnLongClickDelegate(convertView));
  holder.taskDescription=td;
  return convertView;
}","public View getView(int position,View convertView,ViewGroup parent){
  if (convertView == null) {
    convertView=createView(parent);
  }
  final ViewHolder holder=(ViewHolder)convertView.getTag();
  final int index=mRecentTaskDescriptions.size() - position - 1;
  final TaskDescription td=mRecentTaskDescriptions.get(index);
  holder.labelView.setText(td.getLabel());
  holder.thumbnailView.setContentDescription(td.getLabel());
  holder.loadedThumbnailAndIcon=td.isLoaded();
  if (td.isLoaded()) {
    updateThumbnail(holder,td.getThumbnail(),true,false);
    updateIcon(holder,td.getIcon(),true,false);
  }
  if (index == 0) {
    if (mAnimateIconOfFirstTask) {
      ViewHolder oldHolder=mItemToAnimateInWhenWindowAnimationIsFinished;
      if (oldHolder != null) {
        oldHolder.iconView.setAlpha(1f);
        oldHolder.iconView.setTranslationX(0f);
        oldHolder.iconView.setTranslationY(0f);
        oldHolder.labelView.setAlpha(1f);
        oldHolder.labelView.setTranslationX(0f);
        oldHolder.labelView.setTranslationY(0f);
        if (oldHolder.calloutLine != null) {
          oldHolder.calloutLine.setAlpha(1f);
          oldHolder.calloutLine.setTranslationX(0f);
          oldHolder.calloutLine.setTranslationY(0f);
        }
      }
      mItemToAnimateInWhenWindowAnimationIsFinished=null;
      final ViewTreeObserver observer=getViewTreeObserver();
      final OnGlobalLayoutListener animateFirstIcon=new OnGlobalLayoutListener(){
        public void onGlobalLayout(){
          ViewHolder oldHolder=mItemToAnimateInWhenWindowAnimationIsFinished;
          if (oldHolder != null) {
            oldHolder.iconView.setAlpha(1f);
            oldHolder.iconView.setTranslationX(0f);
            oldHolder.iconView.setTranslationY(0f);
            oldHolder.labelView.setAlpha(1f);
            oldHolder.labelView.setTranslationX(0f);
            oldHolder.labelView.setTranslationY(0f);
            if (oldHolder.calloutLine != null) {
              oldHolder.calloutLine.setAlpha(1f);
              oldHolder.calloutLine.setTranslationX(0f);
              oldHolder.calloutLine.setTranslationY(0f);
            }
          }
          mItemToAnimateInWhenWindowAnimationIsFinished=holder;
          int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
          final Configuration config=getResources().getConfiguration();
          if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
            if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
              translation=-translation;
            }
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationX(translation);
            holder.labelView.setAlpha(0f);
            holder.labelView.setTranslationX(translation);
            holder.calloutLine.setAlpha(0f);
            holder.calloutLine.setTranslationX(translation);
          }
 else {
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationY(translation);
          }
          if (!mWaitingForWindowAnimation) {
            animateInIconOfFirstTask();
          }
          getViewTreeObserver().removeOnGlobalLayoutListener(this);
        }
      }
;
      observer.addOnGlobalLayoutListener(animateFirstIcon);
    }
  }
  holder.thumbnailView.setTag(td);
  holder.thumbnailView.setOnLongClickListener(new OnLongClickDelegate(convertView));
  holder.taskDescription=td;
  return convertView;
}"
2706,"public void show(boolean show,ArrayList<TaskDescription> recentTaskDescriptions,boolean firstScreenful,boolean animateIconOfFirstTask){
  mAnimateIconOfFirstTask=animateIconOfFirstTask;
  mWaitingForWindowAnimation=animateIconOfFirstTask;
  if (show) {
    mWaitingToShow=true;
    refreshRecentTasksList(recentTaskDescriptions,firstScreenful);
    showIfReady();
  }
 else {
    showImpl(false);
  }
}","public void show(boolean show,ArrayList<TaskDescription> recentTaskDescriptions,boolean firstScreenful,boolean animateIconOfFirstTask){
  if (show && mCallUiHiddenBeforeNextReload) {
    onUiHidden();
    recentTaskDescriptions=null;
    mAnimateIconOfFirstTask=false;
    mWaitingForWindowAnimation=false;
  }
 else {
    mAnimateIconOfFirstTask=animateIconOfFirstTask;
    mWaitingForWindowAnimation=animateIconOfFirstTask;
  }
  if (show) {
    mWaitingToShow=true;
    refreshRecentTasksList(recentTaskDescriptions,firstScreenful);
    showIfReady();
  }
 else {
    showImpl(false);
  }
}"
2707,"public void onGlobalLayout(){
  if (mItemToAnimateInWhenWindowAnimationIsFinished != null) {
    holder.iconView.setAlpha(1f);
    holder.iconView.setTranslationX(0f);
    holder.iconView.setTranslationY(0f);
    holder.labelView.setAlpha(1f);
    holder.labelView.setTranslationX(0f);
    holder.labelView.setTranslationY(0f);
    if (holder.calloutLine != null) {
      holder.calloutLine.setAlpha(1f);
      holder.calloutLine.setTranslationX(0f);
      holder.calloutLine.setTranslationY(0f);
    }
  }
  mItemToAnimateInWhenWindowAnimationIsFinished=holder;
  int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
  final Configuration config=getResources().getConfiguration();
  if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
    if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
      translation=-translation;
    }
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationX(translation);
    holder.labelView.setAlpha(0f);
    holder.labelView.setTranslationX(translation);
    holder.calloutLine.setAlpha(0f);
    holder.calloutLine.setTranslationX(translation);
  }
 else {
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationY(translation);
  }
  if (!mWaitingForWindowAnimation) {
    animateInIconOfFirstTask();
  }
  getViewTreeObserver().removeOnGlobalLayoutListener(this);
}","public void onGlobalLayout(){
  ViewHolder oldHolder=mItemToAnimateInWhenWindowAnimationIsFinished;
  if (oldHolder != null) {
    oldHolder.iconView.setAlpha(1f);
    oldHolder.iconView.setTranslationX(0f);
    oldHolder.iconView.setTranslationY(0f);
    oldHolder.labelView.setAlpha(1f);
    oldHolder.labelView.setTranslationX(0f);
    oldHolder.labelView.setTranslationY(0f);
    if (oldHolder.calloutLine != null) {
      oldHolder.calloutLine.setAlpha(1f);
      oldHolder.calloutLine.setTranslationX(0f);
      oldHolder.calloutLine.setTranslationY(0f);
    }
  }
  mItemToAnimateInWhenWindowAnimationIsFinished=holder;
  int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
  final Configuration config=getResources().getConfiguration();
  if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
    if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
      translation=-translation;
    }
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationX(translation);
    holder.labelView.setAlpha(0f);
    holder.labelView.setTranslationX(translation);
    holder.calloutLine.setAlpha(0f);
    holder.calloutLine.setTranslationX(translation);
  }
 else {
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationY(translation);
  }
  if (!mWaitingForWindowAnimation) {
    animateInIconOfFirstTask();
  }
  getViewTreeObserver().removeOnGlobalLayoutListener(this);
}"
2708,"private void showImpl(boolean show){
  sendCloseSystemWindows(mContext,BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS);
  mShowing=show;
  if (show) {
    boolean noApps=mRecentTaskDescriptions != null && (mRecentTaskDescriptions.size() == 0);
    mRecentsNoApps.setAlpha(1f);
    mRecentsNoApps.setVisibility(noApps ? View.VISIBLE : View.INVISIBLE);
    onAnimationEnd(null);
    setFocusable(true);
    setFocusableInTouchMode(true);
    requestFocus();
  }
 else {
    mWaitingToShow=false;
    if (mPopup != null) {
      mPopup.dismiss();
    }
  }
}","private void showImpl(boolean show){
  sendCloseSystemWindows(mContext,BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS);
  mShowing=show;
  if (show) {
    boolean noApps=mRecentTaskDescriptions != null && (mRecentTaskDescriptions.size() == 0);
    mRecentsNoApps.setAlpha(1f);
    mRecentsNoApps.setVisibility(noApps ? View.VISIBLE : View.INVISIBLE);
    onAnimationEnd(null);
    setFocusable(true);
    setFocusableInTouchMode(true);
    requestFocus();
  }
 else {
    mWaitingToShow=false;
    mCallUiHiddenBeforeNextReload=true;
    if (mPopup != null) {
      mPopup.dismiss();
    }
  }
}"
2709,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mActionBarBottom.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mContainerView.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() == VISIBLE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionView.isSplitActionBar()) {
    if (stable) {
      bottomInset=mActionBarHeight;
    }
 else {
      bottomInset=mActionBarBottom.getMeasuredHeight();
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    super.fitSystemWindows(mInnerInsets);
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  pullChildren();
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  if (mActionBarBottom != null) {
    measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
    lp=(LayoutParams)mActionBarBottom.getLayoutParams();
    maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
    maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  }
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mContainerView.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() == VISIBLE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionView.isSplitActionBar()) {
    if (mActionBarBottom != null) {
      if (stable) {
        bottomInset=mActionBarHeight;
      }
 else {
        bottomInset=mActionBarBottom.getMeasuredHeight();
      }
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    super.fitSystemWindows(mInnerInsets);
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}"
2710,"@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}","@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  if (mActionBarBottom != null) {
    changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  }
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}"
2711,"public void onUiHidden(){
  if (!mShowing && mRecentTaskDescriptions != null) {
    onAnimationEnd(null);
    clearRecentTasksList();
  }
}","public void onUiHidden(){
  mCallUiHiddenBeforeNextReload=false;
  if (!mShowing && mRecentTaskDescriptions != null) {
    onAnimationEnd(null);
    clearRecentTasksList();
  }
}"
2712,"public View getView(int position,View convertView,ViewGroup parent){
  if (convertView == null) {
    convertView=createView(parent);
  }
  final ViewHolder holder=(ViewHolder)convertView.getTag();
  final int index=mRecentTaskDescriptions.size() - position - 1;
  final TaskDescription td=mRecentTaskDescriptions.get(index);
  holder.labelView.setText(td.getLabel());
  holder.thumbnailView.setContentDescription(td.getLabel());
  holder.loadedThumbnailAndIcon=td.isLoaded();
  if (td.isLoaded()) {
    updateThumbnail(holder,td.getThumbnail(),true,false);
    updateIcon(holder,td.getIcon(),true,false);
  }
  if (index == 0) {
    if (mAnimateIconOfFirstTask) {
      if (mItemToAnimateInWhenWindowAnimationIsFinished != null) {
        holder.iconView.setAlpha(1f);
        holder.iconView.setTranslationX(0f);
        holder.iconView.setTranslationY(0f);
        holder.labelView.setAlpha(1f);
        holder.labelView.setTranslationX(0f);
        holder.labelView.setTranslationY(0f);
        if (holder.calloutLine != null) {
          holder.calloutLine.setAlpha(1f);
          holder.calloutLine.setTranslationX(0f);
          holder.calloutLine.setTranslationY(0f);
        }
      }
      mItemToAnimateInWhenWindowAnimationIsFinished=null;
      final ViewTreeObserver observer=getViewTreeObserver();
      final OnGlobalLayoutListener animateFirstIcon=new OnGlobalLayoutListener(){
        public void onGlobalLayout(){
          if (mItemToAnimateInWhenWindowAnimationIsFinished != null) {
            holder.iconView.setAlpha(1f);
            holder.iconView.setTranslationX(0f);
            holder.iconView.setTranslationY(0f);
            holder.labelView.setAlpha(1f);
            holder.labelView.setTranslationX(0f);
            holder.labelView.setTranslationY(0f);
            if (holder.calloutLine != null) {
              holder.calloutLine.setAlpha(1f);
              holder.calloutLine.setTranslationX(0f);
              holder.calloutLine.setTranslationY(0f);
            }
          }
          mItemToAnimateInWhenWindowAnimationIsFinished=holder;
          int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
          final Configuration config=getResources().getConfiguration();
          if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
            if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
              translation=-translation;
            }
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationX(translation);
            holder.labelView.setAlpha(0f);
            holder.labelView.setTranslationX(translation);
            holder.calloutLine.setAlpha(0f);
            holder.calloutLine.setTranslationX(translation);
          }
 else {
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationY(translation);
          }
          if (!mWaitingForWindowAnimation) {
            animateInIconOfFirstTask();
          }
          getViewTreeObserver().removeOnGlobalLayoutListener(this);
        }
      }
;
      observer.addOnGlobalLayoutListener(animateFirstIcon);
    }
  }
  holder.thumbnailView.setTag(td);
  holder.thumbnailView.setOnLongClickListener(new OnLongClickDelegate(convertView));
  holder.taskDescription=td;
  return convertView;
}","public View getView(int position,View convertView,ViewGroup parent){
  if (convertView == null) {
    convertView=createView(parent);
  }
  final ViewHolder holder=(ViewHolder)convertView.getTag();
  final int index=mRecentTaskDescriptions.size() - position - 1;
  final TaskDescription td=mRecentTaskDescriptions.get(index);
  holder.labelView.setText(td.getLabel());
  holder.thumbnailView.setContentDescription(td.getLabel());
  holder.loadedThumbnailAndIcon=td.isLoaded();
  if (td.isLoaded()) {
    updateThumbnail(holder,td.getThumbnail(),true,false);
    updateIcon(holder,td.getIcon(),true,false);
  }
  if (index == 0) {
    if (mAnimateIconOfFirstTask) {
      ViewHolder oldHolder=mItemToAnimateInWhenWindowAnimationIsFinished;
      if (oldHolder != null) {
        oldHolder.iconView.setAlpha(1f);
        oldHolder.iconView.setTranslationX(0f);
        oldHolder.iconView.setTranslationY(0f);
        oldHolder.labelView.setAlpha(1f);
        oldHolder.labelView.setTranslationX(0f);
        oldHolder.labelView.setTranslationY(0f);
        if (oldHolder.calloutLine != null) {
          oldHolder.calloutLine.setAlpha(1f);
          oldHolder.calloutLine.setTranslationX(0f);
          oldHolder.calloutLine.setTranslationY(0f);
        }
      }
      mItemToAnimateInWhenWindowAnimationIsFinished=null;
      final ViewTreeObserver observer=getViewTreeObserver();
      final OnGlobalLayoutListener animateFirstIcon=new OnGlobalLayoutListener(){
        public void onGlobalLayout(){
          ViewHolder oldHolder=mItemToAnimateInWhenWindowAnimationIsFinished;
          if (oldHolder != null) {
            oldHolder.iconView.setAlpha(1f);
            oldHolder.iconView.setTranslationX(0f);
            oldHolder.iconView.setTranslationY(0f);
            oldHolder.labelView.setAlpha(1f);
            oldHolder.labelView.setTranslationX(0f);
            oldHolder.labelView.setTranslationY(0f);
            if (oldHolder.calloutLine != null) {
              oldHolder.calloutLine.setAlpha(1f);
              oldHolder.calloutLine.setTranslationX(0f);
              oldHolder.calloutLine.setTranslationY(0f);
            }
          }
          mItemToAnimateInWhenWindowAnimationIsFinished=holder;
          int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
          final Configuration config=getResources().getConfiguration();
          if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
            if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
              translation=-translation;
            }
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationX(translation);
            holder.labelView.setAlpha(0f);
            holder.labelView.setTranslationX(translation);
            holder.calloutLine.setAlpha(0f);
            holder.calloutLine.setTranslationX(translation);
          }
 else {
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationY(translation);
          }
          if (!mWaitingForWindowAnimation) {
            animateInIconOfFirstTask();
          }
          getViewTreeObserver().removeOnGlobalLayoutListener(this);
        }
      }
;
      observer.addOnGlobalLayoutListener(animateFirstIcon);
    }
  }
  holder.thumbnailView.setTag(td);
  holder.thumbnailView.setOnLongClickListener(new OnLongClickDelegate(convertView));
  holder.taskDescription=td;
  return convertView;
}"
2713,"public void show(boolean show,ArrayList<TaskDescription> recentTaskDescriptions,boolean firstScreenful,boolean animateIconOfFirstTask){
  mAnimateIconOfFirstTask=animateIconOfFirstTask;
  mWaitingForWindowAnimation=animateIconOfFirstTask;
  if (show) {
    mWaitingToShow=true;
    refreshRecentTasksList(recentTaskDescriptions,firstScreenful);
    showIfReady();
  }
 else {
    showImpl(false);
  }
}","public void show(boolean show,ArrayList<TaskDescription> recentTaskDescriptions,boolean firstScreenful,boolean animateIconOfFirstTask){
  if (show && mCallUiHiddenBeforeNextReload) {
    onUiHidden();
    recentTaskDescriptions=null;
    mAnimateIconOfFirstTask=false;
    mWaitingForWindowAnimation=false;
  }
 else {
    mAnimateIconOfFirstTask=animateIconOfFirstTask;
    mWaitingForWindowAnimation=animateIconOfFirstTask;
  }
  if (show) {
    mWaitingToShow=true;
    refreshRecentTasksList(recentTaskDescriptions,firstScreenful);
    showIfReady();
  }
 else {
    showImpl(false);
  }
}"
2714,"public void onGlobalLayout(){
  if (mItemToAnimateInWhenWindowAnimationIsFinished != null) {
    holder.iconView.setAlpha(1f);
    holder.iconView.setTranslationX(0f);
    holder.iconView.setTranslationY(0f);
    holder.labelView.setAlpha(1f);
    holder.labelView.setTranslationX(0f);
    holder.labelView.setTranslationY(0f);
    if (holder.calloutLine != null) {
      holder.calloutLine.setAlpha(1f);
      holder.calloutLine.setTranslationX(0f);
      holder.calloutLine.setTranslationY(0f);
    }
  }
  mItemToAnimateInWhenWindowAnimationIsFinished=holder;
  int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
  final Configuration config=getResources().getConfiguration();
  if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
    if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
      translation=-translation;
    }
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationX(translation);
    holder.labelView.setAlpha(0f);
    holder.labelView.setTranslationX(translation);
    holder.calloutLine.setAlpha(0f);
    holder.calloutLine.setTranslationX(translation);
  }
 else {
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationY(translation);
  }
  if (!mWaitingForWindowAnimation) {
    animateInIconOfFirstTask();
  }
  getViewTreeObserver().removeOnGlobalLayoutListener(this);
}","public void onGlobalLayout(){
  ViewHolder oldHolder=mItemToAnimateInWhenWindowAnimationIsFinished;
  if (oldHolder != null) {
    oldHolder.iconView.setAlpha(1f);
    oldHolder.iconView.setTranslationX(0f);
    oldHolder.iconView.setTranslationY(0f);
    oldHolder.labelView.setAlpha(1f);
    oldHolder.labelView.setTranslationX(0f);
    oldHolder.labelView.setTranslationY(0f);
    if (oldHolder.calloutLine != null) {
      oldHolder.calloutLine.setAlpha(1f);
      oldHolder.calloutLine.setTranslationX(0f);
      oldHolder.calloutLine.setTranslationY(0f);
    }
  }
  mItemToAnimateInWhenWindowAnimationIsFinished=holder;
  int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
  final Configuration config=getResources().getConfiguration();
  if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
    if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
      translation=-translation;
    }
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationX(translation);
    holder.labelView.setAlpha(0f);
    holder.labelView.setTranslationX(translation);
    holder.calloutLine.setAlpha(0f);
    holder.calloutLine.setTranslationX(translation);
  }
 else {
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationY(translation);
  }
  if (!mWaitingForWindowAnimation) {
    animateInIconOfFirstTask();
  }
  getViewTreeObserver().removeOnGlobalLayoutListener(this);
}"
2715,"private void showImpl(boolean show){
  sendCloseSystemWindows(mContext,BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS);
  mShowing=show;
  if (show) {
    boolean noApps=mRecentTaskDescriptions != null && (mRecentTaskDescriptions.size() == 0);
    mRecentsNoApps.setAlpha(1f);
    mRecentsNoApps.setVisibility(noApps ? View.VISIBLE : View.INVISIBLE);
    onAnimationEnd(null);
    setFocusable(true);
    setFocusableInTouchMode(true);
    requestFocus();
  }
 else {
    mWaitingToShow=false;
    if (mPopup != null) {
      mPopup.dismiss();
    }
  }
}","private void showImpl(boolean show){
  sendCloseSystemWindows(mContext,BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS);
  mShowing=show;
  if (show) {
    boolean noApps=mRecentTaskDescriptions != null && (mRecentTaskDescriptions.size() == 0);
    mRecentsNoApps.setAlpha(1f);
    mRecentsNoApps.setVisibility(noApps ? View.VISIBLE : View.INVISIBLE);
    onAnimationEnd(null);
    setFocusable(true);
    setFocusableInTouchMode(true);
    requestFocus();
  }
 else {
    mWaitingToShow=false;
    mCallUiHiddenBeforeNextReload=true;
    if (mPopup != null) {
      mPopup.dismiss();
    }
  }
}"
2716,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mActionBarBottom.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mContainerView.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() == VISIBLE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionView.isSplitActionBar()) {
    if (stable) {
      bottomInset=mActionBarHeight;
    }
 else {
      bottomInset=mActionBarBottom.getMeasuredHeight();
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    super.fitSystemWindows(mInnerInsets);
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  pullChildren();
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  if (mActionBarBottom != null) {
    measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
    lp=(LayoutParams)mActionBarBottom.getLayoutParams();
    maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
    maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  }
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mContainerView.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() == VISIBLE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionView.isSplitActionBar()) {
    if (mActionBarBottom != null) {
      if (stable) {
        bottomInset=mActionBarHeight;
      }
 else {
        bottomInset=mActionBarBottom.getMeasuredHeight();
      }
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    super.fitSystemWindows(mInnerInsets);
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}"
2717,"@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}","@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  if (mActionBarBottom != null) {
    changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  }
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}"
2718,"public void onUiHidden(){
  if (!mShowing && mRecentTaskDescriptions != null) {
    onAnimationEnd(null);
    clearRecentTasksList();
  }
}","public void onUiHidden(){
  mCallUiHiddenBeforeNextReload=false;
  if (!mShowing && mRecentTaskDescriptions != null) {
    onAnimationEnd(null);
    clearRecentTasksList();
  }
}"
2719,"public View getView(int position,View convertView,ViewGroup parent){
  if (convertView == null) {
    convertView=createView(parent);
  }
  final ViewHolder holder=(ViewHolder)convertView.getTag();
  final int index=mRecentTaskDescriptions.size() - position - 1;
  final TaskDescription td=mRecentTaskDescriptions.get(index);
  holder.labelView.setText(td.getLabel());
  holder.thumbnailView.setContentDescription(td.getLabel());
  holder.loadedThumbnailAndIcon=td.isLoaded();
  if (td.isLoaded()) {
    updateThumbnail(holder,td.getThumbnail(),true,false);
    updateIcon(holder,td.getIcon(),true,false);
  }
  if (index == 0) {
    if (mAnimateIconOfFirstTask) {
      if (mItemToAnimateInWhenWindowAnimationIsFinished != null) {
        holder.iconView.setAlpha(1f);
        holder.iconView.setTranslationX(0f);
        holder.iconView.setTranslationY(0f);
        holder.labelView.setAlpha(1f);
        holder.labelView.setTranslationX(0f);
        holder.labelView.setTranslationY(0f);
        if (holder.calloutLine != null) {
          holder.calloutLine.setAlpha(1f);
          holder.calloutLine.setTranslationX(0f);
          holder.calloutLine.setTranslationY(0f);
        }
      }
      mItemToAnimateInWhenWindowAnimationIsFinished=null;
      final ViewTreeObserver observer=getViewTreeObserver();
      final OnGlobalLayoutListener animateFirstIcon=new OnGlobalLayoutListener(){
        public void onGlobalLayout(){
          if (mItemToAnimateInWhenWindowAnimationIsFinished != null) {
            holder.iconView.setAlpha(1f);
            holder.iconView.setTranslationX(0f);
            holder.iconView.setTranslationY(0f);
            holder.labelView.setAlpha(1f);
            holder.labelView.setTranslationX(0f);
            holder.labelView.setTranslationY(0f);
            if (holder.calloutLine != null) {
              holder.calloutLine.setAlpha(1f);
              holder.calloutLine.setTranslationX(0f);
              holder.calloutLine.setTranslationY(0f);
            }
          }
          mItemToAnimateInWhenWindowAnimationIsFinished=holder;
          int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
          final Configuration config=getResources().getConfiguration();
          if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
            if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
              translation=-translation;
            }
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationX(translation);
            holder.labelView.setAlpha(0f);
            holder.labelView.setTranslationX(translation);
            holder.calloutLine.setAlpha(0f);
            holder.calloutLine.setTranslationX(translation);
          }
 else {
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationY(translation);
          }
          if (!mWaitingForWindowAnimation) {
            animateInIconOfFirstTask();
          }
          getViewTreeObserver().removeOnGlobalLayoutListener(this);
        }
      }
;
      observer.addOnGlobalLayoutListener(animateFirstIcon);
    }
  }
  holder.thumbnailView.setTag(td);
  holder.thumbnailView.setOnLongClickListener(new OnLongClickDelegate(convertView));
  holder.taskDescription=td;
  return convertView;
}","public View getView(int position,View convertView,ViewGroup parent){
  if (convertView == null) {
    convertView=createView(parent);
  }
  final ViewHolder holder=(ViewHolder)convertView.getTag();
  final int index=mRecentTaskDescriptions.size() - position - 1;
  final TaskDescription td=mRecentTaskDescriptions.get(index);
  holder.labelView.setText(td.getLabel());
  holder.thumbnailView.setContentDescription(td.getLabel());
  holder.loadedThumbnailAndIcon=td.isLoaded();
  if (td.isLoaded()) {
    updateThumbnail(holder,td.getThumbnail(),true,false);
    updateIcon(holder,td.getIcon(),true,false);
  }
  if (index == 0) {
    if (mAnimateIconOfFirstTask) {
      ViewHolder oldHolder=mItemToAnimateInWhenWindowAnimationIsFinished;
      if (oldHolder != null) {
        oldHolder.iconView.setAlpha(1f);
        oldHolder.iconView.setTranslationX(0f);
        oldHolder.iconView.setTranslationY(0f);
        oldHolder.labelView.setAlpha(1f);
        oldHolder.labelView.setTranslationX(0f);
        oldHolder.labelView.setTranslationY(0f);
        if (oldHolder.calloutLine != null) {
          oldHolder.calloutLine.setAlpha(1f);
          oldHolder.calloutLine.setTranslationX(0f);
          oldHolder.calloutLine.setTranslationY(0f);
        }
      }
      mItemToAnimateInWhenWindowAnimationIsFinished=null;
      final ViewTreeObserver observer=getViewTreeObserver();
      final OnGlobalLayoutListener animateFirstIcon=new OnGlobalLayoutListener(){
        public void onGlobalLayout(){
          ViewHolder oldHolder=mItemToAnimateInWhenWindowAnimationIsFinished;
          if (oldHolder != null) {
            oldHolder.iconView.setAlpha(1f);
            oldHolder.iconView.setTranslationX(0f);
            oldHolder.iconView.setTranslationY(0f);
            oldHolder.labelView.setAlpha(1f);
            oldHolder.labelView.setTranslationX(0f);
            oldHolder.labelView.setTranslationY(0f);
            if (oldHolder.calloutLine != null) {
              oldHolder.calloutLine.setAlpha(1f);
              oldHolder.calloutLine.setTranslationX(0f);
              oldHolder.calloutLine.setTranslationY(0f);
            }
          }
          mItemToAnimateInWhenWindowAnimationIsFinished=holder;
          int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
          final Configuration config=getResources().getConfiguration();
          if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
            if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
              translation=-translation;
            }
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationX(translation);
            holder.labelView.setAlpha(0f);
            holder.labelView.setTranslationX(translation);
            holder.calloutLine.setAlpha(0f);
            holder.calloutLine.setTranslationX(translation);
          }
 else {
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationY(translation);
          }
          if (!mWaitingForWindowAnimation) {
            animateInIconOfFirstTask();
          }
          getViewTreeObserver().removeOnGlobalLayoutListener(this);
        }
      }
;
      observer.addOnGlobalLayoutListener(animateFirstIcon);
    }
  }
  holder.thumbnailView.setTag(td);
  holder.thumbnailView.setOnLongClickListener(new OnLongClickDelegate(convertView));
  holder.taskDescription=td;
  return convertView;
}"
2720,"public void show(boolean show,ArrayList<TaskDescription> recentTaskDescriptions,boolean firstScreenful,boolean animateIconOfFirstTask){
  mAnimateIconOfFirstTask=animateIconOfFirstTask;
  mWaitingForWindowAnimation=animateIconOfFirstTask;
  if (show) {
    mWaitingToShow=true;
    refreshRecentTasksList(recentTaskDescriptions,firstScreenful);
    showIfReady();
  }
 else {
    showImpl(false);
  }
}","public void show(boolean show,ArrayList<TaskDescription> recentTaskDescriptions,boolean firstScreenful,boolean animateIconOfFirstTask){
  if (show && mCallUiHiddenBeforeNextReload) {
    onUiHidden();
    recentTaskDescriptions=null;
    mAnimateIconOfFirstTask=false;
    mWaitingForWindowAnimation=false;
  }
 else {
    mAnimateIconOfFirstTask=animateIconOfFirstTask;
    mWaitingForWindowAnimation=animateIconOfFirstTask;
  }
  if (show) {
    mWaitingToShow=true;
    refreshRecentTasksList(recentTaskDescriptions,firstScreenful);
    showIfReady();
  }
 else {
    showImpl(false);
  }
}"
2721,"public void onGlobalLayout(){
  if (mItemToAnimateInWhenWindowAnimationIsFinished != null) {
    holder.iconView.setAlpha(1f);
    holder.iconView.setTranslationX(0f);
    holder.iconView.setTranslationY(0f);
    holder.labelView.setAlpha(1f);
    holder.labelView.setTranslationX(0f);
    holder.labelView.setTranslationY(0f);
    if (holder.calloutLine != null) {
      holder.calloutLine.setAlpha(1f);
      holder.calloutLine.setTranslationX(0f);
      holder.calloutLine.setTranslationY(0f);
    }
  }
  mItemToAnimateInWhenWindowAnimationIsFinished=holder;
  int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
  final Configuration config=getResources().getConfiguration();
  if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
    if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
      translation=-translation;
    }
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationX(translation);
    holder.labelView.setAlpha(0f);
    holder.labelView.setTranslationX(translation);
    holder.calloutLine.setAlpha(0f);
    holder.calloutLine.setTranslationX(translation);
  }
 else {
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationY(translation);
  }
  if (!mWaitingForWindowAnimation) {
    animateInIconOfFirstTask();
  }
  getViewTreeObserver().removeOnGlobalLayoutListener(this);
}","public void onGlobalLayout(){
  ViewHolder oldHolder=mItemToAnimateInWhenWindowAnimationIsFinished;
  if (oldHolder != null) {
    oldHolder.iconView.setAlpha(1f);
    oldHolder.iconView.setTranslationX(0f);
    oldHolder.iconView.setTranslationY(0f);
    oldHolder.labelView.setAlpha(1f);
    oldHolder.labelView.setTranslationX(0f);
    oldHolder.labelView.setTranslationY(0f);
    if (oldHolder.calloutLine != null) {
      oldHolder.calloutLine.setAlpha(1f);
      oldHolder.calloutLine.setTranslationX(0f);
      oldHolder.calloutLine.setTranslationY(0f);
    }
  }
  mItemToAnimateInWhenWindowAnimationIsFinished=holder;
  int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
  final Configuration config=getResources().getConfiguration();
  if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
    if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
      translation=-translation;
    }
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationX(translation);
    holder.labelView.setAlpha(0f);
    holder.labelView.setTranslationX(translation);
    holder.calloutLine.setAlpha(0f);
    holder.calloutLine.setTranslationX(translation);
  }
 else {
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationY(translation);
  }
  if (!mWaitingForWindowAnimation) {
    animateInIconOfFirstTask();
  }
  getViewTreeObserver().removeOnGlobalLayoutListener(this);
}"
2722,"private void showImpl(boolean show){
  sendCloseSystemWindows(mContext,BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS);
  mShowing=show;
  if (show) {
    boolean noApps=mRecentTaskDescriptions != null && (mRecentTaskDescriptions.size() == 0);
    mRecentsNoApps.setAlpha(1f);
    mRecentsNoApps.setVisibility(noApps ? View.VISIBLE : View.INVISIBLE);
    onAnimationEnd(null);
    setFocusable(true);
    setFocusableInTouchMode(true);
    requestFocus();
  }
 else {
    mWaitingToShow=false;
    if (mPopup != null) {
      mPopup.dismiss();
    }
  }
}","private void showImpl(boolean show){
  sendCloseSystemWindows(mContext,BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS);
  mShowing=show;
  if (show) {
    boolean noApps=mRecentTaskDescriptions != null && (mRecentTaskDescriptions.size() == 0);
    mRecentsNoApps.setAlpha(1f);
    mRecentsNoApps.setVisibility(noApps ? View.VISIBLE : View.INVISIBLE);
    onAnimationEnd(null);
    setFocusable(true);
    setFocusableInTouchMode(true);
    requestFocus();
  }
 else {
    mWaitingToShow=false;
    mCallUiHiddenBeforeNextReload=true;
    if (mPopup != null) {
      mPopup.dismiss();
    }
  }
}"
2723,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mActionBarBottom.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mContainerView.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() == VISIBLE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionView.isSplitActionBar()) {
    if (stable) {
      bottomInset=mActionBarHeight;
    }
 else {
      bottomInset=mActionBarBottom.getMeasuredHeight();
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    super.fitSystemWindows(mInnerInsets);
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  pullChildren();
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  if (mActionBarBottom != null) {
    measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
    lp=(LayoutParams)mActionBarBottom.getLayoutParams();
    maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
    maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  }
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mContainerView.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() == VISIBLE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionView.isSplitActionBar()) {
    if (mActionBarBottom != null) {
      if (stable) {
        bottomInset=mActionBarHeight;
      }
 else {
        bottomInset=mActionBarBottom.getMeasuredHeight();
      }
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    super.fitSystemWindows(mInnerInsets);
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}"
2724,"@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}","@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  if (mActionBarBottom != null) {
    changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  }
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}"
2725,"public void onUiHidden(){
  if (!mShowing && mRecentTaskDescriptions != null) {
    onAnimationEnd(null);
    clearRecentTasksList();
  }
}","public void onUiHidden(){
  mCallUiHiddenBeforeNextReload=false;
  if (!mShowing && mRecentTaskDescriptions != null) {
    onAnimationEnd(null);
    clearRecentTasksList();
  }
}"
2726,"public View getView(int position,View convertView,ViewGroup parent){
  if (convertView == null) {
    convertView=createView(parent);
  }
  final ViewHolder holder=(ViewHolder)convertView.getTag();
  final int index=mRecentTaskDescriptions.size() - position - 1;
  final TaskDescription td=mRecentTaskDescriptions.get(index);
  holder.labelView.setText(td.getLabel());
  holder.thumbnailView.setContentDescription(td.getLabel());
  holder.loadedThumbnailAndIcon=td.isLoaded();
  if (td.isLoaded()) {
    updateThumbnail(holder,td.getThumbnail(),true,false);
    updateIcon(holder,td.getIcon(),true,false);
  }
  if (index == 0) {
    if (mAnimateIconOfFirstTask) {
      if (mItemToAnimateInWhenWindowAnimationIsFinished != null) {
        holder.iconView.setAlpha(1f);
        holder.iconView.setTranslationX(0f);
        holder.iconView.setTranslationY(0f);
        holder.labelView.setAlpha(1f);
        holder.labelView.setTranslationX(0f);
        holder.labelView.setTranslationY(0f);
        if (holder.calloutLine != null) {
          holder.calloutLine.setAlpha(1f);
          holder.calloutLine.setTranslationX(0f);
          holder.calloutLine.setTranslationY(0f);
        }
      }
      mItemToAnimateInWhenWindowAnimationIsFinished=null;
      final ViewTreeObserver observer=getViewTreeObserver();
      final OnGlobalLayoutListener animateFirstIcon=new OnGlobalLayoutListener(){
        public void onGlobalLayout(){
          if (mItemToAnimateInWhenWindowAnimationIsFinished != null) {
            holder.iconView.setAlpha(1f);
            holder.iconView.setTranslationX(0f);
            holder.iconView.setTranslationY(0f);
            holder.labelView.setAlpha(1f);
            holder.labelView.setTranslationX(0f);
            holder.labelView.setTranslationY(0f);
            if (holder.calloutLine != null) {
              holder.calloutLine.setAlpha(1f);
              holder.calloutLine.setTranslationX(0f);
              holder.calloutLine.setTranslationY(0f);
            }
          }
          mItemToAnimateInWhenWindowAnimationIsFinished=holder;
          int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
          final Configuration config=getResources().getConfiguration();
          if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
            if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
              translation=-translation;
            }
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationX(translation);
            holder.labelView.setAlpha(0f);
            holder.labelView.setTranslationX(translation);
            holder.calloutLine.setAlpha(0f);
            holder.calloutLine.setTranslationX(translation);
          }
 else {
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationY(translation);
          }
          if (!mWaitingForWindowAnimation) {
            animateInIconOfFirstTask();
          }
          getViewTreeObserver().removeOnGlobalLayoutListener(this);
        }
      }
;
      observer.addOnGlobalLayoutListener(animateFirstIcon);
    }
  }
  holder.thumbnailView.setTag(td);
  holder.thumbnailView.setOnLongClickListener(new OnLongClickDelegate(convertView));
  holder.taskDescription=td;
  return convertView;
}","public View getView(int position,View convertView,ViewGroup parent){
  if (convertView == null) {
    convertView=createView(parent);
  }
  final ViewHolder holder=(ViewHolder)convertView.getTag();
  final int index=mRecentTaskDescriptions.size() - position - 1;
  final TaskDescription td=mRecentTaskDescriptions.get(index);
  holder.labelView.setText(td.getLabel());
  holder.thumbnailView.setContentDescription(td.getLabel());
  holder.loadedThumbnailAndIcon=td.isLoaded();
  if (td.isLoaded()) {
    updateThumbnail(holder,td.getThumbnail(),true,false);
    updateIcon(holder,td.getIcon(),true,false);
  }
  if (index == 0) {
    if (mAnimateIconOfFirstTask) {
      ViewHolder oldHolder=mItemToAnimateInWhenWindowAnimationIsFinished;
      if (oldHolder != null) {
        oldHolder.iconView.setAlpha(1f);
        oldHolder.iconView.setTranslationX(0f);
        oldHolder.iconView.setTranslationY(0f);
        oldHolder.labelView.setAlpha(1f);
        oldHolder.labelView.setTranslationX(0f);
        oldHolder.labelView.setTranslationY(0f);
        if (oldHolder.calloutLine != null) {
          oldHolder.calloutLine.setAlpha(1f);
          oldHolder.calloutLine.setTranslationX(0f);
          oldHolder.calloutLine.setTranslationY(0f);
        }
      }
      mItemToAnimateInWhenWindowAnimationIsFinished=null;
      final ViewTreeObserver observer=getViewTreeObserver();
      final OnGlobalLayoutListener animateFirstIcon=new OnGlobalLayoutListener(){
        public void onGlobalLayout(){
          ViewHolder oldHolder=mItemToAnimateInWhenWindowAnimationIsFinished;
          if (oldHolder != null) {
            oldHolder.iconView.setAlpha(1f);
            oldHolder.iconView.setTranslationX(0f);
            oldHolder.iconView.setTranslationY(0f);
            oldHolder.labelView.setAlpha(1f);
            oldHolder.labelView.setTranslationX(0f);
            oldHolder.labelView.setTranslationY(0f);
            if (oldHolder.calloutLine != null) {
              oldHolder.calloutLine.setAlpha(1f);
              oldHolder.calloutLine.setTranslationX(0f);
              oldHolder.calloutLine.setTranslationY(0f);
            }
          }
          mItemToAnimateInWhenWindowAnimationIsFinished=holder;
          int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
          final Configuration config=getResources().getConfiguration();
          if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
            if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
              translation=-translation;
            }
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationX(translation);
            holder.labelView.setAlpha(0f);
            holder.labelView.setTranslationX(translation);
            holder.calloutLine.setAlpha(0f);
            holder.calloutLine.setTranslationX(translation);
          }
 else {
            holder.iconView.setAlpha(0f);
            holder.iconView.setTranslationY(translation);
          }
          if (!mWaitingForWindowAnimation) {
            animateInIconOfFirstTask();
          }
          getViewTreeObserver().removeOnGlobalLayoutListener(this);
        }
      }
;
      observer.addOnGlobalLayoutListener(animateFirstIcon);
    }
  }
  holder.thumbnailView.setTag(td);
  holder.thumbnailView.setOnLongClickListener(new OnLongClickDelegate(convertView));
  holder.taskDescription=td;
  return convertView;
}"
2727,"public void show(boolean show,ArrayList<TaskDescription> recentTaskDescriptions,boolean firstScreenful,boolean animateIconOfFirstTask){
  mAnimateIconOfFirstTask=animateIconOfFirstTask;
  mWaitingForWindowAnimation=animateIconOfFirstTask;
  if (show) {
    mWaitingToShow=true;
    refreshRecentTasksList(recentTaskDescriptions,firstScreenful);
    showIfReady();
  }
 else {
    showImpl(false);
  }
}","public void show(boolean show,ArrayList<TaskDescription> recentTaskDescriptions,boolean firstScreenful,boolean animateIconOfFirstTask){
  if (show && mCallUiHiddenBeforeNextReload) {
    onUiHidden();
    recentTaskDescriptions=null;
    mAnimateIconOfFirstTask=false;
    mWaitingForWindowAnimation=false;
  }
 else {
    mAnimateIconOfFirstTask=animateIconOfFirstTask;
    mWaitingForWindowAnimation=animateIconOfFirstTask;
  }
  if (show) {
    mWaitingToShow=true;
    refreshRecentTasksList(recentTaskDescriptions,firstScreenful);
    showIfReady();
  }
 else {
    showImpl(false);
  }
}"
2728,"public void onGlobalLayout(){
  if (mItemToAnimateInWhenWindowAnimationIsFinished != null) {
    holder.iconView.setAlpha(1f);
    holder.iconView.setTranslationX(0f);
    holder.iconView.setTranslationY(0f);
    holder.labelView.setAlpha(1f);
    holder.labelView.setTranslationX(0f);
    holder.labelView.setTranslationY(0f);
    if (holder.calloutLine != null) {
      holder.calloutLine.setAlpha(1f);
      holder.calloutLine.setTranslationX(0f);
      holder.calloutLine.setTranslationY(0f);
    }
  }
  mItemToAnimateInWhenWindowAnimationIsFinished=holder;
  int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
  final Configuration config=getResources().getConfiguration();
  if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
    if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
      translation=-translation;
    }
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationX(translation);
    holder.labelView.setAlpha(0f);
    holder.labelView.setTranslationX(translation);
    holder.calloutLine.setAlpha(0f);
    holder.calloutLine.setTranslationX(translation);
  }
 else {
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationY(translation);
  }
  if (!mWaitingForWindowAnimation) {
    animateInIconOfFirstTask();
  }
  getViewTreeObserver().removeOnGlobalLayoutListener(this);
}","public void onGlobalLayout(){
  ViewHolder oldHolder=mItemToAnimateInWhenWindowAnimationIsFinished;
  if (oldHolder != null) {
    oldHolder.iconView.setAlpha(1f);
    oldHolder.iconView.setTranslationX(0f);
    oldHolder.iconView.setTranslationY(0f);
    oldHolder.labelView.setAlpha(1f);
    oldHolder.labelView.setTranslationX(0f);
    oldHolder.labelView.setTranslationY(0f);
    if (oldHolder.calloutLine != null) {
      oldHolder.calloutLine.setAlpha(1f);
      oldHolder.calloutLine.setTranslationX(0f);
      oldHolder.calloutLine.setTranslationY(0f);
    }
  }
  mItemToAnimateInWhenWindowAnimationIsFinished=holder;
  int translation=-getResources().getDimensionPixelSize(R.dimen.status_bar_recents_app_icon_translate_distance);
  final Configuration config=getResources().getConfiguration();
  if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {
    if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
      translation=-translation;
    }
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationX(translation);
    holder.labelView.setAlpha(0f);
    holder.labelView.setTranslationX(translation);
    holder.calloutLine.setAlpha(0f);
    holder.calloutLine.setTranslationX(translation);
  }
 else {
    holder.iconView.setAlpha(0f);
    holder.iconView.setTranslationY(translation);
  }
  if (!mWaitingForWindowAnimation) {
    animateInIconOfFirstTask();
  }
  getViewTreeObserver().removeOnGlobalLayoutListener(this);
}"
2729,"private void showImpl(boolean show){
  sendCloseSystemWindows(mContext,BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS);
  mShowing=show;
  if (show) {
    boolean noApps=mRecentTaskDescriptions != null && (mRecentTaskDescriptions.size() == 0);
    mRecentsNoApps.setAlpha(1f);
    mRecentsNoApps.setVisibility(noApps ? View.VISIBLE : View.INVISIBLE);
    onAnimationEnd(null);
    setFocusable(true);
    setFocusableInTouchMode(true);
    requestFocus();
  }
 else {
    mWaitingToShow=false;
    if (mPopup != null) {
      mPopup.dismiss();
    }
  }
}","private void showImpl(boolean show){
  sendCloseSystemWindows(mContext,BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS);
  mShowing=show;
  if (show) {
    boolean noApps=mRecentTaskDescriptions != null && (mRecentTaskDescriptions.size() == 0);
    mRecentsNoApps.setAlpha(1f);
    mRecentsNoApps.setVisibility(noApps ? View.VISIBLE : View.INVISIBLE);
    onAnimationEnd(null);
    setFocusable(true);
    setFocusableInTouchMode(true);
    requestFocus();
  }
 else {
    mWaitingToShow=false;
    mCallUiHiddenBeforeNextReload=true;
    if (mPopup != null) {
      mPopup.dismiss();
    }
  }
}"
2730,"private boolean applyInsets(View view,Rect insets,boolean left,boolean top,boolean bottom,boolean right){
  boolean changed=false;
  FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)view.getLayoutParams();
  if (left && lp.leftMargin != insets.left) {
    changed=true;
    lp.leftMargin=insets.left;
  }
  if (top && lp.topMargin != insets.top) {
    changed=true;
    lp.topMargin=insets.top;
  }
  if (right && lp.rightMargin != insets.right) {
    changed=true;
    lp.rightMargin=insets.right;
  }
  if (bottom && lp.bottomMargin != insets.bottom) {
    changed=true;
    lp.bottomMargin=insets.bottom;
  }
  return changed;
}","private boolean applyInsets(View view,Rect insets,boolean left,boolean top,boolean bottom,boolean right){
  boolean changed=false;
  LayoutParams lp=(LayoutParams)view.getLayoutParams();
  if (left && lp.leftMargin != insets.left) {
    changed=true;
    lp.leftMargin=insets.left;
  }
  if (top && lp.topMargin != insets.top) {
    changed=true;
    lp.topMargin=insets.top;
  }
  if (right && lp.rightMargin != insets.right) {
    changed=true;
    lp.rightMargin=insets.right;
  }
  if (bottom && lp.bottomMargin != insets.bottom) {
    changed=true;
    lp.bottomMargin=insets.bottom;
  }
  return changed;
}"
2731,"@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  if (mActionBarBottom != null) {
    changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  }
  int topSpace=0;
  if (stable || mActionBarTop.getVisibility() == VISIBLE) {
    topSpace=mActionBarHeight;
  }
  if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
    View tabs=mContainerView.getTabContainer();
    if (tabs != null && (stable || tabs.getVisibility() == VISIBLE)) {
      topSpace+=mActionBarHeight;
    }
  }
  int bottomSpace=0;
  if (mActionView.isSplitActionBar()) {
    if ((mActionBarBottom != null && (stable || mActionBarBottom.getVisibility() == VISIBLE))) {
      bottomSpace=mActionBarHeight;
    }
  }
  boolean res=computeFitSystemWindows(insets,mLocalInsets);
  if (!mOverlayMode && !stable) {
    mLocalInsets.top+=topSpace;
    mLocalInsets.bottom+=bottomSpace;
  }
 else {
    insets.top+=topSpace;
    insets.bottom+=bottomSpace;
  }
  changed|=applyInsets(mContent,mLocalInsets,true,true,true,true);
  if (changed) {
    requestLayout();
  }
  super.fitSystemWindows(insets);
  return true;
}","@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}"
2732,"private void resolveRules(int layoutDirection){
  final boolean isLayoutRtl=(layoutDirection == View.LAYOUT_DIRECTION_RTL);
  System.arraycopy(mInitialRules,LEFT_OF,mRules,LEFT_OF,VERB_COUNT);
  if (mRules[ALIGN_START] != 0) {
    mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT]=mRules[ALIGN_START];
  }
  if (mRules[ALIGN_END] != 0) {
    mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT]=mRules[ALIGN_END];
  }
  if (mRules[START_OF] != 0) {
    mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF]=mRules[START_OF];
  }
  if (mRules[END_OF] != 0) {
    mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF]=mRules[END_OF];
  }
  if (mRules[ALIGN_PARENT_START] != 0) {
    mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT]=mRules[ALIGN_PARENT_START];
  }
  if (mRules[ALIGN_PARENT_END] != 0) {
    mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT]=mRules[ALIGN_PARENT_END];
  }
  mRulesChanged=false;
}","private void resolveRules(int layoutDirection){
  final boolean isLayoutRtl=(layoutDirection == View.LAYOUT_DIRECTION_RTL);
  System.arraycopy(mInitialRules,LEFT_OF,mRules,LEFT_OF,VERB_COUNT);
  if (mIsRtlCompatibilityMode) {
    if (mRules[ALIGN_START] != 0) {
      if (mRules[ALIGN_LEFT] == 0) {
        mRules[ALIGN_LEFT]=mRules[ALIGN_START];
      }
      mRules[ALIGN_START]=0;
    }
    if (mRules[ALIGN_END] != 0) {
      if (mRules[ALIGN_RIGHT] == 0) {
        mRules[ALIGN_RIGHT]=mRules[ALIGN_END];
      }
      mRules[ALIGN_END]=0;
    }
    if (mRules[START_OF] != 0) {
      if (mRules[LEFT_OF] == 0) {
        mRules[LEFT_OF]=mRules[START_OF];
      }
      mRules[START_OF]=0;
    }
    if (mRules[END_OF] != 0) {
      if (mRules[RIGHT_OF] == 0) {
        mRules[RIGHT_OF]=mRules[END_OF];
      }
      mRules[END_OF]=0;
    }
    if (mRules[ALIGN_PARENT_START] != 0) {
      if (mRules[ALIGN_PARENT_LEFT] == 0) {
        mRules[ALIGN_PARENT_LEFT]=mRules[ALIGN_PARENT_START];
      }
      mRules[ALIGN_PARENT_START]=0;
    }
    if (mRules[ALIGN_PARENT_RIGHT] == 0) {
      if (mRules[ALIGN_PARENT_RIGHT] == 0) {
        mRules[ALIGN_PARENT_RIGHT]=mRules[ALIGN_PARENT_END];
      }
      mRules[ALIGN_PARENT_END]=0;
    }
  }
 else {
    if ((mRules[ALIGN_START] != 0 || mRules[ALIGN_END] != 0) && (mRules[ALIGN_LEFT] != 0 || mRules[ALIGN_RIGHT] != 0)) {
      mRules[ALIGN_LEFT]=0;
      mRules[ALIGN_RIGHT]=0;
    }
    if (mRules[ALIGN_START] != 0) {
      mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT]=mRules[ALIGN_START];
      mRules[ALIGN_START]=0;
    }
    if (mRules[ALIGN_END] != 0) {
      mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT]=mRules[ALIGN_END];
      mRules[ALIGN_END]=0;
    }
    if ((mRules[START_OF] != 0 || mRules[END_OF] != 0) && (mRules[LEFT_OF] != 0 || mRules[RIGHT_OF] != 0)) {
      mRules[LEFT_OF]=0;
      mRules[RIGHT_OF]=0;
    }
    if (mRules[START_OF] != 0) {
      mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF]=mRules[START_OF];
      mRules[START_OF]=0;
    }
    if (mRules[END_OF] != 0) {
      mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF]=mRules[END_OF];
      mRules[END_OF]=0;
    }
    if ((mRules[ALIGN_PARENT_START] != 0 || mRules[ALIGN_PARENT_END] != 0) && (mRules[ALIGN_PARENT_LEFT] != 0 || mRules[ALIGN_PARENT_RIGHT] != 0)) {
      mRules[ALIGN_PARENT_LEFT]=0;
      mRules[ALIGN_PARENT_RIGHT]=0;
    }
    if (mRules[ALIGN_PARENT_START] != 0) {
      mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT]=mRules[ALIGN_PARENT_START];
      mRules[ALIGN_PARENT_START]=0;
    }
    if (mRules[ALIGN_PARENT_END] != 0) {
      mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT]=mRules[ALIGN_PARENT_END];
      mRules[ALIGN_PARENT_END]=0;
    }
  }
  mRulesChanged=false;
}"
2733,"private boolean applyInsets(View view,Rect insets,boolean left,boolean top,boolean bottom,boolean right){
  boolean changed=false;
  FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)view.getLayoutParams();
  if (left && lp.leftMargin != insets.left) {
    changed=true;
    lp.leftMargin=insets.left;
  }
  if (top && lp.topMargin != insets.top) {
    changed=true;
    lp.topMargin=insets.top;
  }
  if (right && lp.rightMargin != insets.right) {
    changed=true;
    lp.rightMargin=insets.right;
  }
  if (bottom && lp.bottomMargin != insets.bottom) {
    changed=true;
    lp.bottomMargin=insets.bottom;
  }
  return changed;
}","private boolean applyInsets(View view,Rect insets,boolean left,boolean top,boolean bottom,boolean right){
  boolean changed=false;
  LayoutParams lp=(LayoutParams)view.getLayoutParams();
  if (left && lp.leftMargin != insets.left) {
    changed=true;
    lp.leftMargin=insets.left;
  }
  if (top && lp.topMargin != insets.top) {
    changed=true;
    lp.topMargin=insets.top;
  }
  if (right && lp.rightMargin != insets.right) {
    changed=true;
    lp.rightMargin=insets.right;
  }
  if (bottom && lp.bottomMargin != insets.bottom) {
    changed=true;
    lp.bottomMargin=insets.bottom;
  }
  return changed;
}"
2734,"@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  if (mActionBarBottom != null) {
    changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  }
  int topSpace=0;
  if (stable || mActionBarTop.getVisibility() == VISIBLE) {
    topSpace=mActionBarHeight;
  }
  if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
    View tabs=mContainerView.getTabContainer();
    if (tabs != null && (stable || tabs.getVisibility() == VISIBLE)) {
      topSpace+=mActionBarHeight;
    }
  }
  int bottomSpace=0;
  if (mActionView.isSplitActionBar()) {
    if ((mActionBarBottom != null && (stable || mActionBarBottom.getVisibility() == VISIBLE))) {
      bottomSpace=mActionBarHeight;
    }
  }
  boolean res=computeFitSystemWindows(insets,mLocalInsets);
  if (!mOverlayMode && !stable) {
    mLocalInsets.top+=topSpace;
    mLocalInsets.bottom+=bottomSpace;
  }
 else {
    insets.top+=topSpace;
    insets.bottom+=bottomSpace;
  }
  changed|=applyInsets(mContent,mLocalInsets,true,true,true,true);
  if (changed) {
    requestLayout();
  }
  super.fitSystemWindows(insets);
  return true;
}","@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}"
2735,"private boolean applyInsets(View view,Rect insets,boolean left,boolean top,boolean bottom,boolean right){
  boolean changed=false;
  FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)view.getLayoutParams();
  if (left && lp.leftMargin != insets.left) {
    changed=true;
    lp.leftMargin=insets.left;
  }
  if (top && lp.topMargin != insets.top) {
    changed=true;
    lp.topMargin=insets.top;
  }
  if (right && lp.rightMargin != insets.right) {
    changed=true;
    lp.rightMargin=insets.right;
  }
  if (bottom && lp.bottomMargin != insets.bottom) {
    changed=true;
    lp.bottomMargin=insets.bottom;
  }
  return changed;
}","private boolean applyInsets(View view,Rect insets,boolean left,boolean top,boolean bottom,boolean right){
  boolean changed=false;
  LayoutParams lp=(LayoutParams)view.getLayoutParams();
  if (left && lp.leftMargin != insets.left) {
    changed=true;
    lp.leftMargin=insets.left;
  }
  if (top && lp.topMargin != insets.top) {
    changed=true;
    lp.topMargin=insets.top;
  }
  if (right && lp.rightMargin != insets.right) {
    changed=true;
    lp.rightMargin=insets.right;
  }
  if (bottom && lp.bottomMargin != insets.bottom) {
    changed=true;
    lp.bottomMargin=insets.bottom;
  }
  return changed;
}"
2736,"@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  if (mActionBarBottom != null) {
    changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  }
  int topSpace=0;
  if (stable || mActionBarTop.getVisibility() == VISIBLE) {
    topSpace=mActionBarHeight;
  }
  if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
    View tabs=mContainerView.getTabContainer();
    if (tabs != null && (stable || tabs.getVisibility() == VISIBLE)) {
      topSpace+=mActionBarHeight;
    }
  }
  int bottomSpace=0;
  if (mActionView.isSplitActionBar()) {
    if ((mActionBarBottom != null && (stable || mActionBarBottom.getVisibility() == VISIBLE))) {
      bottomSpace=mActionBarHeight;
    }
  }
  boolean res=computeFitSystemWindows(insets,mLocalInsets);
  if (!mOverlayMode && !stable) {
    mLocalInsets.top+=topSpace;
    mLocalInsets.bottom+=bottomSpace;
  }
 else {
    insets.top+=topSpace;
    insets.bottom+=bottomSpace;
  }
  changed|=applyInsets(mContent,mLocalInsets,true,true,true,true);
  if (changed) {
    requestLayout();
  }
  super.fitSystemWindows(insets);
  return true;
}","@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}"
2737,"private boolean applyInsets(View view,Rect insets,boolean left,boolean top,boolean bottom,boolean right){
  boolean changed=false;
  FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)view.getLayoutParams();
  if (left && lp.leftMargin != insets.left) {
    changed=true;
    lp.leftMargin=insets.left;
  }
  if (top && lp.topMargin != insets.top) {
    changed=true;
    lp.topMargin=insets.top;
  }
  if (right && lp.rightMargin != insets.right) {
    changed=true;
    lp.rightMargin=insets.right;
  }
  if (bottom && lp.bottomMargin != insets.bottom) {
    changed=true;
    lp.bottomMargin=insets.bottom;
  }
  return changed;
}","private boolean applyInsets(View view,Rect insets,boolean left,boolean top,boolean bottom,boolean right){
  boolean changed=false;
  LayoutParams lp=(LayoutParams)view.getLayoutParams();
  if (left && lp.leftMargin != insets.left) {
    changed=true;
    lp.leftMargin=insets.left;
  }
  if (top && lp.topMargin != insets.top) {
    changed=true;
    lp.topMargin=insets.top;
  }
  if (right && lp.rightMargin != insets.right) {
    changed=true;
    lp.rightMargin=insets.right;
  }
  if (bottom && lp.bottomMargin != insets.bottom) {
    changed=true;
    lp.bottomMargin=insets.bottom;
  }
  return changed;
}"
2738,"@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  if (mActionBarBottom != null) {
    changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  }
  int topSpace=0;
  if (stable || mActionBarTop.getVisibility() == VISIBLE) {
    topSpace=mActionBarHeight;
  }
  if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
    View tabs=mContainerView.getTabContainer();
    if (tabs != null && (stable || tabs.getVisibility() == VISIBLE)) {
      topSpace+=mActionBarHeight;
    }
  }
  int bottomSpace=0;
  if (mActionView.isSplitActionBar()) {
    if ((mActionBarBottom != null && (stable || mActionBarBottom.getVisibility() == VISIBLE))) {
      bottomSpace=mActionBarHeight;
    }
  }
  boolean res=computeFitSystemWindows(insets,mLocalInsets);
  if (!mOverlayMode && !stable) {
    mLocalInsets.top+=topSpace;
    mLocalInsets.bottom+=bottomSpace;
  }
 else {
    insets.top+=topSpace;
    insets.bottom+=bottomSpace;
  }
  changed|=applyInsets(mContent,mLocalInsets,true,true,true,true);
  if (changed) {
    requestLayout();
  }
  super.fitSystemWindows(insets);
  return true;
}","@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}"
2739,"private boolean applyInsets(View view,Rect insets,boolean left,boolean top,boolean bottom,boolean right){
  boolean changed=false;
  FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)view.getLayoutParams();
  if (left && lp.leftMargin != insets.left) {
    changed=true;
    lp.leftMargin=insets.left;
  }
  if (top && lp.topMargin != insets.top) {
    changed=true;
    lp.topMargin=insets.top;
  }
  if (right && lp.rightMargin != insets.right) {
    changed=true;
    lp.rightMargin=insets.right;
  }
  if (bottom && lp.bottomMargin != insets.bottom) {
    changed=true;
    lp.bottomMargin=insets.bottom;
  }
  return changed;
}","private boolean applyInsets(View view,Rect insets,boolean left,boolean top,boolean bottom,boolean right){
  boolean changed=false;
  LayoutParams lp=(LayoutParams)view.getLayoutParams();
  if (left && lp.leftMargin != insets.left) {
    changed=true;
    lp.leftMargin=insets.left;
  }
  if (top && lp.topMargin != insets.top) {
    changed=true;
    lp.topMargin=insets.top;
  }
  if (right && lp.rightMargin != insets.right) {
    changed=true;
    lp.rightMargin=insets.right;
  }
  if (bottom && lp.bottomMargin != insets.bottom) {
    changed=true;
    lp.bottomMargin=insets.bottom;
  }
  return changed;
}"
2740,"@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  if (mActionBarBottom != null) {
    changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  }
  int topSpace=0;
  if (stable || mActionBarTop.getVisibility() == VISIBLE) {
    topSpace=mActionBarHeight;
  }
  if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
    View tabs=mContainerView.getTabContainer();
    if (tabs != null && (stable || tabs.getVisibility() == VISIBLE)) {
      topSpace+=mActionBarHeight;
    }
  }
  int bottomSpace=0;
  if (mActionView.isSplitActionBar()) {
    if ((mActionBarBottom != null && (stable || mActionBarBottom.getVisibility() == VISIBLE))) {
      bottomSpace=mActionBarHeight;
    }
  }
  boolean res=computeFitSystemWindows(insets,mLocalInsets);
  if (!mOverlayMode && !stable) {
    mLocalInsets.top+=topSpace;
    mLocalInsets.bottom+=bottomSpace;
  }
 else {
    insets.top+=topSpace;
    insets.bottom+=bottomSpace;
  }
  changed|=applyInsets(mContent,mLocalInsets,true,true,true,true);
  if (changed) {
    requestLayout();
  }
  super.fitSystemWindows(insets);
  return true;
}","@Override protected boolean fitSystemWindows(Rect insets){
  pullChildren();
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  boolean changed=applyInsets(mActionBarTop,insets,true,true,false,true);
  changed|=applyInsets(mActionBarBottom,insets,true,false,true,true);
  mBaseInnerInsets.set(insets);
  computeFitSystemWindows(mBaseInnerInsets,mBaseContentInsets);
  if (!mLastBaseContentInsets.equals(mBaseContentInsets)) {
    changed=true;
    mLastBaseContentInsets.set(mBaseContentInsets);
  }
  if (changed) {
    requestLayout();
  }
  return true;
}"
2741,"private final ActivityRecord resetTaskIfNeededLocked(ActivityRecord taskTop,ActivityRecord newActivity){
  boolean forceReset=(newActivity.info.flags & ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;
  if (ACTIVITY_INACTIVE_RESET_TIME > 0 && taskTop.task.getInactiveDuration() > ACTIVITY_INACTIVE_RESET_TIME) {
    if ((newActivity.info.flags & ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0) {
      forceReset=true;
    }
  }
  final TaskRecord task=taskTop.task;
  boolean taskFound=false;
  ActivityOptions topOptions=null;
  for (int i=mTaskHistory.size() - 1; i >= 0; --i) {
    final TaskRecord targetTask=mTaskHistory.get(i);
    if (targetTask == task) {
      topOptions=resetTargetTaskIfNeededLocked(task,forceReset);
      taskFound=true;
    }
 else {
      resetAffinityTaskIfNeededLocked(targetTask,task,taskFound,forceReset,taskTop);
    }
  }
  int taskNdx=mTaskHistory.indexOf(task);
  do {
    taskTop=mTaskHistory.get(taskNdx--).getTopActivity();
  }
 while (taskTop == null && taskNdx >= 0);
  if (topOptions != null) {
    if (taskTop != null) {
      if (VALIDATE_TASK_REPLACE)       Slog.w(TAG,""String_Node_Str"" + topOptions);
      taskTop.updateOptionsLocked(topOptions);
    }
 else {
      if (VALIDATE_TASK_REPLACE)       Slog.w(TAG,""String_Node_Str"" + topOptions + ""String_Node_Str"");
      topOptions.abort();
    }
  }
  return taskTop;
}","private final ActivityRecord resetTaskIfNeededLocked(ActivityRecord taskTop,ActivityRecord newActivity){
  boolean forceReset=(newActivity.info.flags & ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;
  if (ACTIVITY_INACTIVE_RESET_TIME > 0 && taskTop.task.getInactiveDuration() > ACTIVITY_INACTIVE_RESET_TIME) {
    if ((newActivity.info.flags & ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0) {
      forceReset=true;
    }
  }
  final TaskRecord task=taskTop.task;
  boolean taskFound=false;
  ActivityOptions topOptions=null;
  int reparentInsertionPoint=-1;
  for (int i=mTaskHistory.size() - 1; i >= 0; --i) {
    final TaskRecord targetTask=mTaskHistory.get(i);
    if (targetTask == task) {
      topOptions=resetTargetTaskIfNeededLocked(task,forceReset);
      taskFound=true;
    }
 else {
      reparentInsertionPoint=resetAffinityTaskIfNeededLocked(targetTask,task,taskFound,forceReset,reparentInsertionPoint);
    }
  }
  int taskNdx=mTaskHistory.indexOf(task);
  do {
    taskTop=mTaskHistory.get(taskNdx--).getTopActivity();
  }
 while (taskTop == null && taskNdx >= 0);
  if (topOptions != null) {
    if (taskTop != null) {
      if (VALIDATE_TASK_REPLACE)       Slog.w(TAG,""String_Node_Str"" + topOptions);
      taskTop.updateOptionsLocked(topOptions);
    }
 else {
      if (VALIDATE_TASK_REPLACE)       Slog.w(TAG,""String_Node_Str"" + topOptions + ""String_Node_Str"");
      topOptions.abort();
    }
  }
  return taskTop;
}"
2742,"/** 
 * Helper method for #resetTaskIfNeededLocked. Processes all of the activities in a given TaskRecord looking for an affinity with the task of resetTaskIfNeededLocked.taskTop.
 * @param affinityTask The task we are looking for an affinity to.
 * @param task Task that resetTaskIfNeededLocked.taskTop belongs to.
 * @param topTaskIsHigher True if #task has already been processed by resetTaskIfNeededLocked.
 * @param forceReset Flag passed in to resetTaskIfNeededLocked.
 */
private final void resetAffinityTaskIfNeededLocked(TaskRecord affinityTask,TaskRecord task,boolean topTaskIsHigher,boolean forceReset,ActivityRecord taskTop){
  int replyChainEnd=-1;
  final int taskId=task.taskId;
  final String taskAffinity=task.affinity;
  final ArrayList<ActivityRecord> activities=affinityTask.mActivities;
  final int numActivities=activities.size();
  for (int i=numActivities - 1; i > 0; --i) {
    ActivityRecord target=activities.get(i);
    final int flags=target.info.flags;
    boolean finishOnTaskLaunch=(flags & ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
    boolean allowTaskReparenting=(flags & ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;
    if (target.resultTo != null) {
      if (replyChainEnd < 0) {
        replyChainEnd=i;
      }
    }
 else     if (topTaskIsHigher && allowTaskReparenting && taskAffinity != null && taskAffinity.equals(target.taskAffinity)) {
      if (forceReset || finishOnTaskLaunch) {
        final int start=replyChainEnd >= 0 ? replyChainEnd : i;
        if (DEBUG_TASKS)         Slog.v(TAG,""String_Node_Str"" + start + ""String_Node_Str""+ i);
        for (int srcPos=start; srcPos >= i; --srcPos) {
          final ActivityRecord p=activities.get(srcPos);
          if (p.finishing) {
            continue;
          }
          if (VALIDATE_TASK_REPLACE)           Slog.w(TAG,""String_Node_Str"" + p);
          finishActivityLocked(p,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
        }
      }
 else {
        int taskTopI=mHistory.indexOf(taskTop);
        final int end=replyChainEnd >= 0 ? replyChainEnd : i;
        if (DEBUG_TASKS)         Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ end);
        for (int srcPos=i; srcPos <= end; ++srcPos) {
          final ActivityRecord p=activities.get(srcPos);
          setTask(p,task,null,false);
          task.addActivityToTop(p);
{
            mHistory.remove(p);
            mHistory.add(taskTopI,p);
          }
          if (DEBUG_ADD_REMOVE)           Slog.i(TAG,""String_Node_Str"" + p + ""String_Node_Str""+ task,new RuntimeException(""String_Node_Str"").fillInStackTrace());
          if (DEBUG_TASKS)           Slog.v(TAG,""String_Node_Str"" + p + ""String_Node_Str""+ srcPos+ ""String_Node_Str""+ task);
          mService.mWindowManager.setAppGroupId(p.appToken,taskId);
        }
        mService.mWindowManager.moveTaskToTop(taskId);
        if (VALIDATE_TASK_REPLACE) {
          verifyActivityRecords(false);
        }
        if (VALIDATE_TOKENS) {
          validateAppTokensLocked();
        }
        if (target.info.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
          ArrayList<ActivityRecord> taskActivities=task.mActivities;
          boolean found=false;
          int targetNdx=taskActivities.indexOf(target);
          if (targetNdx > 0) {
            ActivityRecord p=taskActivities.get(targetNdx - 1);
            if (p.intent.getComponent().equals(target.intent.getComponent())) {
              if (finishActivityLocked(p,Activity.RESULT_CANCELED,null,""String_Node_Str"",false)) {
                taskTopI--;
              }
            }
          }
        }
      }
      replyChainEnd=-1;
    }
  }
}","/** 
 * Helper method for #resetTaskIfNeededLocked. Processes all of the activities in a given TaskRecord looking for an affinity with the task of resetTaskIfNeededLocked.taskTop.
 * @param affinityTask The task we are looking for an affinity to.
 * @param task Task that resetTaskIfNeededLocked.taskTop belongs to.
 * @param topTaskIsHigher True if #task has already been processed by resetTaskIfNeededLocked.
 * @param forceReset Flag passed in to resetTaskIfNeededLocked.
 */
private final int resetAffinityTaskIfNeededLocked(TaskRecord affinityTask,TaskRecord task,boolean topTaskIsHigher,boolean forceReset,int taskInsertionPoint){
  int replyChainEnd=-1;
  final int taskId=task.taskId;
  final String taskAffinity=task.affinity;
  final ArrayList<ActivityRecord> activities=affinityTask.mActivities;
  final int numActivities=activities.size();
  for (int i=numActivities - 1; i > 0; --i) {
    ActivityRecord target=activities.get(i);
    final int flags=target.info.flags;
    boolean finishOnTaskLaunch=(flags & ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
    boolean allowTaskReparenting=(flags & ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;
    if (target.resultTo != null) {
      if (replyChainEnd < 0) {
        replyChainEnd=i;
      }
    }
 else     if (topTaskIsHigher && allowTaskReparenting && taskAffinity != null && taskAffinity.equals(target.taskAffinity)) {
      if (forceReset || finishOnTaskLaunch) {
        final int start=replyChainEnd >= 0 ? replyChainEnd : i;
        if (DEBUG_TASKS)         Slog.v(TAG,""String_Node_Str"" + start + ""String_Node_Str""+ i);
        for (int srcPos=start; srcPos >= i; --srcPos) {
          final ActivityRecord p=activities.get(srcPos);
          if (p.finishing) {
            continue;
          }
          if (VALIDATE_TASK_REPLACE)           Slog.w(TAG,""String_Node_Str"" + p);
          finishActivityLocked(p,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
        }
      }
 else {
        if (taskInsertionPoint < 0) {
          taskInsertionPoint=task.mActivities.size();
        }
        int taskTopI=mHistory.indexOf(task.mActivities.get(taskInsertionPoint - 1));
        final int start=replyChainEnd >= 0 ? replyChainEnd : i;
        if (DEBUG_TASKS)         Slog.v(TAG,""String_Node_Str"" + affinityTask + ""String_Node_Str""+ start+ ""String_Node_Str""+ i+ ""String_Node_Str""+ task+ ""String_Node_Str""+ taskInsertionPoint);
        for (int srcPos=start; srcPos >= i; --srcPos) {
          final ActivityRecord p=activities.get(srcPos);
          setTask(p,task,null,false);
          task.addActivityAtIndex(taskInsertionPoint,p);
{
            mHistory.remove(p);
            mHistory.add(taskTopI,p);
            if (DEBUG_ADD_REMOVE)             Slog.i(TAG,""String_Node_Str"" + p + ""String_Node_Str""+ taskTopI);
            --taskTopI;
          }
          if (DEBUG_ADD_REMOVE)           Slog.i(TAG,""String_Node_Str"" + p + ""String_Node_Str""+ task,new RuntimeException(""String_Node_Str"").fillInStackTrace());
          if (DEBUG_TASKS)           Slog.v(TAG,""String_Node_Str"" + p + ""String_Node_Str""+ srcPos+ ""String_Node_Str""+ task);
          mService.mWindowManager.setAppGroupId(p.appToken,taskId);
        }
        mService.mWindowManager.moveTaskToTop(taskId);
        if (VALIDATE_TASK_REPLACE) {
          verifyActivityRecords(false);
        }
        if (VALIDATE_TOKENS) {
          validateAppTokensLocked();
        }
        if (target.info.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
          ArrayList<ActivityRecord> taskActivities=task.mActivities;
          boolean found=false;
          int targetNdx=taskActivities.indexOf(target);
          if (targetNdx > 0) {
            ActivityRecord p=taskActivities.get(targetNdx - 1);
            if (p.intent.getComponent().equals(target.intent.getComponent())) {
              if (finishActivityLocked(p,Activity.RESULT_CANCELED,null,""String_Node_Str"",false)) {
                taskTopI--;
              }
            }
          }
        }
      }
      replyChainEnd=-1;
    }
  }
  return taskInsertionPoint;
}"
2743,"void addActivityAtBottom(ActivityRecord r){
  if (!mActivities.remove(r) && r.fullscreen) {
    numFullscreen++;
  }
  mActivities.add(0,r);
}","void addActivityAtBottom(ActivityRecord r){
  addActivityAtIndex(0,r);
}"
2744,"private final ActivityRecord resetTaskIfNeededLocked(ActivityRecord taskTop,ActivityRecord newActivity){
  boolean forceReset=(newActivity.info.flags & ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;
  if (ACTIVITY_INACTIVE_RESET_TIME > 0 && taskTop.task.getInactiveDuration() > ACTIVITY_INACTIVE_RESET_TIME) {
    if ((newActivity.info.flags & ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0) {
      forceReset=true;
    }
  }
  final TaskRecord task=taskTop.task;
  boolean taskFound=false;
  ActivityOptions topOptions=null;
  for (int i=mTaskHistory.size() - 1; i >= 0; --i) {
    final TaskRecord targetTask=mTaskHistory.get(i);
    if (targetTask == task) {
      topOptions=resetTargetTaskIfNeededLocked(task,forceReset);
      taskFound=true;
    }
 else {
      resetAffinityTaskIfNeededLocked(targetTask,task,taskFound,forceReset,taskTop);
    }
  }
  int taskNdx=mTaskHistory.indexOf(task);
  do {
    taskTop=mTaskHistory.get(taskNdx--).getTopActivity();
  }
 while (taskTop == null && taskNdx >= 0);
  if (topOptions != null) {
    if (taskTop != null) {
      if (VALIDATE_TASK_REPLACE)       Slog.w(TAG,""String_Node_Str"" + topOptions);
      taskTop.updateOptionsLocked(topOptions);
    }
 else {
      if (VALIDATE_TASK_REPLACE)       Slog.w(TAG,""String_Node_Str"" + topOptions + ""String_Node_Str"");
      topOptions.abort();
    }
  }
  return taskTop;
}","private final ActivityRecord resetTaskIfNeededLocked(ActivityRecord taskTop,ActivityRecord newActivity){
  boolean forceReset=(newActivity.info.flags & ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;
  if (ACTIVITY_INACTIVE_RESET_TIME > 0 && taskTop.task.getInactiveDuration() > ACTIVITY_INACTIVE_RESET_TIME) {
    if ((newActivity.info.flags & ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0) {
      forceReset=true;
    }
  }
  final TaskRecord task=taskTop.task;
  boolean taskFound=false;
  ActivityOptions topOptions=null;
  int reparentInsertionPoint=-1;
  for (int i=mTaskHistory.size() - 1; i >= 0; --i) {
    final TaskRecord targetTask=mTaskHistory.get(i);
    if (targetTask == task) {
      topOptions=resetTargetTaskIfNeededLocked(task,forceReset);
      taskFound=true;
    }
 else {
      reparentInsertionPoint=resetAffinityTaskIfNeededLocked(targetTask,task,taskFound,forceReset,reparentInsertionPoint);
    }
  }
  int taskNdx=mTaskHistory.indexOf(task);
  do {
    taskTop=mTaskHistory.get(taskNdx--).getTopActivity();
  }
 while (taskTop == null && taskNdx >= 0);
  if (topOptions != null) {
    if (taskTop != null) {
      if (VALIDATE_TASK_REPLACE)       Slog.w(TAG,""String_Node_Str"" + topOptions);
      taskTop.updateOptionsLocked(topOptions);
    }
 else {
      if (VALIDATE_TASK_REPLACE)       Slog.w(TAG,""String_Node_Str"" + topOptions + ""String_Node_Str"");
      topOptions.abort();
    }
  }
  return taskTop;
}"
2745,"/** 
 * Helper method for #resetTaskIfNeededLocked. Processes all of the activities in a given TaskRecord looking for an affinity with the task of resetTaskIfNeededLocked.taskTop.
 * @param affinityTask The task we are looking for an affinity to.
 * @param task Task that resetTaskIfNeededLocked.taskTop belongs to.
 * @param topTaskIsHigher True if #task has already been processed by resetTaskIfNeededLocked.
 * @param forceReset Flag passed in to resetTaskIfNeededLocked.
 */
private final void resetAffinityTaskIfNeededLocked(TaskRecord affinityTask,TaskRecord task,boolean topTaskIsHigher,boolean forceReset,ActivityRecord taskTop){
  int replyChainEnd=-1;
  final int taskId=task.taskId;
  final String taskAffinity=task.affinity;
  final ArrayList<ActivityRecord> activities=affinityTask.mActivities;
  final int numActivities=activities.size();
  for (int i=numActivities - 1; i > 0; --i) {
    ActivityRecord target=activities.get(i);
    final int flags=target.info.flags;
    boolean finishOnTaskLaunch=(flags & ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
    boolean allowTaskReparenting=(flags & ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;
    if (target.resultTo != null) {
      if (replyChainEnd < 0) {
        replyChainEnd=i;
      }
    }
 else     if (topTaskIsHigher && allowTaskReparenting && taskAffinity != null && taskAffinity.equals(target.taskAffinity)) {
      if (forceReset || finishOnTaskLaunch) {
        final int start=replyChainEnd >= 0 ? replyChainEnd : i;
        if (DEBUG_TASKS)         Slog.v(TAG,""String_Node_Str"" + start + ""String_Node_Str""+ i);
        for (int srcPos=start; srcPos >= i; --srcPos) {
          final ActivityRecord p=activities.get(srcPos);
          if (p.finishing) {
            continue;
          }
          if (VALIDATE_TASK_REPLACE)           Slog.w(TAG,""String_Node_Str"" + p);
          finishActivityLocked(p,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
        }
      }
 else {
        int taskTopI=mHistory.indexOf(taskTop);
        final int end=replyChainEnd >= 0 ? replyChainEnd : i;
        if (DEBUG_TASKS)         Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ end);
        for (int srcPos=i; srcPos <= end; ++srcPos) {
          final ActivityRecord p=activities.get(srcPos);
          setTask(p,task,null,false);
          task.addActivityToTop(p);
{
            mHistory.remove(p);
            mHistory.add(taskTopI,p);
          }
          if (DEBUG_ADD_REMOVE)           Slog.i(TAG,""String_Node_Str"" + p + ""String_Node_Str""+ task,new RuntimeException(""String_Node_Str"").fillInStackTrace());
          if (DEBUG_TASKS)           Slog.v(TAG,""String_Node_Str"" + p + ""String_Node_Str""+ srcPos+ ""String_Node_Str""+ task);
          mService.mWindowManager.setAppGroupId(p.appToken,taskId);
        }
        mService.mWindowManager.moveTaskToTop(taskId);
        if (VALIDATE_TASK_REPLACE) {
          verifyActivityRecords(false);
        }
        if (VALIDATE_TOKENS) {
          validateAppTokensLocked();
        }
        if (target.info.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
          ArrayList<ActivityRecord> taskActivities=task.mActivities;
          boolean found=false;
          int targetNdx=taskActivities.indexOf(target);
          if (targetNdx > 0) {
            ActivityRecord p=taskActivities.get(targetNdx - 1);
            if (p.intent.getComponent().equals(target.intent.getComponent())) {
              if (finishActivityLocked(p,Activity.RESULT_CANCELED,null,""String_Node_Str"",false)) {
                taskTopI--;
              }
            }
          }
        }
      }
      replyChainEnd=-1;
    }
  }
}","/** 
 * Helper method for #resetTaskIfNeededLocked. Processes all of the activities in a given TaskRecord looking for an affinity with the task of resetTaskIfNeededLocked.taskTop.
 * @param affinityTask The task we are looking for an affinity to.
 * @param task Task that resetTaskIfNeededLocked.taskTop belongs to.
 * @param topTaskIsHigher True if #task has already been processed by resetTaskIfNeededLocked.
 * @param forceReset Flag passed in to resetTaskIfNeededLocked.
 */
private final int resetAffinityTaskIfNeededLocked(TaskRecord affinityTask,TaskRecord task,boolean topTaskIsHigher,boolean forceReset,int taskInsertionPoint){
  int replyChainEnd=-1;
  final int taskId=task.taskId;
  final String taskAffinity=task.affinity;
  final ArrayList<ActivityRecord> activities=affinityTask.mActivities;
  final int numActivities=activities.size();
  for (int i=numActivities - 1; i > 0; --i) {
    ActivityRecord target=activities.get(i);
    final int flags=target.info.flags;
    boolean finishOnTaskLaunch=(flags & ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
    boolean allowTaskReparenting=(flags & ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;
    if (target.resultTo != null) {
      if (replyChainEnd < 0) {
        replyChainEnd=i;
      }
    }
 else     if (topTaskIsHigher && allowTaskReparenting && taskAffinity != null && taskAffinity.equals(target.taskAffinity)) {
      if (forceReset || finishOnTaskLaunch) {
        final int start=replyChainEnd >= 0 ? replyChainEnd : i;
        if (DEBUG_TASKS)         Slog.v(TAG,""String_Node_Str"" + start + ""String_Node_Str""+ i);
        for (int srcPos=start; srcPos >= i; --srcPos) {
          final ActivityRecord p=activities.get(srcPos);
          if (p.finishing) {
            continue;
          }
          if (VALIDATE_TASK_REPLACE)           Slog.w(TAG,""String_Node_Str"" + p);
          finishActivityLocked(p,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
        }
      }
 else {
        if (taskInsertionPoint < 0) {
          taskInsertionPoint=task.mActivities.size();
        }
        int taskTopI=mHistory.indexOf(task.mActivities.get(taskInsertionPoint - 1));
        final int start=replyChainEnd >= 0 ? replyChainEnd : i;
        if (DEBUG_TASKS)         Slog.v(TAG,""String_Node_Str"" + affinityTask + ""String_Node_Str""+ start+ ""String_Node_Str""+ i+ ""String_Node_Str""+ task+ ""String_Node_Str""+ taskInsertionPoint);
        for (int srcPos=start; srcPos >= i; --srcPos) {
          final ActivityRecord p=activities.get(srcPos);
          setTask(p,task,null,false);
          task.addActivityAtIndex(taskInsertionPoint,p);
{
            mHistory.remove(p);
            mHistory.add(taskTopI,p);
            if (DEBUG_ADD_REMOVE)             Slog.i(TAG,""String_Node_Str"" + p + ""String_Node_Str""+ taskTopI);
            --taskTopI;
          }
          if (DEBUG_ADD_REMOVE)           Slog.i(TAG,""String_Node_Str"" + p + ""String_Node_Str""+ task,new RuntimeException(""String_Node_Str"").fillInStackTrace());
          if (DEBUG_TASKS)           Slog.v(TAG,""String_Node_Str"" + p + ""String_Node_Str""+ srcPos+ ""String_Node_Str""+ task);
          mService.mWindowManager.setAppGroupId(p.appToken,taskId);
        }
        mService.mWindowManager.moveTaskToTop(taskId);
        if (VALIDATE_TASK_REPLACE) {
          verifyActivityRecords(false);
        }
        if (VALIDATE_TOKENS) {
          validateAppTokensLocked();
        }
        if (target.info.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
          ArrayList<ActivityRecord> taskActivities=task.mActivities;
          boolean found=false;
          int targetNdx=taskActivities.indexOf(target);
          if (targetNdx > 0) {
            ActivityRecord p=taskActivities.get(targetNdx - 1);
            if (p.intent.getComponent().equals(target.intent.getComponent())) {
              if (finishActivityLocked(p,Activity.RESULT_CANCELED,null,""String_Node_Str"",false)) {
                taskTopI--;
              }
            }
          }
        }
      }
      replyChainEnd=-1;
    }
  }
  return taskInsertionPoint;
}"
2746,"void addActivityAtBottom(ActivityRecord r){
  if (!mActivities.remove(r) && r.fullscreen) {
    numFullscreen++;
  }
  mActivities.add(0,r);
}","void addActivityAtBottom(ActivityRecord r){
  addActivityAtIndex(0,r);
}"
2747,"/** 
 * Get the profile proxy object associated with the profile. <p>Profile can be one of   {@link BluetoothProfile#HEALTH},   {@link BluetoothProfile#HEADSET},  {@link BluetoothProfile#A2DP},   {@link BluetoothProfile#GATT}, or   {@link BluetoothProfile#GATT_SERVER}. Clients must implements  {@link BluetoothProfile.ServiceListener} to get notified ofthe connection status and to get the proxy object.
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},  {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */
public boolean getProfileProxy(Context context,BluetoothProfile.ServiceListener listener,int profile){
  if (context == null || listener == null)   return false;
  if (profile == BluetoothProfile.HEADSET) {
    BluetoothHeadset headset=new BluetoothHeadset(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.A2DP) {
    BluetoothA2dp a2dp=new BluetoothA2dp(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.INPUT_DEVICE) {
    BluetoothInputDevice iDev=new BluetoothInputDevice(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.PAN) {
    BluetoothPan pan=new BluetoothPan(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.HEALTH) {
    BluetoothHealth health=new BluetoothHealth(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.GATT) {
    BluetoothGatt gatt=new BluetoothGatt(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.GATT_SERVER) {
    BluetoothGattServer gattServer=new BluetoothGattServer(context,listener);
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Get the profile proxy object associated with the profile. <p>Profile can be one of   {@link BluetoothProfile#HEALTH},   {@link BluetoothProfile#HEADSET}, or   {@link BluetoothProfile#A2DP}. Clients must implement  {@link BluetoothProfile.ServiceListener} to get notified ofthe connection status and to get the proxy object.
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},  {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */
public boolean getProfileProxy(Context context,BluetoothProfile.ServiceListener listener,int profile){
  if (context == null || listener == null)   return false;
  if (profile == BluetoothProfile.HEADSET) {
    BluetoothHeadset headset=new BluetoothHeadset(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.A2DP) {
    BluetoothA2dp a2dp=new BluetoothA2dp(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.INPUT_DEVICE) {
    BluetoothInputDevice iDev=new BluetoothInputDevice(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.PAN) {
    BluetoothPan pan=new BluetoothPan(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.HEALTH) {
    BluetoothHealth health=new BluetoothHealth(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.GATT) {
    BluetoothGatt gatt=new BluetoothGatt(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.GATT_SERVER) {
    BluetoothGattServer gattServer=new BluetoothGattServer(context,listener);
    return true;
  }
 else {
    return false;
  }
}"
2748,"/** 
 * Get the profile proxy object associated with the profile. <p>Profile can be one of   {@link BluetoothProfile#HEALTH},   {@link BluetoothProfile#HEADSET},  {@link BluetoothProfile#A2DP},   {@link BluetoothProfile#GATT}, or   {@link BluetoothProfile#GATT_SERVER}. Clients must implements  {@link BluetoothProfile.ServiceListener} to get notified ofthe connection status and to get the proxy object.
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},  {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */
public boolean getProfileProxy(Context context,BluetoothProfile.ServiceListener listener,int profile){
  if (context == null || listener == null)   return false;
  if (profile == BluetoothProfile.HEADSET) {
    BluetoothHeadset headset=new BluetoothHeadset(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.A2DP) {
    BluetoothA2dp a2dp=new BluetoothA2dp(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.INPUT_DEVICE) {
    BluetoothInputDevice iDev=new BluetoothInputDevice(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.PAN) {
    BluetoothPan pan=new BluetoothPan(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.HEALTH) {
    BluetoothHealth health=new BluetoothHealth(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.GATT) {
    BluetoothGatt gatt=new BluetoothGatt(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.GATT_SERVER) {
    BluetoothGattServer gattServer=new BluetoothGattServer(context,listener);
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Get the profile proxy object associated with the profile. <p>Profile can be one of   {@link BluetoothProfile#HEALTH},   {@link BluetoothProfile#HEADSET}, or   {@link BluetoothProfile#A2DP}. Clients must implement  {@link BluetoothProfile.ServiceListener} to get notified ofthe connection status and to get the proxy object.
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},  {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */
public boolean getProfileProxy(Context context,BluetoothProfile.ServiceListener listener,int profile){
  if (context == null || listener == null)   return false;
  if (profile == BluetoothProfile.HEADSET) {
    BluetoothHeadset headset=new BluetoothHeadset(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.A2DP) {
    BluetoothA2dp a2dp=new BluetoothA2dp(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.INPUT_DEVICE) {
    BluetoothInputDevice iDev=new BluetoothInputDevice(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.PAN) {
    BluetoothPan pan=new BluetoothPan(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.HEALTH) {
    BluetoothHealth health=new BluetoothHealth(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.GATT) {
    BluetoothGatt gatt=new BluetoothGatt(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.GATT_SERVER) {
    BluetoothGattServer gattServer=new BluetoothGattServer(context,listener);
    return true;
  }
 else {
    return false;
  }
}"
2749,"/** 
 * Get the profile proxy object associated with the profile. <p>Profile can be one of   {@link BluetoothProfile#HEALTH},   {@link BluetoothProfile#HEADSET},  {@link BluetoothProfile#A2DP},   {@link BluetoothProfile#GATT}, or   {@link BluetoothProfile#GATT_SERVER}. Clients must implements  {@link BluetoothProfile.ServiceListener} to get notified ofthe connection status and to get the proxy object.
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},  {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */
public boolean getProfileProxy(Context context,BluetoothProfile.ServiceListener listener,int profile){
  if (context == null || listener == null)   return false;
  if (profile == BluetoothProfile.HEADSET) {
    BluetoothHeadset headset=new BluetoothHeadset(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.A2DP) {
    BluetoothA2dp a2dp=new BluetoothA2dp(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.INPUT_DEVICE) {
    BluetoothInputDevice iDev=new BluetoothInputDevice(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.PAN) {
    BluetoothPan pan=new BluetoothPan(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.HEALTH) {
    BluetoothHealth health=new BluetoothHealth(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.GATT) {
    BluetoothGatt gatt=new BluetoothGatt(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.GATT_SERVER) {
    BluetoothGattServer gattServer=new BluetoothGattServer(context,listener);
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Get the profile proxy object associated with the profile. <p>Profile can be one of   {@link BluetoothProfile#HEALTH},   {@link BluetoothProfile#HEADSET}, or   {@link BluetoothProfile#A2DP}. Clients must implement  {@link BluetoothProfile.ServiceListener} to get notified ofthe connection status and to get the proxy object.
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},  {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */
public boolean getProfileProxy(Context context,BluetoothProfile.ServiceListener listener,int profile){
  if (context == null || listener == null)   return false;
  if (profile == BluetoothProfile.HEADSET) {
    BluetoothHeadset headset=new BluetoothHeadset(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.A2DP) {
    BluetoothA2dp a2dp=new BluetoothA2dp(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.INPUT_DEVICE) {
    BluetoothInputDevice iDev=new BluetoothInputDevice(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.PAN) {
    BluetoothPan pan=new BluetoothPan(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.HEALTH) {
    BluetoothHealth health=new BluetoothHealth(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.GATT) {
    BluetoothGatt gatt=new BluetoothGatt(context,listener);
    return true;
  }
 else   if (profile == BluetoothProfile.GATT_SERVER) {
    BluetoothGattServer gattServer=new BluetoothGattServer(context,listener);
    return true;
  }
 else {
    return false;
  }
}"
2750,"/** 
 * Handle a request by the system to show the soft input area.
 */
public void showSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  if (onShowInputRequested(flags,false)) {
    showWindow(true);
  }
  boolean showing=onEvaluateInputViewShown();
  mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}","/** 
 * Handle a request by the system to show the soft input area.
 */
public void showSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  if (onShowInputRequested(flags,false)) {
    showWindow(true);
  }
  boolean showing=isInputViewShown();
  mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}"
2751,"@SuppressWarnings(""String_Node_Str"") @Override public void setImeWindowStatus(IBinder token,int vis,int backDisposition){
  final long ident=Binder.clearCallingIdentity();
  try {
    if (token == null || mCurToken != token) {
      int uid=Binder.getCallingUid();
      Slog.w(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ token);
      return;
    }
synchronized (mMethodMap) {
      mImeWindowVis=vis;
      mBackDisposition=backDisposition;
      if (mStatusBar != null) {
        mStatusBar.setImeWindowStatus(token,vis,backDisposition);
      }
      final boolean iconVisibility=(vis & InputMethodService.IME_ACTIVE) != 0;
      final InputMethodInfo imi=mMethodMap.get(mCurMethodId);
      if (imi != null && iconVisibility && needsToShowImeSwitchOngoingNotification()) {
        final PackageManager pm=mContext.getPackageManager();
        final CharSequence title=mRes.getText(com.android.internal.R.string.select_input_method);
        final CharSequence imiLabel=imi.loadLabel(pm);
        final CharSequence summary=mCurrentSubtype != null ? TextUtils.concat(mCurrentSubtype.getDisplayName(mContext,imi.getPackageName(),imi.getServiceInfo().applicationInfo),(TextUtils.isEmpty(imiLabel) ? ""String_Node_Str"" : ""String_Node_Str"" + imiLabel)) : imiLabel;
        mImeSwitcherNotification.setLatestEventInfo(mContext,title,summary,mImeSwitchPendingIntent);
        if (mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"" + imiLabel + ""String_Node_Str""+ summary);
          }
          mNotificationManager.notifyAsUser(null,com.android.internal.R.string.select_input_method,mImeSwitcherNotification,UserHandle.ALL);
          mNotificationShown=true;
        }
      }
 else {
        if (mNotificationShown && mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"");
          }
          mNotificationManager.cancelAsUser(null,com.android.internal.R.string.select_input_method,UserHandle.ALL);
          mNotificationShown=false;
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void setImeWindowStatus(IBinder token,int vis,int backDisposition){
  final long ident=Binder.clearCallingIdentity();
  try {
    if (token == null || mCurToken != token) {
      int uid=Binder.getCallingUid();
      Slog.w(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ token);
      return;
    }
synchronized (mMethodMap) {
      mImeWindowVis=vis;
      mBackDisposition=backDisposition;
      if (mStatusBar != null) {
        mStatusBar.setImeWindowStatus(token,vis,backDisposition);
      }
      final boolean iconVisibility=((vis & (InputMethodService.IME_ACTIVE)) != 0) && (mWindowManagerService.isHardKeyboardAvailable() || (vis & (InputMethodService.IME_VISIBLE)) != 0);
      final InputMethodInfo imi=mMethodMap.get(mCurMethodId);
      if (imi != null && iconVisibility && needsToShowImeSwitchOngoingNotification()) {
        final PackageManager pm=mContext.getPackageManager();
        final CharSequence title=mRes.getText(com.android.internal.R.string.select_input_method);
        final CharSequence imiLabel=imi.loadLabel(pm);
        final CharSequence summary=mCurrentSubtype != null ? TextUtils.concat(mCurrentSubtype.getDisplayName(mContext,imi.getPackageName(),imi.getServiceInfo().applicationInfo),(TextUtils.isEmpty(imiLabel) ? ""String_Node_Str"" : ""String_Node_Str"" + imiLabel)) : imiLabel;
        mImeSwitcherNotification.setLatestEventInfo(mContext,title,summary,mImeSwitchPendingIntent);
        if (mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"" + imiLabel + ""String_Node_Str""+ summary);
          }
          mNotificationManager.notifyAsUser(null,com.android.internal.R.string.select_input_method,mImeSwitcherNotification,UserHandle.ALL);
          mNotificationShown=true;
        }
      }
 else {
        if (mNotificationShown && mNotificationManager != null) {
          if (DEBUG) {
            Slog.d(TAG,""String_Node_Str"");
          }
          mNotificationManager.cancelAsUser(null,com.android.internal.R.string.select_input_method,UserHandle.ALL);
          mNotificationShown=false;
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
2752,"/** 
 * copy constructor 
 */
public WifiP2pDevice(WifiP2pDevice source){
  if (source != null) {
    deviceName=source.deviceName;
    deviceAddress=source.deviceAddress;
    primaryDeviceType=source.primaryDeviceType;
    secondaryDeviceType=source.secondaryDeviceType;
    wpsConfigMethodsSupported=source.wpsConfigMethodsSupported;
    deviceCapability=source.deviceCapability;
    groupCapability=source.groupCapability;
    status=source.status;
    wfdInfo=source.wfdInfo;
  }
}","/** 
 * copy constructor 
 */
public WifiP2pDevice(WifiP2pDevice source){
  if (source != null) {
    deviceName=source.deviceName;
    deviceAddress=source.deviceAddress;
    primaryDeviceType=source.primaryDeviceType;
    secondaryDeviceType=source.secondaryDeviceType;
    wpsConfigMethodsSupported=source.wpsConfigMethodsSupported;
    deviceCapability=source.deviceCapability;
    groupCapability=source.groupCapability;
    status=source.status;
    wfdInfo=new WifiP2pWfdInfo(source.wfdInfo);
  }
}"
2753,"/** 
 * @hide 
 */
public WifiP2pDeviceList(ArrayList<WifiP2pDevice> devices){
  for (  WifiP2pDevice device : devices) {
    if (device.deviceAddress != null) {
      mDevices.put(device.deviceAddress,device);
    }
  }
}","/** 
 * @hide 
 */
public WifiP2pDeviceList(ArrayList<WifiP2pDevice> devices){
  for (  WifiP2pDevice device : devices) {
    if (device.deviceAddress != null) {
      mDevices.put(device.deviceAddress,new WifiP2pDevice(device));
    }
  }
}"
2754,"private void sendPeersChangedBroadcast(){
  final Intent intent=new Intent(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  intent.putExtra(WifiP2pManager.EXTRA_P2P_DEVICE_LIST,mPeers);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
  mContext.sendBroadcastAsUser(intent,UserHandle.ALL);
}","private void sendPeersChangedBroadcast(){
  final Intent intent=new Intent(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  intent.putExtra(WifiP2pManager.EXTRA_P2P_DEVICE_LIST,new WifiP2pDeviceList(mPeers));
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
  mContext.sendBroadcastAsUser(intent,UserHandle.ALL);
}"
2755,"/** 
 * copy constructor 
 */
public WifiP2pDevice(WifiP2pDevice source){
  if (source != null) {
    deviceName=source.deviceName;
    deviceAddress=source.deviceAddress;
    primaryDeviceType=source.primaryDeviceType;
    secondaryDeviceType=source.secondaryDeviceType;
    wpsConfigMethodsSupported=source.wpsConfigMethodsSupported;
    deviceCapability=source.deviceCapability;
    groupCapability=source.groupCapability;
    status=source.status;
    wfdInfo=source.wfdInfo;
  }
}","/** 
 * copy constructor 
 */
public WifiP2pDevice(WifiP2pDevice source){
  if (source != null) {
    deviceName=source.deviceName;
    deviceAddress=source.deviceAddress;
    primaryDeviceType=source.primaryDeviceType;
    secondaryDeviceType=source.secondaryDeviceType;
    wpsConfigMethodsSupported=source.wpsConfigMethodsSupported;
    deviceCapability=source.deviceCapability;
    groupCapability=source.groupCapability;
    status=source.status;
    wfdInfo=new WifiP2pWfdInfo(source.wfdInfo);
  }
}"
2756,"/** 
 * @hide 
 */
public WifiP2pDeviceList(ArrayList<WifiP2pDevice> devices){
  for (  WifiP2pDevice device : devices) {
    if (device.deviceAddress != null) {
      mDevices.put(device.deviceAddress,device);
    }
  }
}","/** 
 * @hide 
 */
public WifiP2pDeviceList(ArrayList<WifiP2pDevice> devices){
  for (  WifiP2pDevice device : devices) {
    if (device.deviceAddress != null) {
      mDevices.put(device.deviceAddress,new WifiP2pDevice(device));
    }
  }
}"
2757,"private void sendPeersChangedBroadcast(){
  final Intent intent=new Intent(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  intent.putExtra(WifiP2pManager.EXTRA_P2P_DEVICE_LIST,mPeers);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
  mContext.sendBroadcastAsUser(intent,UserHandle.ALL);
}","private void sendPeersChangedBroadcast(){
  final Intent intent=new Intent(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  intent.putExtra(WifiP2pManager.EXTRA_P2P_DEVICE_LIST,new WifiP2pDeviceList(mPeers));
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
  mContext.sendBroadcastAsUser(intent,UserHandle.ALL);
}"
2758,"/** 
 * copy constructor 
 */
public WifiP2pDevice(WifiP2pDevice source){
  if (source != null) {
    deviceName=source.deviceName;
    deviceAddress=source.deviceAddress;
    primaryDeviceType=source.primaryDeviceType;
    secondaryDeviceType=source.secondaryDeviceType;
    wpsConfigMethodsSupported=source.wpsConfigMethodsSupported;
    deviceCapability=source.deviceCapability;
    groupCapability=source.groupCapability;
    status=source.status;
    wfdInfo=source.wfdInfo;
  }
}","/** 
 * copy constructor 
 */
public WifiP2pDevice(WifiP2pDevice source){
  if (source != null) {
    deviceName=source.deviceName;
    deviceAddress=source.deviceAddress;
    primaryDeviceType=source.primaryDeviceType;
    secondaryDeviceType=source.secondaryDeviceType;
    wpsConfigMethodsSupported=source.wpsConfigMethodsSupported;
    deviceCapability=source.deviceCapability;
    groupCapability=source.groupCapability;
    status=source.status;
    wfdInfo=new WifiP2pWfdInfo(source.wfdInfo);
  }
}"
2759,"/** 
 * @hide 
 */
public WifiP2pDeviceList(ArrayList<WifiP2pDevice> devices){
  for (  WifiP2pDevice device : devices) {
    if (device.deviceAddress != null) {
      mDevices.put(device.deviceAddress,device);
    }
  }
}","/** 
 * @hide 
 */
public WifiP2pDeviceList(ArrayList<WifiP2pDevice> devices){
  for (  WifiP2pDevice device : devices) {
    if (device.deviceAddress != null) {
      mDevices.put(device.deviceAddress,new WifiP2pDevice(device));
    }
  }
}"
2760,"private void sendPeersChangedBroadcast(){
  final Intent intent=new Intent(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  intent.putExtra(WifiP2pManager.EXTRA_P2P_DEVICE_LIST,mPeers);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
  mContext.sendBroadcastAsUser(intent,UserHandle.ALL);
}","private void sendPeersChangedBroadcast(){
  final Intent intent=new Intent(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  intent.putExtra(WifiP2pManager.EXTRA_P2P_DEVICE_LIST,new WifiP2pDeviceList(mPeers));
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
  mContext.sendBroadcastAsUser(intent,UserHandle.ALL);
}"
2761,"public void validateAppTokens(List<TaskGroup> tasks){
synchronized (mWindowMap) {
    int t=tasks.size() - 1;
    if (t < 0) {
      Slog.w(TAG,""String_Node_Str"");
      return;
    }
    TaskGroup task=tasks.get(0);
    int taskId=task.taskId;
    DisplayContent displayContent=mTaskIdToDisplayContents.get(taskId);
    if (displayContent == null) {
      Slog.w(TAG,""String_Node_Str"" + taskId);
      return;
    }
    boolean mismatch=false;
    AppTokenIterator iterator=displayContent.getTmpAppIterator(REVERSE_ITERATOR);
    for (; t >= 0 && !mismatch; --t) {
      task=tasks.get(t);
      List<IApplicationToken> tokens=task.tokens;
      int v=task.tokens.size() - 1;
      DisplayContent lastDisplayContent=displayContent;
      displayContent=mTaskIdToDisplayContents.get(taskId);
      if (displayContent != lastDisplayContent) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
      while (v >= 0) {
        AppWindowToken atoken=iterator.next();
        if (atoken.removed) {
          continue;
        }
        if (tokens.get(v) != atoken.token) {
          mismatch=true;
          break;
        }
        v--;
      }
    }
    if (mismatch || iterator.hasNext()) {
      Slog.w(TAG,""String_Node_Str"" + tasks);
      Slog.w(TAG,""String_Node_Str"" + iterator);
    }
  }
}","public void validateAppTokens(List<TaskGroup> tasks){
synchronized (mWindowMap) {
    int t=tasks.size() - 1;
    if (t < 0) {
      Slog.w(TAG,""String_Node_Str"");
      return;
    }
    TaskGroup task=tasks.get(0);
    int taskId=task.taskId;
    DisplayContent displayContent=mTaskIdToDisplayContents.get(taskId);
    if (displayContent == null) {
      Slog.w(TAG,""String_Node_Str"" + taskId);
      return;
    }
    boolean mismatch=false;
    AppTokenIterator iterator=displayContent.getTmpAppIterator(REVERSE_ITERATOR);
    for (; t >= 0 && !mismatch; --t) {
      task=tasks.get(t);
      List<IApplicationToken> tokens=task.tokens;
      int v=task.tokens.size() - 1;
      DisplayContent lastDisplayContent=displayContent;
      displayContent=mTaskIdToDisplayContents.get(taskId);
      if (displayContent != lastDisplayContent) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
      while (v >= 0) {
        if (!iterator.hasNext()) {
          mismatch=true;
          break;
        }
        AppWindowToken atoken=iterator.next();
        if (atoken.removed) {
          continue;
        }
        if (tokens.get(v) != atoken.token) {
          mismatch=true;
          break;
        }
        v--;
      }
    }
    if (mismatch || iterator.hasNext()) {
      Slog.w(TAG,""String_Node_Str"" + tasks);
      Slog.w(TAG,""String_Node_Str"" + iterator);
    }
  }
}"
2762,"public void validateAppTokens(List<TaskGroup> tasks){
synchronized (mWindowMap) {
    int t=tasks.size() - 1;
    if (t < 0) {
      Slog.w(TAG,""String_Node_Str"");
      return;
    }
    TaskGroup task=tasks.get(0);
    int taskId=task.taskId;
    DisplayContent displayContent=mTaskIdToDisplayContents.get(taskId);
    if (displayContent == null) {
      Slog.w(TAG,""String_Node_Str"" + taskId);
      return;
    }
    boolean mismatch=false;
    AppTokenIterator iterator=displayContent.getTmpAppIterator(REVERSE_ITERATOR);
    for (; t >= 0 && !mismatch; --t) {
      task=tasks.get(t);
      List<IApplicationToken> tokens=task.tokens;
      int v=task.tokens.size() - 1;
      DisplayContent lastDisplayContent=displayContent;
      displayContent=mTaskIdToDisplayContents.get(taskId);
      if (displayContent != lastDisplayContent) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
      while (v >= 0) {
        AppWindowToken atoken=iterator.next();
        if (atoken.removed) {
          continue;
        }
        if (tokens.get(v) != atoken.token) {
          mismatch=true;
          break;
        }
        v--;
      }
    }
    if (mismatch || iterator.hasNext()) {
      Slog.w(TAG,""String_Node_Str"" + tasks);
      Slog.w(TAG,""String_Node_Str"" + iterator);
    }
  }
}","public void validateAppTokens(List<TaskGroup> tasks){
synchronized (mWindowMap) {
    int t=tasks.size() - 1;
    if (t < 0) {
      Slog.w(TAG,""String_Node_Str"");
      return;
    }
    TaskGroup task=tasks.get(0);
    int taskId=task.taskId;
    DisplayContent displayContent=mTaskIdToDisplayContents.get(taskId);
    if (displayContent == null) {
      Slog.w(TAG,""String_Node_Str"" + taskId);
      return;
    }
    boolean mismatch=false;
    AppTokenIterator iterator=displayContent.getTmpAppIterator(REVERSE_ITERATOR);
    for (; t >= 0 && !mismatch; --t) {
      task=tasks.get(t);
      List<IApplicationToken> tokens=task.tokens;
      int v=task.tokens.size() - 1;
      DisplayContent lastDisplayContent=displayContent;
      displayContent=mTaskIdToDisplayContents.get(taskId);
      if (displayContent != lastDisplayContent) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
      while (v >= 0) {
        if (!iterator.hasNext()) {
          mismatch=true;
          break;
        }
        AppWindowToken atoken=iterator.next();
        if (atoken.removed) {
          continue;
        }
        if (tokens.get(v) != atoken.token) {
          mismatch=true;
          break;
        }
        v--;
      }
    }
    if (mismatch || iterator.hasNext()) {
      Slog.w(TAG,""String_Node_Str"" + tasks);
      Slog.w(TAG,""String_Node_Str"" + iterator);
    }
  }
}"
2763,"public void validateAppTokens(List<TaskGroup> tasks){
synchronized (mWindowMap) {
    int t=tasks.size() - 1;
    if (t < 0) {
      Slog.w(TAG,""String_Node_Str"");
      return;
    }
    TaskGroup task=tasks.get(0);
    int taskId=task.taskId;
    DisplayContent displayContent=mTaskIdToDisplayContents.get(taskId);
    if (displayContent == null) {
      Slog.w(TAG,""String_Node_Str"" + taskId);
      return;
    }
    boolean mismatch=false;
    AppTokenIterator iterator=displayContent.getTmpAppIterator(REVERSE_ITERATOR);
    for (; t >= 0 && !mismatch; --t) {
      task=tasks.get(t);
      List<IApplicationToken> tokens=task.tokens;
      int v=task.tokens.size() - 1;
      DisplayContent lastDisplayContent=displayContent;
      displayContent=mTaskIdToDisplayContents.get(taskId);
      if (displayContent != lastDisplayContent) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
      while (v >= 0) {
        AppWindowToken atoken=iterator.next();
        if (atoken.removed) {
          continue;
        }
        if (tokens.get(v) != atoken.token) {
          mismatch=true;
          break;
        }
        v--;
      }
    }
    if (mismatch || iterator.hasNext()) {
      Slog.w(TAG,""String_Node_Str"" + tasks);
      Slog.w(TAG,""String_Node_Str"" + iterator);
    }
  }
}","public void validateAppTokens(List<TaskGroup> tasks){
synchronized (mWindowMap) {
    int t=tasks.size() - 1;
    if (t < 0) {
      Slog.w(TAG,""String_Node_Str"");
      return;
    }
    TaskGroup task=tasks.get(0);
    int taskId=task.taskId;
    DisplayContent displayContent=mTaskIdToDisplayContents.get(taskId);
    if (displayContent == null) {
      Slog.w(TAG,""String_Node_Str"" + taskId);
      return;
    }
    boolean mismatch=false;
    AppTokenIterator iterator=displayContent.getTmpAppIterator(REVERSE_ITERATOR);
    for (; t >= 0 && !mismatch; --t) {
      task=tasks.get(t);
      List<IApplicationToken> tokens=task.tokens;
      int v=task.tokens.size() - 1;
      DisplayContent lastDisplayContent=displayContent;
      displayContent=mTaskIdToDisplayContents.get(taskId);
      if (displayContent != lastDisplayContent) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
      while (v >= 0) {
        if (!iterator.hasNext()) {
          mismatch=true;
          break;
        }
        AppWindowToken atoken=iterator.next();
        if (atoken.removed) {
          continue;
        }
        if (tokens.get(v) != atoken.token) {
          mismatch=true;
          break;
        }
        v--;
      }
    }
    if (mismatch || iterator.hasNext()) {
      Slog.w(TAG,""String_Node_Str"" + tasks);
      Slog.w(TAG,""String_Node_Str"" + iterator);
    }
  }
}"
2764,"/** 
 * Return the uid of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.  The returned integer is supplied by the system, so that an application can not spoof its uid.
 * @return The uid of the PendingIntent, or -1 if there isnone associated with it.
 */
public int getCreatorUid(){
  try {
    return ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
  }
 catch (  RemoteException e) {
    return -1;
  }
}","/** 
 * Return the uid of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.  The returned integer is supplied by the system, so that an application can not spoof its uid. <p class=""note"">Be careful about how you use this.  All this tells you is who created the PendingIntent.  It does <strong>not</strong> tell you who handed the PendingIntent to you: that is, PendingIntent objects are intended to be passed between applications, so the PendingIntent you receive from an application could actually be one it received from another application, meaning the result you get here will identify the original application.  Because of this, you should only use this information to identify who you expect to be interacting with through a   {@link #send} call, not who gave you the PendingIntent.</p>
 * @return The uid of the PendingIntent, or -1 if there isnone associated with it.
 */
public int getCreatorUid(){
  try {
    return ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
  }
 catch (  RemoteException e) {
    return -1;
  }
}"
2765,"/** 
 * Retrieve a PendingIntent that will start a new activity, like calling  {@link Context#startActivity(Intent) Context.startActivity(Intent)}. Note that the activity will be started outside of the context of an existing activity, so you must use the   {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 * @param context The Context in which this PendingIntent should startthe activity.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.May be null if there are no options.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getActivity(Context context,int requestCode,Intent intent,int flags,Bundle options){
  String packageName=context.getPackageName();
  String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
  try {
    intent.setAllowFds(false);
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY,packageName,null,null,requestCode,new Intent[]{intent},resolvedType != null ? new String[]{resolvedType} : null,flags,options,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * Retrieve a PendingIntent that will start a new activity, like calling  {@link Context#startActivity(Intent) Context.startActivity(Intent)}. Note that the activity will be started outside of the context of an existing activity, so you must use the   {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.<p class=""note"">For security reasons, the  {@link android.content.Intent}you supply here should almost always be an <em>explicit intent</em>, that is specify an explicit component to be delivered to through  {@link Intent#setClass(android.content.Context,Class)} Intent.setClass</p>
 * @param context The Context in which this PendingIntent should startthe activity.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.May be null if there are no options.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getActivity(Context context,int requestCode,Intent intent,int flags,Bundle options){
  String packageName=context.getPackageName();
  String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
  try {
    intent.setAllowFds(false);
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY,packageName,null,null,requestCode,new Intent[]{intent},resolvedType != null ? new String[]{resolvedType} : null,flags,options,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}"
2766,"/** 
 * Retrieve a PendingIntent that will perform a broadcast, like calling  {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
 * @param context The Context in which this PendingIntent should performthe broadcast.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getBroadcast(Context context,int requestCode,Intent intent,int flags){
  return getBroadcastAsUser(context,requestCode,intent,flags,new UserHandle(UserHandle.myUserId()));
}","/** 
 * Retrieve a PendingIntent that will perform a broadcast, like calling  {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}. <p class=""note"">For security reasons, the   {@link android.content.Intent}you supply here should almost always be an <em>explicit intent</em>, that is specify an explicit component to be delivered to through  {@link Intent#setClass(android.content.Context,Class)} Intent.setClass</p>
 * @param context The Context in which this PendingIntent should performthe broadcast.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getBroadcast(Context context,int requestCode,Intent intent,int flags){
  return getBroadcastAsUser(context,requestCode,intent,flags,new UserHandle(UserHandle.myUserId()));
}"
2767,"/** 
 * Retrieve a PendingIntent that will start a service, like calling  {@link Context#startService Context.startService()}.  The start arguments given to the service will come from the extras of the Intent.
 * @param context The Context in which this PendingIntent should startthe service.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getService(Context context,int requestCode,Intent intent,int flags){
  String packageName=context.getPackageName();
  String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
  try {
    intent.setAllowFds(false);
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE,packageName,null,null,requestCode,new Intent[]{intent},resolvedType != null ? new String[]{resolvedType} : null,flags,null,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * Retrieve a PendingIntent that will start a service, like calling  {@link Context#startService Context.startService()}.  The start arguments given to the service will come from the extras of the Intent. <p class=""note"">For security reasons, the   {@link android.content.Intent}you supply here should almost always be an <em>explicit intent</em>, that is specify an explicit component to be delivered to through  {@link Intent#setClass(android.content.Context,Class)} Intent.setClass</p>
 * @param context The Context in which this PendingIntent should startthe service.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getService(Context context,int requestCode,Intent intent,int flags){
  String packageName=context.getPackageName();
  String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
  try {
    intent.setAllowFds(false);
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE,packageName,null,null,requestCode,new Intent[]{intent},resolvedType != null ? new String[]{resolvedType} : null,flags,null,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}"
2768,"/** 
 * Like   {@link #getActivity(Context,int,Intent,int)}, but allows an array of Intents to be supplied.  The last Intent in the array is taken as the primary key for the PendingIntent, like the single Intent given to   {@link #getActivity(Context,int,Intent,int)}.  Upon sending the resulting PendingIntent, all of the Intents are started in the same way as they would be by passing them to   {@link Context#startActivities(Intent[])}. <p class=""note""> The <em>first</em> intent in the array will be started outside of the context of an existing activity, so you must use the   {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities afterthe first in the array are started in the context of the previous activity in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.) </p> <p class=""note""> The <em>last</em> intent in the array represents the key for the PendingIntent.  In other words, it is the significant element for matching (as done with the single intent given to  {@link #getActivity(Context,int,Intent,int)}, its content will be the subject of replacement by  {@link #send(Context,int,Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc. This is because it is the most specific of the supplied intents, and the UI the user actually sees when the intents are started. </p>
 * @param context The Context in which this PendingIntent should startthe activity.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getActivities(Context context,int requestCode,Intent[] intents,int flags,Bundle options){
  String packageName=context.getPackageName();
  String[] resolvedTypes=new String[intents.length];
  for (int i=0; i < intents.length; i++) {
    intents[i].setAllowFds(false);
    resolvedTypes[i]=intents[i].resolveTypeIfNeeded(context.getContentResolver());
  }
  try {
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY,packageName,null,null,requestCode,intents,resolvedTypes,flags,options,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * Like   {@link #getActivity(Context,int,Intent,int)}, but allows an array of Intents to be supplied.  The last Intent in the array is taken as the primary key for the PendingIntent, like the single Intent given to   {@link #getActivity(Context,int,Intent,int)}.  Upon sending the resulting PendingIntent, all of the Intents are started in the same way as they would be by passing them to   {@link Context#startActivities(Intent[])}. <p class=""note""> The <em>first</em> intent in the array will be started outside of the context of an existing activity, so you must use the   {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities afterthe first in the array are started in the context of the previous activity in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.) </p> <p class=""note""> The <em>last</em> intent in the array represents the key for the PendingIntent.  In other words, it is the significant element for matching (as done with the single intent given to  {@link #getActivity(Context,int,Intent,int)}, its content will be the subject of replacement by  {@link #send(Context,int,Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc. This is because it is the most specific of the supplied intents, and the UI the user actually sees when the intents are started. </p> <p class=""note"">For security reasons, the   {@link android.content.Intent} objectsyou supply here should almost always be <em>explicit intents</em>, that is specify an explicit component to be delivered to through {@link Intent#setClass(android.content.Context,Class)} Intent.setClass</p>
 * @param context The Context in which this PendingIntent should startthe activity.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getActivities(Context context,int requestCode,Intent[] intents,int flags,Bundle options){
  String packageName=context.getPackageName();
  String[] resolvedTypes=new String[intents.length];
  for (int i=0; i < intents.length; i++) {
    intents[i].setAllowFds(false);
    resolvedTypes[i]=intents[i].resolveTypeIfNeeded(context.getContentResolver());
  }
  try {
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY,packageName,null,null,requestCode,intents,resolvedTypes,flags,options,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}"
2769,"/** 
 * Return the package name of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.  The returned string is supplied by the system, so that an application can not spoof its package.
 * @return The package name of the PendingIntent, or null if there isnone associated with it.
 */
public String getCreatorPackage(){
  try {
    return ActivityManagerNative.getDefault().getPackageForIntentSender(mTarget);
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the package name of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.  The returned string is supplied by the system, so that an application can not spoof its package. <p class=""note"">Be careful about how you use this.  All this tells you is who created the PendingIntent.  It does <strong>not</strong> tell you who handed the PendingIntent to you: that is, PendingIntent objects are intended to be passed between applications, so the PendingIntent you receive from an application could actually be one it received from another application, meaning the result you get here will identify the original application.  Because of this, you should only use this information to identify who you expect to be interacting with through a   {@link #send} call, not who gave you the PendingIntent.</p>
 * @return The package name of the PendingIntent, or null if there isnone associated with it.
 */
public String getCreatorPackage(){
  try {
    return ActivityManagerNative.getDefault().getPackageForIntentSender(mTarget);
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2770,"/** 
 * Return the user handle of the application that created this PendingIntent, that is the user under which you will actually be sending the Intent.  The returned UserHandle is supplied by the system, so that an application can not spoof its user.  See  {@link android.os.Process#myUserHandle() Process.myUserHandle()} formore explanation of user handles.
 * @return The user handle of the PendingIntent, or null if there isnone associated with it.
 */
public UserHandle getCreatorUserHandle(){
  try {
    int uid=ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
    return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the user handle of the application that created this PendingIntent, that is the user under which you will actually be sending the Intent.  The returned UserHandle is supplied by the system, so that an application can not spoof its user.  See  {@link android.os.Process#myUserHandle() Process.myUserHandle()} formore explanation of user handles. <p class=""note"">Be careful about how you use this.  All this tells you is who created the PendingIntent.  It does <strong>not</strong> tell you who handed the PendingIntent to you: that is, PendingIntent objects are intended to be passed between applications, so the PendingIntent you receive from an application could actually be one it received from another application, meaning the result you get here will identify the original application.  Because of this, you should only use this information to identify who you expect to be interacting with through a  {@link #send} call, not who gave you the PendingIntent.</p>
 * @return The user handle of the PendingIntent, or null if there isnone associated with it.
 */
public UserHandle getCreatorUserHandle(){
  try {
    int uid=ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
    return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2771,"/** 
 * This is like   {@link #openFile}, but can be implemented by providers that need to be able to return sub-sections of files, often assets inside of their .apk. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>If you implement this, your clients must be able to deal with such file slices, either directly with  {@link ContentResolver#openAssetFileDescriptor}, or by using the higher-level  {@link ContentResolver#openInputStream ContentResolver.openInputStream}or   {@link ContentResolver#openOutputStream ContentResolver.openOutputStream}methods. <p class=""note"">If you are implementing this to return a full file, you should create the AssetFileDescriptor with  {@link AssetFileDescriptor#UNKNOWN_LENGTH} to be compatible withapplications that can not handle sub-sections of files.</p>
 * @param uri The URI whose file is to be opened.
 * @param mode Access mode for the file.  May be ""r"" for read-only access,""w"" for write-only access (erasing whatever data is currently in the file), ""wa"" for write-only access to append to any existing data, ""rw"" for read and write access on any existing data, and ""rwt"" for read and write access that truncates any existing file.
 * @return Returns a new AssetFileDescriptor which you can use to accessthe file.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the file.
 * @see #openFile(Uri,String)
 * @see #openFileHelper(Uri,String)
 */
public AssetFileDescriptor openAssetFile(Uri uri,String mode) throws FileNotFoundException {
  ParcelFileDescriptor fd=openFile(uri,mode);
  return fd != null ? new AssetFileDescriptor(fd,0,-1) : null;
}","/** 
 * This is like   {@link #openFile}, but can be implemented by providers that need to be able to return sub-sections of files, often assets inside of their .apk. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>If you implement this, your clients must be able to deal with such file slices, either directly with  {@link ContentResolver#openAssetFileDescriptor}, or by using the higher-level  {@link ContentResolver#openInputStream ContentResolver.openInputStream}or   {@link ContentResolver#openOutputStream ContentResolver.openOutputStream}methods. <p class=""note"">If you are implementing this to return a full file, you should create the AssetFileDescriptor with  {@link AssetFileDescriptor#UNKNOWN_LENGTH} to be compatible withapplications that can not handle sub-sections of files.</p> <p class=""note"">For use in Intents, you will want to implement  {@link #getType}to return the appropriate MIME type for the data returned here with the same URI.  This will allow intent resolution to automatically determine the data MIME type and select the appropriate matching targets as part of its operation.</p> <p class=""note"">For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by   {@link android.provider.OpenableColumns}.</p>
 * @param uri The URI whose file is to be opened.
 * @param mode Access mode for the file.  May be ""r"" for read-only access,""w"" for write-only access (erasing whatever data is currently in the file), ""wa"" for write-only access to append to any existing data, ""rw"" for read and write access on any existing data, and ""rwt"" for read and write access that truncates any existing file.
 * @return Returns a new AssetFileDescriptor which you can use to accessthe file.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the file.
 * @see #openFile(Uri,String)
 * @see #openFileHelper(Uri,String)
 * @see #getType(android.net.Uri)
 */
public AssetFileDescriptor openAssetFile(Uri uri,String mode) throws FileNotFoundException {
  ParcelFileDescriptor fd=openFile(uri,mode);
  return fd != null ? new AssetFileDescriptor(fd,0,-1) : null;
}"
2772,"/** 
 * Override this to handle requests to open a file blob. The default implementation always throws   {@link FileNotFoundException}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>This method returns a ParcelFileDescriptor, which is returned directly to the caller.  This way large data (such as images and documents) can be returned without copying the content. <p>The returned ParcelFileDescriptor is owned by the caller, so it is their responsibility to close it when done.  That is, the implementation of this method should create a new ParcelFileDescriptor for each call.
 * @param uri The URI whose file is to be opened.
 * @param mode Access mode for the file.  May be ""r"" for read-only access,""rw"" for read and write access, or ""rwt"" for read and write access that truncates any existing file.
 * @return Returns a new ParcelFileDescriptor which you can use to accessthe file.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the file.
 * @see #openAssetFile(Uri,String)
 * @see #openFileHelper(Uri,String)
 */
public ParcelFileDescriptor openFile(Uri uri,String mode) throws FileNotFoundException {
  throw new FileNotFoundException(""String_Node_Str"" + uri);
}","/** 
 * Override this to handle requests to open a file blob. The default implementation always throws   {@link FileNotFoundException}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>This method returns a ParcelFileDescriptor, which is returned directly to the caller.  This way large data (such as images and documents) can be returned without copying the content. <p>The returned ParcelFileDescriptor is owned by the caller, so it is their responsibility to close it when done.  That is, the implementation of this method should create a new ParcelFileDescriptor for each call. <p class=""note"">For use in Intents, you will want to implement   {@link #getType}to return the appropriate MIME type for the data returned here with the same URI.  This will allow intent resolution to automatically determine the data MIME type and select the appropriate matching targets as part of its operation.</p> <p class=""note"">For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by   {@link android.provider.OpenableColumns}. You may also want to support other common columns if you have additional meta-data to supply, such as   {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}in   {@link android.provider.MediaStore.MediaColumns}.</p>
 * @param uri The URI whose file is to be opened.
 * @param mode Access mode for the file.  May be ""r"" for read-only access,""rw"" for read and write access, or ""rwt"" for read and write access that truncates any existing file.
 * @return Returns a new ParcelFileDescriptor which you can use to accessthe file.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the file.
 * @see #openAssetFile(Uri,String)
 * @see #openFileHelper(Uri,String)
 * @see #getType(android.net.Uri)
 */
public ParcelFileDescriptor openFile(Uri uri,String mode) throws FileNotFoundException {
  throw new FileNotFoundException(""String_Node_Str"" + uri);
}"
2773,"/** 
 * Called by a client to open a read-only stream containing data of a particular MIME type.  This is like   {@link #openAssetFile(Uri,String)}, except the file can only be read-only and the content provider may perform data conversions to generate data of the desired type. <p>The default implementation compares the given mimeType against the result of   {@link #getType(Uri)} and, if the match, simple calls{@link #openAssetFile(Uri,String)}. <p>See   {@link ClipData} for examples of the use and implementationof this method.
 * @param uri The data in the content provider being queried.
 * @param mimeTypeFilter The type of data the client desires.  May bea pattern, such as *\/*, if the caller does not have specific type requirements; in this case the content provider will pick its best type matching the pattern.
 * @param opts Additional options from the client.  The definitions ofthese are specific to the content provider being called.
 * @return Returns a new AssetFileDescriptor from which the client canread data of the desired type.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the data.
 * @throws IllegalArgumentException Throws IllegalArgumentException if thecontent provider does not support the requested MIME type.
 * @see #getStreamTypes(Uri,String)
 * @see #openAssetFile(Uri,String)
 * @see ClipDescription#compareMimeTypes(String,String)
 */
public AssetFileDescriptor openTypedAssetFile(Uri uri,String mimeTypeFilter,Bundle opts) throws FileNotFoundException {
  if (""String_Node_Str"".equals(mimeTypeFilter)) {
    return openAssetFile(uri,""String_Node_Str"");
  }
  String baseType=getType(uri);
  if (baseType != null && ClipDescription.compareMimeTypes(baseType,mimeTypeFilter)) {
    return openAssetFile(uri,""String_Node_Str"");
  }
  throw new FileNotFoundException(""String_Node_Str"" + uri + ""String_Node_Str""+ mimeTypeFilter);
}","/** 
 * Called by a client to open a read-only stream containing data of a particular MIME type.  This is like   {@link #openAssetFile(Uri,String)}, except the file can only be read-only and the content provider may perform data conversions to generate data of the desired type. <p>The default implementation compares the given mimeType against the result of   {@link #getType(Uri)} and, if they match, simply calls{@link #openAssetFile(Uri,String)}. <p>See   {@link ClipData} for examples of the use and implementationof this method. <p class=""note"">For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by  {@link android.provider.OpenableColumns}. You may also want to support other common columns if you have additional meta-data to supply, such as   {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}in   {@link android.provider.MediaStore.MediaColumns}.</p>
 * @param uri The data in the content provider being queried.
 * @param mimeTypeFilter The type of data the client desires.  May bea pattern, such as *\/*, if the caller does not have specific type requirements; in this case the content provider will pick its best type matching the pattern.
 * @param opts Additional options from the client.  The definitions ofthese are specific to the content provider being called.
 * @return Returns a new AssetFileDescriptor from which the client canread data of the desired type.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the data.
 * @throws IllegalArgumentException Throws IllegalArgumentException if thecontent provider does not support the requested MIME type.
 * @see #getStreamTypes(Uri,String)
 * @see #openAssetFile(Uri,String)
 * @see ClipDescription#compareMimeTypes(String,String)
 */
public AssetFileDescriptor openTypedAssetFile(Uri uri,String mimeTypeFilter,Bundle opts) throws FileNotFoundException {
  if (""String_Node_Str"".equals(mimeTypeFilter)) {
    return openAssetFile(uri,""String_Node_Str"");
  }
  String baseType=getType(uri);
  if (baseType != null && ClipDescription.compareMimeTypes(baseType,mimeTypeFilter)) {
    return openAssetFile(uri,""String_Node_Str"");
  }
  throw new FileNotFoundException(""String_Node_Str"" + uri + ""String_Node_Str""+ mimeTypeFilter);
}"
2774,"/** 
 * Return the uid of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.  The returned integer is supplied by the system, so that an application can not spoof its uid.
 * @return The uid of the PendingIntent, or -1 if there isnone associated with it.
 */
public int getCreatorUid(){
  try {
    return ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
  }
 catch (  RemoteException e) {
    return -1;
  }
}","/** 
 * Return the uid of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.  The returned integer is supplied by the system, so that an application can not spoof its uid. <p class=""note"">Be careful about how you use this.  All this tells you is who created the PendingIntent.  It does <strong>not</strong> tell you who handed the PendingIntent to you: that is, PendingIntent objects are intended to be passed between applications, so the PendingIntent you receive from an application could actually be one it received from another application, meaning the result you get here will identify the original application.  Because of this, you should only use this information to identify who you expect to be interacting with through a   {@link #send} call, not who gave you the PendingIntent.</p>
 * @return The uid of the PendingIntent, or -1 if there isnone associated with it.
 */
public int getCreatorUid(){
  try {
    return ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
  }
 catch (  RemoteException e) {
    return -1;
  }
}"
2775,"/** 
 * Retrieve a PendingIntent that will start a new activity, like calling  {@link Context#startActivity(Intent) Context.startActivity(Intent)}. Note that the activity will be started outside of the context of an existing activity, so you must use the   {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 * @param context The Context in which this PendingIntent should startthe activity.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.May be null if there are no options.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getActivity(Context context,int requestCode,Intent intent,int flags,Bundle options){
  String packageName=context.getPackageName();
  String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
  try {
    intent.setAllowFds(false);
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY,packageName,null,null,requestCode,new Intent[]{intent},resolvedType != null ? new String[]{resolvedType} : null,flags,options,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * Retrieve a PendingIntent that will start a new activity, like calling  {@link Context#startActivity(Intent) Context.startActivity(Intent)}. Note that the activity will be started outside of the context of an existing activity, so you must use the   {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.<p class=""note"">For security reasons, the  {@link android.content.Intent}you supply here should almost always be an <em>explicit intent</em>, that is specify an explicit component to be delivered to through  {@link Intent#setClass(android.content.Context,Class)} Intent.setClass</p>
 * @param context The Context in which this PendingIntent should startthe activity.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.May be null if there are no options.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getActivity(Context context,int requestCode,Intent intent,int flags,Bundle options){
  String packageName=context.getPackageName();
  String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
  try {
    intent.setAllowFds(false);
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY,packageName,null,null,requestCode,new Intent[]{intent},resolvedType != null ? new String[]{resolvedType} : null,flags,options,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}"
2776,"/** 
 * Retrieve a PendingIntent that will perform a broadcast, like calling  {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
 * @param context The Context in which this PendingIntent should performthe broadcast.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getBroadcast(Context context,int requestCode,Intent intent,int flags){
  return getBroadcastAsUser(context,requestCode,intent,flags,new UserHandle(UserHandle.myUserId()));
}","/** 
 * Retrieve a PendingIntent that will perform a broadcast, like calling  {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}. <p class=""note"">For security reasons, the   {@link android.content.Intent}you supply here should almost always be an <em>explicit intent</em>, that is specify an explicit component to be delivered to through  {@link Intent#setClass(android.content.Context,Class)} Intent.setClass</p>
 * @param context The Context in which this PendingIntent should performthe broadcast.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getBroadcast(Context context,int requestCode,Intent intent,int flags){
  return getBroadcastAsUser(context,requestCode,intent,flags,new UserHandle(UserHandle.myUserId()));
}"
2777,"/** 
 * Retrieve a PendingIntent that will start a service, like calling  {@link Context#startService Context.startService()}.  The start arguments given to the service will come from the extras of the Intent.
 * @param context The Context in which this PendingIntent should startthe service.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getService(Context context,int requestCode,Intent intent,int flags){
  String packageName=context.getPackageName();
  String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
  try {
    intent.setAllowFds(false);
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE,packageName,null,null,requestCode,new Intent[]{intent},resolvedType != null ? new String[]{resolvedType} : null,flags,null,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * Retrieve a PendingIntent that will start a service, like calling  {@link Context#startService Context.startService()}.  The start arguments given to the service will come from the extras of the Intent. <p class=""note"">For security reasons, the   {@link android.content.Intent}you supply here should almost always be an <em>explicit intent</em>, that is specify an explicit component to be delivered to through  {@link Intent#setClass(android.content.Context,Class)} Intent.setClass</p>
 * @param context The Context in which this PendingIntent should startthe service.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getService(Context context,int requestCode,Intent intent,int flags){
  String packageName=context.getPackageName();
  String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
  try {
    intent.setAllowFds(false);
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE,packageName,null,null,requestCode,new Intent[]{intent},resolvedType != null ? new String[]{resolvedType} : null,flags,null,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}"
2778,"/** 
 * Like   {@link #getActivity(Context,int,Intent,int)}, but allows an array of Intents to be supplied.  The last Intent in the array is taken as the primary key for the PendingIntent, like the single Intent given to   {@link #getActivity(Context,int,Intent,int)}.  Upon sending the resulting PendingIntent, all of the Intents are started in the same way as they would be by passing them to   {@link Context#startActivities(Intent[])}. <p class=""note""> The <em>first</em> intent in the array will be started outside of the context of an existing activity, so you must use the   {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities afterthe first in the array are started in the context of the previous activity in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.) </p> <p class=""note""> The <em>last</em> intent in the array represents the key for the PendingIntent.  In other words, it is the significant element for matching (as done with the single intent given to  {@link #getActivity(Context,int,Intent,int)}, its content will be the subject of replacement by  {@link #send(Context,int,Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc. This is because it is the most specific of the supplied intents, and the UI the user actually sees when the intents are started. </p>
 * @param context The Context in which this PendingIntent should startthe activity.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getActivities(Context context,int requestCode,Intent[] intents,int flags,Bundle options){
  String packageName=context.getPackageName();
  String[] resolvedTypes=new String[intents.length];
  for (int i=0; i < intents.length; i++) {
    intents[i].setAllowFds(false);
    resolvedTypes[i]=intents[i].resolveTypeIfNeeded(context.getContentResolver());
  }
  try {
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY,packageName,null,null,requestCode,intents,resolvedTypes,flags,options,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * Like   {@link #getActivity(Context,int,Intent,int)}, but allows an array of Intents to be supplied.  The last Intent in the array is taken as the primary key for the PendingIntent, like the single Intent given to   {@link #getActivity(Context,int,Intent,int)}.  Upon sending the resulting PendingIntent, all of the Intents are started in the same way as they would be by passing them to   {@link Context#startActivities(Intent[])}. <p class=""note""> The <em>first</em> intent in the array will be started outside of the context of an existing activity, so you must use the   {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities afterthe first in the array are started in the context of the previous activity in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.) </p> <p class=""note""> The <em>last</em> intent in the array represents the key for the PendingIntent.  In other words, it is the significant element for matching (as done with the single intent given to  {@link #getActivity(Context,int,Intent,int)}, its content will be the subject of replacement by  {@link #send(Context,int,Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc. This is because it is the most specific of the supplied intents, and the UI the user actually sees when the intents are started. </p> <p class=""note"">For security reasons, the   {@link android.content.Intent} objectsyou supply here should almost always be <em>explicit intents</em>, that is specify an explicit component to be delivered to through {@link Intent#setClass(android.content.Context,Class)} Intent.setClass</p>
 * @param context The Context in which this PendingIntent should startthe activity.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getActivities(Context context,int requestCode,Intent[] intents,int flags,Bundle options){
  String packageName=context.getPackageName();
  String[] resolvedTypes=new String[intents.length];
  for (int i=0; i < intents.length; i++) {
    intents[i].setAllowFds(false);
    resolvedTypes[i]=intents[i].resolveTypeIfNeeded(context.getContentResolver());
  }
  try {
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY,packageName,null,null,requestCode,intents,resolvedTypes,flags,options,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}"
2779,"/** 
 * Return the package name of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.  The returned string is supplied by the system, so that an application can not spoof its package.
 * @return The package name of the PendingIntent, or null if there isnone associated with it.
 */
public String getCreatorPackage(){
  try {
    return ActivityManagerNative.getDefault().getPackageForIntentSender(mTarget);
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the package name of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.  The returned string is supplied by the system, so that an application can not spoof its package. <p class=""note"">Be careful about how you use this.  All this tells you is who created the PendingIntent.  It does <strong>not</strong> tell you who handed the PendingIntent to you: that is, PendingIntent objects are intended to be passed between applications, so the PendingIntent you receive from an application could actually be one it received from another application, meaning the result you get here will identify the original application.  Because of this, you should only use this information to identify who you expect to be interacting with through a   {@link #send} call, not who gave you the PendingIntent.</p>
 * @return The package name of the PendingIntent, or null if there isnone associated with it.
 */
public String getCreatorPackage(){
  try {
    return ActivityManagerNative.getDefault().getPackageForIntentSender(mTarget);
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2780,"/** 
 * Return the user handle of the application that created this PendingIntent, that is the user under which you will actually be sending the Intent.  The returned UserHandle is supplied by the system, so that an application can not spoof its user.  See  {@link android.os.Process#myUserHandle() Process.myUserHandle()} formore explanation of user handles.
 * @return The user handle of the PendingIntent, or null if there isnone associated with it.
 */
public UserHandle getCreatorUserHandle(){
  try {
    int uid=ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
    return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the user handle of the application that created this PendingIntent, that is the user under which you will actually be sending the Intent.  The returned UserHandle is supplied by the system, so that an application can not spoof its user.  See  {@link android.os.Process#myUserHandle() Process.myUserHandle()} formore explanation of user handles. <p class=""note"">Be careful about how you use this.  All this tells you is who created the PendingIntent.  It does <strong>not</strong> tell you who handed the PendingIntent to you: that is, PendingIntent objects are intended to be passed between applications, so the PendingIntent you receive from an application could actually be one it received from another application, meaning the result you get here will identify the original application.  Because of this, you should only use this information to identify who you expect to be interacting with through a  {@link #send} call, not who gave you the PendingIntent.</p>
 * @return The user handle of the PendingIntent, or null if there isnone associated with it.
 */
public UserHandle getCreatorUserHandle(){
  try {
    int uid=ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
    return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2781,"/** 
 * This is like   {@link #openFile}, but can be implemented by providers that need to be able to return sub-sections of files, often assets inside of their .apk. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>If you implement this, your clients must be able to deal with such file slices, either directly with  {@link ContentResolver#openAssetFileDescriptor}, or by using the higher-level  {@link ContentResolver#openInputStream ContentResolver.openInputStream}or   {@link ContentResolver#openOutputStream ContentResolver.openOutputStream}methods. <p class=""note"">If you are implementing this to return a full file, you should create the AssetFileDescriptor with  {@link AssetFileDescriptor#UNKNOWN_LENGTH} to be compatible withapplications that can not handle sub-sections of files.</p>
 * @param uri The URI whose file is to be opened.
 * @param mode Access mode for the file.  May be ""r"" for read-only access,""w"" for write-only access (erasing whatever data is currently in the file), ""wa"" for write-only access to append to any existing data, ""rw"" for read and write access on any existing data, and ""rwt"" for read and write access that truncates any existing file.
 * @return Returns a new AssetFileDescriptor which you can use to accessthe file.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the file.
 * @see #openFile(Uri,String)
 * @see #openFileHelper(Uri,String)
 */
public AssetFileDescriptor openAssetFile(Uri uri,String mode) throws FileNotFoundException {
  ParcelFileDescriptor fd=openFile(uri,mode);
  return fd != null ? new AssetFileDescriptor(fd,0,-1) : null;
}","/** 
 * This is like   {@link #openFile}, but can be implemented by providers that need to be able to return sub-sections of files, often assets inside of their .apk. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>If you implement this, your clients must be able to deal with such file slices, either directly with  {@link ContentResolver#openAssetFileDescriptor}, or by using the higher-level  {@link ContentResolver#openInputStream ContentResolver.openInputStream}or   {@link ContentResolver#openOutputStream ContentResolver.openOutputStream}methods. <p class=""note"">If you are implementing this to return a full file, you should create the AssetFileDescriptor with  {@link AssetFileDescriptor#UNKNOWN_LENGTH} to be compatible withapplications that can not handle sub-sections of files.</p> <p class=""note"">For use in Intents, you will want to implement  {@link #getType}to return the appropriate MIME type for the data returned here with the same URI.  This will allow intent resolution to automatically determine the data MIME type and select the appropriate matching targets as part of its operation.</p> <p class=""note"">For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by   {@link android.provider.OpenableColumns}.</p>
 * @param uri The URI whose file is to be opened.
 * @param mode Access mode for the file.  May be ""r"" for read-only access,""w"" for write-only access (erasing whatever data is currently in the file), ""wa"" for write-only access to append to any existing data, ""rw"" for read and write access on any existing data, and ""rwt"" for read and write access that truncates any existing file.
 * @return Returns a new AssetFileDescriptor which you can use to accessthe file.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the file.
 * @see #openFile(Uri,String)
 * @see #openFileHelper(Uri,String)
 * @see #getType(android.net.Uri)
 */
public AssetFileDescriptor openAssetFile(Uri uri,String mode) throws FileNotFoundException {
  ParcelFileDescriptor fd=openFile(uri,mode);
  return fd != null ? new AssetFileDescriptor(fd,0,-1) : null;
}"
2782,"/** 
 * Override this to handle requests to open a file blob. The default implementation always throws   {@link FileNotFoundException}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>This method returns a ParcelFileDescriptor, which is returned directly to the caller.  This way large data (such as images and documents) can be returned without copying the content. <p>The returned ParcelFileDescriptor is owned by the caller, so it is their responsibility to close it when done.  That is, the implementation of this method should create a new ParcelFileDescriptor for each call.
 * @param uri The URI whose file is to be opened.
 * @param mode Access mode for the file.  May be ""r"" for read-only access,""rw"" for read and write access, or ""rwt"" for read and write access that truncates any existing file.
 * @return Returns a new ParcelFileDescriptor which you can use to accessthe file.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the file.
 * @see #openAssetFile(Uri,String)
 * @see #openFileHelper(Uri,String)
 */
public ParcelFileDescriptor openFile(Uri uri,String mode) throws FileNotFoundException {
  throw new FileNotFoundException(""String_Node_Str"" + uri);
}","/** 
 * Override this to handle requests to open a file blob. The default implementation always throws   {@link FileNotFoundException}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>This method returns a ParcelFileDescriptor, which is returned directly to the caller.  This way large data (such as images and documents) can be returned without copying the content. <p>The returned ParcelFileDescriptor is owned by the caller, so it is their responsibility to close it when done.  That is, the implementation of this method should create a new ParcelFileDescriptor for each call. <p class=""note"">For use in Intents, you will want to implement   {@link #getType}to return the appropriate MIME type for the data returned here with the same URI.  This will allow intent resolution to automatically determine the data MIME type and select the appropriate matching targets as part of its operation.</p> <p class=""note"">For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by   {@link android.provider.OpenableColumns}. You may also want to support other common columns if you have additional meta-data to supply, such as   {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}in   {@link android.provider.MediaStore.MediaColumns}.</p>
 * @param uri The URI whose file is to be opened.
 * @param mode Access mode for the file.  May be ""r"" for read-only access,""rw"" for read and write access, or ""rwt"" for read and write access that truncates any existing file.
 * @return Returns a new ParcelFileDescriptor which you can use to accessthe file.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the file.
 * @see #openAssetFile(Uri,String)
 * @see #openFileHelper(Uri,String)
 * @see #getType(android.net.Uri)
 */
public ParcelFileDescriptor openFile(Uri uri,String mode) throws FileNotFoundException {
  throw new FileNotFoundException(""String_Node_Str"" + uri);
}"
2783,"/** 
 * Called by a client to open a read-only stream containing data of a particular MIME type.  This is like   {@link #openAssetFile(Uri,String)}, except the file can only be read-only and the content provider may perform data conversions to generate data of the desired type. <p>The default implementation compares the given mimeType against the result of   {@link #getType(Uri)} and, if the match, simple calls{@link #openAssetFile(Uri,String)}. <p>See   {@link ClipData} for examples of the use and implementationof this method.
 * @param uri The data in the content provider being queried.
 * @param mimeTypeFilter The type of data the client desires.  May bea pattern, such as *\/*, if the caller does not have specific type requirements; in this case the content provider will pick its best type matching the pattern.
 * @param opts Additional options from the client.  The definitions ofthese are specific to the content provider being called.
 * @return Returns a new AssetFileDescriptor from which the client canread data of the desired type.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the data.
 * @throws IllegalArgumentException Throws IllegalArgumentException if thecontent provider does not support the requested MIME type.
 * @see #getStreamTypes(Uri,String)
 * @see #openAssetFile(Uri,String)
 * @see ClipDescription#compareMimeTypes(String,String)
 */
public AssetFileDescriptor openTypedAssetFile(Uri uri,String mimeTypeFilter,Bundle opts) throws FileNotFoundException {
  if (""String_Node_Str"".equals(mimeTypeFilter)) {
    return openAssetFile(uri,""String_Node_Str"");
  }
  String baseType=getType(uri);
  if (baseType != null && ClipDescription.compareMimeTypes(baseType,mimeTypeFilter)) {
    return openAssetFile(uri,""String_Node_Str"");
  }
  throw new FileNotFoundException(""String_Node_Str"" + uri + ""String_Node_Str""+ mimeTypeFilter);
}","/** 
 * Called by a client to open a read-only stream containing data of a particular MIME type.  This is like   {@link #openAssetFile(Uri,String)}, except the file can only be read-only and the content provider may perform data conversions to generate data of the desired type. <p>The default implementation compares the given mimeType against the result of   {@link #getType(Uri)} and, if they match, simply calls{@link #openAssetFile(Uri,String)}. <p>See   {@link ClipData} for examples of the use and implementationof this method. <p class=""note"">For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by  {@link android.provider.OpenableColumns}. You may also want to support other common columns if you have additional meta-data to supply, such as   {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}in   {@link android.provider.MediaStore.MediaColumns}.</p>
 * @param uri The data in the content provider being queried.
 * @param mimeTypeFilter The type of data the client desires.  May bea pattern, such as *\/*, if the caller does not have specific type requirements; in this case the content provider will pick its best type matching the pattern.
 * @param opts Additional options from the client.  The definitions ofthese are specific to the content provider being called.
 * @return Returns a new AssetFileDescriptor from which the client canread data of the desired type.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the data.
 * @throws IllegalArgumentException Throws IllegalArgumentException if thecontent provider does not support the requested MIME type.
 * @see #getStreamTypes(Uri,String)
 * @see #openAssetFile(Uri,String)
 * @see ClipDescription#compareMimeTypes(String,String)
 */
public AssetFileDescriptor openTypedAssetFile(Uri uri,String mimeTypeFilter,Bundle opts) throws FileNotFoundException {
  if (""String_Node_Str"".equals(mimeTypeFilter)) {
    return openAssetFile(uri,""String_Node_Str"");
  }
  String baseType=getType(uri);
  if (baseType != null && ClipDescription.compareMimeTypes(baseType,mimeTypeFilter)) {
    return openAssetFile(uri,""String_Node_Str"");
  }
  throw new FileNotFoundException(""String_Node_Str"" + uri + ""String_Node_Str""+ mimeTypeFilter);
}"
2784,"/** 
 * Return the uid of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.  The returned integer is supplied by the system, so that an application can not spoof its uid.
 * @return The uid of the PendingIntent, or -1 if there isnone associated with it.
 */
public int getCreatorUid(){
  try {
    return ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
  }
 catch (  RemoteException e) {
    return -1;
  }
}","/** 
 * Return the uid of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.  The returned integer is supplied by the system, so that an application can not spoof its uid. <p class=""note"">Be careful about how you use this.  All this tells you is who created the PendingIntent.  It does <strong>not</strong> tell you who handed the PendingIntent to you: that is, PendingIntent objects are intended to be passed between applications, so the PendingIntent you receive from an application could actually be one it received from another application, meaning the result you get here will identify the original application.  Because of this, you should only use this information to identify who you expect to be interacting with through a   {@link #send} call, not who gave you the PendingIntent.</p>
 * @return The uid of the PendingIntent, or -1 if there isnone associated with it.
 */
public int getCreatorUid(){
  try {
    return ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
  }
 catch (  RemoteException e) {
    return -1;
  }
}"
2785,"/** 
 * Retrieve a PendingIntent that will start a new activity, like calling  {@link Context#startActivity(Intent) Context.startActivity(Intent)}. Note that the activity will be started outside of the context of an existing activity, so you must use the   {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 * @param context The Context in which this PendingIntent should startthe activity.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.May be null if there are no options.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getActivity(Context context,int requestCode,Intent intent,int flags,Bundle options){
  String packageName=context.getPackageName();
  String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
  try {
    intent.setAllowFds(false);
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY,packageName,null,null,requestCode,new Intent[]{intent},resolvedType != null ? new String[]{resolvedType} : null,flags,options,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * Retrieve a PendingIntent that will start a new activity, like calling  {@link Context#startActivity(Intent) Context.startActivity(Intent)}. Note that the activity will be started outside of the context of an existing activity, so you must use the   {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.<p class=""note"">For security reasons, the  {@link android.content.Intent}you supply here should almost always be an <em>explicit intent</em>, that is specify an explicit component to be delivered to through  {@link Intent#setClass(android.content.Context,Class)} Intent.setClass</p>
 * @param context The Context in which this PendingIntent should startthe activity.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.May be null if there are no options.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getActivity(Context context,int requestCode,Intent intent,int flags,Bundle options){
  String packageName=context.getPackageName();
  String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
  try {
    intent.setAllowFds(false);
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY,packageName,null,null,requestCode,new Intent[]{intent},resolvedType != null ? new String[]{resolvedType} : null,flags,options,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}"
2786,"/** 
 * Retrieve a PendingIntent that will perform a broadcast, like calling  {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
 * @param context The Context in which this PendingIntent should performthe broadcast.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getBroadcast(Context context,int requestCode,Intent intent,int flags){
  return getBroadcastAsUser(context,requestCode,intent,flags,new UserHandle(UserHandle.myUserId()));
}","/** 
 * Retrieve a PendingIntent that will perform a broadcast, like calling  {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}. <p class=""note"">For security reasons, the   {@link android.content.Intent}you supply here should almost always be an <em>explicit intent</em>, that is specify an explicit component to be delivered to through  {@link Intent#setClass(android.content.Context,Class)} Intent.setClass</p>
 * @param context The Context in which this PendingIntent should performthe broadcast.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getBroadcast(Context context,int requestCode,Intent intent,int flags){
  return getBroadcastAsUser(context,requestCode,intent,flags,new UserHandle(UserHandle.myUserId()));
}"
2787,"/** 
 * Retrieve a PendingIntent that will start a service, like calling  {@link Context#startService Context.startService()}.  The start arguments given to the service will come from the extras of the Intent.
 * @param context The Context in which this PendingIntent should startthe service.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getService(Context context,int requestCode,Intent intent,int flags){
  String packageName=context.getPackageName();
  String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
  try {
    intent.setAllowFds(false);
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE,packageName,null,null,requestCode,new Intent[]{intent},resolvedType != null ? new String[]{resolvedType} : null,flags,null,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * Retrieve a PendingIntent that will start a service, like calling  {@link Context#startService Context.startService()}.  The start arguments given to the service will come from the extras of the Intent. <p class=""note"">For security reasons, the   {@link android.content.Intent}you supply here should almost always be an <em>explicit intent</em>, that is specify an explicit component to be delivered to through  {@link Intent#setClass(android.content.Context,Class)} Intent.setClass</p>
 * @param context The Context in which this PendingIntent should startthe service.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getService(Context context,int requestCode,Intent intent,int flags){
  String packageName=context.getPackageName();
  String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
  try {
    intent.setAllowFds(false);
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE,packageName,null,null,requestCode,new Intent[]{intent},resolvedType != null ? new String[]{resolvedType} : null,flags,null,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}"
2788,"/** 
 * Like   {@link #getActivity(Context,int,Intent,int)}, but allows an array of Intents to be supplied.  The last Intent in the array is taken as the primary key for the PendingIntent, like the single Intent given to   {@link #getActivity(Context,int,Intent,int)}.  Upon sending the resulting PendingIntent, all of the Intents are started in the same way as they would be by passing them to   {@link Context#startActivities(Intent[])}. <p class=""note""> The <em>first</em> intent in the array will be started outside of the context of an existing activity, so you must use the   {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities afterthe first in the array are started in the context of the previous activity in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.) </p> <p class=""note""> The <em>last</em> intent in the array represents the key for the PendingIntent.  In other words, it is the significant element for matching (as done with the single intent given to  {@link #getActivity(Context,int,Intent,int)}, its content will be the subject of replacement by  {@link #send(Context,int,Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc. This is because it is the most specific of the supplied intents, and the UI the user actually sees when the intents are started. </p>
 * @param context The Context in which this PendingIntent should startthe activity.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getActivities(Context context,int requestCode,Intent[] intents,int flags,Bundle options){
  String packageName=context.getPackageName();
  String[] resolvedTypes=new String[intents.length];
  for (int i=0; i < intents.length; i++) {
    intents[i].setAllowFds(false);
    resolvedTypes[i]=intents[i].resolveTypeIfNeeded(context.getContentResolver());
  }
  try {
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY,packageName,null,null,requestCode,intents,resolvedTypes,flags,options,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * Like   {@link #getActivity(Context,int,Intent,int)}, but allows an array of Intents to be supplied.  The last Intent in the array is taken as the primary key for the PendingIntent, like the single Intent given to   {@link #getActivity(Context,int,Intent,int)}.  Upon sending the resulting PendingIntent, all of the Intents are started in the same way as they would be by passing them to   {@link Context#startActivities(Intent[])}. <p class=""note""> The <em>first</em> intent in the array will be started outside of the context of an existing activity, so you must use the   {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities afterthe first in the array are started in the context of the previous activity in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.) </p> <p class=""note""> The <em>last</em> intent in the array represents the key for the PendingIntent.  In other words, it is the significant element for matching (as done with the single intent given to  {@link #getActivity(Context,int,Intent,int)}, its content will be the subject of replacement by  {@link #send(Context,int,Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc. This is because it is the most specific of the supplied intents, and the UI the user actually sees when the intents are started. </p> <p class=""note"">For security reasons, the   {@link android.content.Intent} objectsyou supply here should almost always be <em>explicit intents</em>, that is specify an explicit component to be delivered to through {@link Intent#setClass(android.content.Context,Class)} Intent.setClass</p>
 * @param context The Context in which this PendingIntent should startthe activity.
 * @param requestCode Private request code for the sender (currentlynot used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT},   {@link #FLAG_NO_CREATE},  {@link #FLAG_CANCEL_CURRENT},   {@link #FLAG_UPDATE_CURRENT}, or any of the flags as supported by  {@link Intent#fillIn Intent.fillIn()} to control which unspecified partsof the intent that can be supplied when the actual send happens.
 * @return Returns an existing or new PendingIntent matching the givenparameters.  May return null only if  {@link #FLAG_NO_CREATE} has beensupplied.
 */
public static PendingIntent getActivities(Context context,int requestCode,Intent[] intents,int flags,Bundle options){
  String packageName=context.getPackageName();
  String[] resolvedTypes=new String[intents.length];
  for (int i=0; i < intents.length; i++) {
    intents[i].setAllowFds(false);
    resolvedTypes[i]=intents[i].resolveTypeIfNeeded(context.getContentResolver());
  }
  try {
    IIntentSender target=ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY,packageName,null,null,requestCode,intents,resolvedTypes,flags,options,UserHandle.myUserId());
    return target != null ? new PendingIntent(target) : null;
  }
 catch (  RemoteException e) {
  }
  return null;
}"
2789,"/** 
 * Return the package name of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.  The returned string is supplied by the system, so that an application can not spoof its package.
 * @return The package name of the PendingIntent, or null if there isnone associated with it.
 */
public String getCreatorPackage(){
  try {
    return ActivityManagerNative.getDefault().getPackageForIntentSender(mTarget);
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the package name of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.  The returned string is supplied by the system, so that an application can not spoof its package. <p class=""note"">Be careful about how you use this.  All this tells you is who created the PendingIntent.  It does <strong>not</strong> tell you who handed the PendingIntent to you: that is, PendingIntent objects are intended to be passed between applications, so the PendingIntent you receive from an application could actually be one it received from another application, meaning the result you get here will identify the original application.  Because of this, you should only use this information to identify who you expect to be interacting with through a   {@link #send} call, not who gave you the PendingIntent.</p>
 * @return The package name of the PendingIntent, or null if there isnone associated with it.
 */
public String getCreatorPackage(){
  try {
    return ActivityManagerNative.getDefault().getPackageForIntentSender(mTarget);
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2790,"/** 
 * Return the user handle of the application that created this PendingIntent, that is the user under which you will actually be sending the Intent.  The returned UserHandle is supplied by the system, so that an application can not spoof its user.  See  {@link android.os.Process#myUserHandle() Process.myUserHandle()} formore explanation of user handles.
 * @return The user handle of the PendingIntent, or null if there isnone associated with it.
 */
public UserHandle getCreatorUserHandle(){
  try {
    int uid=ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
    return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
  }
 catch (  RemoteException e) {
    return null;
  }
}","/** 
 * Return the user handle of the application that created this PendingIntent, that is the user under which you will actually be sending the Intent.  The returned UserHandle is supplied by the system, so that an application can not spoof its user.  See  {@link android.os.Process#myUserHandle() Process.myUserHandle()} formore explanation of user handles. <p class=""note"">Be careful about how you use this.  All this tells you is who created the PendingIntent.  It does <strong>not</strong> tell you who handed the PendingIntent to you: that is, PendingIntent objects are intended to be passed between applications, so the PendingIntent you receive from an application could actually be one it received from another application, meaning the result you get here will identify the original application.  Because of this, you should only use this information to identify who you expect to be interacting with through a  {@link #send} call, not who gave you the PendingIntent.</p>
 * @return The user handle of the PendingIntent, or null if there isnone associated with it.
 */
public UserHandle getCreatorUserHandle(){
  try {
    int uid=ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
    return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
  }
 catch (  RemoteException e) {
    return null;
  }
}"
2791,"/** 
 * This is like   {@link #openFile}, but can be implemented by providers that need to be able to return sub-sections of files, often assets inside of their .apk. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>If you implement this, your clients must be able to deal with such file slices, either directly with  {@link ContentResolver#openAssetFileDescriptor}, or by using the higher-level  {@link ContentResolver#openInputStream ContentResolver.openInputStream}or   {@link ContentResolver#openOutputStream ContentResolver.openOutputStream}methods. <p class=""note"">If you are implementing this to return a full file, you should create the AssetFileDescriptor with  {@link AssetFileDescriptor#UNKNOWN_LENGTH} to be compatible withapplications that can not handle sub-sections of files.</p>
 * @param uri The URI whose file is to be opened.
 * @param mode Access mode for the file.  May be ""r"" for read-only access,""w"" for write-only access (erasing whatever data is currently in the file), ""wa"" for write-only access to append to any existing data, ""rw"" for read and write access on any existing data, and ""rwt"" for read and write access that truncates any existing file.
 * @return Returns a new AssetFileDescriptor which you can use to accessthe file.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the file.
 * @see #openFile(Uri,String)
 * @see #openFileHelper(Uri,String)
 */
public AssetFileDescriptor openAssetFile(Uri uri,String mode) throws FileNotFoundException {
  ParcelFileDescriptor fd=openFile(uri,mode);
  return fd != null ? new AssetFileDescriptor(fd,0,-1) : null;
}","/** 
 * This is like   {@link #openFile}, but can be implemented by providers that need to be able to return sub-sections of files, often assets inside of their .apk. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>If you implement this, your clients must be able to deal with such file slices, either directly with  {@link ContentResolver#openAssetFileDescriptor}, or by using the higher-level  {@link ContentResolver#openInputStream ContentResolver.openInputStream}or   {@link ContentResolver#openOutputStream ContentResolver.openOutputStream}methods. <p class=""note"">If you are implementing this to return a full file, you should create the AssetFileDescriptor with  {@link AssetFileDescriptor#UNKNOWN_LENGTH} to be compatible withapplications that can not handle sub-sections of files.</p> <p class=""note"">For use in Intents, you will want to implement  {@link #getType}to return the appropriate MIME type for the data returned here with the same URI.  This will allow intent resolution to automatically determine the data MIME type and select the appropriate matching targets as part of its operation.</p> <p class=""note"">For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by   {@link android.provider.OpenableColumns}.</p>
 * @param uri The URI whose file is to be opened.
 * @param mode Access mode for the file.  May be ""r"" for read-only access,""w"" for write-only access (erasing whatever data is currently in the file), ""wa"" for write-only access to append to any existing data, ""rw"" for read and write access on any existing data, and ""rwt"" for read and write access that truncates any existing file.
 * @return Returns a new AssetFileDescriptor which you can use to accessthe file.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the file.
 * @see #openFile(Uri,String)
 * @see #openFileHelper(Uri,String)
 * @see #getType(android.net.Uri)
 */
public AssetFileDescriptor openAssetFile(Uri uri,String mode) throws FileNotFoundException {
  ParcelFileDescriptor fd=openFile(uri,mode);
  return fd != null ? new AssetFileDescriptor(fd,0,-1) : null;
}"
2792,"/** 
 * Override this to handle requests to open a file blob. The default implementation always throws   {@link FileNotFoundException}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>This method returns a ParcelFileDescriptor, which is returned directly to the caller.  This way large data (such as images and documents) can be returned without copying the content. <p>The returned ParcelFileDescriptor is owned by the caller, so it is their responsibility to close it when done.  That is, the implementation of this method should create a new ParcelFileDescriptor for each call.
 * @param uri The URI whose file is to be opened.
 * @param mode Access mode for the file.  May be ""r"" for read-only access,""rw"" for read and write access, or ""rwt"" for read and write access that truncates any existing file.
 * @return Returns a new ParcelFileDescriptor which you can use to accessthe file.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the file.
 * @see #openAssetFile(Uri,String)
 * @see #openFileHelper(Uri,String)
 */
public ParcelFileDescriptor openFile(Uri uri,String mode) throws FileNotFoundException {
  throw new FileNotFoundException(""String_Node_Str"" + uri);
}","/** 
 * Override this to handle requests to open a file blob. The default implementation always throws   {@link FileNotFoundException}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>This method returns a ParcelFileDescriptor, which is returned directly to the caller.  This way large data (such as images and documents) can be returned without copying the content. <p>The returned ParcelFileDescriptor is owned by the caller, so it is their responsibility to close it when done.  That is, the implementation of this method should create a new ParcelFileDescriptor for each call. <p class=""note"">For use in Intents, you will want to implement   {@link #getType}to return the appropriate MIME type for the data returned here with the same URI.  This will allow intent resolution to automatically determine the data MIME type and select the appropriate matching targets as part of its operation.</p> <p class=""note"">For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by   {@link android.provider.OpenableColumns}. You may also want to support other common columns if you have additional meta-data to supply, such as   {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}in   {@link android.provider.MediaStore.MediaColumns}.</p>
 * @param uri The URI whose file is to be opened.
 * @param mode Access mode for the file.  May be ""r"" for read-only access,""rw"" for read and write access, or ""rwt"" for read and write access that truncates any existing file.
 * @return Returns a new ParcelFileDescriptor which you can use to accessthe file.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the file.
 * @see #openAssetFile(Uri,String)
 * @see #openFileHelper(Uri,String)
 * @see #getType(android.net.Uri)
 */
public ParcelFileDescriptor openFile(Uri uri,String mode) throws FileNotFoundException {
  throw new FileNotFoundException(""String_Node_Str"" + uri);
}"
2793,"/** 
 * Called by a client to open a read-only stream containing data of a particular MIME type.  This is like   {@link #openAssetFile(Uri,String)}, except the file can only be read-only and the content provider may perform data conversions to generate data of the desired type. <p>The default implementation compares the given mimeType against the result of   {@link #getType(Uri)} and, if the match, simple calls{@link #openAssetFile(Uri,String)}. <p>See   {@link ClipData} for examples of the use and implementationof this method.
 * @param uri The data in the content provider being queried.
 * @param mimeTypeFilter The type of data the client desires.  May bea pattern, such as *\/*, if the caller does not have specific type requirements; in this case the content provider will pick its best type matching the pattern.
 * @param opts Additional options from the client.  The definitions ofthese are specific to the content provider being called.
 * @return Returns a new AssetFileDescriptor from which the client canread data of the desired type.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the data.
 * @throws IllegalArgumentException Throws IllegalArgumentException if thecontent provider does not support the requested MIME type.
 * @see #getStreamTypes(Uri,String)
 * @see #openAssetFile(Uri,String)
 * @see ClipDescription#compareMimeTypes(String,String)
 */
public AssetFileDescriptor openTypedAssetFile(Uri uri,String mimeTypeFilter,Bundle opts) throws FileNotFoundException {
  if (""String_Node_Str"".equals(mimeTypeFilter)) {
    return openAssetFile(uri,""String_Node_Str"");
  }
  String baseType=getType(uri);
  if (baseType != null && ClipDescription.compareMimeTypes(baseType,mimeTypeFilter)) {
    return openAssetFile(uri,""String_Node_Str"");
  }
  throw new FileNotFoundException(""String_Node_Str"" + uri + ""String_Node_Str""+ mimeTypeFilter);
}","/** 
 * Called by a client to open a read-only stream containing data of a particular MIME type.  This is like   {@link #openAssetFile(Uri,String)}, except the file can only be read-only and the content provider may perform data conversions to generate data of the desired type. <p>The default implementation compares the given mimeType against the result of   {@link #getType(Uri)} and, if they match, simply calls{@link #openAssetFile(Uri,String)}. <p>See   {@link ClipData} for examples of the use and implementationof this method. <p class=""note"">For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by  {@link android.provider.OpenableColumns}. You may also want to support other common columns if you have additional meta-data to supply, such as   {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}in   {@link android.provider.MediaStore.MediaColumns}.</p>
 * @param uri The data in the content provider being queried.
 * @param mimeTypeFilter The type of data the client desires.  May bea pattern, such as *\/*, if the caller does not have specific type requirements; in this case the content provider will pick its best type matching the pattern.
 * @param opts Additional options from the client.  The definitions ofthese are specific to the content provider being called.
 * @return Returns a new AssetFileDescriptor from which the client canread data of the desired type.
 * @throws FileNotFoundException Throws FileNotFoundException if there isno file associated with the given URI or the mode is invalid.
 * @throws SecurityException Throws SecurityException if the caller doesnot have permission to access the data.
 * @throws IllegalArgumentException Throws IllegalArgumentException if thecontent provider does not support the requested MIME type.
 * @see #getStreamTypes(Uri,String)
 * @see #openAssetFile(Uri,String)
 * @see ClipDescription#compareMimeTypes(String,String)
 */
public AssetFileDescriptor openTypedAssetFile(Uri uri,String mimeTypeFilter,Bundle opts) throws FileNotFoundException {
  if (""String_Node_Str"".equals(mimeTypeFilter)) {
    return openAssetFile(uri,""String_Node_Str"");
  }
  String baseType=getType(uri);
  if (baseType != null && ClipDescription.compareMimeTypes(baseType,mimeTypeFilter)) {
    return openAssetFile(uri,""String_Node_Str"");
  }
  throw new FileNotFoundException(""String_Node_Str"" + uri + ""String_Node_Str""+ mimeTypeFilter);
}"
2794,"public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  mAppWidgetHost=new AppWidgetHost(context,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  mAppWidgetHost.setUserId(mUserId);
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(mContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}","public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  mAppWidgetHost=new AppWidgetHost(context,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  mAppWidgetHost.setUserId(mUserId);
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(mContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}"
2795,"private void cleanupAppWidgetIds(){
  if (!KeyguardUpdateMonitor.getInstance(mContext).hasBootCompleted()) {
    mCleanupAppWidgetsOnBootCompleted=true;
    return;
  }
  int[] appWidgetIdsInKeyguardSettings=mLockPatternUtils.getAppWidgets();
  int[] appWidgetIdsBoundToHost=mAppWidgetHost.getAppWidgetIds();
  for (int i=0; i < appWidgetIdsBoundToHost.length; i++) {
    int appWidgetId=appWidgetIdsBoundToHost[i];
    if (!contains(appWidgetIdsInKeyguardSettings,appWidgetId)) {
      Log.d(TAG,""String_Node_Str"" + appWidgetId);
      mAppWidgetHost.deleteAppWidgetId(appWidgetId);
    }
  }
}","private void cleanupAppWidgetIds(){
  if (!KeyguardUpdateMonitor.getInstance(mContext).hasBootCompleted()) {
    mCleanupAppWidgetsOnBootCompleted=true;
    return;
  }
  if (!mSafeModeEnabled && !widgetsDisabledByDpm()) {
    int[] appWidgetIdsInKeyguardSettings=mLockPatternUtils.getAppWidgets();
    int[] appWidgetIdsBoundToHost=mAppWidgetHost.getAppWidgetIds();
    for (int i=0; i < appWidgetIdsBoundToHost.length; i++) {
      int appWidgetId=appWidgetIdsBoundToHost[i];
      if (!contains(appWidgetIdsInKeyguardSettings,appWidgetId)) {
        Log.d(TAG,""String_Node_Str"" + appWidgetId);
        mAppWidgetHost.deleteAppWidgetId(appWidgetId);
      }
    }
  }
}"
2796,"public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  mAppWidgetHost=new AppWidgetHost(context,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  mAppWidgetHost.setUserId(mUserId);
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(mContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}","public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  mAppWidgetHost=new AppWidgetHost(context,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  mAppWidgetHost.setUserId(mUserId);
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(mContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}"
2797,"private void cleanupAppWidgetIds(){
  if (!KeyguardUpdateMonitor.getInstance(mContext).hasBootCompleted()) {
    mCleanupAppWidgetsOnBootCompleted=true;
    return;
  }
  int[] appWidgetIdsInKeyguardSettings=mLockPatternUtils.getAppWidgets();
  int[] appWidgetIdsBoundToHost=mAppWidgetHost.getAppWidgetIds();
  for (int i=0; i < appWidgetIdsBoundToHost.length; i++) {
    int appWidgetId=appWidgetIdsBoundToHost[i];
    if (!contains(appWidgetIdsInKeyguardSettings,appWidgetId)) {
      Log.d(TAG,""String_Node_Str"" + appWidgetId);
      mAppWidgetHost.deleteAppWidgetId(appWidgetId);
    }
  }
}","private void cleanupAppWidgetIds(){
  if (!KeyguardUpdateMonitor.getInstance(mContext).hasBootCompleted()) {
    mCleanupAppWidgetsOnBootCompleted=true;
    return;
  }
  if (!mSafeModeEnabled && !widgetsDisabledByDpm()) {
    int[] appWidgetIdsInKeyguardSettings=mLockPatternUtils.getAppWidgets();
    int[] appWidgetIdsBoundToHost=mAppWidgetHost.getAppWidgetIds();
    for (int i=0; i < appWidgetIdsBoundToHost.length; i++) {
      int appWidgetId=appWidgetIdsBoundToHost[i];
      if (!contains(appWidgetIdsInKeyguardSettings,appWidgetId)) {
        Log.d(TAG,""String_Node_Str"" + appWidgetId);
        mAppWidgetHost.deleteAppWidgetId(appWidgetId);
      }
    }
  }
}"
2798,"private void resetAllInternalStateLocked(final boolean updateOnlyWhenLocaleChanged){
  if (!mSystemReady) {
    return;
  }
  final Locale newLocale=mRes.getConfiguration().locale;
  if (!updateOnlyWhenLocaleChanged || (newLocale != null && !newLocale.equals(mLastSystemLocale))) {
    if (!updateOnlyWhenLocaleChanged) {
      hideCurrentInputLocked(0,null);
      mCurMethodId=null;
      unbindCurrentMethodLocked(true,false);
    }
    if (DEBUG) {
      Slog.i(TAG,""String_Node_Str"" + newLocale);
    }
    mImListManager=new InputMethodAndSubtypeListManager(mContext,this);
    buildInputMethodListLocked(mMethodList,mMethodMap,updateOnlyWhenLocaleChanged);
    if (!updateOnlyWhenLocaleChanged) {
      final String selectedImiId=mSettings.getSelectedInputMethod();
      if (TextUtils.isEmpty(selectedImiId)) {
        resetDefaultImeLocked(mContext);
      }
    }
 else {
      resetDefaultImeLocked(mContext);
    }
    updateFromSettingsLocked(true);
    mLastSystemLocale=newLocale;
    if (!updateOnlyWhenLocaleChanged) {
      try {
        startInputInnerLocked();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"",e);
      }
    }
  }
}","private void resetAllInternalStateLocked(final boolean updateOnlyWhenLocaleChanged,final boolean resetDefaultEnabledIme){
  if (!mSystemReady) {
    return;
  }
  final Locale newLocale=mRes.getConfiguration().locale;
  if (!updateOnlyWhenLocaleChanged || (newLocale != null && !newLocale.equals(mLastSystemLocale))) {
    if (!updateOnlyWhenLocaleChanged) {
      hideCurrentInputLocked(0,null);
      mCurMethodId=null;
      unbindCurrentMethodLocked(true,false);
    }
    if (DEBUG) {
      Slog.i(TAG,""String_Node_Str"" + newLocale);
    }
    mImListManager=new InputMethodAndSubtypeListManager(mContext,this);
    buildInputMethodListLocked(mMethodList,mMethodMap,resetDefaultEnabledIme);
    if (!updateOnlyWhenLocaleChanged) {
      final String selectedImiId=mSettings.getSelectedInputMethod();
      if (TextUtils.isEmpty(selectedImiId)) {
        resetDefaultImeLocked(mContext);
      }
    }
 else {
      resetDefaultImeLocked(mContext);
    }
    updateFromSettingsLocked(true);
    mLastSystemLocale=newLocale;
    if (!updateOnlyWhenLocaleChanged) {
      try {
        startInputInnerLocked();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"",e);
      }
    }
  }
}"
2799,"private void checkCurrentLocaleChangedLocked(){
  resetAllInternalStateLocked(true);
}","private void checkCurrentLocaleChangedLocked(){
  resetAllInternalStateLocked(true,true);
}"
2800,"private void switchUserLocked(int newUserId){
  mSettings.setCurrentUserId(newUserId);
  mFileManager=new InputMethodFileManager(mMethodMap,newUserId);
  resetAllInternalStateLocked(false);
}","private void switchUserLocked(int newUserId){
  mSettings.setCurrentUserId(newUserId);
  mFileManager=new InputMethodFileManager(mMethodMap,newUserId);
  final String defaultImiId=mSettings.getSelectedInputMethod();
  final boolean needsToResetDefaultIme=TextUtils.isEmpty(defaultImiId);
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + newUserId + ""String_Node_Str""+ defaultImiId);
  }
  resetAllInternalStateLocked(false,needsToResetDefaultIme);
}"
2801,"private void resetAllInternalStateLocked(final boolean updateOnlyWhenLocaleChanged){
  if (!mSystemReady) {
    return;
  }
  final Locale newLocale=mRes.getConfiguration().locale;
  if (!updateOnlyWhenLocaleChanged || (newLocale != null && !newLocale.equals(mLastSystemLocale))) {
    if (!updateOnlyWhenLocaleChanged) {
      hideCurrentInputLocked(0,null);
      mCurMethodId=null;
      unbindCurrentMethodLocked(true,false);
    }
    if (DEBUG) {
      Slog.i(TAG,""String_Node_Str"" + newLocale);
    }
    mImListManager=new InputMethodAndSubtypeListManager(mContext,this);
    buildInputMethodListLocked(mMethodList,mMethodMap,updateOnlyWhenLocaleChanged);
    if (!updateOnlyWhenLocaleChanged) {
      final String selectedImiId=mSettings.getSelectedInputMethod();
      if (TextUtils.isEmpty(selectedImiId)) {
        resetDefaultImeLocked(mContext);
      }
    }
 else {
      resetDefaultImeLocked(mContext);
    }
    updateFromSettingsLocked(true);
    mLastSystemLocale=newLocale;
    if (!updateOnlyWhenLocaleChanged) {
      try {
        startInputInnerLocked();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"",e);
      }
    }
  }
}","private void resetAllInternalStateLocked(final boolean updateOnlyWhenLocaleChanged,final boolean resetDefaultEnabledIme){
  if (!mSystemReady) {
    return;
  }
  final Locale newLocale=mRes.getConfiguration().locale;
  if (!updateOnlyWhenLocaleChanged || (newLocale != null && !newLocale.equals(mLastSystemLocale))) {
    if (!updateOnlyWhenLocaleChanged) {
      hideCurrentInputLocked(0,null);
      mCurMethodId=null;
      unbindCurrentMethodLocked(true,false);
    }
    if (DEBUG) {
      Slog.i(TAG,""String_Node_Str"" + newLocale);
    }
    mImListManager=new InputMethodAndSubtypeListManager(mContext,this);
    buildInputMethodListLocked(mMethodList,mMethodMap,resetDefaultEnabledIme);
    if (!updateOnlyWhenLocaleChanged) {
      final String selectedImiId=mSettings.getSelectedInputMethod();
      if (TextUtils.isEmpty(selectedImiId)) {
        resetDefaultImeLocked(mContext);
      }
    }
 else {
      resetDefaultImeLocked(mContext);
    }
    updateFromSettingsLocked(true);
    mLastSystemLocale=newLocale;
    if (!updateOnlyWhenLocaleChanged) {
      try {
        startInputInnerLocked();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"",e);
      }
    }
  }
}"
2802,"private void checkCurrentLocaleChangedLocked(){
  resetAllInternalStateLocked(true);
}","private void checkCurrentLocaleChangedLocked(){
  resetAllInternalStateLocked(true,true);
}"
2803,"private void switchUserLocked(int newUserId){
  mSettings.setCurrentUserId(newUserId);
  mFileManager=new InputMethodFileManager(mMethodMap,newUserId);
  resetAllInternalStateLocked(false);
}","private void switchUserLocked(int newUserId){
  mSettings.setCurrentUserId(newUserId);
  mFileManager=new InputMethodFileManager(mMethodMap,newUserId);
  final String defaultImiId=mSettings.getSelectedInputMethod();
  final boolean needsToResetDefaultIme=TextUtils.isEmpty(defaultImiId);
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + newUserId + ""String_Node_Str""+ defaultImiId);
  }
  resetAllInternalStateLocked(false,needsToResetDefaultIme);
}"
2804,"public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  mAppWidgetHost=new AppWidgetHost(context,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  mAppWidgetHost.setUserId(mUserId);
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(mContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}","public KeyguardHostView(Context context,AttributeSet attrs){
  super(context,attrs);
  mLockPatternUtils=new LockPatternUtils(context);
  mUserId=mLockPatternUtils.getCurrentUser();
  mAppWidgetHost=new AppWidgetHost(context,APPWIDGET_HOST_ID,mOnClickHandler,Looper.myLooper());
  mAppWidgetHost.setUserId(mUserId);
  DevicePolicyManager dpm=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
  if (dpm != null) {
    mDisabledFeatures=getDisabledFeatures(dpm);
    mCameraDisabled=dpm.getCameraDisabled(null);
  }
  mSafeModeEnabled=LockPatternUtils.isSafeModeEnabled();
  cleanupAppWidgetIds();
  mAppWidgetManager=AppWidgetManager.getInstance(mContext);
  mSecurityModel=new KeyguardSecurityModel(context);
  mViewStateManager=new KeyguardViewStateManager(this);
  mUserSetupCompleted=Settings.Secure.getIntForUser(mContext.getContentResolver(),Settings.Secure.USER_SETUP_COMPLETE,0,UserHandle.USER_CURRENT) != 0;
  if (mSafeModeEnabled) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
  if ((mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA) != 0) {
    Log.v(TAG,""String_Node_Str"");
  }
}"
2805,"private void cleanupAppWidgetIds(){
  if (!KeyguardUpdateMonitor.getInstance(mContext).hasBootCompleted()) {
    mCleanupAppWidgetsOnBootCompleted=true;
    return;
  }
  int[] appWidgetIdsInKeyguardSettings=mLockPatternUtils.getAppWidgets();
  int[] appWidgetIdsBoundToHost=mAppWidgetHost.getAppWidgetIds();
  for (int i=0; i < appWidgetIdsBoundToHost.length; i++) {
    int appWidgetId=appWidgetIdsBoundToHost[i];
    if (!contains(appWidgetIdsInKeyguardSettings,appWidgetId)) {
      Log.d(TAG,""String_Node_Str"" + appWidgetId);
      mAppWidgetHost.deleteAppWidgetId(appWidgetId);
    }
  }
}","private void cleanupAppWidgetIds(){
  if (!KeyguardUpdateMonitor.getInstance(mContext).hasBootCompleted()) {
    mCleanupAppWidgetsOnBootCompleted=true;
    return;
  }
  if (!mSafeModeEnabled && !widgetsDisabledByDpm()) {
    int[] appWidgetIdsInKeyguardSettings=mLockPatternUtils.getAppWidgets();
    int[] appWidgetIdsBoundToHost=mAppWidgetHost.getAppWidgetIds();
    for (int i=0; i < appWidgetIdsBoundToHost.length; i++) {
      int appWidgetId=appWidgetIdsBoundToHost[i];
      if (!contains(appWidgetIdsInKeyguardSettings,appWidgetId)) {
        Log.d(TAG,""String_Node_Str"" + appWidgetId);
        mAppWidgetHost.deleteAppWidgetId(appWidgetId);
      }
    }
  }
}"
2806,"private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}","private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}"
2807,"private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}","private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}"
2808,"private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}","private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}"
2809,"private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}","private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}"
2810,"private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}","private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}"
2811,"private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}","private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}"
2812,"private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}","private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}"
2813,"private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}","private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}"
2814,"/** 
 * Operates like   {@link #markAfter(String)}, but uses a given heuristic to estimate the  {@code str}'s directionality.
 * @param str String after which the mark may need to appear.
 * @param heuristic The text direction heuristic that will be used to estimate the {@code str}'s directionality.
 * @return LRM for RTL text in LTR context; RLM for LTR text in RTL context;else, the empty string.
 */
public String markAfter(String str,TextDirectionHeuristic heuristic){
  final boolean isRtl=heuristic.isRtl(str,0,str.length());
  if (!isRtlContext && (isRtl || getExitDir(str) == Dir.RTL)) {
    return LRM_STRING;
  }
  if (isRtlContext && (!isRtl || getExitDir(str) == Dir.LTR)) {
    return RLM_STRING;
  }
  return EMPTY_STRING;
}","/** 
 * Operates like   {@link #markAfter(String)}, but uses a given heuristic to estimate the  {@code str}'s directionality.
 * @param str String after which the mark may need to appear.
 * @param heuristic The text direction heuristic that will be used to estimate the {@code str}'s directionality.
 * @return LRM for RTL text in LTR context; RLM for LTR text in RTL context;else, the empty string.
 */
public String markAfter(String str,TextDirectionHeuristic heuristic){
  final boolean isRtl=heuristic.isRtl(str,0,str.length());
  if (!isRtlContext && (isRtl || getExitDir(str) == DIR_RTL)) {
    return LRM_STRING;
  }
  if (isRtlContext && (!isRtl || getExitDir(str) == DIR_LTR)) {
    return RLM_STRING;
  }
  return EMPTY_STRING;
}"
2815,"/** 
 * Returns the directionality of the last character with strong directionality in the string, or Dir.UNKNOWN if none was encountered. For efficiency, actually scans backwards from the end of the string. Treats a non-BN character between an LRE/RLE/LRO/RLO and its matching PDF as a strong character, LTR after LRE/LRO, and RTL after RLE/RLO. The results are undefined for a string containing unbalanced LRE/RLE/LRO/RLO/PDF characters.
 */
Dir getExitDir(){
  charIndex=length;
  int embeddingLevel=0;
  int lastNonEmptyEmbeddingLevel=0;
  while (charIndex > 0) {
switch (dirTypeBackward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT:
      if (embeddingLevel == 0) {
        return Dir.LTR;
      }
    if (lastNonEmptyEmbeddingLevel == 0) {
      lastNonEmptyEmbeddingLevel=embeddingLevel;
    }
  break;
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
if (lastNonEmptyEmbeddingLevel == embeddingLevel) {
  return Dir.LTR;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC:
if (embeddingLevel == 0) {
return Dir.RTL;
}
if (lastNonEmptyEmbeddingLevel == 0) {
lastNonEmptyEmbeddingLevel=embeddingLevel;
}
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
if (lastNonEmptyEmbeddingLevel == embeddingLevel) {
return Dir.RTL;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
++embeddingLevel;
break;
case Character.DIRECTIONALITY_BOUNDARY_NEUTRAL:
break;
default :
if (lastNonEmptyEmbeddingLevel == 0) {
lastNonEmptyEmbeddingLevel=embeddingLevel;
}
break;
}
}
return Dir.UNKNOWN;
}","/** 
 * Returns the directionality of the last character with strong directionality in the string, or DIR_UNKNOWN if none was encountered. For efficiency, actually scans backwards from the end of the string. Treats a non-BN character between an LRE/RLE/LRO/RLO and its matching PDF as a strong character, LTR after LRE/LRO, and RTL after RLE/RLO. The results are undefined for a string containing unbalanced LRE/RLE/LRO/RLO/PDF characters.
 */
int getExitDir(){
  charIndex=length;
  int embeddingLevel=0;
  int lastNonEmptyEmbeddingLevel=0;
  while (charIndex > 0) {
switch (dirTypeBackward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT:
      if (embeddingLevel == 0) {
        return DIR_LTR;
      }
    if (lastNonEmptyEmbeddingLevel == 0) {
      lastNonEmptyEmbeddingLevel=embeddingLevel;
    }
  break;
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
if (lastNonEmptyEmbeddingLevel == embeddingLevel) {
  return DIR_LTR;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC:
if (embeddingLevel == 0) {
return DIR_RTL;
}
if (lastNonEmptyEmbeddingLevel == 0) {
lastNonEmptyEmbeddingLevel=embeddingLevel;
}
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
if (lastNonEmptyEmbeddingLevel == embeddingLevel) {
return DIR_RTL;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
++embeddingLevel;
break;
case Character.DIRECTIONALITY_BOUNDARY_NEUTRAL:
break;
default :
if (lastNonEmptyEmbeddingLevel == 0) {
lastNonEmptyEmbeddingLevel=embeddingLevel;
}
break;
}
}
return DIR_UNKNOWN;
}"
2816,"/** 
 * Returns the directionality of the first character with strong directionality in the string, or Dir.UNKNOWN if none was encountered. Treats a non-BN character between an LRE/RLE/LRO/RLO and its matching PDF as a strong character, LTR after LRE/LRO, and RTL after RLE/RLO. The results are undefined for a string containing unbalanced LRE/RLE/LRO/RLO/PDF characters.
 */
Dir getEntryDir(){
  charIndex=0;
  int embeddingLevel=0;
  Dir embeddingLevelDir=Dir.UNKNOWN;
  int firstNonEmptyEmbeddingLevel=0;
  while (charIndex < length && firstNonEmptyEmbeddingLevel == 0) {
switch (dirTypeForward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
      ++embeddingLevel;
    embeddingLevelDir=Dir.LTR;
  break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
++embeddingLevel;
embeddingLevelDir=Dir.RTL;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
--embeddingLevel;
embeddingLevelDir=Dir.UNKNOWN;
break;
case Character.DIRECTIONALITY_BOUNDARY_NEUTRAL:
break;
case Character.DIRECTIONALITY_LEFT_TO_RIGHT:
if (embeddingLevel == 0) {
return Dir.LTR;
}
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC:
if (embeddingLevel == 0) {
return Dir.RTL;
}
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
default :
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
}
}
if (firstNonEmptyEmbeddingLevel == 0) {
return Dir.UNKNOWN;
}
if (embeddingLevelDir != Dir.UNKNOWN) {
return embeddingLevelDir;
}
while (charIndex > 0) {
switch (dirTypeBackward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
if (firstNonEmptyEmbeddingLevel == embeddingLevel) {
return Dir.LTR;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
if (firstNonEmptyEmbeddingLevel == embeddingLevel) {
return Dir.RTL;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
++embeddingLevel;
break;
}
}
return Dir.UNKNOWN;
}","/** 
 * Returns the directionality of the first character with strong directionality in the string, or DIR_UNKNOWN if none was encountered. Treats a non-BN character between an LRE/RLE/LRO/RLO and its matching PDF as a strong character, LTR after LRE/LRO, and RTL after RLE/RLO. The results are undefined for a string containing unbalanced LRE/RLE/LRO/RLO/PDF characters.
 */
int getEntryDir(){
  charIndex=0;
  int embeddingLevel=0;
  int embeddingLevelDir=DIR_UNKNOWN;
  int firstNonEmptyEmbeddingLevel=0;
  while (charIndex < length && firstNonEmptyEmbeddingLevel == 0) {
switch (dirTypeForward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
      ++embeddingLevel;
    embeddingLevelDir=DIR_LTR;
  break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
++embeddingLevel;
embeddingLevelDir=DIR_RTL;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
--embeddingLevel;
embeddingLevelDir=DIR_UNKNOWN;
break;
case Character.DIRECTIONALITY_BOUNDARY_NEUTRAL:
break;
case Character.DIRECTIONALITY_LEFT_TO_RIGHT:
if (embeddingLevel == 0) {
return DIR_LTR;
}
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC:
if (embeddingLevel == 0) {
return DIR_RTL;
}
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
default :
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
}
}
if (firstNonEmptyEmbeddingLevel == 0) {
return DIR_UNKNOWN;
}
if (embeddingLevelDir != DIR_UNKNOWN) {
return embeddingLevelDir;
}
while (charIndex > 0) {
switch (dirTypeBackward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
if (firstNonEmptyEmbeddingLevel == embeddingLevel) {
return DIR_LTR;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
if (firstNonEmptyEmbeddingLevel == embeddingLevel) {
return DIR_RTL;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
++embeddingLevel;
break;
}
}
return DIR_UNKNOWN;
}"
2817,"/** 
 * Operates like   {@link #markBefore(String)}, but uses a given heuristic to estimate the  {@code str}'s directionality.
 * @param str String before which the mark may need to appear.
 * @param heuristic The text direction heuristic that will be used to estimate the {@code str}'s directionality.
 * @return LRM for RTL text in LTR context; RLM for LTR text in RTL context;else, the empty string.
 */
public String markBefore(String str,TextDirectionHeuristic heuristic){
  final boolean isRtl=heuristic.isRtl(str,0,str.length());
  if (!isRtlContext && (isRtl || getEntryDir(str) == Dir.RTL)) {
    return LRM_STRING;
  }
  if (isRtlContext && (!isRtl || getEntryDir(str) == Dir.LTR)) {
    return RLM_STRING;
  }
  return EMPTY_STRING;
}","/** 
 * Operates like   {@link #markBefore(String)}, but uses a given heuristic to estimate the  {@code str}'s directionality.
 * @param str String before which the mark may need to appear.
 * @param heuristic The text direction heuristic that will be used to estimate the {@code str}'s directionality.
 * @return LRM for RTL text in LTR context; RLM for LTR text in RTL context;else, the empty string.
 */
public String markBefore(String str,TextDirectionHeuristic heuristic){
  final boolean isRtl=heuristic.isRtl(str,0,str.length());
  if (!isRtlContext && (isRtl || getEntryDir(str) == DIR_RTL)) {
    return LRM_STRING;
  }
  if (isRtlContext && (!isRtl || getEntryDir(str) == DIR_LTR)) {
    return RLM_STRING;
  }
  return EMPTY_STRING;
}"
2818,"private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}","private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}"
2819,"private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}","private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}"
2820,"/** 
 * Operates like   {@link #markAfter(String)}, but uses a given heuristic to estimate the  {@code str}'s directionality.
 * @param str String after which the mark may need to appear.
 * @param heuristic The text direction heuristic that will be used to estimate the {@code str}'s directionality.
 * @return LRM for RTL text in LTR context; RLM for LTR text in RTL context;else, the empty string.
 */
public String markAfter(String str,TextDirectionHeuristic heuristic){
  final boolean isRtl=heuristic.isRtl(str,0,str.length());
  if (!isRtlContext && (isRtl || getExitDir(str) == Dir.RTL)) {
    return LRM_STRING;
  }
  if (isRtlContext && (!isRtl || getExitDir(str) == Dir.LTR)) {
    return RLM_STRING;
  }
  return EMPTY_STRING;
}","/** 
 * Operates like   {@link #markAfter(String)}, but uses a given heuristic to estimate the  {@code str}'s directionality.
 * @param str String after which the mark may need to appear.
 * @param heuristic The text direction heuristic that will be used to estimate the {@code str}'s directionality.
 * @return LRM for RTL text in LTR context; RLM for LTR text in RTL context;else, the empty string.
 */
public String markAfter(String str,TextDirectionHeuristic heuristic){
  final boolean isRtl=heuristic.isRtl(str,0,str.length());
  if (!isRtlContext && (isRtl || getExitDir(str) == DIR_RTL)) {
    return LRM_STRING;
  }
  if (isRtlContext && (!isRtl || getExitDir(str) == DIR_LTR)) {
    return RLM_STRING;
  }
  return EMPTY_STRING;
}"
2821,"/** 
 * Returns the directionality of the last character with strong directionality in the string, or Dir.UNKNOWN if none was encountered. For efficiency, actually scans backwards from the end of the string. Treats a non-BN character between an LRE/RLE/LRO/RLO and its matching PDF as a strong character, LTR after LRE/LRO, and RTL after RLE/RLO. The results are undefined for a string containing unbalanced LRE/RLE/LRO/RLO/PDF characters.
 */
Dir getExitDir(){
  charIndex=length;
  int embeddingLevel=0;
  int lastNonEmptyEmbeddingLevel=0;
  while (charIndex > 0) {
switch (dirTypeBackward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT:
      if (embeddingLevel == 0) {
        return Dir.LTR;
      }
    if (lastNonEmptyEmbeddingLevel == 0) {
      lastNonEmptyEmbeddingLevel=embeddingLevel;
    }
  break;
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
if (lastNonEmptyEmbeddingLevel == embeddingLevel) {
  return Dir.LTR;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC:
if (embeddingLevel == 0) {
return Dir.RTL;
}
if (lastNonEmptyEmbeddingLevel == 0) {
lastNonEmptyEmbeddingLevel=embeddingLevel;
}
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
if (lastNonEmptyEmbeddingLevel == embeddingLevel) {
return Dir.RTL;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
++embeddingLevel;
break;
case Character.DIRECTIONALITY_BOUNDARY_NEUTRAL:
break;
default :
if (lastNonEmptyEmbeddingLevel == 0) {
lastNonEmptyEmbeddingLevel=embeddingLevel;
}
break;
}
}
return Dir.UNKNOWN;
}","/** 
 * Returns the directionality of the last character with strong directionality in the string, or DIR_UNKNOWN if none was encountered. For efficiency, actually scans backwards from the end of the string. Treats a non-BN character between an LRE/RLE/LRO/RLO and its matching PDF as a strong character, LTR after LRE/LRO, and RTL after RLE/RLO. The results are undefined for a string containing unbalanced LRE/RLE/LRO/RLO/PDF characters.
 */
int getExitDir(){
  charIndex=length;
  int embeddingLevel=0;
  int lastNonEmptyEmbeddingLevel=0;
  while (charIndex > 0) {
switch (dirTypeBackward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT:
      if (embeddingLevel == 0) {
        return DIR_LTR;
      }
    if (lastNonEmptyEmbeddingLevel == 0) {
      lastNonEmptyEmbeddingLevel=embeddingLevel;
    }
  break;
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
if (lastNonEmptyEmbeddingLevel == embeddingLevel) {
  return DIR_LTR;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC:
if (embeddingLevel == 0) {
return DIR_RTL;
}
if (lastNonEmptyEmbeddingLevel == 0) {
lastNonEmptyEmbeddingLevel=embeddingLevel;
}
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
if (lastNonEmptyEmbeddingLevel == embeddingLevel) {
return DIR_RTL;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
++embeddingLevel;
break;
case Character.DIRECTIONALITY_BOUNDARY_NEUTRAL:
break;
default :
if (lastNonEmptyEmbeddingLevel == 0) {
lastNonEmptyEmbeddingLevel=embeddingLevel;
}
break;
}
}
return DIR_UNKNOWN;
}"
2822,"/** 
 * Returns the directionality of the first character with strong directionality in the string, or Dir.UNKNOWN if none was encountered. Treats a non-BN character between an LRE/RLE/LRO/RLO and its matching PDF as a strong character, LTR after LRE/LRO, and RTL after RLE/RLO. The results are undefined for a string containing unbalanced LRE/RLE/LRO/RLO/PDF characters.
 */
Dir getEntryDir(){
  charIndex=0;
  int embeddingLevel=0;
  Dir embeddingLevelDir=Dir.UNKNOWN;
  int firstNonEmptyEmbeddingLevel=0;
  while (charIndex < length && firstNonEmptyEmbeddingLevel == 0) {
switch (dirTypeForward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
      ++embeddingLevel;
    embeddingLevelDir=Dir.LTR;
  break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
++embeddingLevel;
embeddingLevelDir=Dir.RTL;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
--embeddingLevel;
embeddingLevelDir=Dir.UNKNOWN;
break;
case Character.DIRECTIONALITY_BOUNDARY_NEUTRAL:
break;
case Character.DIRECTIONALITY_LEFT_TO_RIGHT:
if (embeddingLevel == 0) {
return Dir.LTR;
}
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC:
if (embeddingLevel == 0) {
return Dir.RTL;
}
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
default :
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
}
}
if (firstNonEmptyEmbeddingLevel == 0) {
return Dir.UNKNOWN;
}
if (embeddingLevelDir != Dir.UNKNOWN) {
return embeddingLevelDir;
}
while (charIndex > 0) {
switch (dirTypeBackward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
if (firstNonEmptyEmbeddingLevel == embeddingLevel) {
return Dir.LTR;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
if (firstNonEmptyEmbeddingLevel == embeddingLevel) {
return Dir.RTL;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
++embeddingLevel;
break;
}
}
return Dir.UNKNOWN;
}","/** 
 * Returns the directionality of the first character with strong directionality in the string, or DIR_UNKNOWN if none was encountered. Treats a non-BN character between an LRE/RLE/LRO/RLO and its matching PDF as a strong character, LTR after LRE/LRO, and RTL after RLE/RLO. The results are undefined for a string containing unbalanced LRE/RLE/LRO/RLO/PDF characters.
 */
int getEntryDir(){
  charIndex=0;
  int embeddingLevel=0;
  int embeddingLevelDir=DIR_UNKNOWN;
  int firstNonEmptyEmbeddingLevel=0;
  while (charIndex < length && firstNonEmptyEmbeddingLevel == 0) {
switch (dirTypeForward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
      ++embeddingLevel;
    embeddingLevelDir=DIR_LTR;
  break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
++embeddingLevel;
embeddingLevelDir=DIR_RTL;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
--embeddingLevel;
embeddingLevelDir=DIR_UNKNOWN;
break;
case Character.DIRECTIONALITY_BOUNDARY_NEUTRAL:
break;
case Character.DIRECTIONALITY_LEFT_TO_RIGHT:
if (embeddingLevel == 0) {
return DIR_LTR;
}
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC:
if (embeddingLevel == 0) {
return DIR_RTL;
}
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
default :
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
}
}
if (firstNonEmptyEmbeddingLevel == 0) {
return DIR_UNKNOWN;
}
if (embeddingLevelDir != DIR_UNKNOWN) {
return embeddingLevelDir;
}
while (charIndex > 0) {
switch (dirTypeBackward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
if (firstNonEmptyEmbeddingLevel == embeddingLevel) {
return DIR_LTR;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
if (firstNonEmptyEmbeddingLevel == embeddingLevel) {
return DIR_RTL;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
++embeddingLevel;
break;
}
}
return DIR_UNKNOWN;
}"
2823,"/** 
 * Operates like   {@link #markBefore(String)}, but uses a given heuristic to estimate the  {@code str}'s directionality.
 * @param str String before which the mark may need to appear.
 * @param heuristic The text direction heuristic that will be used to estimate the {@code str}'s directionality.
 * @return LRM for RTL text in LTR context; RLM for LTR text in RTL context;else, the empty string.
 */
public String markBefore(String str,TextDirectionHeuristic heuristic){
  final boolean isRtl=heuristic.isRtl(str,0,str.length());
  if (!isRtlContext && (isRtl || getEntryDir(str) == Dir.RTL)) {
    return LRM_STRING;
  }
  if (isRtlContext && (!isRtl || getEntryDir(str) == Dir.LTR)) {
    return RLM_STRING;
  }
  return EMPTY_STRING;
}","/** 
 * Operates like   {@link #markBefore(String)}, but uses a given heuristic to estimate the  {@code str}'s directionality.
 * @param str String before which the mark may need to appear.
 * @param heuristic The text direction heuristic that will be used to estimate the {@code str}'s directionality.
 * @return LRM for RTL text in LTR context; RLM for LTR text in RTL context;else, the empty string.
 */
public String markBefore(String str,TextDirectionHeuristic heuristic){
  final boolean isRtl=heuristic.isRtl(str,0,str.length());
  if (!isRtlContext && (isRtl || getEntryDir(str) == DIR_RTL)) {
    return LRM_STRING;
  }
  if (isRtlContext && (!isRtl || getEntryDir(str) == DIR_LTR)) {
    return RLM_STRING;
  }
  return EMPTY_STRING;
}"
2824,"private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}","private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}"
2825,"private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}","private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}"
2826,"/** 
 * Operates like   {@link #markAfter(String)}, but uses a given heuristic to estimate the  {@code str}'s directionality.
 * @param str String after which the mark may need to appear.
 * @param heuristic The text direction heuristic that will be used to estimate the {@code str}'s directionality.
 * @return LRM for RTL text in LTR context; RLM for LTR text in RTL context;else, the empty string.
 */
public String markAfter(String str,TextDirectionHeuristic heuristic){
  final boolean isRtl=heuristic.isRtl(str,0,str.length());
  if (!isRtlContext && (isRtl || getExitDir(str) == Dir.RTL)) {
    return LRM_STRING;
  }
  if (isRtlContext && (!isRtl || getExitDir(str) == Dir.LTR)) {
    return RLM_STRING;
  }
  return EMPTY_STRING;
}","/** 
 * Operates like   {@link #markAfter(String)}, but uses a given heuristic to estimate the  {@code str}'s directionality.
 * @param str String after which the mark may need to appear.
 * @param heuristic The text direction heuristic that will be used to estimate the {@code str}'s directionality.
 * @return LRM for RTL text in LTR context; RLM for LTR text in RTL context;else, the empty string.
 */
public String markAfter(String str,TextDirectionHeuristic heuristic){
  final boolean isRtl=heuristic.isRtl(str,0,str.length());
  if (!isRtlContext && (isRtl || getExitDir(str) == DIR_RTL)) {
    return LRM_STRING;
  }
  if (isRtlContext && (!isRtl || getExitDir(str) == DIR_LTR)) {
    return RLM_STRING;
  }
  return EMPTY_STRING;
}"
2827,"/** 
 * Returns the directionality of the last character with strong directionality in the string, or Dir.UNKNOWN if none was encountered. For efficiency, actually scans backwards from the end of the string. Treats a non-BN character between an LRE/RLE/LRO/RLO and its matching PDF as a strong character, LTR after LRE/LRO, and RTL after RLE/RLO. The results are undefined for a string containing unbalanced LRE/RLE/LRO/RLO/PDF characters.
 */
Dir getExitDir(){
  charIndex=length;
  int embeddingLevel=0;
  int lastNonEmptyEmbeddingLevel=0;
  while (charIndex > 0) {
switch (dirTypeBackward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT:
      if (embeddingLevel == 0) {
        return Dir.LTR;
      }
    if (lastNonEmptyEmbeddingLevel == 0) {
      lastNonEmptyEmbeddingLevel=embeddingLevel;
    }
  break;
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
if (lastNonEmptyEmbeddingLevel == embeddingLevel) {
  return Dir.LTR;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC:
if (embeddingLevel == 0) {
return Dir.RTL;
}
if (lastNonEmptyEmbeddingLevel == 0) {
lastNonEmptyEmbeddingLevel=embeddingLevel;
}
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
if (lastNonEmptyEmbeddingLevel == embeddingLevel) {
return Dir.RTL;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
++embeddingLevel;
break;
case Character.DIRECTIONALITY_BOUNDARY_NEUTRAL:
break;
default :
if (lastNonEmptyEmbeddingLevel == 0) {
lastNonEmptyEmbeddingLevel=embeddingLevel;
}
break;
}
}
return Dir.UNKNOWN;
}","/** 
 * Returns the directionality of the last character with strong directionality in the string, or DIR_UNKNOWN if none was encountered. For efficiency, actually scans backwards from the end of the string. Treats a non-BN character between an LRE/RLE/LRO/RLO and its matching PDF as a strong character, LTR after LRE/LRO, and RTL after RLE/RLO. The results are undefined for a string containing unbalanced LRE/RLE/LRO/RLO/PDF characters.
 */
int getExitDir(){
  charIndex=length;
  int embeddingLevel=0;
  int lastNonEmptyEmbeddingLevel=0;
  while (charIndex > 0) {
switch (dirTypeBackward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT:
      if (embeddingLevel == 0) {
        return DIR_LTR;
      }
    if (lastNonEmptyEmbeddingLevel == 0) {
      lastNonEmptyEmbeddingLevel=embeddingLevel;
    }
  break;
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
if (lastNonEmptyEmbeddingLevel == embeddingLevel) {
  return DIR_LTR;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC:
if (embeddingLevel == 0) {
return DIR_RTL;
}
if (lastNonEmptyEmbeddingLevel == 0) {
lastNonEmptyEmbeddingLevel=embeddingLevel;
}
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
if (lastNonEmptyEmbeddingLevel == embeddingLevel) {
return DIR_RTL;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
++embeddingLevel;
break;
case Character.DIRECTIONALITY_BOUNDARY_NEUTRAL:
break;
default :
if (lastNonEmptyEmbeddingLevel == 0) {
lastNonEmptyEmbeddingLevel=embeddingLevel;
}
break;
}
}
return DIR_UNKNOWN;
}"
2828,"/** 
 * Returns the directionality of the first character with strong directionality in the string, or Dir.UNKNOWN if none was encountered. Treats a non-BN character between an LRE/RLE/LRO/RLO and its matching PDF as a strong character, LTR after LRE/LRO, and RTL after RLE/RLO. The results are undefined for a string containing unbalanced LRE/RLE/LRO/RLO/PDF characters.
 */
Dir getEntryDir(){
  charIndex=0;
  int embeddingLevel=0;
  Dir embeddingLevelDir=Dir.UNKNOWN;
  int firstNonEmptyEmbeddingLevel=0;
  while (charIndex < length && firstNonEmptyEmbeddingLevel == 0) {
switch (dirTypeForward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
      ++embeddingLevel;
    embeddingLevelDir=Dir.LTR;
  break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
++embeddingLevel;
embeddingLevelDir=Dir.RTL;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
--embeddingLevel;
embeddingLevelDir=Dir.UNKNOWN;
break;
case Character.DIRECTIONALITY_BOUNDARY_NEUTRAL:
break;
case Character.DIRECTIONALITY_LEFT_TO_RIGHT:
if (embeddingLevel == 0) {
return Dir.LTR;
}
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC:
if (embeddingLevel == 0) {
return Dir.RTL;
}
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
default :
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
}
}
if (firstNonEmptyEmbeddingLevel == 0) {
return Dir.UNKNOWN;
}
if (embeddingLevelDir != Dir.UNKNOWN) {
return embeddingLevelDir;
}
while (charIndex > 0) {
switch (dirTypeBackward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
if (firstNonEmptyEmbeddingLevel == embeddingLevel) {
return Dir.LTR;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
if (firstNonEmptyEmbeddingLevel == embeddingLevel) {
return Dir.RTL;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
++embeddingLevel;
break;
}
}
return Dir.UNKNOWN;
}","/** 
 * Returns the directionality of the first character with strong directionality in the string, or DIR_UNKNOWN if none was encountered. Treats a non-BN character between an LRE/RLE/LRO/RLO and its matching PDF as a strong character, LTR after LRE/LRO, and RTL after RLE/RLO. The results are undefined for a string containing unbalanced LRE/RLE/LRO/RLO/PDF characters.
 */
int getEntryDir(){
  charIndex=0;
  int embeddingLevel=0;
  int embeddingLevelDir=DIR_UNKNOWN;
  int firstNonEmptyEmbeddingLevel=0;
  while (charIndex < length && firstNonEmptyEmbeddingLevel == 0) {
switch (dirTypeForward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
      ++embeddingLevel;
    embeddingLevelDir=DIR_LTR;
  break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
++embeddingLevel;
embeddingLevelDir=DIR_RTL;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
--embeddingLevel;
embeddingLevelDir=DIR_UNKNOWN;
break;
case Character.DIRECTIONALITY_BOUNDARY_NEUTRAL:
break;
case Character.DIRECTIONALITY_LEFT_TO_RIGHT:
if (embeddingLevel == 0) {
return DIR_LTR;
}
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC:
if (embeddingLevel == 0) {
return DIR_RTL;
}
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
default :
firstNonEmptyEmbeddingLevel=embeddingLevel;
break;
}
}
if (firstNonEmptyEmbeddingLevel == 0) {
return DIR_UNKNOWN;
}
if (embeddingLevelDir != DIR_UNKNOWN) {
return embeddingLevelDir;
}
while (charIndex > 0) {
switch (dirTypeBackward()) {
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING:
case Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE:
if (firstNonEmptyEmbeddingLevel == embeddingLevel) {
return DIR_LTR;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING:
case Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE:
if (firstNonEmptyEmbeddingLevel == embeddingLevel) {
return DIR_RTL;
}
--embeddingLevel;
break;
case Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT:
++embeddingLevel;
break;
}
}
return DIR_UNKNOWN;
}"
2829,"/** 
 * Operates like   {@link #markBefore(String)}, but uses a given heuristic to estimate the  {@code str}'s directionality.
 * @param str String before which the mark may need to appear.
 * @param heuristic The text direction heuristic that will be used to estimate the {@code str}'s directionality.
 * @return LRM for RTL text in LTR context; RLM for LTR text in RTL context;else, the empty string.
 */
public String markBefore(String str,TextDirectionHeuristic heuristic){
  final boolean isRtl=heuristic.isRtl(str,0,str.length());
  if (!isRtlContext && (isRtl || getEntryDir(str) == Dir.RTL)) {
    return LRM_STRING;
  }
  if (isRtlContext && (!isRtl || getEntryDir(str) == Dir.LTR)) {
    return RLM_STRING;
  }
  return EMPTY_STRING;
}","/** 
 * Operates like   {@link #markBefore(String)}, but uses a given heuristic to estimate the  {@code str}'s directionality.
 * @param str String before which the mark may need to appear.
 * @param heuristic The text direction heuristic that will be used to estimate the {@code str}'s directionality.
 * @return LRM for RTL text in LTR context; RLM for LTR text in RTL context;else, the empty string.
 */
public String markBefore(String str,TextDirectionHeuristic heuristic){
  final boolean isRtl=heuristic.isRtl(str,0,str.length());
  if (!isRtlContext && (isRtl || getEntryDir(str) == DIR_RTL)) {
    return LRM_STRING;
  }
  if (isRtlContext && (!isRtl || getEntryDir(str) == DIR_LTR)) {
    return RLM_STRING;
  }
  return EMPTY_STRING;
}"
2830,"private void initializeGlobals(RenderScript RS,ScriptC_alloc s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  int Z=0;
  s.set_dimX(X);
  s.set_dimY(Y);
  s.set_dimZ(Z);
  typeBuilder.setX(X).setY(Y);
  Allocation A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  typeBuilder=new Type.Builder(RS,Element.I32(RS));
  typeBuilder.setX(X).setY(Y).setFaces(true);
  Allocation AFaces=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aFaces(AFaces);
  typeBuilder.setFaces(false).setMipmaps(true);
  Allocation ALOD=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aLOD(ALOD);
  typeBuilder.setFaces(true).setMipmaps(true);
  Allocation AFacesLOD=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aFacesLOD(AFacesLOD);
  return;
}","private void initializeGlobals(RenderScript RS,ScriptC_alloc s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  int Z=0;
  s.set_dimX(X);
  s.set_dimY(Y);
  s.set_dimZ(Z);
  typeBuilder.setX(X).setY(Y);
  Allocation A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  s.set_aRaw(A);
  typeBuilder=new Type.Builder(RS,Element.I32(RS));
  typeBuilder.setX(X).setY(Y).setFaces(true);
  Allocation AFaces=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aFaces(AFaces);
  typeBuilder.setFaces(false).setMipmaps(true);
  Allocation ALOD=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aLOD(ALOD);
  typeBuilder.setFaces(true).setMipmaps(true);
  Allocation AFacesLOD=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aFacesLOD(AFacesLOD);
  return;
}"
2831,"public void run(){
  RenderScript pRS=RenderScript.create(mCtx);
  ScriptC_alloc s=new ScriptC_alloc(pRS);
  pRS.setMessageHandler(mRsMessage);
  initializeGlobals(pRS,s);
  s.invoke_alloc_test();
  pRS.finish();
  waitForMessage();
  pRS.destroy();
}","public void run(){
  RenderScript pRS=RenderScript.create(mCtx);
  ScriptC_alloc s=new ScriptC_alloc(pRS);
  pRS.setMessageHandler(mRsMessage);
  initializeGlobals(pRS,s);
  s.forEach_root(s.get_aRaw());
  s.invoke_alloc_test();
  pRS.finish();
  waitForMessage();
  pRS.destroy();
}"
2832,"private void initializeGlobals(RenderScript RS,ScriptC_foreach s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  return;
}","private void initializeGlobals(RenderScript RS,ScriptC_foreach s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aRaw(A);
  return;
}"
2833,"private void initializeGlobals(RenderScript RS,ScriptC_foreach_bounds s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  s.set_s(s);
  s.set_ain(A);
  s.set_aout(A);
  s.set_xStart(2);
  s.set_xEnd(5);
  s.set_yStart(3);
  s.set_yEnd(6);
  s.forEach_zero(A);
  return;
}","private void initializeGlobals(RenderScript RS,ScriptC_foreach_bounds s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aRaw(A);
  s.set_s(s);
  s.set_ain(A);
  s.set_aout(A);
  s.set_xStart(2);
  s.set_xEnd(5);
  s.set_yStart(3);
  s.set_yEnd(6);
  s.forEach_zero(A);
  return;
}"
2834,"private void initializeGlobals(RenderScript RS,ScriptC_noroot s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  return;
}","private void initializeGlobals(RenderScript RS,ScriptC_noroot s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aRaw(A);
  return;
}"
2835,"/** 
 * Called to determine the initial header to be shown.  The default implementation simply returns the fragment of the first header.  Note that the returned Header object does not actually need to exist in your header list -- whatever its fragment is will simply be used to show for the initial UI.
 */
public Header onGetInitialHeader(){
  return mHeaders.get(0);
}","/** 
 * Called to determine the initial header to be shown.  The default implementation simply returns the fragment of the first header.  Note that the returned Header object does not actually need to exist in your header list -- whatever its fragment is will simply be used to show for the initial UI.
 */
public Header onGetInitialHeader(){
  for (int i=0; i < mHeaders.size(); i++) {
    Header h=mHeaders.get(i);
    if (h.fragment != null) {
      return h;
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}"
2836,"/** 
 * When in two-pane mode, switch to the fragment pane to show the given preference fragment.
 * @param header The new header to display.
 */
public void switchToHeader(Header header){
  if (mCurHeader == header) {
    getFragmentManager().popBackStack(BACK_STACK_PREFS,FragmentManager.POP_BACK_STACK_INCLUSIVE);
  }
 else {
    int direction=mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader);
    switchToHeaderInner(header.fragment,header.fragmentArguments,direction);
    setSelectedHeader(header);
  }
}","/** 
 * When in two-pane mode, switch to the fragment pane to show the given preference fragment.
 * @param header The new header to display.
 */
public void switchToHeader(Header header){
  if (mCurHeader == header) {
    getFragmentManager().popBackStack(BACK_STACK_PREFS,FragmentManager.POP_BACK_STACK_INCLUSIVE);
  }
 else {
    if (header.fragment == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    int direction=mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader);
    switchToHeaderInner(header.fragment,header.fragmentArguments,direction);
    setSelectedHeader(header);
  }
}"
2837,"/** 
 * Called to determine the initial header to be shown.  The default implementation simply returns the fragment of the first header.  Note that the returned Header object does not actually need to exist in your header list -- whatever its fragment is will simply be used to show for the initial UI.
 */
public Header onGetInitialHeader(){
  return mHeaders.get(0);
}","/** 
 * Called to determine the initial header to be shown.  The default implementation simply returns the fragment of the first header.  Note that the returned Header object does not actually need to exist in your header list -- whatever its fragment is will simply be used to show for the initial UI.
 */
public Header onGetInitialHeader(){
  for (int i=0; i < mHeaders.size(); i++) {
    Header h=mHeaders.get(i);
    if (h.fragment != null) {
      return h;
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}"
2838,"/** 
 * When in two-pane mode, switch to the fragment pane to show the given preference fragment.
 * @param header The new header to display.
 */
public void switchToHeader(Header header){
  if (mCurHeader == header) {
    getFragmentManager().popBackStack(BACK_STACK_PREFS,FragmentManager.POP_BACK_STACK_INCLUSIVE);
  }
 else {
    int direction=mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader);
    switchToHeaderInner(header.fragment,header.fragmentArguments,direction);
    setSelectedHeader(header);
  }
}","/** 
 * When in two-pane mode, switch to the fragment pane to show the given preference fragment.
 * @param header The new header to display.
 */
public void switchToHeader(Header header){
  if (mCurHeader == header) {
    getFragmentManager().popBackStack(BACK_STACK_PREFS,FragmentManager.POP_BACK_STACK_INCLUSIVE);
  }
 else {
    if (header.fragment == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    int direction=mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader);
    switchToHeaderInner(header.fragment,header.fragmentArguments,direction);
    setSelectedHeader(header);
  }
}"
2839,"private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}","private void computeGroupBounds(){
  Bounds[] values=groupBounds.values;
  for (int i=0; i < values.length; i++) {
    values[i].reset();
  }
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    groupBounds.getValue(i).include(GridLayout.this,c,spec,this);
  }
}"
2840,"private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}","private PackedMap<Spec,Bounds> createGroupBounds(){
  Assoc<Spec,Bounds> assoc=Assoc.of(Spec.class,Bounds.class);
  for (int i=0, N=getChildCount(); i < N; i++) {
    View c=getChildAt(i);
    if (c.getVisibility() == View.GONE)     continue;
    LayoutParams lp=getLayoutParams(c);
    Spec spec=horizontal ? lp.columnSpec : lp.rowSpec;
    Bounds bounds=getAlignment(spec.alignment,horizontal).getBounds();
    assoc.put(spec,bounds);
  }
  return assoc.pack();
}"
2841,"private void initializeGlobals(RenderScript RS,ScriptC_alloc s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  int Z=0;
  s.set_dimX(X);
  s.set_dimY(Y);
  s.set_dimZ(Z);
  typeBuilder.setX(X).setY(Y);
  Allocation A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  typeBuilder=new Type.Builder(RS,Element.I32(RS));
  typeBuilder.setX(X).setY(Y).setFaces(true);
  Allocation AFaces=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aFaces(AFaces);
  typeBuilder.setFaces(false).setMipmaps(true);
  Allocation ALOD=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aLOD(ALOD);
  typeBuilder.setFaces(true).setMipmaps(true);
  Allocation AFacesLOD=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aFacesLOD(AFacesLOD);
  return;
}","private void initializeGlobals(RenderScript RS,ScriptC_alloc s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  int Z=0;
  s.set_dimX(X);
  s.set_dimY(Y);
  s.set_dimZ(Z);
  typeBuilder.setX(X).setY(Y);
  Allocation A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  s.set_aRaw(A);
  typeBuilder=new Type.Builder(RS,Element.I32(RS));
  typeBuilder.setX(X).setY(Y).setFaces(true);
  Allocation AFaces=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aFaces(AFaces);
  typeBuilder.setFaces(false).setMipmaps(true);
  Allocation ALOD=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aLOD(ALOD);
  typeBuilder.setFaces(true).setMipmaps(true);
  Allocation AFacesLOD=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aFacesLOD(AFacesLOD);
  return;
}"
2842,"public void run(){
  RenderScript pRS=RenderScript.create(mCtx);
  ScriptC_alloc s=new ScriptC_alloc(pRS);
  pRS.setMessageHandler(mRsMessage);
  initializeGlobals(pRS,s);
  s.invoke_alloc_test();
  pRS.finish();
  waitForMessage();
  pRS.destroy();
}","public void run(){
  RenderScript pRS=RenderScript.create(mCtx);
  ScriptC_alloc s=new ScriptC_alloc(pRS);
  pRS.setMessageHandler(mRsMessage);
  initializeGlobals(pRS,s);
  s.forEach_root(s.get_aRaw());
  s.invoke_alloc_test();
  pRS.finish();
  waitForMessage();
  pRS.destroy();
}"
2843,"private void initializeGlobals(RenderScript RS,ScriptC_foreach s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  return;
}","private void initializeGlobals(RenderScript RS,ScriptC_foreach s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aRaw(A);
  return;
}"
2844,"private void initializeGlobals(RenderScript RS,ScriptC_foreach_bounds s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  s.set_s(s);
  s.set_ain(A);
  s.set_aout(A);
  s.set_xStart(2);
  s.set_xEnd(5);
  s.set_yStart(3);
  s.set_yEnd(6);
  s.forEach_zero(A);
  return;
}","private void initializeGlobals(RenderScript RS,ScriptC_foreach_bounds s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aRaw(A);
  s.set_s(s);
  s.set_ain(A);
  s.set_aout(A);
  s.set_xStart(2);
  s.set_xEnd(5);
  s.set_yStart(3);
  s.set_yEnd(6);
  s.forEach_zero(A);
  return;
}"
2845,"private void initializeGlobals(RenderScript RS,ScriptC_noroot s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  return;
}","private void initializeGlobals(RenderScript RS,ScriptC_noroot s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aRaw(A);
  return;
}"
2846,"/** 
 * Called to determine the initial header to be shown.  The default implementation simply returns the fragment of the first header.  Note that the returned Header object does not actually need to exist in your header list -- whatever its fragment is will simply be used to show for the initial UI.
 */
public Header onGetInitialHeader(){
  return mHeaders.get(0);
}","/** 
 * Called to determine the initial header to be shown.  The default implementation simply returns the fragment of the first header.  Note that the returned Header object does not actually need to exist in your header list -- whatever its fragment is will simply be used to show for the initial UI.
 */
public Header onGetInitialHeader(){
  for (int i=0; i < mHeaders.size(); i++) {
    Header h=mHeaders.get(i);
    if (h.fragment != null) {
      return h;
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}"
2847,"/** 
 * When in two-pane mode, switch to the fragment pane to show the given preference fragment.
 * @param header The new header to display.
 */
public void switchToHeader(Header header){
  if (mCurHeader == header) {
    getFragmentManager().popBackStack(BACK_STACK_PREFS,FragmentManager.POP_BACK_STACK_INCLUSIVE);
  }
 else {
    int direction=mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader);
    switchToHeaderInner(header.fragment,header.fragmentArguments,direction);
    setSelectedHeader(header);
  }
}","/** 
 * When in two-pane mode, switch to the fragment pane to show the given preference fragment.
 * @param header The new header to display.
 */
public void switchToHeader(Header header){
  if (mCurHeader == header) {
    getFragmentManager().popBackStack(BACK_STACK_PREFS,FragmentManager.POP_BACK_STACK_INCLUSIVE);
  }
 else {
    if (header.fragment == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    int direction=mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader);
    switchToHeaderInner(header.fragment,header.fragmentArguments,direction);
    setSelectedHeader(header);
  }
}"
2848,"/** 
 * @return true if layout direction has been resolved.
 */
private boolean isLayoutDirectionResolved(){
  return (mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED) == PFLAG2_LAYOUT_DIRECTION_RESOLVED;
}","/** 
 * @return true if layout direction has been resolved.
 * @hide
 */
public boolean isLayoutDirectionResolved(){
  return (mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED) == PFLAG2_LAYOUT_DIRECTION_RESOLVED;
}"
2849,"/** 
 * Resolve the text alignment.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveTextAlignment(){
  mPrivateFlags2&=~(PFLAG2_TEXT_ALIGNMENT_RESOLVED | PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK);
  if (hasRtlSupport()) {
    final int textAlignment=getRawTextAlignment();
switch (textAlignment) {
case TEXT_ALIGNMENT_INHERIT:
      if (!canResolveTextAlignment()) {
        mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
        return false;
      }
    View parent=(View)mParent;
  if (!parent.isTextAlignmentResolved()) {
    mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
    return false;
  }
final int parentResolvedTextAlignment=parent.getTextAlignment();
switch (parentResolvedTextAlignment) {
case TEXT_ALIGNMENT_GRAVITY:
case TEXT_ALIGNMENT_TEXT_START:
case TEXT_ALIGNMENT_TEXT_END:
case TEXT_ALIGNMENT_CENTER:
case TEXT_ALIGNMENT_VIEW_START:
case TEXT_ALIGNMENT_VIEW_END:
mPrivateFlags2|=(parentResolvedTextAlignment << PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
break;
case TEXT_ALIGNMENT_GRAVITY:
case TEXT_ALIGNMENT_TEXT_START:
case TEXT_ALIGNMENT_TEXT_END:
case TEXT_ALIGNMENT_CENTER:
case TEXT_ALIGNMENT_VIEW_START:
case TEXT_ALIGNMENT_VIEW_END:
mPrivateFlags2|=(textAlignment << PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
}
 else {
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED;
return true;
}","/** 
 * Resolve the text alignment.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveTextAlignment(){
  mPrivateFlags2&=~(PFLAG2_TEXT_ALIGNMENT_RESOLVED | PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK);
  if (hasRtlSupport()) {
    final int textAlignment=getRawTextAlignment();
switch (textAlignment) {
case TEXT_ALIGNMENT_INHERIT:
      if (!canResolveTextAlignment()) {
        mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
        return false;
      }
    if (!mParent.isTextAlignmentResolved()) {
      mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
      return false;
    }
  final int parentResolvedTextAlignment=mParent.getTextAlignment();
switch (parentResolvedTextAlignment) {
case TEXT_ALIGNMENT_GRAVITY:
case TEXT_ALIGNMENT_TEXT_START:
case TEXT_ALIGNMENT_TEXT_END:
case TEXT_ALIGNMENT_CENTER:
case TEXT_ALIGNMENT_VIEW_START:
case TEXT_ALIGNMENT_VIEW_END:
  mPrivateFlags2|=(parentResolvedTextAlignment << PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
break;
case TEXT_ALIGNMENT_GRAVITY:
case TEXT_ALIGNMENT_TEXT_START:
case TEXT_ALIGNMENT_TEXT_END:
case TEXT_ALIGNMENT_CENTER:
case TEXT_ALIGNMENT_VIEW_START:
case TEXT_ALIGNMENT_VIEW_END:
mPrivateFlags2|=(textAlignment << PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
}
 else {
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED;
return true;
}"
2850,"/** 
 * @return true if text alignment is resolved.
 */
private boolean isTextAlignmentResolved(){
  return (mPrivateFlags2 & PFLAG2_TEXT_ALIGNMENT_RESOLVED) == PFLAG2_TEXT_ALIGNMENT_RESOLVED;
}","/** 
 * @return true if text alignment is resolved.
 * @hide
 */
public boolean isTextAlignmentResolved(){
  return (mPrivateFlags2 & PFLAG2_TEXT_ALIGNMENT_RESOLVED) == PFLAG2_TEXT_ALIGNMENT_RESOLVED;
}"
2851,"/** 
 * Check if text direction resolution can be done.
 * @return true if text direction resolution can be done otherwise return false.
 */
private boolean canResolveTextDirection(){
switch (getRawTextDirection()) {
case TEXT_DIRECTION_INHERIT:
    return (mParent != null) && (mParent instanceof View) && ((View)mParent).canResolveTextDirection();
default :
  return true;
}
}","/** 
 * Check if text direction resolution can be done.
 * @return true if text direction resolution can be done otherwise return false.
 * @hide
 */
public boolean canResolveTextDirection(){
switch (getRawTextDirection()) {
case TEXT_DIRECTION_INHERIT:
    return (mParent != null) && mParent.canResolveTextDirection();
default :
  return true;
}
}"
2852,"/** 
 * @return true if text direction is resolved.
 */
private boolean isTextDirectionResolved(){
  return (mPrivateFlags2 & PFLAG2_TEXT_DIRECTION_RESOLVED) == PFLAG2_TEXT_DIRECTION_RESOLVED;
}","/** 
 * @return true if text direction is resolved.
 * @hide
 */
public boolean isTextDirectionResolved(){
  return (mPrivateFlags2 & PFLAG2_TEXT_DIRECTION_RESOLVED) == PFLAG2_TEXT_DIRECTION_RESOLVED;
}"
2853,"/** 
 * Returns the resolved layout direction for this view.
 * @return {@link #LAYOUT_DIRECTION_RTL} if the layout direction is RTL or returns{@link #LAYOUT_DIRECTION_LTR} if the layout direction is not RTL.For compatibility, this will return  {@link #LAYOUT_DIRECTION_LTR} if API versionis lower than  {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 * @attr ref android.R.styleable#View_layoutDirection
 */
@ViewDebug.ExportedProperty(category=""String_Node_Str"",mapping={@ViewDebug.IntToString(from=LAYOUT_DIRECTION_LTR,to=""String_Node_Str""),@ViewDebug.IntToString(from=LAYOUT_DIRECTION_RTL,to=""String_Node_Str"")}) public int getLayoutDirection(){
  final int targetSdkVersion=getContext().getApplicationInfo().targetSdkVersion;
  if (targetSdkVersion < JELLY_BEAN_MR1) {
    mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED;
    return LAYOUT_DIRECTION_LTR;
  }
  return ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) == PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) ? LAYOUT_DIRECTION_RTL : LAYOUT_DIRECTION_LTR;
}","/** 
 * Returns the resolved layout direction for this view.
 * @return {@link #LAYOUT_DIRECTION_RTL} if the layout direction is RTL or returns{@link #LAYOUT_DIRECTION_LTR} if the layout direction is not RTL.For compatibility, this will return  {@link #LAYOUT_DIRECTION_LTR} if API versionis lower than  {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 * @attr ref android.R.styleable#View_layoutDirection
 */
@ViewDebug.ExportedProperty(category=""String_Node_Str"",mapping={@ViewDebug.IntToString(from=LAYOUT_DIRECTION_LTR,to=""String_Node_Str""),@ViewDebug.IntToString(from=LAYOUT_DIRECTION_RTL,to=""String_Node_Str"")}) public int getLayoutDirection(){
  final int targetSdkVersion=getContext().getApplicationInfo().targetSdkVersion;
  if (targetSdkVersion < JELLY_BEAN_MR1) {
    mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED;
    return LAYOUT_DIRECTION_RESOLVED_DEFAULT;
  }
  return ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) == PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) ? LAYOUT_DIRECTION_RTL : LAYOUT_DIRECTION_LTR;
}"
2854,"/** 
 * Resolve the text direction.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveTextDirection(){
  mPrivateFlags2&=~(PFLAG2_TEXT_DIRECTION_RESOLVED | PFLAG2_TEXT_DIRECTION_RESOLVED_MASK);
  if (hasRtlSupport()) {
    final int textDirection=getRawTextDirection();
switch (textDirection) {
case TEXT_DIRECTION_INHERIT:
      if (!canResolveTextDirection()) {
        mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
        return false;
      }
    View parent=((View)mParent);
  if (!parent.isTextDirectionResolved()) {
    mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
    return false;
  }
final int parentResolvedDirection=parent.getTextDirection();
switch (parentResolvedDirection) {
case TEXT_DIRECTION_FIRST_STRONG:
case TEXT_DIRECTION_ANY_RTL:
case TEXT_DIRECTION_LTR:
case TEXT_DIRECTION_RTL:
case TEXT_DIRECTION_LOCALE:
mPrivateFlags2|=(parentResolvedDirection << PFLAG2_TEXT_DIRECTION_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
break;
case TEXT_DIRECTION_FIRST_STRONG:
case TEXT_DIRECTION_ANY_RTL:
case TEXT_DIRECTION_LTR:
case TEXT_DIRECTION_RTL:
case TEXT_DIRECTION_LOCALE:
mPrivateFlags2|=(textDirection << PFLAG2_TEXT_DIRECTION_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
}
 else {
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED;
return true;
}","/** 
 * Resolve the text direction.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveTextDirection(){
  mPrivateFlags2&=~(PFLAG2_TEXT_DIRECTION_RESOLVED | PFLAG2_TEXT_DIRECTION_RESOLVED_MASK);
  if (hasRtlSupport()) {
    final int textDirection=getRawTextDirection();
switch (textDirection) {
case TEXT_DIRECTION_INHERIT:
      if (!canResolveTextDirection()) {
        mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
        return false;
      }
    if (!mParent.isTextDirectionResolved()) {
      mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
      return false;
    }
  final int parentResolvedDirection=mParent.getTextDirection();
switch (parentResolvedDirection) {
case TEXT_DIRECTION_FIRST_STRONG:
case TEXT_DIRECTION_ANY_RTL:
case TEXT_DIRECTION_LTR:
case TEXT_DIRECTION_RTL:
case TEXT_DIRECTION_LOCALE:
  mPrivateFlags2|=(parentResolvedDirection << PFLAG2_TEXT_DIRECTION_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
break;
case TEXT_DIRECTION_FIRST_STRONG:
case TEXT_DIRECTION_ANY_RTL:
case TEXT_DIRECTION_LTR:
case TEXT_DIRECTION_RTL:
case TEXT_DIRECTION_LOCALE:
mPrivateFlags2|=(textDirection << PFLAG2_TEXT_DIRECTION_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
}
 else {
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED;
return true;
}"
2855,"/** 
 * Resolve and cache the layout direction. LTR is set initially. This is implicitly supposing that the parent directionality can and will be resolved before its children.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveLayoutDirection(){
  mPrivateFlags2&=~PFLAG2_LAYOUT_DIRECTION_RESOLVED_MASK;
  if (hasRtlSupport()) {
switch ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_MASK) >> PFLAG2_LAYOUT_DIRECTION_MASK_SHIFT) {
case LAYOUT_DIRECTION_INHERIT:
      if (!canResolveLayoutDirection())       return false;
    View parent=((View)mParent);
  if (!parent.isLayoutDirectionResolved())   return false;
if (parent.getLayoutDirection() == LAYOUT_DIRECTION_RTL) {
  mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
}
break;
case LAYOUT_DIRECTION_RTL:
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
break;
case LAYOUT_DIRECTION_LOCALE:
if ((LAYOUT_DIRECTION_RTL == TextUtils.getLayoutDirectionFromLocale(Locale.getDefault()))) {
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
}
break;
default :
}
}
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED;
return true;
}","/** 
 * Resolve and cache the layout direction. LTR is set initially. This is implicitly supposing that the parent directionality can and will be resolved before its children.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveLayoutDirection(){
  mPrivateFlags2&=~PFLAG2_LAYOUT_DIRECTION_RESOLVED_MASK;
  if (hasRtlSupport()) {
switch ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_MASK) >> PFLAG2_LAYOUT_DIRECTION_MASK_SHIFT) {
case LAYOUT_DIRECTION_INHERIT:
      if (!canResolveLayoutDirection())       return false;
    if (!mParent.isLayoutDirectionResolved())     return false;
  if (mParent.getLayoutDirection() == LAYOUT_DIRECTION_RTL) {
    mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
  }
break;
case LAYOUT_DIRECTION_RTL:
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
break;
case LAYOUT_DIRECTION_LOCALE:
if ((LAYOUT_DIRECTION_RTL == TextUtils.getLayoutDirectionFromLocale(Locale.getDefault()))) {
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
}
break;
default :
}
}
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED;
return true;
}"
2856,"/** 
 * Check if layout direction resolution can be done.
 * @return true if layout direction resolution can be done otherwise return false.
 * @hide
 */
public boolean canResolveLayoutDirection(){
switch (getRawLayoutDirection()) {
case LAYOUT_DIRECTION_INHERIT:
    return (mParent != null) && (mParent instanceof ViewGroup) && ((ViewGroup)mParent).canResolveLayoutDirection();
default :
  return true;
}
}","/** 
 * Check if layout direction resolution can be done.
 * @return true if layout direction resolution can be done otherwise return false.
 * @hide
 */
public boolean canResolveLayoutDirection(){
switch (getRawLayoutDirection()) {
case LAYOUT_DIRECTION_INHERIT:
    return (mParent != null) && mParent.canResolveLayoutDirection();
default :
  return true;
}
}"
2857,"/** 
 * Check if text alignment resolution can be done.
 * @return true if text alignment resolution can be done otherwise return false.
 */
private boolean canResolveTextAlignment(){
switch (getRawTextAlignment()) {
case TEXT_DIRECTION_INHERIT:
    return (mParent != null) && (mParent instanceof View) && ((View)mParent).canResolveTextAlignment();
default :
  return true;
}
}","/** 
 * Check if text alignment resolution can be done.
 * @return true if text alignment resolution can be done otherwise return false.
 * @hide
 */
public boolean canResolveTextAlignment(){
switch (getRawTextAlignment()) {
case TEXT_DIRECTION_INHERIT:
    return (mParent != null) && mParent.canResolveTextAlignment();
default :
  return true;
}
}"
2858,"/** 
 * Return a color integer associated with a particular resource ID. If the resource holds a complex  {@link android.content.res.ColorStateList}, then the default color from the set is returned.
 * @param id The desired resource identifier, as generated by the aapttool. This integer encodes the package, type, and resource entry. The value 0 is an invalid identifier.
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 * @return Returns a single color value in the form 0xAARRGGBB.
 */
public int getColor(int id) throws NotFoundException {
  TypedValue value;
synchronized (mAccessLock) {
    value=mTmpValue;
    if (value == null) {
      value=new TypedValue();
    }
    getValue(id,value,true);
    if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
      mTmpValue=value;
      return value.data;
    }
 else     if (value.type != TypedValue.TYPE_STRING) {
      throw new NotFoundException(""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ Integer.toHexString(value.type)+ ""String_Node_Str"");
    }
  }
  ColorStateList csl=loadColorStateList(value,id);
synchronized (mAccessLock) {
    if (mTmpValue == null) {
      mTmpValue=value;
    }
  }
  return csl.getDefaultColor();
}","/** 
 * Return a color integer associated with a particular resource ID. If the resource holds a complex  {@link android.content.res.ColorStateList}, then the default color from the set is returned.
 * @param id The desired resource identifier, as generated by the aapttool. This integer encodes the package, type, and resource entry. The value 0 is an invalid identifier.
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 * @return Returns a single color value in the form 0xAARRGGBB.
 */
public int getColor(int id) throws NotFoundException {
  TypedValue value;
synchronized (mAccessLock) {
    value=mTmpValue;
    if (value == null) {
      value=new TypedValue();
    }
    getValue(id,value,true);
    if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
      mTmpValue=value;
      return value.data;
    }
 else     if (value.type != TypedValue.TYPE_STRING) {
      throw new NotFoundException(""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ Integer.toHexString(value.type)+ ""String_Node_Str"");
    }
    mTmpValue=null;
  }
  ColorStateList csl=loadColorStateList(value,id);
synchronized (mAccessLock) {
    if (mTmpValue == null) {
      mTmpValue=value;
    }
  }
  return csl.getDefaultColor();
}"
2859,"/** 
 * Return a color integer associated with a particular resource ID. If the resource holds a complex  {@link android.content.res.ColorStateList}, then the default color from the set is returned.
 * @param id The desired resource identifier, as generated by the aapttool. This integer encodes the package, type, and resource entry. The value 0 is an invalid identifier.
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 * @return Returns a single color value in the form 0xAARRGGBB.
 */
public int getColor(int id) throws NotFoundException {
  TypedValue value;
synchronized (mAccessLock) {
    value=mTmpValue;
    if (value == null) {
      value=new TypedValue();
    }
    getValue(id,value,true);
    if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
      mTmpValue=value;
      return value.data;
    }
 else     if (value.type != TypedValue.TYPE_STRING) {
      throw new NotFoundException(""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ Integer.toHexString(value.type)+ ""String_Node_Str"");
    }
  }
  ColorStateList csl=loadColorStateList(value,id);
synchronized (mAccessLock) {
    if (mTmpValue == null) {
      mTmpValue=value;
    }
  }
  return csl.getDefaultColor();
}","/** 
 * Return a color integer associated with a particular resource ID. If the resource holds a complex  {@link android.content.res.ColorStateList}, then the default color from the set is returned.
 * @param id The desired resource identifier, as generated by the aapttool. This integer encodes the package, type, and resource entry. The value 0 is an invalid identifier.
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 * @return Returns a single color value in the form 0xAARRGGBB.
 */
public int getColor(int id) throws NotFoundException {
  TypedValue value;
synchronized (mAccessLock) {
    value=mTmpValue;
    if (value == null) {
      value=new TypedValue();
    }
    getValue(id,value,true);
    if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
      mTmpValue=value;
      return value.data;
    }
 else     if (value.type != TypedValue.TYPE_STRING) {
      throw new NotFoundException(""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ Integer.toHexString(value.type)+ ""String_Node_Str"");
    }
    mTmpValue=null;
  }
  ColorStateList csl=loadColorStateList(value,id);
synchronized (mAccessLock) {
    if (mTmpValue == null) {
      mTmpValue=value;
    }
  }
  return csl.getDefaultColor();
}"
2860,"/** 
 * @return true if layout direction has been resolved.
 */
private boolean isLayoutDirectionResolved(){
  return (mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED) == PFLAG2_LAYOUT_DIRECTION_RESOLVED;
}","/** 
 * @return true if layout direction has been resolved.
 * @hide
 */
public boolean isLayoutDirectionResolved(){
  return (mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED) == PFLAG2_LAYOUT_DIRECTION_RESOLVED;
}"
2861,"/** 
 * Resolve the text alignment.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveTextAlignment(){
  mPrivateFlags2&=~(PFLAG2_TEXT_ALIGNMENT_RESOLVED | PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK);
  if (hasRtlSupport()) {
    final int textAlignment=getRawTextAlignment();
switch (textAlignment) {
case TEXT_ALIGNMENT_INHERIT:
      if (!canResolveTextAlignment()) {
        mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
        return false;
      }
    View parent=(View)mParent;
  if (!parent.isTextAlignmentResolved()) {
    mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
    return false;
  }
final int parentResolvedTextAlignment=parent.getTextAlignment();
switch (parentResolvedTextAlignment) {
case TEXT_ALIGNMENT_GRAVITY:
case TEXT_ALIGNMENT_TEXT_START:
case TEXT_ALIGNMENT_TEXT_END:
case TEXT_ALIGNMENT_CENTER:
case TEXT_ALIGNMENT_VIEW_START:
case TEXT_ALIGNMENT_VIEW_END:
mPrivateFlags2|=(parentResolvedTextAlignment << PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
break;
case TEXT_ALIGNMENT_GRAVITY:
case TEXT_ALIGNMENT_TEXT_START:
case TEXT_ALIGNMENT_TEXT_END:
case TEXT_ALIGNMENT_CENTER:
case TEXT_ALIGNMENT_VIEW_START:
case TEXT_ALIGNMENT_VIEW_END:
mPrivateFlags2|=(textAlignment << PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
}
 else {
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED;
return true;
}","/** 
 * Resolve the text alignment.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveTextAlignment(){
  mPrivateFlags2&=~(PFLAG2_TEXT_ALIGNMENT_RESOLVED | PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK);
  if (hasRtlSupport()) {
    final int textAlignment=getRawTextAlignment();
switch (textAlignment) {
case TEXT_ALIGNMENT_INHERIT:
      if (!canResolveTextAlignment()) {
        mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
        return false;
      }
    if (!mParent.isTextAlignmentResolved()) {
      mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
      return false;
    }
  final int parentResolvedTextAlignment=mParent.getTextAlignment();
switch (parentResolvedTextAlignment) {
case TEXT_ALIGNMENT_GRAVITY:
case TEXT_ALIGNMENT_TEXT_START:
case TEXT_ALIGNMENT_TEXT_END:
case TEXT_ALIGNMENT_CENTER:
case TEXT_ALIGNMENT_VIEW_START:
case TEXT_ALIGNMENT_VIEW_END:
  mPrivateFlags2|=(parentResolvedTextAlignment << PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
break;
case TEXT_ALIGNMENT_GRAVITY:
case TEXT_ALIGNMENT_TEXT_START:
case TEXT_ALIGNMENT_TEXT_END:
case TEXT_ALIGNMENT_CENTER:
case TEXT_ALIGNMENT_VIEW_START:
case TEXT_ALIGNMENT_VIEW_END:
mPrivateFlags2|=(textAlignment << PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
}
 else {
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED;
return true;
}"
2862,"/** 
 * @return true if text alignment is resolved.
 */
private boolean isTextAlignmentResolved(){
  return (mPrivateFlags2 & PFLAG2_TEXT_ALIGNMENT_RESOLVED) == PFLAG2_TEXT_ALIGNMENT_RESOLVED;
}","/** 
 * @return true if text alignment is resolved.
 * @hide
 */
public boolean isTextAlignmentResolved(){
  return (mPrivateFlags2 & PFLAG2_TEXT_ALIGNMENT_RESOLVED) == PFLAG2_TEXT_ALIGNMENT_RESOLVED;
}"
2863,"/** 
 * Check if text direction resolution can be done.
 * @return true if text direction resolution can be done otherwise return false.
 */
private boolean canResolveTextDirection(){
switch (getRawTextDirection()) {
case TEXT_DIRECTION_INHERIT:
    return (mParent != null) && (mParent instanceof View) && ((View)mParent).canResolveTextDirection();
default :
  return true;
}
}","/** 
 * Check if text direction resolution can be done.
 * @return true if text direction resolution can be done otherwise return false.
 * @hide
 */
public boolean canResolveTextDirection(){
switch (getRawTextDirection()) {
case TEXT_DIRECTION_INHERIT:
    return (mParent != null) && mParent.canResolveTextDirection();
default :
  return true;
}
}"
2864,"/** 
 * @return true if text direction is resolved.
 */
private boolean isTextDirectionResolved(){
  return (mPrivateFlags2 & PFLAG2_TEXT_DIRECTION_RESOLVED) == PFLAG2_TEXT_DIRECTION_RESOLVED;
}","/** 
 * @return true if text direction is resolved.
 * @hide
 */
public boolean isTextDirectionResolved(){
  return (mPrivateFlags2 & PFLAG2_TEXT_DIRECTION_RESOLVED) == PFLAG2_TEXT_DIRECTION_RESOLVED;
}"
2865,"/** 
 * Returns the resolved layout direction for this view.
 * @return {@link #LAYOUT_DIRECTION_RTL} if the layout direction is RTL or returns{@link #LAYOUT_DIRECTION_LTR} if the layout direction is not RTL.For compatibility, this will return  {@link #LAYOUT_DIRECTION_LTR} if API versionis lower than  {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 * @attr ref android.R.styleable#View_layoutDirection
 */
@ViewDebug.ExportedProperty(category=""String_Node_Str"",mapping={@ViewDebug.IntToString(from=LAYOUT_DIRECTION_LTR,to=""String_Node_Str""),@ViewDebug.IntToString(from=LAYOUT_DIRECTION_RTL,to=""String_Node_Str"")}) public int getLayoutDirection(){
  final int targetSdkVersion=getContext().getApplicationInfo().targetSdkVersion;
  if (targetSdkVersion < JELLY_BEAN_MR1) {
    mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED;
    return LAYOUT_DIRECTION_LTR;
  }
  return ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) == PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) ? LAYOUT_DIRECTION_RTL : LAYOUT_DIRECTION_LTR;
}","/** 
 * Returns the resolved layout direction for this view.
 * @return {@link #LAYOUT_DIRECTION_RTL} if the layout direction is RTL or returns{@link #LAYOUT_DIRECTION_LTR} if the layout direction is not RTL.For compatibility, this will return  {@link #LAYOUT_DIRECTION_LTR} if API versionis lower than  {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 * @attr ref android.R.styleable#View_layoutDirection
 */
@ViewDebug.ExportedProperty(category=""String_Node_Str"",mapping={@ViewDebug.IntToString(from=LAYOUT_DIRECTION_LTR,to=""String_Node_Str""),@ViewDebug.IntToString(from=LAYOUT_DIRECTION_RTL,to=""String_Node_Str"")}) public int getLayoutDirection(){
  final int targetSdkVersion=getContext().getApplicationInfo().targetSdkVersion;
  if (targetSdkVersion < JELLY_BEAN_MR1) {
    mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED;
    return LAYOUT_DIRECTION_RESOLVED_DEFAULT;
  }
  return ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) == PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) ? LAYOUT_DIRECTION_RTL : LAYOUT_DIRECTION_LTR;
}"
2866,"/** 
 * Resolve the text direction.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveTextDirection(){
  mPrivateFlags2&=~(PFLAG2_TEXT_DIRECTION_RESOLVED | PFLAG2_TEXT_DIRECTION_RESOLVED_MASK);
  if (hasRtlSupport()) {
    final int textDirection=getRawTextDirection();
switch (textDirection) {
case TEXT_DIRECTION_INHERIT:
      if (!canResolveTextDirection()) {
        mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
        return false;
      }
    View parent=((View)mParent);
  if (!parent.isTextDirectionResolved()) {
    mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
    return false;
  }
final int parentResolvedDirection=parent.getTextDirection();
switch (parentResolvedDirection) {
case TEXT_DIRECTION_FIRST_STRONG:
case TEXT_DIRECTION_ANY_RTL:
case TEXT_DIRECTION_LTR:
case TEXT_DIRECTION_RTL:
case TEXT_DIRECTION_LOCALE:
mPrivateFlags2|=(parentResolvedDirection << PFLAG2_TEXT_DIRECTION_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
break;
case TEXT_DIRECTION_FIRST_STRONG:
case TEXT_DIRECTION_ANY_RTL:
case TEXT_DIRECTION_LTR:
case TEXT_DIRECTION_RTL:
case TEXT_DIRECTION_LOCALE:
mPrivateFlags2|=(textDirection << PFLAG2_TEXT_DIRECTION_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
}
 else {
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED;
return true;
}","/** 
 * Resolve the text direction.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveTextDirection(){
  mPrivateFlags2&=~(PFLAG2_TEXT_DIRECTION_RESOLVED | PFLAG2_TEXT_DIRECTION_RESOLVED_MASK);
  if (hasRtlSupport()) {
    final int textDirection=getRawTextDirection();
switch (textDirection) {
case TEXT_DIRECTION_INHERIT:
      if (!canResolveTextDirection()) {
        mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
        return false;
      }
    if (!mParent.isTextDirectionResolved()) {
      mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
      return false;
    }
  final int parentResolvedDirection=mParent.getTextDirection();
switch (parentResolvedDirection) {
case TEXT_DIRECTION_FIRST_STRONG:
case TEXT_DIRECTION_ANY_RTL:
case TEXT_DIRECTION_LTR:
case TEXT_DIRECTION_RTL:
case TEXT_DIRECTION_LOCALE:
  mPrivateFlags2|=(parentResolvedDirection << PFLAG2_TEXT_DIRECTION_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
break;
case TEXT_DIRECTION_FIRST_STRONG:
case TEXT_DIRECTION_ANY_RTL:
case TEXT_DIRECTION_LTR:
case TEXT_DIRECTION_RTL:
case TEXT_DIRECTION_LOCALE:
mPrivateFlags2|=(textDirection << PFLAG2_TEXT_DIRECTION_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
}
 else {
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED;
return true;
}"
2867,"/** 
 * Resolve and cache the layout direction. LTR is set initially. This is implicitly supposing that the parent directionality can and will be resolved before its children.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveLayoutDirection(){
  mPrivateFlags2&=~PFLAG2_LAYOUT_DIRECTION_RESOLVED_MASK;
  if (hasRtlSupport()) {
switch ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_MASK) >> PFLAG2_LAYOUT_DIRECTION_MASK_SHIFT) {
case LAYOUT_DIRECTION_INHERIT:
      if (!canResolveLayoutDirection())       return false;
    View parent=((View)mParent);
  if (!parent.isLayoutDirectionResolved())   return false;
if (parent.getLayoutDirection() == LAYOUT_DIRECTION_RTL) {
  mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
}
break;
case LAYOUT_DIRECTION_RTL:
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
break;
case LAYOUT_DIRECTION_LOCALE:
if ((LAYOUT_DIRECTION_RTL == TextUtils.getLayoutDirectionFromLocale(Locale.getDefault()))) {
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
}
break;
default :
}
}
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED;
return true;
}","/** 
 * Resolve and cache the layout direction. LTR is set initially. This is implicitly supposing that the parent directionality can and will be resolved before its children.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveLayoutDirection(){
  mPrivateFlags2&=~PFLAG2_LAYOUT_DIRECTION_RESOLVED_MASK;
  if (hasRtlSupport()) {
switch ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_MASK) >> PFLAG2_LAYOUT_DIRECTION_MASK_SHIFT) {
case LAYOUT_DIRECTION_INHERIT:
      if (!canResolveLayoutDirection())       return false;
    if (!mParent.isLayoutDirectionResolved())     return false;
  if (mParent.getLayoutDirection() == LAYOUT_DIRECTION_RTL) {
    mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
  }
break;
case LAYOUT_DIRECTION_RTL:
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
break;
case LAYOUT_DIRECTION_LOCALE:
if ((LAYOUT_DIRECTION_RTL == TextUtils.getLayoutDirectionFromLocale(Locale.getDefault()))) {
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
}
break;
default :
}
}
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED;
return true;
}"
2868,"/** 
 * Check if layout direction resolution can be done.
 * @return true if layout direction resolution can be done otherwise return false.
 * @hide
 */
public boolean canResolveLayoutDirection(){
switch (getRawLayoutDirection()) {
case LAYOUT_DIRECTION_INHERIT:
    return (mParent != null) && (mParent instanceof ViewGroup) && ((ViewGroup)mParent).canResolveLayoutDirection();
default :
  return true;
}
}","/** 
 * Check if layout direction resolution can be done.
 * @return true if layout direction resolution can be done otherwise return false.
 * @hide
 */
public boolean canResolveLayoutDirection(){
switch (getRawLayoutDirection()) {
case LAYOUT_DIRECTION_INHERIT:
    return (mParent != null) && mParent.canResolveLayoutDirection();
default :
  return true;
}
}"
2869,"/** 
 * Check if text alignment resolution can be done.
 * @return true if text alignment resolution can be done otherwise return false.
 */
private boolean canResolveTextAlignment(){
switch (getRawTextAlignment()) {
case TEXT_DIRECTION_INHERIT:
    return (mParent != null) && (mParent instanceof View) && ((View)mParent).canResolveTextAlignment();
default :
  return true;
}
}","/** 
 * Check if text alignment resolution can be done.
 * @return true if text alignment resolution can be done otherwise return false.
 * @hide
 */
public boolean canResolveTextAlignment(){
switch (getRawTextAlignment()) {
case TEXT_DIRECTION_INHERIT:
    return (mParent != null) && mParent.canResolveTextAlignment();
default :
  return true;
}
}"
2870,"/** 
 * Return a color integer associated with a particular resource ID. If the resource holds a complex  {@link android.content.res.ColorStateList}, then the default color from the set is returned.
 * @param id The desired resource identifier, as generated by the aapttool. This integer encodes the package, type, and resource entry. The value 0 is an invalid identifier.
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 * @return Returns a single color value in the form 0xAARRGGBB.
 */
public int getColor(int id) throws NotFoundException {
  TypedValue value;
synchronized (mAccessLock) {
    value=mTmpValue;
    if (value == null) {
      value=new TypedValue();
    }
    getValue(id,value,true);
    if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
      mTmpValue=value;
      return value.data;
    }
 else     if (value.type != TypedValue.TYPE_STRING) {
      throw new NotFoundException(""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ Integer.toHexString(value.type)+ ""String_Node_Str"");
    }
  }
  ColorStateList csl=loadColorStateList(value,id);
synchronized (mAccessLock) {
    if (mTmpValue == null) {
      mTmpValue=value;
    }
  }
  return csl.getDefaultColor();
}","/** 
 * Return a color integer associated with a particular resource ID. If the resource holds a complex  {@link android.content.res.ColorStateList}, then the default color from the set is returned.
 * @param id The desired resource identifier, as generated by the aapttool. This integer encodes the package, type, and resource entry. The value 0 is an invalid identifier.
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 * @return Returns a single color value in the form 0xAARRGGBB.
 */
public int getColor(int id) throws NotFoundException {
  TypedValue value;
synchronized (mAccessLock) {
    value=mTmpValue;
    if (value == null) {
      value=new TypedValue();
    }
    getValue(id,value,true);
    if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
      mTmpValue=value;
      return value.data;
    }
 else     if (value.type != TypedValue.TYPE_STRING) {
      throw new NotFoundException(""String_Node_Str"" + Integer.toHexString(id) + ""String_Node_Str""+ Integer.toHexString(value.type)+ ""String_Node_Str"");
    }
    mTmpValue=null;
  }
  ColorStateList csl=loadColorStateList(value,id);
synchronized (mAccessLock) {
    if (mTmpValue == null) {
      mTmpValue=value;
    }
  }
  return csl.getDefaultColor();
}"
2871,"/** 
 * @return true if layout direction has been resolved.
 */
private boolean isLayoutDirectionResolved(){
  return (mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED) == PFLAG2_LAYOUT_DIRECTION_RESOLVED;
}","/** 
 * @return true if layout direction has been resolved.
 * @hide
 */
public boolean isLayoutDirectionResolved(){
  return (mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED) == PFLAG2_LAYOUT_DIRECTION_RESOLVED;
}"
2872,"/** 
 * Resolve the text alignment.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveTextAlignment(){
  mPrivateFlags2&=~(PFLAG2_TEXT_ALIGNMENT_RESOLVED | PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK);
  if (hasRtlSupport()) {
    final int textAlignment=getRawTextAlignment();
switch (textAlignment) {
case TEXT_ALIGNMENT_INHERIT:
      if (!canResolveTextAlignment()) {
        mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
        return false;
      }
    View parent=(View)mParent;
  if (!parent.isTextAlignmentResolved()) {
    mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
    return false;
  }
final int parentResolvedTextAlignment=parent.getTextAlignment();
switch (parentResolvedTextAlignment) {
case TEXT_ALIGNMENT_GRAVITY:
case TEXT_ALIGNMENT_TEXT_START:
case TEXT_ALIGNMENT_TEXT_END:
case TEXT_ALIGNMENT_CENTER:
case TEXT_ALIGNMENT_VIEW_START:
case TEXT_ALIGNMENT_VIEW_END:
mPrivateFlags2|=(parentResolvedTextAlignment << PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
break;
case TEXT_ALIGNMENT_GRAVITY:
case TEXT_ALIGNMENT_TEXT_START:
case TEXT_ALIGNMENT_TEXT_END:
case TEXT_ALIGNMENT_CENTER:
case TEXT_ALIGNMENT_VIEW_START:
case TEXT_ALIGNMENT_VIEW_END:
mPrivateFlags2|=(textAlignment << PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
}
 else {
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED;
return true;
}","/** 
 * Resolve the text alignment.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveTextAlignment(){
  mPrivateFlags2&=~(PFLAG2_TEXT_ALIGNMENT_RESOLVED | PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK);
  if (hasRtlSupport()) {
    final int textAlignment=getRawTextAlignment();
switch (textAlignment) {
case TEXT_ALIGNMENT_INHERIT:
      if (!canResolveTextAlignment()) {
        mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
        return false;
      }
    if (!mParent.isTextAlignmentResolved()) {
      mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
      return false;
    }
  final int parentResolvedTextAlignment=mParent.getTextAlignment();
switch (parentResolvedTextAlignment) {
case TEXT_ALIGNMENT_GRAVITY:
case TEXT_ALIGNMENT_TEXT_START:
case TEXT_ALIGNMENT_TEXT_END:
case TEXT_ALIGNMENT_CENTER:
case TEXT_ALIGNMENT_VIEW_START:
case TEXT_ALIGNMENT_VIEW_END:
  mPrivateFlags2|=(parentResolvedTextAlignment << PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
break;
case TEXT_ALIGNMENT_GRAVITY:
case TEXT_ALIGNMENT_TEXT_START:
case TEXT_ALIGNMENT_TEXT_END:
case TEXT_ALIGNMENT_CENTER:
case TEXT_ALIGNMENT_VIEW_START:
case TEXT_ALIGNMENT_VIEW_END:
mPrivateFlags2|=(textAlignment << PFLAG2_TEXT_ALIGNMENT_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
}
 else {
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT;
}
mPrivateFlags2|=PFLAG2_TEXT_ALIGNMENT_RESOLVED;
return true;
}"
2873,"/** 
 * @return true if text alignment is resolved.
 */
private boolean isTextAlignmentResolved(){
  return (mPrivateFlags2 & PFLAG2_TEXT_ALIGNMENT_RESOLVED) == PFLAG2_TEXT_ALIGNMENT_RESOLVED;
}","/** 
 * @return true if text alignment is resolved.
 * @hide
 */
public boolean isTextAlignmentResolved(){
  return (mPrivateFlags2 & PFLAG2_TEXT_ALIGNMENT_RESOLVED) == PFLAG2_TEXT_ALIGNMENT_RESOLVED;
}"
2874,"/** 
 * Check if text direction resolution can be done.
 * @return true if text direction resolution can be done otherwise return false.
 */
private boolean canResolveTextDirection(){
switch (getRawTextDirection()) {
case TEXT_DIRECTION_INHERIT:
    return (mParent != null) && (mParent instanceof View) && ((View)mParent).canResolveTextDirection();
default :
  return true;
}
}","/** 
 * Check if text direction resolution can be done.
 * @return true if text direction resolution can be done otherwise return false.
 * @hide
 */
public boolean canResolveTextDirection(){
switch (getRawTextDirection()) {
case TEXT_DIRECTION_INHERIT:
    return (mParent != null) && mParent.canResolveTextDirection();
default :
  return true;
}
}"
2875,"/** 
 * @return true if text direction is resolved.
 */
private boolean isTextDirectionResolved(){
  return (mPrivateFlags2 & PFLAG2_TEXT_DIRECTION_RESOLVED) == PFLAG2_TEXT_DIRECTION_RESOLVED;
}","/** 
 * @return true if text direction is resolved.
 * @hide
 */
public boolean isTextDirectionResolved(){
  return (mPrivateFlags2 & PFLAG2_TEXT_DIRECTION_RESOLVED) == PFLAG2_TEXT_DIRECTION_RESOLVED;
}"
2876,"/** 
 * Returns the resolved layout direction for this view.
 * @return {@link #LAYOUT_DIRECTION_RTL} if the layout direction is RTL or returns{@link #LAYOUT_DIRECTION_LTR} if the layout direction is not RTL.For compatibility, this will return  {@link #LAYOUT_DIRECTION_LTR} if API versionis lower than  {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 * @attr ref android.R.styleable#View_layoutDirection
 */
@ViewDebug.ExportedProperty(category=""String_Node_Str"",mapping={@ViewDebug.IntToString(from=LAYOUT_DIRECTION_LTR,to=""String_Node_Str""),@ViewDebug.IntToString(from=LAYOUT_DIRECTION_RTL,to=""String_Node_Str"")}) public int getLayoutDirection(){
  final int targetSdkVersion=getContext().getApplicationInfo().targetSdkVersion;
  if (targetSdkVersion < JELLY_BEAN_MR1) {
    mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED;
    return LAYOUT_DIRECTION_LTR;
  }
  return ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) == PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) ? LAYOUT_DIRECTION_RTL : LAYOUT_DIRECTION_LTR;
}","/** 
 * Returns the resolved layout direction for this view.
 * @return {@link #LAYOUT_DIRECTION_RTL} if the layout direction is RTL or returns{@link #LAYOUT_DIRECTION_LTR} if the layout direction is not RTL.For compatibility, this will return  {@link #LAYOUT_DIRECTION_LTR} if API versionis lower than  {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 * @attr ref android.R.styleable#View_layoutDirection
 */
@ViewDebug.ExportedProperty(category=""String_Node_Str"",mapping={@ViewDebug.IntToString(from=LAYOUT_DIRECTION_LTR,to=""String_Node_Str""),@ViewDebug.IntToString(from=LAYOUT_DIRECTION_RTL,to=""String_Node_Str"")}) public int getLayoutDirection(){
  final int targetSdkVersion=getContext().getApplicationInfo().targetSdkVersion;
  if (targetSdkVersion < JELLY_BEAN_MR1) {
    mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED;
    return LAYOUT_DIRECTION_RESOLVED_DEFAULT;
  }
  return ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) == PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) ? LAYOUT_DIRECTION_RTL : LAYOUT_DIRECTION_LTR;
}"
2877,"/** 
 * Resolve the text direction.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveTextDirection(){
  mPrivateFlags2&=~(PFLAG2_TEXT_DIRECTION_RESOLVED | PFLAG2_TEXT_DIRECTION_RESOLVED_MASK);
  if (hasRtlSupport()) {
    final int textDirection=getRawTextDirection();
switch (textDirection) {
case TEXT_DIRECTION_INHERIT:
      if (!canResolveTextDirection()) {
        mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
        return false;
      }
    View parent=((View)mParent);
  if (!parent.isTextDirectionResolved()) {
    mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
    return false;
  }
final int parentResolvedDirection=parent.getTextDirection();
switch (parentResolvedDirection) {
case TEXT_DIRECTION_FIRST_STRONG:
case TEXT_DIRECTION_ANY_RTL:
case TEXT_DIRECTION_LTR:
case TEXT_DIRECTION_RTL:
case TEXT_DIRECTION_LOCALE:
mPrivateFlags2|=(parentResolvedDirection << PFLAG2_TEXT_DIRECTION_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
break;
case TEXT_DIRECTION_FIRST_STRONG:
case TEXT_DIRECTION_ANY_RTL:
case TEXT_DIRECTION_LTR:
case TEXT_DIRECTION_RTL:
case TEXT_DIRECTION_LOCALE:
mPrivateFlags2|=(textDirection << PFLAG2_TEXT_DIRECTION_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
}
 else {
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED;
return true;
}","/** 
 * Resolve the text direction.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveTextDirection(){
  mPrivateFlags2&=~(PFLAG2_TEXT_DIRECTION_RESOLVED | PFLAG2_TEXT_DIRECTION_RESOLVED_MASK);
  if (hasRtlSupport()) {
    final int textDirection=getRawTextDirection();
switch (textDirection) {
case TEXT_DIRECTION_INHERIT:
      if (!canResolveTextDirection()) {
        mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
        return false;
      }
    if (!mParent.isTextDirectionResolved()) {
      mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
      return false;
    }
  final int parentResolvedDirection=mParent.getTextDirection();
switch (parentResolvedDirection) {
case TEXT_DIRECTION_FIRST_STRONG:
case TEXT_DIRECTION_ANY_RTL:
case TEXT_DIRECTION_LTR:
case TEXT_DIRECTION_RTL:
case TEXT_DIRECTION_LOCALE:
  mPrivateFlags2|=(parentResolvedDirection << PFLAG2_TEXT_DIRECTION_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
break;
case TEXT_DIRECTION_FIRST_STRONG:
case TEXT_DIRECTION_ANY_RTL:
case TEXT_DIRECTION_LTR:
case TEXT_DIRECTION_RTL:
case TEXT_DIRECTION_LOCALE:
mPrivateFlags2|=(textDirection << PFLAG2_TEXT_DIRECTION_RESOLVED_MASK_SHIFT);
break;
default :
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
}
 else {
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT;
}
mPrivateFlags2|=PFLAG2_TEXT_DIRECTION_RESOLVED;
return true;
}"
2878,"/** 
 * Resolve and cache the layout direction. LTR is set initially. This is implicitly supposing that the parent directionality can and will be resolved before its children.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveLayoutDirection(){
  mPrivateFlags2&=~PFLAG2_LAYOUT_DIRECTION_RESOLVED_MASK;
  if (hasRtlSupport()) {
switch ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_MASK) >> PFLAG2_LAYOUT_DIRECTION_MASK_SHIFT) {
case LAYOUT_DIRECTION_INHERIT:
      if (!canResolveLayoutDirection())       return false;
    View parent=((View)mParent);
  if (!parent.isLayoutDirectionResolved())   return false;
if (parent.getLayoutDirection() == LAYOUT_DIRECTION_RTL) {
  mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
}
break;
case LAYOUT_DIRECTION_RTL:
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
break;
case LAYOUT_DIRECTION_LOCALE:
if ((LAYOUT_DIRECTION_RTL == TextUtils.getLayoutDirectionFromLocale(Locale.getDefault()))) {
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
}
break;
default :
}
}
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED;
return true;
}","/** 
 * Resolve and cache the layout direction. LTR is set initially. This is implicitly supposing that the parent directionality can and will be resolved before its children.
 * @return true if resolution has been done, false otherwise.
 * @hide
 */
public boolean resolveLayoutDirection(){
  mPrivateFlags2&=~PFLAG2_LAYOUT_DIRECTION_RESOLVED_MASK;
  if (hasRtlSupport()) {
switch ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_MASK) >> PFLAG2_LAYOUT_DIRECTION_MASK_SHIFT) {
case LAYOUT_DIRECTION_INHERIT:
      if (!canResolveLayoutDirection())       return false;
    if (!mParent.isLayoutDirectionResolved())     return false;
  if (mParent.getLayoutDirection() == LAYOUT_DIRECTION_RTL) {
    mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
  }
break;
case LAYOUT_DIRECTION_RTL:
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
break;
case LAYOUT_DIRECTION_LOCALE:
if ((LAYOUT_DIRECTION_RTL == TextUtils.getLayoutDirectionFromLocale(Locale.getDefault()))) {
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL;
}
break;
default :
}
}
mPrivateFlags2|=PFLAG2_LAYOUT_DIRECTION_RESOLVED;
return true;
}"
2879,"/** 
 * Check if layout direction resolution can be done.
 * @return true if layout direction resolution can be done otherwise return false.
 * @hide
 */
public boolean canResolveLayoutDirection(){
switch (getRawLayoutDirection()) {
case LAYOUT_DIRECTION_INHERIT:
    return (mParent != null) && (mParent instanceof ViewGroup) && ((ViewGroup)mParent).canResolveLayoutDirection();
default :
  return true;
}
}","/** 
 * Check if layout direction resolution can be done.
 * @return true if layout direction resolution can be done otherwise return false.
 * @hide
 */
public boolean canResolveLayoutDirection(){
switch (getRawLayoutDirection()) {
case LAYOUT_DIRECTION_INHERIT:
    return (mParent != null) && mParent.canResolveLayoutDirection();
default :
  return true;
}
}"
2880,"/** 
 * Check if text alignment resolution can be done.
 * @return true if text alignment resolution can be done otherwise return false.
 */
private boolean canResolveTextAlignment(){
switch (getRawTextAlignment()) {
case TEXT_DIRECTION_INHERIT:
    return (mParent != null) && (mParent instanceof View) && ((View)mParent).canResolveTextAlignment();
default :
  return true;
}
}","/** 
 * Check if text alignment resolution can be done.
 * @return true if text alignment resolution can be done otherwise return false.
 * @hide
 */
public boolean canResolveTextAlignment(){
switch (getRawTextAlignment()) {
case TEXT_DIRECTION_INHERIT:
    return (mParent != null) && mParent.canResolveTextAlignment();
default :
  return true;
}
}"
2881,"private static void showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
}","private static void showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
}"
2882,"private void initializeGlobals(RenderScript RS,ScriptC_alloc s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  int Z=0;
  s.set_dimX(X);
  s.set_dimY(Y);
  s.set_dimZ(Z);
  typeBuilder.setX(X).setY(Y);
  Allocation A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  typeBuilder=new Type.Builder(RS,Element.I32(RS));
  typeBuilder.setX(X).setY(Y).setFaces(true);
  Allocation AFaces=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aFaces(AFaces);
  typeBuilder.setFaces(false).setMipmaps(true);
  Allocation ALOD=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aLOD(ALOD);
  typeBuilder.setFaces(true).setMipmaps(true);
  Allocation AFacesLOD=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aFacesLOD(AFacesLOD);
  return;
}","private void initializeGlobals(RenderScript RS,ScriptC_alloc s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  int Z=0;
  s.set_dimX(X);
  s.set_dimY(Y);
  s.set_dimZ(Z);
  typeBuilder.setX(X).setY(Y);
  Allocation A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  s.set_aRaw(A);
  typeBuilder=new Type.Builder(RS,Element.I32(RS));
  typeBuilder.setX(X).setY(Y).setFaces(true);
  Allocation AFaces=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aFaces(AFaces);
  typeBuilder.setFaces(false).setMipmaps(true);
  Allocation ALOD=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aLOD(ALOD);
  typeBuilder.setFaces(true).setMipmaps(true);
  Allocation AFacesLOD=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aFacesLOD(AFacesLOD);
  return;
}"
2883,"public void run(){
  RenderScript pRS=RenderScript.create(mCtx);
  ScriptC_alloc s=new ScriptC_alloc(pRS);
  pRS.setMessageHandler(mRsMessage);
  initializeGlobals(pRS,s);
  s.invoke_alloc_test();
  pRS.finish();
  waitForMessage();
  pRS.destroy();
}","public void run(){
  RenderScript pRS=RenderScript.create(mCtx);
  ScriptC_alloc s=new ScriptC_alloc(pRS);
  pRS.setMessageHandler(mRsMessage);
  initializeGlobals(pRS,s);
  s.forEach_root(s.get_aRaw());
  s.invoke_alloc_test();
  pRS.finish();
  waitForMessage();
  pRS.destroy();
}"
2884,"private void initializeGlobals(RenderScript RS,ScriptC_foreach s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  return;
}","private void initializeGlobals(RenderScript RS,ScriptC_foreach s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aRaw(A);
  return;
}"
2885,"private void initializeGlobals(RenderScript RS,ScriptC_foreach_bounds s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  s.set_s(s);
  s.set_ain(A);
  s.set_aout(A);
  s.set_xStart(2);
  s.set_xEnd(5);
  s.set_yStart(3);
  s.set_yEnd(6);
  s.forEach_zero(A);
  return;
}","private void initializeGlobals(RenderScript RS,ScriptC_foreach_bounds s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aRaw(A);
  s.set_s(s);
  s.set_ain(A);
  s.set_aout(A);
  s.set_xStart(2);
  s.set_xEnd(5);
  s.set_yStart(3);
  s.set_yEnd(6);
  s.forEach_zero(A);
  return;
}"
2886,"private void initializeGlobals(RenderScript RS,ScriptC_noroot s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.bind_a(A);
  return;
}","private void initializeGlobals(RenderScript RS,ScriptC_noroot s){
  Type.Builder typeBuilder=new Type.Builder(RS,Element.I32(RS));
  int X=5;
  int Y=7;
  s.set_dimX(X);
  s.set_dimY(Y);
  typeBuilder.setX(X).setY(Y);
  A=Allocation.createTyped(RS,typeBuilder.create());
  s.set_aRaw(A);
  return;
}"
2887,"private static void showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
}","private static void showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
}"
2888,"private static void showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
}","private static void showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
}"
2889,"/** 
 * Implement this method to handle hover events. <p> This method is called whenever a pointer is hovering into, over, or out of the bounds of a view and the view is not currently being touched. Hover events are represented as pointer events with action  {@link MotionEvent#ACTION_HOVER_ENTER},   {@link MotionEvent#ACTION_HOVER_MOVE}, or   {@link MotionEvent#ACTION_HOVER_EXIT}. </p> <ul> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_ENTER}when the pointer enters the bounds of the view.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_MOVE}when the pointer has already entered the bounds of the view and has moved.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_EXIT}when the pointer has exited the bounds of the view or when the pointer is about to go down due to a button click, tap, or similar user action that causes the view to be touched.</li> </ul> <p> The view should implement this method to return true to indicate that it is handling the hover event, such as by changing its drawable state. </p><p> The default implementation calls   {@link #setHovered} to update the hovered stateof the view when a hover enter or hover exit event is received, if the view is enabled and is clickable.  The default implementation also sends hover accessibility events. </p>
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
public boolean onHoverEvent(MotionEvent event){
  final int action=event.getActionMasked();
  if (!mSendingHoverAccessibilityEvents) {
    if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(),event.getY())) {
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
      mSendingHoverAccessibilityEvents=true;
    }
  }
 else {
    if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(),event.getY()))) {
      mSendingHoverAccessibilityEvents=false;
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
      if (mAttachInfo != null && !mAttachInfo.mHasWindowFocus) {
        getViewRootImpl().setAccessibilityFocus(null,null);
      }
    }
  }
  if (isHoverable()) {
switch (action) {
case MotionEvent.ACTION_HOVER_ENTER:
      setHovered(true);
    break;
case MotionEvent.ACTION_HOVER_EXIT:
  setHovered(false);
break;
}
dispatchGenericMotionEventInternal(event);
return true;
}
return false;
}","/** 
 * Implement this method to handle hover events. <p> This method is called whenever a pointer is hovering into, over, or out of the bounds of a view and the view is not currently being touched. Hover events are represented as pointer events with action  {@link MotionEvent#ACTION_HOVER_ENTER},   {@link MotionEvent#ACTION_HOVER_MOVE}, or   {@link MotionEvent#ACTION_HOVER_EXIT}. </p> <ul> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_ENTER}when the pointer enters the bounds of the view.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_MOVE}when the pointer has already entered the bounds of the view and has moved.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_EXIT}when the pointer has exited the bounds of the view or when the pointer is about to go down due to a button click, tap, or similar user action that causes the view to be touched.</li> </ul> <p> The view should implement this method to return true to indicate that it is handling the hover event, such as by changing its drawable state. </p><p> The default implementation calls   {@link #setHovered} to update the hovered stateof the view when a hover enter or hover exit event is received, if the view is enabled and is clickable.  The default implementation also sends hover accessibility events. </p>
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
public boolean onHoverEvent(MotionEvent event){
  final int action=event.getActionMasked();
  if (!mSendingHoverAccessibilityEvents) {
    if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(),event.getY())) {
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
      mSendingHoverAccessibilityEvents=true;
    }
  }
 else {
    if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(),event.getY()))) {
      mSendingHoverAccessibilityEvents=false;
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
      if (mAttachInfo != null && !mAttachInfo.mHasWindowFocus) {
        getViewRootImpl().setAccessibilityFocus(null,null);
      }
    }
  }
  if (isHoverable()) {
switch (action) {
case MotionEvent.ACTION_HOVER_ENTER:
      setHovered(true);
    break;
case MotionEvent.ACTION_HOVER_EXIT:
  setHovered(false);
break;
}
return dispatchGenericMotionEventInternal(event);
}
return false;
}"
2890,"/** 
 * Implement this method to handle hover events. <p> This method is called whenever a pointer is hovering into, over, or out of the bounds of a view and the view is not currently being touched. Hover events are represented as pointer events with action  {@link MotionEvent#ACTION_HOVER_ENTER},   {@link MotionEvent#ACTION_HOVER_MOVE}, or   {@link MotionEvent#ACTION_HOVER_EXIT}. </p> <ul> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_ENTER}when the pointer enters the bounds of the view.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_MOVE}when the pointer has already entered the bounds of the view and has moved.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_EXIT}when the pointer has exited the bounds of the view or when the pointer is about to go down due to a button click, tap, or similar user action that causes the view to be touched.</li> </ul> <p> The view should implement this method to return true to indicate that it is handling the hover event, such as by changing its drawable state. </p><p> The default implementation calls   {@link #setHovered} to update the hovered stateof the view when a hover enter or hover exit event is received, if the view is enabled and is clickable.  The default implementation also sends hover accessibility events. </p>
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
public boolean onHoverEvent(MotionEvent event){
  final int action=event.getActionMasked();
  if (!mSendingHoverAccessibilityEvents) {
    if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(),event.getY())) {
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
      mSendingHoverAccessibilityEvents=true;
    }
  }
 else {
    if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(),event.getY()))) {
      mSendingHoverAccessibilityEvents=false;
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
      if (mAttachInfo != null && !mAttachInfo.mHasWindowFocus) {
        getViewRootImpl().setAccessibilityFocus(null,null);
      }
    }
  }
  if (isHoverable()) {
switch (action) {
case MotionEvent.ACTION_HOVER_ENTER:
      setHovered(true);
    break;
case MotionEvent.ACTION_HOVER_EXIT:
  setHovered(false);
break;
}
dispatchGenericMotionEventInternal(event);
return true;
}
return false;
}","/** 
 * Implement this method to handle hover events. <p> This method is called whenever a pointer is hovering into, over, or out of the bounds of a view and the view is not currently being touched. Hover events are represented as pointer events with action  {@link MotionEvent#ACTION_HOVER_ENTER},   {@link MotionEvent#ACTION_HOVER_MOVE}, or   {@link MotionEvent#ACTION_HOVER_EXIT}. </p> <ul> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_ENTER}when the pointer enters the bounds of the view.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_MOVE}when the pointer has already entered the bounds of the view and has moved.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_EXIT}when the pointer has exited the bounds of the view or when the pointer is about to go down due to a button click, tap, or similar user action that causes the view to be touched.</li> </ul> <p> The view should implement this method to return true to indicate that it is handling the hover event, such as by changing its drawable state. </p><p> The default implementation calls   {@link #setHovered} to update the hovered stateof the view when a hover enter or hover exit event is received, if the view is enabled and is clickable.  The default implementation also sends hover accessibility events. </p>
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
public boolean onHoverEvent(MotionEvent event){
  final int action=event.getActionMasked();
  if (!mSendingHoverAccessibilityEvents) {
    if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(),event.getY())) {
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
      mSendingHoverAccessibilityEvents=true;
    }
  }
 else {
    if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(),event.getY()))) {
      mSendingHoverAccessibilityEvents=false;
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
      if (mAttachInfo != null && !mAttachInfo.mHasWindowFocus) {
        getViewRootImpl().setAccessibilityFocus(null,null);
      }
    }
  }
  if (isHoverable()) {
switch (action) {
case MotionEvent.ACTION_HOVER_ENTER:
      setHovered(true);
    break;
case MotionEvent.ACTION_HOVER_EXIT:
  setHovered(false);
break;
}
return dispatchGenericMotionEventInternal(event);
}
return false;
}"
2891,"/** 
 * Implement this method to handle hover events. <p> This method is called whenever a pointer is hovering into, over, or out of the bounds of a view and the view is not currently being touched. Hover events are represented as pointer events with action  {@link MotionEvent#ACTION_HOVER_ENTER},   {@link MotionEvent#ACTION_HOVER_MOVE}, or   {@link MotionEvent#ACTION_HOVER_EXIT}. </p> <ul> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_ENTER}when the pointer enters the bounds of the view.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_MOVE}when the pointer has already entered the bounds of the view and has moved.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_EXIT}when the pointer has exited the bounds of the view or when the pointer is about to go down due to a button click, tap, or similar user action that causes the view to be touched.</li> </ul> <p> The view should implement this method to return true to indicate that it is handling the hover event, such as by changing its drawable state. </p><p> The default implementation calls   {@link #setHovered} to update the hovered stateof the view when a hover enter or hover exit event is received, if the view is enabled and is clickable.  The default implementation also sends hover accessibility events. </p>
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
public boolean onHoverEvent(MotionEvent event){
  final int action=event.getActionMasked();
  if (!mSendingHoverAccessibilityEvents) {
    if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(),event.getY())) {
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
      mSendingHoverAccessibilityEvents=true;
    }
  }
 else {
    if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(),event.getY()))) {
      mSendingHoverAccessibilityEvents=false;
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
      if (mAttachInfo != null && !mAttachInfo.mHasWindowFocus) {
        getViewRootImpl().setAccessibilityFocus(null,null);
      }
    }
  }
  if (isHoverable()) {
switch (action) {
case MotionEvent.ACTION_HOVER_ENTER:
      setHovered(true);
    break;
case MotionEvent.ACTION_HOVER_EXIT:
  setHovered(false);
break;
}
dispatchGenericMotionEventInternal(event);
return true;
}
return false;
}","/** 
 * Implement this method to handle hover events. <p> This method is called whenever a pointer is hovering into, over, or out of the bounds of a view and the view is not currently being touched. Hover events are represented as pointer events with action  {@link MotionEvent#ACTION_HOVER_ENTER},   {@link MotionEvent#ACTION_HOVER_MOVE}, or   {@link MotionEvent#ACTION_HOVER_EXIT}. </p> <ul> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_ENTER}when the pointer enters the bounds of the view.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_MOVE}when the pointer has already entered the bounds of the view and has moved.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_EXIT}when the pointer has exited the bounds of the view or when the pointer is about to go down due to a button click, tap, or similar user action that causes the view to be touched.</li> </ul> <p> The view should implement this method to return true to indicate that it is handling the hover event, such as by changing its drawable state. </p><p> The default implementation calls   {@link #setHovered} to update the hovered stateof the view when a hover enter or hover exit event is received, if the view is enabled and is clickable.  The default implementation also sends hover accessibility events. </p>
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
public boolean onHoverEvent(MotionEvent event){
  final int action=event.getActionMasked();
  if (!mSendingHoverAccessibilityEvents) {
    if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(),event.getY())) {
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
      mSendingHoverAccessibilityEvents=true;
    }
  }
 else {
    if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(),event.getY()))) {
      mSendingHoverAccessibilityEvents=false;
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
      if (mAttachInfo != null && !mAttachInfo.mHasWindowFocus) {
        getViewRootImpl().setAccessibilityFocus(null,null);
      }
    }
  }
  if (isHoverable()) {
switch (action) {
case MotionEvent.ACTION_HOVER_ENTER:
      setHovered(true);
    break;
case MotionEvent.ACTION_HOVER_EXIT:
  setHovered(false);
break;
}
return dispatchGenericMotionEventInternal(event);
}
return false;
}"
2892,"/** 
 * Sets the fully qualified resource name of the source view's id. <p> <strong>Note:</strong> Cannot be called from an  {@link android.accessibilityservice.AccessibilityService}. This class is made immutable before being delivered to an AccessibilityService. </p>
 * @param viewId The id resource name.
 */
public void setViewIdResourceName(CharSequence viewIdResName){
  enforceNotSealed();
  mViewIdResourceName=viewIdResName;
}","/** 
 * Sets the fully qualified resource name of the source view's id. <p> <strong>Note:</strong> Cannot be called from an  {@link android.accessibilityservice.AccessibilityService}. This class is made immutable before being delivered to an AccessibilityService. </p>
 * @param viewIdResName The id resource name.
 */
public void setViewIdResourceName(CharSequence viewIdResName){
  enforceNotSealed();
  mViewIdResourceName=viewIdResName;
}"
2893,"/** 
 * Sets the fully qualified resource name of the source view's id. <p> <strong>Note:</strong> Cannot be called from an  {@link android.accessibilityservice.AccessibilityService}. This class is made immutable before being delivered to an AccessibilityService. </p>
 * @param viewId The id resource name.
 */
public void setViewIdResourceName(CharSequence viewIdResName){
  enforceNotSealed();
  mViewIdResourceName=viewIdResName;
}","/** 
 * Sets the fully qualified resource name of the source view's id. <p> <strong>Note:</strong> Cannot be called from an  {@link android.accessibilityservice.AccessibilityService}. This class is made immutable before being delivered to an AccessibilityService. </p>
 * @param viewIdResName The id resource name.
 */
public void setViewIdResourceName(CharSequence viewIdResName){
  enforceNotSealed();
  mViewIdResourceName=viewIdResName;
}"
2894,"public RelativeLayout(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  initFromAttributes(context,attrs);
  mAllowBrokenMeasureSpecs=context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.JELLY_BEAN_MR1;
}","public RelativeLayout(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  initFromAttributes(context,attrs);
  mAllowBrokenMeasureSpecs=context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.JELLY_BEAN_MR1;
  getDisplayWidth();
}"
2895,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  if (isLayoutRtl() && (myWidth == -1 || isWrapContentWidth)) {
    int w=getPaddingStart() + getPaddingEnd();
    for (int i=0; i < count; i++) {
      View child=views[i];
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        int[] rules=params.getRules(View.LAYOUT_DIRECTION_LTR);
        applyHorizontalSizeRules(params,myWidth,rules);
        measureChildHorizontal(child,params,-1,myHeight);
        w+=child.getMeasuredWidth();
        w+=params.leftMargin + params.rightMargin;
      }
    }
    if (myWidth == -1) {
      myWidth=w;
    }
 else {
      if (w > 0) {
        myWidth=Math.min(myWidth,w);
      }
    }
  }
  final int layoutDirection=getLayoutDirection();
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        width=Math.max(width,params.mRight);
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  final int layoutDirection=getLayoutDirection();
  if (isLayoutRtl() && myWidth == -1) {
    myWidth=mDisplayWidth;
  }
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        if (isLayoutRtl()) {
          width=Math.max(width,myWidth - params.mLeft);
        }
 else {
          width=Math.max(width,params.mRight);
        }
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  if (isLayoutRtl()) {
    final int offsetWidth=myWidth - width;
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        params.mLeft-=offsetWidth;
        params.mRight-=offsetWidth;
      }
    }
  }
  setMeasuredDimension(width,height);
}"
2896,"public RelativeLayout(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  initFromAttributes(context,attrs);
  mAllowBrokenMeasureSpecs=context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.JELLY_BEAN_MR1;
}","public RelativeLayout(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  initFromAttributes(context,attrs);
  mAllowBrokenMeasureSpecs=context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.JELLY_BEAN_MR1;
  getDisplayWidth();
}"
2897,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  if (isLayoutRtl() && (myWidth == -1 || isWrapContentWidth)) {
    int w=getPaddingStart() + getPaddingEnd();
    for (int i=0; i < count; i++) {
      View child=views[i];
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        int[] rules=params.getRules(View.LAYOUT_DIRECTION_LTR);
        applyHorizontalSizeRules(params,myWidth,rules);
        measureChildHorizontal(child,params,-1,myHeight);
        w+=child.getMeasuredWidth();
        w+=params.leftMargin + params.rightMargin;
      }
    }
    if (myWidth == -1) {
      myWidth=w;
    }
 else {
      if (w > 0) {
        myWidth=Math.min(myWidth,w);
      }
    }
  }
  final int layoutDirection=getLayoutDirection();
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        width=Math.max(width,params.mRight);
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  final int layoutDirection=getLayoutDirection();
  if (isLayoutRtl() && myWidth == -1) {
    myWidth=mDisplayWidth;
  }
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        if (isLayoutRtl()) {
          width=Math.max(width,myWidth - params.mLeft);
        }
 else {
          width=Math.max(width,params.mRight);
        }
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  if (isLayoutRtl()) {
    final int offsetWidth=myWidth - width;
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        params.mLeft-=offsetWidth;
        params.mRight-=offsetWidth;
      }
    }
  }
  setMeasuredDimension(width,height);
}"
2898,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(packageName);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromUid);
  pw.print(""String_Node_Str"");
  pw.println(userId);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  pw.print(prefix);
  pw.println(intent.toInsecureStringWithClip());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frontOfTask);
  pw.print(""String_Node_Str"");
  pw.println(task);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskAffinity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(realActivity.flattenToShortString());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(baseDir);
  if (!resDir.equals(baseDir)) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(resDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(stateNotNeeded);
  pw.print(""String_Node_Str"");
  pw.print(componentSpecified);
  pw.print(""String_Node_Str"");
  pw.println(isHomeActivity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(compat);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(labelRes));
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(icon));
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(theme));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(configuration);
  if (resultTo != null || resultWho != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(resultTo);
    pw.print(""String_Node_Str"");
    pw.print(resultWho);
    pw.print(""String_Node_Str"");
    pw.println(requestCode);
  }
  if (results != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(results);
  }
  if (pendingResults != null && pendingResults.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (    WeakReference<PendingIntentRecord> wpir : pendingResults) {
      PendingIntentRecord pir=wpir != null ? wpir.get() : null;
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (pir == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(pir);
        pir.dump(pw,prefix + ""String_Node_Str"");
      }
    }
  }
  if (newIntents != null && newIntents.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < newIntents.size(); i++) {
      Intent intent=(Intent)newIntents.get(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (intent == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(intent.toShortString(false,true,false,true));
      }
    }
  }
  if (pendingOptions != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pendingOptions);
  }
  if (uriPermissions != null) {
    if (uriPermissions.readUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.readUriPermissions);
    }
    if (uriPermissions.writeUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.writeUriPermissions);
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchFailed);
  pw.print(""String_Node_Str"");
  pw.print(haveState);
  pw.print(""String_Node_Str"");
  pw.println(icicle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(state);
  pw.print(""String_Node_Str"");
  pw.print(stopped);
  pw.print(""String_Node_Str"");
  pw.print(delayedResume);
  pw.print(""String_Node_Str"");
  pw.println(finishing);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(keysPaused);
  pw.print(""String_Node_Str"");
  pw.print(inHistory);
  pw.print(""String_Node_Str"");
  pw.print(visible);
  pw.print(""String_Node_Str"");
  pw.print(sleeping);
  pw.print(""String_Node_Str"");
  pw.println(idle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(fullscreen);
  pw.print(""String_Node_Str"");
  pw.print(noDisplay);
  pw.print(""String_Node_Str"");
  pw.print(immersive);
  pw.print(""String_Node_Str"");
  pw.println(launchMode);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frozenBeforeDestroy);
  pw.print(""String_Node_Str"");
  pw.print(thumbnailNeeded);
  pw.print(""String_Node_Str"");
  pw.println(forceNewConfig);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(System.identityHashCode(thumbHolder)));
  if (thumbHolder != null) {
    pw.print(""String_Node_Str"");
    pw.print(thumbHolder.lastThumbnail);
    pw.print(""String_Node_Str"");
    pw.print(thumbHolder.lastDescription);
  }
  pw.println();
  if (launchTime != 0 || startTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    if (launchTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(launchTime,now,pw);
    pw.print(""String_Node_Str"");
    if (startTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(startTime,now,pw);
    pw.println();
  }
  if (lastVisibleTime != 0 || waitingVisible || nowVisible) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(waitingVisible);
    pw.print(""String_Node_Str"");
    pw.print(nowVisible);
    pw.print(""String_Node_Str"");
    if (lastVisibleTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(lastVisibleTime,now,pw);
    pw.println();
  }
  if (configDestroy || configChangeFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(configDestroy);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(configChangeFlags));
  }
  if (connections != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(packageName);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromUid);
  pw.print(""String_Node_Str"");
  pw.println(userId);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  pw.print(prefix);
  pw.println(intent.toInsecureStringWithClip());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frontOfTask);
  pw.print(""String_Node_Str"");
  pw.println(task);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskAffinity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(realActivity.flattenToShortString());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(baseDir);
  if (!resDir.equals(baseDir)) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(resDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(stateNotNeeded);
  pw.print(""String_Node_Str"");
  pw.print(componentSpecified);
  pw.print(""String_Node_Str"");
  pw.println(isHomeActivity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(compat);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(labelRes));
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(icon));
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(theme));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(configuration);
  if (resultTo != null || resultWho != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(resultTo);
    pw.print(""String_Node_Str"");
    pw.print(resultWho);
    pw.print(""String_Node_Str"");
    pw.println(requestCode);
  }
  if (results != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(results);
  }
  if (pendingResults != null && pendingResults.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (    WeakReference<PendingIntentRecord> wpir : pendingResults) {
      PendingIntentRecord pir=wpir != null ? wpir.get() : null;
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (pir == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(pir);
        pir.dump(pw,prefix + ""String_Node_Str"");
      }
    }
  }
  if (newIntents != null && newIntents.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < newIntents.size(); i++) {
      Intent intent=(Intent)newIntents.get(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (intent == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(intent.toShortString(false,true,false,true));
      }
    }
  }
  if (pendingOptions != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pendingOptions);
  }
  if (uriPermissions != null) {
    if (uriPermissions.readUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.readUriPermissions);
    }
    if (uriPermissions.writeUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.writeUriPermissions);
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchFailed);
  pw.print(""String_Node_Str"");
  pw.print(launchCount);
  pw.print(""String_Node_Str"");
  if (lastLaunchTime == 0)   pw.print(""String_Node_Str"");
 else   TimeUtils.formatDuration(lastLaunchTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(haveState);
  pw.print(""String_Node_Str"");
  pw.println(icicle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(state);
  pw.print(""String_Node_Str"");
  pw.print(stopped);
  pw.print(""String_Node_Str"");
  pw.print(delayedResume);
  pw.print(""String_Node_Str"");
  pw.println(finishing);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(keysPaused);
  pw.print(""String_Node_Str"");
  pw.print(inHistory);
  pw.print(""String_Node_Str"");
  pw.print(visible);
  pw.print(""String_Node_Str"");
  pw.print(sleeping);
  pw.print(""String_Node_Str"");
  pw.println(idle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(fullscreen);
  pw.print(""String_Node_Str"");
  pw.print(noDisplay);
  pw.print(""String_Node_Str"");
  pw.print(immersive);
  pw.print(""String_Node_Str"");
  pw.println(launchMode);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frozenBeforeDestroy);
  pw.print(""String_Node_Str"");
  pw.print(thumbnailNeeded);
  pw.print(""String_Node_Str"");
  pw.println(forceNewConfig);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(System.identityHashCode(thumbHolder)));
  if (thumbHolder != null) {
    pw.print(""String_Node_Str"");
    pw.print(thumbHolder.lastThumbnail);
    pw.print(""String_Node_Str"");
    pw.print(thumbHolder.lastDescription);
  }
  pw.println();
  if (launchTime != 0 || startTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    if (launchTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(launchTime,now,pw);
    pw.print(""String_Node_Str"");
    if (startTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(startTime,now,pw);
    pw.println();
  }
  if (lastVisibleTime != 0 || waitingVisible || nowVisible) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(waitingVisible);
    pw.print(""String_Node_Str"");
    pw.print(nowVisible);
    pw.print(""String_Node_Str"");
    if (lastVisibleTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(lastVisibleTime,now,pw);
    pw.println();
  }
  if (configDestroy || configChangeFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(configDestroy);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(configChangeFlags));
  }
  if (connections != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
}"
2899,"final void activityStoppedLocked(ActivityRecord r,Bundle icicle,Bitmap thumbnail,CharSequence description){
  if (r.state != ActivityState.STOPPING) {
    Slog.i(TAG,""String_Node_Str"" + r);
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    return;
  }
  if (DEBUG_SAVED_STATE)   Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ icicle);
  if (icicle != null) {
    r.icicle=icicle;
    r.haveState=true;
    r.updateThumbnail(thumbnail,description);
  }
  if (!r.stopped) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    r.stopped=true;
    r.state=ActivityState.STOPPED;
    if (r.finishing) {
      r.clearOptionsLocked();
    }
 else {
      if (r.configDestroy) {
        destroyActivityLocked(r,true,false,""String_Node_Str"");
        resumeTopActivityLocked(null);
      }
 else {
        ProcessRecord fgApp=null;
        if (mResumedActivity != null) {
          fgApp=mResumedActivity.app;
        }
 else         if (mPausingActivity != null) {
          fgApp=mPausingActivity.app;
        }
        if (r.app != null && fgApp != null && r.app != fgApp && r.lastVisibleTime > mService.mPreviousProcessVisibleTime && r.app != mService.mHomeProcess) {
          mService.mPreviousProcess=r.app;
          mService.mPreviousProcessVisibleTime=r.lastVisibleTime;
        }
      }
    }
  }
}","final void activityStoppedLocked(ActivityRecord r,Bundle icicle,Bitmap thumbnail,CharSequence description){
  if (r.state != ActivityState.STOPPING) {
    Slog.i(TAG,""String_Node_Str"" + r);
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    return;
  }
  if (DEBUG_SAVED_STATE)   Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ icicle);
  if (icicle != null) {
    r.icicle=icicle;
    r.haveState=true;
    r.launchCount=0;
    r.updateThumbnail(thumbnail,description);
  }
  if (!r.stopped) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    r.stopped=true;
    r.state=ActivityState.STOPPED;
    if (r.finishing) {
      r.clearOptionsLocked();
    }
 else {
      if (r.configDestroy) {
        destroyActivityLocked(r,true,false,""String_Node_Str"");
        resumeTopActivityLocked(null);
      }
 else {
        ProcessRecord fgApp=null;
        if (mResumedActivity != null) {
          fgApp=mResumedActivity.app;
        }
 else         if (mPausingActivity != null) {
          fgApp=mPausingActivity.app;
        }
        if (r.app != null && fgApp != null && r.app != fgApp && r.lastVisibleTime > mService.mPreviousProcessVisibleTime && r.app != mService.mHomeProcess) {
          mService.mPreviousProcess=r.app;
          mService.mPreviousProcessVisibleTime=r.lastVisibleTime;
        }
      }
    }
  }
}"
2900,"/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    r.app=null;
  }
  mFinishingActivities.remove(r);
  mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (mService.mPendingThumbnails.size() > 0) {
    mService.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}","/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    if (DEBUG_APP)     Slog.v(TAG,""String_Node_Str"" + r);
    r.app=null;
  }
  mFinishingActivities.remove(r);
  mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (mService.mPendingThumbnails.size() > 0) {
    mService.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}"
2901,"boolean removeHistoryRecordsForAppLocked(ProcessRecord app){
  removeHistoryRecordsForAppLocked(mLRUActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mStoppingActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mGoingToSleepActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mWaitingVisibleActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mFinishingActivities,app,""String_Node_Str"");
  boolean hasVisibleActivities=false;
  int i=mHistory.size();
  if (DEBUG_CLEANUP)   Slog.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ i+ ""String_Node_Str"");
  while (i > 0) {
    i--;
    ActivityRecord r=(ActivityRecord)mHistory.get(i);
    if (DEBUG_CLEANUP)     Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.app);
    if (r.app == app) {
      if ((!r.haveState && !r.stateNotNeeded) || r.finishing) {
        if (ActivityStack.DEBUG_ADD_REMOVE || DEBUG_CLEANUP) {
          RuntimeException here=new RuntimeException(""String_Node_Str"");
          here.fillInStackTrace();
          Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ i+ ""String_Node_Str""+ r.haveState+ ""String_Node_Str""+ r.stateNotNeeded+ ""String_Node_Str""+ r.finishing+ ""String_Node_Str""+ r.state,here);
        }
        if (!r.finishing) {
          Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
          EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName,""String_Node_Str"");
        }
        removeActivityFromHistoryLocked(r);
      }
 else {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"");
        if (r.visible) {
          hasVisibleActivities=true;
        }
        r.app=null;
        r.nowVisible=false;
        if (!r.haveState) {
          if (ActivityStack.DEBUG_SAVED_STATE)           Slog.i(TAG,""String_Node_Str"" + r);
          r.icicle=null;
        }
      }
      r.stack.cleanUpActivityLocked(r,true,true);
    }
  }
  return hasVisibleActivities;
}","boolean removeHistoryRecordsForAppLocked(ProcessRecord app){
  removeHistoryRecordsForAppLocked(mLRUActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mStoppingActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mGoingToSleepActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mWaitingVisibleActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mFinishingActivities,app,""String_Node_Str"");
  boolean hasVisibleActivities=false;
  int i=mHistory.size();
  if (DEBUG_CLEANUP)   Slog.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ i+ ""String_Node_Str"");
  while (i > 0) {
    i--;
    ActivityRecord r=(ActivityRecord)mHistory.get(i);
    if (DEBUG_CLEANUP)     Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.app);
    if (r.app == app) {
      boolean remove;
      if ((!r.haveState && !r.stateNotNeeded) || r.finishing) {
        remove=true;
      }
 else       if (r.launchCount > 2 && r.lastLaunchTime > (SystemClock.uptimeMillis() - 60000)) {
        remove=true;
      }
 else {
        remove=false;
      }
      if (remove) {
        if (ActivityStack.DEBUG_ADD_REMOVE || DEBUG_CLEANUP) {
          RuntimeException here=new RuntimeException(""String_Node_Str"");
          here.fillInStackTrace();
          Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ i+ ""String_Node_Str""+ r.haveState+ ""String_Node_Str""+ r.stateNotNeeded+ ""String_Node_Str""+ r.finishing+ ""String_Node_Str""+ r.state,here);
        }
        if (!r.finishing) {
          Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
          EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName,""String_Node_Str"");
        }
        removeActivityFromHistoryLocked(r);
      }
 else {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"");
        if (r.visible) {
          hasVisibleActivities=true;
        }
        if (DEBUG_APP)         Slog.v(TAG,""String_Node_Str"" + r);
        r.app=null;
        r.nowVisible=false;
        if (!r.haveState) {
          if (ActivityStack.DEBUG_SAVED_STATE)           Slog.i(TAG,""String_Node_Str"" + r);
          r.icicle=null;
        }
      }
      r.stack.cleanUpActivityLocked(r,true,true);
    }
  }
  return hasVisibleActivities;
}"
2902,"final boolean realStartActivityLocked(ActivityRecord r,ProcessRecord app,boolean andResume,boolean checkConfig) throws RemoteException {
  r.startFreezingScreenLocked(app,0);
  mService.mWindowManager.setAppVisibility(r.appToken,true);
  r.startLaunchTickingLocked();
  if (checkConfig) {
    Configuration config=mService.mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,r.mayFreezeScreenLocked(app) ? r.appToken : null);
    mService.updateConfigurationLocked(config,r,false,false);
  }
  r.app=app;
  app.waitingToKill=null;
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + r);
  int idx=app.activities.indexOf(r);
  if (idx < 0) {
    app.activities.add(r);
  }
  mService.updateLruProcessLocked(app,true);
  try {
    if (app.thread == null) {
      throw new RemoteException();
    }
    List<ResultInfo> results=null;
    List<Intent> newIntents=null;
    if (andResume) {
      results=r.results;
      newIntents=r.newIntents;
    }
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.icicle+ ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
    if (andResume) {
      EventLog.writeEvent(EventLogTags.AM_RESTART_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
    }
    if (r.isHomeActivity) {
      mService.mHomeProcess=app;
    }
    mService.ensurePackageDexOpt(r.intent.getComponent().getPackageName());
    r.sleeping=false;
    r.forceNewConfig=false;
    showAskCompatModeDialogLocked(r);
    r.compat=mService.compatibilityInfoForPackageLocked(r.info.applicationInfo);
    String profileFile=null;
    ParcelFileDescriptor profileFd=null;
    boolean profileAutoStop=false;
    if (mService.mProfileApp != null && mService.mProfileApp.equals(app.processName)) {
      if (mService.mProfileProc == null || mService.mProfileProc == app) {
        mService.mProfileProc=app;
        profileFile=mService.mProfileFile;
        profileFd=mService.mProfileFd;
        profileAutoStop=mService.mAutoStopProfiler;
      }
    }
    app.hasShownUi=true;
    app.pendingUiClean=true;
    if (profileFd != null) {
      try {
        profileFd=profileFd.dup();
      }
 catch (      IOException e) {
        profileFd=null;
      }
    }
    app.thread.scheduleLaunchActivity(new Intent(r.intent),r.appToken,System.identityHashCode(r),r.info,new Configuration(mService.mConfiguration),r.compat,r.icicle,results,newIntents,!andResume,mService.isNextTransitionForward(),profileFile,profileFd,profileAutoStop);
    if ((app.info.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
      if (app.processName.equals(app.info.packageName)) {
        if (mService.mHeavyWeightProcess != null && mService.mHeavyWeightProcess != app) {
          Log.w(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ mService.mHeavyWeightProcess);
        }
        mService.mHeavyWeightProcess=app;
        Message msg=mService.mHandler.obtainMessage(ActivityManagerService.POST_HEAVY_NOTIFICATION_MSG);
        msg.obj=r;
        mService.mHandler.sendMessage(msg);
      }
    }
  }
 catch (  RemoteException e) {
    if (r.launchFailed) {
      Slog.e(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString() + ""String_Node_Str"",e);
      mService.appDiedLocked(app,app.pid,app.thread);
      requestFinishActivityLocked(r.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
      return false;
    }
    app.activities.remove(r);
    throw e;
  }
  r.launchFailed=false;
  if (updateLRUListLocked(r)) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  if (andResume) {
    r.state=ActivityState.RESUMED;
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.stopped=false;
    mResumedActivity=r;
    r.task.touchActiveTime();
    if (mMainStack) {
      mService.addRecentTaskLocked(r.task);
    }
    completeResumeLocked(r);
    checkReadyForSleepLocked();
    if (DEBUG_SAVED_STATE)     Slog.i(TAG,""String_Node_Str"" + r.icicle);
  }
 else {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.STOPPED;
    r.stopped=true;
  }
  if (mMainStack) {
    mService.startSetupActivityLocked();
  }
  return true;
}","final boolean realStartActivityLocked(ActivityRecord r,ProcessRecord app,boolean andResume,boolean checkConfig) throws RemoteException {
  r.startFreezingScreenLocked(app,0);
  mService.mWindowManager.setAppVisibility(r.appToken,true);
  r.startLaunchTickingLocked();
  if (checkConfig) {
    Configuration config=mService.mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,r.mayFreezeScreenLocked(app) ? r.appToken : null);
    mService.updateConfigurationLocked(config,r,false,false);
  }
  r.app=app;
  app.waitingToKill=null;
  r.launchCount++;
  r.lastLaunchTime=SystemClock.uptimeMillis();
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + r);
  int idx=app.activities.indexOf(r);
  if (idx < 0) {
    app.activities.add(r);
  }
  mService.updateLruProcessLocked(app,true);
  try {
    if (app.thread == null) {
      throw new RemoteException();
    }
    List<ResultInfo> results=null;
    List<Intent> newIntents=null;
    if (andResume) {
      results=r.results;
      newIntents=r.newIntents;
    }
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.icicle+ ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
    if (andResume) {
      EventLog.writeEvent(EventLogTags.AM_RESTART_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
    }
    if (r.isHomeActivity) {
      mService.mHomeProcess=app;
    }
    mService.ensurePackageDexOpt(r.intent.getComponent().getPackageName());
    r.sleeping=false;
    r.forceNewConfig=false;
    showAskCompatModeDialogLocked(r);
    r.compat=mService.compatibilityInfoForPackageLocked(r.info.applicationInfo);
    String profileFile=null;
    ParcelFileDescriptor profileFd=null;
    boolean profileAutoStop=false;
    if (mService.mProfileApp != null && mService.mProfileApp.equals(app.processName)) {
      if (mService.mProfileProc == null || mService.mProfileProc == app) {
        mService.mProfileProc=app;
        profileFile=mService.mProfileFile;
        profileFd=mService.mProfileFd;
        profileAutoStop=mService.mAutoStopProfiler;
      }
    }
    app.hasShownUi=true;
    app.pendingUiClean=true;
    if (profileFd != null) {
      try {
        profileFd=profileFd.dup();
      }
 catch (      IOException e) {
        profileFd=null;
      }
    }
    app.thread.scheduleLaunchActivity(new Intent(r.intent),r.appToken,System.identityHashCode(r),r.info,new Configuration(mService.mConfiguration),r.compat,r.icicle,results,newIntents,!andResume,mService.isNextTransitionForward(),profileFile,profileFd,profileAutoStop);
    if ((app.info.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
      if (app.processName.equals(app.info.packageName)) {
        if (mService.mHeavyWeightProcess != null && mService.mHeavyWeightProcess != app) {
          Log.w(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ mService.mHeavyWeightProcess);
        }
        mService.mHeavyWeightProcess=app;
        Message msg=mService.mHandler.obtainMessage(ActivityManagerService.POST_HEAVY_NOTIFICATION_MSG);
        msg.obj=r;
        mService.mHandler.sendMessage(msg);
      }
    }
  }
 catch (  RemoteException e) {
    if (r.launchFailed) {
      Slog.e(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString() + ""String_Node_Str"",e);
      mService.appDiedLocked(app,app.pid,app.thread);
      requestFinishActivityLocked(r.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
      return false;
    }
    app.activities.remove(r);
    throw e;
  }
  r.launchFailed=false;
  if (updateLRUListLocked(r)) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  if (andResume) {
    r.state=ActivityState.RESUMED;
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.stopped=false;
    mResumedActivity=r;
    r.task.touchActiveTime();
    if (mMainStack) {
      mService.addRecentTaskLocked(r.task);
    }
    completeResumeLocked(r);
    checkReadyForSleepLocked();
    if (DEBUG_SAVED_STATE)     Slog.i(TAG,""String_Node_Str"" + r.icicle);
  }
 else {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.STOPPED;
    r.stopped=true;
  }
  if (mMainStack) {
    mService.startSetupActivityLocked();
  }
  return true;
}"
2903,"/** 
 * Destroy the current CLIENT SIDE instance of an activity.  This may be called both when actually finishing an activity, or when performing a configuration switch where we destroy the current client-side object but then create a new client-side object for this same HistoryRecord.
 */
final boolean destroyActivityLocked(ActivityRecord r,boolean removeFromApp,boolean oomAdj,String reason){
  if (DEBUG_SWITCH || DEBUG_CLEANUP)   Slog.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ r+ ""String_Node_Str""+ (r.app != null ? r.app.processName : ""String_Node_Str""));
  EventLog.writeEvent(EventLogTags.AM_DESTROY_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  boolean removedFromHistory=false;
  cleanUpActivityLocked(r,false,false);
  final boolean hadApp=r.app != null;
  if (hadApp) {
    if (removeFromApp) {
      int idx=r.app.activities.indexOf(r);
      if (idx >= 0) {
        r.app.activities.remove(idx);
      }
      if (mService.mHeavyWeightProcess == r.app && r.app.activities.size() <= 0) {
        mService.mHeavyWeightProcess=null;
        mService.mHandler.sendEmptyMessage(ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);
      }
      if (r.app.activities.size() == 0) {
        mService.updateOomAdjLocked();
      }
    }
    boolean skipDestroy=false;
    try {
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleDestroyActivity(r.appToken,r.finishing,r.configChangeFlags);
    }
 catch (    Exception e) {
      if (r.finishing) {
        removeActivityFromHistoryLocked(r);
        removedFromHistory=true;
        skipDestroy=true;
      }
    }
    r.nowVisible=false;
    if (r.finishing && !skipDestroy) {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYING;
      Message msg=mHandler.obtainMessage(DESTROY_TIMEOUT_MSG);
      msg.obj=r;
      mHandler.sendMessageDelayed(msg,DESTROY_TIMEOUT);
    }
 else {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYED;
      r.app=null;
    }
  }
 else {
    if (r.finishing) {
      removeActivityFromHistoryLocked(r);
      removedFromHistory=true;
    }
 else {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYED;
      r.app=null;
    }
  }
  r.configChangeFlags=0;
  if (!mLRUActivities.remove(r) && hadApp) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  return removedFromHistory;
}","/** 
 * Destroy the current CLIENT SIDE instance of an activity.  This may be called both when actually finishing an activity, or when performing a configuration switch where we destroy the current client-side object but then create a new client-side object for this same HistoryRecord.
 */
final boolean destroyActivityLocked(ActivityRecord r,boolean removeFromApp,boolean oomAdj,String reason){
  if (DEBUG_SWITCH || DEBUG_CLEANUP)   Slog.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ r+ ""String_Node_Str""+ (r.app != null ? r.app.processName : ""String_Node_Str""));
  EventLog.writeEvent(EventLogTags.AM_DESTROY_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  boolean removedFromHistory=false;
  cleanUpActivityLocked(r,false,false);
  final boolean hadApp=r.app != null;
  if (hadApp) {
    if (removeFromApp) {
      int idx=r.app.activities.indexOf(r);
      if (idx >= 0) {
        r.app.activities.remove(idx);
      }
      if (mService.mHeavyWeightProcess == r.app && r.app.activities.size() <= 0) {
        mService.mHeavyWeightProcess=null;
        mService.mHandler.sendEmptyMessage(ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);
      }
      if (r.app.activities.size() == 0) {
        mService.updateOomAdjLocked();
      }
    }
    boolean skipDestroy=false;
    try {
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleDestroyActivity(r.appToken,r.finishing,r.configChangeFlags);
    }
 catch (    Exception e) {
      if (r.finishing) {
        removeActivityFromHistoryLocked(r);
        removedFromHistory=true;
        skipDestroy=true;
      }
    }
    r.nowVisible=false;
    if (r.finishing && !skipDestroy) {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYING;
      Message msg=mHandler.obtainMessage(DESTROY_TIMEOUT_MSG);
      msg.obj=r;
      mHandler.sendMessageDelayed(msg,DESTROY_TIMEOUT);
    }
 else {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYED;
      if (DEBUG_APP)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app=null;
    }
  }
 else {
    if (r.finishing) {
      removeActivityFromHistoryLocked(r);
      removedFromHistory=true;
    }
 else {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYED;
      if (DEBUG_APP)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app=null;
    }
  }
  r.configChangeFlags=0;
  if (!mLRUActivities.remove(r) && hadApp) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  return removedFromHistory;
}"
2904,"final void removeActivityFromHistoryLocked(ActivityRecord r){
  finishActivityResultsLocked(r,Activity.RESULT_CANCELED,null);
  r.makeFinishing();
  if (DEBUG_ADD_REMOVE) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  mHistory.remove(r);
  r.takeFromHistory();
  removeTimeoutsForActivityLocked(r);
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  r.state=ActivityState.DESTROYED;
  r.app=null;
  mService.mWindowManager.removeAppToken(r.appToken);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
  cleanUpActivityServicesLocked(r);
  r.removeUriPermissionsLocked();
}","final void removeActivityFromHistoryLocked(ActivityRecord r){
  finishActivityResultsLocked(r,Activity.RESULT_CANCELED,null);
  r.makeFinishing();
  if (DEBUG_ADD_REMOVE) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  mHistory.remove(r);
  r.takeFromHistory();
  removeTimeoutsForActivityLocked(r);
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  r.state=ActivityState.DESTROYED;
  if (DEBUG_APP)   Slog.v(TAG,""String_Node_Str"" + r);
  r.app=null;
  mService.mWindowManager.removeAppToken(r.appToken);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
  cleanUpActivityServicesLocked(r);
  r.removeUriPermissionsLocked();
}"
2905,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(packageName);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromUid);
  pw.print(""String_Node_Str"");
  pw.println(userId);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  pw.print(prefix);
  pw.println(intent.toInsecureStringWithClip());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frontOfTask);
  pw.print(""String_Node_Str"");
  pw.println(task);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskAffinity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(realActivity.flattenToShortString());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(baseDir);
  if (!resDir.equals(baseDir)) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(resDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(stateNotNeeded);
  pw.print(""String_Node_Str"");
  pw.print(componentSpecified);
  pw.print(""String_Node_Str"");
  pw.println(isHomeActivity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(compat);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(labelRes));
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(icon));
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(theme));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(configuration);
  if (resultTo != null || resultWho != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(resultTo);
    pw.print(""String_Node_Str"");
    pw.print(resultWho);
    pw.print(""String_Node_Str"");
    pw.println(requestCode);
  }
  if (results != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(results);
  }
  if (pendingResults != null && pendingResults.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (    WeakReference<PendingIntentRecord> wpir : pendingResults) {
      PendingIntentRecord pir=wpir != null ? wpir.get() : null;
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (pir == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(pir);
        pir.dump(pw,prefix + ""String_Node_Str"");
      }
    }
  }
  if (newIntents != null && newIntents.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < newIntents.size(); i++) {
      Intent intent=(Intent)newIntents.get(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (intent == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(intent.toShortString(false,true,false,true));
      }
    }
  }
  if (pendingOptions != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pendingOptions);
  }
  if (uriPermissions != null) {
    if (uriPermissions.readUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.readUriPermissions);
    }
    if (uriPermissions.writeUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.writeUriPermissions);
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchFailed);
  pw.print(""String_Node_Str"");
  pw.print(haveState);
  pw.print(""String_Node_Str"");
  pw.println(icicle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(state);
  pw.print(""String_Node_Str"");
  pw.print(stopped);
  pw.print(""String_Node_Str"");
  pw.print(delayedResume);
  pw.print(""String_Node_Str"");
  pw.println(finishing);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(keysPaused);
  pw.print(""String_Node_Str"");
  pw.print(inHistory);
  pw.print(""String_Node_Str"");
  pw.print(visible);
  pw.print(""String_Node_Str"");
  pw.print(sleeping);
  pw.print(""String_Node_Str"");
  pw.println(idle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(fullscreen);
  pw.print(""String_Node_Str"");
  pw.print(noDisplay);
  pw.print(""String_Node_Str"");
  pw.print(immersive);
  pw.print(""String_Node_Str"");
  pw.println(launchMode);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frozenBeforeDestroy);
  pw.print(""String_Node_Str"");
  pw.print(thumbnailNeeded);
  pw.print(""String_Node_Str"");
  pw.println(forceNewConfig);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(System.identityHashCode(thumbHolder)));
  if (thumbHolder != null) {
    pw.print(""String_Node_Str"");
    pw.print(thumbHolder.lastThumbnail);
    pw.print(""String_Node_Str"");
    pw.print(thumbHolder.lastDescription);
  }
  pw.println();
  if (launchTime != 0 || startTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    if (launchTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(launchTime,now,pw);
    pw.print(""String_Node_Str"");
    if (startTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(startTime,now,pw);
    pw.println();
  }
  if (lastVisibleTime != 0 || waitingVisible || nowVisible) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(waitingVisible);
    pw.print(""String_Node_Str"");
    pw.print(nowVisible);
    pw.print(""String_Node_Str"");
    if (lastVisibleTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(lastVisibleTime,now,pw);
    pw.println();
  }
  if (configDestroy || configChangeFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(configDestroy);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(configChangeFlags));
  }
  if (connections != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(packageName);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromUid);
  pw.print(""String_Node_Str"");
  pw.println(userId);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  pw.print(prefix);
  pw.println(intent.toInsecureStringWithClip());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frontOfTask);
  pw.print(""String_Node_Str"");
  pw.println(task);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskAffinity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(realActivity.flattenToShortString());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(baseDir);
  if (!resDir.equals(baseDir)) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(resDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(stateNotNeeded);
  pw.print(""String_Node_Str"");
  pw.print(componentSpecified);
  pw.print(""String_Node_Str"");
  pw.println(isHomeActivity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(compat);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(labelRes));
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(icon));
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(theme));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(configuration);
  if (resultTo != null || resultWho != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(resultTo);
    pw.print(""String_Node_Str"");
    pw.print(resultWho);
    pw.print(""String_Node_Str"");
    pw.println(requestCode);
  }
  if (results != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(results);
  }
  if (pendingResults != null && pendingResults.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (    WeakReference<PendingIntentRecord> wpir : pendingResults) {
      PendingIntentRecord pir=wpir != null ? wpir.get() : null;
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (pir == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(pir);
        pir.dump(pw,prefix + ""String_Node_Str"");
      }
    }
  }
  if (newIntents != null && newIntents.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < newIntents.size(); i++) {
      Intent intent=(Intent)newIntents.get(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (intent == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(intent.toShortString(false,true,false,true));
      }
    }
  }
  if (pendingOptions != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pendingOptions);
  }
  if (uriPermissions != null) {
    if (uriPermissions.readUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.readUriPermissions);
    }
    if (uriPermissions.writeUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.writeUriPermissions);
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchFailed);
  pw.print(""String_Node_Str"");
  pw.print(launchCount);
  pw.print(""String_Node_Str"");
  if (lastLaunchTime == 0)   pw.print(""String_Node_Str"");
 else   TimeUtils.formatDuration(lastLaunchTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(haveState);
  pw.print(""String_Node_Str"");
  pw.println(icicle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(state);
  pw.print(""String_Node_Str"");
  pw.print(stopped);
  pw.print(""String_Node_Str"");
  pw.print(delayedResume);
  pw.print(""String_Node_Str"");
  pw.println(finishing);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(keysPaused);
  pw.print(""String_Node_Str"");
  pw.print(inHistory);
  pw.print(""String_Node_Str"");
  pw.print(visible);
  pw.print(""String_Node_Str"");
  pw.print(sleeping);
  pw.print(""String_Node_Str"");
  pw.println(idle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(fullscreen);
  pw.print(""String_Node_Str"");
  pw.print(noDisplay);
  pw.print(""String_Node_Str"");
  pw.print(immersive);
  pw.print(""String_Node_Str"");
  pw.println(launchMode);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frozenBeforeDestroy);
  pw.print(""String_Node_Str"");
  pw.print(thumbnailNeeded);
  pw.print(""String_Node_Str"");
  pw.println(forceNewConfig);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(System.identityHashCode(thumbHolder)));
  if (thumbHolder != null) {
    pw.print(""String_Node_Str"");
    pw.print(thumbHolder.lastThumbnail);
    pw.print(""String_Node_Str"");
    pw.print(thumbHolder.lastDescription);
  }
  pw.println();
  if (launchTime != 0 || startTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    if (launchTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(launchTime,now,pw);
    pw.print(""String_Node_Str"");
    if (startTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(startTime,now,pw);
    pw.println();
  }
  if (lastVisibleTime != 0 || waitingVisible || nowVisible) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(waitingVisible);
    pw.print(""String_Node_Str"");
    pw.print(nowVisible);
    pw.print(""String_Node_Str"");
    if (lastVisibleTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(lastVisibleTime,now,pw);
    pw.println();
  }
  if (configDestroy || configChangeFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(configDestroy);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(configChangeFlags));
  }
  if (connections != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
}"
2906,"final void activityStoppedLocked(ActivityRecord r,Bundle icicle,Bitmap thumbnail,CharSequence description){
  if (r.state != ActivityState.STOPPING) {
    Slog.i(TAG,""String_Node_Str"" + r);
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    return;
  }
  if (DEBUG_SAVED_STATE)   Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ icicle);
  if (icicle != null) {
    r.icicle=icicle;
    r.haveState=true;
    r.updateThumbnail(thumbnail,description);
  }
  if (!r.stopped) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    r.stopped=true;
    r.state=ActivityState.STOPPED;
    if (r.finishing) {
      r.clearOptionsLocked();
    }
 else {
      if (r.configDestroy) {
        destroyActivityLocked(r,true,false,""String_Node_Str"");
        resumeTopActivityLocked(null);
      }
 else {
        ProcessRecord fgApp=null;
        if (mResumedActivity != null) {
          fgApp=mResumedActivity.app;
        }
 else         if (mPausingActivity != null) {
          fgApp=mPausingActivity.app;
        }
        if (r.app != null && fgApp != null && r.app != fgApp && r.lastVisibleTime > mService.mPreviousProcessVisibleTime && r.app != mService.mHomeProcess) {
          mService.mPreviousProcess=r.app;
          mService.mPreviousProcessVisibleTime=r.lastVisibleTime;
        }
      }
    }
  }
}","final void activityStoppedLocked(ActivityRecord r,Bundle icicle,Bitmap thumbnail,CharSequence description){
  if (r.state != ActivityState.STOPPING) {
    Slog.i(TAG,""String_Node_Str"" + r);
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    return;
  }
  if (DEBUG_SAVED_STATE)   Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ icicle);
  if (icicle != null) {
    r.icicle=icicle;
    r.haveState=true;
    r.launchCount=0;
    r.updateThumbnail(thumbnail,description);
  }
  if (!r.stopped) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    r.stopped=true;
    r.state=ActivityState.STOPPED;
    if (r.finishing) {
      r.clearOptionsLocked();
    }
 else {
      if (r.configDestroy) {
        destroyActivityLocked(r,true,false,""String_Node_Str"");
        resumeTopActivityLocked(null);
      }
 else {
        ProcessRecord fgApp=null;
        if (mResumedActivity != null) {
          fgApp=mResumedActivity.app;
        }
 else         if (mPausingActivity != null) {
          fgApp=mPausingActivity.app;
        }
        if (r.app != null && fgApp != null && r.app != fgApp && r.lastVisibleTime > mService.mPreviousProcessVisibleTime && r.app != mService.mHomeProcess) {
          mService.mPreviousProcess=r.app;
          mService.mPreviousProcessVisibleTime=r.lastVisibleTime;
        }
      }
    }
  }
}"
2907,"/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    r.app=null;
  }
  mFinishingActivities.remove(r);
  mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (mService.mPendingThumbnails.size() > 0) {
    mService.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}","/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    if (DEBUG_APP)     Slog.v(TAG,""String_Node_Str"" + r);
    r.app=null;
  }
  mFinishingActivities.remove(r);
  mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (mService.mPendingThumbnails.size() > 0) {
    mService.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}"
2908,"boolean removeHistoryRecordsForAppLocked(ProcessRecord app){
  removeHistoryRecordsForAppLocked(mLRUActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mStoppingActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mGoingToSleepActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mWaitingVisibleActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mFinishingActivities,app,""String_Node_Str"");
  boolean hasVisibleActivities=false;
  int i=mHistory.size();
  if (DEBUG_CLEANUP)   Slog.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ i+ ""String_Node_Str"");
  while (i > 0) {
    i--;
    ActivityRecord r=(ActivityRecord)mHistory.get(i);
    if (DEBUG_CLEANUP)     Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.app);
    if (r.app == app) {
      if ((!r.haveState && !r.stateNotNeeded) || r.finishing) {
        if (ActivityStack.DEBUG_ADD_REMOVE || DEBUG_CLEANUP) {
          RuntimeException here=new RuntimeException(""String_Node_Str"");
          here.fillInStackTrace();
          Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ i+ ""String_Node_Str""+ r.haveState+ ""String_Node_Str""+ r.stateNotNeeded+ ""String_Node_Str""+ r.finishing+ ""String_Node_Str""+ r.state,here);
        }
        if (!r.finishing) {
          Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
          EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName,""String_Node_Str"");
        }
        removeActivityFromHistoryLocked(r);
      }
 else {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"");
        if (r.visible) {
          hasVisibleActivities=true;
        }
        r.app=null;
        r.nowVisible=false;
        if (!r.haveState) {
          if (ActivityStack.DEBUG_SAVED_STATE)           Slog.i(TAG,""String_Node_Str"" + r);
          r.icicle=null;
        }
      }
      r.stack.cleanUpActivityLocked(r,true,true);
    }
  }
  return hasVisibleActivities;
}","boolean removeHistoryRecordsForAppLocked(ProcessRecord app){
  removeHistoryRecordsForAppLocked(mLRUActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mStoppingActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mGoingToSleepActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mWaitingVisibleActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mFinishingActivities,app,""String_Node_Str"");
  boolean hasVisibleActivities=false;
  int i=mHistory.size();
  if (DEBUG_CLEANUP)   Slog.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ i+ ""String_Node_Str"");
  while (i > 0) {
    i--;
    ActivityRecord r=(ActivityRecord)mHistory.get(i);
    if (DEBUG_CLEANUP)     Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.app);
    if (r.app == app) {
      boolean remove;
      if ((!r.haveState && !r.stateNotNeeded) || r.finishing) {
        remove=true;
      }
 else       if (r.launchCount > 2 && r.lastLaunchTime > (SystemClock.uptimeMillis() - 60000)) {
        remove=true;
      }
 else {
        remove=false;
      }
      if (remove) {
        if (ActivityStack.DEBUG_ADD_REMOVE || DEBUG_CLEANUP) {
          RuntimeException here=new RuntimeException(""String_Node_Str"");
          here.fillInStackTrace();
          Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ i+ ""String_Node_Str""+ r.haveState+ ""String_Node_Str""+ r.stateNotNeeded+ ""String_Node_Str""+ r.finishing+ ""String_Node_Str""+ r.state,here);
        }
        if (!r.finishing) {
          Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
          EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName,""String_Node_Str"");
        }
        removeActivityFromHistoryLocked(r);
      }
 else {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"");
        if (r.visible) {
          hasVisibleActivities=true;
        }
        if (DEBUG_APP)         Slog.v(TAG,""String_Node_Str"" + r);
        r.app=null;
        r.nowVisible=false;
        if (!r.haveState) {
          if (ActivityStack.DEBUG_SAVED_STATE)           Slog.i(TAG,""String_Node_Str"" + r);
          r.icicle=null;
        }
      }
      r.stack.cleanUpActivityLocked(r,true,true);
    }
  }
  return hasVisibleActivities;
}"
2909,"final boolean realStartActivityLocked(ActivityRecord r,ProcessRecord app,boolean andResume,boolean checkConfig) throws RemoteException {
  r.startFreezingScreenLocked(app,0);
  mService.mWindowManager.setAppVisibility(r.appToken,true);
  r.startLaunchTickingLocked();
  if (checkConfig) {
    Configuration config=mService.mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,r.mayFreezeScreenLocked(app) ? r.appToken : null);
    mService.updateConfigurationLocked(config,r,false,false);
  }
  r.app=app;
  app.waitingToKill=null;
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + r);
  int idx=app.activities.indexOf(r);
  if (idx < 0) {
    app.activities.add(r);
  }
  mService.updateLruProcessLocked(app,true);
  try {
    if (app.thread == null) {
      throw new RemoteException();
    }
    List<ResultInfo> results=null;
    List<Intent> newIntents=null;
    if (andResume) {
      results=r.results;
      newIntents=r.newIntents;
    }
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.icicle+ ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
    if (andResume) {
      EventLog.writeEvent(EventLogTags.AM_RESTART_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
    }
    if (r.isHomeActivity) {
      mService.mHomeProcess=app;
    }
    mService.ensurePackageDexOpt(r.intent.getComponent().getPackageName());
    r.sleeping=false;
    r.forceNewConfig=false;
    showAskCompatModeDialogLocked(r);
    r.compat=mService.compatibilityInfoForPackageLocked(r.info.applicationInfo);
    String profileFile=null;
    ParcelFileDescriptor profileFd=null;
    boolean profileAutoStop=false;
    if (mService.mProfileApp != null && mService.mProfileApp.equals(app.processName)) {
      if (mService.mProfileProc == null || mService.mProfileProc == app) {
        mService.mProfileProc=app;
        profileFile=mService.mProfileFile;
        profileFd=mService.mProfileFd;
        profileAutoStop=mService.mAutoStopProfiler;
      }
    }
    app.hasShownUi=true;
    app.pendingUiClean=true;
    if (profileFd != null) {
      try {
        profileFd=profileFd.dup();
      }
 catch (      IOException e) {
        profileFd=null;
      }
    }
    app.thread.scheduleLaunchActivity(new Intent(r.intent),r.appToken,System.identityHashCode(r),r.info,new Configuration(mService.mConfiguration),r.compat,r.icicle,results,newIntents,!andResume,mService.isNextTransitionForward(),profileFile,profileFd,profileAutoStop);
    if ((app.info.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
      if (app.processName.equals(app.info.packageName)) {
        if (mService.mHeavyWeightProcess != null && mService.mHeavyWeightProcess != app) {
          Log.w(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ mService.mHeavyWeightProcess);
        }
        mService.mHeavyWeightProcess=app;
        Message msg=mService.mHandler.obtainMessage(ActivityManagerService.POST_HEAVY_NOTIFICATION_MSG);
        msg.obj=r;
        mService.mHandler.sendMessage(msg);
      }
    }
  }
 catch (  RemoteException e) {
    if (r.launchFailed) {
      Slog.e(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString() + ""String_Node_Str"",e);
      mService.appDiedLocked(app,app.pid,app.thread);
      requestFinishActivityLocked(r.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
      return false;
    }
    app.activities.remove(r);
    throw e;
  }
  r.launchFailed=false;
  if (updateLRUListLocked(r)) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  if (andResume) {
    r.state=ActivityState.RESUMED;
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.stopped=false;
    mResumedActivity=r;
    r.task.touchActiveTime();
    if (mMainStack) {
      mService.addRecentTaskLocked(r.task);
    }
    completeResumeLocked(r);
    checkReadyForSleepLocked();
    if (DEBUG_SAVED_STATE)     Slog.i(TAG,""String_Node_Str"" + r.icicle);
  }
 else {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.STOPPED;
    r.stopped=true;
  }
  if (mMainStack) {
    mService.startSetupActivityLocked();
  }
  return true;
}","final boolean realStartActivityLocked(ActivityRecord r,ProcessRecord app,boolean andResume,boolean checkConfig) throws RemoteException {
  r.startFreezingScreenLocked(app,0);
  mService.mWindowManager.setAppVisibility(r.appToken,true);
  r.startLaunchTickingLocked();
  if (checkConfig) {
    Configuration config=mService.mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,r.mayFreezeScreenLocked(app) ? r.appToken : null);
    mService.updateConfigurationLocked(config,r,false,false);
  }
  r.app=app;
  app.waitingToKill=null;
  r.launchCount++;
  r.lastLaunchTime=SystemClock.uptimeMillis();
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + r);
  int idx=app.activities.indexOf(r);
  if (idx < 0) {
    app.activities.add(r);
  }
  mService.updateLruProcessLocked(app,true);
  try {
    if (app.thread == null) {
      throw new RemoteException();
    }
    List<ResultInfo> results=null;
    List<Intent> newIntents=null;
    if (andResume) {
      results=r.results;
      newIntents=r.newIntents;
    }
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.icicle+ ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
    if (andResume) {
      EventLog.writeEvent(EventLogTags.AM_RESTART_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
    }
    if (r.isHomeActivity) {
      mService.mHomeProcess=app;
    }
    mService.ensurePackageDexOpt(r.intent.getComponent().getPackageName());
    r.sleeping=false;
    r.forceNewConfig=false;
    showAskCompatModeDialogLocked(r);
    r.compat=mService.compatibilityInfoForPackageLocked(r.info.applicationInfo);
    String profileFile=null;
    ParcelFileDescriptor profileFd=null;
    boolean profileAutoStop=false;
    if (mService.mProfileApp != null && mService.mProfileApp.equals(app.processName)) {
      if (mService.mProfileProc == null || mService.mProfileProc == app) {
        mService.mProfileProc=app;
        profileFile=mService.mProfileFile;
        profileFd=mService.mProfileFd;
        profileAutoStop=mService.mAutoStopProfiler;
      }
    }
    app.hasShownUi=true;
    app.pendingUiClean=true;
    if (profileFd != null) {
      try {
        profileFd=profileFd.dup();
      }
 catch (      IOException e) {
        profileFd=null;
      }
    }
    app.thread.scheduleLaunchActivity(new Intent(r.intent),r.appToken,System.identityHashCode(r),r.info,new Configuration(mService.mConfiguration),r.compat,r.icicle,results,newIntents,!andResume,mService.isNextTransitionForward(),profileFile,profileFd,profileAutoStop);
    if ((app.info.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
      if (app.processName.equals(app.info.packageName)) {
        if (mService.mHeavyWeightProcess != null && mService.mHeavyWeightProcess != app) {
          Log.w(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ mService.mHeavyWeightProcess);
        }
        mService.mHeavyWeightProcess=app;
        Message msg=mService.mHandler.obtainMessage(ActivityManagerService.POST_HEAVY_NOTIFICATION_MSG);
        msg.obj=r;
        mService.mHandler.sendMessage(msg);
      }
    }
  }
 catch (  RemoteException e) {
    if (r.launchFailed) {
      Slog.e(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString() + ""String_Node_Str"",e);
      mService.appDiedLocked(app,app.pid,app.thread);
      requestFinishActivityLocked(r.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
      return false;
    }
    app.activities.remove(r);
    throw e;
  }
  r.launchFailed=false;
  if (updateLRUListLocked(r)) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  if (andResume) {
    r.state=ActivityState.RESUMED;
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.stopped=false;
    mResumedActivity=r;
    r.task.touchActiveTime();
    if (mMainStack) {
      mService.addRecentTaskLocked(r.task);
    }
    completeResumeLocked(r);
    checkReadyForSleepLocked();
    if (DEBUG_SAVED_STATE)     Slog.i(TAG,""String_Node_Str"" + r.icicle);
  }
 else {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.STOPPED;
    r.stopped=true;
  }
  if (mMainStack) {
    mService.startSetupActivityLocked();
  }
  return true;
}"
2910,"/** 
 * Destroy the current CLIENT SIDE instance of an activity.  This may be called both when actually finishing an activity, or when performing a configuration switch where we destroy the current client-side object but then create a new client-side object for this same HistoryRecord.
 */
final boolean destroyActivityLocked(ActivityRecord r,boolean removeFromApp,boolean oomAdj,String reason){
  if (DEBUG_SWITCH || DEBUG_CLEANUP)   Slog.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ r+ ""String_Node_Str""+ (r.app != null ? r.app.processName : ""String_Node_Str""));
  EventLog.writeEvent(EventLogTags.AM_DESTROY_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  boolean removedFromHistory=false;
  cleanUpActivityLocked(r,false,false);
  final boolean hadApp=r.app != null;
  if (hadApp) {
    if (removeFromApp) {
      int idx=r.app.activities.indexOf(r);
      if (idx >= 0) {
        r.app.activities.remove(idx);
      }
      if (mService.mHeavyWeightProcess == r.app && r.app.activities.size() <= 0) {
        mService.mHeavyWeightProcess=null;
        mService.mHandler.sendEmptyMessage(ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);
      }
      if (r.app.activities.size() == 0) {
        mService.updateOomAdjLocked();
      }
    }
    boolean skipDestroy=false;
    try {
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleDestroyActivity(r.appToken,r.finishing,r.configChangeFlags);
    }
 catch (    Exception e) {
      if (r.finishing) {
        removeActivityFromHistoryLocked(r);
        removedFromHistory=true;
        skipDestroy=true;
      }
    }
    r.nowVisible=false;
    if (r.finishing && !skipDestroy) {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYING;
      Message msg=mHandler.obtainMessage(DESTROY_TIMEOUT_MSG);
      msg.obj=r;
      mHandler.sendMessageDelayed(msg,DESTROY_TIMEOUT);
    }
 else {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYED;
      r.app=null;
    }
  }
 else {
    if (r.finishing) {
      removeActivityFromHistoryLocked(r);
      removedFromHistory=true;
    }
 else {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYED;
      r.app=null;
    }
  }
  r.configChangeFlags=0;
  if (!mLRUActivities.remove(r) && hadApp) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  return removedFromHistory;
}","/** 
 * Destroy the current CLIENT SIDE instance of an activity.  This may be called both when actually finishing an activity, or when performing a configuration switch where we destroy the current client-side object but then create a new client-side object for this same HistoryRecord.
 */
final boolean destroyActivityLocked(ActivityRecord r,boolean removeFromApp,boolean oomAdj,String reason){
  if (DEBUG_SWITCH || DEBUG_CLEANUP)   Slog.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ r+ ""String_Node_Str""+ (r.app != null ? r.app.processName : ""String_Node_Str""));
  EventLog.writeEvent(EventLogTags.AM_DESTROY_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  boolean removedFromHistory=false;
  cleanUpActivityLocked(r,false,false);
  final boolean hadApp=r.app != null;
  if (hadApp) {
    if (removeFromApp) {
      int idx=r.app.activities.indexOf(r);
      if (idx >= 0) {
        r.app.activities.remove(idx);
      }
      if (mService.mHeavyWeightProcess == r.app && r.app.activities.size() <= 0) {
        mService.mHeavyWeightProcess=null;
        mService.mHandler.sendEmptyMessage(ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);
      }
      if (r.app.activities.size() == 0) {
        mService.updateOomAdjLocked();
      }
    }
    boolean skipDestroy=false;
    try {
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleDestroyActivity(r.appToken,r.finishing,r.configChangeFlags);
    }
 catch (    Exception e) {
      if (r.finishing) {
        removeActivityFromHistoryLocked(r);
        removedFromHistory=true;
        skipDestroy=true;
      }
    }
    r.nowVisible=false;
    if (r.finishing && !skipDestroy) {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYING;
      Message msg=mHandler.obtainMessage(DESTROY_TIMEOUT_MSG);
      msg.obj=r;
      mHandler.sendMessageDelayed(msg,DESTROY_TIMEOUT);
    }
 else {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYED;
      if (DEBUG_APP)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app=null;
    }
  }
 else {
    if (r.finishing) {
      removeActivityFromHistoryLocked(r);
      removedFromHistory=true;
    }
 else {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYED;
      if (DEBUG_APP)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app=null;
    }
  }
  r.configChangeFlags=0;
  if (!mLRUActivities.remove(r) && hadApp) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  return removedFromHistory;
}"
2911,"final void removeActivityFromHistoryLocked(ActivityRecord r){
  finishActivityResultsLocked(r,Activity.RESULT_CANCELED,null);
  r.makeFinishing();
  if (DEBUG_ADD_REMOVE) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  mHistory.remove(r);
  r.takeFromHistory();
  removeTimeoutsForActivityLocked(r);
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  r.state=ActivityState.DESTROYED;
  r.app=null;
  mService.mWindowManager.removeAppToken(r.appToken);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
  cleanUpActivityServicesLocked(r);
  r.removeUriPermissionsLocked();
}","final void removeActivityFromHistoryLocked(ActivityRecord r){
  finishActivityResultsLocked(r,Activity.RESULT_CANCELED,null);
  r.makeFinishing();
  if (DEBUG_ADD_REMOVE) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  mHistory.remove(r);
  r.takeFromHistory();
  removeTimeoutsForActivityLocked(r);
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  r.state=ActivityState.DESTROYED;
  if (DEBUG_APP)   Slog.v(TAG,""String_Node_Str"" + r);
  r.app=null;
  mService.mWindowManager.removeAppToken(r.appToken);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
  cleanUpActivityServicesLocked(r);
  r.removeUriPermissionsLocked();
}"
2912,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(packageName);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromUid);
  pw.print(""String_Node_Str"");
  pw.println(userId);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  pw.print(prefix);
  pw.println(intent.toInsecureStringWithClip());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frontOfTask);
  pw.print(""String_Node_Str"");
  pw.println(task);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskAffinity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(realActivity.flattenToShortString());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(baseDir);
  if (!resDir.equals(baseDir)) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(resDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(stateNotNeeded);
  pw.print(""String_Node_Str"");
  pw.print(componentSpecified);
  pw.print(""String_Node_Str"");
  pw.println(isHomeActivity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(compat);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(labelRes));
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(icon));
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(theme));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(configuration);
  if (resultTo != null || resultWho != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(resultTo);
    pw.print(""String_Node_Str"");
    pw.print(resultWho);
    pw.print(""String_Node_Str"");
    pw.println(requestCode);
  }
  if (results != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(results);
  }
  if (pendingResults != null && pendingResults.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (    WeakReference<PendingIntentRecord> wpir : pendingResults) {
      PendingIntentRecord pir=wpir != null ? wpir.get() : null;
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (pir == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(pir);
        pir.dump(pw,prefix + ""String_Node_Str"");
      }
    }
  }
  if (newIntents != null && newIntents.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < newIntents.size(); i++) {
      Intent intent=(Intent)newIntents.get(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (intent == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(intent.toShortString(false,true,false,true));
      }
    }
  }
  if (pendingOptions != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pendingOptions);
  }
  if (uriPermissions != null) {
    if (uriPermissions.readUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.readUriPermissions);
    }
    if (uriPermissions.writeUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.writeUriPermissions);
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchFailed);
  pw.print(""String_Node_Str"");
  pw.print(haveState);
  pw.print(""String_Node_Str"");
  pw.println(icicle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(state);
  pw.print(""String_Node_Str"");
  pw.print(stopped);
  pw.print(""String_Node_Str"");
  pw.print(delayedResume);
  pw.print(""String_Node_Str"");
  pw.println(finishing);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(keysPaused);
  pw.print(""String_Node_Str"");
  pw.print(inHistory);
  pw.print(""String_Node_Str"");
  pw.print(visible);
  pw.print(""String_Node_Str"");
  pw.print(sleeping);
  pw.print(""String_Node_Str"");
  pw.println(idle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(fullscreen);
  pw.print(""String_Node_Str"");
  pw.print(noDisplay);
  pw.print(""String_Node_Str"");
  pw.print(immersive);
  pw.print(""String_Node_Str"");
  pw.println(launchMode);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frozenBeforeDestroy);
  pw.print(""String_Node_Str"");
  pw.print(thumbnailNeeded);
  pw.print(""String_Node_Str"");
  pw.println(forceNewConfig);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(System.identityHashCode(thumbHolder)));
  if (thumbHolder != null) {
    pw.print(""String_Node_Str"");
    pw.print(thumbHolder.lastThumbnail);
    pw.print(""String_Node_Str"");
    pw.print(thumbHolder.lastDescription);
  }
  pw.println();
  if (launchTime != 0 || startTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    if (launchTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(launchTime,now,pw);
    pw.print(""String_Node_Str"");
    if (startTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(startTime,now,pw);
    pw.println();
  }
  if (lastVisibleTime != 0 || waitingVisible || nowVisible) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(waitingVisible);
    pw.print(""String_Node_Str"");
    pw.print(nowVisible);
    pw.print(""String_Node_Str"");
    if (lastVisibleTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(lastVisibleTime,now,pw);
    pw.println();
  }
  if (configDestroy || configChangeFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(configDestroy);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(configChangeFlags));
  }
  if (connections != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(packageName);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromUid);
  pw.print(""String_Node_Str"");
  pw.println(userId);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  pw.print(prefix);
  pw.println(intent.toInsecureStringWithClip());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frontOfTask);
  pw.print(""String_Node_Str"");
  pw.println(task);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskAffinity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(realActivity.flattenToShortString());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(baseDir);
  if (!resDir.equals(baseDir)) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(resDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(stateNotNeeded);
  pw.print(""String_Node_Str"");
  pw.print(componentSpecified);
  pw.print(""String_Node_Str"");
  pw.println(isHomeActivity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(compat);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(labelRes));
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(icon));
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(theme));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(configuration);
  if (resultTo != null || resultWho != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(resultTo);
    pw.print(""String_Node_Str"");
    pw.print(resultWho);
    pw.print(""String_Node_Str"");
    pw.println(requestCode);
  }
  if (results != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(results);
  }
  if (pendingResults != null && pendingResults.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (    WeakReference<PendingIntentRecord> wpir : pendingResults) {
      PendingIntentRecord pir=wpir != null ? wpir.get() : null;
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (pir == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(pir);
        pir.dump(pw,prefix + ""String_Node_Str"");
      }
    }
  }
  if (newIntents != null && newIntents.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < newIntents.size(); i++) {
      Intent intent=(Intent)newIntents.get(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (intent == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(intent.toShortString(false,true,false,true));
      }
    }
  }
  if (pendingOptions != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pendingOptions);
  }
  if (uriPermissions != null) {
    if (uriPermissions.readUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.readUriPermissions);
    }
    if (uriPermissions.writeUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.writeUriPermissions);
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchFailed);
  pw.print(""String_Node_Str"");
  pw.print(launchCount);
  pw.print(""String_Node_Str"");
  if (lastLaunchTime == 0)   pw.print(""String_Node_Str"");
 else   TimeUtils.formatDuration(lastLaunchTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(haveState);
  pw.print(""String_Node_Str"");
  pw.println(icicle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(state);
  pw.print(""String_Node_Str"");
  pw.print(stopped);
  pw.print(""String_Node_Str"");
  pw.print(delayedResume);
  pw.print(""String_Node_Str"");
  pw.println(finishing);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(keysPaused);
  pw.print(""String_Node_Str"");
  pw.print(inHistory);
  pw.print(""String_Node_Str"");
  pw.print(visible);
  pw.print(""String_Node_Str"");
  pw.print(sleeping);
  pw.print(""String_Node_Str"");
  pw.println(idle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(fullscreen);
  pw.print(""String_Node_Str"");
  pw.print(noDisplay);
  pw.print(""String_Node_Str"");
  pw.print(immersive);
  pw.print(""String_Node_Str"");
  pw.println(launchMode);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frozenBeforeDestroy);
  pw.print(""String_Node_Str"");
  pw.print(thumbnailNeeded);
  pw.print(""String_Node_Str"");
  pw.println(forceNewConfig);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(System.identityHashCode(thumbHolder)));
  if (thumbHolder != null) {
    pw.print(""String_Node_Str"");
    pw.print(thumbHolder.lastThumbnail);
    pw.print(""String_Node_Str"");
    pw.print(thumbHolder.lastDescription);
  }
  pw.println();
  if (launchTime != 0 || startTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    if (launchTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(launchTime,now,pw);
    pw.print(""String_Node_Str"");
    if (startTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(startTime,now,pw);
    pw.println();
  }
  if (lastVisibleTime != 0 || waitingVisible || nowVisible) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(waitingVisible);
    pw.print(""String_Node_Str"");
    pw.print(nowVisible);
    pw.print(""String_Node_Str"");
    if (lastVisibleTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(lastVisibleTime,now,pw);
    pw.println();
  }
  if (configDestroy || configChangeFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(configDestroy);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(configChangeFlags));
  }
  if (connections != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
}"
2913,"final void activityStoppedLocked(ActivityRecord r,Bundle icicle,Bitmap thumbnail,CharSequence description){
  if (r.state != ActivityState.STOPPING) {
    Slog.i(TAG,""String_Node_Str"" + r);
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    return;
  }
  if (DEBUG_SAVED_STATE)   Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ icicle);
  if (icicle != null) {
    r.icicle=icicle;
    r.haveState=true;
    r.updateThumbnail(thumbnail,description);
  }
  if (!r.stopped) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    r.stopped=true;
    r.state=ActivityState.STOPPED;
    if (r.finishing) {
      r.clearOptionsLocked();
    }
 else {
      if (r.configDestroy) {
        destroyActivityLocked(r,true,false,""String_Node_Str"");
        resumeTopActivityLocked(null);
      }
 else {
        ProcessRecord fgApp=null;
        if (mResumedActivity != null) {
          fgApp=mResumedActivity.app;
        }
 else         if (mPausingActivity != null) {
          fgApp=mPausingActivity.app;
        }
        if (r.app != null && fgApp != null && r.app != fgApp && r.lastVisibleTime > mService.mPreviousProcessVisibleTime && r.app != mService.mHomeProcess) {
          mService.mPreviousProcess=r.app;
          mService.mPreviousProcessVisibleTime=r.lastVisibleTime;
        }
      }
    }
  }
}","final void activityStoppedLocked(ActivityRecord r,Bundle icicle,Bitmap thumbnail,CharSequence description){
  if (r.state != ActivityState.STOPPING) {
    Slog.i(TAG,""String_Node_Str"" + r);
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    return;
  }
  if (DEBUG_SAVED_STATE)   Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ icicle);
  if (icicle != null) {
    r.icicle=icicle;
    r.haveState=true;
    r.launchCount=0;
    r.updateThumbnail(thumbnail,description);
  }
  if (!r.stopped) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    r.stopped=true;
    r.state=ActivityState.STOPPED;
    if (r.finishing) {
      r.clearOptionsLocked();
    }
 else {
      if (r.configDestroy) {
        destroyActivityLocked(r,true,false,""String_Node_Str"");
        resumeTopActivityLocked(null);
      }
 else {
        ProcessRecord fgApp=null;
        if (mResumedActivity != null) {
          fgApp=mResumedActivity.app;
        }
 else         if (mPausingActivity != null) {
          fgApp=mPausingActivity.app;
        }
        if (r.app != null && fgApp != null && r.app != fgApp && r.lastVisibleTime > mService.mPreviousProcessVisibleTime && r.app != mService.mHomeProcess) {
          mService.mPreviousProcess=r.app;
          mService.mPreviousProcessVisibleTime=r.lastVisibleTime;
        }
      }
    }
  }
}"
2914,"/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    r.app=null;
  }
  mFinishingActivities.remove(r);
  mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (mService.mPendingThumbnails.size() > 0) {
    mService.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}","/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    if (DEBUG_APP)     Slog.v(TAG,""String_Node_Str"" + r);
    r.app=null;
  }
  mFinishingActivities.remove(r);
  mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (mService.mPendingThumbnails.size() > 0) {
    mService.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}"
2915,"boolean removeHistoryRecordsForAppLocked(ProcessRecord app){
  removeHistoryRecordsForAppLocked(mLRUActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mStoppingActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mGoingToSleepActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mWaitingVisibleActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mFinishingActivities,app,""String_Node_Str"");
  boolean hasVisibleActivities=false;
  int i=mHistory.size();
  if (DEBUG_CLEANUP)   Slog.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ i+ ""String_Node_Str"");
  while (i > 0) {
    i--;
    ActivityRecord r=(ActivityRecord)mHistory.get(i);
    if (DEBUG_CLEANUP)     Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.app);
    if (r.app == app) {
      if ((!r.haveState && !r.stateNotNeeded) || r.finishing) {
        if (ActivityStack.DEBUG_ADD_REMOVE || DEBUG_CLEANUP) {
          RuntimeException here=new RuntimeException(""String_Node_Str"");
          here.fillInStackTrace();
          Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ i+ ""String_Node_Str""+ r.haveState+ ""String_Node_Str""+ r.stateNotNeeded+ ""String_Node_Str""+ r.finishing+ ""String_Node_Str""+ r.state,here);
        }
        if (!r.finishing) {
          Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
          EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName,""String_Node_Str"");
        }
        removeActivityFromHistoryLocked(r);
      }
 else {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"");
        if (r.visible) {
          hasVisibleActivities=true;
        }
        r.app=null;
        r.nowVisible=false;
        if (!r.haveState) {
          if (ActivityStack.DEBUG_SAVED_STATE)           Slog.i(TAG,""String_Node_Str"" + r);
          r.icicle=null;
        }
      }
      r.stack.cleanUpActivityLocked(r,true,true);
    }
  }
  return hasVisibleActivities;
}","boolean removeHistoryRecordsForAppLocked(ProcessRecord app){
  removeHistoryRecordsForAppLocked(mLRUActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mStoppingActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mGoingToSleepActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mWaitingVisibleActivities,app,""String_Node_Str"");
  removeHistoryRecordsForAppLocked(mFinishingActivities,app,""String_Node_Str"");
  boolean hasVisibleActivities=false;
  int i=mHistory.size();
  if (DEBUG_CLEANUP)   Slog.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ i+ ""String_Node_Str"");
  while (i > 0) {
    i--;
    ActivityRecord r=(ActivityRecord)mHistory.get(i);
    if (DEBUG_CLEANUP)     Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.app);
    if (r.app == app) {
      boolean remove;
      if ((!r.haveState && !r.stateNotNeeded) || r.finishing) {
        remove=true;
      }
 else       if (r.launchCount > 2 && r.lastLaunchTime > (SystemClock.uptimeMillis() - 60000)) {
        remove=true;
      }
 else {
        remove=false;
      }
      if (remove) {
        if (ActivityStack.DEBUG_ADD_REMOVE || DEBUG_CLEANUP) {
          RuntimeException here=new RuntimeException(""String_Node_Str"");
          here.fillInStackTrace();
          Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ i+ ""String_Node_Str""+ r.haveState+ ""String_Node_Str""+ r.stateNotNeeded+ ""String_Node_Str""+ r.finishing+ ""String_Node_Str""+ r.state,here);
        }
        if (!r.finishing) {
          Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
          EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName,""String_Node_Str"");
        }
        removeActivityFromHistoryLocked(r);
      }
 else {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"");
        if (r.visible) {
          hasVisibleActivities=true;
        }
        if (DEBUG_APP)         Slog.v(TAG,""String_Node_Str"" + r);
        r.app=null;
        r.nowVisible=false;
        if (!r.haveState) {
          if (ActivityStack.DEBUG_SAVED_STATE)           Slog.i(TAG,""String_Node_Str"" + r);
          r.icicle=null;
        }
      }
      r.stack.cleanUpActivityLocked(r,true,true);
    }
  }
  return hasVisibleActivities;
}"
2916,"final boolean realStartActivityLocked(ActivityRecord r,ProcessRecord app,boolean andResume,boolean checkConfig) throws RemoteException {
  r.startFreezingScreenLocked(app,0);
  mService.mWindowManager.setAppVisibility(r.appToken,true);
  r.startLaunchTickingLocked();
  if (checkConfig) {
    Configuration config=mService.mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,r.mayFreezeScreenLocked(app) ? r.appToken : null);
    mService.updateConfigurationLocked(config,r,false,false);
  }
  r.app=app;
  app.waitingToKill=null;
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + r);
  int idx=app.activities.indexOf(r);
  if (idx < 0) {
    app.activities.add(r);
  }
  mService.updateLruProcessLocked(app,true);
  try {
    if (app.thread == null) {
      throw new RemoteException();
    }
    List<ResultInfo> results=null;
    List<Intent> newIntents=null;
    if (andResume) {
      results=r.results;
      newIntents=r.newIntents;
    }
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.icicle+ ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
    if (andResume) {
      EventLog.writeEvent(EventLogTags.AM_RESTART_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
    }
    if (r.isHomeActivity) {
      mService.mHomeProcess=app;
    }
    mService.ensurePackageDexOpt(r.intent.getComponent().getPackageName());
    r.sleeping=false;
    r.forceNewConfig=false;
    showAskCompatModeDialogLocked(r);
    r.compat=mService.compatibilityInfoForPackageLocked(r.info.applicationInfo);
    String profileFile=null;
    ParcelFileDescriptor profileFd=null;
    boolean profileAutoStop=false;
    if (mService.mProfileApp != null && mService.mProfileApp.equals(app.processName)) {
      if (mService.mProfileProc == null || mService.mProfileProc == app) {
        mService.mProfileProc=app;
        profileFile=mService.mProfileFile;
        profileFd=mService.mProfileFd;
        profileAutoStop=mService.mAutoStopProfiler;
      }
    }
    app.hasShownUi=true;
    app.pendingUiClean=true;
    if (profileFd != null) {
      try {
        profileFd=profileFd.dup();
      }
 catch (      IOException e) {
        profileFd=null;
      }
    }
    app.thread.scheduleLaunchActivity(new Intent(r.intent),r.appToken,System.identityHashCode(r),r.info,new Configuration(mService.mConfiguration),r.compat,r.icicle,results,newIntents,!andResume,mService.isNextTransitionForward(),profileFile,profileFd,profileAutoStop);
    if ((app.info.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
      if (app.processName.equals(app.info.packageName)) {
        if (mService.mHeavyWeightProcess != null && mService.mHeavyWeightProcess != app) {
          Log.w(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ mService.mHeavyWeightProcess);
        }
        mService.mHeavyWeightProcess=app;
        Message msg=mService.mHandler.obtainMessage(ActivityManagerService.POST_HEAVY_NOTIFICATION_MSG);
        msg.obj=r;
        mService.mHandler.sendMessage(msg);
      }
    }
  }
 catch (  RemoteException e) {
    if (r.launchFailed) {
      Slog.e(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString() + ""String_Node_Str"",e);
      mService.appDiedLocked(app,app.pid,app.thread);
      requestFinishActivityLocked(r.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
      return false;
    }
    app.activities.remove(r);
    throw e;
  }
  r.launchFailed=false;
  if (updateLRUListLocked(r)) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  if (andResume) {
    r.state=ActivityState.RESUMED;
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.stopped=false;
    mResumedActivity=r;
    r.task.touchActiveTime();
    if (mMainStack) {
      mService.addRecentTaskLocked(r.task);
    }
    completeResumeLocked(r);
    checkReadyForSleepLocked();
    if (DEBUG_SAVED_STATE)     Slog.i(TAG,""String_Node_Str"" + r.icicle);
  }
 else {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.STOPPED;
    r.stopped=true;
  }
  if (mMainStack) {
    mService.startSetupActivityLocked();
  }
  return true;
}","final boolean realStartActivityLocked(ActivityRecord r,ProcessRecord app,boolean andResume,boolean checkConfig) throws RemoteException {
  r.startFreezingScreenLocked(app,0);
  mService.mWindowManager.setAppVisibility(r.appToken,true);
  r.startLaunchTickingLocked();
  if (checkConfig) {
    Configuration config=mService.mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,r.mayFreezeScreenLocked(app) ? r.appToken : null);
    mService.updateConfigurationLocked(config,r,false,false);
  }
  r.app=app;
  app.waitingToKill=null;
  r.launchCount++;
  r.lastLaunchTime=SystemClock.uptimeMillis();
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + r);
  int idx=app.activities.indexOf(r);
  if (idx < 0) {
    app.activities.add(r);
  }
  mService.updateLruProcessLocked(app,true);
  try {
    if (app.thread == null) {
      throw new RemoteException();
    }
    List<ResultInfo> results=null;
    List<Intent> newIntents=null;
    if (andResume) {
      results=r.results;
      newIntents=r.newIntents;
    }
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.icicle+ ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
    if (andResume) {
      EventLog.writeEvent(EventLogTags.AM_RESTART_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
    }
    if (r.isHomeActivity) {
      mService.mHomeProcess=app;
    }
    mService.ensurePackageDexOpt(r.intent.getComponent().getPackageName());
    r.sleeping=false;
    r.forceNewConfig=false;
    showAskCompatModeDialogLocked(r);
    r.compat=mService.compatibilityInfoForPackageLocked(r.info.applicationInfo);
    String profileFile=null;
    ParcelFileDescriptor profileFd=null;
    boolean profileAutoStop=false;
    if (mService.mProfileApp != null && mService.mProfileApp.equals(app.processName)) {
      if (mService.mProfileProc == null || mService.mProfileProc == app) {
        mService.mProfileProc=app;
        profileFile=mService.mProfileFile;
        profileFd=mService.mProfileFd;
        profileAutoStop=mService.mAutoStopProfiler;
      }
    }
    app.hasShownUi=true;
    app.pendingUiClean=true;
    if (profileFd != null) {
      try {
        profileFd=profileFd.dup();
      }
 catch (      IOException e) {
        profileFd=null;
      }
    }
    app.thread.scheduleLaunchActivity(new Intent(r.intent),r.appToken,System.identityHashCode(r),r.info,new Configuration(mService.mConfiguration),r.compat,r.icicle,results,newIntents,!andResume,mService.isNextTransitionForward(),profileFile,profileFd,profileAutoStop);
    if ((app.info.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
      if (app.processName.equals(app.info.packageName)) {
        if (mService.mHeavyWeightProcess != null && mService.mHeavyWeightProcess != app) {
          Log.w(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ mService.mHeavyWeightProcess);
        }
        mService.mHeavyWeightProcess=app;
        Message msg=mService.mHandler.obtainMessage(ActivityManagerService.POST_HEAVY_NOTIFICATION_MSG);
        msg.obj=r;
        mService.mHandler.sendMessage(msg);
      }
    }
  }
 catch (  RemoteException e) {
    if (r.launchFailed) {
      Slog.e(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString() + ""String_Node_Str"",e);
      mService.appDiedLocked(app,app.pid,app.thread);
      requestFinishActivityLocked(r.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",false);
      return false;
    }
    app.activities.remove(r);
    throw e;
  }
  r.launchFailed=false;
  if (updateLRUListLocked(r)) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  if (andResume) {
    r.state=ActivityState.RESUMED;
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.stopped=false;
    mResumedActivity=r;
    r.task.touchActiveTime();
    if (mMainStack) {
      mService.addRecentTaskLocked(r.task);
    }
    completeResumeLocked(r);
    checkReadyForSleepLocked();
    if (DEBUG_SAVED_STATE)     Slog.i(TAG,""String_Node_Str"" + r.icicle);
  }
 else {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.STOPPED;
    r.stopped=true;
  }
  if (mMainStack) {
    mService.startSetupActivityLocked();
  }
  return true;
}"
2917,"/** 
 * Destroy the current CLIENT SIDE instance of an activity.  This may be called both when actually finishing an activity, or when performing a configuration switch where we destroy the current client-side object but then create a new client-side object for this same HistoryRecord.
 */
final boolean destroyActivityLocked(ActivityRecord r,boolean removeFromApp,boolean oomAdj,String reason){
  if (DEBUG_SWITCH || DEBUG_CLEANUP)   Slog.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ r+ ""String_Node_Str""+ (r.app != null ? r.app.processName : ""String_Node_Str""));
  EventLog.writeEvent(EventLogTags.AM_DESTROY_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  boolean removedFromHistory=false;
  cleanUpActivityLocked(r,false,false);
  final boolean hadApp=r.app != null;
  if (hadApp) {
    if (removeFromApp) {
      int idx=r.app.activities.indexOf(r);
      if (idx >= 0) {
        r.app.activities.remove(idx);
      }
      if (mService.mHeavyWeightProcess == r.app && r.app.activities.size() <= 0) {
        mService.mHeavyWeightProcess=null;
        mService.mHandler.sendEmptyMessage(ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);
      }
      if (r.app.activities.size() == 0) {
        mService.updateOomAdjLocked();
      }
    }
    boolean skipDestroy=false;
    try {
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleDestroyActivity(r.appToken,r.finishing,r.configChangeFlags);
    }
 catch (    Exception e) {
      if (r.finishing) {
        removeActivityFromHistoryLocked(r);
        removedFromHistory=true;
        skipDestroy=true;
      }
    }
    r.nowVisible=false;
    if (r.finishing && !skipDestroy) {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYING;
      Message msg=mHandler.obtainMessage(DESTROY_TIMEOUT_MSG);
      msg.obj=r;
      mHandler.sendMessageDelayed(msg,DESTROY_TIMEOUT);
    }
 else {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYED;
      r.app=null;
    }
  }
 else {
    if (r.finishing) {
      removeActivityFromHistoryLocked(r);
      removedFromHistory=true;
    }
 else {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYED;
      r.app=null;
    }
  }
  r.configChangeFlags=0;
  if (!mLRUActivities.remove(r) && hadApp) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  return removedFromHistory;
}","/** 
 * Destroy the current CLIENT SIDE instance of an activity.  This may be called both when actually finishing an activity, or when performing a configuration switch where we destroy the current client-side object but then create a new client-side object for this same HistoryRecord.
 */
final boolean destroyActivityLocked(ActivityRecord r,boolean removeFromApp,boolean oomAdj,String reason){
  if (DEBUG_SWITCH || DEBUG_CLEANUP)   Slog.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ r+ ""String_Node_Str""+ (r.app != null ? r.app.processName : ""String_Node_Str""));
  EventLog.writeEvent(EventLogTags.AM_DESTROY_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  boolean removedFromHistory=false;
  cleanUpActivityLocked(r,false,false);
  final boolean hadApp=r.app != null;
  if (hadApp) {
    if (removeFromApp) {
      int idx=r.app.activities.indexOf(r);
      if (idx >= 0) {
        r.app.activities.remove(idx);
      }
      if (mService.mHeavyWeightProcess == r.app && r.app.activities.size() <= 0) {
        mService.mHeavyWeightProcess=null;
        mService.mHandler.sendEmptyMessage(ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);
      }
      if (r.app.activities.size() == 0) {
        mService.updateOomAdjLocked();
      }
    }
    boolean skipDestroy=false;
    try {
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleDestroyActivity(r.appToken,r.finishing,r.configChangeFlags);
    }
 catch (    Exception e) {
      if (r.finishing) {
        removeActivityFromHistoryLocked(r);
        removedFromHistory=true;
        skipDestroy=true;
      }
    }
    r.nowVisible=false;
    if (r.finishing && !skipDestroy) {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYING;
      Message msg=mHandler.obtainMessage(DESTROY_TIMEOUT_MSG);
      msg.obj=r;
      mHandler.sendMessageDelayed(msg,DESTROY_TIMEOUT);
    }
 else {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYED;
      if (DEBUG_APP)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app=null;
    }
  }
 else {
    if (r.finishing) {
      removeActivityFromHistoryLocked(r);
      removedFromHistory=true;
    }
 else {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.DESTROYED;
      if (DEBUG_APP)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app=null;
    }
  }
  r.configChangeFlags=0;
  if (!mLRUActivities.remove(r) && hadApp) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  return removedFromHistory;
}"
2918,"final void removeActivityFromHistoryLocked(ActivityRecord r){
  finishActivityResultsLocked(r,Activity.RESULT_CANCELED,null);
  r.makeFinishing();
  if (DEBUG_ADD_REMOVE) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  mHistory.remove(r);
  r.takeFromHistory();
  removeTimeoutsForActivityLocked(r);
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  r.state=ActivityState.DESTROYED;
  r.app=null;
  mService.mWindowManager.removeAppToken(r.appToken);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
  cleanUpActivityServicesLocked(r);
  r.removeUriPermissionsLocked();
}","final void removeActivityFromHistoryLocked(ActivityRecord r){
  finishActivityResultsLocked(r,Activity.RESULT_CANCELED,null);
  r.makeFinishing();
  if (DEBUG_ADD_REMOVE) {
    RuntimeException here=new RuntimeException(""String_Node_Str"");
    here.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  mHistory.remove(r);
  r.takeFromHistory();
  removeTimeoutsForActivityLocked(r);
  if (DEBUG_STATES)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  r.state=ActivityState.DESTROYED;
  if (DEBUG_APP)   Slog.v(TAG,""String_Node_Str"" + r);
  r.app=null;
  mService.mWindowManager.removeAppToken(r.appToken);
  if (VALIDATE_TOKENS) {
    validateAppTokensLocked();
  }
  cleanUpActivityServicesLocked(r);
  r.removeUriPermissionsLocked();
}"
2919,"public RelativeLayout(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  initFromAttributes(context,attrs);
  mAllowBrokenMeasureSpecs=context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.JELLY_BEAN_MR1;
}","public RelativeLayout(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  initFromAttributes(context,attrs);
  mAllowBrokenMeasureSpecs=context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.JELLY_BEAN_MR1;
  getDisplayWidth();
}"
2920,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  if (isLayoutRtl() && (myWidth == -1 || isWrapContentWidth)) {
    int w=getPaddingStart() + getPaddingEnd();
    for (int i=0; i < count; i++) {
      View child=views[i];
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        int[] rules=params.getRules(View.LAYOUT_DIRECTION_LTR);
        applyHorizontalSizeRules(params,myWidth,rules);
        measureChildHorizontal(child,params,-1,myHeight);
        w+=child.getMeasuredWidth();
        w+=params.leftMargin + params.rightMargin;
      }
    }
    if (myWidth == -1) {
      myWidth=w;
    }
 else {
      if (w > 0) {
        myWidth=Math.min(myWidth,w);
      }
    }
  }
  final int layoutDirection=getLayoutDirection();
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        width=Math.max(width,params.mRight);
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  final int layoutDirection=getLayoutDirection();
  if (isLayoutRtl() && myWidth == -1) {
    myWidth=mDisplayWidth;
  }
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        if (isLayoutRtl()) {
          width=Math.max(width,myWidth - params.mLeft);
        }
 else {
          width=Math.max(width,params.mRight);
        }
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  if (isLayoutRtl()) {
    final int offsetWidth=myWidth - width;
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        params.mLeft-=offsetWidth;
        params.mRight-=offsetWidth;
      }
    }
  }
  setMeasuredDimension(width,height);
}"
2921,"public <R>R runAction(Action<R> action,R errorResult,String method,boolean reconnect,boolean onlyEstablishedConnection){
synchronized (mStartLock) {
    try {
      if (mService == null) {
        Log.w(TAG,method + ""String_Node_Str"");
        return errorResult;
      }
      if (onlyEstablishedConnection && isEstablished()) {
        Log.w(TAG,method + ""String_Node_Str"");
        return errorResult;
      }
      return action.run(mService);
    }
 catch (    RemoteException ex) {
      Log.e(TAG,method + ""String_Node_Str"",ex);
      if (reconnect) {
        disconnect();
        initTts();
      }
      return errorResult;
    }
  }
}","public <R>R runAction(Action<R> action,R errorResult,String method,boolean reconnect,boolean onlyEstablishedConnection){
synchronized (mStartLock) {
    try {
      if (mService == null) {
        Log.w(TAG,method + ""String_Node_Str"");
        return errorResult;
      }
      if (onlyEstablishedConnection && !isEstablished()) {
        Log.w(TAG,method + ""String_Node_Str"");
        return errorResult;
      }
      return action.run(mService);
    }
 catch (    RemoteException ex) {
      Log.e(TAG,method + ""String_Node_Str"",ex);
      if (reconnect) {
        disconnect();
        initTts();
      }
      return errorResult;
    }
  }
}"
2922,"public <R>R runAction(Action<R> action,R errorResult,String method,boolean reconnect,boolean onlyEstablishedConnection){
synchronized (mStartLock) {
    try {
      if (mService == null) {
        Log.w(TAG,method + ""String_Node_Str"");
        return errorResult;
      }
      if (onlyEstablishedConnection && isEstablished()) {
        Log.w(TAG,method + ""String_Node_Str"");
        return errorResult;
      }
      return action.run(mService);
    }
 catch (    RemoteException ex) {
      Log.e(TAG,method + ""String_Node_Str"",ex);
      if (reconnect) {
        disconnect();
        initTts();
      }
      return errorResult;
    }
  }
}","public <R>R runAction(Action<R> action,R errorResult,String method,boolean reconnect,boolean onlyEstablishedConnection){
synchronized (mStartLock) {
    try {
      if (mService == null) {
        Log.w(TAG,method + ""String_Node_Str"");
        return errorResult;
      }
      if (onlyEstablishedConnection && !isEstablished()) {
        Log.w(TAG,method + ""String_Node_Str"");
        return errorResult;
      }
      return action.run(mService);
    }
 catch (    RemoteException ex) {
      Log.e(TAG,method + ""String_Node_Str"",ex);
      if (reconnect) {
        disconnect();
        initTts();
      }
      return errorResult;
    }
  }
}"
2923,"private void applyHorizontalSizeRules(LayoutParams childParams,int myWidth){
  final int layoutDirection=getLayoutDirection();
  int[] rules=childParams.getRules(layoutDirection);
  RelativeLayout.LayoutParams anchorParams;
  childParams.mLeft=-1;
  childParams.mRight=-1;
  anchorParams=getRelatedViewParams(rules,LEFT_OF);
  if (anchorParams != null) {
    childParams.mRight=anchorParams.mLeft - (anchorParams.leftMargin + childParams.rightMargin);
  }
 else   if (childParams.alignWithParent && rules[LEFT_OF] != 0) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
  anchorParams=getRelatedViewParams(rules,RIGHT_OF);
  if (anchorParams != null) {
    childParams.mLeft=anchorParams.mRight + (anchorParams.rightMargin + childParams.leftMargin);
  }
 else   if (childParams.alignWithParent && rules[RIGHT_OF] != 0) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  anchorParams=getRelatedViewParams(rules,ALIGN_LEFT);
  if (anchorParams != null) {
    childParams.mLeft=anchorParams.mLeft + childParams.leftMargin;
  }
 else   if (childParams.alignWithParent && rules[ALIGN_LEFT] != 0) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  anchorParams=getRelatedViewParams(rules,ALIGN_RIGHT);
  if (anchorParams != null) {
    childParams.mRight=anchorParams.mRight - childParams.rightMargin;
  }
 else   if (childParams.alignWithParent && rules[ALIGN_RIGHT] != 0) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
  if (0 != rules[ALIGN_PARENT_LEFT]) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  if (0 != rules[ALIGN_PARENT_RIGHT]) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
}","private void applyHorizontalSizeRules(LayoutParams childParams,int myWidth,int[] rules){
  RelativeLayout.LayoutParams anchorParams;
  childParams.mLeft=-1;
  childParams.mRight=-1;
  anchorParams=getRelatedViewParams(rules,LEFT_OF);
  if (anchorParams != null) {
    childParams.mRight=anchorParams.mLeft - (anchorParams.leftMargin + childParams.rightMargin);
  }
 else   if (childParams.alignWithParent && rules[LEFT_OF] != 0) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
  anchorParams=getRelatedViewParams(rules,RIGHT_OF);
  if (anchorParams != null) {
    childParams.mLeft=anchorParams.mRight + (anchorParams.rightMargin + childParams.leftMargin);
  }
 else   if (childParams.alignWithParent && rules[RIGHT_OF] != 0) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  anchorParams=getRelatedViewParams(rules,ALIGN_LEFT);
  if (anchorParams != null) {
    childParams.mLeft=anchorParams.mLeft + childParams.leftMargin;
  }
 else   if (childParams.alignWithParent && rules[ALIGN_LEFT] != 0) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  anchorParams=getRelatedViewParams(rules,ALIGN_RIGHT);
  if (anchorParams != null) {
    childParams.mRight=anchorParams.mRight - childParams.rightMargin;
  }
 else   if (childParams.alignWithParent && rules[ALIGN_RIGHT] != 0) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
  if (0 != rules[ALIGN_PARENT_LEFT]) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  if (0 != rules[ALIGN_PARENT_RIGHT]) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
}"
2924,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  if (isLayoutRtl() && (myWidth == -1 || isWrapContentWidth)) {
    int w=getPaddingStart() + getPaddingEnd();
    final int childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED);
    for (int i=0; i < count; i++) {
      View child=views[i];
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        int childHeightMeasureSpec;
        if (params.width == LayoutParams.MATCH_PARENT) {
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(myHeight,MeasureSpec.EXACTLY);
        }
 else {
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(myHeight,MeasureSpec.AT_MOST);
        }
        child.measure(childWidthMeasureSpec,childHeightMeasureSpec);
        w+=child.getMeasuredWidth();
        w+=params.leftMargin + params.rightMargin;
      }
    }
    if (myWidth == -1) {
      myWidth=w;
    }
 else {
      if (w > 0) {
        myWidth=Math.min(myWidth,w);
      }
    }
  }
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyHorizontalSizeRules(params,myWidth);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        width=Math.max(width,params.mRight);
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  final int layoutDirection=getLayoutDirection();
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  if (isLayoutRtl() && (myWidth == -1 || isWrapContentWidth)) {
    int w=getPaddingStart() + getPaddingEnd();
    for (int i=0; i < count; i++) {
      View child=views[i];
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        int[] rules=params.getRules(View.LAYOUT_DIRECTION_LTR);
        applyHorizontalSizeRules(params,myWidth,rules);
        measureChildHorizontal(child,params,-1,myHeight);
        w+=child.getMeasuredWidth();
        w+=params.leftMargin + params.rightMargin;
      }
    }
    if (myWidth == -1) {
      myWidth=w;
    }
 else {
      if (w > 0) {
        myWidth=Math.min(myWidth,w);
      }
    }
  }
  final int layoutDirection=getLayoutDirection();
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        width=Math.max(width,params.mRight);
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  setMeasuredDimension(width,height);
}"
2925,"private void applyHorizontalSizeRules(LayoutParams childParams,int myWidth){
  final int layoutDirection=getLayoutDirection();
  int[] rules=childParams.getRules(layoutDirection);
  RelativeLayout.LayoutParams anchorParams;
  childParams.mLeft=-1;
  childParams.mRight=-1;
  anchorParams=getRelatedViewParams(rules,LEFT_OF);
  if (anchorParams != null) {
    childParams.mRight=anchorParams.mLeft - (anchorParams.leftMargin + childParams.rightMargin);
  }
 else   if (childParams.alignWithParent && rules[LEFT_OF] != 0) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
  anchorParams=getRelatedViewParams(rules,RIGHT_OF);
  if (anchorParams != null) {
    childParams.mLeft=anchorParams.mRight + (anchorParams.rightMargin + childParams.leftMargin);
  }
 else   if (childParams.alignWithParent && rules[RIGHT_OF] != 0) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  anchorParams=getRelatedViewParams(rules,ALIGN_LEFT);
  if (anchorParams != null) {
    childParams.mLeft=anchorParams.mLeft + childParams.leftMargin;
  }
 else   if (childParams.alignWithParent && rules[ALIGN_LEFT] != 0) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  anchorParams=getRelatedViewParams(rules,ALIGN_RIGHT);
  if (anchorParams != null) {
    childParams.mRight=anchorParams.mRight - childParams.rightMargin;
  }
 else   if (childParams.alignWithParent && rules[ALIGN_RIGHT] != 0) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
  if (0 != rules[ALIGN_PARENT_LEFT]) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  if (0 != rules[ALIGN_PARENT_RIGHT]) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
}","private void applyHorizontalSizeRules(LayoutParams childParams,int myWidth,int[] rules){
  RelativeLayout.LayoutParams anchorParams;
  childParams.mLeft=-1;
  childParams.mRight=-1;
  anchorParams=getRelatedViewParams(rules,LEFT_OF);
  if (anchorParams != null) {
    childParams.mRight=anchorParams.mLeft - (anchorParams.leftMargin + childParams.rightMargin);
  }
 else   if (childParams.alignWithParent && rules[LEFT_OF] != 0) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
  anchorParams=getRelatedViewParams(rules,RIGHT_OF);
  if (anchorParams != null) {
    childParams.mLeft=anchorParams.mRight + (anchorParams.rightMargin + childParams.leftMargin);
  }
 else   if (childParams.alignWithParent && rules[RIGHT_OF] != 0) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  anchorParams=getRelatedViewParams(rules,ALIGN_LEFT);
  if (anchorParams != null) {
    childParams.mLeft=anchorParams.mLeft + childParams.leftMargin;
  }
 else   if (childParams.alignWithParent && rules[ALIGN_LEFT] != 0) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  anchorParams=getRelatedViewParams(rules,ALIGN_RIGHT);
  if (anchorParams != null) {
    childParams.mRight=anchorParams.mRight - childParams.rightMargin;
  }
 else   if (childParams.alignWithParent && rules[ALIGN_RIGHT] != 0) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
  if (0 != rules[ALIGN_PARENT_LEFT]) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  if (0 != rules[ALIGN_PARENT_RIGHT]) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
}"
2926,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  if (isLayoutRtl() && (myWidth == -1 || isWrapContentWidth)) {
    int w=getPaddingStart() + getPaddingEnd();
    final int childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED);
    for (int i=0; i < count; i++) {
      View child=views[i];
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        int childHeightMeasureSpec;
        if (params.width == LayoutParams.MATCH_PARENT) {
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(myHeight,MeasureSpec.EXACTLY);
        }
 else {
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(myHeight,MeasureSpec.AT_MOST);
        }
        child.measure(childWidthMeasureSpec,childHeightMeasureSpec);
        w+=child.getMeasuredWidth();
        w+=params.leftMargin + params.rightMargin;
      }
    }
    if (myWidth == -1) {
      myWidth=w;
    }
 else {
      if (w > 0) {
        myWidth=Math.min(myWidth,w);
      }
    }
  }
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyHorizontalSizeRules(params,myWidth);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        width=Math.max(width,params.mRight);
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  final int layoutDirection=getLayoutDirection();
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  if (isLayoutRtl() && (myWidth == -1 || isWrapContentWidth)) {
    int w=getPaddingStart() + getPaddingEnd();
    for (int i=0; i < count; i++) {
      View child=views[i];
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        int[] rules=params.getRules(View.LAYOUT_DIRECTION_LTR);
        applyHorizontalSizeRules(params,myWidth,rules);
        measureChildHorizontal(child,params,-1,myHeight);
        w+=child.getMeasuredWidth();
        w+=params.leftMargin + params.rightMargin;
      }
    }
    if (myWidth == -1) {
      myWidth=w;
    }
 else {
      if (w > 0) {
        myWidth=Math.min(myWidth,w);
      }
    }
  }
  final int layoutDirection=getLayoutDirection();
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        width=Math.max(width,params.mRight);
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  setMeasuredDimension(width,height);
}"
2927,"/** 
 * Implement this method to handle hover events. <p> This method is called whenever a pointer is hovering into, over, or out of the bounds of a view and the view is not currently being touched. Hover events are represented as pointer events with action  {@link MotionEvent#ACTION_HOVER_ENTER},   {@link MotionEvent#ACTION_HOVER_MOVE}, or   {@link MotionEvent#ACTION_HOVER_EXIT}. </p> <ul> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_ENTER}when the pointer enters the bounds of the view.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_MOVE}when the pointer has already entered the bounds of the view and has moved.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_EXIT}when the pointer has exited the bounds of the view or when the pointer is about to go down due to a button click, tap, or similar user action that causes the view to be touched.</li> </ul> <p> The view should implement this method to return true to indicate that it is handling the hover event, such as by changing its drawable state. </p><p> The default implementation calls   {@link #setHovered} to update the hovered stateof the view when a hover enter or hover exit event is received, if the view is enabled and is clickable.  The default implementation also sends hover accessibility events. </p>
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
public boolean onHoverEvent(MotionEvent event){
  final int action=event.getActionMasked();
  if (!mSendingHoverAccessibilityEvents) {
    if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(),event.getY())) {
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
      mSendingHoverAccessibilityEvents=true;
    }
  }
 else {
    if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(),event.getY()))) {
      mSendingHoverAccessibilityEvents=false;
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
      if (mAttachInfo != null && !mAttachInfo.mHasWindowFocus) {
        getViewRootImpl().setAccessibilityFocus(null,null);
      }
    }
  }
  if (isHoverable()) {
switch (action) {
case MotionEvent.ACTION_HOVER_ENTER:
      setHovered(true);
    break;
case MotionEvent.ACTION_HOVER_EXIT:
  setHovered(false);
break;
}
dispatchGenericMotionEventInternal(event);
return true;
}
return false;
}","/** 
 * Implement this method to handle hover events. <p> This method is called whenever a pointer is hovering into, over, or out of the bounds of a view and the view is not currently being touched. Hover events are represented as pointer events with action  {@link MotionEvent#ACTION_HOVER_ENTER},   {@link MotionEvent#ACTION_HOVER_MOVE}, or   {@link MotionEvent#ACTION_HOVER_EXIT}. </p> <ul> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_ENTER}when the pointer enters the bounds of the view.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_MOVE}when the pointer has already entered the bounds of the view and has moved.</li> <li>The view receives a hover event with action   {@link MotionEvent#ACTION_HOVER_EXIT}when the pointer has exited the bounds of the view or when the pointer is about to go down due to a button click, tap, or similar user action that causes the view to be touched.</li> </ul> <p> The view should implement this method to return true to indicate that it is handling the hover event, such as by changing its drawable state. </p><p> The default implementation calls   {@link #setHovered} to update the hovered stateof the view when a hover enter or hover exit event is received, if the view is enabled and is clickable.  The default implementation also sends hover accessibility events. </p>
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
public boolean onHoverEvent(MotionEvent event){
  final int action=event.getActionMasked();
  if (!mSendingHoverAccessibilityEvents) {
    if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(),event.getY())) {
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
      mSendingHoverAccessibilityEvents=true;
    }
  }
 else {
    if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(),event.getY()))) {
      mSendingHoverAccessibilityEvents=false;
      sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
      if (mAttachInfo != null && !mAttachInfo.mHasWindowFocus) {
        getViewRootImpl().setAccessibilityFocus(null,null);
      }
    }
  }
  if (isHoverable()) {
switch (action) {
case MotionEvent.ACTION_HOVER_ENTER:
      setHovered(true);
    break;
case MotionEvent.ACTION_HOVER_EXIT:
  setHovered(false);
break;
}
return dispatchGenericMotionEventInternal(event);
}
return false;
}"
2928,"private void applyHorizontalSizeRules(LayoutParams childParams,int myWidth){
  final int layoutDirection=getLayoutDirection();
  int[] rules=childParams.getRules(layoutDirection);
  RelativeLayout.LayoutParams anchorParams;
  childParams.mLeft=-1;
  childParams.mRight=-1;
  anchorParams=getRelatedViewParams(rules,LEFT_OF);
  if (anchorParams != null) {
    childParams.mRight=anchorParams.mLeft - (anchorParams.leftMargin + childParams.rightMargin);
  }
 else   if (childParams.alignWithParent && rules[LEFT_OF] != 0) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
  anchorParams=getRelatedViewParams(rules,RIGHT_OF);
  if (anchorParams != null) {
    childParams.mLeft=anchorParams.mRight + (anchorParams.rightMargin + childParams.leftMargin);
  }
 else   if (childParams.alignWithParent && rules[RIGHT_OF] != 0) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  anchorParams=getRelatedViewParams(rules,ALIGN_LEFT);
  if (anchorParams != null) {
    childParams.mLeft=anchorParams.mLeft + childParams.leftMargin;
  }
 else   if (childParams.alignWithParent && rules[ALIGN_LEFT] != 0) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  anchorParams=getRelatedViewParams(rules,ALIGN_RIGHT);
  if (anchorParams != null) {
    childParams.mRight=anchorParams.mRight - childParams.rightMargin;
  }
 else   if (childParams.alignWithParent && rules[ALIGN_RIGHT] != 0) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
  if (0 != rules[ALIGN_PARENT_LEFT]) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  if (0 != rules[ALIGN_PARENT_RIGHT]) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
}","private void applyHorizontalSizeRules(LayoutParams childParams,int myWidth,int[] rules){
  RelativeLayout.LayoutParams anchorParams;
  childParams.mLeft=-1;
  childParams.mRight=-1;
  anchorParams=getRelatedViewParams(rules,LEFT_OF);
  if (anchorParams != null) {
    childParams.mRight=anchorParams.mLeft - (anchorParams.leftMargin + childParams.rightMargin);
  }
 else   if (childParams.alignWithParent && rules[LEFT_OF] != 0) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
  anchorParams=getRelatedViewParams(rules,RIGHT_OF);
  if (anchorParams != null) {
    childParams.mLeft=anchorParams.mRight + (anchorParams.rightMargin + childParams.leftMargin);
  }
 else   if (childParams.alignWithParent && rules[RIGHT_OF] != 0) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  anchorParams=getRelatedViewParams(rules,ALIGN_LEFT);
  if (anchorParams != null) {
    childParams.mLeft=anchorParams.mLeft + childParams.leftMargin;
  }
 else   if (childParams.alignWithParent && rules[ALIGN_LEFT] != 0) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  anchorParams=getRelatedViewParams(rules,ALIGN_RIGHT);
  if (anchorParams != null) {
    childParams.mRight=anchorParams.mRight - childParams.rightMargin;
  }
 else   if (childParams.alignWithParent && rules[ALIGN_RIGHT] != 0) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
  if (0 != rules[ALIGN_PARENT_LEFT]) {
    childParams.mLeft=mPaddingLeft + childParams.leftMargin;
  }
  if (0 != rules[ALIGN_PARENT_RIGHT]) {
    if (myWidth >= 0) {
      childParams.mRight=myWidth - mPaddingRight - childParams.rightMargin;
    }
 else {
    }
  }
}"
2929,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  if (isLayoutRtl() && (myWidth == -1 || isWrapContentWidth)) {
    int w=getPaddingStart() + getPaddingEnd();
    final int childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED);
    for (int i=0; i < count; i++) {
      View child=views[i];
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        int childHeightMeasureSpec;
        if (params.width == LayoutParams.MATCH_PARENT) {
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(myHeight,MeasureSpec.EXACTLY);
        }
 else {
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(myHeight,MeasureSpec.AT_MOST);
        }
        child.measure(childWidthMeasureSpec,childHeightMeasureSpec);
        w+=child.getMeasuredWidth();
        w+=params.leftMargin + params.rightMargin;
      }
    }
    if (myWidth == -1) {
      myWidth=w;
    }
 else {
      if (w > 0) {
        myWidth=Math.min(myWidth,w);
      }
    }
  }
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyHorizontalSizeRules(params,myWidth);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        width=Math.max(width,params.mRight);
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  final int layoutDirection=getLayoutDirection();
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mDirtyHierarchy) {
    mDirtyHierarchy=false;
    sortChildren();
  }
  int myWidth=-1;
  int myHeight=-1;
  int width=0;
  int height=0;
  final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  final int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode != MeasureSpec.UNSPECIFIED) {
    myWidth=widthSize;
  }
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    myHeight=heightSize;
  }
  if (widthMode == MeasureSpec.EXACTLY) {
    width=myWidth;
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=myHeight;
  }
  mHasBaselineAlignedChild=false;
  View ignore=null;
  int gravity=mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  final boolean horizontalGravity=gravity != Gravity.START && gravity != 0;
  gravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final boolean verticalGravity=gravity != Gravity.TOP && gravity != 0;
  int left=Integer.MAX_VALUE;
  int top=Integer.MAX_VALUE;
  int right=Integer.MIN_VALUE;
  int bottom=Integer.MIN_VALUE;
  boolean offsetHorizontalAxis=false;
  boolean offsetVerticalAxis=false;
  if ((horizontalGravity || verticalGravity) && mIgnoreGravity != View.NO_ID) {
    ignore=findViewById(mIgnoreGravity);
  }
  final boolean isWrapContentWidth=widthMode != MeasureSpec.EXACTLY;
  final boolean isWrapContentHeight=heightMode != MeasureSpec.EXACTLY;
  View[] views=mSortedHorizontalChildren;
  int count=views.length;
  if (isLayoutRtl() && (myWidth == -1 || isWrapContentWidth)) {
    int w=getPaddingStart() + getPaddingEnd();
    for (int i=0; i < count; i++) {
      View child=views[i];
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        int[] rules=params.getRules(View.LAYOUT_DIRECTION_LTR);
        applyHorizontalSizeRules(params,myWidth,rules);
        measureChildHorizontal(child,params,-1,myHeight);
        w+=child.getMeasuredWidth();
        w+=params.leftMargin + params.rightMargin;
      }
    }
    if (myWidth == -1) {
      myWidth=w;
    }
 else {
      if (w > 0) {
        myWidth=Math.min(myWidth,w);
      }
    }
  }
  final int layoutDirection=getLayoutDirection();
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      int[] rules=params.getRules(layoutDirection);
      applyHorizontalSizeRules(params,myWidth,rules);
      measureChildHorizontal(child,params,myWidth,myHeight);
      if (positionChildHorizontal(child,params,myWidth,isWrapContentWidth)) {
        offsetHorizontalAxis=true;
      }
    }
  }
  views=mSortedVerticalChildren;
  count=views.length;
  for (int i=0; i < count; i++) {
    View child=views[i];
    if (child.getVisibility() != GONE) {
      LayoutParams params=(LayoutParams)child.getLayoutParams();
      applyVerticalSizeRules(params,myHeight);
      measureChild(child,params,myWidth,myHeight);
      if (positionChildVertical(child,params,myHeight,isWrapContentHeight)) {
        offsetVerticalAxis=true;
      }
      if (isWrapContentWidth) {
        width=Math.max(width,params.mRight);
      }
      if (isWrapContentHeight) {
        height=Math.max(height,params.mBottom);
      }
      if (child != ignore || verticalGravity) {
        left=Math.min(left,params.mLeft - params.leftMargin);
        top=Math.min(top,params.mTop - params.topMargin);
      }
      if (child != ignore || horizontalGravity) {
        right=Math.max(right,params.mRight + params.rightMargin);
        bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
      }
    }
  }
  if (mHasBaselineAlignedChild) {
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      if (child.getVisibility() != GONE) {
        LayoutParams params=(LayoutParams)child.getLayoutParams();
        alignBaseline(child,params);
        if (child != ignore || verticalGravity) {
          left=Math.min(left,params.mLeft - params.leftMargin);
          top=Math.min(top,params.mTop - params.topMargin);
        }
        if (child != ignore || horizontalGravity) {
          right=Math.max(right,params.mRight + params.rightMargin);
          bottom=Math.max(bottom,params.mBottom + params.bottomMargin);
        }
      }
    }
  }
  if (isWrapContentWidth) {
    width+=mPaddingRight;
    if (mLayoutParams.width >= 0) {
      width=Math.max(width,mLayoutParams.width);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    width=resolveSize(width,widthMeasureSpec);
    if (offsetHorizontalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) {
            centerHorizontal(child,params,width);
          }
 else           if (rules[ALIGN_PARENT_RIGHT] != 0) {
            final int childWidth=child.getMeasuredWidth();
            params.mLeft=width - mPaddingRight - childWidth;
            params.mRight=params.mLeft + childWidth;
          }
        }
      }
    }
  }
  if (isWrapContentHeight) {
    height+=mPaddingBottom;
    if (mLayoutParams.height >= 0) {
      height=Math.max(height,mLayoutParams.height);
    }
    height=Math.max(height,getSuggestedMinimumHeight());
    height=resolveSize(height,heightMeasureSpec);
    if (offsetVerticalAxis) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          final int[] rules=params.getRules(layoutDirection);
          if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_VERTICAL] != 0) {
            centerVertical(child,params,height);
          }
 else           if (rules[ALIGN_PARENT_BOTTOM] != 0) {
            final int childHeight=child.getMeasuredHeight();
            params.mTop=height - mPaddingBottom - childHeight;
            params.mBottom=params.mTop + childHeight;
          }
        }
      }
    }
  }
  if (horizontalGravity || verticalGravity) {
    final Rect selfBounds=mSelfBounds;
    selfBounds.set(mPaddingLeft,mPaddingTop,width - mPaddingRight,height - mPaddingBottom);
    final Rect contentBounds=mContentBounds;
    Gravity.apply(mGravity,right - left,bottom - top,selfBounds,contentBounds,layoutDirection);
    final int horizontalOffset=contentBounds.left - left;
    final int verticalOffset=contentBounds.top - top;
    if (horizontalOffset != 0 || verticalOffset != 0) {
      for (int i=0; i < count; i++) {
        View child=getChildAt(i);
        if (child.getVisibility() != GONE && child != ignore) {
          LayoutParams params=(LayoutParams)child.getLayoutParams();
          if (horizontalGravity) {
            params.mLeft+=horizontalOffset;
            params.mRight+=horizontalOffset;
          }
          if (verticalGravity) {
            params.mTop+=verticalOffset;
            params.mBottom+=verticalOffset;
          }
        }
      }
    }
  }
  setMeasuredDimension(width,height);
}"
2930,"public ViewRootImpl(Context context,Display display){
  super();
  if (MEASURE_LATENCY) {
    if (lt == null) {
      lt=new LatencyTimer(100,1000);
    }
  }
  mWindowSession=WindowManagerGlobal.getWindowSession(context.getMainLooper());
  mDisplay=display;
  CompatibilityInfoHolder cih=display.getCompatibilityInfo();
  mCompatibilityInfo=cih != null ? cih : new CompatibilityInfoHolder();
  mThread=Thread.currentThread();
  mLocation=new WindowLeaked(null);
  mLocation.fillInStackTrace();
  mWidth=-1;
  mHeight=-1;
  mDirty=new Rect();
  mTempRect=new Rect();
  mVisRect=new Rect();
  mWinFrame=new Rect();
  mWindow=new W(this);
  mTargetSdkVersion=context.getApplicationInfo().targetSdkVersion;
  mInputMethodCallback=new InputMethodCallback(this);
  mViewVisibility=View.GONE;
  mTransparentRegion=new Region();
  mPreviousTransparentRegion=new Region();
  mFirst=true;
  mAdded=false;
  mAccessibilityManager=AccessibilityManager.getInstance(context);
  mAccessibilityInteractionConnectionManager=new AccessibilityInteractionConnectionManager();
  mAccessibilityManager.addAccessibilityStateChangeListener(mAccessibilityInteractionConnectionManager);
  mAttachInfo=new View.AttachInfo(mWindowSession,mWindow,display,this,mHandler,this);
  mViewConfiguration=ViewConfiguration.get(context);
  mDensity=context.getResources().getDisplayMetrics().densityDpi;
  mNoncompatDensity=context.getResources().getDisplayMetrics().noncompatDensityDpi;
  mFallbackEventHandler=PolicyManager.makeNewFallbackEventHandler(context);
  mProfileRendering=Boolean.parseBoolean(SystemProperties.get(PROPERTY_PROFILE_RENDERING,""String_Node_Str""));
  mChoreographer=Choreographer.getInstance();
  PowerManager powerManager=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mAttachInfo.mScreenOn=powerManager.isScreenOn();
  loadSystemProperties();
  mSimulatedTrackball=new SimulatedTrackball(context);
}","public ViewRootImpl(Context context,Display display){
  super();
  if (MEASURE_LATENCY) {
    if (lt == null) {
      lt=new LatencyTimer(100,1000);
    }
  }
  mWindowSession=WindowManagerGlobal.getWindowSession(context.getMainLooper());
  mDisplay=display;
  CompatibilityInfoHolder cih=display.getCompatibilityInfo();
  mCompatibilityInfo=cih != null ? cih : new CompatibilityInfoHolder();
  mThread=Thread.currentThread();
  mLocation=new WindowLeaked(null);
  mLocation.fillInStackTrace();
  mWidth=-1;
  mHeight=-1;
  mDirty=new Rect();
  mTempRect=new Rect();
  mVisRect=new Rect();
  mWinFrame=new Rect();
  mWindow=new W(this);
  mTargetSdkVersion=context.getApplicationInfo().targetSdkVersion;
  mInputMethodCallback=new InputMethodCallback(this);
  mViewVisibility=View.GONE;
  mTransparentRegion=new Region();
  mPreviousTransparentRegion=new Region();
  mFirst=true;
  mAdded=false;
  mAccessibilityManager=AccessibilityManager.getInstance(context);
  mAccessibilityInteractionConnectionManager=new AccessibilityInteractionConnectionManager();
  mAccessibilityManager.addAccessibilityStateChangeListener(mAccessibilityInteractionConnectionManager);
  mAttachInfo=new View.AttachInfo(mWindowSession,mWindow,display,this,mHandler,this);
  mViewConfiguration=ViewConfiguration.get(context);
  mDensity=context.getResources().getDisplayMetrics().densityDpi;
  mNoncompatDensity=context.getResources().getDisplayMetrics().noncompatDensityDpi;
  mFallbackEventHandler=PolicyManager.makeNewFallbackEventHandler(context);
  mProfileRendering=Boolean.parseBoolean(SystemProperties.get(PROPERTY_PROFILE_RENDERING,""String_Node_Str""));
  mChoreographer=Choreographer.getInstance();
  PowerManager powerManager=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mAttachInfo.mScreenOn=powerManager.isScreenOn();
  loadSystemProperties();
  mSimulatedDpad=new SimulatedDpad(context);
}"
2931,"private int deliverGenericMotionEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  final int source=event.getSource();
  final boolean isJoystick=(source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0;
  final boolean isTouchPad=(source & InputDevice.SOURCE_CLASS_POSITION) != 0;
  if (mView == null || !mAdded) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedTrackball.updateTrackballDirection(this,event);
    }
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchGenericMotionEvent(event)) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedTrackball.updateTrackballDirection(this,event);
    }
    return EVENT_HANDLED;
  }
  if (isJoystick) {
    updateJoystickDirection(event,true);
    return EVENT_HANDLED;
  }
  if (isTouchPad) {
    mSimulatedTrackball.updateTrackballDirection(this,event);
    return EVENT_HANDLED;
  }
  return EVENT_NOT_HANDLED;
}","private int deliverGenericMotionEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  final int source=event.getSource();
  final boolean isJoystick=(source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0;
  final boolean isTouchPad=(source & InputDevice.SOURCE_CLASS_POSITION) != 0;
  if (mView == null || !mAdded) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedDpad.updateTouchPad(this,event,false);
    }
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchGenericMotionEvent(event)) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedDpad.updateTouchPad(this,event,false);
    }
    return EVENT_HANDLED;
  }
  if (isJoystick) {
    updateJoystickDirection(event,true);
    return EVENT_HANDLED;
  }
  if (isTouchPad) {
    mSimulatedDpad.updateTouchPad(this,event,true);
    return EVENT_HANDLED;
  }
  return EVENT_NOT_HANDLED;
}"
2932,"public ViewRootImpl(Context context,Display display){
  super();
  if (MEASURE_LATENCY) {
    if (lt == null) {
      lt=new LatencyTimer(100,1000);
    }
  }
  mWindowSession=WindowManagerGlobal.getWindowSession(context.getMainLooper());
  mDisplay=display;
  CompatibilityInfoHolder cih=display.getCompatibilityInfo();
  mCompatibilityInfo=cih != null ? cih : new CompatibilityInfoHolder();
  mThread=Thread.currentThread();
  mLocation=new WindowLeaked(null);
  mLocation.fillInStackTrace();
  mWidth=-1;
  mHeight=-1;
  mDirty=new Rect();
  mTempRect=new Rect();
  mVisRect=new Rect();
  mWinFrame=new Rect();
  mWindow=new W(this);
  mTargetSdkVersion=context.getApplicationInfo().targetSdkVersion;
  mInputMethodCallback=new InputMethodCallback(this);
  mViewVisibility=View.GONE;
  mTransparentRegion=new Region();
  mPreviousTransparentRegion=new Region();
  mFirst=true;
  mAdded=false;
  mAccessibilityManager=AccessibilityManager.getInstance(context);
  mAccessibilityInteractionConnectionManager=new AccessibilityInteractionConnectionManager();
  mAccessibilityManager.addAccessibilityStateChangeListener(mAccessibilityInteractionConnectionManager);
  mAttachInfo=new View.AttachInfo(mWindowSession,mWindow,display,this,mHandler,this);
  mViewConfiguration=ViewConfiguration.get(context);
  mDensity=context.getResources().getDisplayMetrics().densityDpi;
  mNoncompatDensity=context.getResources().getDisplayMetrics().noncompatDensityDpi;
  mFallbackEventHandler=PolicyManager.makeNewFallbackEventHandler(context);
  mChoreographer=Choreographer.getInstance();
  PowerManager powerManager=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mAttachInfo.mScreenOn=powerManager.isScreenOn();
  loadSystemProperties();
  mSimulatedTrackball=new SimulatedTrackball(context);
}","public ViewRootImpl(Context context,Display display){
  super();
  if (MEASURE_LATENCY) {
    if (lt == null) {
      lt=new LatencyTimer(100,1000);
    }
  }
  mWindowSession=WindowManagerGlobal.getWindowSession(context.getMainLooper());
  mDisplay=display;
  CompatibilityInfoHolder cih=display.getCompatibilityInfo();
  mCompatibilityInfo=cih != null ? cih : new CompatibilityInfoHolder();
  mThread=Thread.currentThread();
  mLocation=new WindowLeaked(null);
  mLocation.fillInStackTrace();
  mWidth=-1;
  mHeight=-1;
  mDirty=new Rect();
  mTempRect=new Rect();
  mVisRect=new Rect();
  mWinFrame=new Rect();
  mWindow=new W(this);
  mTargetSdkVersion=context.getApplicationInfo().targetSdkVersion;
  mInputMethodCallback=new InputMethodCallback(this);
  mViewVisibility=View.GONE;
  mTransparentRegion=new Region();
  mPreviousTransparentRegion=new Region();
  mFirst=true;
  mAdded=false;
  mAccessibilityManager=AccessibilityManager.getInstance(context);
  mAccessibilityInteractionConnectionManager=new AccessibilityInteractionConnectionManager();
  mAccessibilityManager.addAccessibilityStateChangeListener(mAccessibilityInteractionConnectionManager);
  mAttachInfo=new View.AttachInfo(mWindowSession,mWindow,display,this,mHandler,this);
  mViewConfiguration=ViewConfiguration.get(context);
  mDensity=context.getResources().getDisplayMetrics().densityDpi;
  mNoncompatDensity=context.getResources().getDisplayMetrics().noncompatDensityDpi;
  mFallbackEventHandler=PolicyManager.makeNewFallbackEventHandler(context);
  mChoreographer=Choreographer.getInstance();
  PowerManager powerManager=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mAttachInfo.mScreenOn=powerManager.isScreenOn();
  loadSystemProperties();
  mSimulatedDpad=new SimulatedDpad(context);
}"
2933,"private int deliverGenericMotionEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  final int source=event.getSource();
  final boolean isJoystick=(source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0;
  final boolean isTouchPad=(source & InputDevice.SOURCE_CLASS_POSITION) != 0;
  if (mView == null || !mAdded) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedTrackball.updateTrackballDirection(this,event);
    }
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchGenericMotionEvent(event)) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedTrackball.updateTrackballDirection(this,event);
    }
    return EVENT_HANDLED;
  }
  if (isJoystick) {
    updateJoystickDirection(event,true);
    return EVENT_HANDLED;
  }
  if (isTouchPad) {
    mSimulatedTrackball.updateTrackballDirection(this,event);
    return EVENT_HANDLED;
  }
  return EVENT_NOT_HANDLED;
}","private int deliverGenericMotionEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  final int source=event.getSource();
  final boolean isJoystick=(source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0;
  final boolean isTouchPad=(source & InputDevice.SOURCE_CLASS_POSITION) != 0;
  if (mView == null || !mAdded) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedDpad.updateTouchPad(this,event,false);
    }
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchGenericMotionEvent(event)) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedDpad.updateTouchPad(this,event,false);
    }
    return EVENT_HANDLED;
  }
  if (isJoystick) {
    updateJoystickDirection(event,true);
    return EVENT_HANDLED;
  }
  if (isTouchPad) {
    mSimulatedDpad.updateTouchPad(this,event,true);
    return EVENT_HANDLED;
  }
  return EVENT_NOT_HANDLED;
}"
2934,"public ViewRootImpl(Context context,Display display){
  super();
  if (MEASURE_LATENCY) {
    if (lt == null) {
      lt=new LatencyTimer(100,1000);
    }
  }
  mWindowSession=WindowManagerGlobal.getWindowSession(context.getMainLooper());
  mDisplay=display;
  CompatibilityInfoHolder cih=display.getCompatibilityInfo();
  mCompatibilityInfo=cih != null ? cih : new CompatibilityInfoHolder();
  mThread=Thread.currentThread();
  mLocation=new WindowLeaked(null);
  mLocation.fillInStackTrace();
  mWidth=-1;
  mHeight=-1;
  mDirty=new Rect();
  mTempRect=new Rect();
  mVisRect=new Rect();
  mWinFrame=new Rect();
  mWindow=new W(this);
  mTargetSdkVersion=context.getApplicationInfo().targetSdkVersion;
  mInputMethodCallback=new InputMethodCallback(this);
  mViewVisibility=View.GONE;
  mTransparentRegion=new Region();
  mPreviousTransparentRegion=new Region();
  mFirst=true;
  mAdded=false;
  mAccessibilityManager=AccessibilityManager.getInstance(context);
  mAccessibilityInteractionConnectionManager=new AccessibilityInteractionConnectionManager();
  mAccessibilityManager.addAccessibilityStateChangeListener(mAccessibilityInteractionConnectionManager);
  mAttachInfo=new View.AttachInfo(mWindowSession,mWindow,display,this,mHandler,this);
  mViewConfiguration=ViewConfiguration.get(context);
  mDensity=context.getResources().getDisplayMetrics().densityDpi;
  mNoncompatDensity=context.getResources().getDisplayMetrics().noncompatDensityDpi;
  mFallbackEventHandler=PolicyManager.makeNewFallbackEventHandler(context);
  mProfileRendering=Boolean.parseBoolean(SystemProperties.get(PROPERTY_PROFILE_RENDERING,""String_Node_Str""));
  mChoreographer=Choreographer.getInstance();
  PowerManager powerManager=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mAttachInfo.mScreenOn=powerManager.isScreenOn();
  loadSystemProperties();
  mSimulatedTrackball=new SimulatedTrackball(context);
}","public ViewRootImpl(Context context,Display display){
  super();
  if (MEASURE_LATENCY) {
    if (lt == null) {
      lt=new LatencyTimer(100,1000);
    }
  }
  mWindowSession=WindowManagerGlobal.getWindowSession(context.getMainLooper());
  mDisplay=display;
  CompatibilityInfoHolder cih=display.getCompatibilityInfo();
  mCompatibilityInfo=cih != null ? cih : new CompatibilityInfoHolder();
  mThread=Thread.currentThread();
  mLocation=new WindowLeaked(null);
  mLocation.fillInStackTrace();
  mWidth=-1;
  mHeight=-1;
  mDirty=new Rect();
  mTempRect=new Rect();
  mVisRect=new Rect();
  mWinFrame=new Rect();
  mWindow=new W(this);
  mTargetSdkVersion=context.getApplicationInfo().targetSdkVersion;
  mInputMethodCallback=new InputMethodCallback(this);
  mViewVisibility=View.GONE;
  mTransparentRegion=new Region();
  mPreviousTransparentRegion=new Region();
  mFirst=true;
  mAdded=false;
  mAccessibilityManager=AccessibilityManager.getInstance(context);
  mAccessibilityInteractionConnectionManager=new AccessibilityInteractionConnectionManager();
  mAccessibilityManager.addAccessibilityStateChangeListener(mAccessibilityInteractionConnectionManager);
  mAttachInfo=new View.AttachInfo(mWindowSession,mWindow,display,this,mHandler,this);
  mViewConfiguration=ViewConfiguration.get(context);
  mDensity=context.getResources().getDisplayMetrics().densityDpi;
  mNoncompatDensity=context.getResources().getDisplayMetrics().noncompatDensityDpi;
  mFallbackEventHandler=PolicyManager.makeNewFallbackEventHandler(context);
  mProfileRendering=Boolean.parseBoolean(SystemProperties.get(PROPERTY_PROFILE_RENDERING,""String_Node_Str""));
  mChoreographer=Choreographer.getInstance();
  PowerManager powerManager=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mAttachInfo.mScreenOn=powerManager.isScreenOn();
  loadSystemProperties();
  mSimulatedDpad=new SimulatedDpad(context);
}"
2935,"private int deliverGenericMotionEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  final int source=event.getSource();
  final boolean isJoystick=(source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0;
  final boolean isTouchPad=(source & InputDevice.SOURCE_CLASS_POSITION) != 0;
  if (mView == null || !mAdded) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedTrackball.updateTrackballDirection(this,event);
    }
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchGenericMotionEvent(event)) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedTrackball.updateTrackballDirection(this,event);
    }
    return EVENT_HANDLED;
  }
  if (isJoystick) {
    updateJoystickDirection(event,true);
    return EVENT_HANDLED;
  }
  if (isTouchPad) {
    mSimulatedTrackball.updateTrackballDirection(this,event);
    return EVENT_HANDLED;
  }
  return EVENT_NOT_HANDLED;
}","private int deliverGenericMotionEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  final int source=event.getSource();
  final boolean isJoystick=(source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0;
  final boolean isTouchPad=(source & InputDevice.SOURCE_CLASS_POSITION) != 0;
  if (mView == null || !mAdded) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedDpad.updateTouchPad(this,event,false);
    }
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchGenericMotionEvent(event)) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedDpad.updateTouchPad(this,event,false);
    }
    return EVENT_HANDLED;
  }
  if (isJoystick) {
    updateJoystickDirection(event,true);
    return EVENT_HANDLED;
  }
  if (isTouchPad) {
    mSimulatedDpad.updateTouchPad(this,event,true);
    return EVENT_HANDLED;
  }
  return EVENT_NOT_HANDLED;
}"
2936,"public ViewRootImpl(Context context,Display display){
  super();
  if (MEASURE_LATENCY) {
    if (lt == null) {
      lt=new LatencyTimer(100,1000);
    }
  }
  mWindowSession=WindowManagerGlobal.getWindowSession(context.getMainLooper());
  mDisplay=display;
  CompatibilityInfoHolder cih=display.getCompatibilityInfo();
  mCompatibilityInfo=cih != null ? cih : new CompatibilityInfoHolder();
  mThread=Thread.currentThread();
  mLocation=new WindowLeaked(null);
  mLocation.fillInStackTrace();
  mWidth=-1;
  mHeight=-1;
  mDirty=new Rect();
  mTempRect=new Rect();
  mVisRect=new Rect();
  mWinFrame=new Rect();
  mWindow=new W(this);
  mTargetSdkVersion=context.getApplicationInfo().targetSdkVersion;
  mInputMethodCallback=new InputMethodCallback(this);
  mViewVisibility=View.GONE;
  mTransparentRegion=new Region();
  mPreviousTransparentRegion=new Region();
  mFirst=true;
  mAdded=false;
  mAccessibilityManager=AccessibilityManager.getInstance(context);
  mAccessibilityInteractionConnectionManager=new AccessibilityInteractionConnectionManager();
  mAccessibilityManager.addAccessibilityStateChangeListener(mAccessibilityInteractionConnectionManager);
  mAttachInfo=new View.AttachInfo(mWindowSession,mWindow,display,this,mHandler,this);
  mViewConfiguration=ViewConfiguration.get(context);
  mDensity=context.getResources().getDisplayMetrics().densityDpi;
  mNoncompatDensity=context.getResources().getDisplayMetrics().noncompatDensityDpi;
  mFallbackEventHandler=PolicyManager.makeNewFallbackEventHandler(context);
  mProfileRendering=Boolean.parseBoolean(SystemProperties.get(PROPERTY_PROFILE_RENDERING,""String_Node_Str""));
  mChoreographer=Choreographer.getInstance();
  PowerManager powerManager=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mAttachInfo.mScreenOn=powerManager.isScreenOn();
  loadSystemProperties();
  mSimulatedTrackball=new SimulatedTrackball(context);
}","public ViewRootImpl(Context context,Display display){
  super();
  if (MEASURE_LATENCY) {
    if (lt == null) {
      lt=new LatencyTimer(100,1000);
    }
  }
  mWindowSession=WindowManagerGlobal.getWindowSession(context.getMainLooper());
  mDisplay=display;
  CompatibilityInfoHolder cih=display.getCompatibilityInfo();
  mCompatibilityInfo=cih != null ? cih : new CompatibilityInfoHolder();
  mThread=Thread.currentThread();
  mLocation=new WindowLeaked(null);
  mLocation.fillInStackTrace();
  mWidth=-1;
  mHeight=-1;
  mDirty=new Rect();
  mTempRect=new Rect();
  mVisRect=new Rect();
  mWinFrame=new Rect();
  mWindow=new W(this);
  mTargetSdkVersion=context.getApplicationInfo().targetSdkVersion;
  mInputMethodCallback=new InputMethodCallback(this);
  mViewVisibility=View.GONE;
  mTransparentRegion=new Region();
  mPreviousTransparentRegion=new Region();
  mFirst=true;
  mAdded=false;
  mAccessibilityManager=AccessibilityManager.getInstance(context);
  mAccessibilityInteractionConnectionManager=new AccessibilityInteractionConnectionManager();
  mAccessibilityManager.addAccessibilityStateChangeListener(mAccessibilityInteractionConnectionManager);
  mAttachInfo=new View.AttachInfo(mWindowSession,mWindow,display,this,mHandler,this);
  mViewConfiguration=ViewConfiguration.get(context);
  mDensity=context.getResources().getDisplayMetrics().densityDpi;
  mNoncompatDensity=context.getResources().getDisplayMetrics().noncompatDensityDpi;
  mFallbackEventHandler=PolicyManager.makeNewFallbackEventHandler(context);
  mProfileRendering=Boolean.parseBoolean(SystemProperties.get(PROPERTY_PROFILE_RENDERING,""String_Node_Str""));
  mChoreographer=Choreographer.getInstance();
  PowerManager powerManager=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mAttachInfo.mScreenOn=powerManager.isScreenOn();
  loadSystemProperties();
  mSimulatedDpad=new SimulatedDpad(context);
}"
2937,"private int deliverGenericMotionEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  final int source=event.getSource();
  final boolean isJoystick=(source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0;
  final boolean isTouchPad=(source & InputDevice.SOURCE_CLASS_POSITION) != 0;
  if (mView == null || !mAdded) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedTrackball.updateTrackballDirection(this,event);
    }
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchGenericMotionEvent(event)) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedTrackball.updateTrackballDirection(this,event);
    }
    return EVENT_HANDLED;
  }
  if (isJoystick) {
    updateJoystickDirection(event,true);
    return EVENT_HANDLED;
  }
  if (isTouchPad) {
    mSimulatedTrackball.updateTrackballDirection(this,event);
    return EVENT_HANDLED;
  }
  return EVENT_NOT_HANDLED;
}","private int deliverGenericMotionEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  final int source=event.getSource();
  final boolean isJoystick=(source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0;
  final boolean isTouchPad=(source & InputDevice.SOURCE_CLASS_POSITION) != 0;
  if (mView == null || !mAdded) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedDpad.updateTouchPad(this,event,false);
    }
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchGenericMotionEvent(event)) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedDpad.updateTouchPad(this,event,false);
    }
    return EVENT_HANDLED;
  }
  if (isJoystick) {
    updateJoystickDirection(event,true);
    return EVENT_HANDLED;
  }
  if (isTouchPad) {
    mSimulatedDpad.updateTouchPad(this,event,true);
    return EVENT_HANDLED;
  }
  return EVENT_NOT_HANDLED;
}"
2938,"public ViewRootImpl(Context context,Display display){
  super();
  if (MEASURE_LATENCY) {
    if (lt == null) {
      lt=new LatencyTimer(100,1000);
    }
  }
  mWindowSession=WindowManagerGlobal.getWindowSession(context.getMainLooper());
  mDisplay=display;
  CompatibilityInfoHolder cih=display.getCompatibilityInfo();
  mCompatibilityInfo=cih != null ? cih : new CompatibilityInfoHolder();
  mThread=Thread.currentThread();
  mLocation=new WindowLeaked(null);
  mLocation.fillInStackTrace();
  mWidth=-1;
  mHeight=-1;
  mDirty=new Rect();
  mTempRect=new Rect();
  mVisRect=new Rect();
  mWinFrame=new Rect();
  mWindow=new W(this);
  mTargetSdkVersion=context.getApplicationInfo().targetSdkVersion;
  mInputMethodCallback=new InputMethodCallback(this);
  mViewVisibility=View.GONE;
  mTransparentRegion=new Region();
  mPreviousTransparentRegion=new Region();
  mFirst=true;
  mAdded=false;
  mAccessibilityManager=AccessibilityManager.getInstance(context);
  mAccessibilityInteractionConnectionManager=new AccessibilityInteractionConnectionManager();
  mAccessibilityManager.addAccessibilityStateChangeListener(mAccessibilityInteractionConnectionManager);
  mAttachInfo=new View.AttachInfo(mWindowSession,mWindow,display,this,mHandler,this);
  mViewConfiguration=ViewConfiguration.get(context);
  mDensity=context.getResources().getDisplayMetrics().densityDpi;
  mNoncompatDensity=context.getResources().getDisplayMetrics().noncompatDensityDpi;
  mFallbackEventHandler=PolicyManager.makeNewFallbackEventHandler(context);
  mChoreographer=Choreographer.getInstance();
  PowerManager powerManager=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mAttachInfo.mScreenOn=powerManager.isScreenOn();
  loadSystemProperties();
  mSimulatedTrackball=new SimulatedTrackball(context);
}","public ViewRootImpl(Context context,Display display){
  super();
  if (MEASURE_LATENCY) {
    if (lt == null) {
      lt=new LatencyTimer(100,1000);
    }
  }
  mWindowSession=WindowManagerGlobal.getWindowSession(context.getMainLooper());
  mDisplay=display;
  CompatibilityInfoHolder cih=display.getCompatibilityInfo();
  mCompatibilityInfo=cih != null ? cih : new CompatibilityInfoHolder();
  mThread=Thread.currentThread();
  mLocation=new WindowLeaked(null);
  mLocation.fillInStackTrace();
  mWidth=-1;
  mHeight=-1;
  mDirty=new Rect();
  mTempRect=new Rect();
  mVisRect=new Rect();
  mWinFrame=new Rect();
  mWindow=new W(this);
  mTargetSdkVersion=context.getApplicationInfo().targetSdkVersion;
  mInputMethodCallback=new InputMethodCallback(this);
  mViewVisibility=View.GONE;
  mTransparentRegion=new Region();
  mPreviousTransparentRegion=new Region();
  mFirst=true;
  mAdded=false;
  mAccessibilityManager=AccessibilityManager.getInstance(context);
  mAccessibilityInteractionConnectionManager=new AccessibilityInteractionConnectionManager();
  mAccessibilityManager.addAccessibilityStateChangeListener(mAccessibilityInteractionConnectionManager);
  mAttachInfo=new View.AttachInfo(mWindowSession,mWindow,display,this,mHandler,this);
  mViewConfiguration=ViewConfiguration.get(context);
  mDensity=context.getResources().getDisplayMetrics().densityDpi;
  mNoncompatDensity=context.getResources().getDisplayMetrics().noncompatDensityDpi;
  mFallbackEventHandler=PolicyManager.makeNewFallbackEventHandler(context);
  mChoreographer=Choreographer.getInstance();
  PowerManager powerManager=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mAttachInfo.mScreenOn=powerManager.isScreenOn();
  loadSystemProperties();
  mSimulatedDpad=new SimulatedDpad(context);
}"
2939,"private int deliverGenericMotionEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  final int source=event.getSource();
  final boolean isJoystick=(source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0;
  final boolean isTouchPad=(source & InputDevice.SOURCE_CLASS_POSITION) != 0;
  if (mView == null || !mAdded) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedTrackball.updateTrackballDirection(this,event);
    }
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchGenericMotionEvent(event)) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedTrackball.updateTrackballDirection(this,event);
    }
    return EVENT_HANDLED;
  }
  if (isJoystick) {
    updateJoystickDirection(event,true);
    return EVENT_HANDLED;
  }
  if (isTouchPad) {
    mSimulatedTrackball.updateTrackballDirection(this,event);
    return EVENT_HANDLED;
  }
  return EVENT_NOT_HANDLED;
}","private int deliverGenericMotionEventPostIme(QueuedInputEvent q){
  final MotionEvent event=(MotionEvent)q.mEvent;
  final int source=event.getSource();
  final boolean isJoystick=(source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0;
  final boolean isTouchPad=(source & InputDevice.SOURCE_CLASS_POSITION) != 0;
  if (mView == null || !mAdded) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedDpad.updateTouchPad(this,event,false);
    }
    return EVENT_NOT_HANDLED;
  }
  if (mView.dispatchGenericMotionEvent(event)) {
    if (isJoystick) {
      updateJoystickDirection(event,false);
    }
 else     if (isTouchPad) {
      mSimulatedDpad.updateTouchPad(this,event,false);
    }
    return EVENT_HANDLED;
  }
  if (isJoystick) {
    updateJoystickDirection(event,true);
    return EVENT_HANDLED;
  }
  if (isTouchPad) {
    mSimulatedDpad.updateTouchPad(this,event,true);
    return EVENT_HANDLED;
  }
  return EVENT_NOT_HANDLED;
}"
2940,"/** 
 * Called when sensor values have changed. <p>See   {@link android.hardware.SensorManager SensorManager}for details on possible sensor types. <p>See also   {@link android.hardware.SensorEvent SensorEvent}. <p><b>NOTE:</b> The application doesn't own the  {@link android.hardware.SensorEvent event}object passed as a parameter and therefore cannot hold on o it. The object may be part of an internal pool and may be reused by the framework.
 * @param event the {@link android.hardware.SensorEvent SensorEvent}. 
 */
public void onSensorChanged(SensorEvent event);","/** 
 * Called when sensor values have changed. <p>See   {@link android.hardware.SensorManager SensorManager}for details on possible sensor types. <p>See also   {@link android.hardware.SensorEvent SensorEvent}. <p><b>NOTE:</b> The application doesn't own the  {@link android.hardware.SensorEvent event}object passed as a parameter and therefore cannot hold on to it. The object may be part of an internal pool and may be reused by the framework.
 * @param event the {@link android.hardware.SensorEvent SensorEvent}. 
 */
public void onSensorChanged(SensorEvent event);"
2941,"/** 
 * Called when sensor values have changed. <p>See   {@link android.hardware.SensorManager SensorManager}for details on possible sensor types. <p>See also   {@link android.hardware.SensorEvent SensorEvent}. <p><b>NOTE:</b> The application doesn't own the  {@link android.hardware.SensorEvent event}object passed as a parameter and therefore cannot hold on o it. The object may be part of an internal pool and may be reused by the framework.
 * @param event the {@link android.hardware.SensorEvent SensorEvent}. 
 */
public void onSensorChanged(SensorEvent event);","/** 
 * Called when sensor values have changed. <p>See   {@link android.hardware.SensorManager SensorManager}for details on possible sensor types. <p>See also   {@link android.hardware.SensorEvent SensorEvent}. <p><b>NOTE:</b> The application doesn't own the  {@link android.hardware.SensorEvent event}object passed as a parameter and therefore cannot hold on to it. The object may be part of an internal pool and may be reused by the framework.
 * @param event the {@link android.hardware.SensorEvent SensorEvent}. 
 */
public void onSensorChanged(SensorEvent event);"
2942,"/** 
 * Called when sensor values have changed. <p>See   {@link android.hardware.SensorManager SensorManager}for details on possible sensor types. <p>See also   {@link android.hardware.SensorEvent SensorEvent}. <p><b>NOTE:</b> The application doesn't own the  {@link android.hardware.SensorEvent event}object passed as a parameter and therefore cannot hold on o it. The object may be part of an internal pool and may be reused by the framework.
 * @param event the {@link android.hardware.SensorEvent SensorEvent}. 
 */
public void onSensorChanged(SensorEvent event);","/** 
 * Called when sensor values have changed. <p>See   {@link android.hardware.SensorManager SensorManager}for details on possible sensor types. <p>See also   {@link android.hardware.SensorEvent SensorEvent}. <p><b>NOTE:</b> The application doesn't own the  {@link android.hardware.SensorEvent event}object passed as a parameter and therefore cannot hold on to it. The object may be part of an internal pool and may be reused by the framework.
 * @param event the {@link android.hardware.SensorEvent SensorEvent}. 
 */
public void onSensorChanged(SensorEvent event);"
2943,"/** 
 * Called when sensor values have changed. <p>See   {@link android.hardware.SensorManager SensorManager}for details on possible sensor types. <p>See also   {@link android.hardware.SensorEvent SensorEvent}. <p><b>NOTE:</b> The application doesn't own the  {@link android.hardware.SensorEvent event}object passed as a parameter and therefore cannot hold on o it. The object may be part of an internal pool and may be reused by the framework.
 * @param event the {@link android.hardware.SensorEvent SensorEvent}. 
 */
public void onSensorChanged(SensorEvent event);","/** 
 * Called when sensor values have changed. <p>See   {@link android.hardware.SensorManager SensorManager}for details on possible sensor types. <p>See also   {@link android.hardware.SensorEvent SensorEvent}. <p><b>NOTE:</b> The application doesn't own the  {@link android.hardware.SensorEvent event}object passed as a parameter and therefore cannot hold on to it. The object may be part of an internal pool and may be reused by the framework.
 * @param event the {@link android.hardware.SensorEvent SensorEvent}. 
 */
public void onSensorChanged(SensorEvent event);"
2944,"/** 
 * Called when sensor values have changed. <p>See   {@link android.hardware.SensorManager SensorManager}for details on possible sensor types. <p>See also   {@link android.hardware.SensorEvent SensorEvent}. <p><b>NOTE:</b> The application doesn't own the  {@link android.hardware.SensorEvent event}object passed as a parameter and therefore cannot hold on o it. The object may be part of an internal pool and may be reused by the framework.
 * @param event the {@link android.hardware.SensorEvent SensorEvent}. 
 */
public void onSensorChanged(SensorEvent event);","/** 
 * Called when sensor values have changed. <p>See   {@link android.hardware.SensorManager SensorManager}for details on possible sensor types. <p>See also   {@link android.hardware.SensorEvent SensorEvent}. <p><b>NOTE:</b> The application doesn't own the  {@link android.hardware.SensorEvent event}object passed as a parameter and therefore cannot hold on to it. The object may be part of an internal pool and may be reused by the framework.
 * @param event the {@link android.hardware.SensorEvent SensorEvent}. 
 */
public void onSensorChanged(SensorEvent event);"
2945,"private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}","private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}"
2946,"boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (DEBUG) {
    Slog.d(TAG,(enabled ? ""String_Node_Str"" : ""String_Node_Str"") + id);
  }
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}","boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}"
2947,"private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}","private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}"
2948,"private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}","private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}"
2949,"boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (DEBUG) {
    Slog.d(TAG,(enabled ? ""String_Node_Str"" : ""String_Node_Str"") + id);
  }
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}","boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}"
2950,"private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}","private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}"
2951,"private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}","private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}"
2952,"boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (DEBUG) {
    Slog.d(TAG,(enabled ? ""String_Node_Str"" : ""String_Node_Str"") + id);
  }
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}","boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}"
2953,"private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}","private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}"
2954,"private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}","private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}"
2955,"boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (DEBUG) {
    Slog.d(TAG,(enabled ? ""String_Node_Str"" : ""String_Node_Str"") + id);
  }
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}","boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}"
2956,"private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}","private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}"
2957,"private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}","private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}"
2958,"boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (DEBUG) {
    Slog.d(TAG,(enabled ? ""String_Node_Str"" : ""String_Node_Str"") + id);
  }
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}","boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}"
2959,"private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}","private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}"
2960,"public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}","public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  lp.privateFlags|=LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}"
2961,"/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}","/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mForcingShowNavBar=false;
  mForcingShowNavBarLayer=-1;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}"
2962,"private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  final int visibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}","private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  int tmpVisibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  if (mForcingShowNavBar && mFocusedWindow.getSurfaceLayer() < mForcingShowNavBarLayer) {
    tmpVisibility&=~View.SYSTEM_UI_CLEARABLE_FLAGS;
  }
  final int visibility=tmpVisibility;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}"
2963,"/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && (win.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR) != 0) {
    if (mForcingShowNavBarLayer < 0) {
      mForcingShowNavBar=true;
      mForcingShowNavBarLayer=win.getSurfaceLayer();
    }
  }
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}"
2964,"@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}","@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  if (mForcingShowNavBar) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBar);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBarLayer);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}"
2965,"private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,int userId){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId);
    }
    Iterator<SparseArray<Long>> badApps=mProcessCrashTimes.getMap().values().iterator();
    while (badApps.hasNext()) {
      SparseArray<Long> ba=badApps.next();
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        badApps.remove();
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,false,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  TaskRecord lastTask=null;
  for (i=0; i < mMainStack.mHistory.size(); i++) {
    ActivityRecord r=(ActivityRecord)mMainStack.mHistory.get(i);
    final boolean samePackage=r.packageName.equals(name) || (name == null && r.userId == userId);
    if ((userId == UserHandle.USER_ALL || r.userId == userId) && (samePackage || r.task == lastTask) && (r.app == null || evenPersistent || !r.app.persistent)) {
      if (!doit) {
        if (r.finishing) {
          continue;
        }
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + r);
      if (samePackage) {
        if (r.app != null) {
          r.app.removed=true;
        }
        r.app=null;
      }
      lastTask=r.task;
      if (r.stack.finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"",true)) {
        i--;
      }
    }
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  if (name == null) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mMainStack.resumeTopActivityLocked(null);
      mMainStack.scheduleIdleLocked();
    }
  }
  return didSomething;
}","private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,int userId){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId);
    }
    Iterator<SparseArray<Long>> badApps=mProcessCrashTimes.getMap().values().iterator();
    while (badApps.hasNext()) {
      SparseArray<Long> ba=badApps.next();
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        badApps.remove();
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,true,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  TaskRecord lastTask=null;
  for (i=0; i < mMainStack.mHistory.size(); i++) {
    ActivityRecord r=(ActivityRecord)mMainStack.mHistory.get(i);
    final boolean samePackage=r.packageName.equals(name) || (name == null && r.userId == userId);
    if ((userId == UserHandle.USER_ALL || r.userId == userId) && (samePackage || r.task == lastTask) && (r.app == null || evenPersistent || !r.app.persistent)) {
      if (!doit) {
        if (r.finishing) {
          continue;
        }
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + r);
      if (samePackage) {
        if (r.app != null) {
          r.app.removed=true;
        }
        r.app=null;
      }
      lastTask=r.task;
      if (r.stack.finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"",true)) {
        i--;
      }
    }
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  if (name == null) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mMainStack.resumeTopActivityLocked(null);
      mMainStack.scheduleIdleLocked();
    }
  }
  return didSomething;
}"
2966,"public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}","public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  lp.privateFlags|=LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}"
2967,"/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}","/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mForcingShowNavBar=false;
  mForcingShowNavBarLayer=-1;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}"
2968,"private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  final int visibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}","private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  int tmpVisibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  if (mForcingShowNavBar && mFocusedWindow.getSurfaceLayer() < mForcingShowNavBarLayer) {
    tmpVisibility&=~View.SYSTEM_UI_CLEARABLE_FLAGS;
  }
  final int visibility=tmpVisibility;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}"
2969,"/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && (win.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR) != 0) {
    if (mForcingShowNavBarLayer < 0) {
      mForcingShowNavBar=true;
      mForcingShowNavBarLayer=win.getSurfaceLayer();
    }
  }
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}"
2970,"@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}","@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  if (mForcingShowNavBar) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBar);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBarLayer);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}"
2971,"private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,int userId){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId);
    }
    Iterator<SparseArray<Long>> badApps=mProcessCrashTimes.getMap().values().iterator();
    while (badApps.hasNext()) {
      SparseArray<Long> ba=badApps.next();
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        badApps.remove();
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,false,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  TaskRecord lastTask=null;
  for (i=0; i < mMainStack.mHistory.size(); i++) {
    ActivityRecord r=(ActivityRecord)mMainStack.mHistory.get(i);
    final boolean samePackage=r.packageName.equals(name) || (name == null && r.userId == userId);
    if ((userId == UserHandle.USER_ALL || r.userId == userId) && (samePackage || r.task == lastTask) && (r.app == null || evenPersistent || !r.app.persistent)) {
      if (!doit) {
        if (r.finishing) {
          continue;
        }
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + r);
      if (samePackage) {
        if (r.app != null) {
          r.app.removed=true;
        }
        r.app=null;
      }
      lastTask=r.task;
      if (r.stack.finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"",true)) {
        i--;
      }
    }
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  if (name == null) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mMainStack.resumeTopActivityLocked(null);
      mMainStack.scheduleIdleLocked();
    }
  }
  return didSomething;
}","private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,int userId){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId);
    }
    Iterator<SparseArray<Long>> badApps=mProcessCrashTimes.getMap().values().iterator();
    while (badApps.hasNext()) {
      SparseArray<Long> ba=badApps.next();
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        badApps.remove();
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,true,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  TaskRecord lastTask=null;
  for (i=0; i < mMainStack.mHistory.size(); i++) {
    ActivityRecord r=(ActivityRecord)mMainStack.mHistory.get(i);
    final boolean samePackage=r.packageName.equals(name) || (name == null && r.userId == userId);
    if ((userId == UserHandle.USER_ALL || r.userId == userId) && (samePackage || r.task == lastTask) && (r.app == null || evenPersistent || !r.app.persistent)) {
      if (!doit) {
        if (r.finishing) {
          continue;
        }
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + r);
      if (samePackage) {
        if (r.app != null) {
          r.app.removed=true;
        }
        r.app=null;
      }
      lastTask=r.task;
      if (r.stack.finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"",true)) {
        i--;
      }
    }
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  if (name == null) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mMainStack.resumeTopActivityLocked(null);
      mMainStack.scheduleIdleLocked();
    }
  }
  return didSomething;
}"
2972,"public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}","public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  lp.privateFlags|=LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}"
2973,"/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}","/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mForcingShowNavBar=false;
  mForcingShowNavBarLayer=-1;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}"
2974,"private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  final int visibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}","private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  int tmpVisibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  if (mForcingShowNavBar && mFocusedWindow.getSurfaceLayer() < mForcingShowNavBarLayer) {
    tmpVisibility&=~View.SYSTEM_UI_CLEARABLE_FLAGS;
  }
  final int visibility=tmpVisibility;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}"
2975,"/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && (win.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR) != 0) {
    if (mForcingShowNavBarLayer < 0) {
      mForcingShowNavBar=true;
      mForcingShowNavBarLayer=win.getSurfaceLayer();
    }
  }
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}"
2976,"@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}","@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  if (mForcingShowNavBar) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBar);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBarLayer);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}"
2977,"private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,int userId){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId);
    }
    Iterator<SparseArray<Long>> badApps=mProcessCrashTimes.getMap().values().iterator();
    while (badApps.hasNext()) {
      SparseArray<Long> ba=badApps.next();
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        badApps.remove();
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,false,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  TaskRecord lastTask=null;
  for (i=0; i < mMainStack.mHistory.size(); i++) {
    ActivityRecord r=(ActivityRecord)mMainStack.mHistory.get(i);
    final boolean samePackage=r.packageName.equals(name) || (name == null && r.userId == userId);
    if ((userId == UserHandle.USER_ALL || r.userId == userId) && (samePackage || r.task == lastTask) && (r.app == null || evenPersistent || !r.app.persistent)) {
      if (!doit) {
        if (r.finishing) {
          continue;
        }
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + r);
      if (samePackage) {
        if (r.app != null) {
          r.app.removed=true;
        }
        r.app=null;
      }
      lastTask=r.task;
      if (r.stack.finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"",true)) {
        i--;
      }
    }
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  if (name == null) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mMainStack.resumeTopActivityLocked(null);
      mMainStack.scheduleIdleLocked();
    }
  }
  return didSomething;
}","private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,int userId){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId);
    }
    Iterator<SparseArray<Long>> badApps=mProcessCrashTimes.getMap().values().iterator();
    while (badApps.hasNext()) {
      SparseArray<Long> ba=badApps.next();
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        badApps.remove();
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,true,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  TaskRecord lastTask=null;
  for (i=0; i < mMainStack.mHistory.size(); i++) {
    ActivityRecord r=(ActivityRecord)mMainStack.mHistory.get(i);
    final boolean samePackage=r.packageName.equals(name) || (name == null && r.userId == userId);
    if ((userId == UserHandle.USER_ALL || r.userId == userId) && (samePackage || r.task == lastTask) && (r.app == null || evenPersistent || !r.app.persistent)) {
      if (!doit) {
        if (r.finishing) {
          continue;
        }
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + r);
      if (samePackage) {
        if (r.app != null) {
          r.app.removed=true;
        }
        r.app=null;
      }
      lastTask=r.task;
      if (r.stack.finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"",true)) {
        i--;
      }
    }
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  if (name == null) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mMainStack.resumeTopActivityLocked(null);
      mMainStack.scheduleIdleLocked();
    }
  }
  return didSomething;
}"
2978,"public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}","public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  lp.privateFlags|=LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}"
2979,"/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}","/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mForcingShowNavBar=false;
  mForcingShowNavBarLayer=-1;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}"
2980,"private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  final int visibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}","private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  int tmpVisibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  if (mForcingShowNavBar && mFocusedWindow.getSurfaceLayer() < mForcingShowNavBarLayer) {
    tmpVisibility&=~View.SYSTEM_UI_CLEARABLE_FLAGS;
  }
  final int visibility=tmpVisibility;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}"
2981,"/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && (win.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR) != 0) {
    if (mForcingShowNavBarLayer < 0) {
      mForcingShowNavBar=true;
      mForcingShowNavBarLayer=win.getSurfaceLayer();
    }
  }
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}"
2982,"@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}","@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  if (mForcingShowNavBar) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBar);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBarLayer);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}"
2983,"private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,int userId){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId);
    }
    Iterator<SparseArray<Long>> badApps=mProcessCrashTimes.getMap().values().iterator();
    while (badApps.hasNext()) {
      SparseArray<Long> ba=badApps.next();
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        badApps.remove();
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,false,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  TaskRecord lastTask=null;
  for (i=0; i < mMainStack.mHistory.size(); i++) {
    ActivityRecord r=(ActivityRecord)mMainStack.mHistory.get(i);
    final boolean samePackage=r.packageName.equals(name) || (name == null && r.userId == userId);
    if ((userId == UserHandle.USER_ALL || r.userId == userId) && (samePackage || r.task == lastTask) && (r.app == null || evenPersistent || !r.app.persistent)) {
      if (!doit) {
        if (r.finishing) {
          continue;
        }
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + r);
      if (samePackage) {
        if (r.app != null) {
          r.app.removed=true;
        }
        r.app=null;
      }
      lastTask=r.task;
      if (r.stack.finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"",true)) {
        i--;
      }
    }
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  if (name == null) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mMainStack.resumeTopActivityLocked(null);
      mMainStack.scheduleIdleLocked();
    }
  }
  return didSomething;
}","private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,int userId){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId);
    }
    Iterator<SparseArray<Long>> badApps=mProcessCrashTimes.getMap().values().iterator();
    while (badApps.hasNext()) {
      SparseArray<Long> ba=badApps.next();
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        badApps.remove();
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,true,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  TaskRecord lastTask=null;
  for (i=0; i < mMainStack.mHistory.size(); i++) {
    ActivityRecord r=(ActivityRecord)mMainStack.mHistory.get(i);
    final boolean samePackage=r.packageName.equals(name) || (name == null && r.userId == userId);
    if ((userId == UserHandle.USER_ALL || r.userId == userId) && (samePackage || r.task == lastTask) && (r.app == null || evenPersistent || !r.app.persistent)) {
      if (!doit) {
        if (r.finishing) {
          continue;
        }
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + r);
      if (samePackage) {
        if (r.app != null) {
          r.app.removed=true;
        }
        r.app=null;
      }
      lastTask=r.task;
      if (r.stack.finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"",true)) {
        i--;
      }
    }
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  if (name == null) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mMainStack.resumeTopActivityLocked(null);
      mMainStack.scheduleIdleLocked();
    }
  }
  return didSomething;
}"
2984,"public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE && sConfirmSafeVolumeDialog == null) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}","public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE && sConfirmSafeVolumeDialog == null) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  lp.privateFlags|=LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}"
2985,"/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}","/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mForcingShowNavBar=false;
  mForcingShowNavBarLayer=-1;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}"
2986,"private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  final int visibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}","private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  int tmpVisibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  if (mForcingShowNavBar && mFocusedWindow.getSurfaceLayer() < mForcingShowNavBarLayer) {
    tmpVisibility&=~View.SYSTEM_UI_CLEARABLE_FLAGS;
  }
  final int visibility=tmpVisibility;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}"
2987,"/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && (win.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR) != 0) {
    if (mForcingShowNavBarLayer < 0) {
      mForcingShowNavBar=true;
      mForcingShowNavBarLayer=win.getSurfaceLayer();
    }
  }
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}"
2988,"@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}","@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  if (mForcingShowNavBar) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBar);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBarLayer);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}"
2989,"public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE && sConfirmSafeVolumeDialog == null) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}","public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE && sConfirmSafeVolumeDialog == null) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  lp.privateFlags|=LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}"
2990,"/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}","/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mForcingShowNavBar=false;
  mForcingShowNavBarLayer=-1;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}"
2991,"private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  final int visibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}","private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  int tmpVisibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  if (mForcingShowNavBar && mFocusedWindow.getSurfaceLayer() < mForcingShowNavBarLayer) {
    tmpVisibility&=~View.SYSTEM_UI_CLEARABLE_FLAGS;
  }
  final int visibility=tmpVisibility;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}"
2992,"/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && (win.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR) != 0) {
    if (mForcingShowNavBarLayer < 0) {
      mForcingShowNavBar=true;
      mForcingShowNavBarLayer=win.getSurfaceLayer();
    }
  }
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}"
2993,"@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}","@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  if (mForcingShowNavBar) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBar);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBarLayer);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}"
2994,"public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE && sConfirmSafeVolumeDialog == null) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}","public VolumePanel(final Context context,AudioService volumeService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mAudioService=volumeService;
  boolean useMasterVolume=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  if (useMasterVolume) {
    for (int i=0; i < STREAMS.length; i++) {
      StreamResources streamRes=STREAMS[i];
      streamRes.show=(streamRes.streamType == STREAM_MASTER);
    }
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View view=mView=inflater.inflate(R.layout.volume_adjust,null);
  mView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View v,    MotionEvent event){
      resetTimeout();
      return false;
    }
  }
);
  mPanel=(ViewGroup)mView.findViewById(R.id.visible_panel);
  mSliderGroup=(ViewGroup)mView.findViewById(R.id.slider_group);
  mMoreButton=(ImageView)mView.findViewById(R.id.expand_button);
  mDivider=(ImageView)mView.findViewById(R.id.expand_button_divider);
  mDialog=new Dialog(context,R.style.Theme_Panel_Volume){
    public boolean onTouchEvent(    MotionEvent event){
      if (isShowing() && event.getAction() == MotionEvent.ACTION_OUTSIDE && sConfirmSafeVolumeDialog == null) {
        forceTimeout();
        return true;
      }
      return false;
    }
  }
;
  mDialog.setTitle(""String_Node_Str"");
  mDialog.setContentView(mView);
  mDialog.setOnDismissListener(new OnDismissListener(){
    public void onDismiss(    DialogInterface dialog){
      mActiveStreamType=-1;
      mAudioManager.forceVolumeControlStream(mActiveStreamType);
    }
  }
);
  Window window=mDialog.getWindow();
  window.setGravity(Gravity.TOP);
  LayoutParams lp=window.getAttributes();
  lp.token=null;
  lp.y=mContext.getResources().getDimensionPixelOffset(com.android.internal.R.dimen.volume_panel_top);
  lp.type=LayoutParams.TYPE_VOLUME_OVERLAY;
  lp.width=LayoutParams.WRAP_CONTENT;
  lp.height=LayoutParams.WRAP_CONTENT;
  lp.privateFlags|=LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR;
  window.setAttributes(lp);
  window.addFlags(LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);
  mToneGenerators=new ToneGenerator[AudioSystem.getNumStreamTypes()];
  mVibrator=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);
  mVoiceCapable=context.getResources().getBoolean(R.bool.config_voice_capable);
  mShowCombinedVolumes=!mVoiceCapable && !useMasterVolume;
  if (!mShowCombinedVolumes) {
    mMoreButton.setVisibility(View.GONE);
    mDivider.setVisibility(View.GONE);
  }
 else {
    mMoreButton.setOnClickListener(this);
  }
  boolean masterVolumeOnly=context.getResources().getBoolean(com.android.internal.R.bool.config_useMasterVolume);
  boolean masterVolumeKeySounds=mContext.getResources().getBoolean(com.android.internal.R.bool.config_useVolumeKeySounds);
  mPlayMasterStreamTones=masterVolumeOnly && masterVolumeKeySounds;
  listenToRingerMode();
}"
2995,"/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}","/** 
 * {@inheritDoc} 
 */
@Override public void beginPostLayoutPolicyLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  mForceStatusBarFromKeyguard=false;
  mForcingShowNavBar=false;
  mForcingShowNavBarLayer=-1;
  mHideLockScreen=false;
  mAllowLockscreenWhenOn=false;
  mDismissKeyguard=DISMISS_KEYGUARD_NONE;
  mShowingLockscreen=false;
  mShowingDream=false;
}"
2996,"private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  final int visibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}","private int updateSystemUiVisibilityLw(){
  if (mFocusedWindow == null) {
    return 0;
  }
  if (mFocusedWindow.getAttrs().type == TYPE_KEYGUARD && mHideLockScreen == true) {
    return 0;
  }
  int tmpVisibility=mFocusedWindow.getSystemUiVisibility() & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
  if (mForcingShowNavBar && mFocusedWindow.getSurfaceLayer() < mForcingShowNavBarLayer) {
    tmpVisibility&=~View.SYSTEM_UI_CLEARABLE_FLAGS;
  }
  final int visibility=tmpVisibility;
  int diff=visibility ^ mLastSystemUiFlags;
  final boolean needsMenu=mFocusedWindow.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
  if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == mFocusedWindow.getAppToken()) {
    return 0;
  }
  mLastSystemUiFlags=visibility;
  mLastFocusNeedsMenu=needsMenu;
  mFocusedApp=mFocusedWindow.getAppToken();
  mHandler.post(new Runnable(){
    public void run(){
      try {
        IStatusBarService statusbar=getStatusBarService();
        if (statusbar != null) {
          statusbar.setSystemUiVisibility(visibility,0xffffffff);
          statusbar.topAppWindowChanged(needsMenu);
        }
      }
 catch (      RemoteException e) {
        mStatusBarService=null;
      }
    }
  }
);
  return diff;
}"
2997,"/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void applyPostLayoutPolicyLw(WindowState win,WindowManager.LayoutParams attrs){
  if (DEBUG_LAYOUT)   Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isVisibleOrBehindKeyguardLw());
  if (mTopFullscreenOpaqueWindowState == null && (win.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR) != 0) {
    if (mForcingShowNavBarLayer < 0) {
      mForcingShowNavBar=true;
      mForcingShowNavBarLayer=win.getSurfaceLayer();
    }
  }
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      if (attrs.type == TYPE_KEYGUARD) {
        mForceStatusBarFromKeyguard=true;
      }
 else {
        mForceStatusBar=true;
      }
    }
    if (attrs.type == TYPE_KEYGUARD) {
      mShowingLockscreen=true;
    }
    boolean applyWindow=attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
    if (attrs.type == TYPE_DREAM) {
      if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
        mShowingDream=true;
        applyWindow=true;
      }
    }
    if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
        mWinDismissingKeyguard=win;
        mForceStatusBarFromKeyguard=false;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}"
2998,"@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}","@Override public void dump(String prefix,PrintWriter pw,String[] args){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSafeMode);
  pw.print(""String_Node_Str"");
  pw.print(mSystemReady);
  pw.print(""String_Node_Str"");
  pw.println(mSystemBooted);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidState);
  pw.print(""String_Node_Str"");
  pw.print(mLidOpenRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiPlugged);
  if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mLastSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mResettingSystemUiFlags));
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
  }
  if (mLastFocusNeedsMenu) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastFocusNeedsMenu);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockMode);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockRotation);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotationMode);
  pw.print(""String_Node_Str"");
  pw.print(mUserRotation);
  pw.print(""String_Node_Str"");
  pw.println(mAllowAllRotations);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mCurrentAppOrientation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCarDockEnablesAccelerometer);
  pw.print(""String_Node_Str"");
  pw.println(mDeskDockEnablesAccelerometer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLidKeyboardAccessibility);
  pw.print(""String_Node_Str"");
  pw.print(mLidNavigationAccessibility);
  pw.print(""String_Node_Str"");
  pw.println(mLidControlsSleep);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLongPressOnPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mHasSoftInput);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnEarly);
  pw.print(""String_Node_Str"");
  pw.print(mScreenOnFully);
  pw.print(""String_Node_Str"");
  pw.println(mOrientationSensorEnabled);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mUnrestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mUnrestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mRestrictedScreenWidth);
  pw.print(""String_Node_Str"");
  pw.println(mRestrictedScreenHeight);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableFullscreenBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mStableLeft);
  pw.print(""String_Node_Str"");
  pw.print(mStableTop);
  pw.print(""String_Node_Str"");
  pw.print(mStableRight);
  pw.print(""String_Node_Str"");
  pw.print(mStableBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mSystemLeft);
  pw.print(""String_Node_Str"");
  pw.print(mSystemTop);
  pw.print(""String_Node_Str"");
  pw.print(mSystemRight);
  pw.print(""String_Node_Str"");
  pw.print(mSystemBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mCurLeft);
  pw.print(""String_Node_Str"");
  pw.print(mCurTop);
  pw.print(""String_Node_Str"");
  pw.print(mCurRight);
  pw.print(""String_Node_Str"");
  pw.print(mCurBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mContentLeft);
  pw.print(""String_Node_Str"");
  pw.print(mContentTop);
  pw.print(""String_Node_Str"");
  pw.print(mContentRight);
  pw.print(""String_Node_Str"");
  pw.print(mContentBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLeft);
  pw.print(""String_Node_Str"");
  pw.print(mDockTop);
  pw.print(""String_Node_Str"");
  pw.print(mDockRight);
  pw.print(""String_Node_Str"");
  pw.print(mDockBottom);
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDockLayer);
  pw.print(""String_Node_Str"");
  pw.println(mStatusBarLayer);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mShowingLockscreen);
  pw.print(""String_Node_Str"");
  pw.print(mShowingDream);
  pw.print(""String_Node_Str"");
  pw.println(mDreamingLockscreen);
  if (mLastInputMethodWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodWindow);
  }
  if (mLastInputMethodTargetWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastInputMethodTargetWindow);
  }
  if (mStatusBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mStatusBar);
  }
  if (mNavigationBar != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mNavigationBar);
  }
  if (mKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mKeyguard);
  }
  if (mFocusedWindow != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedWindow);
  }
  if (mFocusedApp != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mFocusedApp);
  }
  if (mWinDismissingKeyguard != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mWinDismissingKeyguard);
  }
  if (mTopFullscreenOpaqueWindowState != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mTopFullscreenOpaqueWindowState);
  }
  if (mForcingShowNavBar) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBar);
    pw.print(""String_Node_Str"");
    pw.println(mForcingShowNavBarLayer);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mTopIsFullscreen);
  pw.print(""String_Node_Str"");
  pw.println(mHideLockScreen);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mForceStatusBar);
  pw.print(""String_Node_Str"");
  pw.println(mForceStatusBarFromKeyguard);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mDismissKeyguard);
  pw.print(""String_Node_Str"");
  pw.print(mWinDismissingKeyguard);
  pw.print(""String_Node_Str"");
  pw.println(mHomePressed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mAllowLockscreenWhenOn);
  pw.print(""String_Node_Str"");
  pw.print(mLockScreenTimeout);
  pw.print(""String_Node_Str"");
  pw.println(mLockScreenTimerActive);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mEndcallBehavior);
  pw.print(""String_Node_Str"");
  pw.print(mIncallPowerBehavior);
  pw.print(""String_Node_Str"");
  pw.println(mLongPressOnHomeBehavior);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mLandscapeRotation);
  pw.print(""String_Node_Str"");
  pw.println(mSeascapeRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mPortraitRotation);
  pw.print(""String_Node_Str"");
  pw.println(mUpsideDownRotation);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHdmiRotation);
  pw.print(""String_Node_Str"");
  pw.println(mHdmiRotationLock);
}"
2999,"/** 
 * Called when this view wants to give up focus. If focus is cleared  {@link #onFocusChanged(boolean,int,android.graphics.Rect)} is called.<p> <strong>Note:</strong> When a View clears focus the framework is trying to give focus to the first focusable View from the top. Hence, if this View is the first from the top that can take focus, then all callbacks related to clearing focus will be invoked after wich the framework will give focus to this view. </p>
 */
public void clearFocus(){
  if (DBG) {
    System.out.println(this + ""String_Node_Str"");
  }
  if ((mPrivateFlags & PFLAG_FOCUSED) != 0) {
    mPrivateFlags&=~PFLAG_FOCUSED;
    if (mParent != null) {
      mParent.clearChildFocus(this);
    }
    onFocusChanged(false,0,null);
    refreshDrawableState();
    ensureInputFocusOnFirstFocusable();
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
      notifyAccessibilityStateChanged();
    }
  }
}","/** 
 * Called when this view wants to give up focus. If focus is cleared  {@link #onFocusChanged(boolean,int,android.graphics.Rect)} is called.<p> <strong>Note:</strong> When a View clears focus the framework is trying to give focus to the first focusable View from the top. Hence, if this View is the first from the top that can take focus, then all callbacks related to clearing focus will be invoked after wich the framework will give focus to this view. </p>
 */
public void clearFocus(){
  if (DBG) {
    System.out.println(this + ""String_Node_Str"");
  }
  if ((mPrivateFlags & PFLAG_FOCUSED) != 0) {
    mPrivateFlags&=~PFLAG_FOCUSED;
    if (mParent != null) {
      mParent.clearChildFocus(this);
    }
    onFocusChanged(false,0,null);
    refreshDrawableState();
    if (!rootViewRequestFocus()) {
      notifyGlobalFocusCleared(this);
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
      notifyAccessibilityStateChanged();
    }
  }
}"
3000,"/** 
 * Give this view focus. This will cause  {@link #onFocusChanged(boolean,int,android.graphics.Rect)} to be called.Note: this does not check whether this  {@link View} should get focus, it justgives it focus no matter what.  It should only be called internally by framework code that knows what it is doing, namely  {@link #requestFocus(int,Rect)}.
 * @param direction values are {@link View#FOCUS_UP},   {@link View#FOCUS_DOWN},  {@link View#FOCUS_LEFT} or {@link View#FOCUS_RIGHT}. This is the direction which focus moved when requestFocus() is called. It may not always apply, in which case use the default View.FOCUS_DOWN.
 * @param previouslyFocusedRect The rectangle of the view that had focusprior in this View's coordinate system.
 */
void handleFocusGainInternal(int direction,Rect previouslyFocusedRect){
  if (DBG) {
    System.out.println(this + ""String_Node_Str"");
  }
  if ((mPrivateFlags & PFLAG_FOCUSED) == 0) {
    mPrivateFlags|=PFLAG_FOCUSED;
    if (mParent != null) {
      mParent.requestChildFocus(this,this);
    }
    onFocusChanged(true,direction,previouslyFocusedRect);
    refreshDrawableState();
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
      notifyAccessibilityStateChanged();
    }
  }
}","/** 
 * Give this view focus. This will cause  {@link #onFocusChanged(boolean,int,android.graphics.Rect)} to be called.Note: this does not check whether this  {@link View} should get focus, it justgives it focus no matter what.  It should only be called internally by framework code that knows what it is doing, namely  {@link #requestFocus(int,Rect)}.
 * @param direction values are {@link View#FOCUS_UP},   {@link View#FOCUS_DOWN},  {@link View#FOCUS_LEFT} or {@link View#FOCUS_RIGHT}. This is the direction which focus moved when requestFocus() is called. It may not always apply, in which case use the default View.FOCUS_DOWN.
 * @param previouslyFocusedRect The rectangle of the view that had focusprior in this View's coordinate system.
 */
void handleFocusGainInternal(int direction,Rect previouslyFocusedRect){
  if (DBG) {
    System.out.println(this + ""String_Node_Str"");
  }
  if ((mPrivateFlags & PFLAG_FOCUSED) == 0) {
    mPrivateFlags|=PFLAG_FOCUSED;
    View oldFocus=(mAttachInfo != null) ? getRootView().findFocus() : null;
    if (mParent != null) {
      mParent.requestChildFocus(this,this);
    }
    if (mAttachInfo != null) {
      mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus,this);
    }
    onFocusChanged(true,direction,previouslyFocusedRect);
    refreshDrawableState();
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
      notifyAccessibilityStateChanged();
    }
  }
}"
