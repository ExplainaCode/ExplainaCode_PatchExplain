record_number,buggy_code,fixed_code
22001,"private boolean getValueAt(int index,TypedValue outValue){
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if (type == TypedValue.TYPE_NULL) {
    return false;
  }
  outValue.type=type;
  outValue.data=data[index + AssetManager.STYLE_DATA];
  outValue.assetCookie=data[index + AssetManager.STYLE_ASSET_COOKIE];
  outValue.resourceId=data[index + AssetManager.STYLE_RESOURCE_ID];
  outValue.changingConfigurations=data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS];
  outValue.density=data[index + AssetManager.STYLE_DENSITY];
  if (type == TypedValue.TYPE_STRING) {
    outValue.string=loadStringValueAt(index);
  }
  return true;
}","private boolean getValueAt(int index,TypedValue outValue){
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if (type == TypedValue.TYPE_NULL) {
    return false;
  }
  outValue.type=type;
  outValue.data=data[index + AssetManager.STYLE_DATA];
  outValue.assetCookie=data[index + AssetManager.STYLE_ASSET_COOKIE];
  outValue.resourceId=data[index + AssetManager.STYLE_RESOURCE_ID];
  outValue.changingConfigurations=data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS];
  outValue.density=data[index + AssetManager.STYLE_DENSITY];
  outValue.string=(type == TypedValue.TYPE_STRING) ? loadStringValueAt(index) : null;
  return true;
}"
22002,"private boolean getValueAt(int index,TypedValue outValue){
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if (type == TypedValue.TYPE_NULL) {
    return false;
  }
  outValue.type=type;
  outValue.data=data[index + AssetManager.STYLE_DATA];
  outValue.assetCookie=data[index + AssetManager.STYLE_ASSET_COOKIE];
  outValue.resourceId=data[index + AssetManager.STYLE_RESOURCE_ID];
  outValue.changingConfigurations=data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS];
  outValue.density=data[index + AssetManager.STYLE_DENSITY];
  if (type == TypedValue.TYPE_STRING) {
    outValue.string=loadStringValueAt(index);
  }
  return true;
}","private boolean getValueAt(int index,TypedValue outValue){
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if (type == TypedValue.TYPE_NULL) {
    return false;
  }
  outValue.type=type;
  outValue.data=data[index + AssetManager.STYLE_DATA];
  outValue.assetCookie=data[index + AssetManager.STYLE_ASSET_COOKIE];
  outValue.resourceId=data[index + AssetManager.STYLE_RESOURCE_ID];
  outValue.changingConfigurations=data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS];
  outValue.density=data[index + AssetManager.STYLE_DENSITY];
  outValue.string=(type == TypedValue.TYPE_STRING) ? loadStringValueAt(index) : null;
  return true;
}"
22003,"private final IContentProvider getProvider(Context context,String name){
synchronized (mProviderMap) {
    final ProviderClientRecord pr=mProviderMap.get(name);
    if (pr != null) {
      return pr.mProvider;
    }
  }
  IActivityManager.ContentProviderHolder holder=null;
  try {
    holder=ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(),name);
  }
 catch (  RemoteException ex) {
  }
  if (holder == null) {
    Slog.e(TAG,""String_Node_Str"" + name);
    return null;
  }
  if (holder.permissionFailure != null) {
    throw new SecurityException(""String_Node_Str"" + holder.permissionFailure + ""String_Node_Str""+ name);
  }
  IContentProvider prov=installProvider(context,holder.provider,holder.info,true);
  if (holder.noReleaseNeeded || holder.provider == null) {
synchronized (mProviderMap) {
      mProviderRefCountMap.put(prov.asBinder(),new ProviderRefCount(10000));
    }
  }
  return prov;
}","private final IContentProvider getProvider(Context context,String name){
synchronized (mProviderMap) {
    final ProviderClientRecord pr=mProviderMap.get(name);
    if (pr != null) {
      return pr.mProvider;
    }
  }
  IActivityManager.ContentProviderHolder holder=null;
  try {
    holder=ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(),name);
  }
 catch (  RemoteException ex) {
  }
  if (holder == null) {
    Slog.e(TAG,""String_Node_Str"" + name);
    return null;
  }
  IContentProvider prov=installProvider(context,holder.provider,holder.info,true);
  if (holder.noReleaseNeeded || holder.provider == null) {
synchronized (mProviderMap) {
      mProviderRefCountMap.put(prov.asBinder(),new ProviderRefCount(10000));
    }
  }
  return prov;
}"
22004,"private ContentProviderHolder(Parcel source){
  info=ProviderInfo.CREATOR.createFromParcel(source);
  permissionFailure=source.readString();
  provider=ContentProviderNative.asInterface(source.readStrongBinder());
  noReleaseNeeded=source.readInt() != 0;
}","private ContentProviderHolder(Parcel source){
  info=ProviderInfo.CREATOR.createFromParcel(source);
  provider=ContentProviderNative.asInterface(source.readStrongBinder());
  noReleaseNeeded=source.readInt() != 0;
}"
22005,"/** 
 * After being instantiated, this is called to tell the content provider about itself.
 * @param context The context this provider is running in
 * @param info Registered information about this content provider
 */
public void attachInfo(Context context,ProviderInfo info){
  if (mContext == null) {
    mContext=context;
    mMyUid=Process.myUid();
    if (info != null) {
      setReadPermission(info.readPermission);
      setWritePermission(info.writePermission);
      setPathPermissions(info.pathPermissions);
    }
    ContentProvider.this.onCreate();
  }
}","/** 
 * After being instantiated, this is called to tell the content provider about itself.
 * @param context The context this provider is running in
 * @param info Registered information about this content provider
 */
public void attachInfo(Context context,ProviderInfo info){
  if (mContext == null) {
    mContext=context;
    mMyUid=Process.myUid();
    if (info != null) {
      setReadPermission(info.readPermission);
      setWritePermission(info.writePermission);
      setPathPermissions(info.pathPermissions);
      mExported=info.exported;
    }
    ContentProvider.this.onCreate();
  }
}"
22006,"private void enforceReadPermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return;
  }
  final Context context=getContext();
  final String rperm=getReadPermission();
  final int pid=Binder.getCallingPid();
  if (rperm == null || context.checkPermission(rperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
    return;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String pprperm=pp.getReadPermission();
      if (pprperm != null && pp.match(path)) {
        if (context.checkPermission(pprperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_READ_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return;
  }
  String msg=""String_Node_Str"" + ContentProvider.this.getClass().getName() + ""String_Node_Str""+ uri+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ rperm;
  throw new SecurityException(msg);
}","private void enforceReadPermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return;
  }
  final Context context=getContext();
  final String rperm=getReadPermission();
  final int pid=Binder.getCallingPid();
  if (mExported && (rperm == null || context.checkPermission(rperm,pid,uid) == PackageManager.PERMISSION_GRANTED)) {
    return;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String pprperm=pp.getReadPermission();
      if (pprperm != null && pp.match(path)) {
        if (context.checkPermission(pprperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_READ_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return;
  }
  String msg=""String_Node_Str"" + ContentProvider.this.getClass().getName() + ""String_Node_Str""+ uri+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ rperm;
  throw new SecurityException(msg);
}"
22007,"private boolean hasWritePermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return true;
  }
  final Context context=getContext();
  final String wperm=getWritePermission();
  final int pid=Binder.getCallingPid();
  if (wperm == null || context.checkPermission(wperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
    return true;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String ppwperm=pp.getWritePermission();
      if (ppwperm != null && pp.match(path)) {
        if (context.checkPermission(ppwperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return true;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_WRITE_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return true;
  }
  return false;
}","private boolean hasWritePermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return true;
  }
  final Context context=getContext();
  final String wperm=getWritePermission();
  final int pid=Binder.getCallingPid();
  if (mExported && (wperm == null || context.checkPermission(wperm,pid,uid) == PackageManager.PERMISSION_GRANTED)) {
    return true;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String ppwperm=pp.getWritePermission();
      if (ppwperm != null && pp.match(path)) {
        if (context.checkPermission(ppwperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return true;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_WRITE_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return true;
  }
  return false;
}"
22008,"void grantUriPermissionFromIntentLocked(int callingUid,String targetPkg,Intent intent,ActivityRecord activity){
  if (intent == null) {
    return;
  }
  Uri data=intent.getData();
  if (data == null) {
    return;
  }
  grantUriPermissionLocked(callingUid,targetPkg,data,intent.getFlags(),activity);
}","void grantUriPermissionFromIntentLocked(int callingUid,String targetPkg,Intent intent,ActivityRecord activity){
  if (DEBUG_URI_PERMISSION)   Slog.v(TAG,""String_Node_Str"" + (intent != null ? intent.getData() : null) + ""String_Node_Str""+ intent+ ""String_Node_Str""+ Integer.toHexString(intent != null ? intent.getFlags() : 0));
  if (intent == null) {
    return;
  }
  Uri data=intent.getData();
  if (data == null) {
    return;
  }
  grantUriPermissionLocked(callingUid,targetPkg,data,intent.getFlags(),activity);
}"
22009,"public void handleApplicationStrictModeViolation(IBinder app,int violationMask,StrictMode.ViolationInfo info){
  ProcessRecord r=findAppProcess(app);
  if ((violationMask & StrictMode.PENALTY_DROPBOX) != 0) {
    Integer stackFingerprint=info.crashInfo.stackTrace.hashCode();
    boolean logIt=true;
synchronized (mAlreadyLoggedViolatedStacks) {
      if (mAlreadyLoggedViolatedStacks.contains(stackFingerprint)) {
        logIt=false;
      }
 else {
        if (mAlreadyLoggedViolatedStacks.size() >= MAX_DUP_SUPPRESSED_STACKS) {
          mAlreadyLoggedViolatedStacks.clear();
        }
        mAlreadyLoggedViolatedStacks.add(stackFingerprint);
      }
    }
    if (logIt) {
      logStrictModeViolationToDropBox(r,info);
    }
  }
  if ((violationMask & StrictMode.PENALTY_DIALOG) != 0) {
    AppErrorResult result=new AppErrorResult();
synchronized (this) {
      final long origId=Binder.clearCallingIdentity();
      Message msg=Message.obtain();
      msg.what=SHOW_STRICT_MODE_VIOLATION_MSG;
      HashMap<String,Object> data=new HashMap<String,Object>();
      data.put(""String_Node_Str"",result);
      data.put(""String_Node_Str"",r);
      data.put(""String_Node_Str"",violationMask);
      data.put(""String_Node_Str"",info);
      msg.obj=data;
      mHandler.sendMessage(msg);
      Binder.restoreCallingIdentity(origId);
    }
    int res=result.get();
    Log.w(TAG,""String_Node_Str"" + res);
  }
}","public void handleApplicationStrictModeViolation(IBinder app,int violationMask,StrictMode.ViolationInfo info){
  ProcessRecord r=findAppProcess(app);
  if ((violationMask & StrictMode.PENALTY_DROPBOX) != 0) {
    Integer stackFingerprint=info.crashInfo.stackTrace.hashCode();
    boolean logIt=true;
synchronized (mAlreadyLoggedViolatedStacks) {
      if (mAlreadyLoggedViolatedStacks.contains(stackFingerprint)) {
        logIt=false;
      }
 else {
        if (mAlreadyLoggedViolatedStacks.size() >= MAX_DUP_SUPPRESSED_STACKS) {
          mAlreadyLoggedViolatedStacks.clear();
        }
        mAlreadyLoggedViolatedStacks.add(stackFingerprint);
      }
    }
    if (logIt) {
      logStrictModeViolationToDropBox(r,info);
    }
  }
  if ((violationMask & StrictMode.PENALTY_DIALOG) != 0) {
    AppErrorResult result=new AppErrorResult();
synchronized (this) {
      final long origId=Binder.clearCallingIdentity();
      Message msg=Message.obtain();
      msg.what=SHOW_STRICT_MODE_VIOLATION_MSG;
      HashMap<String,Object> data=new HashMap<String,Object>();
      data.put(""String_Node_Str"",result);
      data.put(""String_Node_Str"",r);
      data.put(""String_Node_Str"",violationMask);
      data.put(""String_Node_Str"",info);
      msg.obj=data;
      mHandler.sendMessage(msg);
      Binder.restoreCallingIdentity(origId);
    }
    int res=result.get();
    Slog.w(TAG,""String_Node_Str"" + res);
  }
}"
22010,"private final boolean checkHoldingPermissionsLocked(IPackageManager pm,ProviderInfo pi,int uid,int modeFlags){
  try {
    if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
      if ((pi.readPermission != null) && (pm.checkUidPermission(pi.readPermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
      if ((pi.writePermission != null) && (pm.checkUidPermission(pi.writePermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    return true;
  }
 catch (  RemoteException e) {
    return false;
  }
}","private final boolean checkHoldingPermissionsLocked(IPackageManager pm,ProviderInfo pi,int uid,int modeFlags){
  try {
    if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
      if ((pi.readPermission != null) && (pm.checkUidPermission(pi.readPermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
      if ((pi.writePermission != null) && (pm.checkUidPermission(pi.writePermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    if (!pi.exported && pi.applicationInfo.uid != uid) {
      return false;
    }
    return true;
  }
 catch (  RemoteException e) {
    return false;
  }
}"
22011,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj <= PERCEPTIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=AppGlobals.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      String msg;
      if ((msg=checkContentProviderPermissionLocked(cpi,r)) != null) {
        throw new SecurityException(msg);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj <= PERCEPTIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=AppGlobals.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      String msg;
      if ((msg=checkContentProviderPermissionLocked(cpi,r)) != null) {
        throw new SecurityException(msg);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}"
22012,"public void handleMessage(Message msg){
switch (msg.what) {
case SHOW_ERROR_MSG:
{
      HashMap data=(HashMap)msg.obj;
synchronized (ActivityManagerService.this) {
        ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
        if (proc != null && proc.crashDialog != null) {
          Slog.e(TAG,""String_Node_Str"" + proc);
          return;
        }
        AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
        if (!mSleeping && !mShuttingDown) {
          Dialog d=new AppErrorDialog(mContext,res,proc);
          d.show();
          proc.crashDialog=d;
        }
 else {
          res.set(0);
        }
      }
      ensureBootCompleted();
    }
  break;
case SHOW_NOT_RESPONDING_MSG:
{
synchronized (ActivityManagerService.this) {
    HashMap data=(HashMap)msg.obj;
    ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
    if (proc != null && proc.anrDialog != null) {
      Slog.e(TAG,""String_Node_Str"" + proc);
      return;
    }
    broadcastIntentLocked(null,null,new Intent(""String_Node_Str""),null,null,0,null,null,null,false,false,MY_PID,Process.SYSTEM_UID);
    Dialog d=new AppNotRespondingDialog(ActivityManagerService.this,mContext,proc,(ActivityRecord)data.get(""String_Node_Str""));
    d.show();
    proc.anrDialog=d;
  }
  ensureBootCompleted();
}
break;
case SHOW_STRICT_MODE_VIOLATION_MSG:
{
HashMap<String,Object> data=(HashMap<String,Object>)msg.obj;
synchronized (ActivityManagerService.this) {
ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
if (proc == null) {
  Slog.e(TAG,""String_Node_Str"");
  break;
}
if (proc.crashDialog != null) {
  Slog.e(TAG,""String_Node_Str"" + proc);
  return;
}
AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
if (!mSleeping && !mShuttingDown) {
  Dialog d=new StrictModeViolationDialog(mContext,res,proc);
  d.show();
  proc.crashDialog=d;
}
 else {
  res.set(0);
}
}
ensureBootCompleted();
}
break;
case SHOW_FACTORY_ERROR_MSG:
{
Dialog d=new FactoryErrorDialog(mContext,msg.getData().getCharSequence(""String_Node_Str""));
d.show();
ensureBootCompleted();
}
break;
case UPDATE_CONFIGURATION_MSG:
{
final ContentResolver resolver=mContext.getContentResolver();
Settings.System.putConfiguration(resolver,(Configuration)msg.obj);
}
break;
case GC_BACKGROUND_PROCESSES_MSG:
{
synchronized (ActivityManagerService.this) {
performAppGcsIfAppropriateLocked();
}
}
break;
case WAIT_FOR_DEBUGGER_MSG:
{
synchronized (ActivityManagerService.this) {
ProcessRecord app=(ProcessRecord)msg.obj;
if (msg.arg1 != 0) {
if (!app.waitedForDebugger) {
Dialog d=new AppWaitingForDebuggerDialog(ActivityManagerService.this,mContext,app);
app.waitDialog=d;
app.waitedForDebugger=true;
d.show();
}
}
 else {
if (app.waitDialog != null) {
app.waitDialog.dismiss();
app.waitDialog=null;
}
}
}
}
break;
case BROADCAST_INTENT_MSG:
{
if (DEBUG_BROADCAST) Slog.v(TAG,""String_Node_Str"");
processNextBroadcast(true);
}
break;
case BROADCAST_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG);
mHandler.sendMessageDelayed(nmsg,BROADCAST_TIMEOUT);
return;
}
if (mSystemReady) {
broadcastTimeout();
}
}
break;
case SERVICE_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,SERVICE_TIMEOUT);
return;
}
serviceTimeout((ProcessRecord)msg.obj);
}
break;
case UPDATE_TIME_ZONE:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.updateTimeZone();
}
 catch (RemoteException ex) {
Slog.w(TAG,""String_Node_Str"" + r.info.processName);
}
}
}
}
}
break;
case SHOW_UID_ERROR_MSG:
{
AlertDialog d=new BaseErrorDialog(mContext);
d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
d.setCancelable(false);
d.setTitle(""String_Node_Str"");
d.setMessage(""String_Node_Str"");
d.setButton(""String_Node_Str"",mHandler.obtainMessage(IM_FEELING_LUCKY_MSG));
mUidAlert=d;
d.show();
}
break;
case IM_FEELING_LUCKY_MSG:
{
if (mUidAlert != null) {
mUidAlert.dismiss();
mUidAlert=null;
}
}
break;
case PROC_START_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,PROC_START_TIMEOUT);
return;
}
ProcessRecord app=(ProcessRecord)msg.obj;
synchronized (ActivityManagerService.this) {
processStartTimedOutLocked(app);
}
}
break;
case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
{
synchronized (ActivityManagerService.this) {
doPendingActivityLaunchesLocked(true);
}
}
break;
case KILL_APPLICATION_MSG:
{
synchronized (ActivityManagerService.this) {
int uid=msg.arg1;
boolean restart=(msg.arg2 == 1);
String pkg=(String)msg.obj;
forceStopPackageLocked(pkg,uid,restart,false,true);
}
}
break;
case FINALIZE_PENDING_INTENT_MSG:
{
((PendingIntentRecord)msg.obj).completeFinalize();
}
break;
case POST_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
ActivityRecord root=(ActivityRecord)msg.obj;
ProcessRecord process=root.app;
if (process == null) {
return;
}
try {
Context context=mContext.createPackageContext(process.info.packageName,0);
String text=mContext.getString(R.string.heavy_weight_notification,context.getApplicationInfo().loadLabel(context.getPackageManager()));
Notification notification=new Notification();
notification.icon=com.android.internal.R.drawable.stat_sys_adb;
notification.when=0;
notification.flags=Notification.FLAG_ONGOING_EVENT;
notification.tickerText=text;
notification.defaults=0;
notification.sound=null;
notification.vibrate=null;
notification.setLatestEventInfo(context,text,mContext.getText(R.string.heavy_weight_notification_detail),PendingIntent.getActivity(mContext,0,root.intent,PendingIntent.FLAG_CANCEL_CURRENT));
try {
int[] outId=new int[1];
inm.enqueueNotification(""String_Node_Str"",R.string.heavy_weight_notification,notification,outId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
 catch (NameNotFoundException e) {
Log.w(TAG,""String_Node_Str"",e);
}
}
break;
case CANCEL_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
try {
inm.cancelNotification(""String_Node_Str"",R.string.heavy_weight_notification);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
break;
case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
{
synchronized (ActivityManagerService.this) {
checkExcessiveWakeLocksLocked(true);
removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
if (mSleeping) {
Message nmsg=obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
sendMessageDelayed(nmsg,WAKE_LOCK_CHECK_DELAY);
}
}
}
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case SHOW_ERROR_MSG:
{
      HashMap data=(HashMap)msg.obj;
synchronized (ActivityManagerService.this) {
        ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
        if (proc != null && proc.crashDialog != null) {
          Slog.e(TAG,""String_Node_Str"" + proc);
          return;
        }
        AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
        if (!mSleeping && !mShuttingDown) {
          Dialog d=new AppErrorDialog(mContext,res,proc);
          d.show();
          proc.crashDialog=d;
        }
 else {
          res.set(0);
        }
      }
      ensureBootCompleted();
    }
  break;
case SHOW_NOT_RESPONDING_MSG:
{
synchronized (ActivityManagerService.this) {
    HashMap data=(HashMap)msg.obj;
    ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
    if (proc != null && proc.anrDialog != null) {
      Slog.e(TAG,""String_Node_Str"" + proc);
      return;
    }
    broadcastIntentLocked(null,null,new Intent(""String_Node_Str""),null,null,0,null,null,null,false,false,MY_PID,Process.SYSTEM_UID);
    Dialog d=new AppNotRespondingDialog(ActivityManagerService.this,mContext,proc,(ActivityRecord)data.get(""String_Node_Str""));
    d.show();
    proc.anrDialog=d;
  }
  ensureBootCompleted();
}
break;
case SHOW_STRICT_MODE_VIOLATION_MSG:
{
HashMap<String,Object> data=(HashMap<String,Object>)msg.obj;
synchronized (ActivityManagerService.this) {
ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
if (proc == null) {
  Slog.e(TAG,""String_Node_Str"");
  break;
}
if (proc.crashDialog != null) {
  Slog.e(TAG,""String_Node_Str"" + proc);
  return;
}
AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
if (!mSleeping && !mShuttingDown) {
  Dialog d=new StrictModeViolationDialog(mContext,res,proc);
  d.show();
  proc.crashDialog=d;
}
 else {
  res.set(0);
}
}
ensureBootCompleted();
}
break;
case SHOW_FACTORY_ERROR_MSG:
{
Dialog d=new FactoryErrorDialog(mContext,msg.getData().getCharSequence(""String_Node_Str""));
d.show();
ensureBootCompleted();
}
break;
case UPDATE_CONFIGURATION_MSG:
{
final ContentResolver resolver=mContext.getContentResolver();
Settings.System.putConfiguration(resolver,(Configuration)msg.obj);
}
break;
case GC_BACKGROUND_PROCESSES_MSG:
{
synchronized (ActivityManagerService.this) {
performAppGcsIfAppropriateLocked();
}
}
break;
case WAIT_FOR_DEBUGGER_MSG:
{
synchronized (ActivityManagerService.this) {
ProcessRecord app=(ProcessRecord)msg.obj;
if (msg.arg1 != 0) {
if (!app.waitedForDebugger) {
Dialog d=new AppWaitingForDebuggerDialog(ActivityManagerService.this,mContext,app);
app.waitDialog=d;
app.waitedForDebugger=true;
d.show();
}
}
 else {
if (app.waitDialog != null) {
app.waitDialog.dismiss();
app.waitDialog=null;
}
}
}
}
break;
case BROADCAST_INTENT_MSG:
{
if (DEBUG_BROADCAST) Slog.v(TAG,""String_Node_Str"");
processNextBroadcast(true);
}
break;
case BROADCAST_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG);
mHandler.sendMessageDelayed(nmsg,BROADCAST_TIMEOUT);
return;
}
if (mSystemReady) {
broadcastTimeout();
}
}
break;
case SERVICE_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,SERVICE_TIMEOUT);
return;
}
serviceTimeout((ProcessRecord)msg.obj);
}
break;
case UPDATE_TIME_ZONE:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.updateTimeZone();
}
 catch (RemoteException ex) {
Slog.w(TAG,""String_Node_Str"" + r.info.processName);
}
}
}
}
}
break;
case SHOW_UID_ERROR_MSG:
{
AlertDialog d=new BaseErrorDialog(mContext);
d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
d.setCancelable(false);
d.setTitle(""String_Node_Str"");
d.setMessage(""String_Node_Str"");
d.setButton(""String_Node_Str"",mHandler.obtainMessage(IM_FEELING_LUCKY_MSG));
mUidAlert=d;
d.show();
}
break;
case IM_FEELING_LUCKY_MSG:
{
if (mUidAlert != null) {
mUidAlert.dismiss();
mUidAlert=null;
}
}
break;
case PROC_START_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,PROC_START_TIMEOUT);
return;
}
ProcessRecord app=(ProcessRecord)msg.obj;
synchronized (ActivityManagerService.this) {
processStartTimedOutLocked(app);
}
}
break;
case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
{
synchronized (ActivityManagerService.this) {
doPendingActivityLaunchesLocked(true);
}
}
break;
case KILL_APPLICATION_MSG:
{
synchronized (ActivityManagerService.this) {
int uid=msg.arg1;
boolean restart=(msg.arg2 == 1);
String pkg=(String)msg.obj;
forceStopPackageLocked(pkg,uid,restart,false,true);
}
}
break;
case FINALIZE_PENDING_INTENT_MSG:
{
((PendingIntentRecord)msg.obj).completeFinalize();
}
break;
case POST_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
ActivityRecord root=(ActivityRecord)msg.obj;
ProcessRecord process=root.app;
if (process == null) {
return;
}
try {
Context context=mContext.createPackageContext(process.info.packageName,0);
String text=mContext.getString(R.string.heavy_weight_notification,context.getApplicationInfo().loadLabel(context.getPackageManager()));
Notification notification=new Notification();
notification.icon=com.android.internal.R.drawable.stat_sys_adb;
notification.when=0;
notification.flags=Notification.FLAG_ONGOING_EVENT;
notification.tickerText=text;
notification.defaults=0;
notification.sound=null;
notification.vibrate=null;
notification.setLatestEventInfo(context,text,mContext.getText(R.string.heavy_weight_notification_detail),PendingIntent.getActivity(mContext,0,root.intent,PendingIntent.FLAG_CANCEL_CURRENT));
try {
int[] outId=new int[1];
inm.enqueueNotification(""String_Node_Str"",R.string.heavy_weight_notification,notification,outId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
 catch (NameNotFoundException e) {
Slog.w(TAG,""String_Node_Str"",e);
}
}
break;
case CANCEL_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
try {
inm.cancelNotification(""String_Node_Str"",R.string.heavy_weight_notification);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
break;
case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
{
synchronized (ActivityManagerService.this) {
checkExcessiveWakeLocksLocked(true);
removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
if (mSleeping) {
Message nmsg=obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
sendMessageDelayed(nmsg,WAKE_LOCK_CHECK_DELAY);
}
}
}
break;
}
}"
22013,"private final String checkContentProviderPermissionLocked(ProviderInfo cpi,ProcessRecord r,int mode){
  final int callingPid=(r != null) ? r.pid : Binder.getCallingPid();
  final int callingUid=(r != null) ? r.info.uid : Binder.getCallingUid();
  if (checkComponentPermission(cpi.readPermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED && mode == ParcelFileDescriptor.MODE_READ_ONLY || mode == -1) {
    return null;
  }
  if (checkComponentPermission(cpi.writePermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
    return null;
  }
  PathPermission[] pps=cpi.pathPermissions;
  if (pps != null) {
    int i=pps.length;
    while (i > 0) {
      i--;
      PathPermission pp=pps[i];
      if (checkComponentPermission(pp.getReadPermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED && mode == ParcelFileDescriptor.MODE_READ_ONLY || mode == -1) {
        return null;
      }
      if (checkComponentPermission(pp.getWritePermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
        return null;
      }
    }
  }
  String msg=""String_Node_Str"" + cpi.name + ""String_Node_Str""+ (r != null ? r : ""String_Node_Str"")+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ cpi.readPermission+ ""String_Node_Str""+ cpi.writePermission;
  Slog.w(TAG,msg);
  return msg;
}","private final String checkContentProviderPermissionLocked(ProviderInfo cpi,ProcessRecord r){
  final int callingPid=(r != null) ? r.pid : Binder.getCallingPid();
  final int callingUid=(r != null) ? r.info.uid : Binder.getCallingUid();
  if (checkComponentPermission(cpi.readPermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
    return null;
  }
  if (checkComponentPermission(cpi.writePermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
    return null;
  }
  PathPermission[] pps=cpi.pathPermissions;
  if (pps != null) {
    int i=pps.length;
    while (i > 0) {
      i--;
      PathPermission pp=pps[i];
      if (checkComponentPermission(pp.getReadPermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
        return null;
      }
      if (checkComponentPermission(pp.getWritePermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
        return null;
      }
    }
  }
  HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.get(callingUid);
  if (perms != null) {
    for (    Map.Entry<Uri,UriPermission> uri : perms.entrySet()) {
      if (uri.getKey().getAuthority().equals(cpi.authority)) {
        return null;
      }
    }
  }
  String msg=""String_Node_Str"" + cpi.name + ""String_Node_Str""+ (r != null ? r : ""String_Node_Str"")+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ cpi.readPermission+ ""String_Node_Str""+ cpi.writePermission;
  Slog.w(TAG,msg);
  return msg;
}"
22014,"private final IContentProvider getProvider(Context context,String name){
synchronized (mProviderMap) {
    final ProviderClientRecord pr=mProviderMap.get(name);
    if (pr != null) {
      return pr.mProvider;
    }
  }
  IActivityManager.ContentProviderHolder holder=null;
  try {
    holder=ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(),name);
  }
 catch (  RemoteException ex) {
  }
  if (holder == null) {
    Slog.e(TAG,""String_Node_Str"" + name);
    return null;
  }
  if (holder.permissionFailure != null) {
    throw new SecurityException(""String_Node_Str"" + holder.permissionFailure + ""String_Node_Str""+ name);
  }
  IContentProvider prov=installProvider(context,holder.provider,holder.info,true);
  if (holder.noReleaseNeeded || holder.provider == null) {
synchronized (mProviderMap) {
      mProviderRefCountMap.put(prov.asBinder(),new ProviderRefCount(10000));
    }
  }
  return prov;
}","private final IContentProvider getProvider(Context context,String name){
synchronized (mProviderMap) {
    final ProviderClientRecord pr=mProviderMap.get(name);
    if (pr != null) {
      return pr.mProvider;
    }
  }
  IActivityManager.ContentProviderHolder holder=null;
  try {
    holder=ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(),name);
  }
 catch (  RemoteException ex) {
  }
  if (holder == null) {
    Slog.e(TAG,""String_Node_Str"" + name);
    return null;
  }
  IContentProvider prov=installProvider(context,holder.provider,holder.info,true);
  if (holder.noReleaseNeeded || holder.provider == null) {
synchronized (mProviderMap) {
      mProviderRefCountMap.put(prov.asBinder(),new ProviderRefCount(10000));
    }
  }
  return prov;
}"
22015,"private ContentProviderHolder(Parcel source){
  info=ProviderInfo.CREATOR.createFromParcel(source);
  permissionFailure=source.readString();
  provider=ContentProviderNative.asInterface(source.readStrongBinder());
  noReleaseNeeded=source.readInt() != 0;
}","private ContentProviderHolder(Parcel source){
  info=ProviderInfo.CREATOR.createFromParcel(source);
  provider=ContentProviderNative.asInterface(source.readStrongBinder());
  noReleaseNeeded=source.readInt() != 0;
}"
22016,"/** 
 * After being instantiated, this is called to tell the content provider about itself.
 * @param context The context this provider is running in
 * @param info Registered information about this content provider
 */
public void attachInfo(Context context,ProviderInfo info){
  if (mContext == null) {
    mContext=context;
    mMyUid=Process.myUid();
    if (info != null) {
      setReadPermission(info.readPermission);
      setWritePermission(info.writePermission);
      setPathPermissions(info.pathPermissions);
    }
    ContentProvider.this.onCreate();
  }
}","/** 
 * After being instantiated, this is called to tell the content provider about itself.
 * @param context The context this provider is running in
 * @param info Registered information about this content provider
 */
public void attachInfo(Context context,ProviderInfo info){
  if (mContext == null) {
    mContext=context;
    mMyUid=Process.myUid();
    if (info != null) {
      setReadPermission(info.readPermission);
      setWritePermission(info.writePermission);
      setPathPermissions(info.pathPermissions);
      mExported=info.exported;
    }
    ContentProvider.this.onCreate();
  }
}"
22017,"private void enforceReadPermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return;
  }
  final Context context=getContext();
  final String rperm=getReadPermission();
  final int pid=Binder.getCallingPid();
  if (rperm == null || context.checkPermission(rperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
    return;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String pprperm=pp.getReadPermission();
      if (pprperm != null && pp.match(path)) {
        if (context.checkPermission(pprperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_READ_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return;
  }
  String msg=""String_Node_Str"" + ContentProvider.this.getClass().getName() + ""String_Node_Str""+ uri+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ rperm;
  throw new SecurityException(msg);
}","private void enforceReadPermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return;
  }
  final Context context=getContext();
  final String rperm=getReadPermission();
  final int pid=Binder.getCallingPid();
  if (mExported && (rperm == null || context.checkPermission(rperm,pid,uid) == PackageManager.PERMISSION_GRANTED)) {
    return;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String pprperm=pp.getReadPermission();
      if (pprperm != null && pp.match(path)) {
        if (context.checkPermission(pprperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_READ_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return;
  }
  String msg=""String_Node_Str"" + ContentProvider.this.getClass().getName() + ""String_Node_Str""+ uri+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ rperm;
  throw new SecurityException(msg);
}"
22018,"private boolean hasWritePermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return true;
  }
  final Context context=getContext();
  final String wperm=getWritePermission();
  final int pid=Binder.getCallingPid();
  if (wperm == null || context.checkPermission(wperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
    return true;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String ppwperm=pp.getWritePermission();
      if (ppwperm != null && pp.match(path)) {
        if (context.checkPermission(ppwperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return true;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_WRITE_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return true;
  }
  return false;
}","private boolean hasWritePermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return true;
  }
  final Context context=getContext();
  final String wperm=getWritePermission();
  final int pid=Binder.getCallingPid();
  if (mExported && (wperm == null || context.checkPermission(wperm,pid,uid) == PackageManager.PERMISSION_GRANTED)) {
    return true;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String ppwperm=pp.getWritePermission();
      if (ppwperm != null && pp.match(path)) {
        if (context.checkPermission(ppwperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return true;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_WRITE_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return true;
  }
  return false;
}"
22019,"void grantUriPermissionFromIntentLocked(int callingUid,String targetPkg,Intent intent,ActivityRecord activity){
  if (intent == null) {
    return;
  }
  Uri data=intent.getData();
  if (data == null) {
    return;
  }
  grantUriPermissionLocked(callingUid,targetPkg,data,intent.getFlags(),activity);
}","void grantUriPermissionFromIntentLocked(int callingUid,String targetPkg,Intent intent,ActivityRecord activity){
  if (DEBUG_URI_PERMISSION)   Slog.v(TAG,""String_Node_Str"" + (intent != null ? intent.getData() : null) + ""String_Node_Str""+ intent+ ""String_Node_Str""+ Integer.toHexString(intent != null ? intent.getFlags() : 0));
  if (intent == null) {
    return;
  }
  Uri data=intent.getData();
  if (data == null) {
    return;
  }
  grantUriPermissionLocked(callingUid,targetPkg,data,intent.getFlags(),activity);
}"
22020,"public void handleApplicationStrictModeViolation(IBinder app,int violationMask,StrictMode.ViolationInfo info){
  ProcessRecord r=findAppProcess(app);
  if ((violationMask & StrictMode.PENALTY_DROPBOX) != 0) {
    Integer stackFingerprint=info.crashInfo.stackTrace.hashCode();
    boolean logIt=true;
synchronized (mAlreadyLoggedViolatedStacks) {
      if (mAlreadyLoggedViolatedStacks.contains(stackFingerprint)) {
        logIt=false;
      }
 else {
        if (mAlreadyLoggedViolatedStacks.size() >= MAX_DUP_SUPPRESSED_STACKS) {
          mAlreadyLoggedViolatedStacks.clear();
        }
        mAlreadyLoggedViolatedStacks.add(stackFingerprint);
      }
    }
    if (logIt) {
      logStrictModeViolationToDropBox(r,info);
    }
  }
  if ((violationMask & StrictMode.PENALTY_DIALOG) != 0) {
    AppErrorResult result=new AppErrorResult();
synchronized (this) {
      final long origId=Binder.clearCallingIdentity();
      Message msg=Message.obtain();
      msg.what=SHOW_STRICT_MODE_VIOLATION_MSG;
      HashMap<String,Object> data=new HashMap<String,Object>();
      data.put(""String_Node_Str"",result);
      data.put(""String_Node_Str"",r);
      data.put(""String_Node_Str"",violationMask);
      data.put(""String_Node_Str"",info);
      msg.obj=data;
      mHandler.sendMessage(msg);
      Binder.restoreCallingIdentity(origId);
    }
    int res=result.get();
    Log.w(TAG,""String_Node_Str"" + res);
  }
}","public void handleApplicationStrictModeViolation(IBinder app,int violationMask,StrictMode.ViolationInfo info){
  ProcessRecord r=findAppProcess(app);
  if ((violationMask & StrictMode.PENALTY_DROPBOX) != 0) {
    Integer stackFingerprint=info.crashInfo.stackTrace.hashCode();
    boolean logIt=true;
synchronized (mAlreadyLoggedViolatedStacks) {
      if (mAlreadyLoggedViolatedStacks.contains(stackFingerprint)) {
        logIt=false;
      }
 else {
        if (mAlreadyLoggedViolatedStacks.size() >= MAX_DUP_SUPPRESSED_STACKS) {
          mAlreadyLoggedViolatedStacks.clear();
        }
        mAlreadyLoggedViolatedStacks.add(stackFingerprint);
      }
    }
    if (logIt) {
      logStrictModeViolationToDropBox(r,info);
    }
  }
  if ((violationMask & StrictMode.PENALTY_DIALOG) != 0) {
    AppErrorResult result=new AppErrorResult();
synchronized (this) {
      final long origId=Binder.clearCallingIdentity();
      Message msg=Message.obtain();
      msg.what=SHOW_STRICT_MODE_VIOLATION_MSG;
      HashMap<String,Object> data=new HashMap<String,Object>();
      data.put(""String_Node_Str"",result);
      data.put(""String_Node_Str"",r);
      data.put(""String_Node_Str"",violationMask);
      data.put(""String_Node_Str"",info);
      msg.obj=data;
      mHandler.sendMessage(msg);
      Binder.restoreCallingIdentity(origId);
    }
    int res=result.get();
    Slog.w(TAG,""String_Node_Str"" + res);
  }
}"
22021,"private final boolean checkHoldingPermissionsLocked(IPackageManager pm,ProviderInfo pi,int uid,int modeFlags){
  try {
    if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
      if ((pi.readPermission != null) && (pm.checkUidPermission(pi.readPermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
      if ((pi.writePermission != null) && (pm.checkUidPermission(pi.writePermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    return true;
  }
 catch (  RemoteException e) {
    return false;
  }
}","private final boolean checkHoldingPermissionsLocked(IPackageManager pm,ProviderInfo pi,int uid,int modeFlags){
  try {
    if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
      if ((pi.readPermission != null) && (pm.checkUidPermission(pi.readPermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
      if ((pi.writePermission != null) && (pm.checkUidPermission(pi.writePermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    if (!pi.exported && pi.applicationInfo.uid != uid) {
      return false;
    }
    return true;
  }
 catch (  RemoteException e) {
    return false;
  }
}"
22022,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj <= PERCEPTIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=AppGlobals.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      String msg;
      if ((msg=checkContentProviderPermissionLocked(cpi,r)) != null) {
        throw new SecurityException(msg);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj <= PERCEPTIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=AppGlobals.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      String msg;
      if ((msg=checkContentProviderPermissionLocked(cpi,r)) != null) {
        throw new SecurityException(msg);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}"
22023,"public void handleMessage(Message msg){
switch (msg.what) {
case SHOW_ERROR_MSG:
{
      HashMap data=(HashMap)msg.obj;
synchronized (ActivityManagerService.this) {
        ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
        if (proc != null && proc.crashDialog != null) {
          Slog.e(TAG,""String_Node_Str"" + proc);
          return;
        }
        AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
        if (!mSleeping && !mShuttingDown) {
          Dialog d=new AppErrorDialog(mContext,res,proc);
          d.show();
          proc.crashDialog=d;
        }
 else {
          res.set(0);
        }
      }
      ensureBootCompleted();
    }
  break;
case SHOW_NOT_RESPONDING_MSG:
{
synchronized (ActivityManagerService.this) {
    HashMap data=(HashMap)msg.obj;
    ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
    if (proc != null && proc.anrDialog != null) {
      Slog.e(TAG,""String_Node_Str"" + proc);
      return;
    }
    broadcastIntentLocked(null,null,new Intent(""String_Node_Str""),null,null,0,null,null,null,false,false,MY_PID,Process.SYSTEM_UID);
    Dialog d=new AppNotRespondingDialog(ActivityManagerService.this,mContext,proc,(ActivityRecord)data.get(""String_Node_Str""));
    d.show();
    proc.anrDialog=d;
  }
  ensureBootCompleted();
}
break;
case SHOW_STRICT_MODE_VIOLATION_MSG:
{
HashMap<String,Object> data=(HashMap<String,Object>)msg.obj;
synchronized (ActivityManagerService.this) {
ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
if (proc == null) {
  Slog.e(TAG,""String_Node_Str"");
  break;
}
if (proc.crashDialog != null) {
  Slog.e(TAG,""String_Node_Str"" + proc);
  return;
}
AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
if (!mSleeping && !mShuttingDown) {
  Dialog d=new StrictModeViolationDialog(mContext,res,proc);
  d.show();
  proc.crashDialog=d;
}
 else {
  res.set(0);
}
}
ensureBootCompleted();
}
break;
case SHOW_FACTORY_ERROR_MSG:
{
Dialog d=new FactoryErrorDialog(mContext,msg.getData().getCharSequence(""String_Node_Str""));
d.show();
ensureBootCompleted();
}
break;
case UPDATE_CONFIGURATION_MSG:
{
final ContentResolver resolver=mContext.getContentResolver();
Settings.System.putConfiguration(resolver,(Configuration)msg.obj);
}
break;
case GC_BACKGROUND_PROCESSES_MSG:
{
synchronized (ActivityManagerService.this) {
performAppGcsIfAppropriateLocked();
}
}
break;
case WAIT_FOR_DEBUGGER_MSG:
{
synchronized (ActivityManagerService.this) {
ProcessRecord app=(ProcessRecord)msg.obj;
if (msg.arg1 != 0) {
if (!app.waitedForDebugger) {
Dialog d=new AppWaitingForDebuggerDialog(ActivityManagerService.this,mContext,app);
app.waitDialog=d;
app.waitedForDebugger=true;
d.show();
}
}
 else {
if (app.waitDialog != null) {
app.waitDialog.dismiss();
app.waitDialog=null;
}
}
}
}
break;
case BROADCAST_INTENT_MSG:
{
if (DEBUG_BROADCAST) Slog.v(TAG,""String_Node_Str"");
processNextBroadcast(true);
}
break;
case BROADCAST_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG);
mHandler.sendMessageDelayed(nmsg,BROADCAST_TIMEOUT);
return;
}
if (mSystemReady) {
broadcastTimeout();
}
}
break;
case SERVICE_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,SERVICE_TIMEOUT);
return;
}
serviceTimeout((ProcessRecord)msg.obj);
}
break;
case UPDATE_TIME_ZONE:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.updateTimeZone();
}
 catch (RemoteException ex) {
Slog.w(TAG,""String_Node_Str"" + r.info.processName);
}
}
}
}
}
break;
case SHOW_UID_ERROR_MSG:
{
AlertDialog d=new BaseErrorDialog(mContext);
d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
d.setCancelable(false);
d.setTitle(""String_Node_Str"");
d.setMessage(""String_Node_Str"");
d.setButton(""String_Node_Str"",mHandler.obtainMessage(IM_FEELING_LUCKY_MSG));
mUidAlert=d;
d.show();
}
break;
case IM_FEELING_LUCKY_MSG:
{
if (mUidAlert != null) {
mUidAlert.dismiss();
mUidAlert=null;
}
}
break;
case PROC_START_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,PROC_START_TIMEOUT);
return;
}
ProcessRecord app=(ProcessRecord)msg.obj;
synchronized (ActivityManagerService.this) {
processStartTimedOutLocked(app);
}
}
break;
case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
{
synchronized (ActivityManagerService.this) {
doPendingActivityLaunchesLocked(true);
}
}
break;
case KILL_APPLICATION_MSG:
{
synchronized (ActivityManagerService.this) {
int uid=msg.arg1;
boolean restart=(msg.arg2 == 1);
String pkg=(String)msg.obj;
forceStopPackageLocked(pkg,uid,restart,false,true);
}
}
break;
case FINALIZE_PENDING_INTENT_MSG:
{
((PendingIntentRecord)msg.obj).completeFinalize();
}
break;
case POST_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
ActivityRecord root=(ActivityRecord)msg.obj;
ProcessRecord process=root.app;
if (process == null) {
return;
}
try {
Context context=mContext.createPackageContext(process.info.packageName,0);
String text=mContext.getString(R.string.heavy_weight_notification,context.getApplicationInfo().loadLabel(context.getPackageManager()));
Notification notification=new Notification();
notification.icon=com.android.internal.R.drawable.stat_sys_adb;
notification.when=0;
notification.flags=Notification.FLAG_ONGOING_EVENT;
notification.tickerText=text;
notification.defaults=0;
notification.sound=null;
notification.vibrate=null;
notification.setLatestEventInfo(context,text,mContext.getText(R.string.heavy_weight_notification_detail),PendingIntent.getActivity(mContext,0,root.intent,PendingIntent.FLAG_CANCEL_CURRENT));
try {
int[] outId=new int[1];
inm.enqueueNotification(""String_Node_Str"",R.string.heavy_weight_notification,notification,outId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
 catch (NameNotFoundException e) {
Log.w(TAG,""String_Node_Str"",e);
}
}
break;
case CANCEL_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
try {
inm.cancelNotification(""String_Node_Str"",R.string.heavy_weight_notification);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
break;
case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
{
synchronized (ActivityManagerService.this) {
checkExcessiveWakeLocksLocked(true);
removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
if (mSleeping) {
Message nmsg=obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
sendMessageDelayed(nmsg,WAKE_LOCK_CHECK_DELAY);
}
}
}
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case SHOW_ERROR_MSG:
{
      HashMap data=(HashMap)msg.obj;
synchronized (ActivityManagerService.this) {
        ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
        if (proc != null && proc.crashDialog != null) {
          Slog.e(TAG,""String_Node_Str"" + proc);
          return;
        }
        AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
        if (!mSleeping && !mShuttingDown) {
          Dialog d=new AppErrorDialog(mContext,res,proc);
          d.show();
          proc.crashDialog=d;
        }
 else {
          res.set(0);
        }
      }
      ensureBootCompleted();
    }
  break;
case SHOW_NOT_RESPONDING_MSG:
{
synchronized (ActivityManagerService.this) {
    HashMap data=(HashMap)msg.obj;
    ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
    if (proc != null && proc.anrDialog != null) {
      Slog.e(TAG,""String_Node_Str"" + proc);
      return;
    }
    broadcastIntentLocked(null,null,new Intent(""String_Node_Str""),null,null,0,null,null,null,false,false,MY_PID,Process.SYSTEM_UID);
    Dialog d=new AppNotRespondingDialog(ActivityManagerService.this,mContext,proc,(ActivityRecord)data.get(""String_Node_Str""));
    d.show();
    proc.anrDialog=d;
  }
  ensureBootCompleted();
}
break;
case SHOW_STRICT_MODE_VIOLATION_MSG:
{
HashMap<String,Object> data=(HashMap<String,Object>)msg.obj;
synchronized (ActivityManagerService.this) {
ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
if (proc == null) {
  Slog.e(TAG,""String_Node_Str"");
  break;
}
if (proc.crashDialog != null) {
  Slog.e(TAG,""String_Node_Str"" + proc);
  return;
}
AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
if (!mSleeping && !mShuttingDown) {
  Dialog d=new StrictModeViolationDialog(mContext,res,proc);
  d.show();
  proc.crashDialog=d;
}
 else {
  res.set(0);
}
}
ensureBootCompleted();
}
break;
case SHOW_FACTORY_ERROR_MSG:
{
Dialog d=new FactoryErrorDialog(mContext,msg.getData().getCharSequence(""String_Node_Str""));
d.show();
ensureBootCompleted();
}
break;
case UPDATE_CONFIGURATION_MSG:
{
final ContentResolver resolver=mContext.getContentResolver();
Settings.System.putConfiguration(resolver,(Configuration)msg.obj);
}
break;
case GC_BACKGROUND_PROCESSES_MSG:
{
synchronized (ActivityManagerService.this) {
performAppGcsIfAppropriateLocked();
}
}
break;
case WAIT_FOR_DEBUGGER_MSG:
{
synchronized (ActivityManagerService.this) {
ProcessRecord app=(ProcessRecord)msg.obj;
if (msg.arg1 != 0) {
if (!app.waitedForDebugger) {
Dialog d=new AppWaitingForDebuggerDialog(ActivityManagerService.this,mContext,app);
app.waitDialog=d;
app.waitedForDebugger=true;
d.show();
}
}
 else {
if (app.waitDialog != null) {
app.waitDialog.dismiss();
app.waitDialog=null;
}
}
}
}
break;
case BROADCAST_INTENT_MSG:
{
if (DEBUG_BROADCAST) Slog.v(TAG,""String_Node_Str"");
processNextBroadcast(true);
}
break;
case BROADCAST_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG);
mHandler.sendMessageDelayed(nmsg,BROADCAST_TIMEOUT);
return;
}
if (mSystemReady) {
broadcastTimeout();
}
}
break;
case SERVICE_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,SERVICE_TIMEOUT);
return;
}
serviceTimeout((ProcessRecord)msg.obj);
}
break;
case UPDATE_TIME_ZONE:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.updateTimeZone();
}
 catch (RemoteException ex) {
Slog.w(TAG,""String_Node_Str"" + r.info.processName);
}
}
}
}
}
break;
case SHOW_UID_ERROR_MSG:
{
AlertDialog d=new BaseErrorDialog(mContext);
d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
d.setCancelable(false);
d.setTitle(""String_Node_Str"");
d.setMessage(""String_Node_Str"");
d.setButton(""String_Node_Str"",mHandler.obtainMessage(IM_FEELING_LUCKY_MSG));
mUidAlert=d;
d.show();
}
break;
case IM_FEELING_LUCKY_MSG:
{
if (mUidAlert != null) {
mUidAlert.dismiss();
mUidAlert=null;
}
}
break;
case PROC_START_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,PROC_START_TIMEOUT);
return;
}
ProcessRecord app=(ProcessRecord)msg.obj;
synchronized (ActivityManagerService.this) {
processStartTimedOutLocked(app);
}
}
break;
case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
{
synchronized (ActivityManagerService.this) {
doPendingActivityLaunchesLocked(true);
}
}
break;
case KILL_APPLICATION_MSG:
{
synchronized (ActivityManagerService.this) {
int uid=msg.arg1;
boolean restart=(msg.arg2 == 1);
String pkg=(String)msg.obj;
forceStopPackageLocked(pkg,uid,restart,false,true);
}
}
break;
case FINALIZE_PENDING_INTENT_MSG:
{
((PendingIntentRecord)msg.obj).completeFinalize();
}
break;
case POST_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
ActivityRecord root=(ActivityRecord)msg.obj;
ProcessRecord process=root.app;
if (process == null) {
return;
}
try {
Context context=mContext.createPackageContext(process.info.packageName,0);
String text=mContext.getString(R.string.heavy_weight_notification,context.getApplicationInfo().loadLabel(context.getPackageManager()));
Notification notification=new Notification();
notification.icon=com.android.internal.R.drawable.stat_sys_adb;
notification.when=0;
notification.flags=Notification.FLAG_ONGOING_EVENT;
notification.tickerText=text;
notification.defaults=0;
notification.sound=null;
notification.vibrate=null;
notification.setLatestEventInfo(context,text,mContext.getText(R.string.heavy_weight_notification_detail),PendingIntent.getActivity(mContext,0,root.intent,PendingIntent.FLAG_CANCEL_CURRENT));
try {
int[] outId=new int[1];
inm.enqueueNotification(""String_Node_Str"",R.string.heavy_weight_notification,notification,outId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
 catch (NameNotFoundException e) {
Slog.w(TAG,""String_Node_Str"",e);
}
}
break;
case CANCEL_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
try {
inm.cancelNotification(""String_Node_Str"",R.string.heavy_weight_notification);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
break;
case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
{
synchronized (ActivityManagerService.this) {
checkExcessiveWakeLocksLocked(true);
removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
if (mSleeping) {
Message nmsg=obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
sendMessageDelayed(nmsg,WAKE_LOCK_CHECK_DELAY);
}
}
}
break;
}
}"
22024,"private final String checkContentProviderPermissionLocked(ProviderInfo cpi,ProcessRecord r,int mode){
  final int callingPid=(r != null) ? r.pid : Binder.getCallingPid();
  final int callingUid=(r != null) ? r.info.uid : Binder.getCallingUid();
  if (checkComponentPermission(cpi.readPermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED && mode == ParcelFileDescriptor.MODE_READ_ONLY || mode == -1) {
    return null;
  }
  if (checkComponentPermission(cpi.writePermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
    return null;
  }
  PathPermission[] pps=cpi.pathPermissions;
  if (pps != null) {
    int i=pps.length;
    while (i > 0) {
      i--;
      PathPermission pp=pps[i];
      if (checkComponentPermission(pp.getReadPermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED && mode == ParcelFileDescriptor.MODE_READ_ONLY || mode == -1) {
        return null;
      }
      if (checkComponentPermission(pp.getWritePermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
        return null;
      }
    }
  }
  String msg=""String_Node_Str"" + cpi.name + ""String_Node_Str""+ (r != null ? r : ""String_Node_Str"")+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ cpi.readPermission+ ""String_Node_Str""+ cpi.writePermission;
  Slog.w(TAG,msg);
  return msg;
}","private final String checkContentProviderPermissionLocked(ProviderInfo cpi,ProcessRecord r){
  final int callingPid=(r != null) ? r.pid : Binder.getCallingPid();
  final int callingUid=(r != null) ? r.info.uid : Binder.getCallingUid();
  if (checkComponentPermission(cpi.readPermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
    return null;
  }
  if (checkComponentPermission(cpi.writePermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
    return null;
  }
  PathPermission[] pps=cpi.pathPermissions;
  if (pps != null) {
    int i=pps.length;
    while (i > 0) {
      i--;
      PathPermission pp=pps[i];
      if (checkComponentPermission(pp.getReadPermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
        return null;
      }
      if (checkComponentPermission(pp.getWritePermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
        return null;
      }
    }
  }
  HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.get(callingUid);
  if (perms != null) {
    for (    Map.Entry<Uri,UriPermission> uri : perms.entrySet()) {
      if (uri.getKey().getAuthority().equals(cpi.authority)) {
        return null;
      }
    }
  }
  String msg=""String_Node_Str"" + cpi.name + ""String_Node_Str""+ (r != null ? r : ""String_Node_Str"")+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ cpi.readPermission+ ""String_Node_Str""+ cpi.writePermission;
  Slog.w(TAG,msg);
  return msg;
}"
22025,"/** 
 * Retrieves the compelete voice mail number.
 * @hide
 */
public String getCompleteVoiceMailNumber(){
  mContext.enforceCallingOrSelfPermission(CALL_PRIVILEGED,""String_Node_Str"");
  String number=mPhone.getVoiceMailNumber();
  Log.d(LOG_TAG,""String_Node_Str"");
  return number;
}","/** 
 * Retrieves the complete voice mail number.
 * @hide
 */
public String getCompleteVoiceMailNumber(){
  mContext.enforceCallingOrSelfPermission(CALL_PRIVILEGED,""String_Node_Str"");
  String number=mPhone.getVoiceMailNumber();
  Log.d(LOG_TAG,""String_Node_Str"");
  return number;
}"
22026,"/** 
 * response.obj.result is an String[14] See ril.h for details Please note that registration state 4 (""unknown"") is treated as ""out of service"" above
 */
public void getRegistrationState(Message result){
  String ret[]=new String[14];
  ret[0]=""String_Node_Str"";
  ret[1]=null;
  ret[2]=null;
  ret[3]=null;
  ret[4]=null;
  ret[5]=null;
  ret[6]=null;
  ret[7]=null;
  ret[8]=null;
  ret[9]=null;
  ret[10]=null;
  ret[11]=null;
  ret[12]=null;
  ret[13]=null;
  ret[14]=null;
  resultSuccess(result,ret);
}","/** 
 * response.obj.result is an String[14] See ril.h for details Please note that registration state 4 (""unknown"") is treated as ""out of service"" above
 */
public void getRegistrationState(Message result){
  String ret[]=new String[14];
  ret[0]=""String_Node_Str"";
  ret[1]=null;
  ret[2]=null;
  ret[3]=null;
  ret[4]=null;
  ret[5]=null;
  ret[6]=null;
  ret[7]=null;
  ret[8]=null;
  ret[9]=null;
  ret[10]=null;
  ret[11]=null;
  ret[12]=null;
  ret[13]=null;
  resultSuccess(result,ret);
}"
22027,"public void dump(Printer pw,String prefix){
  pw.println(prefix + this);
  pw.println(prefix + ""String_Node_Str"" + mRun);
  pw.println(prefix + ""String_Node_Str"" + mThread);
  pw.println(prefix + ""String_Node_Str"" + ((mQueue != null) ? mQueue : ""String_Node_Str""));
  if (mQueue != null) {
synchronized (mQueue) {
      Message msg=mQueue.mMessages;
      int n=0;
      while (msg != null) {
        pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str""+ msg);
        n++;
        msg=msg.next;
      }
      pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str"");
    }
  }
}","public void dump(Printer pw,String prefix){
  pw.println(prefix + this);
  pw.println(prefix + ""String_Node_Str"" + mRun);
  pw.println(prefix + ""String_Node_Str"" + mThread);
  pw.println(prefix + ""String_Node_Str"" + ((mQueue != null) ? mQueue : ""String_Node_Str""));
  if (mQueue != null) {
synchronized (mQueue) {
      long now=SystemClock.uptimeMillis();
      Message msg=mQueue.mMessages;
      int n=0;
      while (msg != null) {
        pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str""+ msg.toString(now));
        n++;
        msg=msg.next;
      }
      pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str"");
    }
  }
}"
22028,"public String toString(){
  StringBuilder b=new StringBuilder();
  b.append(""String_Node_Str"");
  b.append(what);
  b.append(""String_Node_Str"");
  b.append(when);
  if (arg1 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg1);
  }
  if (arg2 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg2);
  }
  if (obj != null) {
    b.append(""String_Node_Str"");
    b.append(obj);
  }
  b.append(""String_Node_Str"");
  return b.toString();
}","String toString(long now){
  StringBuilder b=new StringBuilder();
  b.append(""String_Node_Str"");
  b.append(what);
  b.append(""String_Node_Str"");
  TimeUtils.formatDuration(when - now,b);
  if (arg1 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg1);
  }
  if (arg2 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg2);
  }
  if (obj != null) {
    b.append(""String_Node_Str"");
    b.append(obj);
  }
  b.append(""String_Node_Str"");
  return b.toString();
}"
22029,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageView content=new ImageView(this);
  content.setImageResource(com.android.internal.R.drawable.platlogo);
  content.setScaleType(ImageView.ScaleType.FIT_CENTER);
  setContentView(content);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mToast=Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT);
  ImageView content=new ImageView(this);
  content.setImageResource(com.android.internal.R.drawable.platlogo);
  content.setScaleType(ImageView.ScaleType.FIT_CENTER);
  setContentView(content);
}"
22030,"public void noteScreenOnLocked(){
  if (!mScreenOn) {
    mHistoryCur.states|=HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=true;
    mScreenOnTimer.startRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].startRunningLocked(this);
    }
    noteStartWakeLocked(-1,-1,""String_Node_Str"",0);
  }
}","public void noteScreenOnLocked(){
  if (!mScreenOn) {
    mHistoryCur.states|=HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=true;
    mScreenOnTimer.startRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].startRunningLocked(this);
    }
    noteStartWakeLocked(-1,-1,""String_Node_Str"",WAKE_TYPE_PARTIAL);
  }
}"
22031,"public void noteStartWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.startRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0) {
    Pid p=getPidStatsLocked(pid);
    p.mWakeStart=SystemClock.elapsedRealtime();
  }
}","public void noteStartWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.startRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0 && type == WAKE_TYPE_PARTIAL) {
    Pid p=getPidStatsLocked(pid);
    p.mWakeStart=SystemClock.elapsedRealtime();
  }
}"
22032,"public void noteStopWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.stopRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0) {
    Pid p=mPids.get(pid);
    if (p != null) {
      p.mWakeSum+=SystemClock.elapsedRealtime() - p.mWakeStart;
      p.mWakeStart=0;
    }
  }
}","public void noteStopWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.stopRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0 && type == WAKE_TYPE_PARTIAL) {
    Pid p=mPids.get(pid);
    if (p != null) {
      p.mWakeSum+=SystemClock.elapsedRealtime() - p.mWakeStart;
      p.mWakeStart=0;
    }
  }
}"
22033,"public void noteScreenOffLocked(){
  if (mScreenOn) {
    mHistoryCur.states&=~HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=false;
    mScreenOnTimer.stopRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].stopRunningLocked(this);
    }
    noteStopWakeLocked(-1,-1,""String_Node_Str"",0);
  }
}","public void noteScreenOffLocked(){
  if (mScreenOn) {
    mHistoryCur.states&=~HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=false;
    mScreenOnTimer.stopRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].stopRunningLocked(this);
    }
    noteStopWakeLocked(-1,-1,""String_Node_Str"",WAKE_TYPE_PARTIAL);
  }
}"
22034,"/** 
 * Puts the device to speaker mode. 
 */
void setSpeakerMode();","/** 
 * Puts the device to speaker mode. 
 */
void setSpeakerMode(boolean speakerMode);"
22035,"private void stopCall(boolean releaseSocket){
  Log.d(TAG,""String_Node_Str"");
  if (mRtpSession != null) {
    mRtpSession.join(null);
    if (releaseSocket) {
      mRtpSession.release();
      mRtpSession=null;
    }
  }
  setInCallMode();
}","private void stopCall(boolean releaseSocket){
  Log.d(TAG,""String_Node_Str"");
  if (mRtpSession != null) {
    mRtpSession.join(null);
    if (releaseSocket) {
      mRtpSession.release();
      mRtpSession=null;
    }
  }
}"
22036,"public synchronized void setSpeakerMode(){
  ((AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE)).setSpeakerphoneOn(true);
}","public synchronized void setSpeakerMode(boolean speakerMode){
  ((AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE)).setSpeakerphoneOn(speakerMode);
}"
22037,"private void startCall(SdpSessionDescription peerSd){
  stopCall(DONT_RELEASE_SOCKET);
  mPeerSd=peerSd;
  String peerMediaAddress=peerSd.getPeerMediaAddress(AUDIO);
  int peerMediaPort=peerSd.getPeerMediaPort(AUDIO);
  Log.i(TAG,""String_Node_Str"" + peerMediaAddress + ""String_Node_Str""+ peerMediaPort);
  int localPort=getLocalMediaPort();
  int sampleRate=8000;
  int frameSize=sampleRate / 50;
  try {
    mCodec=getCodec(peerSd);
    AudioStream audioStream=mRtpSession;
    audioStream.associate(InetAddress.getByName(peerMediaAddress),peerMediaPort);
    audioStream.setCodec(convert(mCodec),mCodec.payloadType);
    audioStream.setDtmfType(DTMF);
    Log.d(TAG,""String_Node_Str"" + localPort + ""String_Node_Str""+ peerMediaAddress+ ""String_Node_Str""+ peerMediaPort);
    audioStream.setMode(RtpStream.MODE_NORMAL);
    if (!mHold) {
      if (!peerSd.isSending(AUDIO)) {
        Log.d(TAG,""String_Node_Str"");
        audioStream.setMode(RtpStream.MODE_SEND_ONLY);
      }
      if (!peerSd.isReceiving(AUDIO)) {
        Log.d(TAG,""String_Node_Str"");
        audioStream.setMode(RtpStream.MODE_RECEIVE_ONLY);
      }
    }
    setInCallMode();
    AudioGroup audioGroup=new AudioGroup();
    audioStream.join(audioGroup);
    if (mHold) {
      audioGroup.setMode(AudioGroup.MODE_ON_HOLD);
    }
 else     if (mMuted) {
      audioGroup.setMode(AudioGroup.MODE_MUTED);
    }
 else {
      audioGroup.setMode(AudioGroup.MODE_NORMAL);
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","private void startCall(SdpSessionDescription peerSd){
  stopCall(DONT_RELEASE_SOCKET);
  mPeerSd=peerSd;
  String peerMediaAddress=peerSd.getPeerMediaAddress(AUDIO);
  int peerMediaPort=peerSd.getPeerMediaPort(AUDIO);
  Log.i(TAG,""String_Node_Str"" + peerMediaAddress + ""String_Node_Str""+ peerMediaPort);
  int localPort=getLocalMediaPort();
  int sampleRate=8000;
  int frameSize=sampleRate / 50;
  try {
    mCodec=getCodec(peerSd);
    AudioStream audioStream=mRtpSession;
    audioStream.associate(InetAddress.getByName(peerMediaAddress),peerMediaPort);
    audioStream.setCodec(convert(mCodec),mCodec.payloadType);
    audioStream.setDtmfType(DTMF);
    Log.d(TAG,""String_Node_Str"" + localPort + ""String_Node_Str""+ peerMediaAddress+ ""String_Node_Str""+ peerMediaPort);
    audioStream.setMode(RtpStream.MODE_NORMAL);
    if (!mHold) {
      if (!peerSd.isSending(AUDIO)) {
        Log.d(TAG,""String_Node_Str"");
        audioStream.setMode(RtpStream.MODE_SEND_ONLY);
      }
      if (!peerSd.isReceiving(AUDIO)) {
        Log.d(TAG,""String_Node_Str"");
        audioStream.setMode(RtpStream.MODE_RECEIVE_ONLY);
      }
    }
 else {
      ((AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE)).setMode(AudioManager.MODE_NORMAL);
    }
    AudioGroup audioGroup=new AudioGroup();
    audioStream.join(audioGroup);
    if (mHold) {
      audioGroup.setMode(AudioGroup.MODE_ON_HOLD);
    }
 else     if (mMuted) {
      audioGroup.setMode(AudioGroup.MODE_MUTED);
    }
 else {
      audioGroup.setMode(AudioGroup.MODE_NORMAL);
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
22038,"public void dump(Printer pw,String prefix){
  pw.println(prefix + this);
  pw.println(prefix + ""String_Node_Str"" + mRun);
  pw.println(prefix + ""String_Node_Str"" + mThread);
  pw.println(prefix + ""String_Node_Str"" + ((mQueue != null) ? mQueue : ""String_Node_Str""));
  if (mQueue != null) {
synchronized (mQueue) {
      Message msg=mQueue.mMessages;
      int n=0;
      while (msg != null) {
        pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str""+ msg);
        n++;
        msg=msg.next;
      }
      pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str"");
    }
  }
}","public void dump(Printer pw,String prefix){
  pw.println(prefix + this);
  pw.println(prefix + ""String_Node_Str"" + mRun);
  pw.println(prefix + ""String_Node_Str"" + mThread);
  pw.println(prefix + ""String_Node_Str"" + ((mQueue != null) ? mQueue : ""String_Node_Str""));
  if (mQueue != null) {
synchronized (mQueue) {
      long now=SystemClock.uptimeMillis();
      Message msg=mQueue.mMessages;
      int n=0;
      while (msg != null) {
        pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str""+ msg.toString(now));
        n++;
        msg=msg.next;
      }
      pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str"");
    }
  }
}"
22039,"public String toString(){
  StringBuilder b=new StringBuilder();
  b.append(""String_Node_Str"");
  b.append(what);
  b.append(""String_Node_Str"");
  b.append(when);
  if (arg1 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg1);
  }
  if (arg2 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg2);
  }
  if (obj != null) {
    b.append(""String_Node_Str"");
    b.append(obj);
  }
  b.append(""String_Node_Str"");
  return b.toString();
}","String toString(long now){
  StringBuilder b=new StringBuilder();
  b.append(""String_Node_Str"");
  b.append(what);
  b.append(""String_Node_Str"");
  TimeUtils.formatDuration(when - now,b);
  if (arg1 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg1);
  }
  if (arg2 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg2);
  }
  if (obj != null) {
    b.append(""String_Node_Str"");
    b.append(obj);
  }
  b.append(""String_Node_Str"");
  return b.toString();
}"
22040,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageView content=new ImageView(this);
  content.setImageResource(com.android.internal.R.drawable.platlogo);
  content.setScaleType(ImageView.ScaleType.FIT_CENTER);
  setContentView(content);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mToast=Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT);
  ImageView content=new ImageView(this);
  content.setImageResource(com.android.internal.R.drawable.platlogo);
  content.setScaleType(ImageView.ScaleType.FIT_CENTER);
  setContentView(content);
}"
22041,"public void noteScreenOnLocked(){
  if (!mScreenOn) {
    mHistoryCur.states|=HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=true;
    mScreenOnTimer.startRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].startRunningLocked(this);
    }
    noteStartWakeLocked(-1,-1,""String_Node_Str"",0);
  }
}","public void noteScreenOnLocked(){
  if (!mScreenOn) {
    mHistoryCur.states|=HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=true;
    mScreenOnTimer.startRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].startRunningLocked(this);
    }
    noteStartWakeLocked(-1,-1,""String_Node_Str"",WAKE_TYPE_PARTIAL);
  }
}"
22042,"public void noteStartWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.startRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0) {
    Pid p=getPidStatsLocked(pid);
    p.mWakeStart=SystemClock.elapsedRealtime();
  }
}","public void noteStartWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.startRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0 && type == WAKE_TYPE_PARTIAL) {
    Pid p=getPidStatsLocked(pid);
    p.mWakeStart=SystemClock.elapsedRealtime();
  }
}"
22043,"public void noteStopWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.stopRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0) {
    Pid p=mPids.get(pid);
    if (p != null) {
      p.mWakeSum+=SystemClock.elapsedRealtime() - p.mWakeStart;
      p.mWakeStart=0;
    }
  }
}","public void noteStopWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.stopRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0 && type == WAKE_TYPE_PARTIAL) {
    Pid p=mPids.get(pid);
    if (p != null) {
      p.mWakeSum+=SystemClock.elapsedRealtime() - p.mWakeStart;
      p.mWakeStart=0;
    }
  }
}"
22044,"public void noteScreenOffLocked(){
  if (mScreenOn) {
    mHistoryCur.states&=~HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=false;
    mScreenOnTimer.stopRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].stopRunningLocked(this);
    }
    noteStopWakeLocked(-1,-1,""String_Node_Str"",0);
  }
}","public void noteScreenOffLocked(){
  if (mScreenOn) {
    mHistoryCur.states&=~HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=false;
    mScreenOnTimer.stopRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].stopRunningLocked(this);
    }
    noteStopWakeLocked(-1,-1,""String_Node_Str"",WAKE_TYPE_PARTIAL);
  }
}"
22045,"/** 
 * Get an SMS-SUBMIT PDU for a data message to a destination address &amp; port
 * @param destAddr the address of the destination for the message
 * @param userDara the data for the message
 * @param statusReportRequested Indicates whether a report is requested for this message.
 * @return a <code>SubmitPdu</code> containing the encoded SCaddress, if applicable, and the encoded message. Returns null on encode error.
 */
public static SubmitPdu getSubmitPdu(String destAddr,UserData userData,boolean statusReportRequested){
  return privateGetSubmitPdu(destAddr,statusReportRequested,userData);
}","/** 
 * Get an SMS-SUBMIT PDU for a data message to a destination address &amp; port
 * @param destAddr the address of the destination for the message
 * @param userData the data for the message
 * @param statusReportRequested Indicates whether a report is requested for this message.
 * @return a <code>SubmitPdu</code> containing the encoded SCaddress, if applicable, and the encoded message. Returns null on encode error.
 */
public static SubmitPdu getSubmitPdu(String destAddr,UserData userData,boolean statusReportRequested){
  return privateGetSubmitPdu(destAddr,statusReportRequested,userData);
}"
22046,"/** 
 * Calculate the number of septets needed to encode the message.
 * @param messageBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence messageBody,boolean use7bitOnly){
  return BearerData.calcTextEncodingDetails(messageBody.toString(),use7bitOnly);
}","/** 
 * Calculate the number of septets needed to encode the message.
 * @param messageBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence messageBody,boolean use7bitOnly){
  return BearerData.calcTextEncodingDetails(messageBody,use7bitOnly);
}"
22047,"/** 
 * Create serialized representation for BearerData object. (See 3GPP2 C.R1001-F, v1.0, section 4.5 for layout details)
 * @param bearerData an instance of BearerData.
 * @return data byta array of raw encoded SMS bearer data.
 */
public static byte[] encode(BearerData bData){
  bData.hasUserDataHeader=((bData.userData != null) && (bData.userData.userDataHeader != null));
  try {
    BitwiseOutputStream outStream=new BitwiseOutputStream(200);
    outStream.write(8,SUBPARAM_MESSAGE_IDENTIFIER);
    encodeMessageId(bData,outStream);
    if (bData.userData != null) {
      outStream.write(8,SUBPARAM_USER_DATA);
      encodeUserData(bData,outStream);
    }
    if (bData.callbackNumber != null) {
      outStream.write(8,SUBPARAM_CALLBACK_NUMBER);
      encodeCallbackNumber(bData,outStream);
    }
    if (bData.userAckReq || bData.deliveryAckReq || bData.readAckReq|| bData.reportReq) {
      outStream.write(8,SUBPARAM_REPLY_OPTION);
      encodeReplyOption(bData,outStream);
    }
    if (bData.numberOfMessages != 0) {
      outStream.write(8,SUBPARAM_NUMBER_OF_MESSAGES);
      encodeMsgCount(bData,outStream);
    }
    if (bData.validityPeriodRelativeSet) {
      outStream.write(8,SUBPARAM_VALIDITY_PERIOD_RELATIVE);
      encodeValidityPeriodRel(bData,outStream);
    }
    if (bData.privacyIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIVACY_INDICATOR);
      encodePrivacyIndicator(bData,outStream);
    }
    if (bData.languageIndicatorSet) {
      outStream.write(8,SUBPARAM_LANGUAGE_INDICATOR);
      encodeLanguageIndicator(bData,outStream);
    }
    if (bData.displayModeSet) {
      outStream.write(8,SUBPARAM_MESSAGE_DISPLAY_MODE);
      encodeDisplayMode(bData,outStream);
    }
    if (bData.priorityIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIORITY_INDICATOR);
      encodePriorityIndicator(bData,outStream);
    }
    if (bData.alertIndicatorSet) {
      outStream.write(8,SUBPARAM_ALERT_ON_MESSAGE_DELIVERY);
      encodeMsgDeliveryAlert(bData,outStream);
    }
    if (bData.messageStatusSet) {
      outStream.write(8,SUBPARAM_MESSAGE_STATUS);
      encodeMsgStatus(bData,outStream);
    }
    return outStream.toByteArray();
  }
 catch (  BitwiseOutputStream.AccessException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
catch (  CodingException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
  return null;
}","/** 
 * Create serialized representation for BearerData object. (See 3GPP2 C.R1001-F, v1.0, section 4.5 for layout details)
 * @param bData an instance of BearerData.
 * @return byte array of raw encoded SMS bearer data.
 */
public static byte[] encode(BearerData bData){
  bData.hasUserDataHeader=((bData.userData != null) && (bData.userData.userDataHeader != null));
  try {
    BitwiseOutputStream outStream=new BitwiseOutputStream(200);
    outStream.write(8,SUBPARAM_MESSAGE_IDENTIFIER);
    encodeMessageId(bData,outStream);
    if (bData.userData != null) {
      outStream.write(8,SUBPARAM_USER_DATA);
      encodeUserData(bData,outStream);
    }
    if (bData.callbackNumber != null) {
      outStream.write(8,SUBPARAM_CALLBACK_NUMBER);
      encodeCallbackNumber(bData,outStream);
    }
    if (bData.userAckReq || bData.deliveryAckReq || bData.readAckReq|| bData.reportReq) {
      outStream.write(8,SUBPARAM_REPLY_OPTION);
      encodeReplyOption(bData,outStream);
    }
    if (bData.numberOfMessages != 0) {
      outStream.write(8,SUBPARAM_NUMBER_OF_MESSAGES);
      encodeMsgCount(bData,outStream);
    }
    if (bData.validityPeriodRelativeSet) {
      outStream.write(8,SUBPARAM_VALIDITY_PERIOD_RELATIVE);
      encodeValidityPeriodRel(bData,outStream);
    }
    if (bData.privacyIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIVACY_INDICATOR);
      encodePrivacyIndicator(bData,outStream);
    }
    if (bData.languageIndicatorSet) {
      outStream.write(8,SUBPARAM_LANGUAGE_INDICATOR);
      encodeLanguageIndicator(bData,outStream);
    }
    if (bData.displayModeSet) {
      outStream.write(8,SUBPARAM_MESSAGE_DISPLAY_MODE);
      encodeDisplayMode(bData,outStream);
    }
    if (bData.priorityIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIORITY_INDICATOR);
      encodePriorityIndicator(bData,outStream);
    }
    if (bData.alertIndicatorSet) {
      outStream.write(8,SUBPARAM_ALERT_ON_MESSAGE_DELIVERY);
      encodeMsgDeliveryAlert(bData,outStream);
    }
    if (bData.messageStatusSet) {
      outStream.write(8,SUBPARAM_MESSAGE_STATUS);
      encodeMsgStatus(bData,outStream);
    }
    return outStream.toByteArray();
  }
 catch (  BitwiseOutputStream.AccessException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
catch (  CodingException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
  return null;
}"
22048,"/** 
 * Calculate the message text encoding length, fragmentation, and other details.
 * @param force ignore (but still count) illegal characters if true
 * @return septet count, or -1 on failure
 */
public static TextEncodingDetails calcTextEncodingDetails(CharSequence msg,boolean force7BitEncoding){
  TextEncodingDetails ted;
  int septets=countAsciiSeptets(msg,force7BitEncoding);
  if (septets != -1 && septets <= SmsMessage.MAX_USER_DATA_SEPTETS) {
    ted=new TextEncodingDetails();
    ted.msgCount=1;
    ted.codeUnitCount=septets;
    ted.codeUnitsRemaining=SmsMessage.MAX_USER_DATA_SEPTETS - septets;
    ted.codeUnitSize=SmsMessage.ENCODING_7BIT;
  }
 else {
    ted=com.android.internal.telephony.gsm.SmsMessage.calculateLength(msg,force7BitEncoding);
    if (ted.msgCount == 1 && ted.codeUnitSize == SmsMessage.ENCODING_7BIT) {
      ted.codeUnitCount=msg.length();
      int octets=ted.codeUnitCount * 2;
      if (octets > MAX_USER_DATA_BYTES) {
        ted.msgCount=(octets / MAX_USER_DATA_BYTES_WITH_HEADER) + 1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES_WITH_HEADER - (octets % MAX_USER_DATA_BYTES_WITH_HEADER)) / 2;
      }
 else {
        ted.msgCount=1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
      }
      ted.codeUnitSize=ENCODING_16BIT;
    }
  }
  return ted;
}","/** 
 * Calculate the message text encoding length, fragmentation, and other details.
 * @param msg message text
 * @param force7BitEncoding ignore (but still count) illegal characters if true
 * @return septet count, or -1 on failure
 */
public static TextEncodingDetails calcTextEncodingDetails(CharSequence msg,boolean force7BitEncoding){
  TextEncodingDetails ted;
  int septets=countAsciiSeptets(msg,force7BitEncoding);
  if (septets != -1 && septets <= SmsMessage.MAX_USER_DATA_SEPTETS) {
    ted=new TextEncodingDetails();
    ted.msgCount=1;
    ted.codeUnitCount=septets;
    ted.codeUnitsRemaining=SmsMessage.MAX_USER_DATA_SEPTETS - septets;
    ted.codeUnitSize=SmsMessage.ENCODING_7BIT;
  }
 else {
    ted=com.android.internal.telephony.gsm.SmsMessage.calculateLength(msg,force7BitEncoding);
    if (ted.msgCount == 1 && ted.codeUnitSize == SmsMessage.ENCODING_7BIT) {
      ted.codeUnitCount=msg.length();
      int octets=ted.codeUnitCount * 2;
      if (octets > MAX_USER_DATA_BYTES) {
        ted.msgCount=(octets + (MAX_USER_DATA_BYTES_WITH_HEADER - 1)) / MAX_USER_DATA_BYTES_WITH_HEADER;
        ted.codeUnitsRemaining=((ted.msgCount * MAX_USER_DATA_BYTES_WITH_HEADER) - octets) / 2;
      }
 else {
        ted.msgCount=1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
      }
      ted.codeUnitSize=ENCODING_16BIT;
    }
  }
  return ted;
}"
22049,"/** 
 * Calculate the number of septets needed to encode the message.
 * @param msgBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence msgBody,boolean use7bitOnly){
  TextEncodingDetails ted=new TextEncodingDetails();
  try {
    int septets=GsmAlphabet.countGsmSeptets(msgBody,!use7bitOnly);
    ted.codeUnitCount=septets;
    if (septets > MAX_USER_DATA_SEPTETS) {
      ted.msgCount=(septets / MAX_USER_DATA_SEPTETS_WITH_HEADER) + 1;
      ted.codeUnitsRemaining=MAX_USER_DATA_SEPTETS_WITH_HEADER - (septets % MAX_USER_DATA_SEPTETS_WITH_HEADER);
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=MAX_USER_DATA_SEPTETS - septets;
    }
    ted.codeUnitSize=ENCODING_7BIT;
  }
 catch (  EncodeException ex) {
    int octets=msgBody.length() * 2;
    ted.codeUnitCount=msgBody.length();
    if (octets > MAX_USER_DATA_BYTES) {
      ted.msgCount=(octets / MAX_USER_DATA_BYTES_WITH_HEADER) + 1;
      ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES_WITH_HEADER - (octets % MAX_USER_DATA_BYTES_WITH_HEADER)) / 2;
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
    }
    ted.codeUnitSize=ENCODING_16BIT;
  }
  return ted;
}","/** 
 * Calculate the number of septets needed to encode the message.
 * @param msgBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence msgBody,boolean use7bitOnly){
  TextEncodingDetails ted=new TextEncodingDetails();
  try {
    int septets=GsmAlphabet.countGsmSeptets(msgBody,!use7bitOnly);
    ted.codeUnitCount=septets;
    if (septets > MAX_USER_DATA_SEPTETS) {
      ted.msgCount=(septets + (MAX_USER_DATA_SEPTETS_WITH_HEADER - 1)) / MAX_USER_DATA_SEPTETS_WITH_HEADER;
      ted.codeUnitsRemaining=(ted.msgCount * MAX_USER_DATA_SEPTETS_WITH_HEADER) - septets;
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=MAX_USER_DATA_SEPTETS - septets;
    }
    ted.codeUnitSize=ENCODING_7BIT;
  }
 catch (  EncodeException ex) {
    int octets=msgBody.length() * 2;
    ted.codeUnitCount=msgBody.length();
    if (octets > MAX_USER_DATA_BYTES) {
      ted.msgCount=(octets + (MAX_USER_DATA_BYTES_WITH_HEADER - 1)) / MAX_USER_DATA_BYTES_WITH_HEADER;
      ted.codeUnitsRemaining=((ted.msgCount * MAX_USER_DATA_BYTES_WITH_HEADER) - octets) / 2;
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
    }
    ted.codeUnitSize=ENCODING_16BIT;
  }
  return ted;
}"
22050,"/** 
 * Get an SMS-SUBMIT PDU for a data message to a destination address &amp; port
 * @param destAddr the address of the destination for the message
 * @param userDara the data for the message
 * @param statusReportRequested Indicates whether a report is requested for this message.
 * @return a <code>SubmitPdu</code> containing the encoded SCaddress, if applicable, and the encoded message. Returns null on encode error.
 */
public static SubmitPdu getSubmitPdu(String destAddr,UserData userData,boolean statusReportRequested){
  return privateGetSubmitPdu(destAddr,statusReportRequested,userData);
}","/** 
 * Get an SMS-SUBMIT PDU for a data message to a destination address &amp; port
 * @param destAddr the address of the destination for the message
 * @param userData the data for the message
 * @param statusReportRequested Indicates whether a report is requested for this message.
 * @return a <code>SubmitPdu</code> containing the encoded SCaddress, if applicable, and the encoded message. Returns null on encode error.
 */
public static SubmitPdu getSubmitPdu(String destAddr,UserData userData,boolean statusReportRequested){
  return privateGetSubmitPdu(destAddr,statusReportRequested,userData);
}"
22051,"/** 
 * Calculate the number of septets needed to encode the message.
 * @param messageBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence messageBody,boolean use7bitOnly){
  return BearerData.calcTextEncodingDetails(messageBody.toString(),use7bitOnly);
}","/** 
 * Calculate the number of septets needed to encode the message.
 * @param messageBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence messageBody,boolean use7bitOnly){
  return BearerData.calcTextEncodingDetails(messageBody,use7bitOnly);
}"
22052,"/** 
 * Create serialized representation for BearerData object. (See 3GPP2 C.R1001-F, v1.0, section 4.5 for layout details)
 * @param bearerData an instance of BearerData.
 * @return data byta array of raw encoded SMS bearer data.
 */
public static byte[] encode(BearerData bData){
  bData.hasUserDataHeader=((bData.userData != null) && (bData.userData.userDataHeader != null));
  try {
    BitwiseOutputStream outStream=new BitwiseOutputStream(200);
    outStream.write(8,SUBPARAM_MESSAGE_IDENTIFIER);
    encodeMessageId(bData,outStream);
    if (bData.userData != null) {
      outStream.write(8,SUBPARAM_USER_DATA);
      encodeUserData(bData,outStream);
    }
    if (bData.callbackNumber != null) {
      outStream.write(8,SUBPARAM_CALLBACK_NUMBER);
      encodeCallbackNumber(bData,outStream);
    }
    if (bData.userAckReq || bData.deliveryAckReq || bData.readAckReq|| bData.reportReq) {
      outStream.write(8,SUBPARAM_REPLY_OPTION);
      encodeReplyOption(bData,outStream);
    }
    if (bData.numberOfMessages != 0) {
      outStream.write(8,SUBPARAM_NUMBER_OF_MESSAGES);
      encodeMsgCount(bData,outStream);
    }
    if (bData.validityPeriodRelativeSet) {
      outStream.write(8,SUBPARAM_VALIDITY_PERIOD_RELATIVE);
      encodeValidityPeriodRel(bData,outStream);
    }
    if (bData.privacyIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIVACY_INDICATOR);
      encodePrivacyIndicator(bData,outStream);
    }
    if (bData.languageIndicatorSet) {
      outStream.write(8,SUBPARAM_LANGUAGE_INDICATOR);
      encodeLanguageIndicator(bData,outStream);
    }
    if (bData.displayModeSet) {
      outStream.write(8,SUBPARAM_MESSAGE_DISPLAY_MODE);
      encodeDisplayMode(bData,outStream);
    }
    if (bData.priorityIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIORITY_INDICATOR);
      encodePriorityIndicator(bData,outStream);
    }
    if (bData.alertIndicatorSet) {
      outStream.write(8,SUBPARAM_ALERT_ON_MESSAGE_DELIVERY);
      encodeMsgDeliveryAlert(bData,outStream);
    }
    if (bData.messageStatusSet) {
      outStream.write(8,SUBPARAM_MESSAGE_STATUS);
      encodeMsgStatus(bData,outStream);
    }
    return outStream.toByteArray();
  }
 catch (  BitwiseOutputStream.AccessException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
catch (  CodingException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
  return null;
}","/** 
 * Create serialized representation for BearerData object. (See 3GPP2 C.R1001-F, v1.0, section 4.5 for layout details)
 * @param bData an instance of BearerData.
 * @return byte array of raw encoded SMS bearer data.
 */
public static byte[] encode(BearerData bData){
  bData.hasUserDataHeader=((bData.userData != null) && (bData.userData.userDataHeader != null));
  try {
    BitwiseOutputStream outStream=new BitwiseOutputStream(200);
    outStream.write(8,SUBPARAM_MESSAGE_IDENTIFIER);
    encodeMessageId(bData,outStream);
    if (bData.userData != null) {
      outStream.write(8,SUBPARAM_USER_DATA);
      encodeUserData(bData,outStream);
    }
    if (bData.callbackNumber != null) {
      outStream.write(8,SUBPARAM_CALLBACK_NUMBER);
      encodeCallbackNumber(bData,outStream);
    }
    if (bData.userAckReq || bData.deliveryAckReq || bData.readAckReq|| bData.reportReq) {
      outStream.write(8,SUBPARAM_REPLY_OPTION);
      encodeReplyOption(bData,outStream);
    }
    if (bData.numberOfMessages != 0) {
      outStream.write(8,SUBPARAM_NUMBER_OF_MESSAGES);
      encodeMsgCount(bData,outStream);
    }
    if (bData.validityPeriodRelativeSet) {
      outStream.write(8,SUBPARAM_VALIDITY_PERIOD_RELATIVE);
      encodeValidityPeriodRel(bData,outStream);
    }
    if (bData.privacyIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIVACY_INDICATOR);
      encodePrivacyIndicator(bData,outStream);
    }
    if (bData.languageIndicatorSet) {
      outStream.write(8,SUBPARAM_LANGUAGE_INDICATOR);
      encodeLanguageIndicator(bData,outStream);
    }
    if (bData.displayModeSet) {
      outStream.write(8,SUBPARAM_MESSAGE_DISPLAY_MODE);
      encodeDisplayMode(bData,outStream);
    }
    if (bData.priorityIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIORITY_INDICATOR);
      encodePriorityIndicator(bData,outStream);
    }
    if (bData.alertIndicatorSet) {
      outStream.write(8,SUBPARAM_ALERT_ON_MESSAGE_DELIVERY);
      encodeMsgDeliveryAlert(bData,outStream);
    }
    if (bData.messageStatusSet) {
      outStream.write(8,SUBPARAM_MESSAGE_STATUS);
      encodeMsgStatus(bData,outStream);
    }
    return outStream.toByteArray();
  }
 catch (  BitwiseOutputStream.AccessException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
catch (  CodingException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
  return null;
}"
22053,"/** 
 * Calculate the message text encoding length, fragmentation, and other details.
 * @param force ignore (but still count) illegal characters if true
 * @return septet count, or -1 on failure
 */
public static TextEncodingDetails calcTextEncodingDetails(CharSequence msg,boolean force7BitEncoding){
  TextEncodingDetails ted;
  int septets=countAsciiSeptets(msg,force7BitEncoding);
  if (septets != -1 && septets <= SmsMessage.MAX_USER_DATA_SEPTETS) {
    ted=new TextEncodingDetails();
    ted.msgCount=1;
    ted.codeUnitCount=septets;
    ted.codeUnitsRemaining=SmsMessage.MAX_USER_DATA_SEPTETS - septets;
    ted.codeUnitSize=SmsMessage.ENCODING_7BIT;
  }
 else {
    ted=com.android.internal.telephony.gsm.SmsMessage.calculateLength(msg,force7BitEncoding);
    if (ted.msgCount == 1 && ted.codeUnitSize == SmsMessage.ENCODING_7BIT) {
      ted.codeUnitCount=msg.length();
      int octets=ted.codeUnitCount * 2;
      if (octets > MAX_USER_DATA_BYTES) {
        ted.msgCount=(octets / MAX_USER_DATA_BYTES_WITH_HEADER) + 1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES_WITH_HEADER - (octets % MAX_USER_DATA_BYTES_WITH_HEADER)) / 2;
      }
 else {
        ted.msgCount=1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
      }
      ted.codeUnitSize=ENCODING_16BIT;
    }
  }
  return ted;
}","/** 
 * Calculate the message text encoding length, fragmentation, and other details.
 * @param msg message text
 * @param force7BitEncoding ignore (but still count) illegal characters if true
 * @return septet count, or -1 on failure
 */
public static TextEncodingDetails calcTextEncodingDetails(CharSequence msg,boolean force7BitEncoding){
  TextEncodingDetails ted;
  int septets=countAsciiSeptets(msg,force7BitEncoding);
  if (septets != -1 && septets <= SmsMessage.MAX_USER_DATA_SEPTETS) {
    ted=new TextEncodingDetails();
    ted.msgCount=1;
    ted.codeUnitCount=septets;
    ted.codeUnitsRemaining=SmsMessage.MAX_USER_DATA_SEPTETS - septets;
    ted.codeUnitSize=SmsMessage.ENCODING_7BIT;
  }
 else {
    ted=com.android.internal.telephony.gsm.SmsMessage.calculateLength(msg,force7BitEncoding);
    if (ted.msgCount == 1 && ted.codeUnitSize == SmsMessage.ENCODING_7BIT) {
      ted.codeUnitCount=msg.length();
      int octets=ted.codeUnitCount * 2;
      if (octets > MAX_USER_DATA_BYTES) {
        ted.msgCount=(octets + (MAX_USER_DATA_BYTES_WITH_HEADER - 1)) / MAX_USER_DATA_BYTES_WITH_HEADER;
        ted.codeUnitsRemaining=((ted.msgCount * MAX_USER_DATA_BYTES_WITH_HEADER) - octets) / 2;
      }
 else {
        ted.msgCount=1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
      }
      ted.codeUnitSize=ENCODING_16BIT;
    }
  }
  return ted;
}"
22054,"/** 
 * Calculate the number of septets needed to encode the message.
 * @param msgBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence msgBody,boolean use7bitOnly){
  TextEncodingDetails ted=new TextEncodingDetails();
  try {
    int septets=GsmAlphabet.countGsmSeptets(msgBody,!use7bitOnly);
    ted.codeUnitCount=septets;
    if (septets > MAX_USER_DATA_SEPTETS) {
      ted.msgCount=(septets / MAX_USER_DATA_SEPTETS_WITH_HEADER) + 1;
      ted.codeUnitsRemaining=MAX_USER_DATA_SEPTETS_WITH_HEADER - (septets % MAX_USER_DATA_SEPTETS_WITH_HEADER);
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=MAX_USER_DATA_SEPTETS - septets;
    }
    ted.codeUnitSize=ENCODING_7BIT;
  }
 catch (  EncodeException ex) {
    int octets=msgBody.length() * 2;
    ted.codeUnitCount=msgBody.length();
    if (octets > MAX_USER_DATA_BYTES) {
      ted.msgCount=(octets / MAX_USER_DATA_BYTES_WITH_HEADER) + 1;
      ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES_WITH_HEADER - (octets % MAX_USER_DATA_BYTES_WITH_HEADER)) / 2;
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
    }
    ted.codeUnitSize=ENCODING_16BIT;
  }
  return ted;
}","/** 
 * Calculate the number of septets needed to encode the message.
 * @param msgBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence msgBody,boolean use7bitOnly){
  TextEncodingDetails ted=new TextEncodingDetails();
  try {
    int septets=GsmAlphabet.countGsmSeptets(msgBody,!use7bitOnly);
    ted.codeUnitCount=septets;
    if (septets > MAX_USER_DATA_SEPTETS) {
      ted.msgCount=(septets + (MAX_USER_DATA_SEPTETS_WITH_HEADER - 1)) / MAX_USER_DATA_SEPTETS_WITH_HEADER;
      ted.codeUnitsRemaining=(ted.msgCount * MAX_USER_DATA_SEPTETS_WITH_HEADER) - septets;
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=MAX_USER_DATA_SEPTETS - septets;
    }
    ted.codeUnitSize=ENCODING_7BIT;
  }
 catch (  EncodeException ex) {
    int octets=msgBody.length() * 2;
    ted.codeUnitCount=msgBody.length();
    if (octets > MAX_USER_DATA_BYTES) {
      ted.msgCount=(octets + (MAX_USER_DATA_BYTES_WITH_HEADER - 1)) / MAX_USER_DATA_BYTES_WITH_HEADER;
      ted.codeUnitsRemaining=((ted.msgCount * MAX_USER_DATA_BYTES_WITH_HEADER) - octets) / 2;
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
    }
    ted.codeUnitSize=ENCODING_16BIT;
  }
  return ted;
}"
22055,"/** 
 * Retrieves the compelete voice mail number.
 * @hide
 */
public String getCompleteVoiceMailNumber(){
  mContext.enforceCallingOrSelfPermission(CALL_PRIVILEGED,""String_Node_Str"");
  String number=mPhone.getVoiceMailNumber();
  Log.d(LOG_TAG,""String_Node_Str"");
  return number;
}","/** 
 * Retrieves the complete voice mail number.
 * @hide
 */
public String getCompleteVoiceMailNumber(){
  mContext.enforceCallingOrSelfPermission(CALL_PRIVILEGED,""String_Node_Str"");
  String number=mPhone.getVoiceMailNumber();
  Log.d(LOG_TAG,""String_Node_Str"");
  return number;
}"
22056,"/** 
 * response.obj.result is an String[14] See ril.h for details Please note that registration state 4 (""unknown"") is treated as ""out of service"" above
 */
public void getRegistrationState(Message result){
  String ret[]=new String[14];
  ret[0]=""String_Node_Str"";
  ret[1]=null;
  ret[2]=null;
  ret[3]=null;
  ret[4]=null;
  ret[5]=null;
  ret[6]=null;
  ret[7]=null;
  ret[8]=null;
  ret[9]=null;
  ret[10]=null;
  ret[11]=null;
  ret[12]=null;
  ret[13]=null;
  ret[14]=null;
  resultSuccess(result,ret);
}","/** 
 * response.obj.result is an String[14] See ril.h for details Please note that registration state 4 (""unknown"") is treated as ""out of service"" above
 */
public void getRegistrationState(Message result){
  String ret[]=new String[14];
  ret[0]=""String_Node_Str"";
  ret[1]=null;
  ret[2]=null;
  ret[3]=null;
  ret[4]=null;
  ret[5]=null;
  ret[6]=null;
  ret[7]=null;
  ret[8]=null;
  ret[9]=null;
  ret[10]=null;
  ret[11]=null;
  ret[12]=null;
  ret[13]=null;
  resultSuccess(result,ret);
}"
22057,"public void dispatchKey(KeyEvent event){
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
    if (false && event.getKeyCode() == KeyEvent.KEYCODE_CAMERA) {
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      debug();
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
    }
  }
  Message msg=obtainMessage(DISPATCH_KEY);
  msg.obj=event;
  if (LOCAL_LOGV)   Log.v(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ mView);
  sendMessageAtTime(msg,event.getEventTime());
}","private void dispatchKey(KeyEvent event,boolean sendDone){
  if (false && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (event.getKeyCode() == KeyEvent.KEYCODE_CAMERA) {
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      debug();
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
    }
  }
  Message msg=obtainMessage(DISPATCH_KEY);
  msg.obj=event;
  msg.arg1=sendDone ? 1 : 0;
  if (LOCAL_LOGV)   Log.v(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ mView);
  sendMessageAtTime(msg,event.getEventTime());
}"
22058,"private void deliverKeyEvent(KeyEvent event,boolean sendDone){
  boolean handled=mView != null ? mView.dispatchKeyEventPreIme(event) : true;
  if (handled) {
    if (sendDone) {
      if (LOCAL_LOGV)       Log.v(TAG,""String_Node_Str"");
      finishKeyEvent(event);
    }
    return;
  }
  if (mLastWasImTarget) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null && mView != null) {
      int seq=enqueuePendingEvent(event,sendDone);
      if (DEBUG_IMF)       Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ event);
      imm.dispatchKeyEvent(mView.getContext(),seq,event,mInputMethodCallback);
      return;
    }
  }
  deliverKeyEventToViewHierarchy(event,sendDone);
}","private void deliverKeyEvent(KeyEvent event,boolean sendDone){
  boolean handled=mView != null ? mView.dispatchKeyEventPreIme(event) : true;
  if (handled) {
    if (sendDone) {
      finishKeyEvent(event);
    }
    return;
  }
  if (mLastWasImTarget) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null && mView != null) {
      int seq=enqueuePendingEvent(event,sendDone);
      if (DEBUG_IMF)       Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ event);
      imm.dispatchKeyEvent(mView.getContext(),seq,event,mInputMethodCallback);
      return;
    }
  }
  deliverKeyEventToViewHierarchy(event,sendDone);
}"
22059,"void handleFinishedEvent(int seq,boolean handled){
  final KeyEvent event=(KeyEvent)retrievePendingEvent(seq);
  if (DEBUG_IMF)   Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event);
  if (event != null) {
    final boolean sendDone=seq >= 0;
    if (!handled) {
      deliverKeyEventToViewHierarchy(event,sendDone);
      return;
    }
 else     if (sendDone) {
      if (LOCAL_LOGV)       Log.v(TAG,""String_Node_Str"");
      finishKeyEvent(event);
    }
 else {
      Log.w(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event+ ""String_Node_Str"");
    }
  }
}","void handleFinishedEvent(int seq,boolean handled){
  final KeyEvent event=(KeyEvent)retrievePendingEvent(seq);
  if (DEBUG_IMF)   Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event);
  if (event != null) {
    final boolean sendDone=seq >= 0;
    if (!handled) {
      deliverKeyEventToViewHierarchy(event,sendDone);
      return;
    }
 else     if (sendDone) {
      finishKeyEvent(event);
    }
 else {
      Log.w(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event+ ""String_Node_Str"");
    }
  }
}"
22060,"private void finishKeyEvent(KeyEvent event){
  if (mFinishedCallback != null) {
    mFinishedCallback.run();
    mFinishedCallback=null;
  }
}","private void finishKeyEvent(KeyEvent event){
  if (LOCAL_LOGV)   Log.v(TAG,""String_Node_Str"");
  if (mFinishedCallback != null) {
    mFinishedCallback.run();
    mFinishedCallback=null;
  }
 else {
    Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"");
  }
}"
22061,"public void handleKey(KeyEvent event,Runnable finishedCallback){
  mFinishedCallback=finishedCallback;
  dispatchKey(event);
}","public void handleKey(KeyEvent event,Runnable finishedCallback){
  if (mFinishedCallback != null) {
    Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"");
  }
  mFinishedCallback=finishedCallback;
  dispatchKey(event,true);
}"
22062,"private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
if (mView instanceof ViewGroup) {
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
}
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"");
finishKeyEvent(event);
}
}
}","private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
if (mView instanceof ViewGroup) {
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
}
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
finishKeyEvent(event);
}
}
}"
22063,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case View.AttachInfo.INVALIDATE_MSG:
    ((View)msg.obj).invalidate();
  break;
case View.AttachInfo.INVALIDATE_RECT_MSG:
final View.AttachInfo.InvalidateInfo info=(View.AttachInfo.InvalidateInfo)msg.obj;
info.target.invalidate(info.left,info.top,info.right,info.bottom);
info.release();
break;
case DO_TRAVERSAL:
if (mProfile) {
Debug.startMethodTracing(""String_Node_Str"");
}
performTraversals();
if (mProfile) {
Debug.stopMethodTracing();
mProfile=false;
}
break;
case FINISHED_EVENT:
handleFinishedEvent(msg.arg1,msg.arg2 != 0);
break;
case DISPATCH_KEY:
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
deliverKeyEvent((KeyEvent)msg.obj,true);
break;
case DISPATCH_POINTER:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverPointerEvent(event);
}
  finally {
event.recycle();
if (LOCAL_LOGV || WATCH_POINTER) Log.i(TAG,""String_Node_Str"");
}
}
break;
case DISPATCH_TRACKBALL:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverTrackballEvent(event);
}
  finally {
event.recycle();
}
}
break;
case DISPATCH_APP_VISIBILITY:
handleAppVisibility(msg.arg1 != 0);
break;
case DISPATCH_GET_NEW_SURFACE:
handleGetNewSurface();
break;
case RESIZED:
ResizedInfo ri=(ResizedInfo)msg.obj;
if (mWinFrame.width() == msg.arg1 && mWinFrame.height() == msg.arg2 && mPendingContentInsets.equals(ri.coveredInsets) && mPendingVisibleInsets.equals(ri.visibleInsets) && ((ResizedInfo)msg.obj).newConfig == null) {
break;
}
case RESIZED_REPORT:
if (mAdded) {
Configuration config=((ResizedInfo)msg.obj).newConfig;
if (config != null) {
updateConfiguration(config,false);
}
mWinFrame.left=0;
mWinFrame.right=msg.arg1;
mWinFrame.top=0;
mWinFrame.bottom=msg.arg2;
mPendingContentInsets.set(((ResizedInfo)msg.obj).coveredInsets);
mPendingVisibleInsets.set(((ResizedInfo)msg.obj).visibleInsets);
if (msg.what == RESIZED_REPORT) {
mReportNextDraw=true;
}
if (mView != null) {
forceLayout(mView);
}
requestLayout();
}
break;
case WINDOW_FOCUS_CHANGED:
{
if (mAdded) {
boolean hasWindowFocus=msg.arg1 != 0;
mAttachInfo.mHasWindowFocus=hasWindowFocus;
if (hasWindowFocus) {
boolean inTouchMode=msg.arg2 != 0;
ensureTouchModeLocally(inTouchMode);
if (mGlWanted) {
checkEglErrors();
if (mGlWanted && !mUseGL) {
initializeGL();
if (mGlCanvas != null) {
float appScale=mAttachInfo.mApplicationScale;
mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
}
}
}
}
mLastWasImTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
InputMethodManager imm=InputMethodManager.peekInstance();
if (mView != null) {
if (hasWindowFocus && imm != null && mLastWasImTarget) {
imm.startGettingWindowFocus(mView);
}
mAttachInfo.mKeyDispatchState.reset();
mView.dispatchWindowFocusChanged(hasWindowFocus);
}
if (hasWindowFocus) {
if (imm != null && mLastWasImTarget) {
imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
}
mWindowAttributes.softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
((WindowManager.LayoutParams)mView.getLayoutParams()).softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
mHasHadWindowFocus=true;
}
if (hasWindowFocus && mView != null) {
sendAccessibilityEvents();
}
}
}
break;
case DIE:
doDie();
break;
case DISPATCH_KEY_FROM_IME:
{
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
KeyEvent event=(KeyEvent)msg.obj;
if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
event=KeyEvent.changeFlags(event,event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
}
deliverKeyEventToViewHierarchy((KeyEvent)msg.obj,false);
}
break;
case FINISH_INPUT_CONNECTION:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.reportFinishInputConnection((InputConnection)msg.obj);
}
}
break;
case CHECK_FOCUS:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.checkFocus();
}
}
break;
case CLOSE_SYSTEM_DIALOGS:
{
if (mView != null) {
mView.onCloseSystemDialogs((String)msg.obj);
}
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case View.AttachInfo.INVALIDATE_MSG:
    ((View)msg.obj).invalidate();
  break;
case View.AttachInfo.INVALIDATE_RECT_MSG:
final View.AttachInfo.InvalidateInfo info=(View.AttachInfo.InvalidateInfo)msg.obj;
info.target.invalidate(info.left,info.top,info.right,info.bottom);
info.release();
break;
case DO_TRAVERSAL:
if (mProfile) {
Debug.startMethodTracing(""String_Node_Str"");
}
performTraversals();
if (mProfile) {
Debug.stopMethodTracing();
mProfile=false;
}
break;
case FINISHED_EVENT:
handleFinishedEvent(msg.arg1,msg.arg2 != 0);
break;
case DISPATCH_KEY:
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
deliverKeyEvent((KeyEvent)msg.obj,msg.arg1 != 0);
break;
case DISPATCH_POINTER:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverPointerEvent(event);
}
  finally {
event.recycle();
if (LOCAL_LOGV || WATCH_POINTER) Log.i(TAG,""String_Node_Str"");
}
}
break;
case DISPATCH_TRACKBALL:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverTrackballEvent(event);
}
  finally {
event.recycle();
}
}
break;
case DISPATCH_APP_VISIBILITY:
handleAppVisibility(msg.arg1 != 0);
break;
case DISPATCH_GET_NEW_SURFACE:
handleGetNewSurface();
break;
case RESIZED:
ResizedInfo ri=(ResizedInfo)msg.obj;
if (mWinFrame.width() == msg.arg1 && mWinFrame.height() == msg.arg2 && mPendingContentInsets.equals(ri.coveredInsets) && mPendingVisibleInsets.equals(ri.visibleInsets) && ((ResizedInfo)msg.obj).newConfig == null) {
break;
}
case RESIZED_REPORT:
if (mAdded) {
Configuration config=((ResizedInfo)msg.obj).newConfig;
if (config != null) {
updateConfiguration(config,false);
}
mWinFrame.left=0;
mWinFrame.right=msg.arg1;
mWinFrame.top=0;
mWinFrame.bottom=msg.arg2;
mPendingContentInsets.set(((ResizedInfo)msg.obj).coveredInsets);
mPendingVisibleInsets.set(((ResizedInfo)msg.obj).visibleInsets);
if (msg.what == RESIZED_REPORT) {
mReportNextDraw=true;
}
if (mView != null) {
forceLayout(mView);
}
requestLayout();
}
break;
case WINDOW_FOCUS_CHANGED:
{
if (mAdded) {
boolean hasWindowFocus=msg.arg1 != 0;
mAttachInfo.mHasWindowFocus=hasWindowFocus;
if (hasWindowFocus) {
boolean inTouchMode=msg.arg2 != 0;
ensureTouchModeLocally(inTouchMode);
if (mGlWanted) {
checkEglErrors();
if (mGlWanted && !mUseGL) {
initializeGL();
if (mGlCanvas != null) {
float appScale=mAttachInfo.mApplicationScale;
mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
}
}
}
}
mLastWasImTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
InputMethodManager imm=InputMethodManager.peekInstance();
if (mView != null) {
if (hasWindowFocus && imm != null && mLastWasImTarget) {
imm.startGettingWindowFocus(mView);
}
mAttachInfo.mKeyDispatchState.reset();
mView.dispatchWindowFocusChanged(hasWindowFocus);
}
if (hasWindowFocus) {
if (imm != null && mLastWasImTarget) {
imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
}
mWindowAttributes.softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
((WindowManager.LayoutParams)mView.getLayoutParams()).softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
mHasHadWindowFocus=true;
}
if (hasWindowFocus && mView != null) {
sendAccessibilityEvents();
}
}
}
break;
case DIE:
doDie();
break;
case DISPATCH_KEY_FROM_IME:
{
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
KeyEvent event=(KeyEvent)msg.obj;
if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
event=KeyEvent.changeFlags(event,event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
}
deliverKeyEventToViewHierarchy((KeyEvent)msg.obj,false);
}
break;
case FINISH_INPUT_CONNECTION:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.reportFinishInputConnection((InputConnection)msg.obj);
}
}
break;
case CHECK_FOCUS:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.checkFocus();
}
}
break;
case CLOSE_SYSTEM_DIALOGS:
{
if (mView != null) {
mView.onCloseSystemDialogs((String)msg.obj);
}
}
break;
}
}"
22064,"public void dispatchKey(KeyEvent event){
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
    if (false && event.getKeyCode() == KeyEvent.KEYCODE_CAMERA) {
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      debug();
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
    }
  }
  Message msg=obtainMessage(DISPATCH_KEY);
  msg.obj=event;
  if (LOCAL_LOGV)   Log.v(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ mView);
  sendMessageAtTime(msg,event.getEventTime());
}","private void dispatchKey(KeyEvent event,boolean sendDone){
  if (false && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (event.getKeyCode() == KeyEvent.KEYCODE_CAMERA) {
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      debug();
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
    }
  }
  Message msg=obtainMessage(DISPATCH_KEY);
  msg.obj=event;
  msg.arg1=sendDone ? 1 : 0;
  if (LOCAL_LOGV)   Log.v(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ mView);
  sendMessageAtTime(msg,event.getEventTime());
}"
22065,"private void deliverKeyEvent(KeyEvent event,boolean sendDone){
  boolean handled=mView != null ? mView.dispatchKeyEventPreIme(event) : true;
  if (handled) {
    if (sendDone) {
      if (LOCAL_LOGV)       Log.v(TAG,""String_Node_Str"");
      finishKeyEvent(event);
    }
    return;
  }
  if (mLastWasImTarget) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null && mView != null) {
      int seq=enqueuePendingEvent(event,sendDone);
      if (DEBUG_IMF)       Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ event);
      imm.dispatchKeyEvent(mView.getContext(),seq,event,mInputMethodCallback);
      return;
    }
  }
  deliverKeyEventToViewHierarchy(event,sendDone);
}","private void deliverKeyEvent(KeyEvent event,boolean sendDone){
  boolean handled=mView != null ? mView.dispatchKeyEventPreIme(event) : true;
  if (handled) {
    if (sendDone) {
      finishKeyEvent(event);
    }
    return;
  }
  if (mLastWasImTarget) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null && mView != null) {
      int seq=enqueuePendingEvent(event,sendDone);
      if (DEBUG_IMF)       Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ event);
      imm.dispatchKeyEvent(mView.getContext(),seq,event,mInputMethodCallback);
      return;
    }
  }
  deliverKeyEventToViewHierarchy(event,sendDone);
}"
22066,"void handleFinishedEvent(int seq,boolean handled){
  final KeyEvent event=(KeyEvent)retrievePendingEvent(seq);
  if (DEBUG_IMF)   Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event);
  if (event != null) {
    final boolean sendDone=seq >= 0;
    if (!handled) {
      deliverKeyEventToViewHierarchy(event,sendDone);
      return;
    }
 else     if (sendDone) {
      if (LOCAL_LOGV)       Log.v(TAG,""String_Node_Str"");
      finishKeyEvent(event);
    }
 else {
      Log.w(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event+ ""String_Node_Str"");
    }
  }
}","void handleFinishedEvent(int seq,boolean handled){
  final KeyEvent event=(KeyEvent)retrievePendingEvent(seq);
  if (DEBUG_IMF)   Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event);
  if (event != null) {
    final boolean sendDone=seq >= 0;
    if (!handled) {
      deliverKeyEventToViewHierarchy(event,sendDone);
      return;
    }
 else     if (sendDone) {
      finishKeyEvent(event);
    }
 else {
      Log.w(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event+ ""String_Node_Str"");
    }
  }
}"
22067,"private void finishKeyEvent(KeyEvent event){
  if (mFinishedCallback != null) {
    mFinishedCallback.run();
    mFinishedCallback=null;
  }
}","private void finishKeyEvent(KeyEvent event){
  if (LOCAL_LOGV)   Log.v(TAG,""String_Node_Str"");
  if (mFinishedCallback != null) {
    mFinishedCallback.run();
    mFinishedCallback=null;
  }
 else {
    Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"");
  }
}"
22068,"public void handleKey(KeyEvent event,Runnable finishedCallback){
  mFinishedCallback=finishedCallback;
  dispatchKey(event);
}","public void handleKey(KeyEvent event,Runnable finishedCallback){
  if (mFinishedCallback != null) {
    Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"");
  }
  mFinishedCallback=finishedCallback;
  dispatchKey(event,true);
}"
22069,"private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
if (mView instanceof ViewGroup) {
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
}
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"");
finishKeyEvent(event);
}
}
}","private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
if (mView instanceof ViewGroup) {
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
}
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
finishKeyEvent(event);
}
}
}"
22070,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case View.AttachInfo.INVALIDATE_MSG:
    ((View)msg.obj).invalidate();
  break;
case View.AttachInfo.INVALIDATE_RECT_MSG:
final View.AttachInfo.InvalidateInfo info=(View.AttachInfo.InvalidateInfo)msg.obj;
info.target.invalidate(info.left,info.top,info.right,info.bottom);
info.release();
break;
case DO_TRAVERSAL:
if (mProfile) {
Debug.startMethodTracing(""String_Node_Str"");
}
performTraversals();
if (mProfile) {
Debug.stopMethodTracing();
mProfile=false;
}
break;
case FINISHED_EVENT:
handleFinishedEvent(msg.arg1,msg.arg2 != 0);
break;
case DISPATCH_KEY:
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
deliverKeyEvent((KeyEvent)msg.obj,true);
break;
case DISPATCH_POINTER:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverPointerEvent(event);
}
  finally {
event.recycle();
if (LOCAL_LOGV || WATCH_POINTER) Log.i(TAG,""String_Node_Str"");
}
}
break;
case DISPATCH_TRACKBALL:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverTrackballEvent(event);
}
  finally {
event.recycle();
}
}
break;
case DISPATCH_APP_VISIBILITY:
handleAppVisibility(msg.arg1 != 0);
break;
case DISPATCH_GET_NEW_SURFACE:
handleGetNewSurface();
break;
case RESIZED:
ResizedInfo ri=(ResizedInfo)msg.obj;
if (mWinFrame.width() == msg.arg1 && mWinFrame.height() == msg.arg2 && mPendingContentInsets.equals(ri.coveredInsets) && mPendingVisibleInsets.equals(ri.visibleInsets) && ((ResizedInfo)msg.obj).newConfig == null) {
break;
}
case RESIZED_REPORT:
if (mAdded) {
Configuration config=((ResizedInfo)msg.obj).newConfig;
if (config != null) {
updateConfiguration(config,false);
}
mWinFrame.left=0;
mWinFrame.right=msg.arg1;
mWinFrame.top=0;
mWinFrame.bottom=msg.arg2;
mPendingContentInsets.set(((ResizedInfo)msg.obj).coveredInsets);
mPendingVisibleInsets.set(((ResizedInfo)msg.obj).visibleInsets);
if (msg.what == RESIZED_REPORT) {
mReportNextDraw=true;
}
if (mView != null) {
forceLayout(mView);
}
requestLayout();
}
break;
case WINDOW_FOCUS_CHANGED:
{
if (mAdded) {
boolean hasWindowFocus=msg.arg1 != 0;
mAttachInfo.mHasWindowFocus=hasWindowFocus;
if (hasWindowFocus) {
boolean inTouchMode=msg.arg2 != 0;
ensureTouchModeLocally(inTouchMode);
if (mGlWanted) {
checkEglErrors();
if (mGlWanted && !mUseGL) {
initializeGL();
if (mGlCanvas != null) {
float appScale=mAttachInfo.mApplicationScale;
mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
}
}
}
}
mLastWasImTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
InputMethodManager imm=InputMethodManager.peekInstance();
if (mView != null) {
if (hasWindowFocus && imm != null && mLastWasImTarget) {
imm.startGettingWindowFocus(mView);
}
mAttachInfo.mKeyDispatchState.reset();
mView.dispatchWindowFocusChanged(hasWindowFocus);
}
if (hasWindowFocus) {
if (imm != null && mLastWasImTarget) {
imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
}
mWindowAttributes.softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
((WindowManager.LayoutParams)mView.getLayoutParams()).softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
mHasHadWindowFocus=true;
}
if (hasWindowFocus && mView != null) {
sendAccessibilityEvents();
}
}
}
break;
case DIE:
doDie();
break;
case DISPATCH_KEY_FROM_IME:
{
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
KeyEvent event=(KeyEvent)msg.obj;
if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
event=KeyEvent.changeFlags(event,event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
}
deliverKeyEventToViewHierarchy((KeyEvent)msg.obj,false);
}
break;
case FINISH_INPUT_CONNECTION:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.reportFinishInputConnection((InputConnection)msg.obj);
}
}
break;
case CHECK_FOCUS:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.checkFocus();
}
}
break;
case CLOSE_SYSTEM_DIALOGS:
{
if (mView != null) {
mView.onCloseSystemDialogs((String)msg.obj);
}
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case View.AttachInfo.INVALIDATE_MSG:
    ((View)msg.obj).invalidate();
  break;
case View.AttachInfo.INVALIDATE_RECT_MSG:
final View.AttachInfo.InvalidateInfo info=(View.AttachInfo.InvalidateInfo)msg.obj;
info.target.invalidate(info.left,info.top,info.right,info.bottom);
info.release();
break;
case DO_TRAVERSAL:
if (mProfile) {
Debug.startMethodTracing(""String_Node_Str"");
}
performTraversals();
if (mProfile) {
Debug.stopMethodTracing();
mProfile=false;
}
break;
case FINISHED_EVENT:
handleFinishedEvent(msg.arg1,msg.arg2 != 0);
break;
case DISPATCH_KEY:
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
deliverKeyEvent((KeyEvent)msg.obj,msg.arg1 != 0);
break;
case DISPATCH_POINTER:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverPointerEvent(event);
}
  finally {
event.recycle();
if (LOCAL_LOGV || WATCH_POINTER) Log.i(TAG,""String_Node_Str"");
}
}
break;
case DISPATCH_TRACKBALL:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverTrackballEvent(event);
}
  finally {
event.recycle();
}
}
break;
case DISPATCH_APP_VISIBILITY:
handleAppVisibility(msg.arg1 != 0);
break;
case DISPATCH_GET_NEW_SURFACE:
handleGetNewSurface();
break;
case RESIZED:
ResizedInfo ri=(ResizedInfo)msg.obj;
if (mWinFrame.width() == msg.arg1 && mWinFrame.height() == msg.arg2 && mPendingContentInsets.equals(ri.coveredInsets) && mPendingVisibleInsets.equals(ri.visibleInsets) && ((ResizedInfo)msg.obj).newConfig == null) {
break;
}
case RESIZED_REPORT:
if (mAdded) {
Configuration config=((ResizedInfo)msg.obj).newConfig;
if (config != null) {
updateConfiguration(config,false);
}
mWinFrame.left=0;
mWinFrame.right=msg.arg1;
mWinFrame.top=0;
mWinFrame.bottom=msg.arg2;
mPendingContentInsets.set(((ResizedInfo)msg.obj).coveredInsets);
mPendingVisibleInsets.set(((ResizedInfo)msg.obj).visibleInsets);
if (msg.what == RESIZED_REPORT) {
mReportNextDraw=true;
}
if (mView != null) {
forceLayout(mView);
}
requestLayout();
}
break;
case WINDOW_FOCUS_CHANGED:
{
if (mAdded) {
boolean hasWindowFocus=msg.arg1 != 0;
mAttachInfo.mHasWindowFocus=hasWindowFocus;
if (hasWindowFocus) {
boolean inTouchMode=msg.arg2 != 0;
ensureTouchModeLocally(inTouchMode);
if (mGlWanted) {
checkEglErrors();
if (mGlWanted && !mUseGL) {
initializeGL();
if (mGlCanvas != null) {
float appScale=mAttachInfo.mApplicationScale;
mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
}
}
}
}
mLastWasImTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
InputMethodManager imm=InputMethodManager.peekInstance();
if (mView != null) {
if (hasWindowFocus && imm != null && mLastWasImTarget) {
imm.startGettingWindowFocus(mView);
}
mAttachInfo.mKeyDispatchState.reset();
mView.dispatchWindowFocusChanged(hasWindowFocus);
}
if (hasWindowFocus) {
if (imm != null && mLastWasImTarget) {
imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
}
mWindowAttributes.softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
((WindowManager.LayoutParams)mView.getLayoutParams()).softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
mHasHadWindowFocus=true;
}
if (hasWindowFocus && mView != null) {
sendAccessibilityEvents();
}
}
}
break;
case DIE:
doDie();
break;
case DISPATCH_KEY_FROM_IME:
{
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
KeyEvent event=(KeyEvent)msg.obj;
if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
event=KeyEvent.changeFlags(event,event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
}
deliverKeyEventToViewHierarchy((KeyEvent)msg.obj,false);
}
break;
case FINISH_INPUT_CONNECTION:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.reportFinishInputConnection((InputConnection)msg.obj);
}
}
break;
case CHECK_FOCUS:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.checkFocus();
}
}
break;
case CLOSE_SYSTEM_DIALOGS:
{
if (mView != null) {
mView.onCloseSystemDialogs((String)msg.obj);
}
}
break;
}
}"
22071,"/** 
 * MotionEvent has no getRawX(int) method; simulate it pending future API approval. 
 */
private static float getRawX(MotionEvent event,int pointerIndex){
  float offset=event.getX() - event.getRawX();
  return event.getX(pointerIndex) + offset;
}","/** 
 * MotionEvent has no getRawX(int) method; simulate it pending future API approval. 
 */
private static float getRawX(MotionEvent event,int pointerIndex){
  float offset=event.getRawX() - event.getX();
  return event.getX(pointerIndex) + offset;
}"
22072,"/** 
 * MotionEvent has no getRawY(int) method; simulate it pending future API approval. 
 */
private static float getRawY(MotionEvent event,int pointerIndex){
  float offset=event.getY() - event.getRawY();
  return event.getY(pointerIndex) + offset;
}","/** 
 * MotionEvent has no getRawY(int) method; simulate it pending future API approval. 
 */
private static float getRawY(MotionEvent event,int pointerIndex){
  float offset=event.getRawY() - event.getY();
  return event.getY(pointerIndex) + offset;
}"
22073,"/** 
 * unregister phone from CallManager
 * @param phone
 */
public void unregisterPhone(Phone phone){
  if (phone != null && !mPhones.contains(phone)) {
    mPhones.remove(phone);
    mRingingCalls.remove(phone.getRingingCall());
    mBackgroundCalls.remove(phone.getBackgroundCall());
    mForegroundCalls.remove(phone.getForegroundCall());
    unregisterForPhoneStates(phone);
    if (phone == mDefaultPhone) {
      if (mPhones.isEmpty()) {
        mDefaultPhone=null;
      }
 else {
        mDefaultPhone=mPhones.get(0);
      }
    }
  }
}","/** 
 * unregister phone from CallManager
 * @param phone
 */
public void unregisterPhone(Phone phone){
  if (phone != null && mPhones.contains(phone)) {
    mPhones.remove(phone);
    mRingingCalls.remove(phone.getRingingCall());
    mBackgroundCalls.remove(phone.getBackgroundCall());
    mForegroundCalls.remove(phone.getForegroundCall());
    unregisterForPhoneStates(phone);
    if (phone == mDefaultPhone) {
      if (mPhones.isEmpty()) {
        mDefaultPhone=null;
      }
 else {
        mDefaultPhone=mPhones.get(0);
      }
    }
  }
}"
22074,"/** 
 * MotionEvent has no getRawX(int) method; simulate it pending future API approval. 
 */
private static float getRawX(MotionEvent event,int pointerIndex){
  float offset=event.getX() - event.getRawX();
  return event.getX(pointerIndex) + offset;
}","/** 
 * MotionEvent has no getRawX(int) method; simulate it pending future API approval. 
 */
private static float getRawX(MotionEvent event,int pointerIndex){
  float offset=event.getRawX() - event.getX();
  return event.getX(pointerIndex) + offset;
}"
22075,"/** 
 * MotionEvent has no getRawY(int) method; simulate it pending future API approval. 
 */
private static float getRawY(MotionEvent event,int pointerIndex){
  float offset=event.getY() - event.getRawY();
  return event.getY(pointerIndex) + offset;
}","/** 
 * MotionEvent has no getRawY(int) method; simulate it pending future API approval. 
 */
private static float getRawY(MotionEvent event,int pointerIndex){
  float offset=event.getRawY() - event.getY();
  return event.getY(pointerIndex) + offset;
}"
22076,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (!Intent.ACTION_MEDIA_BUTTON.equals(action)) {
    return;
  }
  KeyEvent event=(KeyEvent)intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
  if (event != null) {
    if ((getMode() == AudioSystem.MODE_IN_CALL) || (getMode() == AudioSystem.MODE_RINGTONE)) {
      return;
    }
synchronized (mRCStack) {
      if (!mRCStack.empty()) {
        Intent targetedIntent=new Intent(Intent.ACTION_MEDIA_BUTTON);
        targetedIntent.putExtras(intent.getExtras());
        targetedIntent.setComponent(mRCStack.peek().mReceiverComponent);
        abortBroadcast();
        context.sendBroadcast(targetedIntent,null);
      }
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (!Intent.ACTION_MEDIA_BUTTON.equals(action)) {
    return;
  }
  KeyEvent event=(KeyEvent)intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
  if (event != null) {
synchronized (mRingingLock) {
      if (mIsRinging || (getMode() == AudioSystem.MODE_IN_CALL) || (getMode() == AudioSystem.MODE_RINGTONE)) {
        return;
      }
    }
synchronized (mRCStack) {
      if (!mRCStack.empty()) {
        Intent targetedIntent=new Intent(Intent.ACTION_MEDIA_BUTTON);
        targetedIntent.putExtras(intent.getExtras());
        targetedIntent.setComponent(mRCStack.peek().mReceiverComponent);
        abortBroadcast();
        context.sendBroadcast(targetedIntent,null);
      }
    }
  }
}"
22077,"@Override public void onCallStateChanged(int state,String incomingNumber){
  if (state == TelephonyManager.CALL_STATE_RINGING) {
    int ringVolume=AudioService.this.getStreamVolume(AudioManager.STREAM_RING);
    if (ringVolume > 0) {
      requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
    }
  }
 else   if (state == TelephonyManager.CALL_STATE_OFFHOOK) {
    requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
  }
 else   if (state == TelephonyManager.CALL_STATE_IDLE) {
    abandonAudioFocus(null,IN_VOICE_COMM_FOCUS_ID);
  }
}","@Override public void onCallStateChanged(int state,String incomingNumber){
  if (state == TelephonyManager.CALL_STATE_RINGING) {
synchronized (mRingingLock) {
      mIsRinging=true;
    }
    int ringVolume=AudioService.this.getStreamVolume(AudioManager.STREAM_RING);
    if (ringVolume > 0) {
      requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
    }
  }
 else   if (state == TelephonyManager.CALL_STATE_OFFHOOK) {
synchronized (mRingingLock) {
      mIsRinging=false;
    }
    requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
  }
 else   if (state == TelephonyManager.CALL_STATE_IDLE) {
synchronized (mRingingLock) {
      mIsRinging=false;
    }
    abandonAudioFocus(null,IN_VOICE_COMM_FOCUS_ID);
  }
}"
22078,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}"
22079,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (!Intent.ACTION_MEDIA_BUTTON.equals(action)) {
    return;
  }
  KeyEvent event=(KeyEvent)intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
  if (event != null) {
    if ((getMode() == AudioSystem.MODE_IN_CALL) || (getMode() == AudioSystem.MODE_RINGTONE)) {
      return;
    }
synchronized (mRCStack) {
      if (!mRCStack.empty()) {
        Intent targetedIntent=new Intent(Intent.ACTION_MEDIA_BUTTON);
        targetedIntent.putExtras(intent.getExtras());
        targetedIntent.setComponent(mRCStack.peek().mReceiverComponent);
        abortBroadcast();
        context.sendBroadcast(targetedIntent,null);
      }
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (!Intent.ACTION_MEDIA_BUTTON.equals(action)) {
    return;
  }
  KeyEvent event=(KeyEvent)intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
  if (event != null) {
synchronized (mRingingLock) {
      if (mIsRinging || (getMode() == AudioSystem.MODE_IN_CALL) || (getMode() == AudioSystem.MODE_RINGTONE)) {
        return;
      }
    }
synchronized (mRCStack) {
      if (!mRCStack.empty()) {
        Intent targetedIntent=new Intent(Intent.ACTION_MEDIA_BUTTON);
        targetedIntent.putExtras(intent.getExtras());
        targetedIntent.setComponent(mRCStack.peek().mReceiverComponent);
        abortBroadcast();
        context.sendBroadcast(targetedIntent,null);
      }
    }
  }
}"
22080,"@Override public void onCallStateChanged(int state,String incomingNumber){
  if (state == TelephonyManager.CALL_STATE_RINGING) {
    int ringVolume=AudioService.this.getStreamVolume(AudioManager.STREAM_RING);
    if (ringVolume > 0) {
      requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
    }
  }
 else   if (state == TelephonyManager.CALL_STATE_OFFHOOK) {
    requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
  }
 else   if (state == TelephonyManager.CALL_STATE_IDLE) {
    abandonAudioFocus(null,IN_VOICE_COMM_FOCUS_ID);
  }
}","@Override public void onCallStateChanged(int state,String incomingNumber){
  if (state == TelephonyManager.CALL_STATE_RINGING) {
synchronized (mRingingLock) {
      mIsRinging=true;
    }
    int ringVolume=AudioService.this.getStreamVolume(AudioManager.STREAM_RING);
    if (ringVolume > 0) {
      requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
    }
  }
 else   if (state == TelephonyManager.CALL_STATE_OFFHOOK) {
synchronized (mRingingLock) {
      mIsRinging=false;
    }
    requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
  }
 else   if (state == TelephonyManager.CALL_STATE_IDLE) {
synchronized (mRingingLock) {
      mIsRinging=false;
    }
    abandonAudioFocus(null,IN_VOICE_COMM_FOCUS_ID);
  }
}"
22081,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}"
22082,"@SuppressWarnings(""String_Node_Str"") private static void dispatchMotionEvent(InputHandler inputHandler,MotionEvent event,long finishedToken){
  Runnable finishedCallback=new FinishedCallback(finishedToken);
  inputHandler.handleMotion(event,finishedCallback);
}","@SuppressWarnings(""String_Node_Str"") private static void dispatchMotionEvent(InputHandler inputHandler,MotionEvent event,long finishedToken){
  Runnable finishedCallback=FinishedCallback.obtain(finishedToken);
  inputHandler.handleMotion(event,finishedCallback);
}"
22083,"@SuppressWarnings(""String_Node_Str"") private static void dispatchKeyEvent(InputHandler inputHandler,KeyEvent event,long finishedToken){
  Runnable finishedCallback=new FinishedCallback(finishedToken);
  inputHandler.handleKey(event,finishedCallback);
}","@SuppressWarnings(""String_Node_Str"") private static void dispatchKeyEvent(InputHandler inputHandler,KeyEvent event,long finishedToken){
  Runnable finishedCallback=FinishedCallback.obtain(finishedToken);
  inputHandler.handleKey(event,finishedCallback);
}"
22084,"public void run(){
synchronized (sLock) {
    nativeFinished(mFinishedToken);
  }
}","public void run(){
synchronized (sLock) {
    if (mFinishedToken == -1) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    nativeFinished(mFinishedToken);
    mFinishedToken=-1;
    if (sRecycleCount < RECYCLE_MAX_COUNT) {
      mRecycleNext=sRecycleHead;
      sRecycleHead=this;
      sRecycleCount+=1;
      if (DEBUG_RECYCLING) {
        Slog.d(TAG,""String_Node_Str"" + sRecycleCount);
      }
    }
  }
}"
22085,"public FinishedCallback(long finishedToken){
  mFinishedToken=finishedToken;
}","private FinishedCallback(){
}"
22086,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}"
22087,"@SuppressWarnings(""String_Node_Str"") private static void dispatchMotionEvent(InputHandler inputHandler,MotionEvent event,long finishedToken){
  Runnable finishedCallback=new FinishedCallback(finishedToken);
  inputHandler.handleMotion(event,finishedCallback);
}","@SuppressWarnings(""String_Node_Str"") private static void dispatchMotionEvent(InputHandler inputHandler,MotionEvent event,long finishedToken){
  Runnable finishedCallback=FinishedCallback.obtain(finishedToken);
  inputHandler.handleMotion(event,finishedCallback);
}"
22088,"@SuppressWarnings(""String_Node_Str"") private static void dispatchKeyEvent(InputHandler inputHandler,KeyEvent event,long finishedToken){
  Runnable finishedCallback=new FinishedCallback(finishedToken);
  inputHandler.handleKey(event,finishedCallback);
}","@SuppressWarnings(""String_Node_Str"") private static void dispatchKeyEvent(InputHandler inputHandler,KeyEvent event,long finishedToken){
  Runnable finishedCallback=FinishedCallback.obtain(finishedToken);
  inputHandler.handleKey(event,finishedCallback);
}"
22089,"public void run(){
synchronized (sLock) {
    nativeFinished(mFinishedToken);
  }
}","public void run(){
synchronized (sLock) {
    if (mFinishedToken == -1) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    nativeFinished(mFinishedToken);
    mFinishedToken=-1;
    if (sRecycleCount < RECYCLE_MAX_COUNT) {
      mRecycleNext=sRecycleHead;
      sRecycleHead=this;
      sRecycleCount+=1;
      if (DEBUG_RECYCLING) {
        Slog.d(TAG,""String_Node_Str"" + sRecycleCount);
      }
    }
  }
}"
22090,"public FinishedCallback(long finishedToken){
  mFinishedToken=finishedToken;
}","private FinishedCallback(){
}"
22091,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}"
22092,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}"
22093,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}"
22094,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}"
22095,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}"
22096,"/** 
 * Parse the pdu.
 * @return the pdu structure if parsing successfully.null if parsing error happened or mandatory fields are not set.
 */
public GenericPdu parse(){
  if (mPduDataStream == null) {
    return null;
  }
  mHeaders=parseHeaders(mPduDataStream);
  if (null == mHeaders) {
    return null;
  }
  int messageType=mHeaders.getOctet(PduHeaders.MESSAGE_TYPE);
  if (false == checkMandatoryHeader(mHeaders)) {
    log(""String_Node_Str"");
    return null;
  }
  if ((PduHeaders.MESSAGE_TYPE_SEND_REQ == messageType) || (PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF == messageType)) {
    mBody=parseParts(mPduDataStream);
    if (null == mBody) {
      return null;
    }
  }
switch (messageType) {
case PduHeaders.MESSAGE_TYPE_SEND_REQ:
    SendReq sendReq=new SendReq(mHeaders,mBody);
  return sendReq;
case PduHeaders.MESSAGE_TYPE_SEND_CONF:
SendConf sendConf=new SendConf(mHeaders);
return sendConf;
case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
NotificationInd notificationInd=new NotificationInd(mHeaders);
return notificationInd;
case PduHeaders.MESSAGE_TYPE_NOTIFYRESP_IND:
NotifyRespInd notifyRespInd=new NotifyRespInd(mHeaders);
return notifyRespInd;
case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
RetrieveConf retrieveConf=new RetrieveConf(mHeaders,mBody);
byte[] contentType=retrieveConf.getContentType();
if (null == contentType) {
return null;
}
String ctTypeStr=new String(contentType);
if (ctTypeStr.equals(ContentType.MULTIPART_MIXED) || ctTypeStr.equals(ContentType.MULTIPART_RELATED)) {
return retrieveConf;
}
return null;
case PduHeaders.MESSAGE_TYPE_DELIVERY_IND:
DeliveryInd deliveryInd=new DeliveryInd(mHeaders);
return deliveryInd;
case PduHeaders.MESSAGE_TYPE_ACKNOWLEDGE_IND:
AcknowledgeInd acknowledgeInd=new AcknowledgeInd(mHeaders);
return acknowledgeInd;
case PduHeaders.MESSAGE_TYPE_READ_ORIG_IND:
ReadOrigInd readOrigInd=new ReadOrigInd(mHeaders);
return readOrigInd;
case PduHeaders.MESSAGE_TYPE_READ_REC_IND:
ReadRecInd readRecInd=new ReadRecInd(mHeaders);
return readRecInd;
default :
log(""String_Node_Str"");
return null;
}
}","/** 
 * Parse the pdu.
 * @return the pdu structure if parsing successfully.null if parsing error happened or mandatory fields are not set.
 */
public GenericPdu parse(){
  if (mPduDataStream == null) {
    return null;
  }
  mHeaders=parseHeaders(mPduDataStream);
  if (null == mHeaders) {
    return null;
  }
  int messageType=mHeaders.getOctet(PduHeaders.MESSAGE_TYPE);
  if (false == checkMandatoryHeader(mHeaders)) {
    log(""String_Node_Str"");
    return null;
  }
  if ((PduHeaders.MESSAGE_TYPE_SEND_REQ == messageType) || (PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF == messageType)) {
    mBody=parseParts(mPduDataStream);
    if (null == mBody) {
      return null;
    }
  }
switch (messageType) {
case PduHeaders.MESSAGE_TYPE_SEND_REQ:
    SendReq sendReq=new SendReq(mHeaders,mBody);
  return sendReq;
case PduHeaders.MESSAGE_TYPE_SEND_CONF:
SendConf sendConf=new SendConf(mHeaders);
return sendConf;
case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
NotificationInd notificationInd=new NotificationInd(mHeaders);
return notificationInd;
case PduHeaders.MESSAGE_TYPE_NOTIFYRESP_IND:
NotifyRespInd notifyRespInd=new NotifyRespInd(mHeaders);
return notifyRespInd;
case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
RetrieveConf retrieveConf=new RetrieveConf(mHeaders,mBody);
byte[] contentType=retrieveConf.getContentType();
if (null == contentType) {
return null;
}
String ctTypeStr=new String(contentType);
if (ctTypeStr.equals(ContentType.MULTIPART_MIXED) || ctTypeStr.equals(ContentType.MULTIPART_RELATED) || ctTypeStr.equals(ContentType.MULTIPART_ALTERNATIVE)) {
return retrieveConf;
}
return null;
case PduHeaders.MESSAGE_TYPE_DELIVERY_IND:
DeliveryInd deliveryInd=new DeliveryInd(mHeaders);
return deliveryInd;
case PduHeaders.MESSAGE_TYPE_ACKNOWLEDGE_IND:
AcknowledgeInd acknowledgeInd=new AcknowledgeInd(mHeaders);
return acknowledgeInd;
case PduHeaders.MESSAGE_TYPE_READ_ORIG_IND:
ReadOrigInd readOrigInd=new ReadOrigInd(mHeaders);
return readOrigInd;
case PduHeaders.MESSAGE_TYPE_READ_REC_IND:
ReadRecInd readRecInd=new ReadRecInd(mHeaders);
return readRecInd;
default :
log(""String_Node_Str"");
return null;
}
}"
22097,"/** 
 * Save data of the part into storage. The source data may be given by a byte[] or a Uri. If it's a byte[], directly save it into storage, otherwise load source data from the dataUri and then save it. If the data is an image, we may scale down it according to user preference.
 * @param part The PDU part which contains data to be saved.
 * @param uri The URI of the part.
 * @param contentType The MIME type of the part.
 * @throws MmsException Cannot find source data or error occurredwhile saving the data.
 */
private void persistData(PduPart part,Uri uri,String contentType) throws MmsException {
  OutputStream os=null;
  InputStream is=null;
  try {
    byte[] data=part.getData();
    if (""String_Node_Str"".equals(contentType) || ""String_Node_Str"".equals(contentType)) {
      ContentValues cv=new ContentValues();
      cv.put(Telephony.Mms.Part.TEXT,new EncodedStringValue(data).getString());
      if (mContentResolver.update(uri,cv,null,null) != 1) {
        throw new MmsException(""String_Node_Str"" + uri.toString());
      }
    }
 else {
      os=mContentResolver.openOutputStream(uri);
      if (data == null) {
        Uri dataUri=part.getDataUri();
        if ((dataUri == null) || (dataUri == uri)) {
          Log.w(TAG,""String_Node_Str"");
          return;
        }
        is=mContentResolver.openInputStream(dataUri);
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        byte[] buffer=new byte[256];
        for (int len=0; (len=is.read(buffer)) != -1; ) {
          os.write(buffer,0,len);
        }
      }
 else {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        os.write(data);
      }
    }
  }
 catch (  FileNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
 finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + os,e);
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + is,e);
      }
    }
  }
}","/** 
 * Save data of the part into storage. The source data may be given by a byte[] or a Uri. If it's a byte[], directly save it into storage, otherwise load source data from the dataUri and then save it. If the data is an image, we may scale down it according to user preference.
 * @param part The PDU part which contains data to be saved.
 * @param uri The URI of the part.
 * @param contentType The MIME type of the part.
 * @throws MmsException Cannot find source data or error occurredwhile saving the data.
 */
private void persistData(PduPart part,Uri uri,String contentType) throws MmsException {
  OutputStream os=null;
  InputStream is=null;
  try {
    byte[] data=part.getData();
    if (ContentType.TEXT_PLAIN.equals(contentType) || ContentType.APP_SMIL.equals(contentType) || ContentType.TEXT_HTML.equals(contentType)) {
      ContentValues cv=new ContentValues();
      cv.put(Telephony.Mms.Part.TEXT,new EncodedStringValue(data).getString());
      if (mContentResolver.update(uri,cv,null,null) != 1) {
        throw new MmsException(""String_Node_Str"" + uri.toString());
      }
    }
 else {
      os=mContentResolver.openOutputStream(uri);
      if (data == null) {
        Uri dataUri=part.getDataUri();
        if ((dataUri == null) || (dataUri == uri)) {
          Log.w(TAG,""String_Node_Str"");
          return;
        }
        is=mContentResolver.openInputStream(dataUri);
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        byte[] buffer=new byte[256];
        for (int len=0; (len=is.read(buffer)) != -1; ) {
          os.write(buffer,0,len);
        }
      }
 else {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        os.write(data);
      }
    }
  }
 catch (  FileNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
 finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + os,e);
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + is,e);
      }
    }
  }
}"
22098,"private PduPart[] loadParts(long msgId) throws MmsException {
  Cursor c=SqliteWrapper.query(mContext,mContentResolver,Uri.parse(""String_Node_Str"" + msgId + ""String_Node_Str""),PART_PROJECTION,null,null,null);
  PduPart[] parts=null;
  try {
    if ((c == null) || (c.getCount() == 0)) {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + msgId + ""String_Node_Str"");
      }
      return null;
    }
    int partCount=c.getCount();
    int partIdx=0;
    parts=new PduPart[partCount];
    while (c.moveToNext()) {
      PduPart part=new PduPart();
      Integer charset=getIntegerFromPartColumn(c,PART_COLUMN_CHARSET);
      if (charset != null) {
        part.setCharset(charset);
      }
      byte[] contentDisposition=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_DISPOSITION);
      if (contentDisposition != null) {
        part.setContentDisposition(contentDisposition);
      }
      byte[] contentId=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_ID);
      if (contentId != null) {
        part.setContentId(contentId);
      }
      byte[] contentLocation=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_LOCATION);
      if (contentLocation != null) {
        part.setContentLocation(contentLocation);
      }
      byte[] contentType=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_TYPE);
      if (contentType != null) {
        part.setContentType(contentType);
      }
 else {
        throw new MmsException(""String_Node_Str"");
      }
      byte[] fileName=getByteArrayFromPartColumn(c,PART_COLUMN_FILENAME);
      if (fileName != null) {
        part.setFilename(fileName);
      }
      byte[] name=getByteArrayFromPartColumn(c,PART_COLUMN_NAME);
      if (name != null) {
        part.setName(name);
      }
      long partId=c.getLong(PART_COLUMN_ID);
      Uri partURI=Uri.parse(""String_Node_Str"" + partId);
      part.setDataUri(partURI);
      String type=toIsoString(contentType);
      if (!ContentType.isImageType(type) && !ContentType.isAudioType(type) && !ContentType.isVideoType(type)) {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        InputStream is=null;
        if (""String_Node_Str"".equals(type) || ""String_Node_Str"".equals(type)) {
          String text=c.getString(PART_COLUMN_TEXT);
          byte[] blob=new EncodedStringValue(text != null ? text : ""String_Node_Str"").getTextString();
          baos.write(blob,0,blob.length);
        }
 else {
          try {
            is=mContentResolver.openInputStream(partURI);
            byte[] buffer=new byte[256];
            int len=is.read(buffer);
            while (len >= 0) {
              baos.write(buffer,0,len);
              len=is.read(buffer);
            }
          }
 catch (          IOException e) {
            Log.e(TAG,""String_Node_Str"",e);
            c.close();
            throw new MmsException(e);
          }
 finally {
            if (is != null) {
              try {
                is.close();
              }
 catch (              IOException e) {
                Log.e(TAG,""String_Node_Str"",e);
              }
            }
          }
        }
        part.setData(baos.toByteArray());
      }
      parts[partIdx++]=part;
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
  return parts;
}","private PduPart[] loadParts(long msgId) throws MmsException {
  Cursor c=SqliteWrapper.query(mContext,mContentResolver,Uri.parse(""String_Node_Str"" + msgId + ""String_Node_Str""),PART_PROJECTION,null,null,null);
  PduPart[] parts=null;
  try {
    if ((c == null) || (c.getCount() == 0)) {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + msgId + ""String_Node_Str"");
      }
      return null;
    }
    int partCount=c.getCount();
    int partIdx=0;
    parts=new PduPart[partCount];
    while (c.moveToNext()) {
      PduPart part=new PduPart();
      Integer charset=getIntegerFromPartColumn(c,PART_COLUMN_CHARSET);
      if (charset != null) {
        part.setCharset(charset);
      }
      byte[] contentDisposition=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_DISPOSITION);
      if (contentDisposition != null) {
        part.setContentDisposition(contentDisposition);
      }
      byte[] contentId=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_ID);
      if (contentId != null) {
        part.setContentId(contentId);
      }
      byte[] contentLocation=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_LOCATION);
      if (contentLocation != null) {
        part.setContentLocation(contentLocation);
      }
      byte[] contentType=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_TYPE);
      if (contentType != null) {
        part.setContentType(contentType);
      }
 else {
        throw new MmsException(""String_Node_Str"");
      }
      byte[] fileName=getByteArrayFromPartColumn(c,PART_COLUMN_FILENAME);
      if (fileName != null) {
        part.setFilename(fileName);
      }
      byte[] name=getByteArrayFromPartColumn(c,PART_COLUMN_NAME);
      if (name != null) {
        part.setName(name);
      }
      long partId=c.getLong(PART_COLUMN_ID);
      Uri partURI=Uri.parse(""String_Node_Str"" + partId);
      part.setDataUri(partURI);
      String type=toIsoString(contentType);
      if (!ContentType.isImageType(type) && !ContentType.isAudioType(type) && !ContentType.isVideoType(type)) {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        InputStream is=null;
        if (ContentType.TEXT_PLAIN.equals(type) || ContentType.APP_SMIL.equals(type) || ContentType.TEXT_HTML.equals(type)) {
          String text=c.getString(PART_COLUMN_TEXT);
          byte[] blob=new EncodedStringValue(text != null ? text : ""String_Node_Str"").getTextString();
          baos.write(blob,0,blob.length);
        }
 else {
          try {
            is=mContentResolver.openInputStream(partURI);
            byte[] buffer=new byte[256];
            int len=is.read(buffer);
            while (len >= 0) {
              baos.write(buffer,0,len);
              len=is.read(buffer);
            }
          }
 catch (          IOException e) {
            Log.e(TAG,""String_Node_Str"",e);
            c.close();
            throw new MmsException(e);
          }
 finally {
            if (is != null) {
              try {
                is.close();
              }
 catch (              IOException e) {
                Log.e(TAG,""String_Node_Str"",e);
              }
            }
          }
        }
        part.setData(baos.toByteArray());
      }
      parts[partIdx++]=part;
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
  return parts;
}"
22099,"/** 
 * Parse the pdu.
 * @return the pdu structure if parsing successfully.null if parsing error happened or mandatory fields are not set.
 */
public GenericPdu parse(){
  if (mPduDataStream == null) {
    return null;
  }
  mHeaders=parseHeaders(mPduDataStream);
  if (null == mHeaders) {
    return null;
  }
  int messageType=mHeaders.getOctet(PduHeaders.MESSAGE_TYPE);
  if (false == checkMandatoryHeader(mHeaders)) {
    log(""String_Node_Str"");
    return null;
  }
  if ((PduHeaders.MESSAGE_TYPE_SEND_REQ == messageType) || (PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF == messageType)) {
    mBody=parseParts(mPduDataStream);
    if (null == mBody) {
      return null;
    }
  }
switch (messageType) {
case PduHeaders.MESSAGE_TYPE_SEND_REQ:
    SendReq sendReq=new SendReq(mHeaders,mBody);
  return sendReq;
case PduHeaders.MESSAGE_TYPE_SEND_CONF:
SendConf sendConf=new SendConf(mHeaders);
return sendConf;
case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
NotificationInd notificationInd=new NotificationInd(mHeaders);
return notificationInd;
case PduHeaders.MESSAGE_TYPE_NOTIFYRESP_IND:
NotifyRespInd notifyRespInd=new NotifyRespInd(mHeaders);
return notifyRespInd;
case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
RetrieveConf retrieveConf=new RetrieveConf(mHeaders,mBody);
byte[] contentType=retrieveConf.getContentType();
if (null == contentType) {
return null;
}
String ctTypeStr=new String(contentType);
if (ctTypeStr.equals(ContentType.MULTIPART_MIXED) || ctTypeStr.equals(ContentType.MULTIPART_RELATED)) {
return retrieveConf;
}
return null;
case PduHeaders.MESSAGE_TYPE_DELIVERY_IND:
DeliveryInd deliveryInd=new DeliveryInd(mHeaders);
return deliveryInd;
case PduHeaders.MESSAGE_TYPE_ACKNOWLEDGE_IND:
AcknowledgeInd acknowledgeInd=new AcknowledgeInd(mHeaders);
return acknowledgeInd;
case PduHeaders.MESSAGE_TYPE_READ_ORIG_IND:
ReadOrigInd readOrigInd=new ReadOrigInd(mHeaders);
return readOrigInd;
case PduHeaders.MESSAGE_TYPE_READ_REC_IND:
ReadRecInd readRecInd=new ReadRecInd(mHeaders);
return readRecInd;
default :
log(""String_Node_Str"");
return null;
}
}","/** 
 * Parse the pdu.
 * @return the pdu structure if parsing successfully.null if parsing error happened or mandatory fields are not set.
 */
public GenericPdu parse(){
  if (mPduDataStream == null) {
    return null;
  }
  mHeaders=parseHeaders(mPduDataStream);
  if (null == mHeaders) {
    return null;
  }
  int messageType=mHeaders.getOctet(PduHeaders.MESSAGE_TYPE);
  if (false == checkMandatoryHeader(mHeaders)) {
    log(""String_Node_Str"");
    return null;
  }
  if ((PduHeaders.MESSAGE_TYPE_SEND_REQ == messageType) || (PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF == messageType)) {
    mBody=parseParts(mPduDataStream);
    if (null == mBody) {
      return null;
    }
  }
switch (messageType) {
case PduHeaders.MESSAGE_TYPE_SEND_REQ:
    SendReq sendReq=new SendReq(mHeaders,mBody);
  return sendReq;
case PduHeaders.MESSAGE_TYPE_SEND_CONF:
SendConf sendConf=new SendConf(mHeaders);
return sendConf;
case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
NotificationInd notificationInd=new NotificationInd(mHeaders);
return notificationInd;
case PduHeaders.MESSAGE_TYPE_NOTIFYRESP_IND:
NotifyRespInd notifyRespInd=new NotifyRespInd(mHeaders);
return notifyRespInd;
case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
RetrieveConf retrieveConf=new RetrieveConf(mHeaders,mBody);
byte[] contentType=retrieveConf.getContentType();
if (null == contentType) {
return null;
}
String ctTypeStr=new String(contentType);
if (ctTypeStr.equals(ContentType.MULTIPART_MIXED) || ctTypeStr.equals(ContentType.MULTIPART_RELATED) || ctTypeStr.equals(ContentType.MULTIPART_ALTERNATIVE)) {
return retrieveConf;
}
return null;
case PduHeaders.MESSAGE_TYPE_DELIVERY_IND:
DeliveryInd deliveryInd=new DeliveryInd(mHeaders);
return deliveryInd;
case PduHeaders.MESSAGE_TYPE_ACKNOWLEDGE_IND:
AcknowledgeInd acknowledgeInd=new AcknowledgeInd(mHeaders);
return acknowledgeInd;
case PduHeaders.MESSAGE_TYPE_READ_ORIG_IND:
ReadOrigInd readOrigInd=new ReadOrigInd(mHeaders);
return readOrigInd;
case PduHeaders.MESSAGE_TYPE_READ_REC_IND:
ReadRecInd readRecInd=new ReadRecInd(mHeaders);
return readRecInd;
default :
log(""String_Node_Str"");
return null;
}
}"
22100,"/** 
 * Save data of the part into storage. The source data may be given by a byte[] or a Uri. If it's a byte[], directly save it into storage, otherwise load source data from the dataUri and then save it. If the data is an image, we may scale down it according to user preference.
 * @param part The PDU part which contains data to be saved.
 * @param uri The URI of the part.
 * @param contentType The MIME type of the part.
 * @throws MmsException Cannot find source data or error occurredwhile saving the data.
 */
private void persistData(PduPart part,Uri uri,String contentType) throws MmsException {
  OutputStream os=null;
  InputStream is=null;
  try {
    byte[] data=part.getData();
    if (""String_Node_Str"".equals(contentType) || ""String_Node_Str"".equals(contentType)) {
      ContentValues cv=new ContentValues();
      cv.put(Telephony.Mms.Part.TEXT,new EncodedStringValue(data).getString());
      if (mContentResolver.update(uri,cv,null,null) != 1) {
        throw new MmsException(""String_Node_Str"" + uri.toString());
      }
    }
 else {
      os=mContentResolver.openOutputStream(uri);
      if (data == null) {
        Uri dataUri=part.getDataUri();
        if ((dataUri == null) || (dataUri == uri)) {
          Log.w(TAG,""String_Node_Str"");
          return;
        }
        is=mContentResolver.openInputStream(dataUri);
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        byte[] buffer=new byte[256];
        for (int len=0; (len=is.read(buffer)) != -1; ) {
          os.write(buffer,0,len);
        }
      }
 else {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        os.write(data);
      }
    }
  }
 catch (  FileNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
 finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + os,e);
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + is,e);
      }
    }
  }
}","/** 
 * Save data of the part into storage. The source data may be given by a byte[] or a Uri. If it's a byte[], directly save it into storage, otherwise load source data from the dataUri and then save it. If the data is an image, we may scale down it according to user preference.
 * @param part The PDU part which contains data to be saved.
 * @param uri The URI of the part.
 * @param contentType The MIME type of the part.
 * @throws MmsException Cannot find source data or error occurredwhile saving the data.
 */
private void persistData(PduPart part,Uri uri,String contentType) throws MmsException {
  OutputStream os=null;
  InputStream is=null;
  try {
    byte[] data=part.getData();
    if (ContentType.TEXT_PLAIN.equals(contentType) || ContentType.APP_SMIL.equals(contentType) || ContentType.TEXT_HTML.equals(contentType)) {
      ContentValues cv=new ContentValues();
      cv.put(Telephony.Mms.Part.TEXT,new EncodedStringValue(data).getString());
      if (mContentResolver.update(uri,cv,null,null) != 1) {
        throw new MmsException(""String_Node_Str"" + uri.toString());
      }
    }
 else {
      os=mContentResolver.openOutputStream(uri);
      if (data == null) {
        Uri dataUri=part.getDataUri();
        if ((dataUri == null) || (dataUri == uri)) {
          Log.w(TAG,""String_Node_Str"");
          return;
        }
        is=mContentResolver.openInputStream(dataUri);
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        byte[] buffer=new byte[256];
        for (int len=0; (len=is.read(buffer)) != -1; ) {
          os.write(buffer,0,len);
        }
      }
 else {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        os.write(data);
      }
    }
  }
 catch (  FileNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
 finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + os,e);
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + is,e);
      }
    }
  }
}"
22101,"private PduPart[] loadParts(long msgId) throws MmsException {
  Cursor c=SqliteWrapper.query(mContext,mContentResolver,Uri.parse(""String_Node_Str"" + msgId + ""String_Node_Str""),PART_PROJECTION,null,null,null);
  PduPart[] parts=null;
  try {
    if ((c == null) || (c.getCount() == 0)) {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + msgId + ""String_Node_Str"");
      }
      return null;
    }
    int partCount=c.getCount();
    int partIdx=0;
    parts=new PduPart[partCount];
    while (c.moveToNext()) {
      PduPart part=new PduPart();
      Integer charset=getIntegerFromPartColumn(c,PART_COLUMN_CHARSET);
      if (charset != null) {
        part.setCharset(charset);
      }
      byte[] contentDisposition=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_DISPOSITION);
      if (contentDisposition != null) {
        part.setContentDisposition(contentDisposition);
      }
      byte[] contentId=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_ID);
      if (contentId != null) {
        part.setContentId(contentId);
      }
      byte[] contentLocation=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_LOCATION);
      if (contentLocation != null) {
        part.setContentLocation(contentLocation);
      }
      byte[] contentType=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_TYPE);
      if (contentType != null) {
        part.setContentType(contentType);
      }
 else {
        throw new MmsException(""String_Node_Str"");
      }
      byte[] fileName=getByteArrayFromPartColumn(c,PART_COLUMN_FILENAME);
      if (fileName != null) {
        part.setFilename(fileName);
      }
      byte[] name=getByteArrayFromPartColumn(c,PART_COLUMN_NAME);
      if (name != null) {
        part.setName(name);
      }
      long partId=c.getLong(PART_COLUMN_ID);
      Uri partURI=Uri.parse(""String_Node_Str"" + partId);
      part.setDataUri(partURI);
      String type=toIsoString(contentType);
      if (!ContentType.isImageType(type) && !ContentType.isAudioType(type) && !ContentType.isVideoType(type)) {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        InputStream is=null;
        if (""String_Node_Str"".equals(type) || ""String_Node_Str"".equals(type)) {
          String text=c.getString(PART_COLUMN_TEXT);
          byte[] blob=new EncodedStringValue(text != null ? text : ""String_Node_Str"").getTextString();
          baos.write(blob,0,blob.length);
        }
 else {
          try {
            is=mContentResolver.openInputStream(partURI);
            byte[] buffer=new byte[256];
            int len=is.read(buffer);
            while (len >= 0) {
              baos.write(buffer,0,len);
              len=is.read(buffer);
            }
          }
 catch (          IOException e) {
            Log.e(TAG,""String_Node_Str"",e);
            c.close();
            throw new MmsException(e);
          }
 finally {
            if (is != null) {
              try {
                is.close();
              }
 catch (              IOException e) {
                Log.e(TAG,""String_Node_Str"",e);
              }
            }
          }
        }
        part.setData(baos.toByteArray());
      }
      parts[partIdx++]=part;
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
  return parts;
}","private PduPart[] loadParts(long msgId) throws MmsException {
  Cursor c=SqliteWrapper.query(mContext,mContentResolver,Uri.parse(""String_Node_Str"" + msgId + ""String_Node_Str""),PART_PROJECTION,null,null,null);
  PduPart[] parts=null;
  try {
    if ((c == null) || (c.getCount() == 0)) {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + msgId + ""String_Node_Str"");
      }
      return null;
    }
    int partCount=c.getCount();
    int partIdx=0;
    parts=new PduPart[partCount];
    while (c.moveToNext()) {
      PduPart part=new PduPart();
      Integer charset=getIntegerFromPartColumn(c,PART_COLUMN_CHARSET);
      if (charset != null) {
        part.setCharset(charset);
      }
      byte[] contentDisposition=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_DISPOSITION);
      if (contentDisposition != null) {
        part.setContentDisposition(contentDisposition);
      }
      byte[] contentId=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_ID);
      if (contentId != null) {
        part.setContentId(contentId);
      }
      byte[] contentLocation=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_LOCATION);
      if (contentLocation != null) {
        part.setContentLocation(contentLocation);
      }
      byte[] contentType=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_TYPE);
      if (contentType != null) {
        part.setContentType(contentType);
      }
 else {
        throw new MmsException(""String_Node_Str"");
      }
      byte[] fileName=getByteArrayFromPartColumn(c,PART_COLUMN_FILENAME);
      if (fileName != null) {
        part.setFilename(fileName);
      }
      byte[] name=getByteArrayFromPartColumn(c,PART_COLUMN_NAME);
      if (name != null) {
        part.setName(name);
      }
      long partId=c.getLong(PART_COLUMN_ID);
      Uri partURI=Uri.parse(""String_Node_Str"" + partId);
      part.setDataUri(partURI);
      String type=toIsoString(contentType);
      if (!ContentType.isImageType(type) && !ContentType.isAudioType(type) && !ContentType.isVideoType(type)) {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        InputStream is=null;
        if (ContentType.TEXT_PLAIN.equals(type) || ContentType.APP_SMIL.equals(type) || ContentType.TEXT_HTML.equals(type)) {
          String text=c.getString(PART_COLUMN_TEXT);
          byte[] blob=new EncodedStringValue(text != null ? text : ""String_Node_Str"").getTextString();
          baos.write(blob,0,blob.length);
        }
 else {
          try {
            is=mContentResolver.openInputStream(partURI);
            byte[] buffer=new byte[256];
            int len=is.read(buffer);
            while (len >= 0) {
              baos.write(buffer,0,len);
              len=is.read(buffer);
            }
          }
 catch (          IOException e) {
            Log.e(TAG,""String_Node_Str"",e);
            c.close();
            throw new MmsException(e);
          }
 finally {
            if (is != null) {
              try {
                is.close();
              }
 catch (              IOException e) {
                Log.e(TAG,""String_Node_Str"",e);
              }
            }
          }
        }
        part.setData(baos.toByteArray());
      }
      parts[partIdx++]=part;
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
  return parts;
}"
22102,"synchronized void getAllProperties(){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,""String_Node_Str"");
  mAdapterProperties.clear();
  String properties[]=(String[])getAdapterPropertiesNative();
  if (properties == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  for (int i=0; i < properties.length; i++) {
    String name=properties[i];
    String newValue=null;
    int len;
    if (name == null) {
      Log.e(TAG,""String_Node_Str"" + i + ""String_Node_Str"");
      continue;
    }
    if (name.equals(""String_Node_Str"")) {
      StringBuilder str=new StringBuilder();
      len=Integer.valueOf(properties[++i]);
      for (int j=0; j < len; j++) {
        str.append(properties[++i]);
        str.append(""String_Node_Str"");
      }
      if (len > 0) {
        newValue=str.toString();
      }
    }
 else {
      newValue=properties[++i];
    }
    mAdapterProperties.put(name,newValue);
  }
  String adapterPath=getAdapterPathNative();
  if (adapterPath != null)   mAdapterProperties.put(""String_Node_Str"",adapterPath + ""String_Node_Str"");
}","synchronized void getAllProperties(){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,""String_Node_Str"");
  mAdapterProperties.clear();
  String properties[]=(String[])getAdapterPropertiesNative();
  if (properties == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  for (int i=0; i < properties.length; i++) {
    String name=properties[i];
    String newValue=null;
    int len;
    if (name == null) {
      Log.e(TAG,""String_Node_Str"" + i + ""String_Node_Str"");
      continue;
    }
    if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
      StringBuilder str=new StringBuilder();
      len=Integer.valueOf(properties[++i]);
      for (int j=0; j < len; j++) {
        str.append(properties[++i]);
        str.append(""String_Node_Str"");
      }
      if (len > 0) {
        newValue=str.toString();
      }
    }
 else {
      newValue=properties[++i];
    }
    mAdapterProperties.put(name,newValue);
  }
  String adapterPath=getAdapterPathNative();
  if (adapterPath != null)   mAdapterProperties.put(""String_Node_Str"",adapterPath + ""String_Node_Str"");
}"
22103,"synchronized void getAllProperties(){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,""String_Node_Str"");
  mAdapterProperties.clear();
  String properties[]=(String[])getAdapterPropertiesNative();
  if (properties == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  for (int i=0; i < properties.length; i++) {
    String name=properties[i];
    String newValue=null;
    int len;
    if (name == null) {
      Log.e(TAG,""String_Node_Str"" + i + ""String_Node_Str"");
      continue;
    }
    if (name.equals(""String_Node_Str"")) {
      StringBuilder str=new StringBuilder();
      len=Integer.valueOf(properties[++i]);
      for (int j=0; j < len; j++) {
        str.append(properties[++i]);
        str.append(""String_Node_Str"");
      }
      if (len > 0) {
        newValue=str.toString();
      }
    }
 else {
      newValue=properties[++i];
    }
    mAdapterProperties.put(name,newValue);
  }
  String adapterPath=getAdapterPathNative();
  if (adapterPath != null)   mAdapterProperties.put(""String_Node_Str"",adapterPath + ""String_Node_Str"");
}","synchronized void getAllProperties(){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,""String_Node_Str"");
  mAdapterProperties.clear();
  String properties[]=(String[])getAdapterPropertiesNative();
  if (properties == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  for (int i=0; i < properties.length; i++) {
    String name=properties[i];
    String newValue=null;
    int len;
    if (name == null) {
      Log.e(TAG,""String_Node_Str"" + i + ""String_Node_Str"");
      continue;
    }
    if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
      StringBuilder str=new StringBuilder();
      len=Integer.valueOf(properties[++i]);
      for (int j=0; j < len; j++) {
        str.append(properties[++i]);
        str.append(""String_Node_Str"");
      }
      if (len > 0) {
        newValue=str.toString();
      }
    }
 else {
      newValue=properties[++i];
    }
    mAdapterProperties.put(name,newValue);
  }
  String adapterPath=getAdapterPathNative();
  if (adapterPath != null)   mAdapterProperties.put(""String_Node_Str"",adapterPath + ""String_Node_Str"");
}"
22104,"/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}","/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    if (!DatabaseHelper.isValidTable(this.table)) {
      throw new IllegalArgumentException(""String_Node_Str"" + this.table);
    }
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}"
22105,"/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}","/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    if (!DatabaseHelper.isValidTable(this.table)) {
      throw new IllegalArgumentException(""String_Node_Str"" + this.table);
    }
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}"
22106,"/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}","/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    if (!DatabaseHelper.isValidTable(this.table)) {
      throw new IllegalArgumentException(""String_Node_Str"" + this.table);
    }
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}"
22107,"/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}","/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    if (!DatabaseHelper.isValidTable(this.table)) {
      throw new IllegalArgumentException(""String_Node_Str"" + this.table);
    }
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}"
22108,"public static String getAudioCodecName(int audioEncoder){
  if (audioEncoder != MediaRecorder.AudioEncoder.AMR_NB && audioEncoder != MediaRecorder.AudioEncoder.AMR_WB && audioEncoder != MediaRecorder.AudioEncoder.AAC && audioEncoder != MediaRecorder.AudioEncoder.AAC_PLUS && audioEncoder != MediaRecorder.AudioEncoder.EAAC_PLUS) {
    throw new IllegalArgumentException(""String_Node_Str"" + audioEncoder);
  }
  return encoderMap.get(audioEncoder);
}","public static String getAudioCodecName(int audioEncoder){
  if (audioEncoder != MediaRecorder.AudioEncoder.AMR_NB && audioEncoder != MediaRecorder.AudioEncoder.AMR_WB && audioEncoder != MediaRecorder.AudioEncoder.AAC && audioEncoder != MediaRecorder.AudioEncoder.AAC_PLUS && audioEncoder != MediaRecorder.AudioEncoder.EAAC_PLUS) {
    throw new IllegalArgumentException(""String_Node_Str"" + audioEncoder);
  }
  return audioEncoderMap.get(audioEncoder);
}"
22109,"public static String getVideoCodecName(int videoEncoder){
  if (videoEncoder != MediaRecorder.VideoEncoder.H263 && videoEncoder != MediaRecorder.VideoEncoder.H264 && videoEncoder != MediaRecorder.VideoEncoder.MPEG_4_SP) {
    throw new IllegalArgumentException(""String_Node_Str"" + videoEncoder);
  }
  return encoderMap.get(videoEncoder);
}","public static String getVideoCodecName(int videoEncoder){
  if (videoEncoder != MediaRecorder.VideoEncoder.H263 && videoEncoder != MediaRecorder.VideoEncoder.H264 && videoEncoder != MediaRecorder.VideoEncoder.MPEG_4_SP) {
    throw new IllegalArgumentException(""String_Node_Str"" + videoEncoder);
  }
  return videoEncoderMap.get(videoEncoder);
}"
22110,"public static String getAudioCodecName(int audioEncoder){
  if (audioEncoder != MediaRecorder.AudioEncoder.AMR_NB && audioEncoder != MediaRecorder.AudioEncoder.AMR_WB && audioEncoder != MediaRecorder.AudioEncoder.AAC && audioEncoder != MediaRecorder.AudioEncoder.AAC_PLUS && audioEncoder != MediaRecorder.AudioEncoder.EAAC_PLUS) {
    throw new IllegalArgumentException(""String_Node_Str"" + audioEncoder);
  }
  return encoderMap.get(audioEncoder);
}","public static String getAudioCodecName(int audioEncoder){
  if (audioEncoder != MediaRecorder.AudioEncoder.AMR_NB && audioEncoder != MediaRecorder.AudioEncoder.AMR_WB && audioEncoder != MediaRecorder.AudioEncoder.AAC && audioEncoder != MediaRecorder.AudioEncoder.AAC_PLUS && audioEncoder != MediaRecorder.AudioEncoder.EAAC_PLUS) {
    throw new IllegalArgumentException(""String_Node_Str"" + audioEncoder);
  }
  return audioEncoderMap.get(audioEncoder);
}"
22111,"public static String getVideoCodecName(int videoEncoder){
  if (videoEncoder != MediaRecorder.VideoEncoder.H263 && videoEncoder != MediaRecorder.VideoEncoder.H264 && videoEncoder != MediaRecorder.VideoEncoder.MPEG_4_SP) {
    throw new IllegalArgumentException(""String_Node_Str"" + videoEncoder);
  }
  return encoderMap.get(videoEncoder);
}","public static String getVideoCodecName(int videoEncoder){
  if (videoEncoder != MediaRecorder.VideoEncoder.H263 && videoEncoder != MediaRecorder.VideoEncoder.H264 && videoEncoder != MediaRecorder.VideoEncoder.MPEG_4_SP) {
    throw new IllegalArgumentException(""String_Node_Str"" + videoEncoder);
  }
  return videoEncoderMap.get(videoEncoder);
}"
22112,"public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    mStartcount=0;
    mCb.unlinkToDeath(this,0);
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    if (mStartcount != 0) {
      try {
        mCb.unlinkToDeath(this,0);
      }
 catch (      NoSuchElementException e) {
        Log.w(TAG,""String_Node_Str"" + mStartcount + ""String_Node_Str"");
      }
    }
    mStartcount=0;
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}"
22113,"public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        mCb.unlinkToDeath(this,0);
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        try {
          mCb.unlinkToDeath(this,0);
        }
 catch (        NoSuchElementException e) {
          Log.w(TAG,""String_Node_Str"");
        }
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}"
22114,"public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    mStartcount=0;
    mCb.unlinkToDeath(this,0);
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    if (mStartcount != 0) {
      try {
        mCb.unlinkToDeath(this,0);
      }
 catch (      NoSuchElementException e) {
        Log.w(TAG,""String_Node_Str"" + mStartcount + ""String_Node_Str"");
      }
    }
    mStartcount=0;
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}"
22115,"public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        mCb.unlinkToDeath(this,0);
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        try {
          mCb.unlinkToDeath(this,0);
        }
 catch (        NoSuchElementException e) {
          Log.w(TAG,""String_Node_Str"");
        }
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}"
22116,"public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    mStartcount=0;
    mCb.unlinkToDeath(this,0);
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    if (mStartcount != 0) {
      try {
        mCb.unlinkToDeath(this,0);
      }
 catch (      NoSuchElementException e) {
        Log.w(TAG,""String_Node_Str"" + mStartcount + ""String_Node_Str"");
      }
    }
    mStartcount=0;
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}"
22117,"public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        mCb.unlinkToDeath(this,0);
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        try {
          mCb.unlinkToDeath(this,0);
        }
 catch (        NoSuchElementException e) {
          Log.w(TAG,""String_Node_Str"");
        }
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}"
22118,"public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    mStartcount=0;
    mCb.unlinkToDeath(this,0);
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    if (mStartcount != 0) {
      try {
        mCb.unlinkToDeath(this,0);
      }
 catch (      NoSuchElementException e) {
        Log.w(TAG,""String_Node_Str"" + mStartcount + ""String_Node_Str"");
      }
    }
    mStartcount=0;
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}"
22119,"public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        mCb.unlinkToDeath(this,0);
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        try {
          mCb.unlinkToDeath(this,0);
        }
 catch (        NoSuchElementException e) {
          Log.w(TAG,""String_Node_Str"");
        }
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}"
22120,"void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers == null ? 0 : broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}","void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers == null ? 0 : broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              id.views=null;
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}"
22121,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
AudioSystem.setParameters(""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
AudioSystem.setParameters(""String_Node_Str"");
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}"
22122,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
AudioSystem.setParameters(""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
AudioSystem.setParameters(""String_Node_Str"");
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}"
22123,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  if (atEdge && getChildCount() > 0) {
    int motionPosition=findMotionRow(y);
    if (motionPosition >= 0) {
      final View motionView=getChildAt(motionPosition - mFirstPosition);
      mMotionViewOriginalTop=motionView.getTop();
    }
    mMotionY=y;
    mMotionPosition=motionPosition;
    invalidate();
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(deltaY) > mTouchSlop) {
    requestDisallowInterceptTouchEvent(true);
  }
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  if (atEdge && getChildCount() > 0) {
    int motionPosition=findMotionRow(y);
    if (motionPosition >= 0) {
      final View motionView=getChildAt(motionPosition - mFirstPosition);
      mMotionViewOriginalTop=motionView.getTop();
    }
    mMotionY=y;
    mMotionPosition=motionPosition;
    invalidate();
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}"
22124,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  if (atEdge && getChildCount() > 0) {
    int motionPosition=findMotionRow(y);
    if (motionPosition >= 0) {
      final View motionView=getChildAt(motionPosition - mFirstPosition);
      mMotionViewOriginalTop=motionView.getTop();
    }
    mMotionY=y;
    mMotionPosition=motionPosition;
    invalidate();
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(deltaY) > mTouchSlop) {
    requestDisallowInterceptTouchEvent(true);
  }
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  if (atEdge && getChildCount() > 0) {
    int motionPosition=findMotionRow(y);
    if (motionPosition >= 0) {
      final View motionView=getChildAt(motionPosition - mFirstPosition);
      mMotionViewOriginalTop=motionView.getTop();
    }
    mMotionY=y;
    mMotionPosition=motionPosition;
    invalidate();
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}"
22125,"void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers == null ? 0 : broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}","void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers == null ? 0 : broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              id.views=null;
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}"
22126,"private int updatePointerIdentifiers(){
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int nextNumPointers=mNextNumPointers;
  final int lastNumPointers=mLastNumPointers;
  if (nextNumPointers == 1 && lastNumPointers == 1) {
    System.arraycopy(nextData,0,lastData,0,MotionEvent.NUM_SAMPLE_DATA);
    return -1;
  }
  final int[] last2Next=mLast2Next;
  for (int i=0; i < lastNumPointers; i++) {
    last2Next[i]=-1;
  }
  if (DEBUG_POINTERS)   Slog.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers);
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  boolean conflicts=false;
  for (int i=0; i < nextNumPointers; i++) {
    conflicts|=assignPointer(i,true);
  }
  if (conflicts) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] != -2) {
        continue;
      }
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
      int numFound;
      do {
        numFound=0;
        long worstDistance=0;
        int worstJ=-1;
        for (int j=0; j < nextNumPointers; j++) {
          if (next2Last[j] != i) {
            continue;
          }
          numFound++;
          if (worstDistance < next2LastDistance[j]) {
            worstDistance=next2LastDistance[j];
            worstJ=j;
          }
        }
        if (worstJ >= 0) {
          if (DEBUG_POINTERS)           Slog.v(""String_Node_Str"",""String_Node_Str"" + worstJ + ""String_Node_Str""+ worstDistance+ ""String_Node_Str"");
          if (assignPointer(worstJ,false)) {
            next2Last[worstJ]=-1;
          }
        }
      }
 while (numFound > 2);
    }
  }
  int retIndex=-1;
  if (lastNumPointers < nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    int nextId=0;
    int i=0;
    while (i < lastNumPointers) {
      if (mPointerIds[i] > nextId) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        System.arraycopy(mPointerIds,i,mPointerIds,i + 1,lastNumPointers - i);
        System.arraycopy(lastData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,(i + 1) * MotionEvent.NUM_SAMPLE_DATA,(lastNumPointers - i) * MotionEvent.NUM_SAMPLE_DATA);
        break;
      }
      i++;
      nextId++;
    }
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"" + nextId + ""String_Node_Str""+ i);
    mLastNumPointers++;
    retIndex=i;
    mPointerIds[i]=nextId;
    for (int j=0; j < nextNumPointers; j++) {
      if (next2Last[j] < 0) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + j);
        next2Last[j]=i;
        break;
      }
    }
  }
  for (int i=0; i < nextNumPointers; i++) {
    int lastIndex=next2Last[i];
    if (lastIndex >= 0) {
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ lastIndex);
      System.arraycopy(nextData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,lastIndex * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
    }
  }
  if (lastNumPointers > nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] == -1) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        retIndex=i;
        break;
      }
    }
  }
  return retIndex;
}","private int updatePointerIdentifiers(){
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int nextNumPointers=mNextNumPointers;
  final int lastNumPointers=mLastNumPointers;
  if (nextNumPointers == 1 && lastNumPointers == 1) {
    System.arraycopy(nextData,0,lastData,0,MotionEvent.NUM_SAMPLE_DATA);
    return -1;
  }
  final int[] last2Next=mLast2Next;
  for (int i=0; i < lastNumPointers; i++) {
    last2Next[i]=-1;
  }
  if (DEBUG_POINTERS)   Slog.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers);
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  boolean conflicts=false;
  for (int i=0; i < nextNumPointers; i++) {
    conflicts|=assignPointer(i,true);
  }
  if (conflicts) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] != -2) {
        continue;
      }
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
      int numFound;
      do {
        numFound=0;
        long worstDistance=0;
        int worstJ=-1;
        for (int j=0; j < nextNumPointers; j++) {
          if (next2Last[j] != i) {
            continue;
          }
          numFound++;
          if (worstDistance < next2LastDistance[j]) {
            worstDistance=next2LastDistance[j];
            worstJ=j;
          }
        }
        if (worstJ >= 0) {
          if (DEBUG_POINTERS)           Slog.v(""String_Node_Str"",""String_Node_Str"" + worstJ + ""String_Node_Str""+ worstDistance+ ""String_Node_Str"");
          if (assignPointer(worstJ,false)) {
            next2Last[worstJ]=-1;
          }
        }
      }
 while (numFound > 2);
    }
  }
  int retIndex=-1;
  if (lastNumPointers < nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    int nextId=0;
    int i=0;
    while (i < lastNumPointers) {
      if (mPointerIds[i] > nextId) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        System.arraycopy(mPointerIds,i,mPointerIds,i + 1,lastNumPointers - i);
        System.arraycopy(lastData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,(i + 1) * MotionEvent.NUM_SAMPLE_DATA,(lastNumPointers - i) * MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(next2Last,i,next2Last,i + 1,lastNumPointers - i);
        break;
      }
      i++;
      nextId++;
    }
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"" + nextId + ""String_Node_Str""+ i);
    mLastNumPointers++;
    retIndex=i;
    mPointerIds[i]=nextId;
    for (int j=0; j < nextNumPointers; j++) {
      if (next2Last[j] < 0) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + j);
        next2Last[j]=i;
        break;
      }
    }
  }
  for (int i=0; i < nextNumPointers; i++) {
    int lastIndex=next2Last[i];
    if (lastIndex >= 0) {
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ lastIndex);
      System.arraycopy(nextData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,lastIndex * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
    }
  }
  if (lastNumPointers > nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] == -1) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        retIndex=i;
        break;
      }
    }
  }
  return retIndex;
}"
22127,"private int updatePointerIdentifiers(){
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int nextNumPointers=mNextNumPointers;
  final int lastNumPointers=mLastNumPointers;
  if (nextNumPointers == 1 && lastNumPointers == 1) {
    System.arraycopy(nextData,0,lastData,0,MotionEvent.NUM_SAMPLE_DATA);
    return -1;
  }
  final int[] last2Next=mLast2Next;
  for (int i=0; i < lastNumPointers; i++) {
    last2Next[i]=-1;
  }
  if (DEBUG_POINTERS)   Slog.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers);
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  boolean conflicts=false;
  for (int i=0; i < nextNumPointers; i++) {
    conflicts|=assignPointer(i,true);
  }
  if (conflicts) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] != -2) {
        continue;
      }
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
      int numFound;
      do {
        numFound=0;
        long worstDistance=0;
        int worstJ=-1;
        for (int j=0; j < nextNumPointers; j++) {
          if (next2Last[j] != i) {
            continue;
          }
          numFound++;
          if (worstDistance < next2LastDistance[j]) {
            worstDistance=next2LastDistance[j];
            worstJ=j;
          }
        }
        if (worstJ >= 0) {
          if (DEBUG_POINTERS)           Slog.v(""String_Node_Str"",""String_Node_Str"" + worstJ + ""String_Node_Str""+ worstDistance+ ""String_Node_Str"");
          if (assignPointer(worstJ,false)) {
            next2Last[worstJ]=-1;
          }
        }
      }
 while (numFound > 2);
    }
  }
  int retIndex=-1;
  if (lastNumPointers < nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    int nextId=0;
    int i=0;
    while (i < lastNumPointers) {
      if (mPointerIds[i] > nextId) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        System.arraycopy(mPointerIds,i,mPointerIds,i + 1,lastNumPointers - i);
        System.arraycopy(lastData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,(i + 1) * MotionEvent.NUM_SAMPLE_DATA,(lastNumPointers - i) * MotionEvent.NUM_SAMPLE_DATA);
        break;
      }
      i++;
      nextId++;
    }
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"" + nextId + ""String_Node_Str""+ i);
    mLastNumPointers++;
    retIndex=i;
    mPointerIds[i]=nextId;
    for (int j=0; j < nextNumPointers; j++) {
      if (next2Last[j] < 0) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + j);
        next2Last[j]=i;
        break;
      }
    }
  }
  for (int i=0; i < nextNumPointers; i++) {
    int lastIndex=next2Last[i];
    if (lastIndex >= 0) {
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ lastIndex);
      System.arraycopy(nextData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,lastIndex * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
    }
  }
  if (lastNumPointers > nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] == -1) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        retIndex=i;
        break;
      }
    }
  }
  return retIndex;
}","private int updatePointerIdentifiers(){
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int nextNumPointers=mNextNumPointers;
  final int lastNumPointers=mLastNumPointers;
  if (nextNumPointers == 1 && lastNumPointers == 1) {
    System.arraycopy(nextData,0,lastData,0,MotionEvent.NUM_SAMPLE_DATA);
    return -1;
  }
  final int[] last2Next=mLast2Next;
  for (int i=0; i < lastNumPointers; i++) {
    last2Next[i]=-1;
  }
  if (DEBUG_POINTERS)   Slog.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers);
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  boolean conflicts=false;
  for (int i=0; i < nextNumPointers; i++) {
    conflicts|=assignPointer(i,true);
  }
  if (conflicts) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] != -2) {
        continue;
      }
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
      int numFound;
      do {
        numFound=0;
        long worstDistance=0;
        int worstJ=-1;
        for (int j=0; j < nextNumPointers; j++) {
          if (next2Last[j] != i) {
            continue;
          }
          numFound++;
          if (worstDistance < next2LastDistance[j]) {
            worstDistance=next2LastDistance[j];
            worstJ=j;
          }
        }
        if (worstJ >= 0) {
          if (DEBUG_POINTERS)           Slog.v(""String_Node_Str"",""String_Node_Str"" + worstJ + ""String_Node_Str""+ worstDistance+ ""String_Node_Str"");
          if (assignPointer(worstJ,false)) {
            next2Last[worstJ]=-1;
          }
        }
      }
 while (numFound > 2);
    }
  }
  int retIndex=-1;
  if (lastNumPointers < nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    int nextId=0;
    int i=0;
    while (i < lastNumPointers) {
      if (mPointerIds[i] > nextId) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        System.arraycopy(mPointerIds,i,mPointerIds,i + 1,lastNumPointers - i);
        System.arraycopy(lastData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,(i + 1) * MotionEvent.NUM_SAMPLE_DATA,(lastNumPointers - i) * MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(next2Last,i,next2Last,i + 1,lastNumPointers - i);
        break;
      }
      i++;
      nextId++;
    }
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"" + nextId + ""String_Node_Str""+ i);
    mLastNumPointers++;
    retIndex=i;
    mPointerIds[i]=nextId;
    for (int j=0; j < nextNumPointers; j++) {
      if (next2Last[j] < 0) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + j);
        next2Last[j]=i;
        break;
      }
    }
  }
  for (int i=0; i < nextNumPointers; i++) {
    int lastIndex=next2Last[i];
    if (lastIndex >= 0) {
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ lastIndex);
      System.arraycopy(nextData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,lastIndex * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
    }
  }
  if (lastNumPointers > nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] == -1) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        retIndex=i;
        break;
      }
    }
  }
  return retIndex;
}"
22128,"private int updatePointerIdentifiers(){
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int nextNumPointers=mNextNumPointers;
  final int lastNumPointers=mLastNumPointers;
  if (nextNumPointers == 1 && lastNumPointers == 1) {
    System.arraycopy(nextData,0,lastData,0,MotionEvent.NUM_SAMPLE_DATA);
    return -1;
  }
  final int[] last2Next=mLast2Next;
  for (int i=0; i < lastNumPointers; i++) {
    last2Next[i]=-1;
  }
  if (DEBUG_POINTERS)   Slog.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers);
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  boolean conflicts=false;
  for (int i=0; i < nextNumPointers; i++) {
    conflicts|=assignPointer(i,true);
  }
  if (conflicts) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] != -2) {
        continue;
      }
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
      int numFound;
      do {
        numFound=0;
        long worstDistance=0;
        int worstJ=-1;
        for (int j=0; j < nextNumPointers; j++) {
          if (next2Last[j] != i) {
            continue;
          }
          numFound++;
          if (worstDistance < next2LastDistance[j]) {
            worstDistance=next2LastDistance[j];
            worstJ=j;
          }
        }
        if (worstJ >= 0) {
          if (DEBUG_POINTERS)           Slog.v(""String_Node_Str"",""String_Node_Str"" + worstJ + ""String_Node_Str""+ worstDistance+ ""String_Node_Str"");
          if (assignPointer(worstJ,false)) {
            next2Last[worstJ]=-1;
          }
        }
      }
 while (numFound > 2);
    }
  }
  int retIndex=-1;
  if (lastNumPointers < nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    int nextId=0;
    int i=0;
    while (i < lastNumPointers) {
      if (mPointerIds[i] > nextId) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        System.arraycopy(mPointerIds,i,mPointerIds,i + 1,lastNumPointers - i);
        System.arraycopy(lastData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,(i + 1) * MotionEvent.NUM_SAMPLE_DATA,(lastNumPointers - i) * MotionEvent.NUM_SAMPLE_DATA);
        break;
      }
      i++;
      nextId++;
    }
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"" + nextId + ""String_Node_Str""+ i);
    mLastNumPointers++;
    retIndex=i;
    mPointerIds[i]=nextId;
    for (int j=0; j < nextNumPointers; j++) {
      if (next2Last[j] < 0) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + j);
        next2Last[j]=i;
        break;
      }
    }
  }
  for (int i=0; i < nextNumPointers; i++) {
    int lastIndex=next2Last[i];
    if (lastIndex >= 0) {
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ lastIndex);
      System.arraycopy(nextData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,lastIndex * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
    }
  }
  if (lastNumPointers > nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] == -1) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        retIndex=i;
        break;
      }
    }
  }
  return retIndex;
}","private int updatePointerIdentifiers(){
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int nextNumPointers=mNextNumPointers;
  final int lastNumPointers=mLastNumPointers;
  if (nextNumPointers == 1 && lastNumPointers == 1) {
    System.arraycopy(nextData,0,lastData,0,MotionEvent.NUM_SAMPLE_DATA);
    return -1;
  }
  final int[] last2Next=mLast2Next;
  for (int i=0; i < lastNumPointers; i++) {
    last2Next[i]=-1;
  }
  if (DEBUG_POINTERS)   Slog.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers);
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  boolean conflicts=false;
  for (int i=0; i < nextNumPointers; i++) {
    conflicts|=assignPointer(i,true);
  }
  if (conflicts) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] != -2) {
        continue;
      }
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
      int numFound;
      do {
        numFound=0;
        long worstDistance=0;
        int worstJ=-1;
        for (int j=0; j < nextNumPointers; j++) {
          if (next2Last[j] != i) {
            continue;
          }
          numFound++;
          if (worstDistance < next2LastDistance[j]) {
            worstDistance=next2LastDistance[j];
            worstJ=j;
          }
        }
        if (worstJ >= 0) {
          if (DEBUG_POINTERS)           Slog.v(""String_Node_Str"",""String_Node_Str"" + worstJ + ""String_Node_Str""+ worstDistance+ ""String_Node_Str"");
          if (assignPointer(worstJ,false)) {
            next2Last[worstJ]=-1;
          }
        }
      }
 while (numFound > 2);
    }
  }
  int retIndex=-1;
  if (lastNumPointers < nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    int nextId=0;
    int i=0;
    while (i < lastNumPointers) {
      if (mPointerIds[i] > nextId) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        System.arraycopy(mPointerIds,i,mPointerIds,i + 1,lastNumPointers - i);
        System.arraycopy(lastData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,(i + 1) * MotionEvent.NUM_SAMPLE_DATA,(lastNumPointers - i) * MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(next2Last,i,next2Last,i + 1,lastNumPointers - i);
        break;
      }
      i++;
      nextId++;
    }
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"" + nextId + ""String_Node_Str""+ i);
    mLastNumPointers++;
    retIndex=i;
    mPointerIds[i]=nextId;
    for (int j=0; j < nextNumPointers; j++) {
      if (next2Last[j] < 0) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + j);
        next2Last[j]=i;
        break;
      }
    }
  }
  for (int i=0; i < nextNumPointers; i++) {
    int lastIndex=next2Last[i];
    if (lastIndex >= 0) {
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ lastIndex);
      System.arraycopy(nextData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,lastIndex * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
    }
  }
  if (lastNumPointers > nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] == -1) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        retIndex=i;
        break;
      }
    }
  }
  return retIndex;
}"
22129,"static boolean isDnsReachable(int dns,int timeout){
  try {
    DatagramSocket socket=new DatagramSocket();
    socket.setSoTimeout(timeout);
    byte[] buf=new byte[DNS_QUERY_BASE_SIZE];
    fillQuery(buf);
    byte parts[]=new byte[4];
    parts[0]=(byte)(dns & 0xff);
    parts[1]=(byte)((dns >> 8) & 0xff);
    parts[2]=(byte)((dns >> 16) & 0xff);
    parts[3]=(byte)((dns >> 24) & 0xff);
    InetAddress dnsAddress=InetAddress.getByAddress(parts);
    DatagramPacket packet=new DatagramPacket(buf,buf.length,dnsAddress,DNS_PORT);
    socket.send(packet);
    DatagramPacket replyPacket=new DatagramPacket(buf,buf.length);
    socket.receive(replyPacket);
    return true;
  }
 catch (  SocketException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  UnknownHostException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  SocketTimeoutException e) {
    return false;
  }
catch (  IOException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  Exception e) {
    if (V || Config.LOGD) {
      Slog.d(TAG,""String_Node_Str"",e);
    }
    return false;
  }
}","static boolean isDnsReachable(int dns,int timeout){
  DatagramSocket socket=null;
  try {
    socket=new DatagramSocket();
    socket.setSoTimeout(timeout);
    byte[] buf=new byte[DNS_QUERY_BASE_SIZE];
    fillQuery(buf);
    byte parts[]=new byte[4];
    parts[0]=(byte)(dns & 0xff);
    parts[1]=(byte)((dns >> 8) & 0xff);
    parts[2]=(byte)((dns >> 16) & 0xff);
    parts[3]=(byte)((dns >> 24) & 0xff);
    InetAddress dnsAddress=InetAddress.getByAddress(parts);
    DatagramPacket packet=new DatagramPacket(buf,buf.length,dnsAddress,DNS_PORT);
    socket.send(packet);
    DatagramPacket replyPacket=new DatagramPacket(buf,buf.length);
    socket.receive(replyPacket);
    return true;
  }
 catch (  SocketException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  UnknownHostException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  SocketTimeoutException e) {
    return false;
  }
catch (  IOException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  Exception e) {
    if (V || Config.LOGD) {
      Slog.d(TAG,""String_Node_Str"",e);
    }
    return false;
  }
 finally {
    if (socket != null) {
      socket.close();
    }
  }
}"
22130,"static boolean isDnsReachable(int dns,int timeout){
  try {
    DatagramSocket socket=new DatagramSocket();
    socket.setSoTimeout(timeout);
    byte[] buf=new byte[DNS_QUERY_BASE_SIZE];
    fillQuery(buf);
    byte parts[]=new byte[4];
    parts[0]=(byte)(dns & 0xff);
    parts[1]=(byte)((dns >> 8) & 0xff);
    parts[2]=(byte)((dns >> 16) & 0xff);
    parts[3]=(byte)((dns >> 24) & 0xff);
    InetAddress dnsAddress=InetAddress.getByAddress(parts);
    DatagramPacket packet=new DatagramPacket(buf,buf.length,dnsAddress,DNS_PORT);
    socket.send(packet);
    DatagramPacket replyPacket=new DatagramPacket(buf,buf.length);
    socket.receive(replyPacket);
    return true;
  }
 catch (  SocketException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  UnknownHostException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  SocketTimeoutException e) {
    return false;
  }
catch (  IOException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  Exception e) {
    if (V || Config.LOGD) {
      Slog.d(TAG,""String_Node_Str"",e);
    }
    return false;
  }
}","static boolean isDnsReachable(int dns,int timeout){
  DatagramSocket socket=null;
  try {
    socket=new DatagramSocket();
    socket.setSoTimeout(timeout);
    byte[] buf=new byte[DNS_QUERY_BASE_SIZE];
    fillQuery(buf);
    byte parts[]=new byte[4];
    parts[0]=(byte)(dns & 0xff);
    parts[1]=(byte)((dns >> 8) & 0xff);
    parts[2]=(byte)((dns >> 16) & 0xff);
    parts[3]=(byte)((dns >> 24) & 0xff);
    InetAddress dnsAddress=InetAddress.getByAddress(parts);
    DatagramPacket packet=new DatagramPacket(buf,buf.length,dnsAddress,DNS_PORT);
    socket.send(packet);
    DatagramPacket replyPacket=new DatagramPacket(buf,buf.length);
    socket.receive(replyPacket);
    return true;
  }
 catch (  SocketException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  UnknownHostException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  SocketTimeoutException e) {
    return false;
  }
catch (  IOException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  Exception e) {
    if (V || Config.LOGD) {
      Slog.d(TAG,""String_Node_Str"",e);
    }
    return false;
  }
 finally {
    if (socket != null) {
      socket.close();
    }
  }
}"
22131,"public void removePackageFromPreferred(String packageName){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS,null);
  Slog.w(TAG,""String_Node_Str"");
}","public void removePackageFromPreferred(String packageName){
  Slog.w(TAG,""String_Node_Str"");
}"
22132,"public void addPackageToPreferred(String packageName){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS,null);
  Slog.w(TAG,""String_Node_Str"");
}","public void addPackageToPreferred(String packageName){
  Slog.w(TAG,""String_Node_Str"");
}"
22133,"public void removePackageFromPreferred(String packageName){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS,null);
  Slog.w(TAG,""String_Node_Str"");
}","public void removePackageFromPreferred(String packageName){
  Slog.w(TAG,""String_Node_Str"");
}"
22134,"public void addPackageToPreferred(String packageName){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS,null);
  Slog.w(TAG,""String_Node_Str"");
}","public void addPackageToPreferred(String packageName){
  Slog.w(TAG,""String_Node_Str"");
}"
22135,"public void removePackageFromPreferred(String packageName){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS,null);
  Slog.w(TAG,""String_Node_Str"");
}","public void removePackageFromPreferred(String packageName){
  Slog.w(TAG,""String_Node_Str"");
}"
22136,"public void addPackageToPreferred(String packageName){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS,null);
  Slog.w(TAG,""String_Node_Str"");
}","public void addPackageToPreferred(String packageName){
  Slog.w(TAG,""String_Node_Str"");
}"
22137,"/** 
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling this function you must not ever touch the event again.
 */
public void recycle(){
  if (TRACK_RECYCLED_LOCATION) {
    if (mRecycledLocation != null) {
      throw new RuntimeException(toString() + ""String_Node_Str"",mRecycledLocation);
    }
    mRecycledLocation=new RuntimeException(""String_Node_Str"");
  }
 else   if (mRecycled) {
    throw new RuntimeException(toString() + ""String_Node_Str"");
  }
synchronized (gRecyclerLock) {
    if (gRecyclerUsed < MAX_RECYCLED) {
      gRecyclerUsed++;
      mNumSamples=0;
      mNext=gRecyclerTop;
      gRecyclerTop=this;
    }
  }
}","/** 
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling this function you must not ever touch the event again.
 */
public void recycle(){
  if (TRACK_RECYCLED_LOCATION) {
    if (mRecycledLocation != null) {
      throw new RuntimeException(toString() + ""String_Node_Str"",mRecycledLocation);
    }
    mRecycledLocation=new RuntimeException(""String_Node_Str"");
  }
 else {
    if (mRecycled) {
      throw new RuntimeException(toString() + ""String_Node_Str"");
    }
    mRecycled=true;
  }
synchronized (gRecyclerLock) {
    if (gRecyclerUsed < MAX_RECYCLED) {
      gRecyclerUsed++;
      mNumSamples=0;
      mNext=gRecyclerTop;
      gRecyclerTop=this;
    }
  }
}"
22138,"/** 
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling this function you must not ever touch the event again.
 */
public void recycle(){
  if (TRACK_RECYCLED_LOCATION) {
    if (mRecycledLocation != null) {
      throw new RuntimeException(toString() + ""String_Node_Str"",mRecycledLocation);
    }
    mRecycledLocation=new RuntimeException(""String_Node_Str"");
  }
 else   if (mRecycled) {
    throw new RuntimeException(toString() + ""String_Node_Str"");
  }
synchronized (gRecyclerLock) {
    if (gRecyclerUsed < MAX_RECYCLED) {
      gRecyclerUsed++;
      mNumSamples=0;
      mNext=gRecyclerTop;
      gRecyclerTop=this;
    }
  }
}","/** 
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling this function you must not ever touch the event again.
 */
public void recycle(){
  if (TRACK_RECYCLED_LOCATION) {
    if (mRecycledLocation != null) {
      throw new RuntimeException(toString() + ""String_Node_Str"",mRecycledLocation);
    }
    mRecycledLocation=new RuntimeException(""String_Node_Str"");
  }
 else {
    if (mRecycled) {
      throw new RuntimeException(toString() + ""String_Node_Str"");
    }
    mRecycled=true;
  }
synchronized (gRecyclerLock) {
    if (gRecyclerUsed < MAX_RECYCLED) {
      gRecyclerUsed++;
      mNumSamples=0;
      mNext=gRecyclerTop;
      gRecyclerTop=this;
    }
  }
}"
22139,"public Boolean geocoderIsImplemented(){
  return mGeocodeProvider != null;
}","public boolean geocoderIsImplemented(){
  return mGeocodeProvider != null;
}"
22140,"public void onItemClick(AdapterView parent,View v,int position,long id){
  onListItemClick((ListView)parent,v,position,id);
}","public void onItemClick(AdapterView<?> parent,View v,int position,long id){
  onListItemClick((ListView)parent,v,position,id);
}"
22141,"SdInstallArgs(Uri packageURI,String cid){
  super(packageURI,null,PackageManager.INSTALL_EXTERNAL,null);
  this.cid=cid;
  cachePath=PackageHelper.getSdDir(cid);
}","SdInstallArgs(Uri packageURI,String cid){
  super(packageURI,null,PackageManager.INSTALL_EXTERNAL,null);
  this.cid=cid;
}"
22142,"SdInstallArgs(Uri packageURI,String cid){
  super(packageURI,null,PackageManager.INSTALL_EXTERNAL,null);
  this.cid=cid;
  cachePath=PackageHelper.getSdDir(cid);
}","SdInstallArgs(Uri packageURI,String cid){
  super(packageURI,null,PackageManager.INSTALL_EXTERNAL,null);
  this.cid=cid;
}"
22143,"SdInstallArgs(Uri packageURI,String cid){
  super(packageURI,null,PackageManager.INSTALL_EXTERNAL,null);
  this.cid=cid;
  cachePath=PackageHelper.getSdDir(cid);
}","SdInstallArgs(Uri packageURI,String cid){
  super(packageURI,null,PackageManager.INSTALL_EXTERNAL,null);
  this.cid=cid;
}"
22144,"public void onPictureTaken(byte[] rawData,Camera camera){
  try {
    if (rawData != null) {
      int rawDataLength=rawData.length;
      File rawoutput=new File(""String_Node_Str"");
      FileOutputStream outstream=new FileOutputStream(rawoutput);
      outstream.write(rawData);
      Log.v(TAG,""String_Node_Str"" + rawDataLength);
      jpegPictureCallbackResult=true;
    }
 else {
      jpegPictureCallbackResult=false;
    }
    mSnapshotDone.open();
    Log.v(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    Log.v(TAG,e.toString());
  }
}","public void onPictureTaken(byte[] rawData,Camera camera){
  try {
    if (rawData != null) {
      int rawDataLength=rawData.length;
      File rawoutput=new File(Environment.getExternalStorageDirectory().toString(),""String_Node_Str"");
      FileOutputStream outstream=new FileOutputStream(rawoutput);
      outstream.write(rawData);
      Log.v(TAG,""String_Node_Str"" + rawDataLength);
      jpegPictureCallbackResult=true;
    }
 else {
      jpegPictureCallbackResult=false;
    }
    mSnapshotDone.open();
    Log.v(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    Log.v(TAG,e.toString());
  }
}"
22145,"public void onPictureTaken(byte[] rawData,Camera camera){
  try {
    if (rawData != null) {
      int rawDataLength=rawData.length;
      File rawoutput=new File(""String_Node_Str"");
      FileOutputStream outstream=new FileOutputStream(rawoutput);
      outstream.write(rawData);
      Log.v(TAG,""String_Node_Str"" + rawDataLength);
      jpegPictureCallbackResult=true;
    }
 else {
      jpegPictureCallbackResult=false;
    }
    mSnapshotDone.open();
    Log.v(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    Log.v(TAG,e.toString());
  }
}","public void onPictureTaken(byte[] rawData,Camera camera){
  try {
    if (rawData != null) {
      int rawDataLength=rawData.length;
      File rawoutput=new File(Environment.getExternalStorageDirectory().toString(),""String_Node_Str"");
      FileOutputStream outstream=new FileOutputStream(rawoutput);
      outstream.write(rawData);
      Log.v(TAG,""String_Node_Str"" + rawDataLength);
      jpegPictureCallbackResult=true;
    }
 else {
      jpegPictureCallbackResult=false;
    }
    mSnapshotDone.open();
    Log.v(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    Log.v(TAG,e.toString());
  }
}"
22146,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        if (r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}"
22147,"/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  unregisterAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}"
22148,"/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}","/** 
 * TODO hide
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}"
22149,"/** 
 * TODO document for SDK
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
  IAudioService service=getService();
  try {
    service.unregisterAudioFocusClient(getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}","/** 
 * TODO hide
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}"
22150,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  try {
synchronized (mAudioFocusLock) {
      removeFocusStackEntry(clientId,true);
    }
  }
 catch (  java.util.ConcurrentModificationException cme) {
    Log.e(TAG,""String_Node_Str"" + cme);
    cme.printStackTrace();
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22151,"public void binderDied(){
synchronized (mFocusStack) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}","public void binderDied(){
synchronized (mAudioFocusLock) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}"
22152,"public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mAudioFocusLock) {
    removeFocusStackEntry(clientId,false);
  }
}"
22153,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mAudioFocusLock) {
    if (!canReassignAudioFocus()) {
      return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22154,"/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mFocusStack) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}","/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mAudioFocusLock) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}"
22155,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        if (r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}"
22156,"/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  unregisterAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}"
22157,"/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}","/** 
 * TODO hide
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}"
22158,"/** 
 * TODO document for SDK
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
  IAudioService service=getService();
  try {
    service.unregisterAudioFocusClient(getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}","/** 
 * TODO hide
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}"
22159,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  try {
synchronized (mAudioFocusLock) {
      removeFocusStackEntry(clientId,true);
    }
  }
 catch (  java.util.ConcurrentModificationException cme) {
    Log.e(TAG,""String_Node_Str"" + cme);
    cme.printStackTrace();
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22160,"public void binderDied(){
synchronized (mFocusStack) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}","public void binderDied(){
synchronized (mAudioFocusLock) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}"
22161,"public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mAudioFocusLock) {
    removeFocusStackEntry(clientId,false);
  }
}"
22162,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mAudioFocusLock) {
    if (!canReassignAudioFocus()) {
      return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22163,"/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mFocusStack) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}","/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mAudioFocusLock) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}"
22164,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        if (r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}"
22165,"/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}","/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (equalsIndex >= query.length()) {
      break;
    }
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}"
22166,"public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
}","public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
}"
22167,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        if (r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}"
22168,"/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  unregisterAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}"
22169,"/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}","/** 
 * TODO hide
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}"
22170,"/** 
 * TODO document for SDK
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
  IAudioService service=getService();
  try {
    service.unregisterAudioFocusClient(getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}","/** 
 * TODO hide
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}"
22171,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  try {
synchronized (mAudioFocusLock) {
      removeFocusStackEntry(clientId,true);
    }
  }
 catch (  java.util.ConcurrentModificationException cme) {
    Log.e(TAG,""String_Node_Str"" + cme);
    cme.printStackTrace();
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22172,"public void binderDied(){
synchronized (mFocusStack) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}","public void binderDied(){
synchronized (mAudioFocusLock) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}"
22173,"public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mAudioFocusLock) {
    removeFocusStackEntry(clientId,false);
  }
}"
22174,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mAudioFocusLock) {
    if (!canReassignAudioFocus()) {
      return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22175,"/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mFocusStack) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}","/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mAudioFocusLock) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}"
22176,"/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  unregisterAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}"
22177,"/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}","/** 
 * TODO hide
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}"
22178,"/** 
 * TODO document for SDK
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
  IAudioService service=getService();
  try {
    service.unregisterAudioFocusClient(getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}","/** 
 * TODO hide
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}"
22179,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  try {
synchronized (mAudioFocusLock) {
      removeFocusStackEntry(clientId,true);
    }
  }
 catch (  java.util.ConcurrentModificationException cme) {
    Log.e(TAG,""String_Node_Str"" + cme);
    cme.printStackTrace();
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22180,"public void binderDied(){
synchronized (mFocusStack) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}","public void binderDied(){
synchronized (mAudioFocusLock) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}"
22181,"public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mAudioFocusLock) {
    removeFocusStackEntry(clientId,false);
  }
}"
22182,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mAudioFocusLock) {
    if (!canReassignAudioFocus()) {
      return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22183,"/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mFocusStack) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}","/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mAudioFocusLock) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}"
22184,"/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}","/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (equalsIndex >= query.length()) {
      break;
    }
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}"
22185,"public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
}","public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
}"
22186,"/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}","/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (equalsIndex >= query.length()) {
      break;
    }
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}"
22187,"public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
}","public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
}"
22188,"/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}","/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (equalsIndex >= query.length()) {
      break;
    }
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}"
22189,"public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
}","public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
}"
22190,"/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
    audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
  return;
case SoundEffectConstants.NAVIGATION_DOWN:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}","/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  try {
    final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
      audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
    return;
case SoundEffectConstants.NAVIGATION_DOWN:
  audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}
 catch (IllegalStateException e) {
Log.e(TAG,""String_Node_Str"" + e);
e.printStackTrace();
}
}"
22191,"/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
    audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
  return;
case SoundEffectConstants.NAVIGATION_DOWN:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}","/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  try {
    final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
      audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
    return;
case SoundEffectConstants.NAVIGATION_DOWN:
  audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}
 catch (IllegalStateException e) {
Log.e(TAG,""String_Node_Str"" + e);
e.printStackTrace();
}
}"
22192,"/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
    audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
  return;
case SoundEffectConstants.NAVIGATION_DOWN:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}","/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  try {
    final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
      audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
    return;
case SoundEffectConstants.NAVIGATION_DOWN:
  audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}
 catch (IllegalStateException e) {
Log.e(TAG,""String_Node_Str"" + e);
e.printStackTrace();
}
}"
22193,"/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
    audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
  return;
case SoundEffectConstants.NAVIGATION_DOWN:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}","/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  try {
    final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
      audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
    return;
case SoundEffectConstants.NAVIGATION_DOWN:
  audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}
 catch (IllegalStateException e) {
Log.e(TAG,""String_Node_Str"" + e);
e.printStackTrace();
}
}"
22194,"String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}","String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
case DISPATCH_PACKAGE_BROADCAST:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}"
22195,"public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
case DISPATCH_PACKAGE_BROADCAST:
handleDispatchPackageBroadcast(msg.arg1,(String[])msg.obj);
break;
}
}"
22196,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case DISPATCH_PACKAGE_BROADCAST_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int cmd=data.readInt();
String[] packages=data.readStringArray();
dispatchPackageBroadcast(cmd,packages);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}"
22197,"private void putCachedString(ResourceName name,CharSequence cs){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}","private void putCachedString(ResourceName name,CharSequence cs){
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}"
22198,"private void putCachedIcon(ResourceName name,Drawable dr){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}","private void putCachedIcon(ResourceName name,Drawable dr){
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}"
22199,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
            if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction())) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp});
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}"
22200,"/** 
 * Invokes the item by calling various listeners or callbacks.
 * @return true if the invocation was handled, false otherwise
 */
public boolean invoke(){
  if (mClickListener != null && mClickListener.onMenuItemClick(this)) {
    return true;
  }
  MenuBuilder.Callback callback=mMenu.getCallback();
  if (callback != null && callback.onMenuItemSelected(mMenu.getRootMenu(),this)) {
    return true;
  }
  if (mItemCallback != null) {
    mItemCallback.run();
    return true;
  }
  if (mIntent != null) {
    mMenu.getContext().startActivity(mIntent);
    return true;
  }
  return false;
}","/** 
 * Invokes the item by calling various listeners or callbacks.
 * @return true if the invocation was handled, false otherwise
 */
public boolean invoke(){
  if (mClickListener != null && mClickListener.onMenuItemClick(this)) {
    return true;
  }
  MenuBuilder.Callback callback=mMenu.getCallback();
  if (callback != null && callback.onMenuItemSelected(mMenu.getRootMenu(),this)) {
    return true;
  }
  if (mItemCallback != null) {
    mItemCallback.run();
    return true;
  }
  if (mIntent != null) {
    try {
      mMenu.getContext().startActivity(mIntent);
      return true;
    }
 catch (    ActivityNotFoundException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  return false;
}"
22201,"String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}","String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
case DISPATCH_PACKAGE_BROADCAST:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}"
22202,"public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
case DISPATCH_PACKAGE_BROADCAST:
handleDispatchPackageBroadcast(msg.arg1,(String[])msg.obj);
break;
}
}"
22203,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case DISPATCH_PACKAGE_BROADCAST_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int cmd=data.readInt();
String[] packages=data.readStringArray();
dispatchPackageBroadcast(cmd,packages);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}"
22204,"private void putCachedString(ResourceName name,CharSequence cs){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}","private void putCachedString(ResourceName name,CharSequence cs){
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}"
22205,"private void putCachedIcon(ResourceName name,Drawable dr){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}","private void putCachedIcon(ResourceName name,Drawable dr){
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}"
22206,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
            if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction())) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp});
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}"
22207,"String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}","String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
case DISPATCH_PACKAGE_BROADCAST:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}"
22208,"public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
case DISPATCH_PACKAGE_BROADCAST:
handleDispatchPackageBroadcast(msg.arg1,(String[])msg.obj);
break;
}
}"
22209,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case DISPATCH_PACKAGE_BROADCAST_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int cmd=data.readInt();
String[] packages=data.readStringArray();
dispatchPackageBroadcast(cmd,packages);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}"
22210,"private void putCachedString(ResourceName name,CharSequence cs){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}","private void putCachedString(ResourceName name,CharSequence cs){
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}"
22211,"private void putCachedIcon(ResourceName name,Drawable dr){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}","private void putCachedIcon(ResourceName name,Drawable dr){
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}"
22212,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
            if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction())) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp});
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}"
22213,"String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}","String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
case DISPATCH_PACKAGE_BROADCAST:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}"
22214,"public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
case DISPATCH_PACKAGE_BROADCAST:
handleDispatchPackageBroadcast(msg.arg1,(String[])msg.obj);
break;
}
}"
22215,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case DISPATCH_PACKAGE_BROADCAST_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int cmd=data.readInt();
String[] packages=data.readStringArray();
dispatchPackageBroadcast(cmd,packages);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}"
22216,"private void putCachedString(ResourceName name,CharSequence cs){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}","private void putCachedString(ResourceName name,CharSequence cs){
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}"
22217,"private void putCachedIcon(ResourceName name,Drawable dr){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}","private void putCachedIcon(ResourceName name,Drawable dr){
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}"
22218,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
            if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction())) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp});
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}"
22219,"/** 
 * Invokes the item by calling various listeners or callbacks.
 * @return true if the invocation was handled, false otherwise
 */
public boolean invoke(){
  if (mClickListener != null && mClickListener.onMenuItemClick(this)) {
    return true;
  }
  MenuBuilder.Callback callback=mMenu.getCallback();
  if (callback != null && callback.onMenuItemSelected(mMenu.getRootMenu(),this)) {
    return true;
  }
  if (mItemCallback != null) {
    mItemCallback.run();
    return true;
  }
  if (mIntent != null) {
    mMenu.getContext().startActivity(mIntent);
    return true;
  }
  return false;
}","/** 
 * Invokes the item by calling various listeners or callbacks.
 * @return true if the invocation was handled, false otherwise
 */
public boolean invoke(){
  if (mClickListener != null && mClickListener.onMenuItemClick(this)) {
    return true;
  }
  MenuBuilder.Callback callback=mMenu.getCallback();
  if (callback != null && callback.onMenuItemSelected(mMenu.getRootMenu(),this)) {
    return true;
  }
  if (mItemCallback != null) {
    mItemCallback.run();
    return true;
  }
  if (mIntent != null) {
    try {
      mMenu.getContext().startActivity(mIntent);
      return true;
    }
 catch (    ActivityNotFoundException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  return false;
}"
22220,"/** 
 * Invokes the item by calling various listeners or callbacks.
 * @return true if the invocation was handled, false otherwise
 */
public boolean invoke(){
  if (mClickListener != null && mClickListener.onMenuItemClick(this)) {
    return true;
  }
  MenuBuilder.Callback callback=mMenu.getCallback();
  if (callback != null && callback.onMenuItemSelected(mMenu.getRootMenu(),this)) {
    return true;
  }
  if (mItemCallback != null) {
    mItemCallback.run();
    return true;
  }
  if (mIntent != null) {
    mMenu.getContext().startActivity(mIntent);
    return true;
  }
  return false;
}","/** 
 * Invokes the item by calling various listeners or callbacks.
 * @return true if the invocation was handled, false otherwise
 */
public boolean invoke(){
  if (mClickListener != null && mClickListener.onMenuItemClick(this)) {
    return true;
  }
  MenuBuilder.Callback callback=mMenu.getCallback();
  if (callback != null && callback.onMenuItemSelected(mMenu.getRootMenu(),this)) {
    return true;
  }
  if (mItemCallback != null) {
    mItemCallback.run();
    return true;
  }
  if (mIntent != null) {
    try {
      mMenu.getContext().startActivity(mIntent);
      return true;
    }
 catch (    ActivityNotFoundException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  return false;
}"
22221,"@Override protected void onRestoreInstanceState(Parcelable state){
  SavedState ss=(SavedState)state;
  super.onRestoreInstanceState(ss.getSuperState());
  mYear=ss.getYear();
  mMonth=ss.getMonth();
  mDay=ss.getDay();
}","@Override protected void onRestoreInstanceState(Parcelable state){
  SavedState ss=(SavedState)state;
  super.onRestoreInstanceState(ss.getSuperState());
  mYear=ss.getYear();
  mMonth=ss.getMonth();
  mDay=ss.getDay();
  updateSpinners();
}"
22222,"private void updateExternalMediaStatusInner(boolean mediaStatus,boolean reportStatus){
  int uidArr[]=null;
  HashSet<String> removeCids=new HashSet<String>();
  HashMap<SdInstallArgs,String> processCids=new HashMap<SdInstallArgs,String>();
  final String list[]=PackageHelper.getSecureContainerList();
  if (list == null || list.length == 0) {
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    int uidList[]=new int[list.length];
    int num=0;
synchronized (mPackages) {
      for (      String cid : list) {
        SdInstallArgs args=new SdInstallArgs(cid);
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + cid);
        String pkgName=args.getPackageName();
        if (pkgName == null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
          continue;
        }
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + pkgName);
        PackageSetting ps=mSettings.mPackages.get(pkgName);
        if (ps != null && ps.codePathString != null && (ps.pkgFlags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ ps.codePathString);
          processCids.put(args,ps.codePathString);
          int uid=ps.userId;
          if (uid != -1) {
            uidList[num++]=uid;
          }
        }
 else {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
        }
      }
    }
    if (num > 0) {
      Arrays.sort(uidList,0,num);
      uidArr=new int[num];
      uidArr[0]=uidList[0];
      int di=0;
      for (int i=1; i < num; i++) {
        if (uidList[i - 1] != uidList[i]) {
          uidArr[di++]=uidList[i];
        }
      }
    }
  }
  if (mediaStatus) {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    loadMediaPackages(processCids,uidArr,removeCids);
    startCleaningPackages();
  }
 else {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    unloadMediaPackages(processCids,uidArr,reportStatus);
  }
}","private void updateExternalMediaStatusInner(boolean mediaStatus,boolean reportStatus){
  int uidArr[]=null;
  HashSet<String> removeCids=new HashSet<String>();
  HashMap<SdInstallArgs,String> processCids=new HashMap<SdInstallArgs,String>();
  final String list[]=PackageHelper.getSecureContainerList();
  if (list == null || list.length == 0) {
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    int uidList[]=new int[list.length];
    int num=0;
synchronized (mPackages) {
      for (      String cid : list) {
        SdInstallArgs args=new SdInstallArgs(cid);
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + cid);
        String pkgName=args.getPackageName();
        if (pkgName == null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
          continue;
        }
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + pkgName);
        PackageSetting ps=mSettings.mPackages.get(pkgName);
        if (ps != null && ps.codePathString != null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ ps.codePathString);
          processCids.put(args,ps.codePathString);
          int uid=ps.userId;
          if (uid != -1) {
            uidList[num++]=uid;
          }
        }
 else {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
        }
      }
    }
    if (num > 0) {
      Arrays.sort(uidList,0,num);
      uidArr=new int[num];
      uidArr[0]=uidList[0];
      int di=0;
      for (int i=1; i < num; i++) {
        if (uidList[i - 1] != uidList[i]) {
          uidArr[di++]=uidList[i];
        }
      }
    }
  }
  if (mediaStatus) {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    loadMediaPackages(processCids,uidArr,removeCids);
    startCleaningPackages();
  }
 else {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    unloadMediaPackages(processCids,uidArr,reportStatus);
  }
}"
22223,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
if ((mCurrX == mFinalX) && (mCurrY == mFinalY)) {
mFinished=true;
}
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}"
22224,"private void updateExternalMediaStatusInner(boolean mediaStatus,boolean reportStatus){
  int uidArr[]=null;
  HashSet<String> removeCids=new HashSet<String>();
  HashMap<SdInstallArgs,String> processCids=new HashMap<SdInstallArgs,String>();
  final String list[]=PackageHelper.getSecureContainerList();
  if (list == null || list.length == 0) {
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    int uidList[]=new int[list.length];
    int num=0;
synchronized (mPackages) {
      for (      String cid : list) {
        SdInstallArgs args=new SdInstallArgs(cid);
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + cid);
        String pkgName=args.getPackageName();
        if (pkgName == null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
          continue;
        }
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + pkgName);
        PackageSetting ps=mSettings.mPackages.get(pkgName);
        if (ps != null && ps.codePathString != null && (ps.pkgFlags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ ps.codePathString);
          processCids.put(args,ps.codePathString);
          int uid=ps.userId;
          if (uid != -1) {
            uidList[num++]=uid;
          }
        }
 else {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
        }
      }
    }
    if (num > 0) {
      Arrays.sort(uidList,0,num);
      uidArr=new int[num];
      uidArr[0]=uidList[0];
      int di=0;
      for (int i=1; i < num; i++) {
        if (uidList[i - 1] != uidList[i]) {
          uidArr[di++]=uidList[i];
        }
      }
    }
  }
  if (mediaStatus) {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    loadMediaPackages(processCids,uidArr,removeCids);
    startCleaningPackages();
  }
 else {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    unloadMediaPackages(processCids,uidArr,reportStatus);
  }
}","private void updateExternalMediaStatusInner(boolean mediaStatus,boolean reportStatus){
  int uidArr[]=null;
  HashSet<String> removeCids=new HashSet<String>();
  HashMap<SdInstallArgs,String> processCids=new HashMap<SdInstallArgs,String>();
  final String list[]=PackageHelper.getSecureContainerList();
  if (list == null || list.length == 0) {
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    int uidList[]=new int[list.length];
    int num=0;
synchronized (mPackages) {
      for (      String cid : list) {
        SdInstallArgs args=new SdInstallArgs(cid);
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + cid);
        String pkgName=args.getPackageName();
        if (pkgName == null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
          continue;
        }
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + pkgName);
        PackageSetting ps=mSettings.mPackages.get(pkgName);
        if (ps != null && ps.codePathString != null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ ps.codePathString);
          processCids.put(args,ps.codePathString);
          int uid=ps.userId;
          if (uid != -1) {
            uidList[num++]=uid;
          }
        }
 else {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
        }
      }
    }
    if (num > 0) {
      Arrays.sort(uidList,0,num);
      uidArr=new int[num];
      uidArr[0]=uidList[0];
      int di=0;
      for (int i=1; i < num; i++) {
        if (uidList[i - 1] != uidList[i]) {
          uidArr[di++]=uidList[i];
        }
      }
    }
  }
  if (mediaStatus) {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    loadMediaPackages(processCids,uidArr,removeCids);
    startCleaningPackages();
  }
 else {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    unloadMediaPackages(processCids,uidArr,reportStatus);
  }
}"
22225,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
if ((mCurrX == mFinalX) && (mCurrY == mFinalY)) {
mFinished=true;
}
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}"
22226,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
if ((mCurrX == mFinalX) && (mCurrY == mFinalY)) {
mFinished=true;
}
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}"
22227,"private void updateExternalMediaStatusInner(boolean mediaStatus,boolean reportStatus){
  int uidArr[]=null;
  HashSet<String> removeCids=new HashSet<String>();
  HashMap<SdInstallArgs,String> processCids=new HashMap<SdInstallArgs,String>();
  final String list[]=PackageHelper.getSecureContainerList();
  if (list == null || list.length == 0) {
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    int uidList[]=new int[list.length];
    int num=0;
synchronized (mPackages) {
      for (      String cid : list) {
        SdInstallArgs args=new SdInstallArgs(cid);
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + cid);
        String pkgName=args.getPackageName();
        if (pkgName == null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
          continue;
        }
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + pkgName);
        PackageSetting ps=mSettings.mPackages.get(pkgName);
        if (ps != null && ps.codePathString != null && (ps.pkgFlags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ ps.codePathString);
          processCids.put(args,ps.codePathString);
          int uid=ps.userId;
          if (uid != -1) {
            uidList[num++]=uid;
          }
        }
 else {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
        }
      }
    }
    if (num > 0) {
      Arrays.sort(uidList,0,num);
      uidArr=new int[num];
      uidArr[0]=uidList[0];
      int di=0;
      for (int i=1; i < num; i++) {
        if (uidList[i - 1] != uidList[i]) {
          uidArr[di++]=uidList[i];
        }
      }
    }
  }
  if (mediaStatus) {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    loadMediaPackages(processCids,uidArr,removeCids);
    startCleaningPackages();
  }
 else {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    unloadMediaPackages(processCids,uidArr,reportStatus);
  }
}","private void updateExternalMediaStatusInner(boolean mediaStatus,boolean reportStatus){
  int uidArr[]=null;
  HashSet<String> removeCids=new HashSet<String>();
  HashMap<SdInstallArgs,String> processCids=new HashMap<SdInstallArgs,String>();
  final String list[]=PackageHelper.getSecureContainerList();
  if (list == null || list.length == 0) {
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    int uidList[]=new int[list.length];
    int num=0;
synchronized (mPackages) {
      for (      String cid : list) {
        SdInstallArgs args=new SdInstallArgs(cid);
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + cid);
        String pkgName=args.getPackageName();
        if (pkgName == null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
          continue;
        }
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + pkgName);
        PackageSetting ps=mSettings.mPackages.get(pkgName);
        if (ps != null && ps.codePathString != null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ ps.codePathString);
          processCids.put(args,ps.codePathString);
          int uid=ps.userId;
          if (uid != -1) {
            uidList[num++]=uid;
          }
        }
 else {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
        }
      }
    }
    if (num > 0) {
      Arrays.sort(uidList,0,num);
      uidArr=new int[num];
      uidArr[0]=uidList[0];
      int di=0;
      for (int i=1; i < num; i++) {
        if (uidList[i - 1] != uidList[i]) {
          uidArr[di++]=uidList[i];
        }
      }
    }
  }
  if (mediaStatus) {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    loadMediaPackages(processCids,uidArr,removeCids);
    startCleaningPackages();
  }
 else {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    unloadMediaPackages(processCids,uidArr,reportStatus);
  }
}"
22228,"void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      onVisibilityChanged(visible);
    }
  }
}","void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      if (visible) {
        updateSurface(false,false);
      }
      onVisibilityChanged(visible);
    }
  }
}"
22229,"void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
  final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
  final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
  final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
  final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
  onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}","void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (mSurfaceCreated) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
    final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
    final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
    final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
    final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
    onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  }
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}"
22230,"void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  reportSurfaceDestroyed();
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}"
22231,"void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}","void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean surfaceCreating=!mSurfaceCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || surfaceCreating|| formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
        mCreated=true;
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      if (!mSurfaceHolder.mSurface.isValid()) {
        reportSurfaceDestroyed();
        if (DEBUG)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      try {
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (surfaceCreating) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || surfaceCreating|| formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mSurfaceCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}"
22232,"void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      onVisibilityChanged(visible);
    }
  }
}","void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      if (visible) {
        updateSurface(false,false);
      }
      onVisibilityChanged(visible);
    }
  }
}"
22233,"void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
  final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
  final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
  final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
  final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
  onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}","void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (mSurfaceCreated) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
    final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
    final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
    final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
    final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
    onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  }
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}"
22234,"void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  reportSurfaceDestroyed();
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}"
22235,"void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}","void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean surfaceCreating=!mSurfaceCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || surfaceCreating|| formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
        mCreated=true;
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      if (!mSurfaceHolder.mSurface.isValid()) {
        reportSurfaceDestroyed();
        if (DEBUG)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      try {
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (surfaceCreating) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || surfaceCreating|| formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mSurfaceCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}"
22236,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
22237,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}"
22238,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}"
22239,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22240,"private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true);
    mSettings.writeLP();
  }
  return true;
}","private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    mSettings.writeLP();
  }
  return true;
}"
22241,"private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,false);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}","private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace,boolean replaceAll){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,replaceAll);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}"
22242,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}"
22243,"private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}","private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true,false);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}"
22244,"void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      onVisibilityChanged(visible);
    }
  }
}","void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      if (visible) {
        updateSurface(false,false);
      }
      onVisibilityChanged(visible);
    }
  }
}"
22245,"void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
  final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
  final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
  final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
  final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
  onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}","void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (mSurfaceCreated) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
    final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
    final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
    final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
    final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
    onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  }
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}"
22246,"void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  reportSurfaceDestroyed();
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}"
22247,"void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}","void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean surfaceCreating=!mSurfaceCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || surfaceCreating|| formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
        mCreated=true;
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      if (!mSurfaceHolder.mSurface.isValid()) {
        reportSurfaceDestroyed();
        if (DEBUG)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      try {
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (surfaceCreating) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || surfaceCreating|| formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mSurfaceCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}"
22248,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
22249,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}"
22250,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}"
22251,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22252,"private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true);
    mSettings.writeLP();
  }
  return true;
}","private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    mSettings.writeLP();
  }
  return true;
}"
22253,"private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,false);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}","private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace,boolean replaceAll){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,replaceAll);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}"
22254,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}"
22255,"private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}","private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true,false);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}"
22256,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
22257,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}"
22258,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}"
22259,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22260,"private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true);
    mSettings.writeLP();
  }
  return true;
}","private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    mSettings.writeLP();
  }
  return true;
}"
22261,"private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,false);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}","private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace,boolean replaceAll){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,replaceAll);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}"
22262,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}"
22263,"private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}","private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true,false);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}"
22264,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
22265,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}"
22266,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}"
22267,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22268,"private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true);
    mSettings.writeLP();
  }
  return true;
}","private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    mSettings.writeLP();
  }
  return true;
}"
22269,"private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,false);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}","private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace,boolean replaceAll){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,replaceAll);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}"
22270,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}"
22271,"private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}","private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true,false);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}"
22272,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        return true;
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (!inFullScreenMode() && mShiftIsPressed) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        mTouchMode=TOUCH_SELECT_MODE;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,false);
        mTouchSelection=mExtendSelection=true;
        invalidate();
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (mTouchMode == TOUCH_SELECT_MODE) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,true);
        invalidate();
        break;
      }
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      int ax=Math.abs(deltaX);
      int ay=Math.abs(deltaY);
      if (ax > MAX_SLOPE_FOR_DIAG * ay) {
        mSnapScrollMode=SNAP_X;
        mSnapPositive=deltaX > 0;
      }
 else       if (ay > MAX_SLOPE_FOR_DIAG * ax) {
        mSnapScrollMode=SNAP_Y;
        mSnapPositive=deltaY > 0;
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    int newScrollX=pinLocX(mScrollX + deltaX);
    int newDeltaX=newScrollX - mScrollX;
    if (deltaX != newDeltaX) {
      deltaX=newDeltaX;
      fDeltaX=(float)newDeltaX;
    }
    int newScrollY=pinLocY(mScrollY + deltaY);
    int newDeltaY=newScrollY - mScrollY;
    if (deltaY != newDeltaY) {
      deltaY=newDeltaY;
      fDeltaY=(float)newDeltaY;
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_SELECT_MODE:
commitCopy();
mTouchSelection=false;
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        return true;
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (!inFullScreenMode() && mShiftIsPressed) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        mTouchMode=TOUCH_SELECT_MODE;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,false);
        mTouchSelection=mExtendSelection=true;
        invalidate();
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (mTouchMode == TOUCH_SELECT_MODE) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,true);
        invalidate();
        break;
      }
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      int ax=Math.abs(deltaX);
      int ay=Math.abs(deltaY);
      if (ax > MAX_SLOPE_FOR_DIAG * ay) {
        mSnapScrollMode=SNAP_X;
        mSnapPositive=deltaX > 0;
      }
 else       if (ay > MAX_SLOPE_FOR_DIAG * ax) {
        mSnapScrollMode=SNAP_Y;
        mSnapPositive=deltaY > 0;
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    int newScrollX=pinLocX(mScrollX + deltaX);
    int newDeltaX=newScrollX - mScrollX;
    if (deltaX != newDeltaX) {
      deltaX=newDeltaX;
      fDeltaX=(float)newDeltaX;
    }
    int newScrollY=pinLocY(mScrollY + deltaY);
    int newDeltaY=newScrollY - mScrollY;
    if (deltaY != newDeltaY) {
      deltaY=newDeltaY;
      fDeltaY=(float)newDeltaY;
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      mLastTouchX=x;
      mLastTouchY=y;
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        mLastTouchX=x;
        mLastTouchY=y;
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_SELECT_MODE:
commitCopy();
mTouchSelection=false;
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}"
22273,"public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
}","public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
synchronized (mCmdQueue) {
    if (mCmdQueue.size() == 0) {
synchronized (mCompletionHandlingLock) {
        if (mLooper != null) {
          mLooper.quit();
        }
        mCompletionThread=null;
      }
    }
  }
}"
22274,"public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
mLooper.quit();
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}","public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
  mLooper.quit();
}
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}"
22275,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
synchronized (mCompletionHandlingLock) {
      if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
        mLooper.quit();
      }
      mCompletionThread=new CreationAndCompletionThread(cmd);
synchronized (mCompletionThread) {
        mCompletionThread.start();
        mCompletionThread.wait();
      }
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}"
22276,"void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      onVisibilityChanged(visible);
    }
  }
}","void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      if (visible) {
        updateSurface(false,false);
      }
      onVisibilityChanged(visible);
    }
  }
}"
22277,"void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
  final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
  final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
  final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
  final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
  onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}","void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (mSurfaceCreated) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
    final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
    final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
    final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
    final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
    onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  }
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}"
22278,"void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  reportSurfaceDestroyed();
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}"
22279,"void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}","void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean surfaceCreating=!mSurfaceCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || surfaceCreating|| formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
        mCreated=true;
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      if (!mSurfaceHolder.mSurface.isValid()) {
        reportSurfaceDestroyed();
        if (DEBUG)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      try {
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (surfaceCreating) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || surfaceCreating|| formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mSurfaceCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}"
22280,"public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
}","public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
synchronized (mCmdQueue) {
    if (mCmdQueue.size() == 0) {
synchronized (mCompletionHandlingLock) {
        if (mLooper != null) {
          mLooper.quit();
        }
        mCompletionThread=null;
      }
    }
  }
}"
22281,"public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
mLooper.quit();
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}","public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
  mLooper.quit();
}
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}"
22282,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
synchronized (mCompletionHandlingLock) {
      if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
        mLooper.quit();
      }
      mCompletionThread=new CreationAndCompletionThread(cmd);
synchronized (mCompletionThread) {
        mCompletionThread.start();
        mCompletionThread.wait();
      }
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}"
22283,"public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
}","public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
synchronized (mCmdQueue) {
    if (mCmdQueue.size() == 0) {
synchronized (mCompletionHandlingLock) {
        if (mLooper != null) {
          mLooper.quit();
        }
        mCompletionThread=null;
      }
    }
  }
}"
22284,"public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
mLooper.quit();
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}","public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
  mLooper.quit();
}
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}"
22285,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
synchronized (mCompletionHandlingLock) {
      if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
        mLooper.quit();
      }
      mCompletionThread=new CreationAndCompletionThread(cmd);
synchronized (mCompletionThread) {
        mCompletionThread.start();
        mCompletionThread.wait();
      }
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}"
22286,"public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
}","public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
synchronized (mCmdQueue) {
    if (mCmdQueue.size() == 0) {
synchronized (mCompletionHandlingLock) {
        if (mLooper != null) {
          mLooper.quit();
        }
        mCompletionThread=null;
      }
    }
  }
}"
22287,"public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
mLooper.quit();
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}","public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
  mLooper.quit();
}
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}"
22288,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
synchronized (mCompletionHandlingLock) {
      if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
        mLooper.quit();
      }
      mCompletionThread=new CreationAndCompletionThread(cmd);
synchronized (mCompletionThread) {
        mCompletionThread.start();
        mCompletionThread.wait();
      }
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}"
22289,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        return true;
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (!inFullScreenMode() && mShiftIsPressed) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        mTouchMode=TOUCH_SELECT_MODE;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,false);
        mTouchSelection=mExtendSelection=true;
        invalidate();
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (mTouchMode == TOUCH_SELECT_MODE) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,true);
        invalidate();
        break;
      }
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      int ax=Math.abs(deltaX);
      int ay=Math.abs(deltaY);
      if (ax > MAX_SLOPE_FOR_DIAG * ay) {
        mSnapScrollMode=SNAP_X;
        mSnapPositive=deltaX > 0;
      }
 else       if (ay > MAX_SLOPE_FOR_DIAG * ax) {
        mSnapScrollMode=SNAP_Y;
        mSnapPositive=deltaY > 0;
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    int newScrollX=pinLocX(mScrollX + deltaX);
    int newDeltaX=newScrollX - mScrollX;
    if (deltaX != newDeltaX) {
      deltaX=newDeltaX;
      fDeltaX=(float)newDeltaX;
    }
    int newScrollY=pinLocY(mScrollY + deltaY);
    int newDeltaY=newScrollY - mScrollY;
    if (deltaY != newDeltaY) {
      deltaY=newDeltaY;
      fDeltaY=(float)newDeltaY;
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_SELECT_MODE:
commitCopy();
mTouchSelection=false;
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        return true;
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (!inFullScreenMode() && mShiftIsPressed) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        mTouchMode=TOUCH_SELECT_MODE;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,false);
        mTouchSelection=mExtendSelection=true;
        invalidate();
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (mTouchMode == TOUCH_SELECT_MODE) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,true);
        invalidate();
        break;
      }
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      int ax=Math.abs(deltaX);
      int ay=Math.abs(deltaY);
      if (ax > MAX_SLOPE_FOR_DIAG * ay) {
        mSnapScrollMode=SNAP_X;
        mSnapPositive=deltaX > 0;
      }
 else       if (ay > MAX_SLOPE_FOR_DIAG * ax) {
        mSnapScrollMode=SNAP_Y;
        mSnapPositive=deltaY > 0;
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    int newScrollX=pinLocX(mScrollX + deltaX);
    int newDeltaX=newScrollX - mScrollX;
    if (deltaX != newDeltaX) {
      deltaX=newDeltaX;
      fDeltaX=(float)newDeltaX;
    }
    int newScrollY=pinLocY(mScrollY + deltaY);
    int newDeltaY=newScrollY - mScrollY;
    if (deltaY != newDeltaY) {
      deltaY=newDeltaY;
      fDeltaY=(float)newDeltaY;
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      mLastTouchX=x;
      mLastTouchY=y;
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        mLastTouchX=x;
        mLastTouchY=y;
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_SELECT_MODE:
commitCopy();
mTouchSelection=false;
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}"
22290,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        return true;
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (!inFullScreenMode() && mShiftIsPressed) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        mTouchMode=TOUCH_SELECT_MODE;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,false);
        mTouchSelection=mExtendSelection=true;
        invalidate();
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (mTouchMode == TOUCH_SELECT_MODE) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,true);
        invalidate();
        break;
      }
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      int ax=Math.abs(deltaX);
      int ay=Math.abs(deltaY);
      if (ax > MAX_SLOPE_FOR_DIAG * ay) {
        mSnapScrollMode=SNAP_X;
        mSnapPositive=deltaX > 0;
      }
 else       if (ay > MAX_SLOPE_FOR_DIAG * ax) {
        mSnapScrollMode=SNAP_Y;
        mSnapPositive=deltaY > 0;
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    int newScrollX=pinLocX(mScrollX + deltaX);
    int newDeltaX=newScrollX - mScrollX;
    if (deltaX != newDeltaX) {
      deltaX=newDeltaX;
      fDeltaX=(float)newDeltaX;
    }
    int newScrollY=pinLocY(mScrollY + deltaY);
    int newDeltaY=newScrollY - mScrollY;
    if (deltaY != newDeltaY) {
      deltaY=newDeltaY;
      fDeltaY=(float)newDeltaY;
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_SELECT_MODE:
commitCopy();
mTouchSelection=false;
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        return true;
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (!inFullScreenMode() && mShiftIsPressed) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        mTouchMode=TOUCH_SELECT_MODE;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,false);
        mTouchSelection=mExtendSelection=true;
        invalidate();
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (mTouchMode == TOUCH_SELECT_MODE) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,true);
        invalidate();
        break;
      }
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      int ax=Math.abs(deltaX);
      int ay=Math.abs(deltaY);
      if (ax > MAX_SLOPE_FOR_DIAG * ay) {
        mSnapScrollMode=SNAP_X;
        mSnapPositive=deltaX > 0;
      }
 else       if (ay > MAX_SLOPE_FOR_DIAG * ax) {
        mSnapScrollMode=SNAP_Y;
        mSnapPositive=deltaY > 0;
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    int newScrollX=pinLocX(mScrollX + deltaX);
    int newDeltaX=newScrollX - mScrollX;
    if (deltaX != newDeltaX) {
      deltaX=newDeltaX;
      fDeltaX=(float)newDeltaX;
    }
    int newScrollY=pinLocY(mScrollY + deltaY);
    int newDeltaY=newScrollY - mScrollY;
    if (deltaY != newDeltaY) {
      deltaY=newDeltaY;
      fDeltaY=(float)newDeltaY;
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      mLastTouchX=x;
      mLastTouchY=y;
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        mLastTouchX=x;
        mLastTouchY=y;
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_SELECT_MODE:
commitCopy();
mTouchSelection=false;
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}"
22291,"public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_CANCEL,listener));
  }
}","public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_CANCEL,listener));
  }
}"
22292,"public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_START_LISTENING,new StartListeningArgs(recognizerIntent,listener)));
  }
}","public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_START_LISTENING,mInternalService.new StartListeningArgs(recognizerIntent,listener)));
  }
}"
22293,"public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_STOP_LISTENING,listener));
  }
}","public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_STOP_LISTENING,listener));
  }
}"
22294,"/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
}","/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
  mListener.mInternalListener=null;
}"
22295,"public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_CANCEL,listener));
  }
}","public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_CANCEL,listener));
  }
}"
22296,"public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_START_LISTENING,new StartListeningArgs(recognizerIntent,listener)));
  }
}","public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_START_LISTENING,mInternalService.new StartListeningArgs(recognizerIntent,listener)));
  }
}"
22297,"public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_STOP_LISTENING,listener));
  }
}","public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_STOP_LISTENING,listener));
  }
}"
22298,"/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
}","/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
  mListener.mInternalListener=null;
}"
22299,"public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_CANCEL,listener));
  }
}","public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_CANCEL,listener));
  }
}"
22300,"public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_START_LISTENING,new StartListeningArgs(recognizerIntent,listener)));
  }
}","public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_START_LISTENING,mInternalService.new StartListeningArgs(recognizerIntent,listener)));
  }
}"
22301,"public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_STOP_LISTENING,listener));
  }
}","public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_STOP_LISTENING,listener));
  }
}"
22302,"/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
}","/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
  mListener.mInternalListener=null;
}"
22303,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        if (!app.killedBackground) {
          numHidden++;
          if (numHidden > MAX_HIDDEN_APPS) {
            Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
            EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
            app.killedBackground=true;
            Process.killProcess(app.pid);
          }
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}"
22304,"void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (killedBackground) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(killedBackground);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}"
22305,"private void cancelA2dpDeviceTimeout(String address){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}","private void cancelA2dpDeviceTimeout(){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}"
22306,"private void cancelA2dpDeviceTimeout(String address){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}","private void cancelA2dpDeviceTimeout(){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}"
22307,"private void cancelA2dpDeviceTimeout(String address){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}","private void cancelA2dpDeviceTimeout(){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}"
22308,"private void cancelA2dpDeviceTimeout(String address){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}","private void cancelA2dpDeviceTimeout(){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}"
22309,"void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}","void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}"
22310,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}"
22311,"public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ proc+ ""String_Node_Str""+ adj+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}","public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + proc + ""String_Node_Str""+ adj+ ""String_Node_Str""+ reason);
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}"
22312,"private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}","private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      EventLog.writeEvent(EventLogTags.AM_KILL,capp.pid,capp.processName,capp.setAdj,""String_Node_Str"" + proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}"
22313,"public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateLruProcessLocked(r.app,false,true);
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
22314,"void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}","void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}"
22315,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}"
22316,"public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ proc+ ""String_Node_Str""+ adj+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}","public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + proc + ""String_Node_Str""+ adj+ ""String_Node_Str""+ reason);
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}"
22317,"private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}","private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      EventLog.writeEvent(EventLogTags.AM_KILL,capp.pid,capp.processName,capp.setAdj,""String_Node_Str"" + proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}"
22318,"public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateLruProcessLocked(r.app,false,true);
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
22319,"/** 
 * Try to parse this message as an email gateway message There are two ways specified in TS 23.040 Section 3.8 : - SMS message ""may have its TP-PID set for internet electronic mail - MT SMS format: [<from-address><space>]<message> - ""Depending on the nature of the gateway, the destination/origination address is either derived from the content of the SMS TP-OA or TP-DA field, or the TP-OA/TP-DA field contains a generic gateway address and the to/from address is added at the beginning as shown above."" (which is supported here) - Multiple addreses separated by commas, no spaces, Subject field delimited by '()' or '##' and '#' Section 9.2.3.24.11 (which are NOT supported here)
 */
protected void extractEmailAddressFromMessageBody(){
  String[] parts=messageBody.split(""String_Node_Str"",2);
  if (parts.length < 2)   return;
  emailFrom=parts[0];
  emailBody=parts[1];
  isEmail=true;
}","/** 
 * Try to parse this message as an email gateway message There are two ways specified in TS 23.040 Section 3.8 : - SMS message ""may have its TP-PID set for internet electronic mail - MT SMS format: [<from-address><space>]<message> - ""Depending on the nature of the gateway, the destination/origination address is either derived from the content of the SMS TP-OA or TP-DA field, or the TP-OA/TP-DA field contains a generic gateway address and the to/from address is added at the beginning as shown above."" (which is supported here) - Multiple addreses separated by commas, no spaces, Subject field delimited by '()' or '##' and '#' Section 9.2.3.24.11 (which are NOT supported here)
 */
protected void extractEmailAddressFromMessageBody(){
  String[] parts=messageBody.split(""String_Node_Str"",2);
  if (parts.length < 2)   return;
  emailFrom=parts[0];
  emailBody=parts[1];
  isEmail=Telephony.Mms.isEmailAddress(emailFrom);
}"
22320,"private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkExt || checkBoth && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}","private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if ((checkExt || checkBoth) && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}"
22321,"boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mSurface != null && c.mAttachedHidden) {
        c.mAttachedHidden=false;
        c.performShowLocked();
        mLayoutNeeded=true;
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}","boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mSurface != null) {
          c.performShowLocked();
          mLayoutNeeded=true;
        }
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}"
22322,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        if (!app.killedBackground) {
          numHidden++;
          if (numHidden > MAX_HIDDEN_APPS) {
            Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
            EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
            app.killedBackground=true;
            Process.killProcess(app.pid);
          }
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}"
22323,"void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (killedBackground) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(killedBackground);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}"
22324,"/** 
 * Try to parse this message as an email gateway message There are two ways specified in TS 23.040 Section 3.8 : - SMS message ""may have its TP-PID set for internet electronic mail - MT SMS format: [<from-address><space>]<message> - ""Depending on the nature of the gateway, the destination/origination address is either derived from the content of the SMS TP-OA or TP-DA field, or the TP-OA/TP-DA field contains a generic gateway address and the to/from address is added at the beginning as shown above."" (which is supported here) - Multiple addreses separated by commas, no spaces, Subject field delimited by '()' or '##' and '#' Section 9.2.3.24.11 (which are NOT supported here)
 */
protected void extractEmailAddressFromMessageBody(){
  String[] parts=messageBody.split(""String_Node_Str"",2);
  if (parts.length < 2)   return;
  emailFrom=parts[0];
  emailBody=parts[1];
  isEmail=true;
}","/** 
 * Try to parse this message as an email gateway message There are two ways specified in TS 23.040 Section 3.8 : - SMS message ""may have its TP-PID set for internet electronic mail - MT SMS format: [<from-address><space>]<message> - ""Depending on the nature of the gateway, the destination/origination address is either derived from the content of the SMS TP-OA or TP-DA field, or the TP-OA/TP-DA field contains a generic gateway address and the to/from address is added at the beginning as shown above."" (which is supported here) - Multiple addreses separated by commas, no spaces, Subject field delimited by '()' or '##' and '#' Section 9.2.3.24.11 (which are NOT supported here)
 */
protected void extractEmailAddressFromMessageBody(){
  String[] parts=messageBody.split(""String_Node_Str"",2);
  if (parts.length < 2)   return;
  emailFrom=parts[0];
  emailBody=parts[1];
  isEmail=Telephony.Mms.isEmailAddress(emailFrom);
}"
22325,"boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mSurface != null && c.mAttachedHidden) {
        c.mAttachedHidden=false;
        c.performShowLocked();
        mLayoutNeeded=true;
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}","boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mSurface != null) {
          c.performShowLocked();
          mLayoutNeeded=true;
        }
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}"
22326,"boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mSurface != null && c.mAttachedHidden) {
        c.mAttachedHidden=false;
        c.performShowLocked();
        mLayoutNeeded=true;
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}","boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mSurface != null) {
          c.performShowLocked();
          mLayoutNeeded=true;
        }
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}"
22327,"private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkExt || checkBoth && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}","private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if ((checkExt || checkBoth) && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}"
22328,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        if (!app.killedBackground) {
          numHidden++;
          if (numHidden > MAX_HIDDEN_APPS) {
            Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
            EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
            app.killedBackground=true;
            Process.killProcess(app.pid);
          }
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}"
22329,"void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (killedBackground) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(killedBackground);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}"
22330,"void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}","void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}"
22331,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}"
22332,"public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ proc+ ""String_Node_Str""+ adj+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}","public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + proc + ""String_Node_Str""+ adj+ ""String_Node_Str""+ reason);
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}"
22333,"private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}","private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      EventLog.writeEvent(EventLogTags.AM_KILL,capp.pid,capp.processName,capp.setAdj,""String_Node_Str"" + proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}"
22334,"public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateLruProcessLocked(r.app,false,true);
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
22335,"void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}","void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}"
22336,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}"
22337,"public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ proc+ ""String_Node_Str""+ adj+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}","public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + proc + ""String_Node_Str""+ adj+ ""String_Node_Str""+ reason);
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}"
22338,"private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}","private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      EventLog.writeEvent(EventLogTags.AM_KILL,capp.pid,capp.processName,capp.setAdj,""String_Node_Str"" + proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}"
22339,"public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateLruProcessLocked(r.app,false,true);
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}"
22340,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        if (!app.killedBackground) {
          numHidden++;
          if (numHidden > MAX_HIDDEN_APPS) {
            Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
            EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
            app.killedBackground=true;
            Process.killProcess(app.pid);
          }
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}"
22341,"void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (killedBackground) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(killedBackground);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}"
22342,"boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mSurface != null && c.mAttachedHidden) {
        c.mAttachedHidden=false;
        c.performShowLocked();
        mLayoutNeeded=true;
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}","boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mSurface != null) {
          c.performShowLocked();
          mLayoutNeeded=true;
        }
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}"
22343,"private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkExt || checkBoth && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}","private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if ((checkExt || checkBoth) && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}"
22344,"/** 
 * Try to parse this message as an email gateway message There are two ways specified in TS 23.040 Section 3.8 : - SMS message ""may have its TP-PID set for internet electronic mail - MT SMS format: [<from-address><space>]<message> - ""Depending on the nature of the gateway, the destination/origination address is either derived from the content of the SMS TP-OA or TP-DA field, or the TP-OA/TP-DA field contains a generic gateway address and the to/from address is added at the beginning as shown above."" (which is supported here) - Multiple addreses separated by commas, no spaces, Subject field delimited by '()' or '##' and '#' Section 9.2.3.24.11 (which are NOT supported here)
 */
protected void extractEmailAddressFromMessageBody(){
  String[] parts=messageBody.split(""String_Node_Str"",2);
  if (parts.length < 2)   return;
  emailFrom=parts[0];
  emailBody=parts[1];
  isEmail=true;
}","/** 
 * Try to parse this message as an email gateway message There are two ways specified in TS 23.040 Section 3.8 : - SMS message ""may have its TP-PID set for internet electronic mail - MT SMS format: [<from-address><space>]<message> - ""Depending on the nature of the gateway, the destination/origination address is either derived from the content of the SMS TP-OA or TP-DA field, or the TP-OA/TP-DA field contains a generic gateway address and the to/from address is added at the beginning as shown above."" (which is supported here) - Multiple addreses separated by commas, no spaces, Subject field delimited by '()' or '##' and '#' Section 9.2.3.24.11 (which are NOT supported here)
 */
protected void extractEmailAddressFromMessageBody(){
  String[] parts=messageBody.split(""String_Node_Str"",2);
  if (parts.length < 2)   return;
  emailFrom=parts[0];
  emailBody=parts[1];
  isEmail=Telephony.Mms.isEmailAddress(emailFrom);
}"
22345,"public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_CANCEL,listener));
  }
}","public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_CANCEL,listener));
  }
}"
22346,"public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_START_LISTENING,new StartListeningArgs(recognizerIntent,listener)));
  }
}","public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_START_LISTENING,mInternalService.new StartListeningArgs(recognizerIntent,listener)));
  }
}"
22347,"public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_STOP_LISTENING,listener));
  }
}","public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_STOP_LISTENING,listener));
  }
}"
22348,"/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
}","/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
  mListener.mInternalListener=null;
}"
22349,"private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkExt || checkBoth && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}","private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if ((checkExt || checkBoth) && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}"
22350,"/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  mBluetoothHeadsetConnected=false;
  mBluetoothHeadset=new BluetoothHeadset(context,mBluetoothHeadsetServiceListener);
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
  intentFilter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
  intentFilter=new IntentFilter(Intent.ACTION_MEDIA_BUTTON);
  intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
  context.registerReceiver(mMediaButtonReceiver,intentFilter);
}","/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  mRingerModeMutedStreams=0;
  setRingerModeInt(getRingerMode(),false);
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  mBluetoothHeadsetConnected=false;
  mBluetoothHeadset=new BluetoothHeadset(context,mBluetoothHeadsetServiceListener);
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
  intentFilter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
  intentFilter=new IntentFilter(Intent.ACTION_MEDIA_BUTTON);
  intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
  context.registerReceiver(mMediaButtonReceiver,intentFilter);
}"
22351,"/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  mBluetoothHeadsetConnected=false;
  mBluetoothHeadset=new BluetoothHeadset(context,mBluetoothHeadsetServiceListener);
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
  intentFilter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
  intentFilter=new IntentFilter(Intent.ACTION_MEDIA_BUTTON);
  intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
  context.registerReceiver(mMediaButtonReceiver,intentFilter);
}","/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  mRingerModeMutedStreams=0;
  setRingerModeInt(getRingerMode(),false);
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  mBluetoothHeadsetConnected=false;
  mBluetoothHeadset=new BluetoothHeadset(context,mBluetoothHeadsetServiceListener);
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
  intentFilter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
  intentFilter=new IntentFilter(Intent.ACTION_MEDIA_BUTTON);
  intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
  context.registerReceiver(mMediaButtonReceiver,intentFilter);
}"
22352,"/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
}","/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
  if ((mPrivateFlags & AWAKEN_SCROLL_BARS_ON_ATTACH) != 0) {
    initialAwakenScrollBars();
    mPrivateFlags&=~AWAKEN_SCROLL_BARS_ON_ATTACH;
  }
}"
22353,"/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
}","/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
  if (visibility == VISIBLE) {
    if (mAttachInfo != null) {
      initialAwakenScrollBars();
    }
 else {
      mPrivateFlags|=AWAKEN_SCROLL_BARS_ON_ATTACH;
    }
  }
}"
22354,"/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
}","/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
  if (visibility == VISIBLE) {
    initialAwakenScrollBars();
  }
}"
22355,"private void makeA2dpDeviceUnavailableLater(String address){
  mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
  Message msg=mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT,address);
  mAudioHandler.sendMessageDelayed(msg,BTA2DP_DOCK_TIMEOUT_MILLIS);
}","private void makeA2dpDeviceUnavailableLater(String address){
  AudioSystem.setParameters(""String_Node_Str"");
  mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
  Message msg=mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT,address);
  mAudioHandler.sendMessageDelayed(msg,BTA2DP_DOCK_TIMEOUT_MILLIS);
}"
22356,"/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
}","/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
  if ((mPrivateFlags & AWAKEN_SCROLL_BARS_ON_ATTACH) != 0) {
    initialAwakenScrollBars();
    mPrivateFlags&=~AWAKEN_SCROLL_BARS_ON_ATTACH;
  }
}"
22357,"/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
}","/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
  if (visibility == VISIBLE) {
    if (mAttachInfo != null) {
      initialAwakenScrollBars();
    }
 else {
      mPrivateFlags|=AWAKEN_SCROLL_BARS_ON_ATTACH;
    }
  }
}"
22358,"/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
}","/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
  if (visibility == VISIBLE) {
    initialAwakenScrollBars();
  }
}"
22359,"private void makeA2dpDeviceUnavailableLater(String address){
  mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
  Message msg=mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT,address);
  mAudioHandler.sendMessageDelayed(msg,BTA2DP_DOCK_TIMEOUT_MILLIS);
}","private void makeA2dpDeviceUnavailableLater(String address){
  AudioSystem.setParameters(""String_Node_Str"");
  mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
  Message msg=mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT,address);
  mAudioHandler.sendMessageDelayed(msg,BTA2DP_DOCK_TIMEOUT_MILLIS);
}"
22360,"/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  mBluetoothHeadsetConnected=false;
  mBluetoothHeadset=new BluetoothHeadset(context,mBluetoothHeadsetServiceListener);
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
  intentFilter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
  intentFilter=new IntentFilter(Intent.ACTION_MEDIA_BUTTON);
  intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
  context.registerReceiver(mMediaButtonReceiver,intentFilter);
}","/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  mRingerModeMutedStreams=0;
  setRingerModeInt(getRingerMode(),false);
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  mBluetoothHeadsetConnected=false;
  mBluetoothHeadset=new BluetoothHeadset(context,mBluetoothHeadsetServiceListener);
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
  intentFilter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
  intentFilter=new IntentFilter(Intent.ACTION_MEDIA_BUTTON);
  intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
  context.registerReceiver(mMediaButtonReceiver,intentFilter);
}"
22361,"/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
}","/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
  if ((mPrivateFlags & AWAKEN_SCROLL_BARS_ON_ATTACH) != 0) {
    initialAwakenScrollBars();
    mPrivateFlags&=~AWAKEN_SCROLL_BARS_ON_ATTACH;
  }
}"
22362,"/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
}","/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
  if (visibility == VISIBLE) {
    if (mAttachInfo != null) {
      initialAwakenScrollBars();
    }
 else {
      mPrivateFlags|=AWAKEN_SCROLL_BARS_ON_ATTACH;
    }
  }
}"
22363,"/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
}","/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
  if (visibility == VISIBLE) {
    initialAwakenScrollBars();
  }
}"
22364,"private void makeA2dpDeviceUnavailableLater(String address){
  mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
  Message msg=mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT,address);
  mAudioHandler.sendMessageDelayed(msg,BTA2DP_DOCK_TIMEOUT_MILLIS);
}","private void makeA2dpDeviceUnavailableLater(String address){
  AudioSystem.setParameters(""String_Node_Str"");
  mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
  Message msg=mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT,address);
  mAudioHandler.sendMessageDelayed(msg,BTA2DP_DOCK_TIMEOUT_MILLIS);
}"
22365,"/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
}","/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
  if ((mPrivateFlags & AWAKEN_SCROLL_BARS_ON_ATTACH) != 0) {
    initialAwakenScrollBars();
    mPrivateFlags&=~AWAKEN_SCROLL_BARS_ON_ATTACH;
  }
}"
22366,"/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
}","/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
  if (visibility == VISIBLE) {
    if (mAttachInfo != null) {
      initialAwakenScrollBars();
    }
 else {
      mPrivateFlags|=AWAKEN_SCROLL_BARS_ON_ATTACH;
    }
  }
}"
22367,"/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
}","/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
  if (visibility == VISIBLE) {
    initialAwakenScrollBars();
  }
}"
22368,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    mPlayer.setOnCompletionListener(this);
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}"
22369,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    mPlayer.setOnCompletionListener(this);
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}"
22370,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    mPlayer.setOnCompletionListener(this);
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}"
22371,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    mPlayer.setOnCompletionListener(this);
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}"
22372,"/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (r.frontOfTask && index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      next.frontOfTask=true;
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}","/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      if (r.frontOfTask) {
        next.frontOfTask=true;
      }
      if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
        next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
      }
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}"
22373,"/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (r.frontOfTask && index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      next.frontOfTask=true;
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}","/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      if (r.frontOfTask) {
        next.frontOfTask=true;
      }
      if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
        next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
      }
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}"
22374,"/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (r.frontOfTask && index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      next.frontOfTask=true;
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}","/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      if (r.frontOfTask) {
        next.frontOfTask=true;
      }
      if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
        next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
      }
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}"
22375,"/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (r.frontOfTask && index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      next.frontOfTask=true;
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}","/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      if (r.frontOfTask) {
        next.frontOfTask=true;
      }
      if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
        next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
      }
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}"
22376,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    ce.mListener=this;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}"
22377,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    streamState.setLastAudibleIndex(index);
    sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      if (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0) {
        sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
      }
 else {
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
      }
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    if (index != 0) {
      streamState.setLastAudibleIndex(index);
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}"
22378,"/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}","/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
 else {
      adjustVolumeIndex=false;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}"
22379,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    streamState.setLastAudibleIndex(index);
    sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      if (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0) {
        sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
      }
 else {
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
      }
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    if (index != 0) {
      streamState.setLastAudibleIndex(index);
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}"
22380,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    streamState.setLastAudibleIndex(index);
    sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      if (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0) {
        sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
      }
 else {
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
      }
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    if (index != 0) {
      streamState.setLastAudibleIndex(index);
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}"
22381,"/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}","/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
 else {
      adjustVolumeIndex=false;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}"
22382,"/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}","/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
 else {
      adjustVolumeIndex=false;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}"
22383,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    ce.mListener=this;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}"
22384,"public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}","public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    IPackageManager pm=ActivityThread.getPackageManager();
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        if ((flags & ActivityManager.RECENT_IGNORE_UNAVAILABLE) != 0) {
          try {
            if (rti.origActivity != null) {
              if (pm.getActivityInfo(rti.origActivity,0) == null) {
                continue;
              }
            }
 else             if (rti.baseIntent != null) {
              if (pm.queryIntentActivities(rti.baseIntent,null,0) == null) {
                continue;
              }
            }
          }
 catch (          RemoteException e) {
          }
        }
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}"
22385,"public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}","public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    IPackageManager pm=ActivityThread.getPackageManager();
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        if ((flags & ActivityManager.RECENT_IGNORE_UNAVAILABLE) != 0) {
          try {
            if (rti.origActivity != null) {
              if (pm.getActivityInfo(rti.origActivity,0) == null) {
                continue;
              }
            }
 else             if (rti.baseIntent != null) {
              if (pm.queryIntentActivities(rti.baseIntent,null,0) == null) {
                continue;
              }
            }
          }
 catch (          RemoteException e) {
          }
        }
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}"
22386,"public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}","public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    IPackageManager pm=ActivityThread.getPackageManager();
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        if ((flags & ActivityManager.RECENT_IGNORE_UNAVAILABLE) != 0) {
          try {
            if (rti.origActivity != null) {
              if (pm.getActivityInfo(rti.origActivity,0) == null) {
                continue;
              }
            }
 else             if (rti.baseIntent != null) {
              if (pm.queryIntentActivities(rti.baseIntent,null,0) == null) {
                continue;
              }
            }
          }
 catch (          RemoteException e) {
          }
        }
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}"
22387,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + w.mRootToken.waitingToShow + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ w.mRootToken.hidden+ ""String_Node_Str""+ w.mViewVisibility);
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}"
22388,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && (w.mOrientationChanging || !w.isDrawnLw())) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}"
22389,"/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && !mDrawPending && !mCommitDrawPending;
}","/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.  Note that this returns true if the orientation is changing even if the window hasn't redrawn because we don't want to stop things from executing during that time.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending));
}"
22390,"/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && !mDrawPending && !mCommitDrawPending && !mExiting && !mDestroying;
}","/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending)) && !mExiting && !mDestroying;
}"
22391,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    ce.mListener=this;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}"
22392,"public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}","public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    IPackageManager pm=ActivityThread.getPackageManager();
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        if ((flags & ActivityManager.RECENT_IGNORE_UNAVAILABLE) != 0) {
          try {
            if (rti.origActivity != null) {
              if (pm.getActivityInfo(rti.origActivity,0) == null) {
                continue;
              }
            }
 else             if (rti.baseIntent != null) {
              if (pm.queryIntentActivities(rti.baseIntent,null,0) == null) {
                continue;
              }
            }
          }
 catch (          RemoteException e) {
          }
        }
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}"
22393,"/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}","/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
 else {
      adjustVolumeIndex=false;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}"
22394,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + w.mRootToken.waitingToShow + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ w.mRootToken.hidden+ ""String_Node_Str""+ w.mViewVisibility);
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}"
22395,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && (w.mOrientationChanging || !w.isDrawnLw())) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}"
22396,"/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && !mDrawPending && !mCommitDrawPending;
}","/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.  Note that this returns true if the orientation is changing even if the window hasn't redrawn because we don't want to stop things from executing during that time.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending));
}"
22397,"/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && !mDrawPending && !mCommitDrawPending && !mExiting && !mDestroying;
}","/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending)) && !mExiting && !mDestroying;
}"
22398,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + w.mRootToken.waitingToShow + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ w.mRootToken.hidden+ ""String_Node_Str""+ w.mViewVisibility);
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}"
22399,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && (w.mOrientationChanging || !w.isDrawnLw())) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}"
22400,"/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && !mDrawPending && !mCommitDrawPending;
}","/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.  Note that this returns true if the orientation is changing even if the window hasn't redrawn because we don't want to stop things from executing during that time.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending));
}"
22401,"/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && !mDrawPending && !mCommitDrawPending && !mExiting && !mDestroying;
}","/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending)) && !mExiting && !mDestroying;
}"
22402,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}"
22403,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}"
22404,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}"
22405,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}"
22406,"private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadIntegerSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,30 * 60 * 1000);
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}","private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,Integer.toString(30 * 60 * 1000));
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}"
22407,"private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadIntegerSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,30 * 60 * 1000);
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}","private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,Integer.toString(30 * 60 * 1000));
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}"
22408,"private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadIntegerSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,30 * 60 * 1000);
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}","private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,Integer.toString(30 * 60 * 1000));
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}"
22409,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}"
22410,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}"
22411,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + w.mRootToken.waitingToShow + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ w.mRootToken.hidden+ ""String_Node_Str""+ w.mViewVisibility);
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}"
22412,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && (w.mOrientationChanging || !w.isDrawnLw())) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}"
22413,"/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && !mDrawPending && !mCommitDrawPending;
}","/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.  Note that this returns true if the orientation is changing even if the window hasn't redrawn because we don't want to stop things from executing during that time.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending));
}"
22414,"/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && !mDrawPending && !mCommitDrawPending && !mExiting && !mDestroying;
}","/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending)) && !mExiting && !mDestroying;
}"
22415,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}"
22416,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}"
22417,"private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadIntegerSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,30 * 60 * 1000);
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}","private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,Integer.toString(30 * 60 * 1000));
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}"
22418,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}"
22419,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}"
22420,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  removeFocusStackEntry(clientId,true);
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22421,"public void unregisterAudioFocusClient(String clientId){
  removeFocusStackEntry(clientId,false);
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}"
22422,"private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadIntegerSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,30 * 60 * 1000);
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}","private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,Integer.toString(30 * 60 * 1000));
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}"
22423,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  removeFocusStackEntry(clientId,true);
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22424,"public void unregisterAudioFocusClient(String clientId){
  removeFocusStackEntry(clientId,false);
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}"
22425,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  removeFocusStackEntry(clientId,true);
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22426,"public void unregisterAudioFocusClient(String clientId){
  removeFocusStackEntry(clientId,false);
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}"
22427,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    ce.mListener=this;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}"
22428,"/** 
 * Something in the current window tells us we need to change the touch mode.  For example, we are not in touch mode, and the user touches the screen. If the touch mode has changed, tell the window manager, and handle it locally.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
boolean ensureTouchMode(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  try {
    sWindowSession.setInTouchMode(inTouchMode);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
  return ensureTouchModeLocally(inTouchMode,true);
}","/** 
 * Something in the current window tells us we need to change the touch mode.  For example, we are not in touch mode, and the user touches the screen. If the touch mode has changed, tell the window manager, and handle it locally.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
boolean ensureTouchMode(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  try {
    sWindowSession.setInTouchMode(inTouchMode);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
  return ensureTouchModeLocally(inTouchMode);
}"
22429,"/** 
 * Ensure that the touch mode for this window is set, and if it is changing, take the appropriate action.
 * @param inTouchMode Whether we want to be in touch mode.
 * @param dispatchFocus
 * @return True if the touch mode changed and focus changed was changed as a result
 */
private boolean ensureTouchModeLocally(boolean inTouchMode,boolean dispatchFocus){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  mAttachInfo.mInTouchMode=inTouchMode;
  mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
  return dispatchFocus && (inTouchMode) ? enterTouchMode() : leaveTouchMode();
}","/** 
 * Ensure that the touch mode for this window is set, and if it is changing, take the appropriate action.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
private boolean ensureTouchModeLocally(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  mAttachInfo.mInTouchMode=inTouchMode;
  mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
  return (inTouchMode) ? enterTouchMode() : leaveTouchMode();
}"
22430,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mTranslucentWindow=lp.format != PixelFormat.OPAQUE;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode,false);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    try {
      boolean hadSurface=mSurface.isValid();
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(""String_Node_Str"",""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0,true);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (mFirst) {
      if (mAddedTouchMode) {
        enterTouchMode();
      }
 else {
        leaveTouchMode();
      }
    }
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(""String_Node_Str"",""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mTranslucentWindow=lp.format != PixelFormat.OPAQUE;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    try {
      boolean hadSurface=mSurface.isValid();
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(""String_Node_Str"",""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(""String_Node_Str"",""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}"
22431,"/** 
 * You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event){
  mTempRect.setEmpty();
  if (!canScroll()) {
    if (isFocused()) {
      View currentFocused=findFocus();
      if (currentFocused == this)       currentFocused=null;
      View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,View.FOCUS_DOWN);
      return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
    }
    return false;
  }
  boolean handled=false;
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (!event.isAltPressed()) {
        handled=arrowScroll(View.FOCUS_UP);
      }
 else {
        handled=fullScroll(View.FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (!event.isAltPressed()) {
    handled=arrowScroll(View.FOCUS_DOWN);
  }
 else {
    handled=fullScroll(View.FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_SPACE:
pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
break;
}
}
return handled;
}","/** 
 * You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event){
  mTempRect.setEmpty();
  if (!canScroll()) {
    if (isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK) {
      View currentFocused=findFocus();
      if (currentFocused == this)       currentFocused=null;
      View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,View.FOCUS_DOWN);
      return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
    }
    return false;
  }
  boolean handled=false;
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (!event.isAltPressed()) {
        handled=arrowScroll(View.FOCUS_UP);
      }
 else {
        handled=fullScroll(View.FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (!event.isAltPressed()) {
    handled=arrowScroll(View.FOCUS_DOWN);
  }
 else {
    handled=fullScroll(View.FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_SPACE:
pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
break;
}
}
return handled;
}"
22432,"/** 
 * Something in the current window tells us we need to change the touch mode.  For example, we are not in touch mode, and the user touches the screen. If the touch mode has changed, tell the window manager, and handle it locally.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
boolean ensureTouchMode(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  try {
    sWindowSession.setInTouchMode(inTouchMode);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
  return ensureTouchModeLocally(inTouchMode,true);
}","/** 
 * Something in the current window tells us we need to change the touch mode.  For example, we are not in touch mode, and the user touches the screen. If the touch mode has changed, tell the window manager, and handle it locally.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
boolean ensureTouchMode(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  try {
    sWindowSession.setInTouchMode(inTouchMode);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
  return ensureTouchModeLocally(inTouchMode);
}"
22433,"/** 
 * Ensure that the touch mode for this window is set, and if it is changing, take the appropriate action.
 * @param inTouchMode Whether we want to be in touch mode.
 * @param dispatchFocus
 * @return True if the touch mode changed and focus changed was changed as a result
 */
private boolean ensureTouchModeLocally(boolean inTouchMode,boolean dispatchFocus){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  mAttachInfo.mInTouchMode=inTouchMode;
  mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
  return dispatchFocus && (inTouchMode) ? enterTouchMode() : leaveTouchMode();
}","/** 
 * Ensure that the touch mode for this window is set, and if it is changing, take the appropriate action.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
private boolean ensureTouchModeLocally(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  mAttachInfo.mInTouchMode=inTouchMode;
  mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
  return (inTouchMode) ? enterTouchMode() : leaveTouchMode();
}"
22434,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mTranslucentWindow=lp.format != PixelFormat.OPAQUE;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode,false);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    try {
      boolean hadSurface=mSurface.isValid();
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(""String_Node_Str"",""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0,true);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (mFirst) {
      if (mAddedTouchMode) {
        enterTouchMode();
      }
 else {
        leaveTouchMode();
      }
    }
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(""String_Node_Str"",""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mTranslucentWindow=lp.format != PixelFormat.OPAQUE;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    try {
      boolean hadSurface=mSurface.isValid();
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(""String_Node_Str"",""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(""String_Node_Str"",""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}"
22435,"/** 
 * You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event){
  mTempRect.setEmpty();
  if (!canScroll()) {
    if (isFocused()) {
      View currentFocused=findFocus();
      if (currentFocused == this)       currentFocused=null;
      View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,View.FOCUS_DOWN);
      return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
    }
    return false;
  }
  boolean handled=false;
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (!event.isAltPressed()) {
        handled=arrowScroll(View.FOCUS_UP);
      }
 else {
        handled=fullScroll(View.FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (!event.isAltPressed()) {
    handled=arrowScroll(View.FOCUS_DOWN);
  }
 else {
    handled=fullScroll(View.FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_SPACE:
pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
break;
}
}
return handled;
}","/** 
 * You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event){
  mTempRect.setEmpty();
  if (!canScroll()) {
    if (isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK) {
      View currentFocused=findFocus();
      if (currentFocused == this)       currentFocused=null;
      View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,View.FOCUS_DOWN);
      return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
    }
    return false;
  }
  boolean handled=false;
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (!event.isAltPressed()) {
        handled=arrowScroll(View.FOCUS_UP);
      }
 else {
        handled=fullScroll(View.FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (!event.isAltPressed()) {
    handled=arrowScroll(View.FOCUS_DOWN);
  }
 else {
    handled=fullScroll(View.FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_SPACE:
pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
break;
}
}
return handled;
}"
22436,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  removeFocusStackEntry(clientId,true);
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22437,"public void unregisterAudioFocusClient(String clientId){
  removeFocusStackEntry(clientId,false);
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}"
22438,"/** 
 * Something in the current window tells us we need to change the touch mode.  For example, we are not in touch mode, and the user touches the screen. If the touch mode has changed, tell the window manager, and handle it locally.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
boolean ensureTouchMode(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  try {
    sWindowSession.setInTouchMode(inTouchMode);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
  return ensureTouchModeLocally(inTouchMode,true);
}","/** 
 * Something in the current window tells us we need to change the touch mode.  For example, we are not in touch mode, and the user touches the screen. If the touch mode has changed, tell the window manager, and handle it locally.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
boolean ensureTouchMode(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  try {
    sWindowSession.setInTouchMode(inTouchMode);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
  return ensureTouchModeLocally(inTouchMode);
}"
22439,"/** 
 * Ensure that the touch mode for this window is set, and if it is changing, take the appropriate action.
 * @param inTouchMode Whether we want to be in touch mode.
 * @param dispatchFocus
 * @return True if the touch mode changed and focus changed was changed as a result
 */
private boolean ensureTouchModeLocally(boolean inTouchMode,boolean dispatchFocus){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  mAttachInfo.mInTouchMode=inTouchMode;
  mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
  return dispatchFocus && (inTouchMode) ? enterTouchMode() : leaveTouchMode();
}","/** 
 * Ensure that the touch mode for this window is set, and if it is changing, take the appropriate action.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
private boolean ensureTouchModeLocally(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  mAttachInfo.mInTouchMode=inTouchMode;
  mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
  return (inTouchMode) ? enterTouchMode() : leaveTouchMode();
}"
22440,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mTranslucentWindow=lp.format != PixelFormat.OPAQUE;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode,false);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    try {
      boolean hadSurface=mSurface.isValid();
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(""String_Node_Str"",""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0,true);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (mFirst) {
      if (mAddedTouchMode) {
        enterTouchMode();
      }
 else {
        leaveTouchMode();
      }
    }
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(""String_Node_Str"",""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mTranslucentWindow=lp.format != PixelFormat.OPAQUE;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    try {
      boolean hadSurface=mSurface.isValid();
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(""String_Node_Str"",""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(""String_Node_Str"",""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}"
22441,"/** 
 * You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event){
  mTempRect.setEmpty();
  if (!canScroll()) {
    if (isFocused()) {
      View currentFocused=findFocus();
      if (currentFocused == this)       currentFocused=null;
      View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,View.FOCUS_DOWN);
      return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
    }
    return false;
  }
  boolean handled=false;
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (!event.isAltPressed()) {
        handled=arrowScroll(View.FOCUS_UP);
      }
 else {
        handled=fullScroll(View.FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (!event.isAltPressed()) {
    handled=arrowScroll(View.FOCUS_DOWN);
  }
 else {
    handled=fullScroll(View.FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_SPACE:
pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
break;
}
}
return handled;
}","/** 
 * You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event){
  mTempRect.setEmpty();
  if (!canScroll()) {
    if (isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK) {
      View currentFocused=findFocus();
      if (currentFocused == this)       currentFocused=null;
      View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,View.FOCUS_DOWN);
      return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
    }
    return false;
  }
  boolean handled=false;
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (!event.isAltPressed()) {
        handled=arrowScroll(View.FOCUS_UP);
      }
 else {
        handled=fullScroll(View.FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (!event.isAltPressed()) {
    handled=arrowScroll(View.FOCUS_DOWN);
  }
 else {
    handled=fullScroll(View.FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_SPACE:
pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
break;
}
}
return handled;
}"
22442,"private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[]){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras);
  }
}","private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[],IIntentReceiver finishedReceiver){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras,finishedReceiver);
  }
}"
22443,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras,null);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras,null);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}"
22444,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}"
22445,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22446,"private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr);
  }
  Runtime.getRuntime().gc();
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}","private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr,new IIntentReceiver.Stub(){
      public void performReceive(      Intent intent,      int resultCode,      String data,      Bundle extras,      boolean ordered,      boolean sticky) throws RemoteException {
        Runtime.getRuntime().gc();
      }
    }
);
  }
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}"
22447,"public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}","public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}"
22448,"private static final void sendPackageBroadcast(String action,String pkg,Bundle extras){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,null,0,null,null,null,false,false);
    }
 catch (    RemoteException ex) {
    }
  }
}","private static final void sendPackageBroadcast(String action,String pkg,Bundle extras,IIntentReceiver finishedReceiver){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,finishedReceiver,0,null,null,null,finishedReceiver != null,false);
    }
 catch (    RemoteException ex) {
    }
  }
}"
22449,"private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras);
}","private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras,null);
}"
22450,"private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}","private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}"
22451,"void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras);
  }
}","void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras,null);
  }
}"
22452,"/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}","/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}"
22453,"private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[]){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras);
  }
}","private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[],IIntentReceiver finishedReceiver){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras,finishedReceiver);
  }
}"
22454,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras,null);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras,null);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}"
22455,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}"
22456,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22457,"private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr);
  }
  Runtime.getRuntime().gc();
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}","private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr,new IIntentReceiver.Stub(){
      public void performReceive(      Intent intent,      int resultCode,      String data,      Bundle extras,      boolean ordered,      boolean sticky) throws RemoteException {
        Runtime.getRuntime().gc();
      }
    }
);
  }
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}"
22458,"public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}","public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}"
22459,"private static final void sendPackageBroadcast(String action,String pkg,Bundle extras){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,null,0,null,null,null,false,false);
    }
 catch (    RemoteException ex) {
    }
  }
}","private static final void sendPackageBroadcast(String action,String pkg,Bundle extras,IIntentReceiver finishedReceiver){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,finishedReceiver,0,null,null,null,finishedReceiver != null,false);
    }
 catch (    RemoteException ex) {
    }
  }
}"
22460,"private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras);
}","private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras,null);
}"
22461,"private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}","private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}"
22462,"void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras);
  }
}","void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras,null);
  }
}"
22463,"/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}","/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}"
22464,"private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[]){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras);
  }
}","private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[],IIntentReceiver finishedReceiver){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras,finishedReceiver);
  }
}"
22465,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras,null);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras,null);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}"
22466,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}"
22467,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22468,"private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr);
  }
  Runtime.getRuntime().gc();
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}","private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr,new IIntentReceiver.Stub(){
      public void performReceive(      Intent intent,      int resultCode,      String data,      Bundle extras,      boolean ordered,      boolean sticky) throws RemoteException {
        Runtime.getRuntime().gc();
      }
    }
);
  }
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}"
22469,"public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}","public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}"
22470,"private static final void sendPackageBroadcast(String action,String pkg,Bundle extras){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,null,0,null,null,null,false,false);
    }
 catch (    RemoteException ex) {
    }
  }
}","private static final void sendPackageBroadcast(String action,String pkg,Bundle extras,IIntentReceiver finishedReceiver){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,finishedReceiver,0,null,null,null,finishedReceiver != null,false);
    }
 catch (    RemoteException ex) {
    }
  }
}"
22471,"private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras);
}","private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras,null);
}"
22472,"private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}","private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}"
22473,"void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras);
  }
}","void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras,null);
  }
}"
22474,"/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}","/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}"
22475,"private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[]){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras);
  }
}","private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[],IIntentReceiver finishedReceiver){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras,finishedReceiver);
  }
}"
22476,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras,null);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras,null);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}"
22477,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}"
22478,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22479,"private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr);
  }
  Runtime.getRuntime().gc();
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}","private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr,new IIntentReceiver.Stub(){
      public void performReceive(      Intent intent,      int resultCode,      String data,      Bundle extras,      boolean ordered,      boolean sticky) throws RemoteException {
        Runtime.getRuntime().gc();
      }
    }
);
  }
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}"
22480,"public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}","public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}"
22481,"private static final void sendPackageBroadcast(String action,String pkg,Bundle extras){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,null,0,null,null,null,false,false);
    }
 catch (    RemoteException ex) {
    }
  }
}","private static final void sendPackageBroadcast(String action,String pkg,Bundle extras,IIntentReceiver finishedReceiver){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,finishedReceiver,0,null,null,null,finishedReceiver != null,false);
    }
 catch (    RemoteException ex) {
    }
  }
}"
22482,"private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras);
}","private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras,null);
}"
22483,"private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}","private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}"
22484,"void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras);
  }
}","void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras,null);
  }
}"
22485,"/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}","/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}"
22486,"private static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}","static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}"
22487,"private static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}","static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}"
22488,"private static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}","static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}"
22489,"private static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}","static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}"
22490,"private static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}","static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}"
22491,"@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAccounts) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAccounts) {
      writeStatisticsLocked();
    }
  }
}","@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAuthorities) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAuthorities) {
      writeStatisticsLocked();
    }
  }
}"
22492,"@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAccounts) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAccounts) {
      writeStatisticsLocked();
    }
  }
}","@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAuthorities) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAuthorities) {
      writeStatisticsLocked();
    }
  }
}"
22493,"@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE,networkInfo.getState(),NetworkState.DO_NOTHING,State.DISCONNECTED);
  networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
    assertTrue(false);
  }
}","@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  waitForNetworkState(ConnectivityManager.TYPE_MOBILE,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
}"
22494,"@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAccounts) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAccounts) {
      writeStatisticsLocked();
    }
  }
}","@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAuthorities) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAuthorities) {
      writeStatisticsLocked();
    }
  }
}"
22495,"@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAccounts) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAccounts) {
      writeStatisticsLocked();
    }
  }
}","@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAuthorities) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAuthorities) {
      writeStatisticsLocked();
    }
  }
}"
22496,"@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAccounts) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAccounts) {
      writeStatisticsLocked();
    }
  }
}","@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAuthorities) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAuthorities) {
      writeStatisticsLocked();
    }
  }
}"
22497,"@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE,networkInfo.getState(),NetworkState.DO_NOTHING,State.DISCONNECTED);
  networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
    assertTrue(false);
  }
}","@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  waitForNetworkState(ConnectivityManager.TYPE_MOBILE,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
}"
22498,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY >= 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY <= 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}"
22499,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY >= 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY <= 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}"
22500,"@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE,networkInfo.getState(),NetworkState.DO_NOTHING,State.DISCONNECTED);
  networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
    assertTrue(false);
  }
}","@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  waitForNetworkState(ConnectivityManager.TYPE_MOBILE,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
}"
22501,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY >= 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY <= 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}"
22502,"@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE,networkInfo.getState(),NetworkState.DO_NOTHING,State.DISCONNECTED);
  networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
    assertTrue(false);
  }
}","@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  waitForNetworkState(ConnectivityManager.TYPE_MOBILE,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
}"
22503,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY >= 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY <= 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}"
22504,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY >= 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY <= 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}"
22505,"void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}","void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mInternalSdkPlatform));
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mExternalSdkPlatform));
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}"
22506,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
22507,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    updatePermissionsLP(null,null,true,false);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22508,"boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}","boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mInternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}"
22509,"void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}","void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mInternalSdkPlatform));
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mExternalSdkPlatform));
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}"
22510,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
22511,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    updatePermissionsLP(null,null,true,false);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22512,"boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}","boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mInternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}"
22513,"void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}","void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mInternalSdkPlatform));
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mExternalSdkPlatform));
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}"
22514,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
22515,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    updatePermissionsLP(null,null,true,false);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22516,"boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}","boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mInternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}"
22517,"void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}","void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mInternalSdkPlatform));
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mExternalSdkPlatform));
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}"
22518,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
22519,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    updatePermissionsLP(null,null,true,false);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22520,"boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}","boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mInternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}"
22521,"@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE,networkInfo.getState(),NetworkState.DO_NOTHING,State.DISCONNECTED);
  networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
    assertTrue(false);
  }
}","@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  waitForNetworkState(ConnectivityManager.TYPE_MOBILE,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
}"
22522,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}"
22523,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}"
22524,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_neverEncrypt,false)) {
    ai.flags|=ApplicationInfo.FLAG_NEVER_ENCRYPT;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_neverEncrypt,false)) {
    ai.flags|=ApplicationInfo.FLAG_NEVER_ENCRYPT;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}"
22525,"boolean computeNewConfigurationLocked(Configuration config){
  if (mDisplay == null) {
    return false;
  }
  mQueue.getInputConfiguration(config);
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int orientation=Configuration.ORIENTATION_SQUARE;
  if (dw < dh) {
    orientation=Configuration.ORIENTATION_PORTRAIT;
  }
 else   if (dw > dh) {
    orientation=Configuration.ORIENTATION_LANDSCAPE;
  }
  config.orientation=orientation;
  DisplayMetrics dm=new DisplayMetrics();
  mDisplay.getMetrics(dm);
  CompatibilityInfo.updateCompatibleScreenFrame(dm,orientation,mCompatibleScreenFrame);
  if (mScreenLayout == Configuration.SCREENLAYOUT_SIZE_UNDEFINED) {
    int longSize=dw;
    int shortSize=dh;
    if (longSize < shortSize) {
      int tmp=longSize;
      longSize=shortSize;
      shortSize=tmp;
    }
    longSize=(int)(longSize / dm.density);
    shortSize=(int)(shortSize / dm.density);
    if (longSize < 470) {
      mScreenLayout=Configuration.SCREENLAYOUT_SIZE_SMALL | Configuration.SCREENLAYOUT_LONG_NO;
    }
 else {
      if (longSize > 640 && shortSize >= 480) {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_LARGE;
      }
 else {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_NORMAL;
        if (shortSize > 321 || longSize > 570) {
          mScreenLayout|=Configuration.SCREENLAYOUT_COMPAT_NEEDED;
        }
      }
      if (((longSize * 3) / 5) >= (shortSize - 1)) {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_YES;
      }
 else {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_NO;
      }
    }
  }
  config.screenLayout=mScreenLayout;
  config.keyboardHidden=Configuration.KEYBOARDHIDDEN_NO;
  config.hardKeyboardHidden=Configuration.HARDKEYBOARDHIDDEN_NO;
  mPolicy.adjustConfigurationLw(config);
  return true;
}","boolean computeNewConfigurationLocked(Configuration config){
  if (mDisplay == null) {
    return false;
  }
  mQueue.getInputConfiguration(config);
  final boolean rotated=(mRotation == Surface.ROTATION_90 || mRotation == Surface.ROTATION_270);
  final int dw=rotated ? mInitialDisplayHeight : mInitialDisplayWidth;
  final int dh=rotated ? mInitialDisplayWidth : mInitialDisplayHeight;
  int orientation=Configuration.ORIENTATION_SQUARE;
  if (dw < dh) {
    orientation=Configuration.ORIENTATION_PORTRAIT;
  }
 else   if (dw > dh) {
    orientation=Configuration.ORIENTATION_LANDSCAPE;
  }
  config.orientation=orientation;
  DisplayMetrics dm=new DisplayMetrics();
  mDisplay.getMetrics(dm);
  CompatibilityInfo.updateCompatibleScreenFrame(dm,orientation,mCompatibleScreenFrame);
  if (mScreenLayout == Configuration.SCREENLAYOUT_SIZE_UNDEFINED) {
    int longSize=dw;
    int shortSize=dh;
    if (longSize < shortSize) {
      int tmp=longSize;
      longSize=shortSize;
      shortSize=tmp;
    }
    longSize=(int)(longSize / dm.density);
    shortSize=(int)(shortSize / dm.density);
    if (longSize < 470) {
      mScreenLayout=Configuration.SCREENLAYOUT_SIZE_SMALL | Configuration.SCREENLAYOUT_LONG_NO;
    }
 else {
      if (longSize > 640 && shortSize >= 480) {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_LARGE;
      }
 else {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_NORMAL;
        if (shortSize > 321 || longSize > 570) {
          mScreenLayout|=Configuration.SCREENLAYOUT_COMPAT_NEEDED;
        }
      }
      if (((longSize * 3) / 5) >= (shortSize - 1)) {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_YES;
      }
 else {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_NO;
      }
    }
  }
  config.screenLayout=mScreenLayout;
  config.keyboardHidden=Configuration.KEYBOARDHIDDEN_NO;
  config.hardKeyboardHidden=Configuration.HARDKEYBOARDHIDDEN_NO;
  mPolicy.adjustConfigurationLw(config);
  return true;
}"
22526,"public int getOrientationFromWindowsLocked(){
  int pos=mWindows.size() - 1;
  while (pos >= 0) {
    WindowState wtoken=(WindowState)mWindows.get(pos);
    pos--;
    if (wtoken.mAppToken != null) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    if (!wtoken.isVisibleLw()) {
      continue;
    }
    int req=wtoken.mAttrs.screenOrientation;
    if ((req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) || (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND)) {
      continue;
    }
 else {
      return req;
    }
  }
  return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}","public int getOrientationFromWindowsLocked(){
  int pos=mWindows.size() - 1;
  while (pos >= 0) {
    WindowState wtoken=(WindowState)mWindows.get(pos);
    pos--;
    if (wtoken.mAppToken != null) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    if (!wtoken.isVisibleLw() || !wtoken.mPolicyVisibilityAfterAnim) {
      continue;
    }
    int req=wtoken.mAttrs.screenOrientation;
    if ((req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) || (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND)) {
      continue;
    }
 else {
      return req;
    }
  }
  return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}"
22527,"private void stopFreezingDisplayLocked(){
  if (!mDisplayFrozen) {
    return;
  }
  if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen) {
    return;
  }
  mDisplayFrozen=false;
  mH.removeMessages(H.APP_FREEZE_TIMEOUT);
  if (PROFILE_ORIENTATION) {
    Debug.stopMethodTracing();
  }
  Surface.unfreezeDisplay(0);
synchronized (mKeyWaiter) {
    mKeyWaiter.mWasFrozen=true;
    mKeyWaiter.notifyAll();
  }
  mH.removeMessages(H.FORCE_GC);
  mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),2000);
  mScreenFrozenLock.release();
}","private void stopFreezingDisplayLocked(){
  if (!mDisplayFrozen) {
    return;
  }
  if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen) {
    return;
  }
  mDisplayFrozen=false;
  mH.removeMessages(H.APP_FREEZE_TIMEOUT);
  if (PROFILE_ORIENTATION) {
    Debug.stopMethodTracing();
  }
  Surface.unfreezeDisplay(0);
synchronized (mKeyWaiter) {
    mKeyWaiter.mWasFrozen=true;
    mKeyWaiter.notifyAll();
  }
  if (updateOrientationFromAppTokensLocked()) {
    mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
  }
  mH.removeMessages(H.FORCE_GC);
  mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),2000);
  mScreenFrozenLock.release();
}"
22528,"public int addWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int viewVisibility,Rect outContentInsets){
  int res=mPolicy.checkAddPermission(attrs);
  if (res != WindowManagerImpl.ADD_OKAY) {
    return res;
  }
  boolean reportNewConfig=false;
  WindowState attachedWindow=null;
  WindowState win=null;
synchronized (mWindowMap) {
    if (mDisplay == null) {
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      mDisplay=wm.getDefaultDisplay();
      mQueue.setDisplay(mDisplay);
      reportNewConfig=true;
    }
    if (mWindowMap.containsKey(client.asBinder())) {
      Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str"");
      return WindowManagerImpl.ADD_DUPLICATE_ADD;
    }
    if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {
      attachedWindow=windowForClientLocked(null,attrs.token,false);
      if (attachedWindow == null) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
      if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
    }
    boolean addToken=false;
    WindowToken token=mTokenMap.get(attrs.token);
    if (token == null) {
      if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      token=new WindowToken(attrs.token,-1,false);
      addToken=true;
    }
 else     if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
      AppWindowToken atoken=token.appWindowToken;
      if (atoken == null) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_NOT_APP_TOKEN;
      }
 else       if (atoken.removed) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_APP_EXITING;
      }
      if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"" + attrs.getTitle());
        return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
      }
    }
 else     if (attrs.type == TYPE_INPUT_METHOD) {
      if (token.windowType != TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
 else     if (attrs.type == TYPE_WALLPAPER) {
      if (token.windowType != TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
    win=new WindowState(session,client,token,attachedWindow,attrs,viewVisibility);
    if (win.mDeathRecipient == null) {
      Slog.w(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str"");
      return WindowManagerImpl.ADD_APP_EXITING;
    }
    mPolicy.adjustWindowParamsLw(win.mAttrs);
    res=mPolicy.prepareAddWindowLw(win,attrs);
    if (res != WindowManagerImpl.ADD_OKAY) {
      return res;
    }
    res=WindowManagerImpl.ADD_OKAY;
    final long origId=Binder.clearCallingIdentity();
    if (addToken) {
      mTokenMap.put(attrs.token,token);
      mTokenList.add(token);
    }
    win.attach();
    mWindowMap.put(client.asBinder(),win);
    if (attrs.type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
      token.appWindowToken.startingWindow=win;
    }
    boolean imMayMove=true;
    if (attrs.type == TYPE_INPUT_METHOD) {
      mInputMethodWindow=win;
      addInputMethodWindowToListLocked(win);
      imMayMove=false;
    }
 else     if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
      mInputMethodDialogs.add(win);
      addWindowToListInOrderLocked(win,true);
      adjustInputMethodDialogsLocked();
      imMayMove=false;
    }
 else {
      addWindowToListInOrderLocked(win,true);
      if (attrs.type == TYPE_WALLPAPER) {
        mLastWallpaperTimeoutTime=0;
        adjustWallpaperWindowsLocked();
      }
 else       if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        adjustWallpaperWindowsLocked();
      }
    }
    win.mEnterAnimationPending=true;
    mPolicy.getContentInsetHintLw(attrs,outContentInsets);
    if (mInTouchMode) {
      res|=WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
    }
    if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {
      res|=WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
    }
    boolean focusChanged=false;
    if (win.canReceiveKeys()) {
      if ((focusChanged=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS)) == true) {
        imMayMove=false;
      }
    }
    if (imMayMove) {
      moveInputMethodWindowsIfNeededLocked(false);
    }
    assignLayersLocked();
    if (focusChanged) {
      if (mCurrentFocus != null) {
        mKeyWaiter.handleNewWindowLocked(mCurrentFocus);
      }
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win);
    if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked()) {
      reportNewConfig=true;
    }
  }
  final long origId=Binder.clearCallingIdentity();
  if (reportNewConfig) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return res;
}","public int addWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int viewVisibility,Rect outContentInsets){
  int res=mPolicy.checkAddPermission(attrs);
  if (res != WindowManagerImpl.ADD_OKAY) {
    return res;
  }
  boolean reportNewConfig=false;
  WindowState attachedWindow=null;
  WindowState win=null;
synchronized (mWindowMap) {
    if (mDisplay == null) {
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      mDisplay=wm.getDefaultDisplay();
      mInitialDisplayWidth=mDisplay.getWidth();
      mInitialDisplayHeight=mDisplay.getHeight();
      mQueue.setDisplay(mDisplay);
      reportNewConfig=true;
    }
    if (mWindowMap.containsKey(client.asBinder())) {
      Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str"");
      return WindowManagerImpl.ADD_DUPLICATE_ADD;
    }
    if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {
      attachedWindow=windowForClientLocked(null,attrs.token,false);
      if (attachedWindow == null) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
      if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
    }
    boolean addToken=false;
    WindowToken token=mTokenMap.get(attrs.token);
    if (token == null) {
      if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      token=new WindowToken(attrs.token,-1,false);
      addToken=true;
    }
 else     if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
      AppWindowToken atoken=token.appWindowToken;
      if (atoken == null) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_NOT_APP_TOKEN;
      }
 else       if (atoken.removed) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_APP_EXITING;
      }
      if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"" + attrs.getTitle());
        return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
      }
    }
 else     if (attrs.type == TYPE_INPUT_METHOD) {
      if (token.windowType != TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
 else     if (attrs.type == TYPE_WALLPAPER) {
      if (token.windowType != TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
    win=new WindowState(session,client,token,attachedWindow,attrs,viewVisibility);
    if (win.mDeathRecipient == null) {
      Slog.w(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str"");
      return WindowManagerImpl.ADD_APP_EXITING;
    }
    mPolicy.adjustWindowParamsLw(win.mAttrs);
    res=mPolicy.prepareAddWindowLw(win,attrs);
    if (res != WindowManagerImpl.ADD_OKAY) {
      return res;
    }
    res=WindowManagerImpl.ADD_OKAY;
    final long origId=Binder.clearCallingIdentity();
    if (addToken) {
      mTokenMap.put(attrs.token,token);
      mTokenList.add(token);
    }
    win.attach();
    mWindowMap.put(client.asBinder(),win);
    if (attrs.type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
      token.appWindowToken.startingWindow=win;
    }
    boolean imMayMove=true;
    if (attrs.type == TYPE_INPUT_METHOD) {
      mInputMethodWindow=win;
      addInputMethodWindowToListLocked(win);
      imMayMove=false;
    }
 else     if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
      mInputMethodDialogs.add(win);
      addWindowToListInOrderLocked(win,true);
      adjustInputMethodDialogsLocked();
      imMayMove=false;
    }
 else {
      addWindowToListInOrderLocked(win,true);
      if (attrs.type == TYPE_WALLPAPER) {
        mLastWallpaperTimeoutTime=0;
        adjustWallpaperWindowsLocked();
      }
 else       if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        adjustWallpaperWindowsLocked();
      }
    }
    win.mEnterAnimationPending=true;
    mPolicy.getContentInsetHintLw(attrs,outContentInsets);
    if (mInTouchMode) {
      res|=WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
    }
    if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {
      res|=WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
    }
    boolean focusChanged=false;
    if (win.canReceiveKeys()) {
      if ((focusChanged=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS)) == true) {
        imMayMove=false;
      }
    }
    if (imMayMove) {
      moveInputMethodWindowsIfNeededLocked(false);
    }
    assignLayersLocked();
    if (focusChanged) {
      if (mCurrentFocus != null) {
        mKeyWaiter.handleNewWindowLocked(mCurrentFocus);
      }
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win);
    if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked()) {
      reportNewConfig=true;
    }
  }
  final long origId=Binder.clearCallingIdentity();
  if (reportNewConfig) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return res;
}"
22529,"boolean updateOrientationFromAppTokensLocked(){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
      if (setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE)) {
        changed=true;
      }
    }
    return changed;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","boolean updateOrientationFromAppTokensLocked(){
  if (mDisplayFrozen) {
    return false;
  }
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
      if (setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE)) {
        changed=true;
      }
    }
    return changed;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
22530,"boolean computeNewConfigurationLocked(Configuration config){
  if (mDisplay == null) {
    return false;
  }
  mQueue.getInputConfiguration(config);
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int orientation=Configuration.ORIENTATION_SQUARE;
  if (dw < dh) {
    orientation=Configuration.ORIENTATION_PORTRAIT;
  }
 else   if (dw > dh) {
    orientation=Configuration.ORIENTATION_LANDSCAPE;
  }
  config.orientation=orientation;
  DisplayMetrics dm=new DisplayMetrics();
  mDisplay.getMetrics(dm);
  CompatibilityInfo.updateCompatibleScreenFrame(dm,orientation,mCompatibleScreenFrame);
  if (mScreenLayout == Configuration.SCREENLAYOUT_SIZE_UNDEFINED) {
    int longSize=dw;
    int shortSize=dh;
    if (longSize < shortSize) {
      int tmp=longSize;
      longSize=shortSize;
      shortSize=tmp;
    }
    longSize=(int)(longSize / dm.density);
    shortSize=(int)(shortSize / dm.density);
    if (longSize < 470) {
      mScreenLayout=Configuration.SCREENLAYOUT_SIZE_SMALL | Configuration.SCREENLAYOUT_LONG_NO;
    }
 else {
      if (longSize > 640 && shortSize >= 480) {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_LARGE;
      }
 else {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_NORMAL;
        if (shortSize > 321 || longSize > 570) {
          mScreenLayout|=Configuration.SCREENLAYOUT_COMPAT_NEEDED;
        }
      }
      if (((longSize * 3) / 5) >= (shortSize - 1)) {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_YES;
      }
 else {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_NO;
      }
    }
  }
  config.screenLayout=mScreenLayout;
  config.keyboardHidden=Configuration.KEYBOARDHIDDEN_NO;
  config.hardKeyboardHidden=Configuration.HARDKEYBOARDHIDDEN_NO;
  mPolicy.adjustConfigurationLw(config);
  return true;
}","boolean computeNewConfigurationLocked(Configuration config){
  if (mDisplay == null) {
    return false;
  }
  mQueue.getInputConfiguration(config);
  final boolean rotated=(mRotation == Surface.ROTATION_90 || mRotation == Surface.ROTATION_270);
  final int dw=rotated ? mInitialDisplayHeight : mInitialDisplayWidth;
  final int dh=rotated ? mInitialDisplayWidth : mInitialDisplayHeight;
  int orientation=Configuration.ORIENTATION_SQUARE;
  if (dw < dh) {
    orientation=Configuration.ORIENTATION_PORTRAIT;
  }
 else   if (dw > dh) {
    orientation=Configuration.ORIENTATION_LANDSCAPE;
  }
  config.orientation=orientation;
  DisplayMetrics dm=new DisplayMetrics();
  mDisplay.getMetrics(dm);
  CompatibilityInfo.updateCompatibleScreenFrame(dm,orientation,mCompatibleScreenFrame);
  if (mScreenLayout == Configuration.SCREENLAYOUT_SIZE_UNDEFINED) {
    int longSize=dw;
    int shortSize=dh;
    if (longSize < shortSize) {
      int tmp=longSize;
      longSize=shortSize;
      shortSize=tmp;
    }
    longSize=(int)(longSize / dm.density);
    shortSize=(int)(shortSize / dm.density);
    if (longSize < 470) {
      mScreenLayout=Configuration.SCREENLAYOUT_SIZE_SMALL | Configuration.SCREENLAYOUT_LONG_NO;
    }
 else {
      if (longSize > 640 && shortSize >= 480) {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_LARGE;
      }
 else {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_NORMAL;
        if (shortSize > 321 || longSize > 570) {
          mScreenLayout|=Configuration.SCREENLAYOUT_COMPAT_NEEDED;
        }
      }
      if (((longSize * 3) / 5) >= (shortSize - 1)) {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_YES;
      }
 else {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_NO;
      }
    }
  }
  config.screenLayout=mScreenLayout;
  config.keyboardHidden=Configuration.KEYBOARDHIDDEN_NO;
  config.hardKeyboardHidden=Configuration.HARDKEYBOARDHIDDEN_NO;
  mPolicy.adjustConfigurationLw(config);
  return true;
}"
22531,"public int getOrientationFromWindowsLocked(){
  int pos=mWindows.size() - 1;
  while (pos >= 0) {
    WindowState wtoken=(WindowState)mWindows.get(pos);
    pos--;
    if (wtoken.mAppToken != null) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    if (!wtoken.isVisibleLw()) {
      continue;
    }
    int req=wtoken.mAttrs.screenOrientation;
    if ((req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) || (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND)) {
      continue;
    }
 else {
      return req;
    }
  }
  return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}","public int getOrientationFromWindowsLocked(){
  int pos=mWindows.size() - 1;
  while (pos >= 0) {
    WindowState wtoken=(WindowState)mWindows.get(pos);
    pos--;
    if (wtoken.mAppToken != null) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    if (!wtoken.isVisibleLw() || !wtoken.mPolicyVisibilityAfterAnim) {
      continue;
    }
    int req=wtoken.mAttrs.screenOrientation;
    if ((req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) || (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND)) {
      continue;
    }
 else {
      return req;
    }
  }
  return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}"
22532,"private void stopFreezingDisplayLocked(){
  if (!mDisplayFrozen) {
    return;
  }
  if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen) {
    return;
  }
  mDisplayFrozen=false;
  mH.removeMessages(H.APP_FREEZE_TIMEOUT);
  if (PROFILE_ORIENTATION) {
    Debug.stopMethodTracing();
  }
  Surface.unfreezeDisplay(0);
synchronized (mKeyWaiter) {
    mKeyWaiter.mWasFrozen=true;
    mKeyWaiter.notifyAll();
  }
  mH.removeMessages(H.FORCE_GC);
  mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),2000);
  mScreenFrozenLock.release();
}","private void stopFreezingDisplayLocked(){
  if (!mDisplayFrozen) {
    return;
  }
  if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen) {
    return;
  }
  mDisplayFrozen=false;
  mH.removeMessages(H.APP_FREEZE_TIMEOUT);
  if (PROFILE_ORIENTATION) {
    Debug.stopMethodTracing();
  }
  Surface.unfreezeDisplay(0);
synchronized (mKeyWaiter) {
    mKeyWaiter.mWasFrozen=true;
    mKeyWaiter.notifyAll();
  }
  if (updateOrientationFromAppTokensLocked()) {
    mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
  }
  mH.removeMessages(H.FORCE_GC);
  mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),2000);
  mScreenFrozenLock.release();
}"
22533,"public int addWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int viewVisibility,Rect outContentInsets){
  int res=mPolicy.checkAddPermission(attrs);
  if (res != WindowManagerImpl.ADD_OKAY) {
    return res;
  }
  boolean reportNewConfig=false;
  WindowState attachedWindow=null;
  WindowState win=null;
synchronized (mWindowMap) {
    if (mDisplay == null) {
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      mDisplay=wm.getDefaultDisplay();
      mQueue.setDisplay(mDisplay);
      reportNewConfig=true;
    }
    if (mWindowMap.containsKey(client.asBinder())) {
      Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str"");
      return WindowManagerImpl.ADD_DUPLICATE_ADD;
    }
    if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {
      attachedWindow=windowForClientLocked(null,attrs.token,false);
      if (attachedWindow == null) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
      if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
    }
    boolean addToken=false;
    WindowToken token=mTokenMap.get(attrs.token);
    if (token == null) {
      if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      token=new WindowToken(attrs.token,-1,false);
      addToken=true;
    }
 else     if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
      AppWindowToken atoken=token.appWindowToken;
      if (atoken == null) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_NOT_APP_TOKEN;
      }
 else       if (atoken.removed) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_APP_EXITING;
      }
      if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"" + attrs.getTitle());
        return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
      }
    }
 else     if (attrs.type == TYPE_INPUT_METHOD) {
      if (token.windowType != TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
 else     if (attrs.type == TYPE_WALLPAPER) {
      if (token.windowType != TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
    win=new WindowState(session,client,token,attachedWindow,attrs,viewVisibility);
    if (win.mDeathRecipient == null) {
      Slog.w(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str"");
      return WindowManagerImpl.ADD_APP_EXITING;
    }
    mPolicy.adjustWindowParamsLw(win.mAttrs);
    res=mPolicy.prepareAddWindowLw(win,attrs);
    if (res != WindowManagerImpl.ADD_OKAY) {
      return res;
    }
    res=WindowManagerImpl.ADD_OKAY;
    final long origId=Binder.clearCallingIdentity();
    if (addToken) {
      mTokenMap.put(attrs.token,token);
      mTokenList.add(token);
    }
    win.attach();
    mWindowMap.put(client.asBinder(),win);
    if (attrs.type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
      token.appWindowToken.startingWindow=win;
    }
    boolean imMayMove=true;
    if (attrs.type == TYPE_INPUT_METHOD) {
      mInputMethodWindow=win;
      addInputMethodWindowToListLocked(win);
      imMayMove=false;
    }
 else     if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
      mInputMethodDialogs.add(win);
      addWindowToListInOrderLocked(win,true);
      adjustInputMethodDialogsLocked();
      imMayMove=false;
    }
 else {
      addWindowToListInOrderLocked(win,true);
      if (attrs.type == TYPE_WALLPAPER) {
        mLastWallpaperTimeoutTime=0;
        adjustWallpaperWindowsLocked();
      }
 else       if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        adjustWallpaperWindowsLocked();
      }
    }
    win.mEnterAnimationPending=true;
    mPolicy.getContentInsetHintLw(attrs,outContentInsets);
    if (mInTouchMode) {
      res|=WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
    }
    if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {
      res|=WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
    }
    boolean focusChanged=false;
    if (win.canReceiveKeys()) {
      if ((focusChanged=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS)) == true) {
        imMayMove=false;
      }
    }
    if (imMayMove) {
      moveInputMethodWindowsIfNeededLocked(false);
    }
    assignLayersLocked();
    if (focusChanged) {
      if (mCurrentFocus != null) {
        mKeyWaiter.handleNewWindowLocked(mCurrentFocus);
      }
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win);
    if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked()) {
      reportNewConfig=true;
    }
  }
  final long origId=Binder.clearCallingIdentity();
  if (reportNewConfig) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return res;
}","public int addWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int viewVisibility,Rect outContentInsets){
  int res=mPolicy.checkAddPermission(attrs);
  if (res != WindowManagerImpl.ADD_OKAY) {
    return res;
  }
  boolean reportNewConfig=false;
  WindowState attachedWindow=null;
  WindowState win=null;
synchronized (mWindowMap) {
    if (mDisplay == null) {
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      mDisplay=wm.getDefaultDisplay();
      mInitialDisplayWidth=mDisplay.getWidth();
      mInitialDisplayHeight=mDisplay.getHeight();
      mQueue.setDisplay(mDisplay);
      reportNewConfig=true;
    }
    if (mWindowMap.containsKey(client.asBinder())) {
      Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str"");
      return WindowManagerImpl.ADD_DUPLICATE_ADD;
    }
    if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {
      attachedWindow=windowForClientLocked(null,attrs.token,false);
      if (attachedWindow == null) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
      if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
    }
    boolean addToken=false;
    WindowToken token=mTokenMap.get(attrs.token);
    if (token == null) {
      if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      token=new WindowToken(attrs.token,-1,false);
      addToken=true;
    }
 else     if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
      AppWindowToken atoken=token.appWindowToken;
      if (atoken == null) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_NOT_APP_TOKEN;
      }
 else       if (atoken.removed) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_APP_EXITING;
      }
      if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"" + attrs.getTitle());
        return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
      }
    }
 else     if (attrs.type == TYPE_INPUT_METHOD) {
      if (token.windowType != TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
 else     if (attrs.type == TYPE_WALLPAPER) {
      if (token.windowType != TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
    win=new WindowState(session,client,token,attachedWindow,attrs,viewVisibility);
    if (win.mDeathRecipient == null) {
      Slog.w(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str"");
      return WindowManagerImpl.ADD_APP_EXITING;
    }
    mPolicy.adjustWindowParamsLw(win.mAttrs);
    res=mPolicy.prepareAddWindowLw(win,attrs);
    if (res != WindowManagerImpl.ADD_OKAY) {
      return res;
    }
    res=WindowManagerImpl.ADD_OKAY;
    final long origId=Binder.clearCallingIdentity();
    if (addToken) {
      mTokenMap.put(attrs.token,token);
      mTokenList.add(token);
    }
    win.attach();
    mWindowMap.put(client.asBinder(),win);
    if (attrs.type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
      token.appWindowToken.startingWindow=win;
    }
    boolean imMayMove=true;
    if (attrs.type == TYPE_INPUT_METHOD) {
      mInputMethodWindow=win;
      addInputMethodWindowToListLocked(win);
      imMayMove=false;
    }
 else     if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
      mInputMethodDialogs.add(win);
      addWindowToListInOrderLocked(win,true);
      adjustInputMethodDialogsLocked();
      imMayMove=false;
    }
 else {
      addWindowToListInOrderLocked(win,true);
      if (attrs.type == TYPE_WALLPAPER) {
        mLastWallpaperTimeoutTime=0;
        adjustWallpaperWindowsLocked();
      }
 else       if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        adjustWallpaperWindowsLocked();
      }
    }
    win.mEnterAnimationPending=true;
    mPolicy.getContentInsetHintLw(attrs,outContentInsets);
    if (mInTouchMode) {
      res|=WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
    }
    if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {
      res|=WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
    }
    boolean focusChanged=false;
    if (win.canReceiveKeys()) {
      if ((focusChanged=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS)) == true) {
        imMayMove=false;
      }
    }
    if (imMayMove) {
      moveInputMethodWindowsIfNeededLocked(false);
    }
    assignLayersLocked();
    if (focusChanged) {
      if (mCurrentFocus != null) {
        mKeyWaiter.handleNewWindowLocked(mCurrentFocus);
      }
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win);
    if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked()) {
      reportNewConfig=true;
    }
  }
  final long origId=Binder.clearCallingIdentity();
  if (reportNewConfig) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return res;
}"
22534,"boolean updateOrientationFromAppTokensLocked(){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
      if (setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE)) {
        changed=true;
      }
    }
    return changed;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","boolean updateOrientationFromAppTokensLocked(){
  if (mDisplayFrozen) {
    return false;
  }
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
      if (setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE)) {
        changed=true;
      }
    }
    return changed;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
22535,"private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}","private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      for (int j=startIndex; j < endIndex; j++) {
        if ((wlBuffer[j] & 0x80) != 0)         wlBuffer[j]=(byte)'?';
      }
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}"
22536,"boolean computeNewConfigurationLocked(Configuration config){
  if (mDisplay == null) {
    return false;
  }
  mQueue.getInputConfiguration(config);
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int orientation=Configuration.ORIENTATION_SQUARE;
  if (dw < dh) {
    orientation=Configuration.ORIENTATION_PORTRAIT;
  }
 else   if (dw > dh) {
    orientation=Configuration.ORIENTATION_LANDSCAPE;
  }
  config.orientation=orientation;
  DisplayMetrics dm=new DisplayMetrics();
  mDisplay.getMetrics(dm);
  CompatibilityInfo.updateCompatibleScreenFrame(dm,orientation,mCompatibleScreenFrame);
  if (mScreenLayout == Configuration.SCREENLAYOUT_SIZE_UNDEFINED) {
    int longSize=dw;
    int shortSize=dh;
    if (longSize < shortSize) {
      int tmp=longSize;
      longSize=shortSize;
      shortSize=tmp;
    }
    longSize=(int)(longSize / dm.density);
    shortSize=(int)(shortSize / dm.density);
    if (longSize < 470) {
      mScreenLayout=Configuration.SCREENLAYOUT_SIZE_SMALL | Configuration.SCREENLAYOUT_LONG_NO;
    }
 else {
      if (longSize > 640 && shortSize >= 480) {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_LARGE;
      }
 else {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_NORMAL;
        if (shortSize > 321 || longSize > 570) {
          mScreenLayout|=Configuration.SCREENLAYOUT_COMPAT_NEEDED;
        }
      }
      if (((longSize * 3) / 5) >= (shortSize - 1)) {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_YES;
      }
 else {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_NO;
      }
    }
  }
  config.screenLayout=mScreenLayout;
  config.keyboardHidden=Configuration.KEYBOARDHIDDEN_NO;
  config.hardKeyboardHidden=Configuration.HARDKEYBOARDHIDDEN_NO;
  mPolicy.adjustConfigurationLw(config);
  return true;
}","boolean computeNewConfigurationLocked(Configuration config){
  if (mDisplay == null) {
    return false;
  }
  mQueue.getInputConfiguration(config);
  final boolean rotated=(mRotation == Surface.ROTATION_90 || mRotation == Surface.ROTATION_270);
  final int dw=rotated ? mInitialDisplayHeight : mInitialDisplayWidth;
  final int dh=rotated ? mInitialDisplayWidth : mInitialDisplayHeight;
  int orientation=Configuration.ORIENTATION_SQUARE;
  if (dw < dh) {
    orientation=Configuration.ORIENTATION_PORTRAIT;
  }
 else   if (dw > dh) {
    orientation=Configuration.ORIENTATION_LANDSCAPE;
  }
  config.orientation=orientation;
  DisplayMetrics dm=new DisplayMetrics();
  mDisplay.getMetrics(dm);
  CompatibilityInfo.updateCompatibleScreenFrame(dm,orientation,mCompatibleScreenFrame);
  if (mScreenLayout == Configuration.SCREENLAYOUT_SIZE_UNDEFINED) {
    int longSize=dw;
    int shortSize=dh;
    if (longSize < shortSize) {
      int tmp=longSize;
      longSize=shortSize;
      shortSize=tmp;
    }
    longSize=(int)(longSize / dm.density);
    shortSize=(int)(shortSize / dm.density);
    if (longSize < 470) {
      mScreenLayout=Configuration.SCREENLAYOUT_SIZE_SMALL | Configuration.SCREENLAYOUT_LONG_NO;
    }
 else {
      if (longSize > 640 && shortSize >= 480) {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_LARGE;
      }
 else {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_NORMAL;
        if (shortSize > 321 || longSize > 570) {
          mScreenLayout|=Configuration.SCREENLAYOUT_COMPAT_NEEDED;
        }
      }
      if (((longSize * 3) / 5) >= (shortSize - 1)) {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_YES;
      }
 else {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_NO;
      }
    }
  }
  config.screenLayout=mScreenLayout;
  config.keyboardHidden=Configuration.KEYBOARDHIDDEN_NO;
  config.hardKeyboardHidden=Configuration.HARDKEYBOARDHIDDEN_NO;
  mPolicy.adjustConfigurationLw(config);
  return true;
}"
22537,"public int getOrientationFromWindowsLocked(){
  int pos=mWindows.size() - 1;
  while (pos >= 0) {
    WindowState wtoken=(WindowState)mWindows.get(pos);
    pos--;
    if (wtoken.mAppToken != null) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    if (!wtoken.isVisibleLw()) {
      continue;
    }
    int req=wtoken.mAttrs.screenOrientation;
    if ((req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) || (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND)) {
      continue;
    }
 else {
      return req;
    }
  }
  return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}","public int getOrientationFromWindowsLocked(){
  int pos=mWindows.size() - 1;
  while (pos >= 0) {
    WindowState wtoken=(WindowState)mWindows.get(pos);
    pos--;
    if (wtoken.mAppToken != null) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    if (!wtoken.isVisibleLw() || !wtoken.mPolicyVisibilityAfterAnim) {
      continue;
    }
    int req=wtoken.mAttrs.screenOrientation;
    if ((req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) || (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND)) {
      continue;
    }
 else {
      return req;
    }
  }
  return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}"
22538,"private void stopFreezingDisplayLocked(){
  if (!mDisplayFrozen) {
    return;
  }
  if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen) {
    return;
  }
  mDisplayFrozen=false;
  mH.removeMessages(H.APP_FREEZE_TIMEOUT);
  if (PROFILE_ORIENTATION) {
    Debug.stopMethodTracing();
  }
  Surface.unfreezeDisplay(0);
synchronized (mKeyWaiter) {
    mKeyWaiter.mWasFrozen=true;
    mKeyWaiter.notifyAll();
  }
  mH.removeMessages(H.FORCE_GC);
  mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),2000);
  mScreenFrozenLock.release();
}","private void stopFreezingDisplayLocked(){
  if (!mDisplayFrozen) {
    return;
  }
  if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen) {
    return;
  }
  mDisplayFrozen=false;
  mH.removeMessages(H.APP_FREEZE_TIMEOUT);
  if (PROFILE_ORIENTATION) {
    Debug.stopMethodTracing();
  }
  Surface.unfreezeDisplay(0);
synchronized (mKeyWaiter) {
    mKeyWaiter.mWasFrozen=true;
    mKeyWaiter.notifyAll();
  }
  if (updateOrientationFromAppTokensLocked()) {
    mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
  }
  mH.removeMessages(H.FORCE_GC);
  mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),2000);
  mScreenFrozenLock.release();
}"
22539,"public int addWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int viewVisibility,Rect outContentInsets){
  int res=mPolicy.checkAddPermission(attrs);
  if (res != WindowManagerImpl.ADD_OKAY) {
    return res;
  }
  boolean reportNewConfig=false;
  WindowState attachedWindow=null;
  WindowState win=null;
synchronized (mWindowMap) {
    if (mDisplay == null) {
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      mDisplay=wm.getDefaultDisplay();
      mQueue.setDisplay(mDisplay);
      reportNewConfig=true;
    }
    if (mWindowMap.containsKey(client.asBinder())) {
      Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str"");
      return WindowManagerImpl.ADD_DUPLICATE_ADD;
    }
    if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {
      attachedWindow=windowForClientLocked(null,attrs.token,false);
      if (attachedWindow == null) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
      if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
    }
    boolean addToken=false;
    WindowToken token=mTokenMap.get(attrs.token);
    if (token == null) {
      if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      token=new WindowToken(attrs.token,-1,false);
      addToken=true;
    }
 else     if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
      AppWindowToken atoken=token.appWindowToken;
      if (atoken == null) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_NOT_APP_TOKEN;
      }
 else       if (atoken.removed) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_APP_EXITING;
      }
      if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"" + attrs.getTitle());
        return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
      }
    }
 else     if (attrs.type == TYPE_INPUT_METHOD) {
      if (token.windowType != TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
 else     if (attrs.type == TYPE_WALLPAPER) {
      if (token.windowType != TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
    win=new WindowState(session,client,token,attachedWindow,attrs,viewVisibility);
    if (win.mDeathRecipient == null) {
      Slog.w(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str"");
      return WindowManagerImpl.ADD_APP_EXITING;
    }
    mPolicy.adjustWindowParamsLw(win.mAttrs);
    res=mPolicy.prepareAddWindowLw(win,attrs);
    if (res != WindowManagerImpl.ADD_OKAY) {
      return res;
    }
    res=WindowManagerImpl.ADD_OKAY;
    final long origId=Binder.clearCallingIdentity();
    if (addToken) {
      mTokenMap.put(attrs.token,token);
      mTokenList.add(token);
    }
    win.attach();
    mWindowMap.put(client.asBinder(),win);
    if (attrs.type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
      token.appWindowToken.startingWindow=win;
    }
    boolean imMayMove=true;
    if (attrs.type == TYPE_INPUT_METHOD) {
      mInputMethodWindow=win;
      addInputMethodWindowToListLocked(win);
      imMayMove=false;
    }
 else     if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
      mInputMethodDialogs.add(win);
      addWindowToListInOrderLocked(win,true);
      adjustInputMethodDialogsLocked();
      imMayMove=false;
    }
 else {
      addWindowToListInOrderLocked(win,true);
      if (attrs.type == TYPE_WALLPAPER) {
        mLastWallpaperTimeoutTime=0;
        adjustWallpaperWindowsLocked();
      }
 else       if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        adjustWallpaperWindowsLocked();
      }
    }
    win.mEnterAnimationPending=true;
    mPolicy.getContentInsetHintLw(attrs,outContentInsets);
    if (mInTouchMode) {
      res|=WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
    }
    if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {
      res|=WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
    }
    boolean focusChanged=false;
    if (win.canReceiveKeys()) {
      if ((focusChanged=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS)) == true) {
        imMayMove=false;
      }
    }
    if (imMayMove) {
      moveInputMethodWindowsIfNeededLocked(false);
    }
    assignLayersLocked();
    if (focusChanged) {
      if (mCurrentFocus != null) {
        mKeyWaiter.handleNewWindowLocked(mCurrentFocus);
      }
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win);
    if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked()) {
      reportNewConfig=true;
    }
  }
  final long origId=Binder.clearCallingIdentity();
  if (reportNewConfig) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return res;
}","public int addWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int viewVisibility,Rect outContentInsets){
  int res=mPolicy.checkAddPermission(attrs);
  if (res != WindowManagerImpl.ADD_OKAY) {
    return res;
  }
  boolean reportNewConfig=false;
  WindowState attachedWindow=null;
  WindowState win=null;
synchronized (mWindowMap) {
    if (mDisplay == null) {
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      mDisplay=wm.getDefaultDisplay();
      mInitialDisplayWidth=mDisplay.getWidth();
      mInitialDisplayHeight=mDisplay.getHeight();
      mQueue.setDisplay(mDisplay);
      reportNewConfig=true;
    }
    if (mWindowMap.containsKey(client.asBinder())) {
      Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str"");
      return WindowManagerImpl.ADD_DUPLICATE_ADD;
    }
    if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {
      attachedWindow=windowForClientLocked(null,attrs.token,false);
      if (attachedWindow == null) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
      if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
    }
    boolean addToken=false;
    WindowToken token=mTokenMap.get(attrs.token);
    if (token == null) {
      if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      token=new WindowToken(attrs.token,-1,false);
      addToken=true;
    }
 else     if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
      AppWindowToken atoken=token.appWindowToken;
      if (atoken == null) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_NOT_APP_TOKEN;
      }
 else       if (atoken.removed) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_APP_EXITING;
      }
      if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"" + attrs.getTitle());
        return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
      }
    }
 else     if (attrs.type == TYPE_INPUT_METHOD) {
      if (token.windowType != TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
 else     if (attrs.type == TYPE_WALLPAPER) {
      if (token.windowType != TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
    win=new WindowState(session,client,token,attachedWindow,attrs,viewVisibility);
    if (win.mDeathRecipient == null) {
      Slog.w(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str"");
      return WindowManagerImpl.ADD_APP_EXITING;
    }
    mPolicy.adjustWindowParamsLw(win.mAttrs);
    res=mPolicy.prepareAddWindowLw(win,attrs);
    if (res != WindowManagerImpl.ADD_OKAY) {
      return res;
    }
    res=WindowManagerImpl.ADD_OKAY;
    final long origId=Binder.clearCallingIdentity();
    if (addToken) {
      mTokenMap.put(attrs.token,token);
      mTokenList.add(token);
    }
    win.attach();
    mWindowMap.put(client.asBinder(),win);
    if (attrs.type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
      token.appWindowToken.startingWindow=win;
    }
    boolean imMayMove=true;
    if (attrs.type == TYPE_INPUT_METHOD) {
      mInputMethodWindow=win;
      addInputMethodWindowToListLocked(win);
      imMayMove=false;
    }
 else     if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
      mInputMethodDialogs.add(win);
      addWindowToListInOrderLocked(win,true);
      adjustInputMethodDialogsLocked();
      imMayMove=false;
    }
 else {
      addWindowToListInOrderLocked(win,true);
      if (attrs.type == TYPE_WALLPAPER) {
        mLastWallpaperTimeoutTime=0;
        adjustWallpaperWindowsLocked();
      }
 else       if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        adjustWallpaperWindowsLocked();
      }
    }
    win.mEnterAnimationPending=true;
    mPolicy.getContentInsetHintLw(attrs,outContentInsets);
    if (mInTouchMode) {
      res|=WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
    }
    if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {
      res|=WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
    }
    boolean focusChanged=false;
    if (win.canReceiveKeys()) {
      if ((focusChanged=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS)) == true) {
        imMayMove=false;
      }
    }
    if (imMayMove) {
      moveInputMethodWindowsIfNeededLocked(false);
    }
    assignLayersLocked();
    if (focusChanged) {
      if (mCurrentFocus != null) {
        mKeyWaiter.handleNewWindowLocked(mCurrentFocus);
      }
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win);
    if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked()) {
      reportNewConfig=true;
    }
  }
  final long origId=Binder.clearCallingIdentity();
  if (reportNewConfig) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return res;
}"
22540,"boolean updateOrientationFromAppTokensLocked(){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
      if (setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE)) {
        changed=true;
      }
    }
    return changed;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","boolean updateOrientationFromAppTokensLocked(){
  if (mDisplayFrozen) {
    return false;
  }
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
      if (setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE)) {
        changed=true;
      }
    }
    return changed;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
22541,"private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}","private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      for (int j=startIndex; j < endIndex; j++) {
        if ((wlBuffer[j] & 0x80) != 0)         wlBuffer[j]=(byte)'?';
      }
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}"
22542,"private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}","private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      for (int j=startIndex; j < endIndex; j++) {
        if ((wlBuffer[j] & 0x80) != 0)         wlBuffer[j]=(byte)'?';
      }
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}"
22543,"public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BACK) {
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null) {
            ds.startTracking(event,this);
            return true;
          }
        }
      }
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
      mMenu.close(true);
      dialog.dismiss();
      return true;
    }
  }
  return mMenu.performShortcut(keyCode,event,0);
}","public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BACK) {
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null) {
            ds.startTracking(event,this);
            return true;
          }
        }
      }
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP && !event.isCanceled()) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null && ds.isTracking(event)) {
            mMenu.close(true);
            dialog.dismiss();
            return true;
          }
        }
      }
    }
  }
  return mMenu.performShortcut(keyCode,event,0);
}"
22544,"public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BACK) {
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null) {
            ds.startTracking(event,this);
            return true;
          }
        }
      }
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
      mMenu.close(true);
      dialog.dismiss();
      return true;
    }
  }
  return mMenu.performShortcut(keyCode,event,0);
}","public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BACK) {
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null) {
            ds.startTracking(event,this);
            return true;
          }
        }
      }
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP && !event.isCanceled()) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null && ds.isTracking(event)) {
            mMenu.close(true);
            dialog.dismiss();
            return true;
          }
        }
      }
    }
  }
  return mMenu.performShortcut(keyCode,event,0);
}"
22545,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}"
22546,"private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}","private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      for (int j=startIndex; j < endIndex; j++) {
        if ((wlBuffer[j] & 0x80) != 0)         wlBuffer[j]=(byte)'?';
      }
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}"
22547,"public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BACK) {
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null) {
            ds.startTracking(event,this);
            return true;
          }
        }
      }
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
      mMenu.close(true);
      dialog.dismiss();
      return true;
    }
  }
  return mMenu.performShortcut(keyCode,event,0);
}","public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BACK) {
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null) {
            ds.startTracking(event,this);
            return true;
          }
        }
      }
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP && !event.isCanceled()) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null && ds.isTracking(event)) {
            mMenu.close(true);
            dialog.dismiss();
            return true;
          }
        }
      }
    }
  }
  return mMenu.performShortcut(keyCode,event,0);
}"
22548,"/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}"
22549,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22550,"/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}"
22551,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22552,"/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}"
22553,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22554,"/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}"
22555,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22556,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}"
22557,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}"
22558,"public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
synchronized (this) {
      if (mCurWidth != w || mCurHeight != h) {
        mCurWidth=w;
        mCurHeight=h;
      }
      if (reportDraw) {
        try {
          surfaceView.mSession.finishDrawing(surfaceView.mWindow);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
    surfaceView.mSurfaceLock.lock();
    try {
      if (reportDraw) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mReportDrawNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
 else       if (surfaceView.mWinFrame.width() != w || surfaceView.mWinFrame.height() != h) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
    }
  finally {
      surfaceView.mSurfaceLock.unlock();
    }
  }
}"
22559,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
case UPDATE_WINDOW_MSG:
{
updateWindow(false);
}
break;
}
}"
22560,"private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      if (mTranslator == null) {
        mSurfaceFrame.right=mWinFrame.width();
        mSurfaceFrame.bottom=mWinFrame.height();
      }
 else {
        float appInvertedScale=mTranslator.applicationInvertedScale;
        mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
        mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
      }
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
        if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (localLOGV)         Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || reportDrawNeeded) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}"
22561,"/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}","/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mLastDimWidth=dw;
      mLastDimHeight=dh;
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
 else   if (mLastDimWidth != dw || mLastDimHeight != dh) {
    mLastDimWidth=dw;
    mLastDimHeight=dh;
    mDimSurface.setSize(dw,dh);
  }
}"
22562,"/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,0,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}","/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}"
22563,"private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  HistoryRecord r=null;
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      r=(HistoryRecord)o;
      index=i;
      break;
    }
  }
  return index;
}","private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      index=i;
      break;
    }
  }
  return index;
}"
22564,"private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}","private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
 else {
    HistoryRecord r=topRunningActivityLocked(null);
    if (r.app == app) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
      int index=indexOfTokenLocked(r);
      finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      index--;
      if (index >= 0) {
        r=(HistoryRecord)mHistory.get(index);
        if (r.state == ActivityState.RESUMED || r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
          if (!r.isHomeActivity) {
            Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
            finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
        }
      }
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}"
22565,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}"
22566,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}"
22567,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}"
22568,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}"
22569,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}"
22570,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}"
22571,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}"
22572,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}"
22573,"/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}","/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mLastDimWidth=dw;
      mLastDimHeight=dh;
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
 else   if (mLastDimWidth != dw || mLastDimHeight != dh) {
    mLastDimWidth=dw;
    mLastDimHeight=dh;
    mDimSurface.setSize(dw,dh);
  }
}"
22574,"/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,0,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}","/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}"
22575,"private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  HistoryRecord r=null;
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      r=(HistoryRecord)o;
      index=i;
      break;
    }
  }
  return index;
}","private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      index=i;
      break;
    }
  }
  return index;
}"
22576,"private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}","private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
 else {
    HistoryRecord r=topRunningActivityLocked(null);
    if (r.app == app) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
      int index=indexOfTokenLocked(r);
      finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      index--;
      if (index >= 0) {
        r=(HistoryRecord)mHistory.get(index);
        if (r.state == ActivityState.RESUMED || r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
          if (!r.isHomeActivity) {
            Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
            finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
        }
      }
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}"
22577,"/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}","/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mLastDimWidth=dw;
      mLastDimHeight=dh;
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
 else   if (mLastDimWidth != dw || mLastDimHeight != dh) {
    mLastDimWidth=dw;
    mLastDimHeight=dh;
    mDimSurface.setSize(dw,dh);
  }
}"
22578,"/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,0,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}","/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}"
22579,"private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  HistoryRecord r=null;
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      r=(HistoryRecord)o;
      index=i;
      break;
    }
  }
  return index;
}","private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      index=i;
      break;
    }
  }
  return index;
}"
22580,"private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}","private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
 else {
    HistoryRecord r=topRunningActivityLocked(null);
    if (r.app == app) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
      int index=indexOfTokenLocked(r);
      finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      index--;
      if (index >= 0) {
        r=(HistoryRecord)mHistory.get(index);
        if (r.state == ActivityState.RESUMED || r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
          if (!r.isHomeActivity) {
            Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
            finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
        }
      }
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}"
22581,"public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
synchronized (this) {
      if (mCurWidth != w || mCurHeight != h) {
        mCurWidth=w;
        mCurHeight=h;
      }
      if (reportDraw) {
        try {
          surfaceView.mSession.finishDrawing(surfaceView.mWindow);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
    surfaceView.mSurfaceLock.lock();
    try {
      if (reportDraw) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mReportDrawNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
 else       if (surfaceView.mWinFrame.width() != w || surfaceView.mWinFrame.height() != h) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
    }
  finally {
      surfaceView.mSurfaceLock.unlock();
    }
  }
}"
22582,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
case UPDATE_WINDOW_MSG:
{
updateWindow(false);
}
break;
}
}"
22583,"private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      if (mTranslator == null) {
        mSurfaceFrame.right=mWinFrame.width();
        mSurfaceFrame.bottom=mWinFrame.height();
      }
 else {
        float appInvertedScale=mTranslator.applicationInvertedScale;
        mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
        mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
      }
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
        if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (localLOGV)         Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || reportDrawNeeded) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}"
22584,"public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
synchronized (this) {
      if (mCurWidth != w || mCurHeight != h) {
        mCurWidth=w;
        mCurHeight=h;
      }
      if (reportDraw) {
        try {
          surfaceView.mSession.finishDrawing(surfaceView.mWindow);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
    surfaceView.mSurfaceLock.lock();
    try {
      if (reportDraw) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mReportDrawNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
 else       if (surfaceView.mWinFrame.width() != w || surfaceView.mWinFrame.height() != h) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
    }
  finally {
      surfaceView.mSurfaceLock.unlock();
    }
  }
}"
22585,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
case UPDATE_WINDOW_MSG:
{
updateWindow(false);
}
break;
}
}"
22586,"private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      if (mTranslator == null) {
        mSurfaceFrame.right=mWinFrame.width();
        mSurfaceFrame.bottom=mWinFrame.height();
      }
 else {
        float appInvertedScale=mTranslator.applicationInvertedScale;
        mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
        mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
      }
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
        if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (localLOGV)         Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || reportDrawNeeded) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}"
22587,"public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
synchronized (this) {
      if (mCurWidth != w || mCurHeight != h) {
        mCurWidth=w;
        mCurHeight=h;
      }
      if (reportDraw) {
        try {
          surfaceView.mSession.finishDrawing(surfaceView.mWindow);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
    surfaceView.mSurfaceLock.lock();
    try {
      if (reportDraw) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mReportDrawNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
 else       if (surfaceView.mWinFrame.width() != w || surfaceView.mWinFrame.height() != h) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
    }
  finally {
      surfaceView.mSurfaceLock.unlock();
    }
  }
}"
22588,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
case UPDATE_WINDOW_MSG:
{
updateWindow(false);
}
break;
}
}"
22589,"private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      if (mTranslator == null) {
        mSurfaceFrame.right=mWinFrame.width();
        mSurfaceFrame.bottom=mWinFrame.height();
      }
 else {
        float appInvertedScale=mTranslator.applicationInvertedScale;
        mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
        mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
      }
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
        if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (localLOGV)         Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || reportDrawNeeded) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}"
22590,"/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}","/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mLastDimWidth=dw;
      mLastDimHeight=dh;
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
 else   if (mLastDimWidth != dw || mLastDimHeight != dh) {
    mLastDimWidth=dw;
    mLastDimHeight=dh;
    mDimSurface.setSize(dw,dh);
  }
}"
22591,"/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,0,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}","/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}"
22592,"private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  HistoryRecord r=null;
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      r=(HistoryRecord)o;
      index=i;
      break;
    }
  }
  return index;
}","private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      index=i;
      break;
    }
  }
  return index;
}"
22593,"private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}","private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
 else {
    HistoryRecord r=topRunningActivityLocked(null);
    if (r.app == app) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
      int index=indexOfTokenLocked(r);
      finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      index--;
      if (index >= 0) {
        r=(HistoryRecord)mHistory.get(index);
        if (r.state == ActivityState.RESUMED || r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
          if (!r.isHomeActivity) {
            Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
            finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
        }
      }
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}"
22594,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}"
22595,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}"
22596,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
synchronized (mPackages) {
      verifySignaturesLP(mSettings.mPackages.get(pkgName),pkg,parseFlags,true);
    }
  }
 else {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      PackageInstalledInfo restoreRes=new PackageInstalledInfo();
      restoreRes.removedInfo=new PackageRemovedInfo();
      parseFlags|=~PackageManager.INSTALL_REPLACE_EXISTING;
      scanPackageLI(restoreFile,parseFlags,scanMode);
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      if (restoreRes.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      }
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
synchronized (mPackages) {
      verifySignaturesLP(mSettings.mPackages.get(pkgName),pkg,parseFlags,true);
    }
  }
 else {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      PackageInstalledInfo restoreRes=new PackageInstalledInfo();
      restoreRes.removedInfo=new PackageRemovedInfo();
      parseFlags&=~PackageManager.INSTALL_REPLACE_EXISTING;
      scanPackageLI(restoreFile,parseFlags,scanMode);
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      if (restoreRes.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      }
    }
  }
}"
22597,"private void installNewPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  String pkgName=pkg.packageName;
  boolean dataDirExists=getDataPathForPackage(pkg).exists();
  res.name=pkgName;
synchronized (mPackages) {
    if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  PackageParser.Package newPackage=scanPackageLI(pkg,parseFlags,scanMode);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    updateSettingsLI(newPackage,installerPackageName,res);
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
      deletePackageLI(pkgName,false,dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,res.removedInfo);
    }
  }
}","private void installNewPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  String pkgName=pkg.packageName;
  boolean dataDirExists=getDataPathForPackage(pkg).exists();
  res.name=pkgName;
synchronized (mPackages) {
    if (mSettings.mRenamedPackages.containsKey(pkgName)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ mSettings.mRenamedPackages.get(pkgName));
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
    if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  PackageParser.Package newPackage=scanPackageLI(pkg,parseFlags,scanMode);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    updateSettingsLI(newPackage,installerPackageName,res);
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
      deletePackageLI(pkgName,false,dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,res.removedInfo);
    }
  }
}"
22598,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
synchronized (mPackages) {
      verifySignaturesLP(mSettings.mPackages.get(pkgName),pkg,parseFlags,true);
    }
  }
 else {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      PackageInstalledInfo restoreRes=new PackageInstalledInfo();
      restoreRes.removedInfo=new PackageRemovedInfo();
      parseFlags|=~PackageManager.INSTALL_REPLACE_EXISTING;
      scanPackageLI(restoreFile,parseFlags,scanMode);
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      if (restoreRes.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      }
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
synchronized (mPackages) {
      verifySignaturesLP(mSettings.mPackages.get(pkgName),pkg,parseFlags,true);
    }
  }
 else {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      PackageInstalledInfo restoreRes=new PackageInstalledInfo();
      restoreRes.removedInfo=new PackageRemovedInfo();
      parseFlags&=~PackageManager.INSTALL_REPLACE_EXISTING;
      scanPackageLI(restoreFile,parseFlags,scanMode);
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      if (restoreRes.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      }
    }
  }
}"
22599,"private void installNewPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  String pkgName=pkg.packageName;
  boolean dataDirExists=getDataPathForPackage(pkg).exists();
  res.name=pkgName;
synchronized (mPackages) {
    if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  PackageParser.Package newPackage=scanPackageLI(pkg,parseFlags,scanMode);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    updateSettingsLI(newPackage,installerPackageName,res);
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
      deletePackageLI(pkgName,false,dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,res.removedInfo);
    }
  }
}","private void installNewPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  String pkgName=pkg.packageName;
  boolean dataDirExists=getDataPathForPackage(pkg).exists();
  res.name=pkgName;
synchronized (mPackages) {
    if (mSettings.mRenamedPackages.containsKey(pkgName)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ mSettings.mRenamedPackages.get(pkgName));
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
    if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  PackageParser.Package newPackage=scanPackageLI(pkg,parseFlags,scanMode);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    updateSettingsLI(newPackage,installerPackageName,res);
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
      deletePackageLI(pkgName,false,dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,res.removedInfo);
    }
  }
}"
22600,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
synchronized (mPackages) {
      verifySignaturesLP(mSettings.mPackages.get(pkgName),pkg,parseFlags,true);
    }
  }
 else {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      PackageInstalledInfo restoreRes=new PackageInstalledInfo();
      restoreRes.removedInfo=new PackageRemovedInfo();
      parseFlags|=~PackageManager.INSTALL_REPLACE_EXISTING;
      scanPackageLI(restoreFile,parseFlags,scanMode);
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      if (restoreRes.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      }
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
synchronized (mPackages) {
      verifySignaturesLP(mSettings.mPackages.get(pkgName),pkg,parseFlags,true);
    }
  }
 else {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      PackageInstalledInfo restoreRes=new PackageInstalledInfo();
      restoreRes.removedInfo=new PackageRemovedInfo();
      parseFlags&=~PackageManager.INSTALL_REPLACE_EXISTING;
      scanPackageLI(restoreFile,parseFlags,scanMode);
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      if (restoreRes.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      }
    }
  }
}"
22601,"private void installNewPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  String pkgName=pkg.packageName;
  boolean dataDirExists=getDataPathForPackage(pkg).exists();
  res.name=pkgName;
synchronized (mPackages) {
    if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  PackageParser.Package newPackage=scanPackageLI(pkg,parseFlags,scanMode);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    updateSettingsLI(newPackage,installerPackageName,res);
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
      deletePackageLI(pkgName,false,dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,res.removedInfo);
    }
  }
}","private void installNewPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  String pkgName=pkg.packageName;
  boolean dataDirExists=getDataPathForPackage(pkg).exists();
  res.name=pkgName;
synchronized (mPackages) {
    if (mSettings.mRenamedPackages.containsKey(pkgName)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ mSettings.mRenamedPackages.get(pkgName));
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
    if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  PackageParser.Package newPackage=scanPackageLI(pkg,parseFlags,scanMode);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    updateSettingsLI(newPackage,installerPackageName,res);
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
      deletePackageLI(pkgName,false,dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,res.removedInfo);
    }
  }
}"
22602,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}"
22603,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}"
22604,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}"
22605,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}"
22606,"final void updateLocked(int flags){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    if (oldAction != null && (flags & UiModeManager.DISABLE_CAR_MODE_GO_HOME) != 0) {
      try {
        Intent intent=new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        updateConfigurationLocked(false);
        ActivityManagerNative.getDefault().startActivityWithConfig(null,intent,null,null,0,null,null,0,false,false,mConfiguration);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,e.getCause());
      }
    }
 else {
      updateConfigurationLocked(true);
    }
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","final void updateLocked(int flags){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    if (oldAction != null && (flags & UiModeManager.DISABLE_CAR_MODE_GO_HOME) != 0) {
      try {
        Intent intent=new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mHoldingConfiguration=false;
        updateConfigurationLocked(false);
        ActivityManagerNative.getDefault().startActivityWithConfig(null,intent,null,null,0,null,null,0,false,false,mConfiguration);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,e.getCause());
      }
    }
 else {
      updateConfigurationLocked(true);
    }
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
22607,"/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
private final boolean ensureActivityConfigurationLocked(HistoryRecord r,int globalChanges){
  if (!mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}","/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
private final boolean ensureActivityConfigurationLocked(HistoryRecord r,int globalChanges){
  if (mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}"
22608,"private final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mConfiguration.diff(config) != 0;
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (config != null && mConfigWillChange) {
      enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        HistoryRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}","private final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mConfiguration.diff(config) != 0;
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + mConfigWillChange);
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (mConfigWillChange) {
      enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      mConfigWillChange=false;
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
      updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        HistoryRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}"
22609,"final void updateLocked(int flags){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    if (oldAction != null && (flags & UiModeManager.DISABLE_CAR_MODE_GO_HOME) != 0) {
      try {
        Intent intent=new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        updateConfigurationLocked(false);
        ActivityManagerNative.getDefault().startActivityWithConfig(null,intent,null,null,0,null,null,0,false,false,mConfiguration);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,e.getCause());
      }
    }
 else {
      updateConfigurationLocked(true);
    }
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","final void updateLocked(int flags){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    if (oldAction != null && (flags & UiModeManager.DISABLE_CAR_MODE_GO_HOME) != 0) {
      try {
        Intent intent=new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mHoldingConfiguration=false;
        updateConfigurationLocked(false);
        ActivityManagerNative.getDefault().startActivityWithConfig(null,intent,null,null,0,null,null,0,false,false,mConfiguration);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,e.getCause());
      }
    }
 else {
      updateConfigurationLocked(true);
    }
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
22610,"/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
private final boolean ensureActivityConfigurationLocked(HistoryRecord r,int globalChanges){
  if (!mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}","/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
private final boolean ensureActivityConfigurationLocked(HistoryRecord r,int globalChanges){
  if (mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}"
22611,"private final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mConfiguration.diff(config) != 0;
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (config != null && mConfigWillChange) {
      enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        HistoryRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}","private final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mConfiguration.diff(config) != 0;
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + mConfigWillChange);
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (mConfigWillChange) {
      enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      mConfigWillChange=false;
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
      updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        HistoryRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}"
22612,"final void updateLocked(int flags){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    if (oldAction != null && (flags & UiModeManager.DISABLE_CAR_MODE_GO_HOME) != 0) {
      try {
        Intent intent=new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        updateConfigurationLocked(false);
        ActivityManagerNative.getDefault().startActivityWithConfig(null,intent,null,null,0,null,null,0,false,false,mConfiguration);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,e.getCause());
      }
    }
 else {
      updateConfigurationLocked(true);
    }
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","final void updateLocked(int flags){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    if (oldAction != null && (flags & UiModeManager.DISABLE_CAR_MODE_GO_HOME) != 0) {
      try {
        Intent intent=new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mHoldingConfiguration=false;
        updateConfigurationLocked(false);
        ActivityManagerNative.getDefault().startActivityWithConfig(null,intent,null,null,0,null,null,0,false,false,mConfiguration);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,e.getCause());
      }
    }
 else {
      updateConfigurationLocked(true);
    }
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
22613,"/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
private final boolean ensureActivityConfigurationLocked(HistoryRecord r,int globalChanges){
  if (!mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}","/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
private final boolean ensureActivityConfigurationLocked(HistoryRecord r,int globalChanges){
  if (mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}"
22614,"private final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mConfiguration.diff(config) != 0;
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (config != null && mConfigWillChange) {
      enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        HistoryRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}","private final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mConfiguration.diff(config) != 0;
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + mConfigWillChange);
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (mConfigWillChange) {
      enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      mConfigWillChange=false;
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
      updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        HistoryRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}"
22615,"/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}","/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}"
22616,"/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label;
    }
  }
  return ci.loadLabel(pm);
}","/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label.toString().trim();
    }
  }
  CharSequence data=ci.loadLabel(pm);
  if (data != null)   data=data.toString().trim();
  return data;
}"
22617,"/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}","/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}"
22618,"/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label;
    }
  }
  return ci.loadLabel(pm);
}","/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label.toString().trim();
    }
  }
  CharSequence data=ci.loadLabel(pm);
  if (data != null)   data=data.toString().trim();
  return data;
}"
22619,"/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}","/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}"
22620,"/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label;
    }
  }
  return ci.loadLabel(pm);
}","/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label.toString().trim();
    }
  }
  CharSequence data=ci.loadLabel(pm);
  if (data != null)   data=data.toString().trim();
  return data;
}"
22621,"/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}","/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}"
22622,"/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label;
    }
  }
  return ci.loadLabel(pm);
}","/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label.toString().trim();
    }
  }
  CharSequence data=ci.loadLabel(pm);
  if (data != null)   data=data.toString().trim();
  return data;
}"
22623,"private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
22624,"private Intent makeIntent() throws URISyntaxException {
  Intent intent=new Intent();
  boolean hasIntentInfo=false;
  mDebugOption=false;
  mWaitOption=false;
  Uri data=null;
  String type=null;
  String opt;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      intent.setAction(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      data=Uri.parse(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      type=nextArgRequired();
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addCategory(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"") || opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,value);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      intent.putExtra(key,(String)null);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Integer.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Boolean.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      ComponentName cn=ComponentName.unflattenFromString(str);
      if (cn == null)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      intent.setComponent(cn);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      intent.setFlags(Integer.decode(str).intValue());
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mDebugOption=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mWaitOption=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      showUsage();
      return null;
    }
  }
  intent.setDataAndType(data,type);
  String uri=nextArg();
  if (uri != null) {
    Intent oldIntent=intent;
    intent=Intent.getIntent(uri);
    if (oldIntent.getAction() != null) {
      intent.setAction(oldIntent.getAction());
    }
    if (oldIntent.getData() != null || oldIntent.getType() != null) {
      intent.setDataAndType(oldIntent.getData(),oldIntent.getType());
    }
    Set cats=oldIntent.getCategories();
    if (cats != null) {
      Iterator it=cats.iterator();
      while (it.hasNext()) {
        intent.addCategory((String)it.next());
      }
    }
    hasIntentInfo=true;
  }
  if (!hasIntentInfo)   throw new IllegalArgumentException(""String_Node_Str"");
  return intent;
}","private Intent makeIntent() throws URISyntaxException {
  Intent intent=new Intent();
  boolean hasIntentInfo=false;
  mDebugOption=false;
  mWaitOption=false;
  Uri data=null;
  String type=null;
  String opt;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      intent.setAction(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      data=Uri.parse(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      type=nextArgRequired();
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addCategory(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"") || opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,value);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      intent.putExtra(key,(String)null);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Integer.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Boolean.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      ComponentName cn=ComponentName.unflattenFromString(str);
      if (cn == null)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      intent.setComponent(cn);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      intent.setFlags(Integer.decode(str).intValue());
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_DEBUG_LOG_RESOLUTION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_USER_ACTION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mDebugOption=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mWaitOption=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      showUsage();
      return null;
    }
  }
  intent.setDataAndType(data,type);
  String uri=nextArg();
  if (uri != null) {
    Intent oldIntent=intent;
    intent=Intent.getIntent(uri);
    if (oldIntent.getAction() != null) {
      intent.setAction(oldIntent.getAction());
    }
    if (oldIntent.getData() != null || oldIntent.getType() != null) {
      intent.setDataAndType(oldIntent.getData(),oldIntent.getType());
    }
    Set cats=oldIntent.getCategories();
    if (cats != null) {
      Iterator it=cats.iterator();
      while (it.hasNext()) {
        intent.addCategory((String)it.next());
      }
    }
    hasIntentInfo=true;
  }
  if (!hasIntentInfo)   throw new IllegalArgumentException(""String_Node_Str"");
  return intent;
}"
22625,"public void onClick(DialogInterface dialog,int which){
  ResolveInfo ri=mAdapter.resolveInfoForPosition(which);
  Intent intent=mAdapter.intentForPosition(which);
  if ((mAlwaysCheck != null) && mAlwaysCheck.isChecked()) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
 else     if (data != null && data.getScheme() != null) {
      filter.addDataScheme(data.getScheme());
      Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
      if (aIt != null) {
        while (aIt.hasNext()) {
          IntentFilter.AuthorityEntry a=aIt.next();
          if (a.match(data) >= 0) {
            int port=a.getPort();
            filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
            break;
          }
        }
      }
      Iterator<PatternMatcher> pIt=ri.filter.pathsIterator();
      if (pIt != null) {
        String path=data.getPath();
        while (path != null && pIt.hasNext()) {
          PatternMatcher p=pIt.next();
          if (p.match(path)) {
            filter.addDataPath(p.getPath(),p.getType());
            break;
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
  finish();
}","public void onClick(DialogInterface dialog,int which){
  ResolveInfo ri=mAdapter.resolveInfoForPosition(which);
  Intent intent=mAdapter.intentForPosition(which);
  if ((mAlwaysCheck != null) && mAlwaysCheck.isChecked()) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        Iterator<PatternMatcher> pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
  finish();
}"
22626,"private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
22627,"private Intent makeIntent() throws URISyntaxException {
  Intent intent=new Intent();
  boolean hasIntentInfo=false;
  mDebugOption=false;
  mWaitOption=false;
  Uri data=null;
  String type=null;
  String opt;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      intent.setAction(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      data=Uri.parse(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      type=nextArgRequired();
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addCategory(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"") || opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,value);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      intent.putExtra(key,(String)null);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Integer.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Boolean.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      ComponentName cn=ComponentName.unflattenFromString(str);
      if (cn == null)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      intent.setComponent(cn);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      intent.setFlags(Integer.decode(str).intValue());
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mDebugOption=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mWaitOption=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      showUsage();
      return null;
    }
  }
  intent.setDataAndType(data,type);
  String uri=nextArg();
  if (uri != null) {
    Intent oldIntent=intent;
    intent=Intent.getIntent(uri);
    if (oldIntent.getAction() != null) {
      intent.setAction(oldIntent.getAction());
    }
    if (oldIntent.getData() != null || oldIntent.getType() != null) {
      intent.setDataAndType(oldIntent.getData(),oldIntent.getType());
    }
    Set cats=oldIntent.getCategories();
    if (cats != null) {
      Iterator it=cats.iterator();
      while (it.hasNext()) {
        intent.addCategory((String)it.next());
      }
    }
    hasIntentInfo=true;
  }
  if (!hasIntentInfo)   throw new IllegalArgumentException(""String_Node_Str"");
  return intent;
}","private Intent makeIntent() throws URISyntaxException {
  Intent intent=new Intent();
  boolean hasIntentInfo=false;
  mDebugOption=false;
  mWaitOption=false;
  Uri data=null;
  String type=null;
  String opt;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      intent.setAction(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      data=Uri.parse(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      type=nextArgRequired();
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addCategory(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"") || opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,value);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      intent.putExtra(key,(String)null);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Integer.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Boolean.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      ComponentName cn=ComponentName.unflattenFromString(str);
      if (cn == null)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      intent.setComponent(cn);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      intent.setFlags(Integer.decode(str).intValue());
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_DEBUG_LOG_RESOLUTION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_USER_ACTION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mDebugOption=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mWaitOption=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      showUsage();
      return null;
    }
  }
  intent.setDataAndType(data,type);
  String uri=nextArg();
  if (uri != null) {
    Intent oldIntent=intent;
    intent=Intent.getIntent(uri);
    if (oldIntent.getAction() != null) {
      intent.setAction(oldIntent.getAction());
    }
    if (oldIntent.getData() != null || oldIntent.getType() != null) {
      intent.setDataAndType(oldIntent.getData(),oldIntent.getType());
    }
    Set cats=oldIntent.getCategories();
    if (cats != null) {
      Iterator it=cats.iterator();
      while (it.hasNext()) {
        intent.addCategory((String)it.next());
      }
    }
    hasIntentInfo=true;
  }
  if (!hasIntentInfo)   throw new IllegalArgumentException(""String_Node_Str"");
  return intent;
}"
22628,"public void onClick(DialogInterface dialog,int which){
  ResolveInfo ri=mAdapter.resolveInfoForPosition(which);
  Intent intent=mAdapter.intentForPosition(which);
  if ((mAlwaysCheck != null) && mAlwaysCheck.isChecked()) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
 else     if (data != null && data.getScheme() != null) {
      filter.addDataScheme(data.getScheme());
      Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
      if (aIt != null) {
        while (aIt.hasNext()) {
          IntentFilter.AuthorityEntry a=aIt.next();
          if (a.match(data) >= 0) {
            int port=a.getPort();
            filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
            break;
          }
        }
      }
      Iterator<PatternMatcher> pIt=ri.filter.pathsIterator();
      if (pIt != null) {
        String path=data.getPath();
        while (path != null && pIt.hasNext()) {
          PatternMatcher p=pIt.next();
          if (p.match(path)) {
            filter.addDataPath(p.getPath(),p.getType());
            break;
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
  finish();
}","public void onClick(DialogInterface dialog,int which){
  ResolveInfo ri=mAdapter.resolveInfoForPosition(which);
  Intent intent=mAdapter.intentForPosition(which);
  if ((mAlwaysCheck != null) && mAlwaysCheck.isChecked()) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        Iterator<PatternMatcher> pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
  finish();
}"
22629,"private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
22630,"private Intent makeIntent() throws URISyntaxException {
  Intent intent=new Intent();
  boolean hasIntentInfo=false;
  mDebugOption=false;
  mWaitOption=false;
  Uri data=null;
  String type=null;
  String opt;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      intent.setAction(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      data=Uri.parse(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      type=nextArgRequired();
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addCategory(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"") || opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,value);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      intent.putExtra(key,(String)null);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Integer.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Boolean.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      ComponentName cn=ComponentName.unflattenFromString(str);
      if (cn == null)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      intent.setComponent(cn);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      intent.setFlags(Integer.decode(str).intValue());
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mDebugOption=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mWaitOption=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      showUsage();
      return null;
    }
  }
  intent.setDataAndType(data,type);
  String uri=nextArg();
  if (uri != null) {
    Intent oldIntent=intent;
    intent=Intent.getIntent(uri);
    if (oldIntent.getAction() != null) {
      intent.setAction(oldIntent.getAction());
    }
    if (oldIntent.getData() != null || oldIntent.getType() != null) {
      intent.setDataAndType(oldIntent.getData(),oldIntent.getType());
    }
    Set cats=oldIntent.getCategories();
    if (cats != null) {
      Iterator it=cats.iterator();
      while (it.hasNext()) {
        intent.addCategory((String)it.next());
      }
    }
    hasIntentInfo=true;
  }
  if (!hasIntentInfo)   throw new IllegalArgumentException(""String_Node_Str"");
  return intent;
}","private Intent makeIntent() throws URISyntaxException {
  Intent intent=new Intent();
  boolean hasIntentInfo=false;
  mDebugOption=false;
  mWaitOption=false;
  Uri data=null;
  String type=null;
  String opt;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      intent.setAction(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      data=Uri.parse(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      type=nextArgRequired();
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addCategory(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"") || opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,value);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      intent.putExtra(key,(String)null);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Integer.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Boolean.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      ComponentName cn=ComponentName.unflattenFromString(str);
      if (cn == null)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      intent.setComponent(cn);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      intent.setFlags(Integer.decode(str).intValue());
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_DEBUG_LOG_RESOLUTION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_USER_ACTION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mDebugOption=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mWaitOption=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      showUsage();
      return null;
    }
  }
  intent.setDataAndType(data,type);
  String uri=nextArg();
  if (uri != null) {
    Intent oldIntent=intent;
    intent=Intent.getIntent(uri);
    if (oldIntent.getAction() != null) {
      intent.setAction(oldIntent.getAction());
    }
    if (oldIntent.getData() != null || oldIntent.getType() != null) {
      intent.setDataAndType(oldIntent.getData(),oldIntent.getType());
    }
    Set cats=oldIntent.getCategories();
    if (cats != null) {
      Iterator it=cats.iterator();
      while (it.hasNext()) {
        intent.addCategory((String)it.next());
      }
    }
    hasIntentInfo=true;
  }
  if (!hasIntentInfo)   throw new IllegalArgumentException(""String_Node_Str"");
  return intent;
}"
22631,"public void onClick(DialogInterface dialog,int which){
  ResolveInfo ri=mAdapter.resolveInfoForPosition(which);
  Intent intent=mAdapter.intentForPosition(which);
  if ((mAlwaysCheck != null) && mAlwaysCheck.isChecked()) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
 else     if (data != null && data.getScheme() != null) {
      filter.addDataScheme(data.getScheme());
      Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
      if (aIt != null) {
        while (aIt.hasNext()) {
          IntentFilter.AuthorityEntry a=aIt.next();
          if (a.match(data) >= 0) {
            int port=a.getPort();
            filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
            break;
          }
        }
      }
      Iterator<PatternMatcher> pIt=ri.filter.pathsIterator();
      if (pIt != null) {
        String path=data.getPath();
        while (path != null && pIt.hasNext()) {
          PatternMatcher p=pIt.next();
          if (p.match(path)) {
            filter.addDataPath(p.getPath(),p.getType());
            break;
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
  finish();
}","public void onClick(DialogInterface dialog,int which){
  ResolveInfo ri=mAdapter.resolveInfoForPosition(which);
  Intent intent=mAdapter.intentForPosition(which);
  if ((mAlwaysCheck != null) && mAlwaysCheck.isChecked()) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        Iterator<PatternMatcher> pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
  finish();
}"
22632,"void startSpringback(){
  if (mScroller.springback(0,mScrollY,0,0,0,0)) {
    mTouchMode=TOUCH_MODE_OVERFLING;
    invalidate();
    post(this);
  }
}","void startSpringback(){
  if (mScroller.springback(0,mScrollY,0,0,0,0)) {
    mTouchMode=TOUCH_MODE_OVERFLING;
    invalidate();
    post(this);
  }
 else {
    mTouchMode=TOUCH_MODE_REST;
  }
}"
22633,"void startSpringback(){
  if (mScroller.springback(0,mScrollY,0,0,0,0)) {
    mTouchMode=TOUCH_MODE_OVERFLING;
    invalidate();
    post(this);
  }
}","void startSpringback(){
  if (mScroller.springback(0,mScrollY,0,0,0,0)) {
    mTouchMode=TOUCH_MODE_OVERFLING;
    invalidate();
    post(this);
  }
 else {
    mTouchMode=TOUCH_MODE_REST;
  }
}"
22634,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}"
22635,"/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}","/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurfaceShown=true;
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}"
22636,"void reclaimSomeSurfaceMemoryLocked(WindowState win,String operation){
  final Surface surface=win.mSurface;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,win.toString(),win.mSession.mPid,operation);
  if (mForceRemoves == null) {
    mForceRemoves=new ArrayList<WindowState>();
  }
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    int N=mWindows.size();
    boolean leakedSurface=false;
    Slog.i(TAG,""String_Node_Str"");
    for (int i=0; i < N; i++) {
      WindowState ws=(WindowState)mWindows.get(i);
      if (ws.mSurface != null) {
        if (!mSessions.contains(ws.mSession)) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mToken+ ""String_Node_Str""+ ws.mSession.mPid+ ""String_Node_Str""+ ws.mSession.mUid);
          ws.mSurface.destroy();
          ws.mSurface=null;
          mForceRemoves.add(ws);
          i--;
          N--;
          leakedSurface=true;
        }
 else         if (win.mAppToken != null && win.mAppToken.clientHidden) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mAppToken);
          ws.mSurface.destroy();
          ws.mSurface=null;
          leakedSurface=true;
        }
      }
    }
    boolean killedApps=false;
    if (!leakedSurface) {
      Slog.w(TAG,""String_Node_Str"");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int i=0; i < N; i++) {
        WindowState ws=(WindowState)mWindows.get(i);
        if (ws.mSurface != null) {
          pidCandidates.append(ws.mSession.mPid,ws.mSession.mPid);
        }
      }
      if (pidCandidates.size() > 0) {
        int[] pids=new int[pidCandidates.size()];
        for (int i=0; i < pids.length; i++) {
          pids[i]=pidCandidates.keyAt(i);
        }
        try {
          if (mActivityManager.killPids(pids,""String_Node_Str"")) {
            killedApps=true;
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG,""String_Node_Str"");
      if (surface != null) {
        surface.destroy();
        win.mSurface=null;
      }
      try {
        win.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
}","void reclaimSomeSurfaceMemoryLocked(WindowState win,String operation){
  final Surface surface=win.mSurface;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,win.toString(),win.mSession.mPid,operation);
  if (mForceRemoves == null) {
    mForceRemoves=new ArrayList<WindowState>();
  }
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    int N=mWindows.size();
    boolean leakedSurface=false;
    Slog.i(TAG,""String_Node_Str"");
    for (int i=0; i < N; i++) {
      WindowState ws=(WindowState)mWindows.get(i);
      if (ws.mSurface != null) {
        if (!mSessions.contains(ws.mSession)) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mToken+ ""String_Node_Str""+ ws.mSession.mPid+ ""String_Node_Str""+ ws.mSession.mUid);
          ws.mSurface.destroy();
          ws.mSurfaceShown=false;
          ws.mSurface=null;
          mForceRemoves.add(ws);
          i--;
          N--;
          leakedSurface=true;
        }
 else         if (win.mAppToken != null && win.mAppToken.clientHidden) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mAppToken);
          ws.mSurface.destroy();
          ws.mSurfaceShown=false;
          ws.mSurface=null;
          leakedSurface=true;
        }
      }
    }
    boolean killedApps=false;
    if (!leakedSurface) {
      Slog.w(TAG,""String_Node_Str"");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int i=0; i < N; i++) {
        WindowState ws=(WindowState)mWindows.get(i);
        if (ws.mSurface != null) {
          pidCandidates.append(ws.mSession.mPid,ws.mSession.mPid);
        }
      }
      if (pidCandidates.size() > 0) {
        int[] pids=new int[pidCandidates.size()];
        for (int i=0; i < pids.length; i++) {
          pids[i]=pidCandidates.keyAt(i);
        }
        try {
          if (mActivityManager.killPids(pids,""String_Node_Str"")) {
            killedApps=true;
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG,""String_Node_Str"");
      if (surface != null) {
        surface.destroy();
        win.mSurfaceShown=false;
        win.mSurface=null;
      }
      try {
        win.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
}"
22637,"/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
  mDimShown=true;
  try {
    mDimSurface.setPosition(0,0);
    mDimSurface.setSize(dw,dh);
    mDimSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}"
22638,"void finishExit(){
  if (DEBUG_ANIM)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mExiting+ ""String_Node_Str""+ mRemoveOnExit+ ""String_Node_Str""+ isWindowAnimating());
  final int N=mChildWindows.size();
  for (int i=0; i < N; i++) {
    ((WindowState)mChildWindows.get(i)).finishExit();
  }
  if (!mExiting) {
    return;
  }
  if (isWindowAnimating()) {
    return;
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mRemoveOnExit);
  if (mSurface != null) {
    mDestroySurface.add(this);
    mDestroying=true;
    if (SHOW_TRANSACTIONS)     logSurface(this,""String_Node_Str"",null);
    try {
      mSurface.hide();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this,e);
    }
    mLastHidden=true;
    mKeyWaiter.releasePendingPointerLocked(mSession);
  }
  mExiting=false;
  if (mRemoveOnExit) {
    mPendingRemove.add(this);
    mRemoveOnExit=false;
  }
}","void finishExit(){
  if (DEBUG_ANIM)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mExiting+ ""String_Node_Str""+ mRemoveOnExit+ ""String_Node_Str""+ isWindowAnimating());
  final int N=mChildWindows.size();
  for (int i=0; i < N; i++) {
    ((WindowState)mChildWindows.get(i)).finishExit();
  }
  if (!mExiting) {
    return;
  }
  if (isWindowAnimating()) {
    return;
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mRemoveOnExit);
  if (mSurface != null) {
    mDestroySurface.add(this);
    mDestroying=true;
    if (SHOW_TRANSACTIONS)     logSurface(this,""String_Node_Str"",null);
    mSurfaceShown=false;
    try {
      mSurface.hide();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this,e);
    }
    mLastHidden=true;
    mKeyWaiter.releasePendingPointerLocked(mSession);
  }
  mExiting=false;
  if (mRemoveOnExit) {
    mPendingRemove.add(this);
    mRemoveOnExit=false;
  }
}"
22639,"void destroySurfaceLocked(){
  mKeyWaiter.finishedKey(mSession,mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(mSession);
  mKeyWaiter.releasePendingTrackballLocked(mSession);
  if (mAppToken != null && this == mAppToken.startingWindow) {
    mAppToken.startingDisplayed=false;
  }
  if (mSurface != null) {
    mDrawPending=false;
    mCommitDrawPending=false;
    mReadyToShow=false;
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      c.mAttachedHidden=true;
    }
    if (mReportDestroySurface) {
      mReportDestroySurface=false;
      mSurfacePendingDestroy=true;
      try {
        mClient.dispatchGetNewSurface();
        return;
      }
 catch (      RemoteException e) {
      }
    }
    try {
      if (DEBUG_VISIBILITY) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession,e);
      }
      if (SHOW_TRANSACTIONS) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        if (SHOW_TRANSACTIONS)         logSurface(this,""String_Node_Str"",e);
      }
      mSurface.destroy();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
    }
    mSurface=null;
  }
}","void destroySurfaceLocked(){
  mKeyWaiter.finishedKey(mSession,mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(mSession);
  mKeyWaiter.releasePendingTrackballLocked(mSession);
  if (mAppToken != null && this == mAppToken.startingWindow) {
    mAppToken.startingDisplayed=false;
  }
  if (mSurface != null) {
    mDrawPending=false;
    mCommitDrawPending=false;
    mReadyToShow=false;
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      c.mAttachedHidden=true;
    }
    if (mReportDestroySurface) {
      mReportDestroySurface=false;
      mSurfacePendingDestroy=true;
      try {
        mClient.dispatchGetNewSurface();
        return;
      }
 catch (      RemoteException e) {
      }
    }
    try {
      if (DEBUG_VISIBILITY) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession,e);
      }
      if (SHOW_TRANSACTIONS) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        if (SHOW_TRANSACTIONS)         logSurface(this,""String_Node_Str"",e);
      }
      mSurface.destroy();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
    }
    mSurfaceShown=false;
    mSurface=null;
  }
}"
22640,"Surface createSurfaceLocked(){
  if (mSurface == null) {
    mReportDestroySurface=false;
    mSurfacePendingDestroy=false;
    mDrawPending=true;
    mCommitDrawPending=false;
    mReadyToShow=false;
    if (mAppToken != null) {
      mAppToken.allDrawn=false;
    }
    int flags=0;
    if (mAttrs.memoryType == MEMORY_TYPE_PUSH_BUFFERS) {
      flags|=Surface.PUSH_BUFFERS;
    }
    if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SECURE) != 0) {
      flags|=Surface.SECURE;
    }
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + mSession.mSurfaceSession + ""String_Node_Str""+ this+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ flags);
    int w=mFrame.width();
    int h=mFrame.height();
    if ((mAttrs.flags & LayoutParams.FLAG_SCALED) != 0) {
      w=mRequestedWidth;
      h=mRequestedHeight;
    }
    if (w <= 0)     w=1;
    if (h <= 0)     h=1;
    try {
      mSurface=new Surface(mSession.mSurfaceSession,mSession.mPid,mAttrs.getTitle().toString(),0,w,h,mAttrs.format,flags);
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mSession.mSurfaceSession+ ""String_Node_Str""+ mSession.mPid+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ this);
    }
 catch (    Surface.OutOfResourcesException e) {
      Slog.w(TAG,""String_Node_Str"");
      reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      return null;
    }
catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
      return null;
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mFrame.left+ ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mAnimLayer);
    if (SHOW_TRANSACTIONS) {
      Slog.i(TAG,""String_Node_Str"");
      if (SHOW_TRANSACTIONS)       logSurface(this,""String_Node_Str"" + mFrame.left + ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str"",null);
    }
    Surface.openTransaction();
    try {
      try {
        mSurface.setPosition(mFrame.left + mXOffset,mFrame.top + mYOffset);
        mSurface.setLayer(mAnimLayer);
        mSurface.hide();
        if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_DITHER) != 0) {
          if (SHOW_TRANSACTIONS)           logSurface(this,""String_Node_Str"",null);
          mSurface.setFlags(Surface.SURFACE_DITHER,Surface.SURFACE_DITHER);
        }
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w,e);
        reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      }
      mLastHidden=true;
    }
  finally {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
      Surface.closeTransaction();
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + this);
  }
  return mSurface;
}","Surface createSurfaceLocked(){
  if (mSurface == null) {
    mReportDestroySurface=false;
    mSurfacePendingDestroy=false;
    mDrawPending=true;
    mCommitDrawPending=false;
    mReadyToShow=false;
    if (mAppToken != null) {
      mAppToken.allDrawn=false;
    }
    int flags=0;
    if (mAttrs.memoryType == MEMORY_TYPE_PUSH_BUFFERS) {
      flags|=Surface.PUSH_BUFFERS;
    }
    if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SECURE) != 0) {
      flags|=Surface.SECURE;
    }
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + mSession.mSurfaceSession + ""String_Node_Str""+ this+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ flags);
    int w=mFrame.width();
    int h=mFrame.height();
    if ((mAttrs.flags & LayoutParams.FLAG_SCALED) != 0) {
      w=mRequestedWidth;
      h=mRequestedHeight;
    }
    if (w <= 0)     w=1;
    if (h <= 0)     h=1;
    mSurfaceShown=false;
    mSurfaceLayer=0;
    mSurfaceAlpha=1;
    mSurfaceX=0;
    mSurfaceY=0;
    mSurfaceW=w;
    mSurfaceH=h;
    try {
      mSurface=new Surface(mSession.mSurfaceSession,mSession.mPid,mAttrs.getTitle().toString(),0,w,h,mAttrs.format,flags);
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mSession.mSurfaceSession+ ""String_Node_Str""+ mSession.mPid+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ this);
    }
 catch (    Surface.OutOfResourcesException e) {
      Slog.w(TAG,""String_Node_Str"");
      reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      return null;
    }
catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
      return null;
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mFrame.left+ ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mAnimLayer);
    if (SHOW_TRANSACTIONS) {
      Slog.i(TAG,""String_Node_Str"");
      if (SHOW_TRANSACTIONS)       logSurface(this,""String_Node_Str"" + mFrame.left + ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str"",null);
    }
    Surface.openTransaction();
    try {
      try {
        mSurfaceX=mFrame.left + mXOffset;
        mSurfaceY=mFrame.top=mYOffset;
        mSurface.setPosition(mSurfaceX,mSurfaceY);
        mSurfaceLayer=mAnimLayer;
        mSurface.setLayer(mAnimLayer);
        mSurfaceShown=false;
        mSurface.hide();
        if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_DITHER) != 0) {
          if (SHOW_TRANSACTIONS)           logSurface(this,""String_Node_Str"",null);
          mSurface.setFlags(Surface.SURFACE_DITHER,Surface.SURFACE_DITHER);
        }
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w,e);
        reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      }
      mLastHidden=true;
    }
  finally {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
      Surface.closeTransaction();
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + this);
  }
  return mSurface;
}"
22641,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}"
22642,"/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}","/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurfaceShown=true;
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}"
22643,"void reclaimSomeSurfaceMemoryLocked(WindowState win,String operation){
  final Surface surface=win.mSurface;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,win.toString(),win.mSession.mPid,operation);
  if (mForceRemoves == null) {
    mForceRemoves=new ArrayList<WindowState>();
  }
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    int N=mWindows.size();
    boolean leakedSurface=false;
    Slog.i(TAG,""String_Node_Str"");
    for (int i=0; i < N; i++) {
      WindowState ws=(WindowState)mWindows.get(i);
      if (ws.mSurface != null) {
        if (!mSessions.contains(ws.mSession)) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mToken+ ""String_Node_Str""+ ws.mSession.mPid+ ""String_Node_Str""+ ws.mSession.mUid);
          ws.mSurface.destroy();
          ws.mSurface=null;
          mForceRemoves.add(ws);
          i--;
          N--;
          leakedSurface=true;
        }
 else         if (win.mAppToken != null && win.mAppToken.clientHidden) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mAppToken);
          ws.mSurface.destroy();
          ws.mSurface=null;
          leakedSurface=true;
        }
      }
    }
    boolean killedApps=false;
    if (!leakedSurface) {
      Slog.w(TAG,""String_Node_Str"");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int i=0; i < N; i++) {
        WindowState ws=(WindowState)mWindows.get(i);
        if (ws.mSurface != null) {
          pidCandidates.append(ws.mSession.mPid,ws.mSession.mPid);
        }
      }
      if (pidCandidates.size() > 0) {
        int[] pids=new int[pidCandidates.size()];
        for (int i=0; i < pids.length; i++) {
          pids[i]=pidCandidates.keyAt(i);
        }
        try {
          if (mActivityManager.killPids(pids,""String_Node_Str"")) {
            killedApps=true;
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG,""String_Node_Str"");
      if (surface != null) {
        surface.destroy();
        win.mSurface=null;
      }
      try {
        win.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
}","void reclaimSomeSurfaceMemoryLocked(WindowState win,String operation){
  final Surface surface=win.mSurface;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,win.toString(),win.mSession.mPid,operation);
  if (mForceRemoves == null) {
    mForceRemoves=new ArrayList<WindowState>();
  }
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    int N=mWindows.size();
    boolean leakedSurface=false;
    Slog.i(TAG,""String_Node_Str"");
    for (int i=0; i < N; i++) {
      WindowState ws=(WindowState)mWindows.get(i);
      if (ws.mSurface != null) {
        if (!mSessions.contains(ws.mSession)) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mToken+ ""String_Node_Str""+ ws.mSession.mPid+ ""String_Node_Str""+ ws.mSession.mUid);
          ws.mSurface.destroy();
          ws.mSurfaceShown=false;
          ws.mSurface=null;
          mForceRemoves.add(ws);
          i--;
          N--;
          leakedSurface=true;
        }
 else         if (win.mAppToken != null && win.mAppToken.clientHidden) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mAppToken);
          ws.mSurface.destroy();
          ws.mSurfaceShown=false;
          ws.mSurface=null;
          leakedSurface=true;
        }
      }
    }
    boolean killedApps=false;
    if (!leakedSurface) {
      Slog.w(TAG,""String_Node_Str"");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int i=0; i < N; i++) {
        WindowState ws=(WindowState)mWindows.get(i);
        if (ws.mSurface != null) {
          pidCandidates.append(ws.mSession.mPid,ws.mSession.mPid);
        }
      }
      if (pidCandidates.size() > 0) {
        int[] pids=new int[pidCandidates.size()];
        for (int i=0; i < pids.length; i++) {
          pids[i]=pidCandidates.keyAt(i);
        }
        try {
          if (mActivityManager.killPids(pids,""String_Node_Str"")) {
            killedApps=true;
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG,""String_Node_Str"");
      if (surface != null) {
        surface.destroy();
        win.mSurfaceShown=false;
        win.mSurface=null;
      }
      try {
        win.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
}"
22644,"/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
  mDimShown=true;
  try {
    mDimSurface.setPosition(0,0);
    mDimSurface.setSize(dw,dh);
    mDimSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}"
22645,"void finishExit(){
  if (DEBUG_ANIM)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mExiting+ ""String_Node_Str""+ mRemoveOnExit+ ""String_Node_Str""+ isWindowAnimating());
  final int N=mChildWindows.size();
  for (int i=0; i < N; i++) {
    ((WindowState)mChildWindows.get(i)).finishExit();
  }
  if (!mExiting) {
    return;
  }
  if (isWindowAnimating()) {
    return;
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mRemoveOnExit);
  if (mSurface != null) {
    mDestroySurface.add(this);
    mDestroying=true;
    if (SHOW_TRANSACTIONS)     logSurface(this,""String_Node_Str"",null);
    try {
      mSurface.hide();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this,e);
    }
    mLastHidden=true;
    mKeyWaiter.releasePendingPointerLocked(mSession);
  }
  mExiting=false;
  if (mRemoveOnExit) {
    mPendingRemove.add(this);
    mRemoveOnExit=false;
  }
}","void finishExit(){
  if (DEBUG_ANIM)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mExiting+ ""String_Node_Str""+ mRemoveOnExit+ ""String_Node_Str""+ isWindowAnimating());
  final int N=mChildWindows.size();
  for (int i=0; i < N; i++) {
    ((WindowState)mChildWindows.get(i)).finishExit();
  }
  if (!mExiting) {
    return;
  }
  if (isWindowAnimating()) {
    return;
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mRemoveOnExit);
  if (mSurface != null) {
    mDestroySurface.add(this);
    mDestroying=true;
    if (SHOW_TRANSACTIONS)     logSurface(this,""String_Node_Str"",null);
    mSurfaceShown=false;
    try {
      mSurface.hide();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this,e);
    }
    mLastHidden=true;
    mKeyWaiter.releasePendingPointerLocked(mSession);
  }
  mExiting=false;
  if (mRemoveOnExit) {
    mPendingRemove.add(this);
    mRemoveOnExit=false;
  }
}"
22646,"void destroySurfaceLocked(){
  mKeyWaiter.finishedKey(mSession,mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(mSession);
  mKeyWaiter.releasePendingTrackballLocked(mSession);
  if (mAppToken != null && this == mAppToken.startingWindow) {
    mAppToken.startingDisplayed=false;
  }
  if (mSurface != null) {
    mDrawPending=false;
    mCommitDrawPending=false;
    mReadyToShow=false;
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      c.mAttachedHidden=true;
    }
    if (mReportDestroySurface) {
      mReportDestroySurface=false;
      mSurfacePendingDestroy=true;
      try {
        mClient.dispatchGetNewSurface();
        return;
      }
 catch (      RemoteException e) {
      }
    }
    try {
      if (DEBUG_VISIBILITY) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession,e);
      }
      if (SHOW_TRANSACTIONS) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        if (SHOW_TRANSACTIONS)         logSurface(this,""String_Node_Str"",e);
      }
      mSurface.destroy();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
    }
    mSurface=null;
  }
}","void destroySurfaceLocked(){
  mKeyWaiter.finishedKey(mSession,mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(mSession);
  mKeyWaiter.releasePendingTrackballLocked(mSession);
  if (mAppToken != null && this == mAppToken.startingWindow) {
    mAppToken.startingDisplayed=false;
  }
  if (mSurface != null) {
    mDrawPending=false;
    mCommitDrawPending=false;
    mReadyToShow=false;
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      c.mAttachedHidden=true;
    }
    if (mReportDestroySurface) {
      mReportDestroySurface=false;
      mSurfacePendingDestroy=true;
      try {
        mClient.dispatchGetNewSurface();
        return;
      }
 catch (      RemoteException e) {
      }
    }
    try {
      if (DEBUG_VISIBILITY) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession,e);
      }
      if (SHOW_TRANSACTIONS) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        if (SHOW_TRANSACTIONS)         logSurface(this,""String_Node_Str"",e);
      }
      mSurface.destroy();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
    }
    mSurfaceShown=false;
    mSurface=null;
  }
}"
22647,"Surface createSurfaceLocked(){
  if (mSurface == null) {
    mReportDestroySurface=false;
    mSurfacePendingDestroy=false;
    mDrawPending=true;
    mCommitDrawPending=false;
    mReadyToShow=false;
    if (mAppToken != null) {
      mAppToken.allDrawn=false;
    }
    int flags=0;
    if (mAttrs.memoryType == MEMORY_TYPE_PUSH_BUFFERS) {
      flags|=Surface.PUSH_BUFFERS;
    }
    if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SECURE) != 0) {
      flags|=Surface.SECURE;
    }
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + mSession.mSurfaceSession + ""String_Node_Str""+ this+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ flags);
    int w=mFrame.width();
    int h=mFrame.height();
    if ((mAttrs.flags & LayoutParams.FLAG_SCALED) != 0) {
      w=mRequestedWidth;
      h=mRequestedHeight;
    }
    if (w <= 0)     w=1;
    if (h <= 0)     h=1;
    try {
      mSurface=new Surface(mSession.mSurfaceSession,mSession.mPid,mAttrs.getTitle().toString(),0,w,h,mAttrs.format,flags);
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mSession.mSurfaceSession+ ""String_Node_Str""+ mSession.mPid+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ this);
    }
 catch (    Surface.OutOfResourcesException e) {
      Slog.w(TAG,""String_Node_Str"");
      reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      return null;
    }
catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
      return null;
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mFrame.left+ ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mAnimLayer);
    if (SHOW_TRANSACTIONS) {
      Slog.i(TAG,""String_Node_Str"");
      if (SHOW_TRANSACTIONS)       logSurface(this,""String_Node_Str"" + mFrame.left + ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str"",null);
    }
    Surface.openTransaction();
    try {
      try {
        mSurface.setPosition(mFrame.left + mXOffset,mFrame.top + mYOffset);
        mSurface.setLayer(mAnimLayer);
        mSurface.hide();
        if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_DITHER) != 0) {
          if (SHOW_TRANSACTIONS)           logSurface(this,""String_Node_Str"",null);
          mSurface.setFlags(Surface.SURFACE_DITHER,Surface.SURFACE_DITHER);
        }
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w,e);
        reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      }
      mLastHidden=true;
    }
  finally {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
      Surface.closeTransaction();
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + this);
  }
  return mSurface;
}","Surface createSurfaceLocked(){
  if (mSurface == null) {
    mReportDestroySurface=false;
    mSurfacePendingDestroy=false;
    mDrawPending=true;
    mCommitDrawPending=false;
    mReadyToShow=false;
    if (mAppToken != null) {
      mAppToken.allDrawn=false;
    }
    int flags=0;
    if (mAttrs.memoryType == MEMORY_TYPE_PUSH_BUFFERS) {
      flags|=Surface.PUSH_BUFFERS;
    }
    if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SECURE) != 0) {
      flags|=Surface.SECURE;
    }
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + mSession.mSurfaceSession + ""String_Node_Str""+ this+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ flags);
    int w=mFrame.width();
    int h=mFrame.height();
    if ((mAttrs.flags & LayoutParams.FLAG_SCALED) != 0) {
      w=mRequestedWidth;
      h=mRequestedHeight;
    }
    if (w <= 0)     w=1;
    if (h <= 0)     h=1;
    mSurfaceShown=false;
    mSurfaceLayer=0;
    mSurfaceAlpha=1;
    mSurfaceX=0;
    mSurfaceY=0;
    mSurfaceW=w;
    mSurfaceH=h;
    try {
      mSurface=new Surface(mSession.mSurfaceSession,mSession.mPid,mAttrs.getTitle().toString(),0,w,h,mAttrs.format,flags);
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mSession.mSurfaceSession+ ""String_Node_Str""+ mSession.mPid+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ this);
    }
 catch (    Surface.OutOfResourcesException e) {
      Slog.w(TAG,""String_Node_Str"");
      reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      return null;
    }
catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
      return null;
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mFrame.left+ ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mAnimLayer);
    if (SHOW_TRANSACTIONS) {
      Slog.i(TAG,""String_Node_Str"");
      if (SHOW_TRANSACTIONS)       logSurface(this,""String_Node_Str"" + mFrame.left + ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str"",null);
    }
    Surface.openTransaction();
    try {
      try {
        mSurfaceX=mFrame.left + mXOffset;
        mSurfaceY=mFrame.top=mYOffset;
        mSurface.setPosition(mSurfaceX,mSurfaceY);
        mSurfaceLayer=mAnimLayer;
        mSurface.setLayer(mAnimLayer);
        mSurfaceShown=false;
        mSurface.hide();
        if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_DITHER) != 0) {
          if (SHOW_TRANSACTIONS)           logSurface(this,""String_Node_Str"",null);
          mSurface.setFlags(Surface.SURFACE_DITHER,Surface.SURFACE_DITHER);
        }
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w,e);
        reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      }
      mLastHidden=true;
    }
  finally {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
      Surface.closeTransaction();
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + this);
  }
  return mSurface;
}"
22648,"WifiService(Context context,WifiStateTracker tracker){
  mContext=context;
  mWifiStateTracker=tracker;
  mWifiStateTracker.enableRssiPolling(true);
  mBatteryStats=BatteryStatsService.getService();
  IBinder b=ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
  nwService=INetworkManagementService.Stub.asInterface(b);
  mScanResultCache=new LinkedHashMap<String,ScanResult>(SCAN_RESULT_CACHE_SIZE,0.75f,true){
    public boolean removeEldestEntry(    Map.Entry eldest){
      return SCAN_RESULT_CACHE_SIZE < this.size();
    }
  }
;
  HandlerThread wifiThread=new HandlerThread(""String_Node_Str"");
  wifiThread.start();
  mWifiHandler=new WifiHandler(wifiThread.getLooper());
  mWifiStateTracker.setWifiState(WIFI_STATE_DISABLED);
  mWifiApState=WIFI_AP_STATE_DISABLED;
  mAlarmManager=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent idleIntent=new Intent(ACTION_DEVICE_IDLE,null);
  mIdleIntent=PendingIntent.getBroadcast(mContext,IDLE_REQUEST,idleIntent,0);
  PowerManager powerManager=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  sWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  sDriverStopWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  mWifiStateTracker.setReleaseWakeLockCallback(new Runnable(){
    public void run(){
      mWifiHandler.removeMessages(MESSAGE_RELEASE_WAKELOCK);
synchronized (sDriverStopWakeLock) {
        if (sDriverStopWakeLock.isHeld()) {
          sDriverStopWakeLock.release();
        }
      }
    }
  }
);
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      mAirplaneModeOverwridden=false;
      updateWifiState();
    }
  }
,new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      ArrayList<String> available=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER);
      ArrayList<String> active=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER);
      updateTetherState(available,active);
    }
  }
,new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
}","WifiService(Context context,WifiStateTracker tracker){
  mContext=context;
  mWifiStateTracker=tracker;
  mWifiStateTracker.enableRssiPolling(true);
  mBatteryStats=BatteryStatsService.getService();
  IBinder b=ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
  nwService=INetworkManagementService.Stub.asInterface(b);
  mScanResultCache=new LinkedHashMap<String,ScanResult>(SCAN_RESULT_CACHE_SIZE,0.75f,true){
    public boolean removeEldestEntry(    Map.Entry eldest){
      return SCAN_RESULT_CACHE_SIZE < this.size();
    }
  }
;
  HandlerThread wifiThread=new HandlerThread(""String_Node_Str"");
  wifiThread.start();
  mWifiHandler=new WifiHandler(wifiThread.getLooper());
  mWifiStateTracker.setWifiState(WIFI_STATE_DISABLED);
  mWifiApState=WIFI_AP_STATE_DISABLED;
  mAlarmManager=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent idleIntent=new Intent(ACTION_DEVICE_IDLE,null);
  mIdleIntent=PendingIntent.getBroadcast(mContext,IDLE_REQUEST,idleIntent,0);
  PowerManager powerManager=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  sWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  sDriverStopWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      mAirplaneModeOverwridden=false;
      updateWifiState();
    }
  }
,new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      ArrayList<String> available=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER);
      ArrayList<String> active=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER);
      updateTetherState(available,active);
    }
  }
,new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
}"
22649,"private void doUpdateWifiState(){
  boolean wifiEnabled=getPersistedWifiEnabled();
  boolean airplaneMode=isAirplaneModeOn() && !mAirplaneModeOverwridden;
  boolean lockHeld=mLocks.hasLocks();
  int strongestLockMode;
  boolean wifiShouldBeEnabled=wifiEnabled && !airplaneMode;
  boolean wifiShouldBeStarted=!mDeviceIdle || lockHeld;
  if (mDeviceIdle && lockHeld) {
    strongestLockMode=mLocks.getStrongestLockMode();
  }
 else {
    strongestLockMode=WifiManager.WIFI_MODE_FULL;
  }
synchronized (mWifiHandler) {
    if ((mWifiStateTracker.getWifiState() == WIFI_STATE_ENABLING) && !airplaneMode) {
      return;
    }
    if (wifiShouldBeEnabled) {
      if (wifiShouldBeStarted) {
        sWakeLock.acquire();
        sendEnableMessage(true,false,mLastEnableUid);
        sWakeLock.acquire();
        sendStartMessage(strongestLockMode == WifiManager.WIFI_MODE_SCAN_ONLY);
      }
 else {
        int wakeLockTimeout=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS,DEFAULT_WAKELOCK_TIMEOUT);
        sDriverStopWakeLock.acquire();
        mWifiHandler.sendEmptyMessage(MESSAGE_STOP_WIFI);
        mWifiHandler.sendEmptyMessageDelayed(MESSAGE_RELEASE_WAKELOCK,wakeLockTimeout);
      }
    }
 else {
      sWakeLock.acquire();
      sendEnableMessage(false,false,mLastEnableUid);
    }
  }
}","private void doUpdateWifiState(){
  boolean wifiEnabled=getPersistedWifiEnabled();
  boolean airplaneMode=isAirplaneModeOn() && !mAirplaneModeOverwridden;
  boolean lockHeld=mLocks.hasLocks();
  int strongestLockMode;
  boolean wifiShouldBeEnabled=wifiEnabled && !airplaneMode;
  boolean wifiShouldBeStarted=!mDeviceIdle || lockHeld;
  if (mDeviceIdle && lockHeld) {
    strongestLockMode=mLocks.getStrongestLockMode();
  }
 else {
    strongestLockMode=WifiManager.WIFI_MODE_FULL;
  }
synchronized (mWifiHandler) {
    if ((mWifiStateTracker.getWifiState() == WIFI_STATE_ENABLING) && !airplaneMode) {
      return;
    }
    if (wifiShouldBeEnabled) {
      if (wifiShouldBeStarted) {
        sWakeLock.acquire();
        sendEnableMessage(true,false,mLastEnableUid);
        sWakeLock.acquire();
        sendStartMessage(strongestLockMode == WifiManager.WIFI_MODE_SCAN_ONLY);
      }
 else       if (!mWifiStateTracker.isDriverStopped()) {
        int wakeLockTimeout=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS,DEFAULT_WAKELOCK_TIMEOUT);
        sDriverStopWakeLock.acquire();
        mWifiHandler.sendEmptyMessage(MESSAGE_STOP_WIFI);
        mWifiHandler.sendEmptyMessageDelayed(MESSAGE_RELEASE_WAKELOCK,wakeLockTimeout);
      }
    }
 else {
      sWakeLock.acquire();
      sendEnableMessage(false,false,mLastEnableUid);
    }
  }
}"
22650,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MESSAGE_ENABLE_WIFI:
    if (mWifiWatchdogService == null) {
      mWifiWatchdogService=new WifiWatchdogService(mContext,mWifiStateTracker);
    }
  setWifiEnabledBlocking(true,msg.arg1 == 1,msg.arg2);
sWakeLock.release();
break;
case MESSAGE_START_WIFI:
mWifiStateTracker.setScanOnlyMode(msg.arg1 != 0);
mWifiStateTracker.restart();
sWakeLock.release();
break;
case MESSAGE_UPDATE_STATE:
doUpdateWifiState();
break;
case MESSAGE_DISABLE_WIFI:
setWifiEnabledBlocking(false,msg.arg1 == 1,msg.arg2);
if (mWifiWatchdogService != null) {
mWifiWatchdogService.quit();
mWifiWatchdogService=null;
}
sWakeLock.release();
break;
case MESSAGE_STOP_WIFI:
mWifiStateTracker.disconnectAndStop();
break;
case MESSAGE_RELEASE_WAKELOCK:
synchronized (sDriverStopWakeLock) {
if (sDriverStopWakeLock.isHeld()) {
sDriverStopWakeLock.release();
}
}
break;
case MESSAGE_START_ACCESS_POINT:
setWifiApEnabledBlocking(true,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
case MESSAGE_STOP_ACCESS_POINT:
setWifiApEnabledBlocking(false,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MESSAGE_ENABLE_WIFI:
    if (mWifiWatchdogService == null) {
      mWifiWatchdogService=new WifiWatchdogService(mContext,mWifiStateTracker);
    }
  setWifiEnabledBlocking(true,msg.arg1 == 1,msg.arg2);
sWakeLock.release();
break;
case MESSAGE_START_WIFI:
mWifiStateTracker.setScanOnlyMode(msg.arg1 != 0);
mWifiStateTracker.restart();
sWakeLock.release();
break;
case MESSAGE_UPDATE_STATE:
doUpdateWifiState();
break;
case MESSAGE_DISABLE_WIFI:
setWifiEnabledBlocking(false,msg.arg1 == 1,msg.arg2);
if (mWifiWatchdogService != null) {
mWifiWatchdogService.quit();
mWifiWatchdogService=null;
}
sWakeLock.release();
break;
case MESSAGE_STOP_WIFI:
mWifiStateTracker.disconnectAndStop();
break;
case MESSAGE_RELEASE_WAKELOCK:
sDriverStopWakeLock.release();
break;
case MESSAGE_START_ACCESS_POINT:
setWifiApEnabledBlocking(true,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
case MESSAGE_STOP_ACCESS_POINT:
setWifiApEnabledBlocking(false,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
}
}"
22651,"/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return stopDriver();
    }
 else {
      return disconnect();
    }
  }
 else {
    releaseWakeLock();
  }
  return true;
}","/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return stopDriver();
    }
 else {
      return disconnect();
    }
  }
  return true;
}"
22652,"private synchronized boolean isDriverStopped(){
  return mRunState == RUN_STATE_STOPPED || mRunState == RUN_STATE_STOPPING;
}","/** 
 * TODO: mRunState is not synchronized in some places address this as part of re-architect. TODO: We are exposing an additional public synchronized call for a wakelock optimization in WifiService. Remove it when we handle the wakelock in ConnectivityService.
 */
public synchronized boolean isDriverStopped(){
  return mRunState == RUN_STATE_STOPPED || mRunState == RUN_STATE_STOPPING;
}"
22653,"@Override public void releaseWakeLock(){
  if (mReleaseWakeLockCallback != null) {
    mReleaseWakeLockCallback.run();
  }
}","/** 
 * We release the wakelock in WifiService using a timer. TODO: Releasing wakelock using both timer and a call from ConnectivityService requires a rethink. We had problems where WifiService could keep a wakelock forever if we delete messages in the asynchronous call from ConnectivityService
 */
@Override public void releaseWakeLock(){
}"
22654,"private boolean chooseNewDefaultIMELocked(){
  List<InputMethodInfo> enabled=getEnabledInputMethodListLocked();
  if (enabled != null && enabled.size() > 0) {
    Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,enabled.get(0).getId());
    return true;
  }
  return false;
}","private boolean chooseNewDefaultIMELocked(){
  List<InputMethodInfo> enabled=getEnabledInputMethodListLocked();
  if (enabled != null && enabled.size() > 0) {
    int i=enabled.size();
    while (i > 0) {
      i--;
      if ((enabled.get(i).getServiceInfo().applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        break;
      }
    }
    Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,enabled.get(i).getId());
    return true;
  }
  return false;
}"
22655,"void buildInputMethodListLocked(ArrayList<InputMethodInfo> list,HashMap<String,InputMethodInfo> map){
  list.clear();
  map.clear();
  PackageManager pm=mContext.getPackageManager();
  List<ResolveInfo> services=pm.queryIntentServices(new Intent(InputMethod.SERVICE_INTERFACE),PackageManager.GET_META_DATA);
  for (int i=0; i < services.size(); ++i) {
    ResolveInfo ri=services.get(i);
    ServiceInfo si=ri.serviceInfo;
    ComponentName compName=new ComponentName(si.packageName,si.name);
    if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(si.permission)) {
      Slog.w(TAG,""String_Node_Str"" + compName + ""String_Node_Str""+ android.Manifest.permission.BIND_INPUT_METHOD);
      continue;
    }
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + compName);
    try {
      InputMethodInfo p=new InputMethodInfo(mContext,ri);
      list.add(p);
      map.put(p.getId(),p);
      if (isSystemIme(p)) {
        setInputMethodEnabled(p.getId(),true);
      }
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + p);
      }
    }
 catch (    XmlPullParserException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
  }
  String defaultIme=Settings.Secure.getString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (!map.containsKey(defaultIme)) {
    if (chooseNewDefaultIMELocked()) {
      updateFromSettingsLocked();
    }
  }
}","void buildInputMethodListLocked(ArrayList<InputMethodInfo> list,HashMap<String,InputMethodInfo> map){
  list.clear();
  map.clear();
  PackageManager pm=mContext.getPackageManager();
  List<ResolveInfo> services=pm.queryIntentServices(new Intent(InputMethod.SERVICE_INTERFACE),PackageManager.GET_META_DATA);
  for (int i=0; i < services.size(); ++i) {
    ResolveInfo ri=services.get(i);
    ServiceInfo si=ri.serviceInfo;
    ComponentName compName=new ComponentName(si.packageName,si.name);
    if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(si.permission)) {
      Slog.w(TAG,""String_Node_Str"" + compName + ""String_Node_Str""+ android.Manifest.permission.BIND_INPUT_METHOD);
      continue;
    }
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + compName);
    try {
      InputMethodInfo p=new InputMethodInfo(mContext,ri);
      list.add(p);
      map.put(p.getId(),p);
      if (isSystemIme(p)) {
        setInputMethodEnabledLocked(p.getId(),true);
      }
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + p);
      }
    }
 catch (    XmlPullParserException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
  }
  String defaultIme=Settings.Secure.getString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (!map.containsKey(defaultIme)) {
    if (chooseNewDefaultIMELocked()) {
      updateFromSettingsLocked();
    }
  }
}"
22656,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      mLastMotionX=x;
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(deltaX,0,mScrollX,0,getScrollRange(),0,getOverscrollMax(),0,true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionX=x;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(deltaX,0,mScrollX,0,getScrollRange(),0,getOverscrollMax(),0,true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}"
22657,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}"
22658,"private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final View child=getChildAt(0);
    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() || x >= child.getRight());
  }
  return false;
}","private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final int scrollX=mScrollX;
    final View child=getChildAt(0);
    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() - scrollX || x >= child.getRight() - scrollX);
  }
  return false;
}"
22659,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax(),true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax(),true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}"
22660,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}"
22661,"private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final View child=getChildAt(0);
    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() || x >= child.getRight());
  }
  return false;
}","private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final int scrollY=mScrollY;
    final View child=getChildAt(0);
    return !(y < child.getTop() - scrollY || y >= child.getBottom() - scrollY || x < child.getLeft() || x >= child.getRight());
  }
  return false;
}"
22662,"private boolean chooseNewDefaultIMELocked(){
  List<InputMethodInfo> enabled=getEnabledInputMethodListLocked();
  if (enabled != null && enabled.size() > 0) {
    Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,enabled.get(0).getId());
    return true;
  }
  return false;
}","private boolean chooseNewDefaultIMELocked(){
  List<InputMethodInfo> enabled=getEnabledInputMethodListLocked();
  if (enabled != null && enabled.size() > 0) {
    int i=enabled.size();
    while (i > 0) {
      i--;
      if ((enabled.get(i).getServiceInfo().applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        break;
      }
    }
    Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,enabled.get(i).getId());
    return true;
  }
  return false;
}"
22663,"void buildInputMethodListLocked(ArrayList<InputMethodInfo> list,HashMap<String,InputMethodInfo> map){
  list.clear();
  map.clear();
  PackageManager pm=mContext.getPackageManager();
  List<ResolveInfo> services=pm.queryIntentServices(new Intent(InputMethod.SERVICE_INTERFACE),PackageManager.GET_META_DATA);
  for (int i=0; i < services.size(); ++i) {
    ResolveInfo ri=services.get(i);
    ServiceInfo si=ri.serviceInfo;
    ComponentName compName=new ComponentName(si.packageName,si.name);
    if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(si.permission)) {
      Slog.w(TAG,""String_Node_Str"" + compName + ""String_Node_Str""+ android.Manifest.permission.BIND_INPUT_METHOD);
      continue;
    }
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + compName);
    try {
      InputMethodInfo p=new InputMethodInfo(mContext,ri);
      list.add(p);
      map.put(p.getId(),p);
      if (isSystemIme(p)) {
        setInputMethodEnabled(p.getId(),true);
      }
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + p);
      }
    }
 catch (    XmlPullParserException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
  }
  String defaultIme=Settings.Secure.getString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (!map.containsKey(defaultIme)) {
    if (chooseNewDefaultIMELocked()) {
      updateFromSettingsLocked();
    }
  }
}","void buildInputMethodListLocked(ArrayList<InputMethodInfo> list,HashMap<String,InputMethodInfo> map){
  list.clear();
  map.clear();
  PackageManager pm=mContext.getPackageManager();
  List<ResolveInfo> services=pm.queryIntentServices(new Intent(InputMethod.SERVICE_INTERFACE),PackageManager.GET_META_DATA);
  for (int i=0; i < services.size(); ++i) {
    ResolveInfo ri=services.get(i);
    ServiceInfo si=ri.serviceInfo;
    ComponentName compName=new ComponentName(si.packageName,si.name);
    if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(si.permission)) {
      Slog.w(TAG,""String_Node_Str"" + compName + ""String_Node_Str""+ android.Manifest.permission.BIND_INPUT_METHOD);
      continue;
    }
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + compName);
    try {
      InputMethodInfo p=new InputMethodInfo(mContext,ri);
      list.add(p);
      map.put(p.getId(),p);
      if (isSystemIme(p)) {
        setInputMethodEnabledLocked(p.getId(),true);
      }
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + p);
      }
    }
 catch (    XmlPullParserException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
  }
  String defaultIme=Settings.Secure.getString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (!map.containsKey(defaultIme)) {
    if (chooseNewDefaultIMELocked()) {
      updateFromSettingsLocked();
    }
  }
}"
22664,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      PackageParser pp=new PackageParser(codePath);
      pp.setSeparateProcesses(mSeparateProcesses);
      final PackageParser.Package pkg=pp.parsePackage(new File(codePath),codePath,mMetrics,parseFlags);
      pp=null;
      doGc=true;
      if (pkg == null) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.cachePath);
        continue;
      }
      setApplicationInfoPaths(pkg,codePath,codePath);
synchronized (mInstallLock) {
        if (scanPackageLI(pkg,parseFlags,SCAN_MONITOR) != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      PackageParser pp=new PackageParser(codePath);
      pp.setSeparateProcesses(mSeparateProcesses);
      final PackageParser.Package pkg=pp.parsePackage(new File(codePath),codePath,mMetrics,parseFlags);
      pp=null;
      doGc=true;
      if (pkg == null) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.cachePath);
        continue;
      }
      setApplicationInfoPaths(pkg,codePath,codePath);
synchronized (mInstallLock) {
        if (scanPackageLI(pkg,parseFlags,SCAN_MONITOR) != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    updatePermissionsLP(null,null,true,false);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22665,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int pointerIndex=ev.findPointerIndex(mActivePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}"
22666,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int pointerIndex=ev.findPointerIndex(mActivePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}"
22667,"WifiService(Context context,WifiStateTracker tracker){
  mContext=context;
  mWifiStateTracker=tracker;
  mWifiStateTracker.enableRssiPolling(true);
  mBatteryStats=BatteryStatsService.getService();
  IBinder b=ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
  nwService=INetworkManagementService.Stub.asInterface(b);
  mScanResultCache=new LinkedHashMap<String,ScanResult>(SCAN_RESULT_CACHE_SIZE,0.75f,true){
    public boolean removeEldestEntry(    Map.Entry eldest){
      return SCAN_RESULT_CACHE_SIZE < this.size();
    }
  }
;
  HandlerThread wifiThread=new HandlerThread(""String_Node_Str"");
  wifiThread.start();
  mWifiHandler=new WifiHandler(wifiThread.getLooper());
  mWifiStateTracker.setWifiState(WIFI_STATE_DISABLED);
  mWifiApState=WIFI_AP_STATE_DISABLED;
  mAlarmManager=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent idleIntent=new Intent(ACTION_DEVICE_IDLE,null);
  mIdleIntent=PendingIntent.getBroadcast(mContext,IDLE_REQUEST,idleIntent,0);
  PowerManager powerManager=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  sWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  sDriverStopWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  mWifiStateTracker.setReleaseWakeLockCallback(new Runnable(){
    public void run(){
      mWifiHandler.removeMessages(MESSAGE_RELEASE_WAKELOCK);
synchronized (sDriverStopWakeLock) {
        if (sDriverStopWakeLock.isHeld()) {
          sDriverStopWakeLock.release();
        }
      }
    }
  }
);
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      mAirplaneModeOverwridden=false;
      updateWifiState();
    }
  }
,new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      ArrayList<String> available=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER);
      ArrayList<String> active=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER);
      updateTetherState(available,active);
    }
  }
,new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
}","WifiService(Context context,WifiStateTracker tracker){
  mContext=context;
  mWifiStateTracker=tracker;
  mWifiStateTracker.enableRssiPolling(true);
  mBatteryStats=BatteryStatsService.getService();
  IBinder b=ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
  nwService=INetworkManagementService.Stub.asInterface(b);
  mScanResultCache=new LinkedHashMap<String,ScanResult>(SCAN_RESULT_CACHE_SIZE,0.75f,true){
    public boolean removeEldestEntry(    Map.Entry eldest){
      return SCAN_RESULT_CACHE_SIZE < this.size();
    }
  }
;
  HandlerThread wifiThread=new HandlerThread(""String_Node_Str"");
  wifiThread.start();
  mWifiHandler=new WifiHandler(wifiThread.getLooper());
  mWifiStateTracker.setWifiState(WIFI_STATE_DISABLED);
  mWifiApState=WIFI_AP_STATE_DISABLED;
  mAlarmManager=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent idleIntent=new Intent(ACTION_DEVICE_IDLE,null);
  mIdleIntent=PendingIntent.getBroadcast(mContext,IDLE_REQUEST,idleIntent,0);
  PowerManager powerManager=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  sWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  sDriverStopWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      mAirplaneModeOverwridden=false;
      updateWifiState();
    }
  }
,new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      ArrayList<String> available=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER);
      ArrayList<String> active=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER);
      updateTetherState(available,active);
    }
  }
,new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
}"
22668,"private void doUpdateWifiState(){
  boolean wifiEnabled=getPersistedWifiEnabled();
  boolean airplaneMode=isAirplaneModeOn() && !mAirplaneModeOverwridden;
  boolean lockHeld=mLocks.hasLocks();
  int strongestLockMode;
  boolean wifiShouldBeEnabled=wifiEnabled && !airplaneMode;
  boolean wifiShouldBeStarted=!mDeviceIdle || lockHeld;
  if (mDeviceIdle && lockHeld) {
    strongestLockMode=mLocks.getStrongestLockMode();
  }
 else {
    strongestLockMode=WifiManager.WIFI_MODE_FULL;
  }
synchronized (mWifiHandler) {
    if ((mWifiStateTracker.getWifiState() == WIFI_STATE_ENABLING) && !airplaneMode) {
      return;
    }
    if (wifiShouldBeEnabled) {
      if (wifiShouldBeStarted) {
        sWakeLock.acquire();
        sendEnableMessage(true,false,mLastEnableUid);
        sWakeLock.acquire();
        sendStartMessage(strongestLockMode == WifiManager.WIFI_MODE_SCAN_ONLY);
      }
 else {
        int wakeLockTimeout=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS,DEFAULT_WAKELOCK_TIMEOUT);
        sDriverStopWakeLock.acquire();
        mWifiHandler.sendEmptyMessage(MESSAGE_STOP_WIFI);
        mWifiHandler.sendEmptyMessageDelayed(MESSAGE_RELEASE_WAKELOCK,wakeLockTimeout);
      }
    }
 else {
      sWakeLock.acquire();
      sendEnableMessage(false,false,mLastEnableUid);
    }
  }
}","private void doUpdateWifiState(){
  boolean wifiEnabled=getPersistedWifiEnabled();
  boolean airplaneMode=isAirplaneModeOn() && !mAirplaneModeOverwridden;
  boolean lockHeld=mLocks.hasLocks();
  int strongestLockMode;
  boolean wifiShouldBeEnabled=wifiEnabled && !airplaneMode;
  boolean wifiShouldBeStarted=!mDeviceIdle || lockHeld;
  if (mDeviceIdle && lockHeld) {
    strongestLockMode=mLocks.getStrongestLockMode();
  }
 else {
    strongestLockMode=WifiManager.WIFI_MODE_FULL;
  }
synchronized (mWifiHandler) {
    if ((mWifiStateTracker.getWifiState() == WIFI_STATE_ENABLING) && !airplaneMode) {
      return;
    }
    if (wifiShouldBeEnabled) {
      if (wifiShouldBeStarted) {
        sWakeLock.acquire();
        sendEnableMessage(true,false,mLastEnableUid);
        sWakeLock.acquire();
        sendStartMessage(strongestLockMode == WifiManager.WIFI_MODE_SCAN_ONLY);
      }
 else       if (!mWifiStateTracker.isDriverStopped()) {
        int wakeLockTimeout=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS,DEFAULT_WAKELOCK_TIMEOUT);
        sDriverStopWakeLock.acquire();
        mWifiHandler.sendEmptyMessage(MESSAGE_STOP_WIFI);
        mWifiHandler.sendEmptyMessageDelayed(MESSAGE_RELEASE_WAKELOCK,wakeLockTimeout);
      }
    }
 else {
      sWakeLock.acquire();
      sendEnableMessage(false,false,mLastEnableUid);
    }
  }
}"
22669,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MESSAGE_ENABLE_WIFI:
    if (mWifiWatchdogService == null) {
      mWifiWatchdogService=new WifiWatchdogService(mContext,mWifiStateTracker);
    }
  setWifiEnabledBlocking(true,msg.arg1 == 1,msg.arg2);
sWakeLock.release();
break;
case MESSAGE_START_WIFI:
mWifiStateTracker.setScanOnlyMode(msg.arg1 != 0);
mWifiStateTracker.restart();
sWakeLock.release();
break;
case MESSAGE_UPDATE_STATE:
doUpdateWifiState();
break;
case MESSAGE_DISABLE_WIFI:
setWifiEnabledBlocking(false,msg.arg1 == 1,msg.arg2);
if (mWifiWatchdogService != null) {
mWifiWatchdogService.quit();
mWifiWatchdogService=null;
}
sWakeLock.release();
break;
case MESSAGE_STOP_WIFI:
mWifiStateTracker.disconnectAndStop();
break;
case MESSAGE_RELEASE_WAKELOCK:
synchronized (sDriverStopWakeLock) {
if (sDriverStopWakeLock.isHeld()) {
sDriverStopWakeLock.release();
}
}
break;
case MESSAGE_START_ACCESS_POINT:
setWifiApEnabledBlocking(true,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
case MESSAGE_STOP_ACCESS_POINT:
setWifiApEnabledBlocking(false,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MESSAGE_ENABLE_WIFI:
    if (mWifiWatchdogService == null) {
      mWifiWatchdogService=new WifiWatchdogService(mContext,mWifiStateTracker);
    }
  setWifiEnabledBlocking(true,msg.arg1 == 1,msg.arg2);
sWakeLock.release();
break;
case MESSAGE_START_WIFI:
mWifiStateTracker.setScanOnlyMode(msg.arg1 != 0);
mWifiStateTracker.restart();
sWakeLock.release();
break;
case MESSAGE_UPDATE_STATE:
doUpdateWifiState();
break;
case MESSAGE_DISABLE_WIFI:
setWifiEnabledBlocking(false,msg.arg1 == 1,msg.arg2);
if (mWifiWatchdogService != null) {
mWifiWatchdogService.quit();
mWifiWatchdogService=null;
}
sWakeLock.release();
break;
case MESSAGE_STOP_WIFI:
mWifiStateTracker.disconnectAndStop();
break;
case MESSAGE_RELEASE_WAKELOCK:
sDriverStopWakeLock.release();
break;
case MESSAGE_START_ACCESS_POINT:
setWifiApEnabledBlocking(true,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
case MESSAGE_STOP_ACCESS_POINT:
setWifiApEnabledBlocking(false,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
}
}"
22670,"/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return stopDriver();
    }
 else {
      return disconnect();
    }
  }
 else {
    releaseWakeLock();
  }
  return true;
}","/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return stopDriver();
    }
 else {
      return disconnect();
    }
  }
  return true;
}"
22671,"private synchronized boolean isDriverStopped(){
  return mRunState == RUN_STATE_STOPPED || mRunState == RUN_STATE_STOPPING;
}","/** 
 * TODO: mRunState is not synchronized in some places address this as part of re-architect. TODO: We are exposing an additional public synchronized call for a wakelock optimization in WifiService. Remove it when we handle the wakelock in ConnectivityService.
 */
public synchronized boolean isDriverStopped(){
  return mRunState == RUN_STATE_STOPPED || mRunState == RUN_STATE_STOPPING;
}"
22672,"@Override public void releaseWakeLock(){
  if (mReleaseWakeLockCallback != null) {
    mReleaseWakeLockCallback.run();
  }
}","/** 
 * We release the wakelock in WifiService using a timer. TODO: Releasing wakelock using both timer and a call from ConnectivityService requires a rethink. We had problems where WifiService could keep a wakelock forever if we delete messages in the asynchronous call from ConnectivityService
 */
@Override public void releaseWakeLock(){
}"
22673,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      mLastMotionX=x;
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(deltaX,0,mScrollX,0,getScrollRange(),0,getOverscrollMax(),0,true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionX=x;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(deltaX,0,mScrollX,0,getScrollRange(),0,getOverscrollMax(),0,true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}"
22674,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}"
22675,"private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final View child=getChildAt(0);
    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() || x >= child.getRight());
  }
  return false;
}","private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final int scrollX=mScrollX;
    final View child=getChildAt(0);
    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() - scrollX || x >= child.getRight() - scrollX);
  }
  return false;
}"
22676,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax(),true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax(),true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}"
22677,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}"
22678,"private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final View child=getChildAt(0);
    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() || x >= child.getRight());
  }
  return false;
}","private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final int scrollY=mScrollY;
    final View child=getChildAt(0);
    return !(y < child.getTop() - scrollY || y >= child.getBottom() - scrollY || x < child.getLeft() || x >= child.getRight());
  }
  return false;
}"
22679,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int pointerIndex=ev.findPointerIndex(mActivePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}"
22680,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int pointerIndex=ev.findPointerIndex(mActivePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}"
22681,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      PackageParser pp=new PackageParser(codePath);
      pp.setSeparateProcesses(mSeparateProcesses);
      final PackageParser.Package pkg=pp.parsePackage(new File(codePath),codePath,mMetrics,parseFlags);
      pp=null;
      doGc=true;
      if (pkg == null) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.cachePath);
        continue;
      }
      setApplicationInfoPaths(pkg,codePath,codePath);
synchronized (mInstallLock) {
        if (scanPackageLI(pkg,parseFlags,SCAN_MONITOR) != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      PackageParser pp=new PackageParser(codePath);
      pp.setSeparateProcesses(mSeparateProcesses);
      final PackageParser.Package pkg=pp.parsePackage(new File(codePath),codePath,mMetrics,parseFlags);
      pp=null;
      doGc=true;
      if (pkg == null) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.cachePath);
        continue;
      }
      setApplicationInfoPaths(pkg,codePath,codePath);
synchronized (mInstallLock) {
        if (scanPackageLI(pkg,parseFlags,SCAN_MONITOR) != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    updatePermissionsLP(null,null,true,false);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}"
22682,"private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (format == null || ""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    return new SimpleDateFormat(format);
  }
}","private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (format == null || ""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    try {
      return new SimpleDateFormat(format);
    }
 catch (    IllegalArgumentException e) {
      return DateFormat.getDateInstance(DateFormat.SHORT);
    }
  }
}"
22683,"private void installDecor(){
  if (mDecor == null) {
    mDecor=generateDecor();
    mDecor.setIsRootNamespace(true);
  }
  if (mContentParent == null) {
    mContentParent=generateLayout(mDecor);
    mTitleView=(TextView)findViewById(com.android.internal.R.id.title);
    if (mTitleView != null) {
      if ((getLocalFeatures() & (1 << FEATURE_NO_TITLE)) != 0) {
        View titleContainer=findViewById(com.android.internal.R.id.title_container);
        if (titleContainer != null) {
          titleContainer.setVisibility(View.GONE);
        }
 else {
          mTitleView.setVisibility(View.GONE);
        }
        if (mContentParent instanceof FrameLayout) {
          ((FrameLayout)mContentParent).setForeground(null);
        }
      }
 else {
        mTitleView.setText(mTitle);
      }
    }
  }
}","private void installDecor(){
  if (mDecor == null) {
    mDecor=generateDecor();
    mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
    mDecor.setIsRootNamespace(true);
  }
  if (mContentParent == null) {
    mContentParent=generateLayout(mDecor);
    mTitleView=(TextView)findViewById(com.android.internal.R.id.title);
    if (mTitleView != null) {
      if ((getLocalFeatures() & (1 << FEATURE_NO_TITLE)) != 0) {
        View titleContainer=findViewById(com.android.internal.R.id.title_container);
        if (titleContainer != null) {
          titleContainer.setVisibility(View.GONE);
        }
 else {
          mTitleView.setVisibility(View.GONE);
        }
        if (mContentParent instanceof FrameLayout) {
          ((FrameLayout)mContentParent).setForeground(null);
        }
      }
 else {
        mTitleView.setText(mTitle);
      }
    }
  }
}"
22684,"public void onBootCompleted(){
  mBootCompleted=true;
  if (mReadyToRunLatch != null) {
    mReadyToRunLatch.countDown();
  }
}","public void onBootCompleted(){
  mBootCompleted=true;
  mSyncStorageEngine.doDatabaseCleanup(AccountManager.get(mContext).getAccounts());
  if (mReadyToRunLatch != null) {
    mReadyToRunLatch.countDown();
  }
}"
22685,"public void onAccountsUpdated(Account[] accounts){
  final boolean justBootedUp=mAccounts == INITIAL_ACCOUNTS_ARRAY;
  mAccounts=accounts;
  ActiveSyncContext activeSyncContext=mActiveSyncContext;
  if (activeSyncContext != null) {
    if (!ArrayUtils.contains(accounts,activeSyncContext.mSyncOperation.account)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(activeSyncContext,null);
    }
  }
  sendCheckAlarmsMessage();
  mSyncStorageEngine.doDatabaseCleanup(accounts);
  if (accounts.length > 0) {
    boolean onlyThoseWithUnkownSyncableState=justBootedUp;
    scheduleSync(null,null,null,0,onlyThoseWithUnkownSyncableState);
  }
}","public void onAccountsUpdated(Account[] accounts){
  final boolean justBootedUp=mAccounts == INITIAL_ACCOUNTS_ARRAY;
  mAccounts=accounts;
  ActiveSyncContext activeSyncContext=mActiveSyncContext;
  if (activeSyncContext != null) {
    if (!ArrayUtils.contains(accounts,activeSyncContext.mSyncOperation.account)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(activeSyncContext,null);
    }
  }
  sendCheckAlarmsMessage();
  if (mBootCompleted) {
    mSyncStorageEngine.doDatabaseCleanup(accounts);
  }
  if (accounts.length > 0) {
    boolean onlyThoseWithUnkownSyncableState=justBootedUp;
    scheduleSync(null,null,null,0,onlyThoseWithUnkownSyncableState);
  }
}"
22686,"/** 
 * Read all account information back in to the initial engine state.
 */
private void readAccountInfoLocked(){
  boolean writeNeeded=false;
  FileInputStream fis=null;
  try {
    fis=mAccountInfoFile.openRead();
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(fis,null);
    int eventType=parser.getEventType();
    while (eventType != XmlPullParser.START_TAG) {
      eventType=parser.next();
    }
    String tagName=parser.getName();
    if (""String_Node_Str"".equals(tagName)) {
      String listen=parser.getAttributeValue(null,""String_Node_Str"");
      String versionString=parser.getAttributeValue(null,""String_Node_Str"");
      int version;
      try {
        version=(versionString == null) ? 0 : Integer.parseInt(versionString);
      }
 catch (      NumberFormatException e) {
        version=0;
      }
      if (version < ACCOUNTS_VERSION) {
        writeNeeded=true;
      }
      mMasterSyncAutomatically=listen == null || Boolean.parseBoolean(listen);
      eventType=parser.next();
      AuthorityInfo authority=null;
      Pair<Bundle,Long> periodicSync=null;
      do {
        if (eventType == XmlPullParser.START_TAG) {
          tagName=parser.getName();
          if (parser.getDepth() == 2) {
            if (""String_Node_Str"".equals(tagName)) {
              authority=parseAuthority(parser,version);
              periodicSync=null;
            }
          }
 else           if (parser.getDepth() == 3) {
            if (""String_Node_Str"".equals(tagName) && authority != null) {
              periodicSync=parsePeriodicSync(parser,authority);
            }
          }
 else           if (parser.getDepth() == 4 && periodicSync != null) {
            if (""String_Node_Str"".equals(tagName)) {
              parseExtra(parser,periodicSync);
            }
          }
        }
        eventType=parser.next();
      }
 while (eventType != XmlPullParser.END_DOCUMENT);
    }
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"",e);
    return;
  }
catch (  java.io.IOException e) {
    if (fis == null)     Log.i(TAG,""String_Node_Str"");
 else     Log.w(TAG,""String_Node_Str"",e);
    return;
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      java.io.IOException e1) {
      }
    }
  }
  if (writeNeeded) {
    writeAccountInfoLocked();
  }
}","/** 
 * Read all account information back in to the initial engine state.
 */
private void readAccountInfoLocked(){
  boolean writeNeeded=false;
  FileInputStream fis=null;
  try {
    fis=mAccountInfoFile.openRead();
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(fis,null);
    int eventType=parser.getEventType();
    while (eventType != XmlPullParser.START_TAG) {
      eventType=parser.next();
    }
    String tagName=parser.getName();
    if (""String_Node_Str"".equals(tagName)) {
      String listen=parser.getAttributeValue(null,""String_Node_Str"");
      String versionString=parser.getAttributeValue(null,""String_Node_Str"");
      int version;
      try {
        version=(versionString == null) ? 0 : Integer.parseInt(versionString);
      }
 catch (      NumberFormatException e) {
        version=0;
      }
      if (version < ACCOUNTS_VERSION) {
        writeNeeded=true;
      }
      mMasterSyncAutomatically=listen == null || Boolean.parseBoolean(listen);
      eventType=parser.next();
      AuthorityInfo authority=null;
      Pair<Bundle,Long> periodicSync=null;
      do {
        if (eventType == XmlPullParser.START_TAG) {
          tagName=parser.getName();
          if (parser.getDepth() == 2) {
            if (""String_Node_Str"".equals(tagName)) {
              authority=parseAuthority(parser,version);
              periodicSync=null;
            }
          }
 else           if (parser.getDepth() == 3) {
            if (""String_Node_Str"".equals(tagName) && authority != null) {
              periodicSync=parsePeriodicSync(parser,authority);
            }
          }
 else           if (parser.getDepth() == 4 && periodicSync != null) {
            if (""String_Node_Str"".equals(tagName)) {
              parseExtra(parser,periodicSync);
            }
          }
        }
        eventType=parser.next();
      }
 while (eventType != XmlPullParser.END_DOCUMENT);
    }
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"",e);
    return;
  }
catch (  java.io.IOException e) {
    if (fis == null)     Log.i(TAG,""String_Node_Str"");
 else     Log.w(TAG,""String_Node_Str"",e);
    return;
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      java.io.IOException e1) {
      }
    }
  }
  if (maybeMigrateSettingsForRenamedAuthorities()) {
    writeNeeded=true;
  }
  if (writeNeeded) {
    writeAccountInfoLocked();
  }
}"
22687,"private AuthorityInfo parseAuthority(XmlPullParser parser,int version){
  AuthorityInfo authority=null;
  int id=-1;
  try {
    id=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
catch (  NullPointerException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (id >= 0) {
    String accountName=parser.getAttributeValue(null,""String_Node_Str"");
    String accountType=parser.getAttributeValue(null,""String_Node_Str"");
    if (accountType == null) {
      accountType=""String_Node_Str"";
    }
    String authorityName=parser.getAttributeValue(null,""String_Node_Str"");
    String enabled=parser.getAttributeValue(null,""String_Node_Str"");
    String syncable=parser.getAttributeValue(null,""String_Node_Str"");
    authority=mAuthorities.get(id);
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    if (authority == null) {
      if (DEBUG_FILE)       Log.v(TAG,""String_Node_Str"");
      authority=getOrCreateAuthorityLocked(new Account(accountName,accountType),authorityName,id,false);
      if (version > 0) {
        authority.periodicSyncs.clear();
      }
    }
    if (authority != null) {
      authority.enabled=enabled == null || Boolean.parseBoolean(enabled);
      if (""String_Node_Str"".equals(syncable)) {
        authority.syncable=-1;
      }
 else {
        authority.syncable=(syncable == null || Boolean.parseBoolean(enabled)) ? 1 : 0;
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    }
  }
  return authority;
}","private AuthorityInfo parseAuthority(XmlPullParser parser,int version){
  AuthorityInfo authority=null;
  int id=-1;
  try {
    id=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
catch (  NullPointerException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (id >= 0) {
    String authorityName=parser.getAttributeValue(null,""String_Node_Str"");
    String enabled=parser.getAttributeValue(null,""String_Node_Str"");
    String syncable=parser.getAttributeValue(null,""String_Node_Str"");
    String accountName=parser.getAttributeValue(null,""String_Node_Str"");
    String accountType=parser.getAttributeValue(null,""String_Node_Str"");
    if (accountType == null) {
      accountType=""String_Node_Str"";
      syncable=""String_Node_Str"";
    }
    authority=mAuthorities.get(id);
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    if (authority == null) {
      if (DEBUG_FILE)       Log.v(TAG,""String_Node_Str"");
      authority=getOrCreateAuthorityLocked(new Account(accountName,accountType),authorityName,id,false);
      if (version > 0) {
        authority.periodicSyncs.clear();
      }
    }
    if (authority != null) {
      authority.enabled=enabled == null || Boolean.parseBoolean(enabled);
      if (""String_Node_Str"".equals(syncable)) {
        authority.syncable=-1;
      }
 else {
        authority.syncable=(syncable == null || Boolean.parseBoolean(syncable)) ? 1 : 0;
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    }
  }
  return authority;
}"
22688,"/** 
 * Write all account information to the account file.
 */
private void writeAccountInfoLocked(){
  if (DEBUG_FILE)   Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
  FileOutputStream fos=null;
  try {
    fos=mAccountInfoFile.startWrite();
    XmlSerializer out=new FastXmlSerializer();
    out.setOutput(fos,""String_Node_Str"");
    out.startDocument(null,true);
    out.setFeature(""String_Node_Str"",true);
    out.startTag(null,""String_Node_Str"");
    out.attribute(null,""String_Node_Str"",Integer.toString(ACCOUNTS_VERSION));
    if (!mMasterSyncAutomatically) {
      out.attribute(null,""String_Node_Str"",""String_Node_Str"");
    }
    final int N=mAuthorities.size();
    for (int i=0; i < N; i++) {
      AuthorityInfo authority=mAuthorities.valueAt(i);
      out.startTag(null,""String_Node_Str"");
      out.attribute(null,""String_Node_Str"",Integer.toString(authority.ident));
      out.attribute(null,""String_Node_Str"",authority.account.name);
      out.attribute(null,""String_Node_Str"",authority.account.type);
      out.attribute(null,""String_Node_Str"",authority.authority);
      if (!authority.enabled) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
      if (authority.syncable < 0) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
 else       if (authority.syncable == 0) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
      for (      Pair<Bundle,Long> periodicSync : authority.periodicSyncs) {
        out.startTag(null,""String_Node_Str"");
        out.attribute(null,""String_Node_Str"",Long.toString(periodicSync.second));
        final Bundle extras=periodicSync.first;
        for (        String key : extras.keySet()) {
          out.startTag(null,""String_Node_Str"");
          out.attribute(null,""String_Node_Str"",key);
          final Object value=extras.get(key);
          if (value instanceof Long) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Integer) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Boolean) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Float) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Double) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof String) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Account) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",((Account)value).name);
            out.attribute(null,""String_Node_Str"",((Account)value).type);
          }
          out.endTag(null,""String_Node_Str"");
        }
        out.endTag(null,""String_Node_Str"");
      }
      out.endTag(null,""String_Node_Str"");
    }
    out.endTag(null,""String_Node_Str"");
    out.endDocument();
    mAccountInfoFile.finishWrite(fos);
  }
 catch (  java.io.IOException e1) {
    Log.w(TAG,""String_Node_Str"",e1);
    if (fos != null) {
      mAccountInfoFile.failWrite(fos);
    }
  }
}","/** 
 * Write all account information to the account file.
 */
private void writeAccountInfoLocked(){
  if (DEBUG_FILE)   Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
  FileOutputStream fos=null;
  try {
    fos=mAccountInfoFile.startWrite();
    XmlSerializer out=new FastXmlSerializer();
    out.setOutput(fos,""String_Node_Str"");
    out.startDocument(null,true);
    out.setFeature(""String_Node_Str"",true);
    out.startTag(null,""String_Node_Str"");
    out.attribute(null,""String_Node_Str"",Integer.toString(ACCOUNTS_VERSION));
    if (!mMasterSyncAutomatically) {
      out.attribute(null,""String_Node_Str"",""String_Node_Str"");
    }
    final int N=mAuthorities.size();
    for (int i=0; i < N; i++) {
      AuthorityInfo authority=mAuthorities.valueAt(i);
      out.startTag(null,""String_Node_Str"");
      out.attribute(null,""String_Node_Str"",Integer.toString(authority.ident));
      out.attribute(null,""String_Node_Str"",authority.account.name);
      out.attribute(null,""String_Node_Str"",authority.account.type);
      out.attribute(null,""String_Node_Str"",authority.authority);
      out.attribute(null,""String_Node_Str"",Boolean.toString(authority.enabled));
      if (authority.syncable < 0) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
 else {
        out.attribute(null,""String_Node_Str"",Boolean.toString(authority.syncable != 0));
      }
      for (      Pair<Bundle,Long> periodicSync : authority.periodicSyncs) {
        out.startTag(null,""String_Node_Str"");
        out.attribute(null,""String_Node_Str"",Long.toString(periodicSync.second));
        final Bundle extras=periodicSync.first;
        for (        String key : extras.keySet()) {
          out.startTag(null,""String_Node_Str"");
          out.attribute(null,""String_Node_Str"",key);
          final Object value=extras.get(key);
          if (value instanceof Long) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Integer) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Boolean) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Float) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Double) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof String) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Account) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",((Account)value).name);
            out.attribute(null,""String_Node_Str"",((Account)value).type);
          }
          out.endTag(null,""String_Node_Str"");
        }
        out.endTag(null,""String_Node_Str"");
      }
      out.endTag(null,""String_Node_Str"");
    }
    out.endTag(null,""String_Node_Str"");
    out.endDocument();
    mAccountInfoFile.finishWrite(fos);
  }
 catch (  java.io.IOException e1) {
    Log.w(TAG,""String_Node_Str"",e1);
    if (fos != null) {
      mAccountInfoFile.failWrite(fos);
    }
  }
}"
22689,"private void removeAuthorityLocked(Account account,String authorityName){
  AccountInfo accountInfo=mAccounts.get(account);
  if (accountInfo != null) {
    if (accountInfo.authorities.remove(authorityName) != null) {
      writeAccountInfoLocked();
    }
  }
}","private void removeAuthorityLocked(Account account,String authorityName){
  AccountInfo accountInfo=mAccounts.get(account);
  if (accountInfo != null) {
    final AuthorityInfo authorityInfo=accountInfo.authorities.remove(authorityName);
    if (authorityInfo != null) {
      mAuthorities.remove(authorityInfo.ident);
      writeAccountInfoLocked();
    }
  }
}"
22690,"@SmallTest public void testAuthorityParsing() throws Exception {
  final Account account=new Account(""String_Node_Str"",""String_Node_Str"");
  final String authority1=""String_Node_Str"";
  final String authority2=""String_Node_Str"";
  final String authority3=""String_Node_Str"";
  final Bundle extras=new Bundle();
  PeriodicSync sync1=new PeriodicSync(account,authority1,extras,(long)(60 * 60 * 24));
  PeriodicSync sync2=new PeriodicSync(account,authority2,extras,(long)(60 * 60 * 24));
  PeriodicSync sync3=new PeriodicSync(account,authority3,extras,(long)(60 * 60 * 24));
  PeriodicSync sync1s=new PeriodicSync(account,authority1,extras,1000);
  PeriodicSync sync2s=new PeriodicSync(account,authority2,extras,1000);
  PeriodicSync sync3s=new PeriodicSync(account,authority3,extras,1000);
  MockContentResolver mockResolver=new MockContentResolver();
  final TestContext testContext=new TestContext(mockResolver,getContext());
  SyncStorageEngine engine=SyncStorageEngine.newTestInstance(testContext);
  byte[] accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  File syncDir=new File(new File(testContext.getFilesDir(),""String_Node_Str""),""String_Node_Str"");
  syncDir.mkdirs();
  AtomicFile accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  FileOutputStream fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  List<PeriodicSync> syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3,syncs.get(0));
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(0,syncs.size());
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3s,syncs.get(0));
}","@SmallTest public void testAuthorityParsing() throws Exception {
  final Account account=new Account(""String_Node_Str"",""String_Node_Str"");
  final String authority1=""String_Node_Str"";
  final String authority2=""String_Node_Str"";
  final String authority3=""String_Node_Str"";
  final Bundle extras=new Bundle();
  PeriodicSync sync1=new PeriodicSync(account,authority1,extras,(long)(60 * 60 * 24));
  PeriodicSync sync2=new PeriodicSync(account,authority2,extras,(long)(60 * 60 * 24));
  PeriodicSync sync3=new PeriodicSync(account,authority3,extras,(long)(60 * 60 * 24));
  PeriodicSync sync1s=new PeriodicSync(account,authority1,extras,1000);
  PeriodicSync sync2s=new PeriodicSync(account,authority2,extras,1000);
  PeriodicSync sync3s=new PeriodicSync(account,authority3,extras,1000);
  MockContentResolver mockResolver=new MockContentResolver();
  final TestContext testContext=new TestContext(mockResolver,getContext());
  byte[] accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  File syncDir=new File(new File(testContext.getFilesDir(),""String_Node_Str""),""String_Node_Str"");
  syncDir.mkdirs();
  AtomicFile accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  FileOutputStream fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  SyncStorageEngine engine=SyncStorageEngine.newTestInstance(testContext);
  List<PeriodicSync> syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3,syncs.get(0));
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(0,syncs.size());
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3s,syncs.get(0));
}"
22691,"private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (format == null || ""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    return new SimpleDateFormat(format);
  }
}","private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (format == null || ""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    try {
      return new SimpleDateFormat(format);
    }
 catch (    IllegalArgumentException e) {
      return DateFormat.getDateInstance(DateFormat.SHORT);
    }
  }
}"
22692,"public void onBootCompleted(){
  mBootCompleted=true;
  if (mReadyToRunLatch != null) {
    mReadyToRunLatch.countDown();
  }
}","public void onBootCompleted(){
  mBootCompleted=true;
  mSyncStorageEngine.doDatabaseCleanup(AccountManager.get(mContext).getAccounts());
  if (mReadyToRunLatch != null) {
    mReadyToRunLatch.countDown();
  }
}"
22693,"public void onAccountsUpdated(Account[] accounts){
  final boolean justBootedUp=mAccounts == INITIAL_ACCOUNTS_ARRAY;
  mAccounts=accounts;
  ActiveSyncContext activeSyncContext=mActiveSyncContext;
  if (activeSyncContext != null) {
    if (!ArrayUtils.contains(accounts,activeSyncContext.mSyncOperation.account)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(activeSyncContext,null);
    }
  }
  sendCheckAlarmsMessage();
  mSyncStorageEngine.doDatabaseCleanup(accounts);
  if (accounts.length > 0) {
    boolean onlyThoseWithUnkownSyncableState=justBootedUp;
    scheduleSync(null,null,null,0,onlyThoseWithUnkownSyncableState);
  }
}","public void onAccountsUpdated(Account[] accounts){
  final boolean justBootedUp=mAccounts == INITIAL_ACCOUNTS_ARRAY;
  mAccounts=accounts;
  ActiveSyncContext activeSyncContext=mActiveSyncContext;
  if (activeSyncContext != null) {
    if (!ArrayUtils.contains(accounts,activeSyncContext.mSyncOperation.account)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(activeSyncContext,null);
    }
  }
  sendCheckAlarmsMessage();
  if (mBootCompleted) {
    mSyncStorageEngine.doDatabaseCleanup(accounts);
  }
  if (accounts.length > 0) {
    boolean onlyThoseWithUnkownSyncableState=justBootedUp;
    scheduleSync(null,null,null,0,onlyThoseWithUnkownSyncableState);
  }
}"
22694,"/** 
 * Read all account information back in to the initial engine state.
 */
private void readAccountInfoLocked(){
  boolean writeNeeded=false;
  FileInputStream fis=null;
  try {
    fis=mAccountInfoFile.openRead();
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(fis,null);
    int eventType=parser.getEventType();
    while (eventType != XmlPullParser.START_TAG) {
      eventType=parser.next();
    }
    String tagName=parser.getName();
    if (""String_Node_Str"".equals(tagName)) {
      String listen=parser.getAttributeValue(null,""String_Node_Str"");
      String versionString=parser.getAttributeValue(null,""String_Node_Str"");
      int version;
      try {
        version=(versionString == null) ? 0 : Integer.parseInt(versionString);
      }
 catch (      NumberFormatException e) {
        version=0;
      }
      if (version < ACCOUNTS_VERSION) {
        writeNeeded=true;
      }
      mMasterSyncAutomatically=listen == null || Boolean.parseBoolean(listen);
      eventType=parser.next();
      AuthorityInfo authority=null;
      Pair<Bundle,Long> periodicSync=null;
      do {
        if (eventType == XmlPullParser.START_TAG) {
          tagName=parser.getName();
          if (parser.getDepth() == 2) {
            if (""String_Node_Str"".equals(tagName)) {
              authority=parseAuthority(parser,version);
              periodicSync=null;
            }
          }
 else           if (parser.getDepth() == 3) {
            if (""String_Node_Str"".equals(tagName) && authority != null) {
              periodicSync=parsePeriodicSync(parser,authority);
            }
          }
 else           if (parser.getDepth() == 4 && periodicSync != null) {
            if (""String_Node_Str"".equals(tagName)) {
              parseExtra(parser,periodicSync);
            }
          }
        }
        eventType=parser.next();
      }
 while (eventType != XmlPullParser.END_DOCUMENT);
    }
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"",e);
    return;
  }
catch (  java.io.IOException e) {
    if (fis == null)     Log.i(TAG,""String_Node_Str"");
 else     Log.w(TAG,""String_Node_Str"",e);
    return;
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      java.io.IOException e1) {
      }
    }
  }
  if (writeNeeded) {
    writeAccountInfoLocked();
  }
}","/** 
 * Read all account information back in to the initial engine state.
 */
private void readAccountInfoLocked(){
  boolean writeNeeded=false;
  FileInputStream fis=null;
  try {
    fis=mAccountInfoFile.openRead();
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(fis,null);
    int eventType=parser.getEventType();
    while (eventType != XmlPullParser.START_TAG) {
      eventType=parser.next();
    }
    String tagName=parser.getName();
    if (""String_Node_Str"".equals(tagName)) {
      String listen=parser.getAttributeValue(null,""String_Node_Str"");
      String versionString=parser.getAttributeValue(null,""String_Node_Str"");
      int version;
      try {
        version=(versionString == null) ? 0 : Integer.parseInt(versionString);
      }
 catch (      NumberFormatException e) {
        version=0;
      }
      if (version < ACCOUNTS_VERSION) {
        writeNeeded=true;
      }
      mMasterSyncAutomatically=listen == null || Boolean.parseBoolean(listen);
      eventType=parser.next();
      AuthorityInfo authority=null;
      Pair<Bundle,Long> periodicSync=null;
      do {
        if (eventType == XmlPullParser.START_TAG) {
          tagName=parser.getName();
          if (parser.getDepth() == 2) {
            if (""String_Node_Str"".equals(tagName)) {
              authority=parseAuthority(parser,version);
              periodicSync=null;
            }
          }
 else           if (parser.getDepth() == 3) {
            if (""String_Node_Str"".equals(tagName) && authority != null) {
              periodicSync=parsePeriodicSync(parser,authority);
            }
          }
 else           if (parser.getDepth() == 4 && periodicSync != null) {
            if (""String_Node_Str"".equals(tagName)) {
              parseExtra(parser,periodicSync);
            }
          }
        }
        eventType=parser.next();
      }
 while (eventType != XmlPullParser.END_DOCUMENT);
    }
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"",e);
    return;
  }
catch (  java.io.IOException e) {
    if (fis == null)     Log.i(TAG,""String_Node_Str"");
 else     Log.w(TAG,""String_Node_Str"",e);
    return;
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      java.io.IOException e1) {
      }
    }
  }
  if (maybeMigrateSettingsForRenamedAuthorities()) {
    writeNeeded=true;
  }
  if (writeNeeded) {
    writeAccountInfoLocked();
  }
}"
22695,"private AuthorityInfo parseAuthority(XmlPullParser parser,int version){
  AuthorityInfo authority=null;
  int id=-1;
  try {
    id=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
catch (  NullPointerException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (id >= 0) {
    String accountName=parser.getAttributeValue(null,""String_Node_Str"");
    String accountType=parser.getAttributeValue(null,""String_Node_Str"");
    if (accountType == null) {
      accountType=""String_Node_Str"";
    }
    String authorityName=parser.getAttributeValue(null,""String_Node_Str"");
    String enabled=parser.getAttributeValue(null,""String_Node_Str"");
    String syncable=parser.getAttributeValue(null,""String_Node_Str"");
    authority=mAuthorities.get(id);
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    if (authority == null) {
      if (DEBUG_FILE)       Log.v(TAG,""String_Node_Str"");
      authority=getOrCreateAuthorityLocked(new Account(accountName,accountType),authorityName,id,false);
      if (version > 0) {
        authority.periodicSyncs.clear();
      }
    }
    if (authority != null) {
      authority.enabled=enabled == null || Boolean.parseBoolean(enabled);
      if (""String_Node_Str"".equals(syncable)) {
        authority.syncable=-1;
      }
 else {
        authority.syncable=(syncable == null || Boolean.parseBoolean(enabled)) ? 1 : 0;
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    }
  }
  return authority;
}","private AuthorityInfo parseAuthority(XmlPullParser parser,int version){
  AuthorityInfo authority=null;
  int id=-1;
  try {
    id=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
catch (  NullPointerException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (id >= 0) {
    String authorityName=parser.getAttributeValue(null,""String_Node_Str"");
    String enabled=parser.getAttributeValue(null,""String_Node_Str"");
    String syncable=parser.getAttributeValue(null,""String_Node_Str"");
    String accountName=parser.getAttributeValue(null,""String_Node_Str"");
    String accountType=parser.getAttributeValue(null,""String_Node_Str"");
    if (accountType == null) {
      accountType=""String_Node_Str"";
      syncable=""String_Node_Str"";
    }
    authority=mAuthorities.get(id);
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    if (authority == null) {
      if (DEBUG_FILE)       Log.v(TAG,""String_Node_Str"");
      authority=getOrCreateAuthorityLocked(new Account(accountName,accountType),authorityName,id,false);
      if (version > 0) {
        authority.periodicSyncs.clear();
      }
    }
    if (authority != null) {
      authority.enabled=enabled == null || Boolean.parseBoolean(enabled);
      if (""String_Node_Str"".equals(syncable)) {
        authority.syncable=-1;
      }
 else {
        authority.syncable=(syncable == null || Boolean.parseBoolean(syncable)) ? 1 : 0;
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    }
  }
  return authority;
}"
22696,"/** 
 * Write all account information to the account file.
 */
private void writeAccountInfoLocked(){
  if (DEBUG_FILE)   Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
  FileOutputStream fos=null;
  try {
    fos=mAccountInfoFile.startWrite();
    XmlSerializer out=new FastXmlSerializer();
    out.setOutput(fos,""String_Node_Str"");
    out.startDocument(null,true);
    out.setFeature(""String_Node_Str"",true);
    out.startTag(null,""String_Node_Str"");
    out.attribute(null,""String_Node_Str"",Integer.toString(ACCOUNTS_VERSION));
    if (!mMasterSyncAutomatically) {
      out.attribute(null,""String_Node_Str"",""String_Node_Str"");
    }
    final int N=mAuthorities.size();
    for (int i=0; i < N; i++) {
      AuthorityInfo authority=mAuthorities.valueAt(i);
      out.startTag(null,""String_Node_Str"");
      out.attribute(null,""String_Node_Str"",Integer.toString(authority.ident));
      out.attribute(null,""String_Node_Str"",authority.account.name);
      out.attribute(null,""String_Node_Str"",authority.account.type);
      out.attribute(null,""String_Node_Str"",authority.authority);
      if (!authority.enabled) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
      if (authority.syncable < 0) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
 else       if (authority.syncable == 0) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
      for (      Pair<Bundle,Long> periodicSync : authority.periodicSyncs) {
        out.startTag(null,""String_Node_Str"");
        out.attribute(null,""String_Node_Str"",Long.toString(periodicSync.second));
        final Bundle extras=periodicSync.first;
        for (        String key : extras.keySet()) {
          out.startTag(null,""String_Node_Str"");
          out.attribute(null,""String_Node_Str"",key);
          final Object value=extras.get(key);
          if (value instanceof Long) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Integer) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Boolean) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Float) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Double) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof String) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Account) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",((Account)value).name);
            out.attribute(null,""String_Node_Str"",((Account)value).type);
          }
          out.endTag(null,""String_Node_Str"");
        }
        out.endTag(null,""String_Node_Str"");
      }
      out.endTag(null,""String_Node_Str"");
    }
    out.endTag(null,""String_Node_Str"");
    out.endDocument();
    mAccountInfoFile.finishWrite(fos);
  }
 catch (  java.io.IOException e1) {
    Log.w(TAG,""String_Node_Str"",e1);
    if (fos != null) {
      mAccountInfoFile.failWrite(fos);
    }
  }
}","/** 
 * Write all account information to the account file.
 */
private void writeAccountInfoLocked(){
  if (DEBUG_FILE)   Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
  FileOutputStream fos=null;
  try {
    fos=mAccountInfoFile.startWrite();
    XmlSerializer out=new FastXmlSerializer();
    out.setOutput(fos,""String_Node_Str"");
    out.startDocument(null,true);
    out.setFeature(""String_Node_Str"",true);
    out.startTag(null,""String_Node_Str"");
    out.attribute(null,""String_Node_Str"",Integer.toString(ACCOUNTS_VERSION));
    if (!mMasterSyncAutomatically) {
      out.attribute(null,""String_Node_Str"",""String_Node_Str"");
    }
    final int N=mAuthorities.size();
    for (int i=0; i < N; i++) {
      AuthorityInfo authority=mAuthorities.valueAt(i);
      out.startTag(null,""String_Node_Str"");
      out.attribute(null,""String_Node_Str"",Integer.toString(authority.ident));
      out.attribute(null,""String_Node_Str"",authority.account.name);
      out.attribute(null,""String_Node_Str"",authority.account.type);
      out.attribute(null,""String_Node_Str"",authority.authority);
      out.attribute(null,""String_Node_Str"",Boolean.toString(authority.enabled));
      if (authority.syncable < 0) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
 else {
        out.attribute(null,""String_Node_Str"",Boolean.toString(authority.syncable != 0));
      }
      for (      Pair<Bundle,Long> periodicSync : authority.periodicSyncs) {
        out.startTag(null,""String_Node_Str"");
        out.attribute(null,""String_Node_Str"",Long.toString(periodicSync.second));
        final Bundle extras=periodicSync.first;
        for (        String key : extras.keySet()) {
          out.startTag(null,""String_Node_Str"");
          out.attribute(null,""String_Node_Str"",key);
          final Object value=extras.get(key);
          if (value instanceof Long) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Integer) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Boolean) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Float) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Double) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof String) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Account) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",((Account)value).name);
            out.attribute(null,""String_Node_Str"",((Account)value).type);
          }
          out.endTag(null,""String_Node_Str"");
        }
        out.endTag(null,""String_Node_Str"");
      }
      out.endTag(null,""String_Node_Str"");
    }
    out.endTag(null,""String_Node_Str"");
    out.endDocument();
    mAccountInfoFile.finishWrite(fos);
  }
 catch (  java.io.IOException e1) {
    Log.w(TAG,""String_Node_Str"",e1);
    if (fos != null) {
      mAccountInfoFile.failWrite(fos);
    }
  }
}"
22697,"private void removeAuthorityLocked(Account account,String authorityName){
  AccountInfo accountInfo=mAccounts.get(account);
  if (accountInfo != null) {
    if (accountInfo.authorities.remove(authorityName) != null) {
      writeAccountInfoLocked();
    }
  }
}","private void removeAuthorityLocked(Account account,String authorityName){
  AccountInfo accountInfo=mAccounts.get(account);
  if (accountInfo != null) {
    final AuthorityInfo authorityInfo=accountInfo.authorities.remove(authorityName);
    if (authorityInfo != null) {
      mAuthorities.remove(authorityInfo.ident);
      writeAccountInfoLocked();
    }
  }
}"
22698,"@SmallTest public void testAuthorityParsing() throws Exception {
  final Account account=new Account(""String_Node_Str"",""String_Node_Str"");
  final String authority1=""String_Node_Str"";
  final String authority2=""String_Node_Str"";
  final String authority3=""String_Node_Str"";
  final Bundle extras=new Bundle();
  PeriodicSync sync1=new PeriodicSync(account,authority1,extras,(long)(60 * 60 * 24));
  PeriodicSync sync2=new PeriodicSync(account,authority2,extras,(long)(60 * 60 * 24));
  PeriodicSync sync3=new PeriodicSync(account,authority3,extras,(long)(60 * 60 * 24));
  PeriodicSync sync1s=new PeriodicSync(account,authority1,extras,1000);
  PeriodicSync sync2s=new PeriodicSync(account,authority2,extras,1000);
  PeriodicSync sync3s=new PeriodicSync(account,authority3,extras,1000);
  MockContentResolver mockResolver=new MockContentResolver();
  final TestContext testContext=new TestContext(mockResolver,getContext());
  SyncStorageEngine engine=SyncStorageEngine.newTestInstance(testContext);
  byte[] accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  File syncDir=new File(new File(testContext.getFilesDir(),""String_Node_Str""),""String_Node_Str"");
  syncDir.mkdirs();
  AtomicFile accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  FileOutputStream fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  List<PeriodicSync> syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3,syncs.get(0));
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(0,syncs.size());
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3s,syncs.get(0));
}","@SmallTest public void testAuthorityParsing() throws Exception {
  final Account account=new Account(""String_Node_Str"",""String_Node_Str"");
  final String authority1=""String_Node_Str"";
  final String authority2=""String_Node_Str"";
  final String authority3=""String_Node_Str"";
  final Bundle extras=new Bundle();
  PeriodicSync sync1=new PeriodicSync(account,authority1,extras,(long)(60 * 60 * 24));
  PeriodicSync sync2=new PeriodicSync(account,authority2,extras,(long)(60 * 60 * 24));
  PeriodicSync sync3=new PeriodicSync(account,authority3,extras,(long)(60 * 60 * 24));
  PeriodicSync sync1s=new PeriodicSync(account,authority1,extras,1000);
  PeriodicSync sync2s=new PeriodicSync(account,authority2,extras,1000);
  PeriodicSync sync3s=new PeriodicSync(account,authority3,extras,1000);
  MockContentResolver mockResolver=new MockContentResolver();
  final TestContext testContext=new TestContext(mockResolver,getContext());
  byte[] accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  File syncDir=new File(new File(testContext.getFilesDir(),""String_Node_Str""),""String_Node_Str"");
  syncDir.mkdirs();
  AtomicFile accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  FileOutputStream fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  SyncStorageEngine engine=SyncStorageEngine.newTestInstance(testContext);
  List<PeriodicSync> syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3,syncs.get(0));
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(0,syncs.size());
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3s,syncs.get(0));
}"
22699,"private void grantPermissionsLP(PackageParser.Package pkg,boolean replace){
  final PackageSetting ps=(PackageSetting)pkg.mExtras;
  if (ps == null) {
    return;
  }
  final GrantedPermissions gp=ps.sharedUser != null ? ps.sharedUser : ps;
  boolean changedPermission=false;
  if (replace) {
    ps.permissionsFixed=false;
    if (gp == ps) {
      gp.grantedPermissions.clear();
      gp.gids=mGlobalGids;
    }
  }
  if (gp.gids == null) {
    gp.gids=mGlobalGids;
  }
  final int N=pkg.requestedPermissions.size();
  for (int i=0; i < N; i++) {
    String name=pkg.requestedPermissions.get(i);
    BasePermission bp=mSettings.mPermissions.get(name);
    if (false) {
      if (gp != ps) {
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ name+ ""String_Node_Str""+ bp);
      }
    }
    if (bp != null && bp.packageSetting != null) {
      final String perm=bp.name;
      boolean allowed;
      boolean allowedSig=false;
      if (bp.protectionLevel == PermissionInfo.PROTECTION_NORMAL || bp.protectionLevel == PermissionInfo.PROTECTION_DANGEROUS) {
        allowed=true;
      }
 else       if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE || bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
        allowed=(checkSignaturesLP(bp.packageSetting.signatures.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (checkSignaturesLP(mPlatformPackage.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH);
        if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
          if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) {
              PackageSetting sysPs=mSettings.getDisabledSystemPkg(pkg.packageName);
              if (sysPs.grantedPermissions.contains(perm)) {
                allowed=true;
              }
 else {
                allowed=false;
              }
            }
 else {
              allowed=true;
            }
          }
        }
        if (allowed) {
          allowedSig=true;
        }
      }
 else {
        allowed=false;
      }
      if (false) {
        if (gp != ps) {
          Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ perm);
        }
      }
      if (allowed) {
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0 && ps.permissionsFixed) {
          if (!allowedSig && !gp.grantedPermissions.contains(perm)) {
            allowed=false;
            final int NP=PackageParser.NEW_PERMISSIONS.length;
            for (int ip=0; ip < NP; ip++) {
              final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
              if (npi.name.equals(perm) && pkg.applicationInfo.targetSdkVersion < npi.sdkVersion) {
                allowed=true;
                Log.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName);
                break;
              }
            }
          }
        }
        if (allowed) {
          if (!gp.grantedPermissions.contains(perm)) {
            changedPermission=true;
            gp.grantedPermissions.add(perm);
            gp.gids=appendInts(gp.gids,bp.gids);
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str"");
        }
      }
 else {
        if (gp.grantedPermissions.remove(perm)) {
          changedPermission=true;
          gp.gids=removeInts(gp.gids,bp.gids);
          Slog.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ pkg.packageName);
    }
  }
  if ((changedPermission || replace) && !ps.permissionsFixed && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) || ((ps.pkgFlags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0)) {
    ps.permissionsFixed=true;
  }
}","private void grantPermissionsLP(PackageParser.Package pkg,boolean replace){
  final PackageSetting ps=(PackageSetting)pkg.mExtras;
  if (ps == null) {
    return;
  }
  final GrantedPermissions gp=ps.sharedUser != null ? ps.sharedUser : ps;
  boolean changedPermission=false;
  if (replace) {
    ps.permissionsFixed=false;
    if (gp == ps) {
      gp.grantedPermissions.clear();
      gp.gids=mGlobalGids;
    }
  }
  if (gp.gids == null) {
    gp.gids=mGlobalGids;
  }
  final int N=pkg.requestedPermissions.size();
  for (int i=0; i < N; i++) {
    String name=pkg.requestedPermissions.get(i);
    BasePermission bp=mSettings.mPermissions.get(name);
    if (false) {
      if (gp != ps) {
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ name+ ""String_Node_Str""+ bp);
      }
    }
    if (bp != null && bp.packageSetting != null) {
      final String perm=bp.name;
      boolean allowed;
      boolean allowedSig=false;
      if (bp.protectionLevel == PermissionInfo.PROTECTION_NORMAL || bp.protectionLevel == PermissionInfo.PROTECTION_DANGEROUS) {
        allowed=true;
      }
 else       if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE || bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
        allowed=(checkSignaturesLP(bp.packageSetting.signatures.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (checkSignaturesLP(mPlatformPackage.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH);
        if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
          if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) {
              PackageSetting sysPs=mSettings.getDisabledSystemPkg(pkg.packageName);
              if (sysPs.grantedPermissions.contains(perm)) {
                allowed=true;
              }
 else {
                allowed=false;
              }
            }
 else {
              allowed=true;
            }
          }
        }
        if (allowed) {
          allowedSig=true;
        }
      }
 else {
        allowed=false;
      }
      if (false) {
        if (gp != ps) {
          Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ perm);
        }
      }
      if (allowed) {
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0 && ps.permissionsFixed) {
          if (!allowedSig && !gp.grantedPermissions.contains(perm)) {
            allowed=false;
            final int NP=PackageParser.NEW_PERMISSIONS.length;
            for (int ip=0; ip < NP; ip++) {
              final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
              if (npi.name.equals(perm) && pkg.applicationInfo.targetSdkVersion < npi.sdkVersion) {
                allowed=true;
                Log.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName);
                break;
              }
            }
          }
        }
        if (allowed) {
          if (!gp.grantedPermissions.contains(perm)) {
            changedPermission=true;
            gp.grantedPermissions.add(perm);
            gp.gids=appendInts(gp.gids,bp.gids);
          }
 else           if (!ps.haveGids) {
            gp.gids=appendInts(gp.gids,bp.gids);
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str"");
        }
      }
 else {
        if (gp.grantedPermissions.remove(perm)) {
          changedPermission=true;
          gp.gids=removeInts(gp.gids,bp.gids);
          Slog.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ pkg.packageName);
    }
  }
  if ((changedPermission || replace) && !ps.permissionsFixed && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) || ((ps.pkgFlags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0)) {
    ps.permissionsFixed=true;
  }
  ps.haveGids=true;
}"
22700,"public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  timeStamp=base.timeStamp;
  timeStampString=base.timeStampString;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  disabledComponents=base.disabledComponents;
  enabledComponents=base.enabledComponents;
  enabled=base.enabled;
  installStatus=base.installStatus;
}","public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  timeStamp=base.timeStamp;
  timeStampString=base.timeStampString;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  haveGids=base.haveGids;
  disabledComponents=base.disabledComponents;
  enabledComponents=base.enabledComponents;
  enabled=base.enabled;
  installStatus=base.installStatus;
}"
22701,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  String packageName=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
    }
 else     if (""String_Node_Str"".equals(opt)) {
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || cmd.contains(""String_Node_Str"")) {
      packageName=cmd;
    }
  }
  boolean printedTitle=false;
synchronized (mPackages) {
    if (mActivities.dump(pw,""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mReceivers.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mServices.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mSettings.mPreferredActivities.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    boolean printedSomething=false;
{
      for (      BasePermission p : mSettings.mPermissions.values()) {
        if (packageName != null && !packageName.equals(p.sourcePackage)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(p.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(p)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(p.sourcePackage);
        pw.print(""String_Node_Str"");
        pw.print(p.uid);
        pw.print(""String_Node_Str"");
        pw.print(arrayToString(p.gids));
        pw.print(""String_Node_Str"");
        pw.print(p.type);
        pw.print(""String_Node_Str"");
        pw.println(p.protectionLevel);
        if (p.packageSetting != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.packageSetting);
        }
        if (p.perm != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.perm);
        }
      }
    }
    printedSomething=false;
    SharedUserSetting packageSharedUser=null;
{
      for (      PackageSetting ps : mSettings.mPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        packageSharedUser=ps.sharedUser;
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(ps.gids));
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
        if (ps.pkg != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.dataDir);
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.targetSdkVersion);
          pw.print(""String_Node_Str"");
          boolean first=true;
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
        }
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(ps.getTimeStampStr());
        pw.print(""String_Node_Str"");
        pw.println(ps.signatures);
        pw.print(""String_Node_Str"");
        pw.print(ps.permissionsFixed);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(ps.pkgFlags));
        pw.print(""String_Node_Str"");
        pw.print(ps.installStatus);
        pw.print(""String_Node_Str"");
        pw.println(ps.enabled);
        if (ps.disabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.disabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.enabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.enabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.grantedPermissions.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.grantedPermissions) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
      }
    }
    printedSomething=false;
    if (mSettings.mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mSettings.mRenamedPackages.entrySet()) {
        if (packageName != null && !packageName.equals(e.getKey()) && !packageName.equals(e.getValue())) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(e.getKey());
        pw.print(""String_Node_Str"");
        pw.println(e.getValue());
      }
    }
    printedSomething=false;
    if (mSettings.mDisabledSysPackages.size() > 0) {
      for (      PackageSetting ps : mSettings.mDisabledSysPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.println(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
      }
    }
    printedSomething=false;
{
      for (      SharedUserSetting su : mSettings.mSharedUsers.values()) {
        if (packageName != null && su != packageSharedUser) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(su.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(su)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.print(su.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(su.gids));
        pw.println(""String_Node_Str"");
        for (        String s : su.grantedPermissions) {
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
    }
    if (packageName == null) {
      if (printedTitle)       pw.println(""String_Node_Str"");
      printedTitle=true;
      pw.println(""String_Node_Str"");
      pw.println(mSettings.mReadMessages.toString());
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      File fname=getSettingsProblemFile();
      FileInputStream in;
      try {
        in=new FileInputStream(fname);
        int avail=in.available();
        byte[] data=new byte[avail];
        in.read(data);
        pw.println(new String(data));
      }
 catch (      FileNotFoundException e) {
      }
catch (      IOException e) {
      }
    }
  }
synchronized (mProviders) {
    boolean printedSomething=false;
    for (    PackageParser.Provider p : mProviders.values()) {
      if (packageName != null && !packageName.equals(p.info.packageName)) {
        continue;
      }
      if (!printedSomething) {
        if (printedTitle)         pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        printedSomething=true;
        printedTitle=true;
      }
      pw.print(""String_Node_Str"");
      pw.print(p.info.authority);
      pw.print(""String_Node_Str"");
      pw.println(p.toString());
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  String packageName=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
    }
 else     if (""String_Node_Str"".equals(opt)) {
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || cmd.contains(""String_Node_Str"")) {
      packageName=cmd;
    }
  }
  boolean printedTitle=false;
synchronized (mPackages) {
    if (mActivities.dump(pw,""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mReceivers.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mServices.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mSettings.mPreferredActivities.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    boolean printedSomething=false;
{
      for (      BasePermission p : mSettings.mPermissions.values()) {
        if (packageName != null && !packageName.equals(p.sourcePackage)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(p.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(p)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(p.sourcePackage);
        pw.print(""String_Node_Str"");
        pw.print(p.uid);
        pw.print(""String_Node_Str"");
        pw.print(arrayToString(p.gids));
        pw.print(""String_Node_Str"");
        pw.print(p.type);
        pw.print(""String_Node_Str"");
        pw.println(p.protectionLevel);
        if (p.packageSetting != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.packageSetting);
        }
        if (p.perm != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.perm);
        }
      }
    }
    printedSomething=false;
    SharedUserSetting packageSharedUser=null;
{
      for (      PackageSetting ps : mSettings.mPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        packageSharedUser=ps.sharedUser;
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(ps.gids));
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
        if (ps.pkg != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.dataDir);
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.targetSdkVersion);
          pw.print(""String_Node_Str"");
          boolean first=true;
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
        }
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(ps.getTimeStampStr());
        pw.print(""String_Node_Str"");
        pw.println(ps.signatures);
        pw.print(""String_Node_Str"");
        pw.print(ps.permissionsFixed);
        pw.print(""String_Node_Str"");
        pw.println(ps.haveGids);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(ps.pkgFlags));
        pw.print(""String_Node_Str"");
        pw.print(ps.installStatus);
        pw.print(""String_Node_Str"");
        pw.println(ps.enabled);
        if (ps.disabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.disabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.enabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.enabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.grantedPermissions.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.grantedPermissions) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
      }
    }
    printedSomething=false;
    if (mSettings.mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mSettings.mRenamedPackages.entrySet()) {
        if (packageName != null && !packageName.equals(e.getKey()) && !packageName.equals(e.getValue())) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(e.getKey());
        pw.print(""String_Node_Str"");
        pw.println(e.getValue());
      }
    }
    printedSomething=false;
    if (mSettings.mDisabledSysPackages.size() > 0) {
      for (      PackageSetting ps : mSettings.mDisabledSysPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.println(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
      }
    }
    printedSomething=false;
{
      for (      SharedUserSetting su : mSettings.mSharedUsers.values()) {
        if (packageName != null && su != packageSharedUser) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(su.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(su)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.print(su.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(su.gids));
        pw.println(""String_Node_Str"");
        for (        String s : su.grantedPermissions) {
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
    }
    if (packageName == null) {
      if (printedTitle)       pw.println(""String_Node_Str"");
      printedTitle=true;
      pw.println(""String_Node_Str"");
      pw.println(mSettings.mReadMessages.toString());
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      File fname=getSettingsProblemFile();
      FileInputStream in;
      try {
        in=new FileInputStream(fname);
        int avail=in.available();
        byte[] data=new byte[avail];
        in.read(data);
        pw.println(new String(data));
      }
 catch (      FileNotFoundException e) {
      }
catch (      IOException e) {
      }
    }
  }
synchronized (mProviders) {
    boolean printedSomething=false;
    for (    PackageParser.Provider p : mProviders.values()) {
      if (packageName != null && !packageName.equals(p.info.packageName)) {
        continue;
      }
      if (!printedSomething) {
        if (printedTitle)         pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        printedSomething=true;
        printedTitle=true;
      }
      pw.print(""String_Node_Str"");
      pw.print(p.info.authority);
      pw.print(""String_Node_Str"");
      pw.println(p.toString());
    }
  }
}"
22702,"private void grantPermissionsLP(PackageParser.Package pkg,boolean replace){
  final PackageSetting ps=(PackageSetting)pkg.mExtras;
  if (ps == null) {
    return;
  }
  final GrantedPermissions gp=ps.sharedUser != null ? ps.sharedUser : ps;
  boolean changedPermission=false;
  if (replace) {
    ps.permissionsFixed=false;
    if (gp == ps) {
      gp.grantedPermissions.clear();
      gp.gids=mGlobalGids;
    }
  }
  if (gp.gids == null) {
    gp.gids=mGlobalGids;
  }
  final int N=pkg.requestedPermissions.size();
  for (int i=0; i < N; i++) {
    String name=pkg.requestedPermissions.get(i);
    BasePermission bp=mSettings.mPermissions.get(name);
    if (false) {
      if (gp != ps) {
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ name+ ""String_Node_Str""+ bp);
      }
    }
    if (bp != null && bp.packageSetting != null) {
      final String perm=bp.name;
      boolean allowed;
      boolean allowedSig=false;
      if (bp.protectionLevel == PermissionInfo.PROTECTION_NORMAL || bp.protectionLevel == PermissionInfo.PROTECTION_DANGEROUS) {
        allowed=true;
      }
 else       if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE || bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
        allowed=(checkSignaturesLP(bp.packageSetting.signatures.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (checkSignaturesLP(mPlatformPackage.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH);
        if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
          if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) {
              PackageSetting sysPs=mSettings.getDisabledSystemPkg(pkg.packageName);
              if (sysPs.grantedPermissions.contains(perm)) {
                allowed=true;
              }
 else {
                allowed=false;
              }
            }
 else {
              allowed=true;
            }
          }
        }
        if (allowed) {
          allowedSig=true;
        }
      }
 else {
        allowed=false;
      }
      if (false) {
        if (gp != ps) {
          Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ perm);
        }
      }
      if (allowed) {
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0 && ps.permissionsFixed) {
          if (!allowedSig && !gp.grantedPermissions.contains(perm)) {
            allowed=false;
            final int NP=PackageParser.NEW_PERMISSIONS.length;
            for (int ip=0; ip < NP; ip++) {
              final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
              if (npi.name.equals(perm) && pkg.applicationInfo.targetSdkVersion < npi.sdkVersion) {
                allowed=true;
                Log.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName);
                break;
              }
            }
          }
        }
        if (allowed) {
          if (!gp.grantedPermissions.contains(perm)) {
            changedPermission=true;
            gp.grantedPermissions.add(perm);
            gp.gids=appendInts(gp.gids,bp.gids);
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str"");
        }
      }
 else {
        if (gp.grantedPermissions.remove(perm)) {
          changedPermission=true;
          gp.gids=removeInts(gp.gids,bp.gids);
          Slog.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ pkg.packageName);
    }
  }
  if ((changedPermission || replace) && !ps.permissionsFixed && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) || ((ps.pkgFlags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0)) {
    ps.permissionsFixed=true;
  }
}","private void grantPermissionsLP(PackageParser.Package pkg,boolean replace){
  final PackageSetting ps=(PackageSetting)pkg.mExtras;
  if (ps == null) {
    return;
  }
  final GrantedPermissions gp=ps.sharedUser != null ? ps.sharedUser : ps;
  boolean changedPermission=false;
  if (replace) {
    ps.permissionsFixed=false;
    if (gp == ps) {
      gp.grantedPermissions.clear();
      gp.gids=mGlobalGids;
    }
  }
  if (gp.gids == null) {
    gp.gids=mGlobalGids;
  }
  final int N=pkg.requestedPermissions.size();
  for (int i=0; i < N; i++) {
    String name=pkg.requestedPermissions.get(i);
    BasePermission bp=mSettings.mPermissions.get(name);
    if (false) {
      if (gp != ps) {
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ name+ ""String_Node_Str""+ bp);
      }
    }
    if (bp != null && bp.packageSetting != null) {
      final String perm=bp.name;
      boolean allowed;
      boolean allowedSig=false;
      if (bp.protectionLevel == PermissionInfo.PROTECTION_NORMAL || bp.protectionLevel == PermissionInfo.PROTECTION_DANGEROUS) {
        allowed=true;
      }
 else       if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE || bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
        allowed=(checkSignaturesLP(bp.packageSetting.signatures.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (checkSignaturesLP(mPlatformPackage.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH);
        if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
          if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) {
              PackageSetting sysPs=mSettings.getDisabledSystemPkg(pkg.packageName);
              if (sysPs.grantedPermissions.contains(perm)) {
                allowed=true;
              }
 else {
                allowed=false;
              }
            }
 else {
              allowed=true;
            }
          }
        }
        if (allowed) {
          allowedSig=true;
        }
      }
 else {
        allowed=false;
      }
      if (false) {
        if (gp != ps) {
          Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ perm);
        }
      }
      if (allowed) {
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0 && ps.permissionsFixed) {
          if (!allowedSig && !gp.grantedPermissions.contains(perm)) {
            allowed=false;
            final int NP=PackageParser.NEW_PERMISSIONS.length;
            for (int ip=0; ip < NP; ip++) {
              final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
              if (npi.name.equals(perm) && pkg.applicationInfo.targetSdkVersion < npi.sdkVersion) {
                allowed=true;
                Log.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName);
                break;
              }
            }
          }
        }
        if (allowed) {
          if (!gp.grantedPermissions.contains(perm)) {
            changedPermission=true;
            gp.grantedPermissions.add(perm);
            gp.gids=appendInts(gp.gids,bp.gids);
          }
 else           if (!ps.haveGids) {
            gp.gids=appendInts(gp.gids,bp.gids);
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str"");
        }
      }
 else {
        if (gp.grantedPermissions.remove(perm)) {
          changedPermission=true;
          gp.gids=removeInts(gp.gids,bp.gids);
          Slog.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ pkg.packageName);
    }
  }
  if ((changedPermission || replace) && !ps.permissionsFixed && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) || ((ps.pkgFlags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0)) {
    ps.permissionsFixed=true;
  }
  ps.haveGids=true;
}"
22703,"public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  timeStamp=base.timeStamp;
  timeStampString=base.timeStampString;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  disabledComponents=base.disabledComponents;
  enabledComponents=base.enabledComponents;
  enabled=base.enabled;
  installStatus=base.installStatus;
}","public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  timeStamp=base.timeStamp;
  timeStampString=base.timeStampString;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  haveGids=base.haveGids;
  disabledComponents=base.disabledComponents;
  enabledComponents=base.enabledComponents;
  enabled=base.enabled;
  installStatus=base.installStatus;
}"
22704,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  String packageName=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
    }
 else     if (""String_Node_Str"".equals(opt)) {
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || cmd.contains(""String_Node_Str"")) {
      packageName=cmd;
    }
  }
  boolean printedTitle=false;
synchronized (mPackages) {
    if (mActivities.dump(pw,""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mReceivers.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mServices.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mSettings.mPreferredActivities.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    boolean printedSomething=false;
{
      for (      BasePermission p : mSettings.mPermissions.values()) {
        if (packageName != null && !packageName.equals(p.sourcePackage)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(p.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(p)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(p.sourcePackage);
        pw.print(""String_Node_Str"");
        pw.print(p.uid);
        pw.print(""String_Node_Str"");
        pw.print(arrayToString(p.gids));
        pw.print(""String_Node_Str"");
        pw.print(p.type);
        pw.print(""String_Node_Str"");
        pw.println(p.protectionLevel);
        if (p.packageSetting != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.packageSetting);
        }
        if (p.perm != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.perm);
        }
      }
    }
    printedSomething=false;
    SharedUserSetting packageSharedUser=null;
{
      for (      PackageSetting ps : mSettings.mPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        packageSharedUser=ps.sharedUser;
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(ps.gids));
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
        if (ps.pkg != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.dataDir);
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.targetSdkVersion);
          pw.print(""String_Node_Str"");
          boolean first=true;
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
        }
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(ps.getTimeStampStr());
        pw.print(""String_Node_Str"");
        pw.println(ps.signatures);
        pw.print(""String_Node_Str"");
        pw.print(ps.permissionsFixed);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(ps.pkgFlags));
        pw.print(""String_Node_Str"");
        pw.print(ps.installStatus);
        pw.print(""String_Node_Str"");
        pw.println(ps.enabled);
        if (ps.disabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.disabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.enabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.enabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.grantedPermissions.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.grantedPermissions) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
      }
    }
    printedSomething=false;
    if (mSettings.mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mSettings.mRenamedPackages.entrySet()) {
        if (packageName != null && !packageName.equals(e.getKey()) && !packageName.equals(e.getValue())) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(e.getKey());
        pw.print(""String_Node_Str"");
        pw.println(e.getValue());
      }
    }
    printedSomething=false;
    if (mSettings.mDisabledSysPackages.size() > 0) {
      for (      PackageSetting ps : mSettings.mDisabledSysPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.println(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
      }
    }
    printedSomething=false;
{
      for (      SharedUserSetting su : mSettings.mSharedUsers.values()) {
        if (packageName != null && su != packageSharedUser) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(su.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(su)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.print(su.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(su.gids));
        pw.println(""String_Node_Str"");
        for (        String s : su.grantedPermissions) {
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
    }
    if (packageName == null) {
      if (printedTitle)       pw.println(""String_Node_Str"");
      printedTitle=true;
      pw.println(""String_Node_Str"");
      pw.println(mSettings.mReadMessages.toString());
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      File fname=getSettingsProblemFile();
      FileInputStream in;
      try {
        in=new FileInputStream(fname);
        int avail=in.available();
        byte[] data=new byte[avail];
        in.read(data);
        pw.println(new String(data));
      }
 catch (      FileNotFoundException e) {
      }
catch (      IOException e) {
      }
    }
  }
synchronized (mProviders) {
    boolean printedSomething=false;
    for (    PackageParser.Provider p : mProviders.values()) {
      if (packageName != null && !packageName.equals(p.info.packageName)) {
        continue;
      }
      if (!printedSomething) {
        if (printedTitle)         pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        printedSomething=true;
        printedTitle=true;
      }
      pw.print(""String_Node_Str"");
      pw.print(p.info.authority);
      pw.print(""String_Node_Str"");
      pw.println(p.toString());
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  String packageName=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
    }
 else     if (""String_Node_Str"".equals(opt)) {
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || cmd.contains(""String_Node_Str"")) {
      packageName=cmd;
    }
  }
  boolean printedTitle=false;
synchronized (mPackages) {
    if (mActivities.dump(pw,""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mReceivers.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mServices.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mSettings.mPreferredActivities.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    boolean printedSomething=false;
{
      for (      BasePermission p : mSettings.mPermissions.values()) {
        if (packageName != null && !packageName.equals(p.sourcePackage)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(p.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(p)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(p.sourcePackage);
        pw.print(""String_Node_Str"");
        pw.print(p.uid);
        pw.print(""String_Node_Str"");
        pw.print(arrayToString(p.gids));
        pw.print(""String_Node_Str"");
        pw.print(p.type);
        pw.print(""String_Node_Str"");
        pw.println(p.protectionLevel);
        if (p.packageSetting != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.packageSetting);
        }
        if (p.perm != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.perm);
        }
      }
    }
    printedSomething=false;
    SharedUserSetting packageSharedUser=null;
{
      for (      PackageSetting ps : mSettings.mPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        packageSharedUser=ps.sharedUser;
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(ps.gids));
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
        if (ps.pkg != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.dataDir);
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.targetSdkVersion);
          pw.print(""String_Node_Str"");
          boolean first=true;
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
        }
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(ps.getTimeStampStr());
        pw.print(""String_Node_Str"");
        pw.println(ps.signatures);
        pw.print(""String_Node_Str"");
        pw.print(ps.permissionsFixed);
        pw.print(""String_Node_Str"");
        pw.println(ps.haveGids);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(ps.pkgFlags));
        pw.print(""String_Node_Str"");
        pw.print(ps.installStatus);
        pw.print(""String_Node_Str"");
        pw.println(ps.enabled);
        if (ps.disabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.disabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.enabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.enabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.grantedPermissions.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.grantedPermissions) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
      }
    }
    printedSomething=false;
    if (mSettings.mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mSettings.mRenamedPackages.entrySet()) {
        if (packageName != null && !packageName.equals(e.getKey()) && !packageName.equals(e.getValue())) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(e.getKey());
        pw.print(""String_Node_Str"");
        pw.println(e.getValue());
      }
    }
    printedSomething=false;
    if (mSettings.mDisabledSysPackages.size() > 0) {
      for (      PackageSetting ps : mSettings.mDisabledSysPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.println(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
      }
    }
    printedSomething=false;
{
      for (      SharedUserSetting su : mSettings.mSharedUsers.values()) {
        if (packageName != null && su != packageSharedUser) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(su.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(su)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.print(su.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(su.gids));
        pw.println(""String_Node_Str"");
        for (        String s : su.grantedPermissions) {
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
    }
    if (packageName == null) {
      if (printedTitle)       pw.println(""String_Node_Str"");
      printedTitle=true;
      pw.println(""String_Node_Str"");
      pw.println(mSettings.mReadMessages.toString());
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      File fname=getSettingsProblemFile();
      FileInputStream in;
      try {
        in=new FileInputStream(fname);
        int avail=in.available();
        byte[] data=new byte[avail];
        in.read(data);
        pw.println(new String(data));
      }
 catch (      FileNotFoundException e) {
      }
catch (      IOException e) {
      }
    }
  }
synchronized (mProviders) {
    boolean printedSomething=false;
    for (    PackageParser.Provider p : mProviders.values()) {
      if (packageName != null && !packageName.equals(p.info.packageName)) {
        continue;
      }
      if (!printedSomething) {
        if (printedTitle)         pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        printedSomething=true;
        printedTitle=true;
      }
      pw.print(""String_Node_Str"");
      pw.print(p.info.authority);
      pw.print(""String_Node_Str"");
      pw.println(p.toString());
    }
  }
}"
22705,"void scaleAll(){
  for (  ChildView v : mChildren) {
    v.mView.setLayoutParams(computeLayout(v));
  }
}","void scaleAll(){
  for (  ChildView v : mChildren) {
    requestLayout(v);
  }
}"
22706,"void attachView(int x,int y,int width,int height){
  if (mView == null) {
    return;
  }
  setBounds(x,y,width,height);
  mWebView.mPrivateHandler.post(new Runnable(){
    public void run(){
      AbsoluteLayout.LayoutParams lp=computeLayout(ChildView.this);
      if (mView.getParent() != null) {
        mView.setLayoutParams(lp);
      }
 else {
        attachViewOnUIThread(lp);
      }
    }
  }
);
}","void attachView(int x,int y,int width,int height){
  if (mView == null) {
    return;
  }
  setBounds(x,y,width,height);
  mWebView.mPrivateHandler.post(new Runnable(){
    public void run(){
      requestLayout(ChildView.this);
      if (mView.getParent() == null) {
        attachViewOnUIThread();
      }
    }
  }
);
}"
22707,"private void attachViewOnUIThread(AbsoluteLayout.LayoutParams lp){
  mWebView.addView(mView,lp);
  mChildren.add(this);
  if (!mReadyToDraw) {
    mView.setVisibility(View.GONE);
  }
}","private void attachViewOnUIThread(){
  mWebView.addView(mView);
  mChildren.add(this);
  if (!mReadyToDraw) {
    mView.setVisibility(View.GONE);
  }
}"
22708,"public boolean onScaleBegin(ScaleGestureDetector detector){
  cancelTouch();
  dismissZoomControl();
  mInZoomOverview=false;
  if (inEditingMode() && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(false);
  }
  return true;
}","public boolean onScaleBegin(ScaleGestureDetector detector){
  cancelTouch();
  dismissZoomControl();
  mInZoomOverview=false;
  if (inEditingMode() && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(false);
  }
  mViewManager.startZoom();
  return true;
}"
22709,"public void onScaleEnd(ScaleGestureDetector detector){
  if (mPreviewZoomOnly) {
    mPreviewZoomOnly=false;
    mAnchorX=viewToContentX((int)mZoomCenterX + mScrollX);
    mAnchorY=viewToContentY((int)mZoomCenterY + mScrollY);
    boolean reflowNow=(mActualScale - mMinZoomScale <= MINIMUM_SCALE_INCREMENT) || ((mActualScale <= 0.8 * mTextWrapScale));
    setNewZoomScale(mActualScale,reflowNow,true);
    invalidate();
  }
  if (inEditingMode() && didUpdateTextViewBounds(false) && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(true);
  }
  mTouchMode=TOUCH_PINCH_DRAG;
  mConfirmMove=true;
  startTouch(detector.getFocusX(),detector.getFocusY(),mLastTouchTime);
}","public void onScaleEnd(ScaleGestureDetector detector){
  if (mPreviewZoomOnly) {
    mPreviewZoomOnly=false;
    mAnchorX=viewToContentX((int)mZoomCenterX + mScrollX);
    mAnchorY=viewToContentY((int)mZoomCenterY + mScrollY);
    boolean reflowNow=(mActualScale - mMinZoomScale <= MINIMUM_SCALE_INCREMENT) || ((mActualScale <= 0.8 * mTextWrapScale));
    setNewZoomScale(mActualScale,reflowNow,true);
    invalidate();
  }
  if (inEditingMode() && didUpdateTextViewBounds(false) && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(true);
  }
  mTouchMode=TOUCH_PINCH_DRAG;
  mConfirmMove=true;
  startTouch(detector.getFocusX(),detector.getFocusY(),mLastTouchTime);
  mViewManager.endZoom();
}"
22710,"/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
public void fling(int velocityY){
  if (getChildCount() > 0) {
    int height=getHeight() - mPaddingBottom - mPaddingTop;
    int bottom=getChildAt(0).getHeight();
    mScroller.fling(mScrollX,mScrollY,0,velocityY,0,0,0,Math.max(0,bottom - height),0,height / 2);
    final boolean movingDown=velocityY > 0;
    View newFocused=findFocusableViewInMyBounds(movingDown,mScroller.getFinalY(),findFocus());
    if (newFocused == null) {
      newFocused=this;
    }
    if (newFocused != findFocus() && newFocused.requestFocus(movingDown ? View.FOCUS_DOWN : View.FOCUS_UP)) {
      mScrollViewMovedFocus=true;
      mScrollViewMovedFocus=false;
    }
    awakenScrollBars(mScroller.getDuration());
    invalidate();
  }
}","/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
public void fling(int velocityY){
  if (getChildCount() > 0) {
    int height=getHeight() - mPaddingBottom - mPaddingTop;
    int bottom=getChildAt(0).getHeight();
    mScroller.fling(mScrollX,mScrollY,0,velocityY,0,0,0,Math.max(0,bottom - height),0,height / 2);
    final boolean movingDown=velocityY > 0;
    View newFocused=findFocusableViewInMyBounds(movingDown,mScroller.getFinalY(),findFocus());
    if (newFocused == null) {
      newFocused=this;
    }
    if (newFocused != findFocus() && newFocused.requestFocus(movingDown ? View.FOCUS_DOWN : View.FOCUS_UP)) {
      mScrollViewMovedFocus=true;
      mScrollViewMovedFocus=false;
    }
    invalidate();
  }
}"
22711,"@Override protected void onOverscrolled(int scrollX,int scrollY,boolean clampedX,boolean clampedY){
  if (!mScroller.isFinished()) {
    mScrollX=scrollX;
    mScrollY=scrollY;
    if (clampedY) {
      mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange());
    }
  }
 else {
    super.scrollTo(scrollX,scrollY);
  }
}","@Override protected void onOverscrolled(int scrollX,int scrollY,boolean clampedX,boolean clampedY){
  if (!mScroller.isFinished()) {
    mScrollX=scrollX;
    mScrollY=scrollY;
    if (clampedY) {
      mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange());
    }
  }
 else {
    super.scrollTo(scrollX,scrollY);
  }
  awakenScrollBars();
}"
22712,"void scaleAll(){
  for (  ChildView v : mChildren) {
    v.mView.setLayoutParams(computeLayout(v));
  }
}","void scaleAll(){
  for (  ChildView v : mChildren) {
    requestLayout(v);
  }
}"
22713,"void attachView(int x,int y,int width,int height){
  if (mView == null) {
    return;
  }
  setBounds(x,y,width,height);
  mWebView.mPrivateHandler.post(new Runnable(){
    public void run(){
      AbsoluteLayout.LayoutParams lp=computeLayout(ChildView.this);
      if (mView.getParent() != null) {
        mView.setLayoutParams(lp);
      }
 else {
        attachViewOnUIThread(lp);
      }
    }
  }
);
}","void attachView(int x,int y,int width,int height){
  if (mView == null) {
    return;
  }
  setBounds(x,y,width,height);
  mWebView.mPrivateHandler.post(new Runnable(){
    public void run(){
      requestLayout(ChildView.this);
      if (mView.getParent() == null) {
        attachViewOnUIThread();
      }
    }
  }
);
}"
22714,"private void attachViewOnUIThread(AbsoluteLayout.LayoutParams lp){
  mWebView.addView(mView,lp);
  mChildren.add(this);
  if (!mReadyToDraw) {
    mView.setVisibility(View.GONE);
  }
}","private void attachViewOnUIThread(){
  mWebView.addView(mView);
  mChildren.add(this);
  if (!mReadyToDraw) {
    mView.setVisibility(View.GONE);
  }
}"
22715,"public boolean onScaleBegin(ScaleGestureDetector detector){
  cancelTouch();
  dismissZoomControl();
  mInZoomOverview=false;
  if (inEditingMode() && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(false);
  }
  return true;
}","public boolean onScaleBegin(ScaleGestureDetector detector){
  cancelTouch();
  dismissZoomControl();
  mInZoomOverview=false;
  if (inEditingMode() && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(false);
  }
  mViewManager.startZoom();
  return true;
}"
22716,"public void onScaleEnd(ScaleGestureDetector detector){
  if (mPreviewZoomOnly) {
    mPreviewZoomOnly=false;
    mAnchorX=viewToContentX((int)mZoomCenterX + mScrollX);
    mAnchorY=viewToContentY((int)mZoomCenterY + mScrollY);
    boolean reflowNow=(mActualScale - mMinZoomScale <= MINIMUM_SCALE_INCREMENT) || ((mActualScale <= 0.8 * mTextWrapScale));
    setNewZoomScale(mActualScale,reflowNow,true);
    invalidate();
  }
  if (inEditingMode() && didUpdateTextViewBounds(false) && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(true);
  }
  mTouchMode=TOUCH_PINCH_DRAG;
  mConfirmMove=true;
  startTouch(detector.getFocusX(),detector.getFocusY(),mLastTouchTime);
}","public void onScaleEnd(ScaleGestureDetector detector){
  if (mPreviewZoomOnly) {
    mPreviewZoomOnly=false;
    mAnchorX=viewToContentX((int)mZoomCenterX + mScrollX);
    mAnchorY=viewToContentY((int)mZoomCenterY + mScrollY);
    boolean reflowNow=(mActualScale - mMinZoomScale <= MINIMUM_SCALE_INCREMENT) || ((mActualScale <= 0.8 * mTextWrapScale));
    setNewZoomScale(mActualScale,reflowNow,true);
    invalidate();
  }
  if (inEditingMode() && didUpdateTextViewBounds(false) && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(true);
  }
  mTouchMode=TOUCH_PINCH_DRAG;
  mConfirmMove=true;
  startTouch(detector.getFocusX(),detector.getFocusY(),mLastTouchTime);
  mViewManager.endZoom();
}"
22717,"boolean scrollToRectOrFocus(Rect rectangle,boolean immediate){
  final View.AttachInfo attachInfo=mAttachInfo;
  final Rect ci=attachInfo.mContentInsets;
  final Rect vi=attachInfo.mVisibleInsets;
  int scrollY=0;
  boolean handled=false;
  if (vi.left > ci.left || vi.top > ci.top || vi.right > ci.right || vi.bottom > ci.bottom) {
    scrollY=mScrollY;
    View focus=mRealFocusedView;
    if (focus == null || focus.mAttachInfo != mAttachInfo) {
      mRealFocusedView=null;
      return false;
    }
    if (focus != mLastScrolledFocus) {
      rectangle=null;
    }
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ rectangle+ ""String_Node_Str""+ ci+ ""String_Node_Str""+ vi);
    if (focus == mLastScrolledFocus && !mScrollMayChange && rectangle == null) {
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ vi.toShortString());
    }
 else     if (focus != null) {
      mLastScrolledFocus=focus;
      mScrollMayChange=false;
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"");
      if (focus.getGlobalVisibleRect(mVisRect,null)) {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.getWidth() + ""String_Node_Str""+ mView.getHeight()+ ""String_Node_Str""+ ci.toShortString()+ ""String_Node_Str""+ vi.toShortString());
        if (rectangle == null) {
          focus.getFocusedRect(mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ mTempRect.toShortString());
          ((ViewGroup)mView).offsetDescendantRectToMyCoords(focus,mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
 else {
          mTempRect.set(rectangle);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
        if (mTempRect.intersect(mVisRect)) {
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString());
          if (mTempRect.height() > (mView.getHeight() - vi.top - vi.bottom)) {
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.top - scrollY) < vi.top) {
            scrollY-=vi.top - (mTempRect.top - scrollY);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.bottom - scrollY) > (mView.getHeight() - vi.bottom)) {
            scrollY+=(mTempRect.bottom - scrollY) - (mView.getHeight() - vi.bottom);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
          handled=true;
        }
      }
    }
  }
  if (scrollY != mScrollY) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ scrollY);
    if (!immediate) {
      if (mScroller == null) {
        mScroller=new Scroller(mView.getContext());
      }
      mScroller.startScroll(0,mScrollY,0,scrollY - mScrollY);
    }
 else     if (mScroller != null) {
      mScroller.abortAnimation();
    }
    mScrollY=scrollY;
  }
  return handled;
}","boolean scrollToRectOrFocus(Rect rectangle,boolean immediate){
  final View.AttachInfo attachInfo=mAttachInfo;
  final Rect ci=attachInfo.mContentInsets;
  final Rect vi=attachInfo.mVisibleInsets;
  int scrollY=0;
  boolean handled=false;
  if (vi.left > ci.left || vi.top > ci.top || vi.right > ci.right || vi.bottom > ci.bottom) {
    scrollY=mScrollY;
    View focus=mRealFocusedView;
    if (focus == null || focus.mAttachInfo != mAttachInfo) {
      mRealFocusedView=null;
      return false;
    }
    if (focus != mLastScrolledFocus) {
      rectangle=null;
    }
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ rectangle+ ""String_Node_Str""+ ci+ ""String_Node_Str""+ vi);
    if (focus == mLastScrolledFocus && !mScrollMayChange && rectangle == null) {
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ vi.toShortString());
    }
 else     if (focus != null) {
      mLastScrolledFocus=focus;
      mScrollMayChange=false;
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"");
      if (focus.getGlobalVisibleRect(mVisRect,null)) {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.getWidth() + ""String_Node_Str""+ mView.getHeight()+ ""String_Node_Str""+ ci.toShortString()+ ""String_Node_Str""+ vi.toShortString());
        if (rectangle == null) {
          focus.getFocusedRect(mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ mTempRect.toShortString());
          if (mView instanceof ViewGroup) {
            ((ViewGroup)mView).offsetDescendantRectToMyCoords(focus,mTempRect);
          }
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
 else {
          mTempRect.set(rectangle);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
        if (mTempRect.intersect(mVisRect)) {
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString());
          if (mTempRect.height() > (mView.getHeight() - vi.top - vi.bottom)) {
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.top - scrollY) < vi.top) {
            scrollY-=vi.top - (mTempRect.top - scrollY);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.bottom - scrollY) > (mView.getHeight() - vi.bottom)) {
            scrollY+=(mTempRect.bottom - scrollY) - (mView.getHeight() - vi.bottom);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
          handled=true;
        }
      }
    }
  }
  if (scrollY != mScrollY) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ scrollY);
    if (!immediate) {
      if (mScroller == null) {
        mScroller=new Scroller(mView.getContext());
      }
      mScroller.startScroll(0,mScrollY,0,scrollY - mScrollY);
    }
 else     if (mScroller != null) {
      mScroller.abortAnimation();
    }
    mScrollY=scrollY;
  }
  return handled;
}"
22718,"private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
if (LOCAL_LOGV) Log.v(""String_Node_Str"",""String_Node_Str"");
try {
sWindowSession.finishKey(mWindow);
}
 catch (RemoteException e) {
}
}
}
}","private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
if (mView instanceof ViewGroup) {
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
}
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
if (LOCAL_LOGV) Log.v(""String_Node_Str"",""String_Node_Str"");
try {
sWindowSession.finishKey(mWindow);
}
 catch (RemoteException e) {
}
}
}
}"
22719,"boolean scrollToRectOrFocus(Rect rectangle,boolean immediate){
  final View.AttachInfo attachInfo=mAttachInfo;
  final Rect ci=attachInfo.mContentInsets;
  final Rect vi=attachInfo.mVisibleInsets;
  int scrollY=0;
  boolean handled=false;
  if (vi.left > ci.left || vi.top > ci.top || vi.right > ci.right || vi.bottom > ci.bottom) {
    scrollY=mScrollY;
    View focus=mRealFocusedView;
    if (focus == null || focus.mAttachInfo != mAttachInfo) {
      mRealFocusedView=null;
      return false;
    }
    if (focus != mLastScrolledFocus) {
      rectangle=null;
    }
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ rectangle+ ""String_Node_Str""+ ci+ ""String_Node_Str""+ vi);
    if (focus == mLastScrolledFocus && !mScrollMayChange && rectangle == null) {
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ vi.toShortString());
    }
 else     if (focus != null) {
      mLastScrolledFocus=focus;
      mScrollMayChange=false;
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"");
      if (focus.getGlobalVisibleRect(mVisRect,null)) {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.getWidth() + ""String_Node_Str""+ mView.getHeight()+ ""String_Node_Str""+ ci.toShortString()+ ""String_Node_Str""+ vi.toShortString());
        if (rectangle == null) {
          focus.getFocusedRect(mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ mTempRect.toShortString());
          ((ViewGroup)mView).offsetDescendantRectToMyCoords(focus,mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
 else {
          mTempRect.set(rectangle);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
        if (mTempRect.intersect(mVisRect)) {
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString());
          if (mTempRect.height() > (mView.getHeight() - vi.top - vi.bottom)) {
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.top - scrollY) < vi.top) {
            scrollY-=vi.top - (mTempRect.top - scrollY);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.bottom - scrollY) > (mView.getHeight() - vi.bottom)) {
            scrollY+=(mTempRect.bottom - scrollY) - (mView.getHeight() - vi.bottom);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
          handled=true;
        }
      }
    }
  }
  if (scrollY != mScrollY) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ scrollY);
    if (!immediate) {
      if (mScroller == null) {
        mScroller=new Scroller(mView.getContext());
      }
      mScroller.startScroll(0,mScrollY,0,scrollY - mScrollY);
    }
 else     if (mScroller != null) {
      mScroller.abortAnimation();
    }
    mScrollY=scrollY;
  }
  return handled;
}","boolean scrollToRectOrFocus(Rect rectangle,boolean immediate){
  final View.AttachInfo attachInfo=mAttachInfo;
  final Rect ci=attachInfo.mContentInsets;
  final Rect vi=attachInfo.mVisibleInsets;
  int scrollY=0;
  boolean handled=false;
  if (vi.left > ci.left || vi.top > ci.top || vi.right > ci.right || vi.bottom > ci.bottom) {
    scrollY=mScrollY;
    View focus=mRealFocusedView;
    if (focus == null || focus.mAttachInfo != mAttachInfo) {
      mRealFocusedView=null;
      return false;
    }
    if (focus != mLastScrolledFocus) {
      rectangle=null;
    }
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ rectangle+ ""String_Node_Str""+ ci+ ""String_Node_Str""+ vi);
    if (focus == mLastScrolledFocus && !mScrollMayChange && rectangle == null) {
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ vi.toShortString());
    }
 else     if (focus != null) {
      mLastScrolledFocus=focus;
      mScrollMayChange=false;
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"");
      if (focus.getGlobalVisibleRect(mVisRect,null)) {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.getWidth() + ""String_Node_Str""+ mView.getHeight()+ ""String_Node_Str""+ ci.toShortString()+ ""String_Node_Str""+ vi.toShortString());
        if (rectangle == null) {
          focus.getFocusedRect(mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ mTempRect.toShortString());
          if (mView instanceof ViewGroup) {
            ((ViewGroup)mView).offsetDescendantRectToMyCoords(focus,mTempRect);
          }
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
 else {
          mTempRect.set(rectangle);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
        if (mTempRect.intersect(mVisRect)) {
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString());
          if (mTempRect.height() > (mView.getHeight() - vi.top - vi.bottom)) {
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.top - scrollY) < vi.top) {
            scrollY-=vi.top - (mTempRect.top - scrollY);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.bottom - scrollY) > (mView.getHeight() - vi.bottom)) {
            scrollY+=(mTempRect.bottom - scrollY) - (mView.getHeight() - vi.bottom);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
          handled=true;
        }
      }
    }
  }
  if (scrollY != mScrollY) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ scrollY);
    if (!immediate) {
      if (mScroller == null) {
        mScroller=new Scroller(mView.getContext());
      }
      mScroller.startScroll(0,mScrollY,0,scrollY - mScrollY);
    }
 else     if (mScroller != null) {
      mScroller.abortAnimation();
    }
    mScrollY=scrollY;
  }
  return handled;
}"
22720,"private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
if (LOCAL_LOGV) Log.v(""String_Node_Str"",""String_Node_Str"");
try {
sWindowSession.finishKey(mWindow);
}
 catch (RemoteException e) {
}
}
}
}","private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
if (mView instanceof ViewGroup) {
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
}
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
if (LOCAL_LOGV) Log.v(""String_Node_Str"",""String_Node_Str"");
try {
sWindowSession.finishKey(mWindow);
}
 catch (RemoteException e) {
}
}
}
}"
22721,"/** 
 * <p>Builds the popup window's content and returns the height the popup should have. Returns -1 when the content already exists.</p>
 * @return the content's height or -1 if content already exists
 */
private int buildDropDown(){
  ViewGroup dropDownView;
  int otherHeights=0;
  final ListAdapter adapter=mAdapter;
  if (adapter != null) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null) {
      final int count=Math.min(adapter.getCount(),20);
      CompletionInfo[] completions=new CompletionInfo[count];
      int realCount=0;
      for (int i=0; i < count; i++) {
        if (adapter.isEnabled(i)) {
          realCount++;
          Object item=adapter.getItem(i);
          long id=adapter.getItemId(i);
          completions[i]=new CompletionInfo(id,i,convertSelectionToString(item));
        }
      }
      if (realCount != count) {
        CompletionInfo[] tmp=new CompletionInfo[realCount];
        System.arraycopy(completions,0,tmp,0,realCount);
        completions=tmp;
      }
      imm.displayCompletions(this,completions);
    }
  }
  if (mDropDownList == null) {
    Context context=getContext();
    mHideSelector=new ListSelectorHider();
    mShowDropDownRunnable=new Runnable(){
      public void run(){
        View view=getDropDownAnchorView();
        if (view != null && view.getWindowToken() != null) {
          showDropDown();
        }
      }
    }
;
    mDropDownList=new DropDownListView(context);
    mDropDownList.setSelector(mDropDownListHighlight);
    mDropDownList.setAdapter(adapter);
    mDropDownList.setVerticalFadingEdgeEnabled(true);
    mDropDownList.setOnItemClickListener(mDropDownItemClickListener);
    mDropDownList.setFocusable(true);
    mDropDownList.setFocusableInTouchMode(true);
    mDropDownList.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
      public void onItemSelected(      AdapterView<?> parent,      View view,      int position,      long id){
        if (position != -1) {
          DropDownListView dropDownList=mDropDownList;
          if (dropDownList != null) {
            dropDownList.mListSelectionHidden=false;
          }
        }
      }
      public void onNothingSelected(      AdapterView<?> parent){
      }
    }
);
    if (mItemSelectedListener != null) {
      mDropDownList.setOnItemSelectedListener(mItemSelectedListener);
    }
    dropDownView=mDropDownList;
    View hintView=getHintView(context);
    if (hintView != null) {
      LinearLayout hintContainer=new LinearLayout(context);
      hintContainer.setOrientation(LinearLayout.VERTICAL);
      LinearLayout.LayoutParams hintParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,0,1.0f);
      hintContainer.addView(dropDownView,hintParams);
      hintContainer.addView(hintView);
      int widthSpec=MeasureSpec.makeMeasureSpec(getWidth(),MeasureSpec.AT_MOST);
      int heightSpec=MeasureSpec.UNSPECIFIED;
      hintView.measure(widthSpec,heightSpec);
      hintParams=(LinearLayout.LayoutParams)hintView.getLayoutParams();
      otherHeights=hintView.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
      dropDownView=hintContainer;
    }
    mPopup.setContentView(dropDownView);
  }
 else {
    dropDownView=(ViewGroup)mPopup.getContentView();
    final View view=dropDownView.findViewById(HINT_VIEW_ID);
    if (view != null) {
      LinearLayout.LayoutParams hintParams=(LinearLayout.LayoutParams)view.getLayoutParams();
      otherHeights=view.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
    }
  }
  boolean ignoreBottomDecorations=mPopup.getInputMethodMode() == PopupWindow.INPUT_METHOD_NOT_NEEDED;
  final int maxHeight=mPopup.getMaxAvailableHeight(getDropDownAnchorView(),mDropDownVerticalOffset,ignoreBottomDecorations);
  int padding=0;
  Drawable background=mPopup.getBackground();
  if (background != null) {
    background.getPadding(mTempRect);
    padding=mTempRect.top + mTempRect.bottom;
  }
  if (mDropDownAlwaysVisible || mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
    return maxHeight + padding;
  }
  final int listContent=mDropDownList.measureHeightOfChildren(MeasureSpec.UNSPECIFIED,0,ListView.NO_POSITION,maxHeight - otherHeights,2);
  if (listContent > 0)   otherHeights+=padding;
  return listContent + otherHeights;
}","/** 
 * <p>Builds the popup window's content and returns the height the popup should have. Returns -1 when the content already exists.</p>
 * @return the content's height or -1 if content already exists
 */
private int buildDropDown(){
  ViewGroup dropDownView;
  int otherHeights=0;
  final ListAdapter adapter=mAdapter;
  if (adapter != null) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null) {
      final int count=Math.min(adapter.getCount(),20);
      CompletionInfo[] completions=new CompletionInfo[count];
      int realCount=0;
      for (int i=0; i < count; i++) {
        if (adapter.isEnabled(i)) {
          realCount++;
          Object item=adapter.getItem(i);
          long id=adapter.getItemId(i);
          completions[i]=new CompletionInfo(id,i,convertSelectionToString(item));
        }
      }
      if (realCount != count) {
        CompletionInfo[] tmp=new CompletionInfo[realCount];
        System.arraycopy(completions,0,tmp,0,realCount);
        completions=tmp;
      }
      imm.displayCompletions(this,completions);
    }
  }
  if (mDropDownList == null) {
    Context context=getContext();
    mHideSelector=new ListSelectorHider();
    mShowDropDownRunnable=new Runnable(){
      public void run(){
        View view=getDropDownAnchorView();
        if (view != null && view.getWindowToken() != null) {
          showDropDown();
        }
      }
    }
;
    mDropDownList=new DropDownListView(context);
    mDropDownList.setSelector(mDropDownListHighlight);
    mDropDownList.setAdapter(adapter);
    mDropDownList.setVerticalFadingEdgeEnabled(true);
    mDropDownList.setOnItemClickListener(mDropDownItemClickListener);
    mDropDownList.setFocusable(true);
    mDropDownList.setFocusableInTouchMode(true);
    mDropDownList.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
      public void onItemSelected(      AdapterView<?> parent,      View view,      int position,      long id){
        if (position != -1) {
          DropDownListView dropDownList=mDropDownList;
          if (dropDownList != null) {
            dropDownList.mListSelectionHidden=false;
          }
        }
      }
      public void onNothingSelected(      AdapterView<?> parent){
      }
    }
);
    mDropDownList.setOnScrollListener(new PopupScrollListener());
    if (mItemSelectedListener != null) {
      mDropDownList.setOnItemSelectedListener(mItemSelectedListener);
    }
    dropDownView=mDropDownList;
    View hintView=getHintView(context);
    if (hintView != null) {
      LinearLayout hintContainer=new LinearLayout(context);
      hintContainer.setOrientation(LinearLayout.VERTICAL);
      LinearLayout.LayoutParams hintParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,0,1.0f);
      hintContainer.addView(dropDownView,hintParams);
      hintContainer.addView(hintView);
      int widthSpec=MeasureSpec.makeMeasureSpec(getWidth(),MeasureSpec.AT_MOST);
      int heightSpec=MeasureSpec.UNSPECIFIED;
      hintView.measure(widthSpec,heightSpec);
      hintParams=(LinearLayout.LayoutParams)hintView.getLayoutParams();
      otherHeights=hintView.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
      dropDownView=hintContainer;
    }
    mPopup.setContentView(dropDownView);
  }
 else {
    dropDownView=(ViewGroup)mPopup.getContentView();
    final View view=dropDownView.findViewById(HINT_VIEW_ID);
    if (view != null) {
      LinearLayout.LayoutParams hintParams=(LinearLayout.LayoutParams)view.getLayoutParams();
      otherHeights=view.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
    }
  }
  boolean ignoreBottomDecorations=mPopup.getInputMethodMode() == PopupWindow.INPUT_METHOD_NOT_NEEDED;
  final int maxHeight=mPopup.getMaxAvailableHeight(getDropDownAnchorView(),mDropDownVerticalOffset,ignoreBottomDecorations);
  int padding=0;
  Drawable background=mPopup.getBackground();
  if (background != null) {
    background.getPadding(mTempRect);
    padding=mTempRect.top + mTempRect.bottom;
  }
  if (mDropDownAlwaysVisible || mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
    return maxHeight + padding;
  }
  final int listContent=mDropDownList.measureHeightOfChildren(MeasureSpec.UNSPECIFIED,0,ListView.NO_POSITION,maxHeight - otherHeights,2);
  if (listContent > 0)   otherHeights+=padding;
  return listContent + otherHeights;
}"
22722,"public boolean onTouch(View v,MotionEvent event){
  if (event.getAction() == MotionEvent.ACTION_DOWN && mPopup != null && mPopup.isShowing()) {
    mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
    showDropDown();
  }
  return false;
}","public boolean onTouch(View v,MotionEvent event){
  final int action=event.getAction();
  if (action == MotionEvent.ACTION_DOWN && mPopup != null && mPopup.isShowing()) {
    postDelayed(mResizePopupRunnable,EXPAND_LIST_TIMEOUT);
  }
 else   if (action == MotionEvent.ACTION_UP) {
    removeCallbacks(mResizePopupRunnable);
  }
  return false;
}"
22723,"/** 
 * <p>Builds the popup window's content and returns the height the popup should have. Returns -1 when the content already exists.</p>
 * @return the content's height or -1 if content already exists
 */
private int buildDropDown(){
  ViewGroup dropDownView;
  int otherHeights=0;
  final ListAdapter adapter=mAdapter;
  if (adapter != null) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null) {
      final int count=Math.min(adapter.getCount(),20);
      CompletionInfo[] completions=new CompletionInfo[count];
      int realCount=0;
      for (int i=0; i < count; i++) {
        if (adapter.isEnabled(i)) {
          realCount++;
          Object item=adapter.getItem(i);
          long id=adapter.getItemId(i);
          completions[i]=new CompletionInfo(id,i,convertSelectionToString(item));
        }
      }
      if (realCount != count) {
        CompletionInfo[] tmp=new CompletionInfo[realCount];
        System.arraycopy(completions,0,tmp,0,realCount);
        completions=tmp;
      }
      imm.displayCompletions(this,completions);
    }
  }
  if (mDropDownList == null) {
    Context context=getContext();
    mHideSelector=new ListSelectorHider();
    mShowDropDownRunnable=new Runnable(){
      public void run(){
        View view=getDropDownAnchorView();
        if (view != null && view.getWindowToken() != null) {
          showDropDown();
        }
      }
    }
;
    mDropDownList=new DropDownListView(context);
    mDropDownList.setSelector(mDropDownListHighlight);
    mDropDownList.setAdapter(adapter);
    mDropDownList.setVerticalFadingEdgeEnabled(true);
    mDropDownList.setOnItemClickListener(mDropDownItemClickListener);
    mDropDownList.setFocusable(true);
    mDropDownList.setFocusableInTouchMode(true);
    mDropDownList.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
      public void onItemSelected(      AdapterView<?> parent,      View view,      int position,      long id){
        if (position != -1) {
          DropDownListView dropDownList=mDropDownList;
          if (dropDownList != null) {
            dropDownList.mListSelectionHidden=false;
          }
        }
      }
      public void onNothingSelected(      AdapterView<?> parent){
      }
    }
);
    if (mItemSelectedListener != null) {
      mDropDownList.setOnItemSelectedListener(mItemSelectedListener);
    }
    dropDownView=mDropDownList;
    View hintView=getHintView(context);
    if (hintView != null) {
      LinearLayout hintContainer=new LinearLayout(context);
      hintContainer.setOrientation(LinearLayout.VERTICAL);
      LinearLayout.LayoutParams hintParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,0,1.0f);
      hintContainer.addView(dropDownView,hintParams);
      hintContainer.addView(hintView);
      int widthSpec=MeasureSpec.makeMeasureSpec(getWidth(),MeasureSpec.AT_MOST);
      int heightSpec=MeasureSpec.UNSPECIFIED;
      hintView.measure(widthSpec,heightSpec);
      hintParams=(LinearLayout.LayoutParams)hintView.getLayoutParams();
      otherHeights=hintView.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
      dropDownView=hintContainer;
    }
    mPopup.setContentView(dropDownView);
  }
 else {
    dropDownView=(ViewGroup)mPopup.getContentView();
    final View view=dropDownView.findViewById(HINT_VIEW_ID);
    if (view != null) {
      LinearLayout.LayoutParams hintParams=(LinearLayout.LayoutParams)view.getLayoutParams();
      otherHeights=view.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
    }
  }
  boolean ignoreBottomDecorations=mPopup.getInputMethodMode() == PopupWindow.INPUT_METHOD_NOT_NEEDED;
  final int maxHeight=mPopup.getMaxAvailableHeight(getDropDownAnchorView(),mDropDownVerticalOffset,ignoreBottomDecorations);
  int padding=0;
  Drawable background=mPopup.getBackground();
  if (background != null) {
    background.getPadding(mTempRect);
    padding=mTempRect.top + mTempRect.bottom;
  }
  if (mDropDownAlwaysVisible || mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
    return maxHeight + padding;
  }
  final int listContent=mDropDownList.measureHeightOfChildren(MeasureSpec.UNSPECIFIED,0,ListView.NO_POSITION,maxHeight - otherHeights,2);
  if (listContent > 0)   otherHeights+=padding;
  return listContent + otherHeights;
}","/** 
 * <p>Builds the popup window's content and returns the height the popup should have. Returns -1 when the content already exists.</p>
 * @return the content's height or -1 if content already exists
 */
private int buildDropDown(){
  ViewGroup dropDownView;
  int otherHeights=0;
  final ListAdapter adapter=mAdapter;
  if (adapter != null) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null) {
      final int count=Math.min(adapter.getCount(),20);
      CompletionInfo[] completions=new CompletionInfo[count];
      int realCount=0;
      for (int i=0; i < count; i++) {
        if (adapter.isEnabled(i)) {
          realCount++;
          Object item=adapter.getItem(i);
          long id=adapter.getItemId(i);
          completions[i]=new CompletionInfo(id,i,convertSelectionToString(item));
        }
      }
      if (realCount != count) {
        CompletionInfo[] tmp=new CompletionInfo[realCount];
        System.arraycopy(completions,0,tmp,0,realCount);
        completions=tmp;
      }
      imm.displayCompletions(this,completions);
    }
  }
  if (mDropDownList == null) {
    Context context=getContext();
    mHideSelector=new ListSelectorHider();
    mShowDropDownRunnable=new Runnable(){
      public void run(){
        View view=getDropDownAnchorView();
        if (view != null && view.getWindowToken() != null) {
          showDropDown();
        }
      }
    }
;
    mDropDownList=new DropDownListView(context);
    mDropDownList.setSelector(mDropDownListHighlight);
    mDropDownList.setAdapter(adapter);
    mDropDownList.setVerticalFadingEdgeEnabled(true);
    mDropDownList.setOnItemClickListener(mDropDownItemClickListener);
    mDropDownList.setFocusable(true);
    mDropDownList.setFocusableInTouchMode(true);
    mDropDownList.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
      public void onItemSelected(      AdapterView<?> parent,      View view,      int position,      long id){
        if (position != -1) {
          DropDownListView dropDownList=mDropDownList;
          if (dropDownList != null) {
            dropDownList.mListSelectionHidden=false;
          }
        }
      }
      public void onNothingSelected(      AdapterView<?> parent){
      }
    }
);
    mDropDownList.setOnScrollListener(new PopupScrollListener());
    if (mItemSelectedListener != null) {
      mDropDownList.setOnItemSelectedListener(mItemSelectedListener);
    }
    dropDownView=mDropDownList;
    View hintView=getHintView(context);
    if (hintView != null) {
      LinearLayout hintContainer=new LinearLayout(context);
      hintContainer.setOrientation(LinearLayout.VERTICAL);
      LinearLayout.LayoutParams hintParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,0,1.0f);
      hintContainer.addView(dropDownView,hintParams);
      hintContainer.addView(hintView);
      int widthSpec=MeasureSpec.makeMeasureSpec(getWidth(),MeasureSpec.AT_MOST);
      int heightSpec=MeasureSpec.UNSPECIFIED;
      hintView.measure(widthSpec,heightSpec);
      hintParams=(LinearLayout.LayoutParams)hintView.getLayoutParams();
      otherHeights=hintView.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
      dropDownView=hintContainer;
    }
    mPopup.setContentView(dropDownView);
  }
 else {
    dropDownView=(ViewGroup)mPopup.getContentView();
    final View view=dropDownView.findViewById(HINT_VIEW_ID);
    if (view != null) {
      LinearLayout.LayoutParams hintParams=(LinearLayout.LayoutParams)view.getLayoutParams();
      otherHeights=view.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
    }
  }
  boolean ignoreBottomDecorations=mPopup.getInputMethodMode() == PopupWindow.INPUT_METHOD_NOT_NEEDED;
  final int maxHeight=mPopup.getMaxAvailableHeight(getDropDownAnchorView(),mDropDownVerticalOffset,ignoreBottomDecorations);
  int padding=0;
  Drawable background=mPopup.getBackground();
  if (background != null) {
    background.getPadding(mTempRect);
    padding=mTempRect.top + mTempRect.bottom;
  }
  if (mDropDownAlwaysVisible || mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
    return maxHeight + padding;
  }
  final int listContent=mDropDownList.measureHeightOfChildren(MeasureSpec.UNSPECIFIED,0,ListView.NO_POSITION,maxHeight - otherHeights,2);
  if (listContent > 0)   otherHeights+=padding;
  return listContent + otherHeights;
}"
22724,"public boolean onTouch(View v,MotionEvent event){
  if (event.getAction() == MotionEvent.ACTION_DOWN && mPopup != null && mPopup.isShowing()) {
    mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
    showDropDown();
  }
  return false;
}","public boolean onTouch(View v,MotionEvent event){
  final int action=event.getAction();
  if (action == MotionEvent.ACTION_DOWN && mPopup != null && mPopup.isShowing()) {
    postDelayed(mResizePopupRunnable,EXPAND_LIST_TIMEOUT);
  }
 else   if (action == MotionEvent.ACTION_UP) {
    removeCallbacks(mResizePopupRunnable);
  }
  return false;
}"
22725,"/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
public void fling(int velocityY){
  if (getChildCount() > 0) {
    int height=getHeight() - mPaddingBottom - mPaddingTop;
    int bottom=getChildAt(0).getHeight();
    mScroller.fling(mScrollX,mScrollY,0,velocityY,0,0,0,Math.max(0,bottom - height),0,height / 2);
    final boolean movingDown=velocityY > 0;
    View newFocused=findFocusableViewInMyBounds(movingDown,mScroller.getFinalY(),findFocus());
    if (newFocused == null) {
      newFocused=this;
    }
    if (newFocused != findFocus() && newFocused.requestFocus(movingDown ? View.FOCUS_DOWN : View.FOCUS_UP)) {
      mScrollViewMovedFocus=true;
      mScrollViewMovedFocus=false;
    }
    awakenScrollBars(mScroller.getDuration());
    invalidate();
  }
}","/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
public void fling(int velocityY){
  if (getChildCount() > 0) {
    int height=getHeight() - mPaddingBottom - mPaddingTop;
    int bottom=getChildAt(0).getHeight();
    mScroller.fling(mScrollX,mScrollY,0,velocityY,0,0,0,Math.max(0,bottom - height),0,height / 2);
    final boolean movingDown=velocityY > 0;
    View newFocused=findFocusableViewInMyBounds(movingDown,mScroller.getFinalY(),findFocus());
    if (newFocused == null) {
      newFocused=this;
    }
    if (newFocused != findFocus() && newFocused.requestFocus(movingDown ? View.FOCUS_DOWN : View.FOCUS_UP)) {
      mScrollViewMovedFocus=true;
      mScrollViewMovedFocus=false;
    }
    invalidate();
  }
}"
22726,"@Override protected void onOverscrolled(int scrollX,int scrollY,boolean clampedX,boolean clampedY){
  if (!mScroller.isFinished()) {
    mScrollX=scrollX;
    mScrollY=scrollY;
    if (clampedY) {
      mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange());
    }
  }
 else {
    super.scrollTo(scrollX,scrollY);
  }
}","@Override protected void onOverscrolled(int scrollX,int scrollY,boolean clampedX,boolean clampedY){
  if (!mScroller.isFinished()) {
    mScrollX=scrollX;
    mScrollY=scrollY;
    if (clampedY) {
      mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange());
    }
  }
 else {
    super.scrollTo(scrollX,scrollY);
  }
  awakenScrollBars();
}"
22727,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0 && (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0)) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
 else {
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    streamState.setLastAudibleIndex(index);
    sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      if (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0) {
        sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
      }
 else {
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
      }
    }
  }
}"
22728,"public void mute(boolean state){
synchronized (mDeathHandlers) {
    if (state) {
      if (mMuteCount == 0) {
        try {
          mICallback.linkToDeath(this,0);
          mDeathHandlers.add(this);
          if (muteCount() == 0) {
            setIndex(0,false);
            sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
          }
        }
 catch (        RemoteException e) {
          binderDied();
          mDeathHandlers.notify();
          return;
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"" + mStreamType + ""String_Node_Str"");
      }
      mMuteCount++;
    }
 else {
      if (mMuteCount == 0) {
        Log.e(TAG,""String_Node_Str"" + mStreamType);
      }
 else {
        mMuteCount--;
        if (mMuteCount == 0) {
          mDeathHandlers.remove(this);
          mICallback.unlinkToDeath(this,0);
          if (muteCount() == 0) {
            if (!isStreamAffectedByRingerMode(mStreamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
              setIndex(mLastAudibleIndex,false);
              sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
            }
          }
        }
      }
    }
    mDeathHandlers.notify();
  }
}","public void mute(boolean state){
synchronized (mDeathHandlers) {
    if (state) {
      if (mMuteCount == 0) {
        try {
          if (mICallback != null) {
            mICallback.linkToDeath(this,0);
          }
          mDeathHandlers.add(this);
          if (muteCount() == 0) {
            setIndex(0,false);
            sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
          }
        }
 catch (        RemoteException e) {
          binderDied();
          mDeathHandlers.notify();
          return;
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"" + mStreamType + ""String_Node_Str"");
      }
      mMuteCount++;
    }
 else {
      if (mMuteCount == 0) {
        Log.e(TAG,""String_Node_Str"" + mStreamType);
      }
 else {
        mMuteCount--;
        if (mMuteCount == 0) {
          mDeathHandlers.remove(this);
          if (mICallback != null) {
            mICallback.unlinkToDeath(this,0);
          }
          if (muteCount() == 0) {
            if (!isStreamAffectedByRingerMode(mStreamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
              setIndex(mLastAudibleIndex,false);
              sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
            }
          }
        }
      }
    }
    mDeathHandlers.notify();
  }
}"
22729,"/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  if (adjustVolume && streamState.adjustIndex(direction)) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,streamState.mIndex);
}","/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=(streamState.muteCount() != 0) ? streamState.mLastAudibleIndex : streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  int index;
  if (streamState.muteCount() != 0) {
    if (adjustVolume) {
      streamState.adjustLastAudibleIndex(direction);
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
    index=streamState.mLastAudibleIndex;
  }
 else {
    if (adjustVolume && streamState.adjustIndex(direction)) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
    index=streamState.mIndex;
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}"
22730,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        checkForUndispatchedAudioFocusChange(mMode,mode);
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        checkForUndispatchedAudioFocusChange(mMode,mode);
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,false);
  }
}"
22731,"private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}","private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
    if (isStreamMutedByRingerMode(streamType)) {
      if (!isStreamAffectedByRingerMode(streamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
        mStreamStates[streamType].mute(null,false);
        mRingerModeMutedStreams&=~(1 << streamType);
      }
    }
 else {
      if (isStreamAffectedByRingerMode(streamType) && mRingerMode != AudioManager.RINGER_MODE_NORMAL) {
        mStreamStates[streamType].mute(null,true);
        mRingerModeMutedStreams|=(1 << streamType);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}"
22732,"private VolumeDeathHandler getDeathHandler(IBinder cb,boolean state){
synchronized (mDeathHandlers) {
    VolumeDeathHandler handler;
    int size=mDeathHandlers.size();
    for (int i=0; i < size; i++) {
      handler=mDeathHandlers.get(i);
      if (cb.equals(handler.mICallback)) {
        return handler;
      }
    }
    if (state) {
      handler=new VolumeDeathHandler(cb);
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      handler=null;
    }
    return handler;
  }
}","private VolumeDeathHandler getDeathHandler(IBinder cb,boolean state){
synchronized (mDeathHandlers) {
    VolumeDeathHandler handler;
    int size=mDeathHandlers.size();
    for (int i=0; i < size; i++) {
      handler=mDeathHandlers.get(i);
      if (cb == handler.mICallback) {
        return handler;
      }
    }
    if (state) {
      handler=new VolumeDeathHandler(cb);
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      handler=null;
    }
    return handler;
  }
}"
22733,"/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  final int oldIndex=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}","/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=(streamState.muteCount() != 0) ? streamState.mLastAudibleIndex : streamState.mIndex;
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  index=(streamState.muteCount() != 0) ? streamState.mLastAudibleIndex : streamState.mIndex;
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}"
22734,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0 && (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0)) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
 else {
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    streamState.setLastAudibleIndex(index);
    sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      if (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0) {
        sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
      }
 else {
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
      }
    }
  }
}"
22735,"public void mute(boolean state){
synchronized (mDeathHandlers) {
    if (state) {
      if (mMuteCount == 0) {
        try {
          mICallback.linkToDeath(this,0);
          mDeathHandlers.add(this);
          if (muteCount() == 0) {
            setIndex(0,false);
            sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
          }
        }
 catch (        RemoteException e) {
          binderDied();
          mDeathHandlers.notify();
          return;
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"" + mStreamType + ""String_Node_Str"");
      }
      mMuteCount++;
    }
 else {
      if (mMuteCount == 0) {
        Log.e(TAG,""String_Node_Str"" + mStreamType);
      }
 else {
        mMuteCount--;
        if (mMuteCount == 0) {
          mDeathHandlers.remove(this);
          mICallback.unlinkToDeath(this,0);
          if (muteCount() == 0) {
            if (!isStreamAffectedByRingerMode(mStreamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
              setIndex(mLastAudibleIndex,false);
              sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
            }
          }
        }
      }
    }
    mDeathHandlers.notify();
  }
}","public void mute(boolean state){
synchronized (mDeathHandlers) {
    if (state) {
      if (mMuteCount == 0) {
        try {
          if (mICallback != null) {
            mICallback.linkToDeath(this,0);
          }
          mDeathHandlers.add(this);
          if (muteCount() == 0) {
            setIndex(0,false);
            sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
          }
        }
 catch (        RemoteException e) {
          binderDied();
          mDeathHandlers.notify();
          return;
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"" + mStreamType + ""String_Node_Str"");
      }
      mMuteCount++;
    }
 else {
      if (mMuteCount == 0) {
        Log.e(TAG,""String_Node_Str"" + mStreamType);
      }
 else {
        mMuteCount--;
        if (mMuteCount == 0) {
          mDeathHandlers.remove(this);
          if (mICallback != null) {
            mICallback.unlinkToDeath(this,0);
          }
          if (muteCount() == 0) {
            if (!isStreamAffectedByRingerMode(mStreamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
              setIndex(mLastAudibleIndex,false);
              sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
            }
          }
        }
      }
    }
    mDeathHandlers.notify();
  }
}"
22736,"/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  if (adjustVolume && streamState.adjustIndex(direction)) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,streamState.mIndex);
}","/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=(streamState.muteCount() != 0) ? streamState.mLastAudibleIndex : streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  int index;
  if (streamState.muteCount() != 0) {
    if (adjustVolume) {
      streamState.adjustLastAudibleIndex(direction);
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
    index=streamState.mLastAudibleIndex;
  }
 else {
    if (adjustVolume && streamState.adjustIndex(direction)) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
    index=streamState.mIndex;
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}"
22737,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        checkForUndispatchedAudioFocusChange(mMode,mode);
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        checkForUndispatchedAudioFocusChange(mMode,mode);
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,false);
  }
}"
22738,"private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}","private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
    if (isStreamMutedByRingerMode(streamType)) {
      if (!isStreamAffectedByRingerMode(streamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
        mStreamStates[streamType].mute(null,false);
        mRingerModeMutedStreams&=~(1 << streamType);
      }
    }
 else {
      if (isStreamAffectedByRingerMode(streamType) && mRingerMode != AudioManager.RINGER_MODE_NORMAL) {
        mStreamStates[streamType].mute(null,true);
        mRingerModeMutedStreams|=(1 << streamType);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}"
22739,"private VolumeDeathHandler getDeathHandler(IBinder cb,boolean state){
synchronized (mDeathHandlers) {
    VolumeDeathHandler handler;
    int size=mDeathHandlers.size();
    for (int i=0; i < size; i++) {
      handler=mDeathHandlers.get(i);
      if (cb.equals(handler.mICallback)) {
        return handler;
      }
    }
    if (state) {
      handler=new VolumeDeathHandler(cb);
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      handler=null;
    }
    return handler;
  }
}","private VolumeDeathHandler getDeathHandler(IBinder cb,boolean state){
synchronized (mDeathHandlers) {
    VolumeDeathHandler handler;
    int size=mDeathHandlers.size();
    for (int i=0; i < size; i++) {
      handler=mDeathHandlers.get(i);
      if (cb == handler.mICallback) {
        return handler;
      }
    }
    if (state) {
      handler=new VolumeDeathHandler(cb);
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      handler=null;
    }
    return handler;
  }
}"
22740,"/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  final int oldIndex=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}","/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=(streamState.muteCount() != 0) ? streamState.mLastAudibleIndex : streamState.mIndex;
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  index=(streamState.muteCount() != 0) ? streamState.mLastAudibleIndex : streamState.mIndex;
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}"
22741,"private boolean trackSignalStrength(){
  return getPreferences().getBoolean(SIGNAL_PREF,true);
}","private boolean trackSignalStrength(){
  return getPreferences().getBoolean(SIGNAL_PREF,false);
}"
22742,"private boolean doDebugLogging(){
  return getPreferences().getBoolean(DEBUG_PREF,true);
}","private boolean doDebugLogging(){
  return getPreferences().getBoolean(DEBUG_PREF,false);
}"
22743,"private boolean trackSignalStrength(){
  return getPreferences().getBoolean(SIGNAL_PREF,true);
}","private boolean trackSignalStrength(){
  return getPreferences().getBoolean(SIGNAL_PREF,false);
}"
22744,"private boolean doDebugLogging(){
  return getPreferences().getBoolean(DEBUG_PREF,true);
}","private boolean doDebugLogging(){
  return getPreferences().getBoolean(DEBUG_PREF,false);
}"
22745,"/** 
 * Sets the drawable to use as the right part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theright strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomLeftStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}","/** 
 * Sets the drawable to use as the right part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theright strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomRightStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}"
22746,"/** 
 * Sets the drawable to use as the left part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theleft strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomLeftStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}","/** 
 * Sets the drawable to use as the right part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theright strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomLeftStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}"
22747,"/** 
 * Sets the drawable to use as the right part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theright strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomLeftStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}","/** 
 * Sets the drawable to use as the right part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theright strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomRightStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}"
22748,"/** 
 * Sets the drawable to use as the left part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theleft strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomLeftStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}","/** 
 * Sets the drawable to use as the right part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theright strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomLeftStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}"
22749,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        checkForUndispatchedAudioFocusChange(mMode,mode);
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}"
22750,"/** 
 * Helper function: Remove focus listeners from the focus stack for a particular client.
 */
private void removeFocusStackEntryForClient(IBinder cb){
  Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
  while (stackIterator.hasNext()) {
    FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
    if (fse.mSourceRef.equals(cb)) {
      Log.i(TAG,""String_Node_Str"" + fse.mClientId);
      mFocusStack.remove(fse);
    }
  }
}","/** 
 * Helper function: Remove focus listeners from the focus stack for a particular client.
 */
private void removeFocusStackEntryForClient(IBinder cb){
  boolean isTopOfStackForClientToRemove=!mFocusStack.isEmpty() && mFocusStack.peek().mSourceRef.equals(cb);
  Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
  while (stackIterator.hasNext()) {
    FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
    if (fse.mSourceRef.equals(cb)) {
      Log.i(TAG,""String_Node_Str"" + fse.mClientId);
      mFocusStack.remove(fse);
    }
  }
  if (isTopOfStackForClientToRemove) {
    notifyTopOfAudioFocusStack();
  }
}"
22751,"/** 
 * Helper function: Remove a focus listener from the focus stack.
 * @param focusListenerToRemove the focus listener
 * @param signal if true and the listener was at the top of the focus stack, i.e. it was holdingfocus, notify the next item in the stack it gained focus.
 */
private void removeFocusStackEntry(String clientToRemove,boolean signal){
  if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientToRemove)) {
    mFocusStack.pop();
    if (signal) {
      if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null) && canReassignAudioFocus()) {
        try {
          mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN,mFocusStack.peek().mClientId);
        }
 catch (        RemoteException e) {
          Log.e(TAG,""String_Node_Str"" + e);
          e.printStackTrace();
        }
      }
    }
  }
 else {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
      if (fse.mClientId.equals(clientToRemove)) {
        Log.i(TAG,""String_Node_Str"" + fse.mClientId);
        mFocusStack.remove(fse);
      }
    }
  }
}","/** 
 * Helper function: Remove a focus listener from the focus stack.
 * @param focusListenerToRemove the focus listener
 * @param signal if true and the listener was at the top of the focus stack, i.e. it was holdingfocus, notify the next item in the stack it gained focus.
 */
private void removeFocusStackEntry(String clientToRemove,boolean signal){
  if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientToRemove)) {
    mFocusStack.pop();
    if (signal) {
      notifyTopOfAudioFocusStack();
    }
  }
 else {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
      if (fse.mClientId.equals(clientToRemove)) {
        Log.i(TAG,""String_Node_Str"" + fse.mClientId);
        mFocusStack.remove(fse);
      }
    }
  }
}"
22752,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      mFocusStack.peek().mFocusChangeType=focusChangeHint;
      return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22753,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        checkForUndispatchedAudioFocusChange(mMode,mode);
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}"
22754,"/** 
 * Helper function: Remove focus listeners from the focus stack for a particular client.
 */
private void removeFocusStackEntryForClient(IBinder cb){
  Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
  while (stackIterator.hasNext()) {
    FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
    if (fse.mSourceRef.equals(cb)) {
      Log.i(TAG,""String_Node_Str"" + fse.mClientId);
      mFocusStack.remove(fse);
    }
  }
}","/** 
 * Helper function: Remove focus listeners from the focus stack for a particular client.
 */
private void removeFocusStackEntryForClient(IBinder cb){
  boolean isTopOfStackForClientToRemove=!mFocusStack.isEmpty() && mFocusStack.peek().mSourceRef.equals(cb);
  Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
  while (stackIterator.hasNext()) {
    FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
    if (fse.mSourceRef.equals(cb)) {
      Log.i(TAG,""String_Node_Str"" + fse.mClientId);
      mFocusStack.remove(fse);
    }
  }
  if (isTopOfStackForClientToRemove) {
    notifyTopOfAudioFocusStack();
  }
}"
22755,"/** 
 * Helper function: Remove a focus listener from the focus stack.
 * @param focusListenerToRemove the focus listener
 * @param signal if true and the listener was at the top of the focus stack, i.e. it was holdingfocus, notify the next item in the stack it gained focus.
 */
private void removeFocusStackEntry(String clientToRemove,boolean signal){
  if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientToRemove)) {
    mFocusStack.pop();
    if (signal) {
      if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null) && canReassignAudioFocus()) {
        try {
          mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN,mFocusStack.peek().mClientId);
        }
 catch (        RemoteException e) {
          Log.e(TAG,""String_Node_Str"" + e);
          e.printStackTrace();
        }
      }
    }
  }
 else {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
      if (fse.mClientId.equals(clientToRemove)) {
        Log.i(TAG,""String_Node_Str"" + fse.mClientId);
        mFocusStack.remove(fse);
      }
    }
  }
}","/** 
 * Helper function: Remove a focus listener from the focus stack.
 * @param focusListenerToRemove the focus listener
 * @param signal if true and the listener was at the top of the focus stack, i.e. it was holdingfocus, notify the next item in the stack it gained focus.
 */
private void removeFocusStackEntry(String clientToRemove,boolean signal){
  if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientToRemove)) {
    mFocusStack.pop();
    if (signal) {
      notifyTopOfAudioFocusStack();
    }
  }
 else {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
      if (fse.mClientId.equals(clientToRemove)) {
        Log.i(TAG,""String_Node_Str"" + fse.mClientId);
        mFocusStack.remove(fse);
      }
    }
  }
}"
22756,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      mFocusStack.peek().mFocusChangeType=focusChangeHint;
      return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}"
22757,"public PointerLocationView(Context c){
  super(c);
  mVC=ViewConfiguration.get(c);
  mTextPaint=new Paint();
  mTextPaint.setAntiAlias(true);
  mTextPaint.setTextSize(10 * getResources().getDisplayMetrics().density);
  mTextPaint.setARGB(255,0,0,0);
  mTextBackgroundPaint=new Paint();
  mTextBackgroundPaint.setAntiAlias(false);
  mTextBackgroundPaint.setARGB(128,255,255,255);
  mTextLevelPaint=new Paint();
  mTextLevelPaint.setAntiAlias(false);
  mTextLevelPaint.setARGB(192,255,0,0);
  mPaint=new Paint();
  mPaint.setAntiAlias(true);
  mPaint.setARGB(255,255,255,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(2);
  mTargetPaint=new Paint();
  mTargetPaint.setAntiAlias(false);
  mTargetPaint.setARGB(255,0,0,192);
  mPathPaint=new Paint();
  mPathPaint.setAntiAlias(false);
  mPathPaint.setARGB(255,0,96,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(1);
  PointerState ps=new PointerState();
  ps.mVelocity=VelocityTracker.obtain();
  mPointers.add(ps);
}","public PointerLocationView(Context c){
  super(c);
  setFocusable(true);
  mVC=ViewConfiguration.get(c);
  mTextPaint=new Paint();
  mTextPaint.setAntiAlias(true);
  mTextPaint.setTextSize(10 * getResources().getDisplayMetrics().density);
  mTextPaint.setARGB(255,0,0,0);
  mTextBackgroundPaint=new Paint();
  mTextBackgroundPaint.setAntiAlias(false);
  mTextBackgroundPaint.setARGB(128,255,255,255);
  mTextLevelPaint=new Paint();
  mTextLevelPaint.setAntiAlias(false);
  mTextLevelPaint.setARGB(192,255,0,0);
  mPaint=new Paint();
  mPaint.setAntiAlias(true);
  mPaint.setARGB(255,255,255,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(2);
  mTargetPaint=new Paint();
  mTargetPaint.setAntiAlias(false);
  mTargetPaint.setARGB(255,0,0,192);
  mPathPaint=new Paint();
  mPathPaint.setAntiAlias(false);
  mPathPaint.setARGB(255,0,96,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(1);
  PointerState ps=new PointerState();
  ps.mVelocity=VelocityTracker.obtain();
  mPointers.add(ps);
}"
22758,"public void run(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          if (di.classes != 0) {
            mDevices.put(ev.deviceId,di);
            if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
              readVirtualKeys(di.name);
            }
            configChanged=true;
          }
 else {
            mIgnoredDevices.put(ev.deviceId,di);
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(di.id) + ""String_Node_Str""+ di.name);
          }
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          if (false) {
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          }
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else           if ((di=mIgnoredDevices.get(ev.deviceId)) != null) {
            mIgnoredDevices.remove(ev.deviceId);
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
            continue;
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        if (di == null) {
          continue;
        }
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              if (BAD_TOUCH_HACK) {
                ms.dropBadPoint(di);
              }
              if (JUMPY_TOUCH_HACK) {
                ms.dropJumpyPoint(di);
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && (ms.mLastNumPointers == 0 || ms.mSkipLastPointers)) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (DEBUG_POINTERS)                   Slog.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Slog.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
 else {
                int num=ms.mNextNumPointers;
                if (num > InputDevice.MAX_POINTERS) {
                  num=InputDevice.MAX_POINTERS;
                }
                System.arraycopy(ms.mNextData,0,ms.mLastData,0,num * MotionEvent.NUM_SAMPLE_DATA);
                ms.mLastNumPointers=num;
                ms.mSkipLastPointers=true;
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Slog.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Slog.e(TAG,""String_Node_Str"",exc);
    }
  }
}","public void run(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          if (di.classes != 0) {
            mDevices.put(ev.deviceId,di);
            if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
              readVirtualKeys(di.name);
            }
            configChanged=true;
          }
 else {
            mIgnoredDevices.put(ev.deviceId,di);
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(di.id) + ""String_Node_Str""+ di.name);
          }
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          if (false) {
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          }
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else           if ((di=mIgnoredDevices.get(ev.deviceId)) != null) {
            mIgnoredDevices.remove(ev.deviceId);
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
            continue;
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        if (di == null) {
          continue;
        }
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              if (BAD_TOUCH_HACK) {
                ms.dropBadPoint(di);
              }
              if (JUMPY_TOUCH_HACK) {
                ms.dropJumpyPoint(di);
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && (ms.mLastNumPointers == 0 || ms.mSkipLastPointers)) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (DEBUG_POINTERS)                   Slog.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Slog.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
 else {
                int num=ms.mNextNumPointers;
                if (num > InputDevice.MAX_POINTERS) {
                  num=InputDevice.MAX_POINTERS;
                }
                System.arraycopy(ms.mNextData,0,ms.mLastData,0,num * MotionEvent.NUM_SAMPLE_DATA);
                ms.mLastNumPointers=num;
                ms.mSkipLastPointers=true;
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Slog.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Slog.e(TAG,""String_Node_Str"",exc);
    }
  }
}"
22759,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
22760,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}"
22761,"private PackageParser.Package scanPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode){
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if (pkg == null) {
    mLastScanError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if (pkg.packageName.equals(""String_Node_Str"")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + mScanningPath);
        Slog.w(TAG,""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      mResolveActivity.applicationInfo=mAndroidApplication;
      mResolveActivity.name=ResolverActivity.class.getName();
      mResolveActivity.packageName=mAndroidApplication.packageName;
      mResolveActivity.processName=mAndroidApplication.processName;
      mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
      mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
      mResolveActivity.theme=com.android.internal.R.style.Theme_Dialog_Alert;
      mResolveActivity.exported=true;
      mResolveActivity.enabled=true;
      mResolveInfo.activityInfo=mResolveActivity;
      mResolveInfo.priority=0;
      mResolveInfo.preferredOrder=0;
      mResolveInfo.match=0;
      mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
    }
  }
  if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.packageName);
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    Slog.w(TAG,""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  boolean removeExisting=false;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {
      if (mTmpSharedLibraries == null || mTmpSharedLibraries.length < mSharedLibraries.size()) {
        mTmpSharedLibraries=new String[mSharedLibraries.size()];
      }
      int num=0;
      int N=pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesLibraries.get(i));
        if (file == null) {
          Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesLibraries.get(i)+ ""String_Node_Str"");
          mLastScanError=PackageManager.INSTALL_FAILED_MISSING_SHARED_LIBRARY;
          return null;
        }
        mTmpSharedLibraries[num]=file;
        num++;
      }
      N=pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));
        if (file == null) {
          Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesOptionalLibraries.get(i)+ ""String_Node_Str"");
        }
 else {
          mTmpSharedLibraries[num]=file;
          num++;
        }
      }
      if (num > 0) {
        pkg.usesLibraryFiles=new String[num];
        System.arraycopy(mTmpSharedLibraries,0,pkg.usesLibraryFiles,0,num);
      }
      if (pkg.reqFeatures != null) {
        N=pkg.reqFeatures.size();
        for (int i=0; i < N; i++) {
          FeatureInfo fi=pkg.reqFeatures.get(i);
          if ((fi.flags & FeatureInfo.FLAG_REQUIRED) == 0) {
            continue;
          }
          if (fi.name != null) {
            if (mAvailableFeatures.get(fi.name) == null) {
              Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ fi.name+ ""String_Node_Str"");
              mLastScanError=PackageManager.INSTALL_FAILED_MISSING_FEATURE;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLP(pkg.mSharedUserId,pkg.applicationInfo.flags,true);
      if (suid == null) {
        Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + pkg.mSharedUserId + ""String_Node_Str""+ suid.userId+ ""String_Node_Str""+ suid.packages);
      }
    }
    if (false) {
      if (pkg.mOriginalPackages != null) {
        Log.w(TAG,""String_Node_Str"");
        Debug.waitForDebugger();
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.mOriginalPackages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLP(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdate(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,""String_Node_Str"" + origPackage.name + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ origPackage.sharedUser.name+ ""String_Node_Str""+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    }
    pkgSetting=mSettings.getPackageLP(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.flags,true,false);
    if (pkgSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg=""String_Node_Str"" + pkgSetting.realName + ""String_Node_Str""+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.mDisabledSysPackages.get(pkg.packageName) != null) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    pkg.applicationInfo.uid=pkgSetting.userId;
    pkg.mExtras=pkgSetting;
    if (!verifySignaturesLP(pkgSetting,pkg,parseFlags,(scanMode & SCAN_UPDATE_SIGNATURE) != 0)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) == 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (!pkgSetting.sharedUser.signatures.mergeSignatures(pkg.mSignatures,false)) {
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      removeExisting=true;
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(""String_Node_Str"");
          for (int j=0; j < names.length; j++) {
            if (mProviders.containsKey(names[j])) {
              PackageParser.Provider other=mProviders.get(names[j]);
              Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
              mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
              return null;
            }
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  if (removeExisting) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    if (mInstaller != null) {
      int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
      if (ret != 0) {
        String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
        reportSettingsProblem(Log.WARN,msg);
        mLastScanError=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
        return null;
      }
    }
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  }
  if (pkg.mAdoptPermissions != null) {
    for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
      String origName=pkg.mAdoptPermissions.get(i);
      PackageSetting orig=mSettings.peekPackageLP(origName);
      if (orig != null) {
        if (verifyPackageUpdate(orig,pkg)) {
          Slog.i(TAG,""String_Node_Str"" + origName + ""String_Node_Str""+ pkg.packageName);
          mSettings.transferPermissions(origName,pkg.packageName);
        }
      }
    }
  }
  long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  final boolean scanFileNewer=forceDex || scanFileTime != pkgSetting.getTimeStamp();
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),""String_Node_Str"");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    dataPath=getDataPathForPackage(pkg);
    boolean uidError=false;
    if (dataPath.exists()) {
      mOutPermissions[1]=0;
      FileUtils.getPermissions(dataPath.getPath(),mOutPermissions);
      if (mOutPermissions[1] == pkg.applicationInfo.uid || !Process.supportsProcesses()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        boolean recovered=false;
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
          if (mInstaller != null) {
            int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
            if (ret >= 0) {
              String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
              reportSettingsProblem(Log.WARN,msg);
              recovered=true;
              ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
              if (ret == -1) {
                msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
                reportSettingsProblem(Log.WARN,msg);
                mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
                return null;
              }
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir=""String_Node_Str"" + pkg.applicationInfo.uid + ""String_Node_Str""+ mOutPermissions[1];
          String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGV)       Log.v(TAG,""String_Node_Str"" + dataPath);
      if (mInstaller != null) {
        int ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        if (ret < 0) {
          mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          return null;
        }
      }
 else {
        dataPath.mkdirs();
        if (dataPath.exists()) {
          FileUtils.setPermissions(dataPath.toString(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        }
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  if (mInstaller != null) {
    String path=scanFile.getPath();
    if (scanFileNewer) {
      Log.i(TAG,path + ""String_Node_Str"");
      int err=cachePackageSharedLibsLI(pkg,dataPath,scanFile);
      if (err != PackageManager.INSTALL_SUCCEEDED) {
        mLastScanError=err;
        return null;
      }
    }
    pkg.mScanPath=path;
    if ((scanMode & SCAN_NO_DEX) == 0) {
      if (performDexOptLI(pkg,forceDex) == DEX_OPT_FAILED) {
        mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
        return null;
      }
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid);
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.mPath,pkg);
    }
    mSettings.insertPackageSettingLP(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    mSettings.mPackagesToBeCleaned.remove(pkgName);
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProvidersByComponent.put(new ComponentName(p.info.packageName,p.info.name),p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(""String_Node_Str"");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProviders.containsKey(names[j])) {
            mProviders.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ""String_Node_Str"" + names[j];
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)             Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
          }
 else {
            PackageParser.Provider other=mProviders.get(names[j]);
            Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pg.info.name + ""String_Node_Str""+ pg.info.packageName+ ""String_Node_Str""+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ tree.name+ ""String_Node_Str""+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ p.group);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}","private PackageParser.Package scanPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode){
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if (pkg == null) {
    mLastScanError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if (pkg.packageName.equals(""String_Node_Str"")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + mScanningPath);
        Slog.w(TAG,""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      mResolveActivity.applicationInfo=mAndroidApplication;
      mResolveActivity.name=ResolverActivity.class.getName();
      mResolveActivity.packageName=mAndroidApplication.packageName;
      mResolveActivity.processName=mAndroidApplication.processName;
      mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
      mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
      mResolveActivity.theme=com.android.internal.R.style.Theme_Dialog_Alert;
      mResolveActivity.exported=true;
      mResolveActivity.enabled=true;
      mResolveInfo.activityInfo=mResolveActivity;
      mResolveInfo.priority=0;
      mResolveInfo.preferredOrder=0;
      mResolveInfo.match=0;
      mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
    }
  }
  if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.packageName);
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    Slog.w(TAG,""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {
      if (mTmpSharedLibraries == null || mTmpSharedLibraries.length < mSharedLibraries.size()) {
        mTmpSharedLibraries=new String[mSharedLibraries.size()];
      }
      int num=0;
      int N=pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesLibraries.get(i));
        if (file == null) {
          Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesLibraries.get(i)+ ""String_Node_Str"");
          mLastScanError=PackageManager.INSTALL_FAILED_MISSING_SHARED_LIBRARY;
          return null;
        }
        mTmpSharedLibraries[num]=file;
        num++;
      }
      N=pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));
        if (file == null) {
          Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesOptionalLibraries.get(i)+ ""String_Node_Str"");
        }
 else {
          mTmpSharedLibraries[num]=file;
          num++;
        }
      }
      if (num > 0) {
        pkg.usesLibraryFiles=new String[num];
        System.arraycopy(mTmpSharedLibraries,0,pkg.usesLibraryFiles,0,num);
      }
      if (pkg.reqFeatures != null) {
        N=pkg.reqFeatures.size();
        for (int i=0; i < N; i++) {
          FeatureInfo fi=pkg.reqFeatures.get(i);
          if ((fi.flags & FeatureInfo.FLAG_REQUIRED) == 0) {
            continue;
          }
          if (fi.name != null) {
            if (mAvailableFeatures.get(fi.name) == null) {
              Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ fi.name+ ""String_Node_Str"");
              mLastScanError=PackageManager.INSTALL_FAILED_MISSING_FEATURE;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLP(pkg.mSharedUserId,pkg.applicationInfo.flags,true);
      if (suid == null) {
        Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + pkg.mSharedUserId + ""String_Node_Str""+ suid.userId+ ""String_Node_Str""+ suid.packages);
      }
    }
    if (false) {
      if (pkg.mOriginalPackages != null) {
        Log.w(TAG,""String_Node_Str"");
        Debug.waitForDebugger();
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.mOriginalPackages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLP(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdate(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,""String_Node_Str"" + origPackage.name + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ origPackage.sharedUser.name+ ""String_Node_Str""+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    }
    pkgSetting=mSettings.getPackageLP(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.flags,true,false);
    if (pkgSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg=""String_Node_Str"" + pkgSetting.realName + ""String_Node_Str""+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.mDisabledSysPackages.get(pkg.packageName) != null) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    pkg.applicationInfo.uid=pkgSetting.userId;
    pkg.mExtras=pkgSetting;
    if (!verifySignaturesLP(pkgSetting,pkg,parseFlags,(scanMode & SCAN_UPDATE_SIGNATURE) != 0)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (!pkgSetting.sharedUser.signatures.mergeSignatures(pkg.mSignatures,false)) {
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
      reportSettingsProblem(Log.WARN,msg);
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(""String_Node_Str"");
          for (int j=0; j < names.length; j++) {
            if (mProviders.containsKey(names[j])) {
              PackageParser.Provider other=mProviders.get(names[j]);
              Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
              mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
              return null;
            }
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  if (pkg.mAdoptPermissions != null) {
    for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
      String origName=pkg.mAdoptPermissions.get(i);
      PackageSetting orig=mSettings.peekPackageLP(origName);
      if (orig != null) {
        if (verifyPackageUpdate(orig,pkg)) {
          Slog.i(TAG,""String_Node_Str"" + origName + ""String_Node_Str""+ pkg.packageName);
          mSettings.transferPermissions(origName,pkg.packageName);
        }
      }
    }
  }
  long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  final boolean scanFileNewer=forceDex || scanFileTime != pkgSetting.getTimeStamp();
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),""String_Node_Str"");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    dataPath=getDataPathForPackage(pkg);
    boolean uidError=false;
    if (dataPath.exists()) {
      mOutPermissions[1]=0;
      FileUtils.getPermissions(dataPath.getPath(),mOutPermissions);
      if (mOutPermissions[1] == pkg.applicationInfo.uid || !Process.supportsProcesses()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        boolean recovered=false;
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
          if (mInstaller != null) {
            int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
            if (ret >= 0) {
              String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
              reportSettingsProblem(Log.WARN,msg);
              recovered=true;
              ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
              if (ret == -1) {
                msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
                reportSettingsProblem(Log.WARN,msg);
                mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
                return null;
              }
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir=""String_Node_Str"" + pkg.applicationInfo.uid + ""String_Node_Str""+ mOutPermissions[1];
          String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGV)       Log.v(TAG,""String_Node_Str"" + dataPath);
      if (mInstaller != null) {
        int ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        if (ret < 0) {
          mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          return null;
        }
      }
 else {
        dataPath.mkdirs();
        if (dataPath.exists()) {
          FileUtils.setPermissions(dataPath.toString(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        }
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  if (mInstaller != null) {
    String path=scanFile.getPath();
    if (scanFileNewer) {
      Log.i(TAG,path + ""String_Node_Str"");
      int err=cachePackageSharedLibsLI(pkg,dataPath,scanFile);
      if (err != PackageManager.INSTALL_SUCCEEDED) {
        mLastScanError=err;
        return null;
      }
    }
    pkg.mScanPath=path;
    if ((scanMode & SCAN_NO_DEX) == 0) {
      if (performDexOptLI(pkg,forceDex) == DEX_OPT_FAILED) {
        mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
        return null;
      }
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid);
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.mPath,pkg);
    }
    mSettings.insertPackageSettingLP(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    mSettings.mPackagesToBeCleaned.remove(pkgName);
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProvidersByComponent.put(new ComponentName(p.info.packageName,p.info.name),p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(""String_Node_Str"");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProviders.containsKey(names[j])) {
            mProviders.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ""String_Node_Str"" + names[j];
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)             Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
          }
 else {
            PackageParser.Provider other=mProviders.get(names[j]);
            Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pg.info.name + ""String_Node_Str""+ pg.info.packageName+ ""String_Node_Str""+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ tree.name+ ""String_Node_Str""+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ p.group);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}"
22762,"public PointerLocationView(Context c){
  super(c);
  mVC=ViewConfiguration.get(c);
  mTextPaint=new Paint();
  mTextPaint.setAntiAlias(true);
  mTextPaint.setTextSize(10 * getResources().getDisplayMetrics().density);
  mTextPaint.setARGB(255,0,0,0);
  mTextBackgroundPaint=new Paint();
  mTextBackgroundPaint.setAntiAlias(false);
  mTextBackgroundPaint.setARGB(128,255,255,255);
  mTextLevelPaint=new Paint();
  mTextLevelPaint.setAntiAlias(false);
  mTextLevelPaint.setARGB(192,255,0,0);
  mPaint=new Paint();
  mPaint.setAntiAlias(true);
  mPaint.setARGB(255,255,255,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(2);
  mTargetPaint=new Paint();
  mTargetPaint.setAntiAlias(false);
  mTargetPaint.setARGB(255,0,0,192);
  mPathPaint=new Paint();
  mPathPaint.setAntiAlias(false);
  mPathPaint.setARGB(255,0,96,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(1);
  PointerState ps=new PointerState();
  ps.mVelocity=VelocityTracker.obtain();
  mPointers.add(ps);
}","public PointerLocationView(Context c){
  super(c);
  setFocusable(true);
  mVC=ViewConfiguration.get(c);
  mTextPaint=new Paint();
  mTextPaint.setAntiAlias(true);
  mTextPaint.setTextSize(10 * getResources().getDisplayMetrics().density);
  mTextPaint.setARGB(255,0,0,0);
  mTextBackgroundPaint=new Paint();
  mTextBackgroundPaint.setAntiAlias(false);
  mTextBackgroundPaint.setARGB(128,255,255,255);
  mTextLevelPaint=new Paint();
  mTextLevelPaint.setAntiAlias(false);
  mTextLevelPaint.setARGB(192,255,0,0);
  mPaint=new Paint();
  mPaint.setAntiAlias(true);
  mPaint.setARGB(255,255,255,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(2);
  mTargetPaint=new Paint();
  mTargetPaint.setAntiAlias(false);
  mTargetPaint.setARGB(255,0,0,192);
  mPathPaint=new Paint();
  mPathPaint.setAntiAlias(false);
  mPathPaint.setARGB(255,0,96,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(1);
  PointerState ps=new PointerState();
  ps.mVelocity=VelocityTracker.obtain();
  mPointers.add(ps);
}"
22763,"public void run(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          if (di.classes != 0) {
            mDevices.put(ev.deviceId,di);
            if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
              readVirtualKeys(di.name);
            }
            configChanged=true;
          }
 else {
            mIgnoredDevices.put(ev.deviceId,di);
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(di.id) + ""String_Node_Str""+ di.name);
          }
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          if (false) {
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          }
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else           if ((di=mIgnoredDevices.get(ev.deviceId)) != null) {
            mIgnoredDevices.remove(ev.deviceId);
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
            continue;
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        if (di == null) {
          continue;
        }
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              if (BAD_TOUCH_HACK) {
                ms.dropBadPoint(di);
              }
              if (JUMPY_TOUCH_HACK) {
                ms.dropJumpyPoint(di);
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && (ms.mLastNumPointers == 0 || ms.mSkipLastPointers)) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (DEBUG_POINTERS)                   Slog.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Slog.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
 else {
                int num=ms.mNextNumPointers;
                if (num > InputDevice.MAX_POINTERS) {
                  num=InputDevice.MAX_POINTERS;
                }
                System.arraycopy(ms.mNextData,0,ms.mLastData,0,num * MotionEvent.NUM_SAMPLE_DATA);
                ms.mLastNumPointers=num;
                ms.mSkipLastPointers=true;
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Slog.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Slog.e(TAG,""String_Node_Str"",exc);
    }
  }
}","public void run(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          if (di.classes != 0) {
            mDevices.put(ev.deviceId,di);
            if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
              readVirtualKeys(di.name);
            }
            configChanged=true;
          }
 else {
            mIgnoredDevices.put(ev.deviceId,di);
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(di.id) + ""String_Node_Str""+ di.name);
          }
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          if (false) {
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          }
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else           if ((di=mIgnoredDevices.get(ev.deviceId)) != null) {
            mIgnoredDevices.remove(ev.deviceId);
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
            continue;
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        if (di == null) {
          continue;
        }
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              if (BAD_TOUCH_HACK) {
                ms.dropBadPoint(di);
              }
              if (JUMPY_TOUCH_HACK) {
                ms.dropJumpyPoint(di);
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && (ms.mLastNumPointers == 0 || ms.mSkipLastPointers)) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (DEBUG_POINTERS)                   Slog.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Slog.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
 else {
                int num=ms.mNextNumPointers;
                if (num > InputDevice.MAX_POINTERS) {
                  num=InputDevice.MAX_POINTERS;
                }
                System.arraycopy(ms.mNextData,0,ms.mLastData,0,num * MotionEvent.NUM_SAMPLE_DATA);
                ms.mLastNumPointers=num;
                ms.mSkipLastPointers=true;
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Slog.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Slog.e(TAG,""String_Node_Str"",exc);
    }
  }
}"
22764,"private boolean writeFileLocked(){
  if (mFile.exists()) {
    if (!mFile.renameTo(mBackupFile)) {
      Log.e(TAG,""String_Node_Str"" + mFile + ""String_Node_Str""+ mBackupFile);
      return false;
    }
  }
  try {
    FileOutputStream str=createFileOutputStream(mFile);
    if (str == null) {
      return false;
    }
    XmlUtils.writeMapXml(mMap,str);
    str.close();
    setFilePermissionsFromMode(mFile.getPath(),mMode,0);
    if (FileUtils.getFileStatus(mFile.getPath(),mFileStatus)) {
      mTimestamp=mFileStatus.mtime;
    }
    mBackupFile.delete();
    return true;
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  if (mFile.exists()) {
    if (!mFile.delete()) {
      Log.e(TAG,""String_Node_Str"" + mFile);
    }
  }
  return false;
}","private boolean writeFileLocked(){
  if (mFile.exists()) {
    if (!mBackupFile.exists()) {
      if (!mFile.renameTo(mBackupFile)) {
        Log.e(TAG,""String_Node_Str"" + mFile + ""String_Node_Str""+ mBackupFile);
        return false;
      }
    }
 else {
      mFile.delete();
    }
  }
  try {
    FileOutputStream str=createFileOutputStream(mFile);
    if (str == null) {
      return false;
    }
    XmlUtils.writeMapXml(mMap,str);
    str.close();
    setFilePermissionsFromMode(mFile.getPath(),mMode,0);
    if (FileUtils.getFileStatus(mFile.getPath(),mFileStatus)) {
      mTimestamp=mFileStatus.mtime;
    }
    mBackupFile.delete();
    return true;
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  if (mFile.exists()) {
    if (!mFile.delete()) {
      Log.e(TAG,""String_Node_Str"" + mFile);
    }
  }
  return false;
}"
22765,"/** 
 * Copy data from a source stream to destFile. Return true if succeed, return false if failed.
 */
public static boolean copyToFile(InputStream inputStream,File destFile){
  try {
    OutputStream out=new FileOutputStream(destFile);
    try {
      byte[] buffer=new byte[4096];
      int bytesRead;
      while ((bytesRead=inputStream.read(buffer)) >= 0) {
        out.write(buffer,0,bytesRead);
      }
    }
  finally {
      out.close();
    }
    return true;
  }
 catch (  IOException e) {
    return false;
  }
}","/** 
 * Copy data from a source stream to destFile. Return true if succeed, return false if failed.
 */
public static boolean copyToFile(InputStream inputStream,File destFile){
  try {
    if (destFile.exists()) {
      destFile.delete();
    }
    OutputStream out=new FileOutputStream(destFile);
    try {
      byte[] buffer=new byte[4096];
      int bytesRead;
      while ((bytesRead=inputStream.read(buffer)) >= 0) {
        out.write(buffer,0,bytesRead);
      }
    }
  finally {
      out.close();
    }
    return true;
  }
 catch (  IOException e) {
    return false;
  }
}"
22766,"/** 
 * Stops the current view recycer tracing. Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.traces</code> containing all the traces (or method calls) relative to the specified view's recycler. Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.recycler</code> containing all of the views used by the recycler of the view supplied to  {@link #startRecyclerTracing(String,View)}. This method will return immediately if TRACE_RECYCLER is false.
 * @see #startRecyclerTracing(String,View)
 * @see #trace(View,android.view.ViewDebug.RecyclerTraceType,int[])
 */
public static void stopRecyclerTracing(){
  if (!TRACE_RECYCLER) {
    return;
  }
  if (sRecyclerOwnerView == null || sRecyclerViews == null) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
  File recyclerDump=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  recyclerDump.mkdirs();
  recyclerDump=new File(recyclerDump,sRecyclerTracePrefix + ""String_Node_Str"");
  try {
    final BufferedWriter out=new BufferedWriter(new FileWriter(recyclerDump),8 * 1024);
    for (    View view : sRecyclerViews) {
      final String name=view.getClass().getName();
      out.write(name);
      out.newLine();
    }
    out.close();
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  recyclerDump=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  recyclerDump=new File(recyclerDump,sRecyclerTracePrefix + ""String_Node_Str"");
  try {
    final FileOutputStream file=new FileOutputStream(recyclerDump);
    final DataOutputStream out=new DataOutputStream(file);
    for (    RecyclerTrace trace : sRecyclerTraces) {
      out.writeInt(trace.view);
      out.writeInt(trace.type.ordinal());
      out.writeInt(trace.position);
      out.writeInt(trace.indexOnScreen);
      out.flush();
    }
    out.close();
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  sRecyclerViews.clear();
  sRecyclerViews=null;
  sRecyclerTraces.clear();
  sRecyclerTraces=null;
  sRecyclerOwnerView=null;
}","/** 
 * Stops the current view recycer tracing. Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.traces</code> containing all the traces (or method calls) relative to the specified view's recycler. Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.recycler</code> containing all of the views used by the recycler of the view supplied to  {@link #startRecyclerTracing(String,View)}. This method will return immediately if TRACE_RECYCLER is false.
 * @see #startRecyclerTracing(String,View)
 * @see #trace(View,android.view.ViewDebug.RecyclerTraceType,int[])
 */
public static void stopRecyclerTracing(){
  if (!TRACE_RECYCLER) {
    return;
  }
  if (sRecyclerOwnerView == null || sRecyclerViews == null) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
  File recyclerDump=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  recyclerDump.mkdirs();
  recyclerDump=new File(recyclerDump,sRecyclerTracePrefix + ""String_Node_Str"");
  try {
    final BufferedWriter out=new BufferedWriter(new FileWriter(recyclerDump),8 * 1024);
    for (    View view : sRecyclerViews) {
      final String name=view.getClass().getName();
      out.write(name);
      out.newLine();
    }
    out.close();
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  recyclerDump=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  recyclerDump=new File(recyclerDump,sRecyclerTracePrefix + ""String_Node_Str"");
  try {
    if (recyclerDump.exists()) {
      recyclerDump.delete();
    }
    final FileOutputStream file=new FileOutputStream(recyclerDump);
    final DataOutputStream out=new DataOutputStream(file);
    for (    RecyclerTrace trace : sRecyclerTraces) {
      out.writeInt(trace.view);
      out.writeInt(trace.type.ordinal());
      out.writeInt(trace.position);
      out.writeInt(trace.indexOnScreen);
      out.flush();
    }
    out.close();
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  sRecyclerViews.clear();
  sRecyclerViews=null;
  sRecyclerTraces.clear();
  sRecyclerTraces=null;
  sRecyclerOwnerView=null;
}"
22767,"public int performBackup(PackageInfo packageInfo,ParcelFileDescriptor data){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + packageInfo.packageName);
  File packageDir=new File(mDataDir,packageInfo.packageName);
  packageDir.mkdirs();
  BackupDataInput changeSet=new BackupDataInput(data.getFileDescriptor());
  try {
    int bufSize=512;
    byte[] buf=new byte[bufSize];
    while (changeSet.readNextHeader()) {
      String key=changeSet.getKey();
      String base64Key=new String(Base64.encode(key.getBytes()));
      File entityFile=new File(packageDir,base64Key);
      int dataSize=changeSet.getDataSize();
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ dataSize+ ""String_Node_Str""+ base64Key);
      if (dataSize >= 0) {
        FileOutputStream entity=new FileOutputStream(entityFile);
        if (dataSize > bufSize) {
          bufSize=dataSize;
          buf=new byte[bufSize];
        }
        changeSet.readEntityData(buf,0,dataSize);
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + dataSize);
        try {
          entity.write(buf,0,dataSize);
        }
 catch (        IOException e) {
          Log.e(TAG,""String_Node_Str"" + entityFile.getAbsolutePath());
          return BackupConstants.TRANSPORT_ERROR;
        }
 finally {
          entity.close();
        }
      }
 else {
        entityFile.delete();
      }
    }
    return BackupConstants.TRANSPORT_OK;
  }
 catch (  IOException e) {
    Log.v(TAG,""String_Node_Str"",e);
    return BackupConstants.TRANSPORT_ERROR;
  }
}","public int performBackup(PackageInfo packageInfo,ParcelFileDescriptor data){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + packageInfo.packageName);
  File packageDir=new File(mDataDir,packageInfo.packageName);
  packageDir.mkdirs();
  BackupDataInput changeSet=new BackupDataInput(data.getFileDescriptor());
  try {
    int bufSize=512;
    byte[] buf=new byte[bufSize];
    while (changeSet.readNextHeader()) {
      String key=changeSet.getKey();
      String base64Key=new String(Base64.encode(key.getBytes()));
      File entityFile=new File(packageDir,base64Key);
      int dataSize=changeSet.getDataSize();
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ dataSize+ ""String_Node_Str""+ base64Key);
      if (dataSize >= 0) {
        if (entityFile.exists()) {
          entityFile.delete();
        }
        FileOutputStream entity=new FileOutputStream(entityFile);
        if (dataSize > bufSize) {
          bufSize=dataSize;
          buf=new byte[bufSize];
        }
        changeSet.readEntityData(buf,0,dataSize);
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + dataSize);
        try {
          entity.write(buf,0,dataSize);
        }
 catch (        IOException e) {
          Log.e(TAG,""String_Node_Str"" + entityFile.getAbsolutePath());
          return BackupConstants.TRANSPORT_ERROR;
        }
 finally {
          entity.close();
        }
      }
 else {
        entityFile.delete();
      }
    }
    return BackupConstants.TRANSPORT_OK;
  }
 catch (  IOException e) {
    Log.v(TAG,""String_Node_Str"",e);
    return BackupConstants.TRANSPORT_ERROR;
  }
}"
22768,"public FileOutputStream startWrite() throws IOException {
  if (mBaseName.exists()) {
    if (!mBaseName.renameTo(mBackupName)) {
      mBackupName.delete();
      if (!mBaseName.renameTo(mBackupName)) {
        Log.w(""String_Node_Str"",""String_Node_Str"" + mBaseName + ""String_Node_Str""+ mBackupName);
      }
    }
  }
  FileOutputStream str=null;
  try {
    str=new FileOutputStream(mBaseName);
  }
 catch (  FileNotFoundException e) {
    File parent=mBaseName.getParentFile();
    if (!parent.mkdir()) {
      throw new IOException(""String_Node_Str"" + mBaseName);
    }
    FileUtils.setPermissions(parent.getPath(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,-1,-1);
    try {
      str=new FileOutputStream(mBaseName);
    }
 catch (    FileNotFoundException e2) {
      throw new IOException(""String_Node_Str"" + mBaseName);
    }
  }
  return str;
}","public FileOutputStream startWrite() throws IOException {
  if (mBaseName.exists()) {
    if (!mBackupName.exists()) {
      if (!mBaseName.renameTo(mBackupName)) {
        Log.w(""String_Node_Str"",""String_Node_Str"" + mBaseName + ""String_Node_Str""+ mBackupName);
      }
    }
 else {
      mBaseName.delete();
    }
  }
  FileOutputStream str=null;
  try {
    str=new FileOutputStream(mBaseName);
  }
 catch (  FileNotFoundException e) {
    File parent=mBaseName.getParentFile();
    if (!parent.mkdir()) {
      throw new IOException(""String_Node_Str"" + mBaseName);
    }
    FileUtils.setPermissions(parent.getPath(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,-1,-1);
    try {
      str=new FileOutputStream(mBaseName);
    }
 catch (    FileNotFoundException e2) {
      throw new IOException(""String_Node_Str"" + mBaseName);
    }
  }
  return str;
}"
22769,"public void writeLocked(){
  if ((mFile == null) || (mBackupFile == null)) {
    Log.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  if (mFile.exists()) {
    if (mBackupFile.exists()) {
      mBackupFile.delete();
    }
    if (!mFile.renameTo(mBackupFile)) {
      Log.w(""String_Node_Str"",""String_Node_Str"");
      return;
    }
  }
  try {
    FileOutputStream stream=new FileOutputStream(mFile);
    Parcel out=Parcel.obtain();
    writeSummaryToParcel(out);
    stream.write(out.marshall());
    out.recycle();
    stream.flush();
    stream.close();
    mBackupFile.delete();
    mLastWriteTime=SystemClock.elapsedRealtime();
    return;
  }
 catch (  IOException e) {
    Log.w(""String_Node_Str"",""String_Node_Str"",e);
  }
  if (mFile.exists()) {
    if (!mFile.delete()) {
      Log.w(TAG,""String_Node_Str"" + mFile);
    }
  }
}","public void writeLocked(){
  if (mFile == null) {
    Slog.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  try {
    FileOutputStream stream=new FileOutputStream(mFile.chooseForWrite());
    Parcel out=Parcel.obtain();
    writeSummaryToParcel(out);
    stream.write(out.marshall());
    out.recycle();
    stream.flush();
    stream.close();
    mFile.commit();
    mLastWriteTime=SystemClock.elapsedRealtime();
    return;
  }
 catch (  IOException e) {
    Slog.w(""String_Node_Str"",""String_Node_Str"",e);
  }
  mFile.rollback();
}"
22770,"public void updateKernelWakelocksLocked(){
  Map<String,KernelWakelockStats> m=readKernelWakelockStats();
  if (m == null) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  for (  Map.Entry<String,KernelWakelockStats> ent : m.entrySet()) {
    String name=ent.getKey();
    KernelWakelockStats kws=ent.getValue();
    SamplingTimer kwlt=mKernelWakelockStats.get(name);
    if (kwlt == null) {
      kwlt=new SamplingTimer(mUnpluggables,mOnBatteryInternal,true);
      mKernelWakelockStats.put(name,kwlt);
    }
    kwlt.updateCurrentReportedCount(kws.mCount);
    kwlt.updateCurrentReportedTotalTime(kws.mTotalTime);
    kwlt.setUpdateVersion(sKernelWakelockUpdateVersion);
  }
  if (m.size() != mKernelWakelockStats.size()) {
    for (    Map.Entry<String,SamplingTimer> ent : mKernelWakelockStats.entrySet()) {
      SamplingTimer st=ent.getValue();
      if (st.getUpdateVersion() != sKernelWakelockUpdateVersion) {
        st.setStale();
      }
    }
  }
}","public void updateKernelWakelocksLocked(){
  Map<String,KernelWakelockStats> m=readKernelWakelockStats();
  if (m == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  for (  Map.Entry<String,KernelWakelockStats> ent : m.entrySet()) {
    String name=ent.getKey();
    KernelWakelockStats kws=ent.getValue();
    SamplingTimer kwlt=mKernelWakelockStats.get(name);
    if (kwlt == null) {
      kwlt=new SamplingTimer(mUnpluggables,mOnBatteryInternal,true);
      mKernelWakelockStats.put(name,kwlt);
    }
    kwlt.updateCurrentReportedCount(kws.mCount);
    kwlt.updateCurrentReportedTotalTime(kws.mTotalTime);
    kwlt.setUpdateVersion(sKernelWakelockUpdateVersion);
  }
  if (m.size() != mKernelWakelockStats.size()) {
    for (    Map.Entry<String,SamplingTimer> ent : mKernelWakelockStats.entrySet()) {
      SamplingTimer st=ent.getValue();
      if (st.getUpdateVersion() != sKernelWakelockUpdateVersion) {
        st.setStale();
      }
    }
  }
}"
22771,"private void readSummaryFromParcel(Parcel in){
  final int version=in.readInt();
  if (version != VERSION) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + version + ""String_Node_Str""+ VERSION+ ""String_Node_Str"");
    return;
  }
  mStartCount=in.readInt();
  mBatteryUptime=in.readLong();
  mBatteryLastUptime=in.readLong();
  mBatteryRealtime=in.readLong();
  mBatteryLastRealtime=in.readLong();
  mUptime=in.readLong();
  mLastUptime=in.readLong();
  mRealtime=in.readLong();
  mLastRealtime=in.readLong();
  mDischargeStartLevel=in.readInt();
  mDischargeCurrentLevel=in.readInt();
  mStartCount++;
  mScreenOn=false;
  mScreenOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
  }
  mInputEventCounter.readSummaryFromParcelLocked(in);
  mPhoneOn=false;
  mPhoneOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
  }
  mWifiOn=false;
  mWifiOnTimer.readSummaryFromParcelLocked(in);
  mWifiRunning=false;
  mWifiRunningTimer.readSummaryFromParcelLocked(in);
  mBluetoothOn=false;
  mBluetoothOnTimer.readSummaryFromParcelLocked(in);
  int NKW=in.readInt();
  for (int ikw=0; ikw < NKW; ikw++) {
    if (in.readInt() != 0) {
      String kwltName=in.readString();
      getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
    }
  }
  sNumSpeedSteps=in.readInt();
  final int NU=in.readInt();
  for (int iu=0; iu < NU; iu++) {
    int uid=in.readInt();
    Uid u=new Uid(uid);
    mUidStats.put(uid,u);
    u.mWifiTurnedOn=false;
    u.mWifiTurnedOnTimer.readSummaryFromParcelLocked(in);
    u.mFullWifiLockOut=false;
    u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
    u.mAudioTurnedOn=false;
    u.mAudioTurnedOnTimer.readSummaryFromParcelLocked(in);
    u.mVideoTurnedOn=false;
    u.mVideoTurnedOnTimer.readSummaryFromParcelLocked(in);
    u.mScanWifiLockOut=false;
    u.mScanWifiLockTimer.readSummaryFromParcelLocked(in);
    u.mWifiMulticastEnabled=false;
    u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
    if (in.readInt() != 0) {
      if (u.mUserActivityCounters == null) {
        u.initUserActivityLocked();
      }
      for (int i=0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
        u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    int NW=in.readInt();
    for (int iw=0; iw < NW; iw++) {
      String wlName=in.readString();
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
      }
    }
    int NP=in.readInt();
    for (int is=0; is < NP; is++) {
      int seNumber=in.readInt();
      if (in.readInt() != 0) {
        u.getSensorTimerLocked(seNumber,true).readSummaryFromParcelLocked(in);
      }
    }
    NP=in.readInt();
    for (int ip=0; ip < NP; ip++) {
      String procName=in.readString();
      Uid.Proc p=u.getProcessStatsLocked(procName);
      p.mUserTime=p.mLoadedUserTime=in.readLong();
      p.mLastUserTime=in.readLong();
      p.mSystemTime=p.mLoadedSystemTime=in.readLong();
      p.mLastSystemTime=in.readLong();
      p.mStarts=p.mLoadedStarts=in.readInt();
      p.mLastStarts=in.readInt();
    }
    NP=in.readInt();
    for (int ip=0; ip < NP; ip++) {
      String pkgName=in.readString();
      Uid.Pkg p=u.getPackageStatsLocked(pkgName);
      p.mWakeups=p.mLoadedWakeups=in.readInt();
      p.mLastWakeups=in.readInt();
      final int NS=in.readInt();
      for (int is=0; is < NS; is++) {
        String servName=in.readString();
        Uid.Pkg.Serv s=u.getServiceStatsLocked(pkgName,servName);
        s.mStartTime=s.mLoadedStartTime=in.readLong();
        s.mLastStartTime=in.readLong();
        s.mStarts=s.mLoadedStarts=in.readInt();
        s.mLastStarts=in.readInt();
        s.mLaunches=s.mLoadedLaunches=in.readInt();
        s.mLastLaunches=in.readInt();
      }
    }
    u.mLoadedTcpBytesReceived=in.readLong();
    u.mLoadedTcpBytesSent=in.readLong();
  }
}","private void readSummaryFromParcel(Parcel in){
  final int version=in.readInt();
  if (version != VERSION) {
    Slog.w(""String_Node_Str"",""String_Node_Str"" + version + ""String_Node_Str""+ VERSION+ ""String_Node_Str"");
    return;
  }
  mStartCount=in.readInt();
  mBatteryUptime=in.readLong();
  mBatteryLastUptime=in.readLong();
  mBatteryRealtime=in.readLong();
  mBatteryLastRealtime=in.readLong();
  mUptime=in.readLong();
  mLastUptime=in.readLong();
  mRealtime=in.readLong();
  mLastRealtime=in.readLong();
  mDischargeStartLevel=in.readInt();
  mDischargeCurrentLevel=in.readInt();
  mStartCount++;
  mScreenOn=false;
  mScreenOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
  }
  mInputEventCounter.readSummaryFromParcelLocked(in);
  mPhoneOn=false;
  mPhoneOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
  }
  mWifiOn=false;
  mWifiOnTimer.readSummaryFromParcelLocked(in);
  mWifiRunning=false;
  mWifiRunningTimer.readSummaryFromParcelLocked(in);
  mBluetoothOn=false;
  mBluetoothOnTimer.readSummaryFromParcelLocked(in);
  int NKW=in.readInt();
  if (NKW > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NKW);
    return;
  }
  for (int ikw=0; ikw < NKW; ikw++) {
    if (in.readInt() != 0) {
      String kwltName=in.readString();
      getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
    }
  }
  sNumSpeedSteps=in.readInt();
  final int NU=in.readInt();
  if (NU > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NU);
    return;
  }
  for (int iu=0; iu < NU; iu++) {
    int uid=in.readInt();
    Uid u=new Uid(uid);
    mUidStats.put(uid,u);
    u.mWifiTurnedOn=false;
    u.mWifiTurnedOnTimer.readSummaryFromParcelLocked(in);
    u.mFullWifiLockOut=false;
    u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
    u.mAudioTurnedOn=false;
    u.mAudioTurnedOnTimer.readSummaryFromParcelLocked(in);
    u.mVideoTurnedOn=false;
    u.mVideoTurnedOnTimer.readSummaryFromParcelLocked(in);
    u.mScanWifiLockOut=false;
    u.mScanWifiLockTimer.readSummaryFromParcelLocked(in);
    u.mWifiMulticastEnabled=false;
    u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
    if (in.readInt() != 0) {
      if (u.mUserActivityCounters == null) {
        u.initUserActivityLocked();
      }
      for (int i=0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
        u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    int NW=in.readInt();
    if (NW > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NW);
      return;
    }
    for (int iw=0; iw < NW; iw++) {
      String wlName=in.readString();
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
      }
    }
    int NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int is=0; is < NP; is++) {
      int seNumber=in.readInt();
      if (in.readInt() != 0) {
        u.getSensorTimerLocked(seNumber,true).readSummaryFromParcelLocked(in);
      }
    }
    NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String procName=in.readString();
      Uid.Proc p=u.getProcessStatsLocked(procName);
      p.mUserTime=p.mLoadedUserTime=in.readLong();
      p.mLastUserTime=in.readLong();
      p.mSystemTime=p.mLoadedSystemTime=in.readLong();
      p.mLastSystemTime=in.readLong();
      p.mStarts=p.mLoadedStarts=in.readInt();
      p.mLastStarts=in.readInt();
    }
    NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String pkgName=in.readString();
      Uid.Pkg p=u.getPackageStatsLocked(pkgName);
      p.mWakeups=p.mLoadedWakeups=in.readInt();
      p.mLastWakeups=in.readInt();
      final int NS=in.readInt();
      for (int is=0; is < NS; is++) {
        String servName=in.readString();
        Uid.Pkg.Serv s=u.getServiceStatsLocked(pkgName,servName);
        s.mStartTime=s.mLoadedStartTime=in.readLong();
        s.mLastStartTime=in.readLong();
        s.mStarts=s.mLoadedStarts=in.readInt();
        s.mLastStarts=in.readInt();
        s.mLaunches=s.mLoadedLaunches=in.readInt();
        s.mLastLaunches=in.readInt();
      }
    }
    u.mLoadedTcpBytesReceived=in.readLong();
    u.mLoadedTcpBytesSent=in.readLong();
  }
}"
22772,"public void readLocked(){
  if ((mFile == null) || (mBackupFile == null)) {
    Log.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  mUidStats.clear();
  FileInputStream stream=null;
  if (mBackupFile.exists()) {
    try {
      stream=new FileInputStream(mBackupFile);
    }
 catch (    java.io.IOException e) {
    }
  }
  try {
    if (stream == null) {
      if (!mFile.exists()) {
        return;
      }
      stream=new FileInputStream(mFile);
    }
    byte[] raw=readFully(stream);
    Parcel in=Parcel.obtain();
    in.unmarshall(raw,0,raw.length);
    in.setDataPosition(0);
    stream.close();
    readSummaryFromParcel(in);
  }
 catch (  java.io.IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"",e);
  }
}","public void readLocked(){
  if (mFile == null) {
    Slog.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  mUidStats.clear();
  try {
    File file=mFile.chooseForRead();
    if (!file.exists()) {
      return;
    }
    FileInputStream stream=new FileInputStream(file);
    byte[] raw=readFully(stream);
    Parcel in=Parcel.obtain();
    in.unmarshall(raw,0,raw.length);
    in.setDataPosition(0);
    stream.close();
    readSummaryFromParcel(in);
  }
 catch (  java.io.IOException e) {
    Slog.e(""String_Node_Str"",""String_Node_Str"",e);
  }
}"
22773,"public BatteryStatsImpl(Parcel p){
  mFile=mBackupFile=null;
  readFromParcel(p);
}","public BatteryStatsImpl(Parcel p){
  mFile=null;
  readFromParcel(p);
}"
22774,"void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}","void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}"
22775,"boolean restoreNamedResourceLocked(){
  if (mName.length() > 4 && ""String_Node_Str"".equals(mName.substring(0,4))) {
    String resName=mName.substring(4);
    String pkg=null;
    int colon=resName.indexOf(':');
    if (colon > 0) {
      pkg=resName.substring(0,colon);
    }
    String ident=null;
    int slash=resName.lastIndexOf('/');
    if (slash > 0) {
      ident=resName.substring(slash + 1);
    }
    String type=null;
    if (colon > 0 && slash > 0 && (slash - colon) > 1) {
      type=resName.substring(colon + 1,slash);
    }
    if (pkg != null && ident != null && type != null) {
      int resId=-1;
      InputStream res=null;
      FileOutputStream fos=null;
      try {
        Context c=mContext.createPackageContext(pkg,Context.CONTEXT_RESTRICTED);
        Resources r=c.getResources();
        resId=r.getIdentifier(resName,null,null);
        if (resId == 0) {
          Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ type+ ""String_Node_Str""+ ident);
          return false;
        }
        res=r.openRawResource(resId);
        fos=new FileOutputStream(WALLPAPER_FILE);
        byte[] buffer=new byte[32768];
        int amt;
        while ((amt=res.read(buffer)) > 0) {
          fos.write(buffer,0,amt);
        }
        Slog.v(TAG,""String_Node_Str"" + resName);
        return true;
      }
 catch (      NameNotFoundException e) {
        Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str"");
      }
catch (      Resources.NotFoundException e) {
        Slog.e(TAG,""String_Node_Str"" + resId);
      }
catch (      IOException e) {
        Slog.e(TAG,""String_Node_Str"",e);
      }
 finally {
        if (res != null) {
          try {
            res.close();
          }
 catch (          IOException ex) {
          }
        }
        if (fos != null) {
          try {
            fos.close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
  return false;
}","boolean restoreNamedResourceLocked(){
  if (mName.length() > 4 && ""String_Node_Str"".equals(mName.substring(0,4))) {
    String resName=mName.substring(4);
    String pkg=null;
    int colon=resName.indexOf(':');
    if (colon > 0) {
      pkg=resName.substring(0,colon);
    }
    String ident=null;
    int slash=resName.lastIndexOf('/');
    if (slash > 0) {
      ident=resName.substring(slash + 1);
    }
    String type=null;
    if (colon > 0 && slash > 0 && (slash - colon) > 1) {
      type=resName.substring(colon + 1,slash);
    }
    if (pkg != null && ident != null && type != null) {
      int resId=-1;
      InputStream res=null;
      FileOutputStream fos=null;
      try {
        Context c=mContext.createPackageContext(pkg,Context.CONTEXT_RESTRICTED);
        Resources r=c.getResources();
        resId=r.getIdentifier(resName,null,null);
        if (resId == 0) {
          Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ type+ ""String_Node_Str""+ ident);
          return false;
        }
        res=r.openRawResource(resId);
        if (WALLPAPER_FILE.exists()) {
          WALLPAPER_FILE.delete();
        }
        fos=new FileOutputStream(WALLPAPER_FILE);
        byte[] buffer=new byte[32768];
        int amt;
        while ((amt=res.read(buffer)) > 0) {
          fos.write(buffer,0,amt);
        }
        Slog.v(TAG,""String_Node_Str"" + resName);
        return true;
      }
 catch (      NameNotFoundException e) {
        Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str"");
      }
catch (      Resources.NotFoundException e) {
        Slog.e(TAG,""String_Node_Str"" + resId);
      }
catch (      IOException e) {
        Slog.e(TAG,""String_Node_Str"",e);
      }
 finally {
        if (res != null) {
          try {
            res.close();
          }
 catch (          IOException ex) {
          }
        }
        if (fos != null) {
          try {
            fos.close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
  return false;
}"
22776,"private void writeStatsToFile(boolean force){
synchronized (mFileLock) {
    mCal.setTimeInMillis(System.currentTimeMillis());
    final int curDay=mCal.get(Calendar.DAY_OF_YEAR);
    final boolean dayChanged=curDay != mLastWriteDay;
    long currElapsedTime=SystemClock.elapsedRealtime();
    if (!force) {
      if (((currElapsedTime - mLastWriteElapsedTime) < FILE_WRITE_INTERVAL) && (!dayChanged)) {
        return;
      }
    }
    mFileLeaf=getCurrentDateStr(FILE_PREFIX);
    File backupFile=null;
    if (mFile != null && mFile.exists()) {
      backupFile=new File(mFile.getPath() + ""String_Node_Str"");
      if (!mFile.renameTo(backupFile)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
    try {
      writeStatsFLOCK();
      mLastWriteElapsedTime=currElapsedTime;
      if (dayChanged) {
        mLastWriteDay=curDay;
synchronized (mStats) {
          mStats.clear();
        }
        mFile=new File(mDir,mFileLeaf);
        checkFileLimitFLOCK();
      }
      if (backupFile != null) {
        backupFile.delete();
      }
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + mFile);
      if (backupFile != null) {
        mFile.delete();
        backupFile.renameTo(mFile);
      }
    }
  }
}","private void writeStatsToFile(boolean force){
synchronized (mFileLock) {
    mCal.setTimeInMillis(System.currentTimeMillis());
    final int curDay=mCal.get(Calendar.DAY_OF_YEAR);
    final boolean dayChanged=curDay != mLastWriteDay;
    long currElapsedTime=SystemClock.elapsedRealtime();
    if (!force) {
      if (((currElapsedTime - mLastWriteElapsedTime) < FILE_WRITE_INTERVAL) && (!dayChanged)) {
        return;
      }
    }
    mFileLeaf=getCurrentDateStr(FILE_PREFIX);
    File backupFile=null;
    if (mFile != null && mFile.exists()) {
      backupFile=new File(mFile.getPath() + ""String_Node_Str"");
      if (!backupFile.exists()) {
        if (!mFile.renameTo(backupFile)) {
          Slog.w(TAG,""String_Node_Str"");
          return;
        }
      }
 else {
        mFile.delete();
      }
    }
    try {
      writeStatsFLOCK();
      mLastWriteElapsedTime=currElapsedTime;
      if (dayChanged) {
        mLastWriteDay=curDay;
synchronized (mStats) {
          mStats.clear();
        }
        mFile=new File(mDir,mFileLeaf);
        checkFileLimitFLOCK();
      }
      if (backupFile != null) {
        backupFile.delete();
      }
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + mFile);
      if (backupFile != null) {
        mFile.delete();
        backupFile.renameTo(mFile);
      }
    }
  }
}"
22777,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
22778,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}"
22779,"private PackageParser.Package scanPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode){
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if (pkg == null) {
    mLastScanError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if (pkg.packageName.equals(""String_Node_Str"")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + mScanningPath);
        Slog.w(TAG,""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      mResolveActivity.applicationInfo=mAndroidApplication;
      mResolveActivity.name=ResolverActivity.class.getName();
      mResolveActivity.packageName=mAndroidApplication.packageName;
      mResolveActivity.processName=mAndroidApplication.processName;
      mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
      mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
      mResolveActivity.theme=com.android.internal.R.style.Theme_Dialog_Alert;
      mResolveActivity.exported=true;
      mResolveActivity.enabled=true;
      mResolveInfo.activityInfo=mResolveActivity;
      mResolveInfo.priority=0;
      mResolveInfo.preferredOrder=0;
      mResolveInfo.match=0;
      mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
    }
  }
  if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.packageName);
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    Slog.w(TAG,""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  boolean removeExisting=false;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {
      if (mTmpSharedLibraries == null || mTmpSharedLibraries.length < mSharedLibraries.size()) {
        mTmpSharedLibraries=new String[mSharedLibraries.size()];
      }
      int num=0;
      int N=pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesLibraries.get(i));
        if (file == null) {
          Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesLibraries.get(i)+ ""String_Node_Str"");
          mLastScanError=PackageManager.INSTALL_FAILED_MISSING_SHARED_LIBRARY;
          return null;
        }
        mTmpSharedLibraries[num]=file;
        num++;
      }
      N=pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));
        if (file == null) {
          Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesOptionalLibraries.get(i)+ ""String_Node_Str"");
        }
 else {
          mTmpSharedLibraries[num]=file;
          num++;
        }
      }
      if (num > 0) {
        pkg.usesLibraryFiles=new String[num];
        System.arraycopy(mTmpSharedLibraries,0,pkg.usesLibraryFiles,0,num);
      }
      if (pkg.reqFeatures != null) {
        N=pkg.reqFeatures.size();
        for (int i=0; i < N; i++) {
          FeatureInfo fi=pkg.reqFeatures.get(i);
          if ((fi.flags & FeatureInfo.FLAG_REQUIRED) == 0) {
            continue;
          }
          if (fi.name != null) {
            if (mAvailableFeatures.get(fi.name) == null) {
              Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ fi.name+ ""String_Node_Str"");
              mLastScanError=PackageManager.INSTALL_FAILED_MISSING_FEATURE;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLP(pkg.mSharedUserId,pkg.applicationInfo.flags,true);
      if (suid == null) {
        Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + pkg.mSharedUserId + ""String_Node_Str""+ suid.userId+ ""String_Node_Str""+ suid.packages);
      }
    }
    if (false) {
      if (pkg.mOriginalPackages != null) {
        Log.w(TAG,""String_Node_Str"");
        Debug.waitForDebugger();
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.mOriginalPackages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLP(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdate(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,""String_Node_Str"" + origPackage.name + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ origPackage.sharedUser.name+ ""String_Node_Str""+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    }
    pkgSetting=mSettings.getPackageLP(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.flags,true,false);
    if (pkgSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg=""String_Node_Str"" + pkgSetting.realName + ""String_Node_Str""+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.mDisabledSysPackages.get(pkg.packageName) != null) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    pkg.applicationInfo.uid=pkgSetting.userId;
    pkg.mExtras=pkgSetting;
    if (!verifySignaturesLP(pkgSetting,pkg,parseFlags,(scanMode & SCAN_UPDATE_SIGNATURE) != 0)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) == 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (!pkgSetting.sharedUser.signatures.mergeSignatures(pkg.mSignatures,false)) {
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      removeExisting=true;
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(""String_Node_Str"");
          for (int j=0; j < names.length; j++) {
            if (mProviders.containsKey(names[j])) {
              PackageParser.Provider other=mProviders.get(names[j]);
              Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
              mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
              return null;
            }
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  if (removeExisting) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    if (mInstaller != null) {
      int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
      if (ret != 0) {
        String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
        reportSettingsProblem(Log.WARN,msg);
        mLastScanError=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
        return null;
      }
    }
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  }
  if (pkg.mAdoptPermissions != null) {
    for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
      String origName=pkg.mAdoptPermissions.get(i);
      PackageSetting orig=mSettings.peekPackageLP(origName);
      if (orig != null) {
        if (verifyPackageUpdate(orig,pkg)) {
          Slog.i(TAG,""String_Node_Str"" + origName + ""String_Node_Str""+ pkg.packageName);
          mSettings.transferPermissions(origName,pkg.packageName);
        }
      }
    }
  }
  long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  final boolean scanFileNewer=forceDex || scanFileTime != pkgSetting.getTimeStamp();
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),""String_Node_Str"");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    dataPath=getDataPathForPackage(pkg);
    boolean uidError=false;
    if (dataPath.exists()) {
      mOutPermissions[1]=0;
      FileUtils.getPermissions(dataPath.getPath(),mOutPermissions);
      if (mOutPermissions[1] == pkg.applicationInfo.uid || !Process.supportsProcesses()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        boolean recovered=false;
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
          if (mInstaller != null) {
            int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
            if (ret >= 0) {
              String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
              reportSettingsProblem(Log.WARN,msg);
              recovered=true;
              ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
              if (ret == -1) {
                msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
                reportSettingsProblem(Log.WARN,msg);
                mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
                return null;
              }
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir=""String_Node_Str"" + pkg.applicationInfo.uid + ""String_Node_Str""+ mOutPermissions[1];
          String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGV)       Log.v(TAG,""String_Node_Str"" + dataPath);
      if (mInstaller != null) {
        int ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        if (ret < 0) {
          mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          return null;
        }
      }
 else {
        dataPath.mkdirs();
        if (dataPath.exists()) {
          FileUtils.setPermissions(dataPath.toString(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        }
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  if (mInstaller != null) {
    String path=scanFile.getPath();
    if (scanFileNewer) {
      Log.i(TAG,path + ""String_Node_Str"");
      int err=cachePackageSharedLibsLI(pkg,dataPath,scanFile);
      if (err != PackageManager.INSTALL_SUCCEEDED) {
        mLastScanError=err;
        return null;
      }
    }
    pkg.mScanPath=path;
    if ((scanMode & SCAN_NO_DEX) == 0) {
      if (performDexOptLI(pkg,forceDex) == DEX_OPT_FAILED) {
        mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
        return null;
      }
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid);
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.mPath,pkg);
    }
    mSettings.insertPackageSettingLP(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    mSettings.mPackagesToBeCleaned.remove(pkgName);
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProvidersByComponent.put(new ComponentName(p.info.packageName,p.info.name),p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(""String_Node_Str"");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProviders.containsKey(names[j])) {
            mProviders.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ""String_Node_Str"" + names[j];
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)             Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
          }
 else {
            PackageParser.Provider other=mProviders.get(names[j]);
            Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pg.info.name + ""String_Node_Str""+ pg.info.packageName+ ""String_Node_Str""+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ tree.name+ ""String_Node_Str""+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ p.group);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}","private PackageParser.Package scanPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode){
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if (pkg == null) {
    mLastScanError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if (pkg.packageName.equals(""String_Node_Str"")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + mScanningPath);
        Slog.w(TAG,""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      mResolveActivity.applicationInfo=mAndroidApplication;
      mResolveActivity.name=ResolverActivity.class.getName();
      mResolveActivity.packageName=mAndroidApplication.packageName;
      mResolveActivity.processName=mAndroidApplication.processName;
      mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
      mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
      mResolveActivity.theme=com.android.internal.R.style.Theme_Dialog_Alert;
      mResolveActivity.exported=true;
      mResolveActivity.enabled=true;
      mResolveInfo.activityInfo=mResolveActivity;
      mResolveInfo.priority=0;
      mResolveInfo.preferredOrder=0;
      mResolveInfo.match=0;
      mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
    }
  }
  if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.packageName);
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    Slog.w(TAG,""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {
      if (mTmpSharedLibraries == null || mTmpSharedLibraries.length < mSharedLibraries.size()) {
        mTmpSharedLibraries=new String[mSharedLibraries.size()];
      }
      int num=0;
      int N=pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesLibraries.get(i));
        if (file == null) {
          Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesLibraries.get(i)+ ""String_Node_Str"");
          mLastScanError=PackageManager.INSTALL_FAILED_MISSING_SHARED_LIBRARY;
          return null;
        }
        mTmpSharedLibraries[num]=file;
        num++;
      }
      N=pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));
        if (file == null) {
          Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesOptionalLibraries.get(i)+ ""String_Node_Str"");
        }
 else {
          mTmpSharedLibraries[num]=file;
          num++;
        }
      }
      if (num > 0) {
        pkg.usesLibraryFiles=new String[num];
        System.arraycopy(mTmpSharedLibraries,0,pkg.usesLibraryFiles,0,num);
      }
      if (pkg.reqFeatures != null) {
        N=pkg.reqFeatures.size();
        for (int i=0; i < N; i++) {
          FeatureInfo fi=pkg.reqFeatures.get(i);
          if ((fi.flags & FeatureInfo.FLAG_REQUIRED) == 0) {
            continue;
          }
          if (fi.name != null) {
            if (mAvailableFeatures.get(fi.name) == null) {
              Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ fi.name+ ""String_Node_Str"");
              mLastScanError=PackageManager.INSTALL_FAILED_MISSING_FEATURE;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLP(pkg.mSharedUserId,pkg.applicationInfo.flags,true);
      if (suid == null) {
        Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + pkg.mSharedUserId + ""String_Node_Str""+ suid.userId+ ""String_Node_Str""+ suid.packages);
      }
    }
    if (false) {
      if (pkg.mOriginalPackages != null) {
        Log.w(TAG,""String_Node_Str"");
        Debug.waitForDebugger();
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.mOriginalPackages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLP(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdate(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,""String_Node_Str"" + origPackage.name + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ origPackage.sharedUser.name+ ""String_Node_Str""+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    }
    pkgSetting=mSettings.getPackageLP(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.flags,true,false);
    if (pkgSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg=""String_Node_Str"" + pkgSetting.realName + ""String_Node_Str""+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.mDisabledSysPackages.get(pkg.packageName) != null) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    pkg.applicationInfo.uid=pkgSetting.userId;
    pkg.mExtras=pkgSetting;
    if (!verifySignaturesLP(pkgSetting,pkg,parseFlags,(scanMode & SCAN_UPDATE_SIGNATURE) != 0)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (!pkgSetting.sharedUser.signatures.mergeSignatures(pkg.mSignatures,false)) {
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
      reportSettingsProblem(Log.WARN,msg);
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(""String_Node_Str"");
          for (int j=0; j < names.length; j++) {
            if (mProviders.containsKey(names[j])) {
              PackageParser.Provider other=mProviders.get(names[j]);
              Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
              mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
              return null;
            }
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  if (pkg.mAdoptPermissions != null) {
    for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
      String origName=pkg.mAdoptPermissions.get(i);
      PackageSetting orig=mSettings.peekPackageLP(origName);
      if (orig != null) {
        if (verifyPackageUpdate(orig,pkg)) {
          Slog.i(TAG,""String_Node_Str"" + origName + ""String_Node_Str""+ pkg.packageName);
          mSettings.transferPermissions(origName,pkg.packageName);
        }
      }
    }
  }
  long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  final boolean scanFileNewer=forceDex || scanFileTime != pkgSetting.getTimeStamp();
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),""String_Node_Str"");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    dataPath=getDataPathForPackage(pkg);
    boolean uidError=false;
    if (dataPath.exists()) {
      mOutPermissions[1]=0;
      FileUtils.getPermissions(dataPath.getPath(),mOutPermissions);
      if (mOutPermissions[1] == pkg.applicationInfo.uid || !Process.supportsProcesses()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        boolean recovered=false;
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
          if (mInstaller != null) {
            int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
            if (ret >= 0) {
              String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
              reportSettingsProblem(Log.WARN,msg);
              recovered=true;
              ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
              if (ret == -1) {
                msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
                reportSettingsProblem(Log.WARN,msg);
                mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
                return null;
              }
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir=""String_Node_Str"" + pkg.applicationInfo.uid + ""String_Node_Str""+ mOutPermissions[1];
          String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGV)       Log.v(TAG,""String_Node_Str"" + dataPath);
      if (mInstaller != null) {
        int ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        if (ret < 0) {
          mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          return null;
        }
      }
 else {
        dataPath.mkdirs();
        if (dataPath.exists()) {
          FileUtils.setPermissions(dataPath.toString(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        }
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  if (mInstaller != null) {
    String path=scanFile.getPath();
    if (scanFileNewer) {
      Log.i(TAG,path + ""String_Node_Str"");
      int err=cachePackageSharedLibsLI(pkg,dataPath,scanFile);
      if (err != PackageManager.INSTALL_SUCCEEDED) {
        mLastScanError=err;
        return null;
      }
    }
    pkg.mScanPath=path;
    if ((scanMode & SCAN_NO_DEX) == 0) {
      if (performDexOptLI(pkg,forceDex) == DEX_OPT_FAILED) {
        mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
        return null;
      }
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid);
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.mPath,pkg);
    }
    mSettings.insertPackageSettingLP(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    mSettings.mPackagesToBeCleaned.remove(pkgName);
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProvidersByComponent.put(new ComponentName(p.info.packageName,p.info.name),p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(""String_Node_Str"");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProviders.containsKey(names[j])) {
            mProviders.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ""String_Node_Str"" + names[j];
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)             Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
          }
 else {
            PackageParser.Provider other=mProviders.get(names[j]);
            Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pg.info.name + ""String_Node_Str""+ pg.info.packageName+ ""String_Node_Str""+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ tree.name+ ""String_Node_Str""+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ p.group);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}"
22780,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
22781,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}"
22782,"private PackageParser.Package scanPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode){
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if (pkg == null) {
    mLastScanError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if (pkg.packageName.equals(""String_Node_Str"")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + mScanningPath);
        Slog.w(TAG,""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      mResolveActivity.applicationInfo=mAndroidApplication;
      mResolveActivity.name=ResolverActivity.class.getName();
      mResolveActivity.packageName=mAndroidApplication.packageName;
      mResolveActivity.processName=mAndroidApplication.processName;
      mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
      mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
      mResolveActivity.theme=com.android.internal.R.style.Theme_Dialog_Alert;
      mResolveActivity.exported=true;
      mResolveActivity.enabled=true;
      mResolveInfo.activityInfo=mResolveActivity;
      mResolveInfo.priority=0;
      mResolveInfo.preferredOrder=0;
      mResolveInfo.match=0;
      mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
    }
  }
  if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.packageName);
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    Slog.w(TAG,""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  boolean removeExisting=false;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {
      if (mTmpSharedLibraries == null || mTmpSharedLibraries.length < mSharedLibraries.size()) {
        mTmpSharedLibraries=new String[mSharedLibraries.size()];
      }
      int num=0;
      int N=pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesLibraries.get(i));
        if (file == null) {
          Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesLibraries.get(i)+ ""String_Node_Str"");
          mLastScanError=PackageManager.INSTALL_FAILED_MISSING_SHARED_LIBRARY;
          return null;
        }
        mTmpSharedLibraries[num]=file;
        num++;
      }
      N=pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));
        if (file == null) {
          Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesOptionalLibraries.get(i)+ ""String_Node_Str"");
        }
 else {
          mTmpSharedLibraries[num]=file;
          num++;
        }
      }
      if (num > 0) {
        pkg.usesLibraryFiles=new String[num];
        System.arraycopy(mTmpSharedLibraries,0,pkg.usesLibraryFiles,0,num);
      }
      if (pkg.reqFeatures != null) {
        N=pkg.reqFeatures.size();
        for (int i=0; i < N; i++) {
          FeatureInfo fi=pkg.reqFeatures.get(i);
          if ((fi.flags & FeatureInfo.FLAG_REQUIRED) == 0) {
            continue;
          }
          if (fi.name != null) {
            if (mAvailableFeatures.get(fi.name) == null) {
              Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ fi.name+ ""String_Node_Str"");
              mLastScanError=PackageManager.INSTALL_FAILED_MISSING_FEATURE;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLP(pkg.mSharedUserId,pkg.applicationInfo.flags,true);
      if (suid == null) {
        Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + pkg.mSharedUserId + ""String_Node_Str""+ suid.userId+ ""String_Node_Str""+ suid.packages);
      }
    }
    if (false) {
      if (pkg.mOriginalPackages != null) {
        Log.w(TAG,""String_Node_Str"");
        Debug.waitForDebugger();
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.mOriginalPackages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLP(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdate(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,""String_Node_Str"" + origPackage.name + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ origPackage.sharedUser.name+ ""String_Node_Str""+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    }
    pkgSetting=mSettings.getPackageLP(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.flags,true,false);
    if (pkgSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg=""String_Node_Str"" + pkgSetting.realName + ""String_Node_Str""+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.mDisabledSysPackages.get(pkg.packageName) != null) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    pkg.applicationInfo.uid=pkgSetting.userId;
    pkg.mExtras=pkgSetting;
    if (!verifySignaturesLP(pkgSetting,pkg,parseFlags,(scanMode & SCAN_UPDATE_SIGNATURE) != 0)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) == 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (!pkgSetting.sharedUser.signatures.mergeSignatures(pkg.mSignatures,false)) {
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      removeExisting=true;
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(""String_Node_Str"");
          for (int j=0; j < names.length; j++) {
            if (mProviders.containsKey(names[j])) {
              PackageParser.Provider other=mProviders.get(names[j]);
              Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
              mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
              return null;
            }
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  if (removeExisting) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    if (mInstaller != null) {
      int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
      if (ret != 0) {
        String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
        reportSettingsProblem(Log.WARN,msg);
        mLastScanError=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
        return null;
      }
    }
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  }
  if (pkg.mAdoptPermissions != null) {
    for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
      String origName=pkg.mAdoptPermissions.get(i);
      PackageSetting orig=mSettings.peekPackageLP(origName);
      if (orig != null) {
        if (verifyPackageUpdate(orig,pkg)) {
          Slog.i(TAG,""String_Node_Str"" + origName + ""String_Node_Str""+ pkg.packageName);
          mSettings.transferPermissions(origName,pkg.packageName);
        }
      }
    }
  }
  long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  final boolean scanFileNewer=forceDex || scanFileTime != pkgSetting.getTimeStamp();
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),""String_Node_Str"");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    dataPath=getDataPathForPackage(pkg);
    boolean uidError=false;
    if (dataPath.exists()) {
      mOutPermissions[1]=0;
      FileUtils.getPermissions(dataPath.getPath(),mOutPermissions);
      if (mOutPermissions[1] == pkg.applicationInfo.uid || !Process.supportsProcesses()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        boolean recovered=false;
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
          if (mInstaller != null) {
            int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
            if (ret >= 0) {
              String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
              reportSettingsProblem(Log.WARN,msg);
              recovered=true;
              ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
              if (ret == -1) {
                msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
                reportSettingsProblem(Log.WARN,msg);
                mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
                return null;
              }
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir=""String_Node_Str"" + pkg.applicationInfo.uid + ""String_Node_Str""+ mOutPermissions[1];
          String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGV)       Log.v(TAG,""String_Node_Str"" + dataPath);
      if (mInstaller != null) {
        int ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        if (ret < 0) {
          mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          return null;
        }
      }
 else {
        dataPath.mkdirs();
        if (dataPath.exists()) {
          FileUtils.setPermissions(dataPath.toString(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        }
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  if (mInstaller != null) {
    String path=scanFile.getPath();
    if (scanFileNewer) {
      Log.i(TAG,path + ""String_Node_Str"");
      int err=cachePackageSharedLibsLI(pkg,dataPath,scanFile);
      if (err != PackageManager.INSTALL_SUCCEEDED) {
        mLastScanError=err;
        return null;
      }
    }
    pkg.mScanPath=path;
    if ((scanMode & SCAN_NO_DEX) == 0) {
      if (performDexOptLI(pkg,forceDex) == DEX_OPT_FAILED) {
        mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
        return null;
      }
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid);
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.mPath,pkg);
    }
    mSettings.insertPackageSettingLP(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    mSettings.mPackagesToBeCleaned.remove(pkgName);
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProvidersByComponent.put(new ComponentName(p.info.packageName,p.info.name),p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(""String_Node_Str"");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProviders.containsKey(names[j])) {
            mProviders.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ""String_Node_Str"" + names[j];
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)             Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
          }
 else {
            PackageParser.Provider other=mProviders.get(names[j]);
            Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pg.info.name + ""String_Node_Str""+ pg.info.packageName+ ""String_Node_Str""+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ tree.name+ ""String_Node_Str""+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ p.group);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}","private PackageParser.Package scanPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode){
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if (pkg == null) {
    mLastScanError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if (pkg.packageName.equals(""String_Node_Str"")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + mScanningPath);
        Slog.w(TAG,""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      mResolveActivity.applicationInfo=mAndroidApplication;
      mResolveActivity.name=ResolverActivity.class.getName();
      mResolveActivity.packageName=mAndroidApplication.packageName;
      mResolveActivity.processName=mAndroidApplication.processName;
      mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
      mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
      mResolveActivity.theme=com.android.internal.R.style.Theme_Dialog_Alert;
      mResolveActivity.exported=true;
      mResolveActivity.enabled=true;
      mResolveInfo.activityInfo=mResolveActivity;
      mResolveInfo.priority=0;
      mResolveInfo.preferredOrder=0;
      mResolveInfo.match=0;
      mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
    }
  }
  if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.packageName);
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    Slog.w(TAG,""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {
      if (mTmpSharedLibraries == null || mTmpSharedLibraries.length < mSharedLibraries.size()) {
        mTmpSharedLibraries=new String[mSharedLibraries.size()];
      }
      int num=0;
      int N=pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesLibraries.get(i));
        if (file == null) {
          Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesLibraries.get(i)+ ""String_Node_Str"");
          mLastScanError=PackageManager.INSTALL_FAILED_MISSING_SHARED_LIBRARY;
          return null;
        }
        mTmpSharedLibraries[num]=file;
        num++;
      }
      N=pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));
        if (file == null) {
          Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesOptionalLibraries.get(i)+ ""String_Node_Str"");
        }
 else {
          mTmpSharedLibraries[num]=file;
          num++;
        }
      }
      if (num > 0) {
        pkg.usesLibraryFiles=new String[num];
        System.arraycopy(mTmpSharedLibraries,0,pkg.usesLibraryFiles,0,num);
      }
      if (pkg.reqFeatures != null) {
        N=pkg.reqFeatures.size();
        for (int i=0; i < N; i++) {
          FeatureInfo fi=pkg.reqFeatures.get(i);
          if ((fi.flags & FeatureInfo.FLAG_REQUIRED) == 0) {
            continue;
          }
          if (fi.name != null) {
            if (mAvailableFeatures.get(fi.name) == null) {
              Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ fi.name+ ""String_Node_Str"");
              mLastScanError=PackageManager.INSTALL_FAILED_MISSING_FEATURE;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLP(pkg.mSharedUserId,pkg.applicationInfo.flags,true);
      if (suid == null) {
        Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + pkg.mSharedUserId + ""String_Node_Str""+ suid.userId+ ""String_Node_Str""+ suid.packages);
      }
    }
    if (false) {
      if (pkg.mOriginalPackages != null) {
        Log.w(TAG,""String_Node_Str"");
        Debug.waitForDebugger();
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.mOriginalPackages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLP(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdate(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,""String_Node_Str"" + origPackage.name + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ origPackage.sharedUser.name+ ""String_Node_Str""+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    }
    pkgSetting=mSettings.getPackageLP(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.flags,true,false);
    if (pkgSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg=""String_Node_Str"" + pkgSetting.realName + ""String_Node_Str""+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.mDisabledSysPackages.get(pkg.packageName) != null) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    pkg.applicationInfo.uid=pkgSetting.userId;
    pkg.mExtras=pkgSetting;
    if (!verifySignaturesLP(pkgSetting,pkg,parseFlags,(scanMode & SCAN_UPDATE_SIGNATURE) != 0)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (!pkgSetting.sharedUser.signatures.mergeSignatures(pkg.mSignatures,false)) {
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
      reportSettingsProblem(Log.WARN,msg);
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(""String_Node_Str"");
          for (int j=0; j < names.length; j++) {
            if (mProviders.containsKey(names[j])) {
              PackageParser.Provider other=mProviders.get(names[j]);
              Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
              mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
              return null;
            }
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  if (pkg.mAdoptPermissions != null) {
    for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
      String origName=pkg.mAdoptPermissions.get(i);
      PackageSetting orig=mSettings.peekPackageLP(origName);
      if (orig != null) {
        if (verifyPackageUpdate(orig,pkg)) {
          Slog.i(TAG,""String_Node_Str"" + origName + ""String_Node_Str""+ pkg.packageName);
          mSettings.transferPermissions(origName,pkg.packageName);
        }
      }
    }
  }
  long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  final boolean scanFileNewer=forceDex || scanFileTime != pkgSetting.getTimeStamp();
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),""String_Node_Str"");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    dataPath=getDataPathForPackage(pkg);
    boolean uidError=false;
    if (dataPath.exists()) {
      mOutPermissions[1]=0;
      FileUtils.getPermissions(dataPath.getPath(),mOutPermissions);
      if (mOutPermissions[1] == pkg.applicationInfo.uid || !Process.supportsProcesses()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        boolean recovered=false;
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
          if (mInstaller != null) {
            int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
            if (ret >= 0) {
              String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
              reportSettingsProblem(Log.WARN,msg);
              recovered=true;
              ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
              if (ret == -1) {
                msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
                reportSettingsProblem(Log.WARN,msg);
                mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
                return null;
              }
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir=""String_Node_Str"" + pkg.applicationInfo.uid + ""String_Node_Str""+ mOutPermissions[1];
          String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGV)       Log.v(TAG,""String_Node_Str"" + dataPath);
      if (mInstaller != null) {
        int ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        if (ret < 0) {
          mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          return null;
        }
      }
 else {
        dataPath.mkdirs();
        if (dataPath.exists()) {
          FileUtils.setPermissions(dataPath.toString(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        }
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  if (mInstaller != null) {
    String path=scanFile.getPath();
    if (scanFileNewer) {
      Log.i(TAG,path + ""String_Node_Str"");
      int err=cachePackageSharedLibsLI(pkg,dataPath,scanFile);
      if (err != PackageManager.INSTALL_SUCCEEDED) {
        mLastScanError=err;
        return null;
      }
    }
    pkg.mScanPath=path;
    if ((scanMode & SCAN_NO_DEX) == 0) {
      if (performDexOptLI(pkg,forceDex) == DEX_OPT_FAILED) {
        mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
        return null;
      }
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid);
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.mPath,pkg);
    }
    mSettings.insertPackageSettingLP(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    mSettings.mPackagesToBeCleaned.remove(pkgName);
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProvidersByComponent.put(new ComponentName(p.info.packageName,p.info.name),p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(""String_Node_Str"");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProviders.containsKey(names[j])) {
            mProviders.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ""String_Node_Str"" + names[j];
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)             Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
          }
 else {
            PackageParser.Provider other=mProviders.get(names[j]);
            Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pg.info.name + ""String_Node_Str""+ pg.info.packageName+ ""String_Node_Str""+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ tree.name+ ""String_Node_Str""+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ p.group);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}"
22783,"@Override protected void onRestoreInstanceState(Bundle state){
  super.onRestoreInstanceState(state);
  Bundle container=state.getBundle(PREFERENCES_TAG);
  if (container != null) {
    final PreferenceScreen preferenceScreen=getPreferenceScreen();
    if (preferenceScreen != null) {
      preferenceScreen.restoreHierarchyState(container);
    }
  }
}","@Override protected void onRestoreInstanceState(Bundle state){
  Bundle container=state.getBundle(PREFERENCES_TAG);
  if (container != null) {
    final PreferenceScreen preferenceScreen=getPreferenceScreen();
    if (preferenceScreen != null) {
      preferenceScreen.restoreHierarchyState(container);
      mSavedInstanceState=state;
      return;
    }
  }
  super.onRestoreInstanceState(state);
}"
22784,"private void bindPreferences(){
  final PreferenceScreen preferenceScreen=getPreferenceScreen();
  if (preferenceScreen != null) {
    preferenceScreen.bind(getListView());
  }
}","private void bindPreferences(){
  final PreferenceScreen preferenceScreen=getPreferenceScreen();
  if (preferenceScreen != null) {
    preferenceScreen.bind(getListView());
    if (mSavedInstanceState != null) {
      super.onRestoreInstanceState(mSavedInstanceState);
      mSavedInstanceState=null;
    }
  }
}"
22785,"@Override protected void onRestoreInstanceState(Bundle state){
  super.onRestoreInstanceState(state);
  Bundle container=state.getBundle(PREFERENCES_TAG);
  if (container != null) {
    final PreferenceScreen preferenceScreen=getPreferenceScreen();
    if (preferenceScreen != null) {
      preferenceScreen.restoreHierarchyState(container);
    }
  }
}","@Override protected void onRestoreInstanceState(Bundle state){
  Bundle container=state.getBundle(PREFERENCES_TAG);
  if (container != null) {
    final PreferenceScreen preferenceScreen=getPreferenceScreen();
    if (preferenceScreen != null) {
      preferenceScreen.restoreHierarchyState(container);
      mSavedInstanceState=state;
      return;
    }
  }
  super.onRestoreInstanceState(state);
}"
22786,"private void bindPreferences(){
  final PreferenceScreen preferenceScreen=getPreferenceScreen();
  if (preferenceScreen != null) {
    preferenceScreen.bind(getListView());
  }
}","private void bindPreferences(){
  final PreferenceScreen preferenceScreen=getPreferenceScreen();
  if (preferenceScreen != null) {
    preferenceScreen.bind(getListView());
    if (mSavedInstanceState != null) {
      super.onRestoreInstanceState(mSavedInstanceState);
      mSavedInstanceState=null;
    }
  }
}"
22787,"/** 
 * Updates the engine configuration.
 */
public int setConfig(String engineConfig){
  return native_setConfig(engineConfig);
}","/** 
 * Updates the engine configuration.
 */
public int setConfig(String engineConfig){
  return native_setConfig(mJniData,engineConfig);
}"
22788,private native final int native_setConfig(String engineConfig);,"private native final int native_setConfig(int jniData,String engineConfig);"
22789,"private final void attach(boolean system){
  sThreadLocal.set(this);
  mSystemThread=system;
  if (!system) {
    ViewRoot.addFirstDrawHandler(new Runnable(){
      public void run(){
        ensureJitEnabled();
      }
    }
);
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    RuntimeInit.setApplicationObject(mAppThread.asBinder());
    IActivityManager mgr=ActivityManagerNative.getDefault();
    try {
      mgr.attachApplication(mAppThread);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    try {
      mInstrumentation=new Instrumentation();
      ContextImpl context=new ContextImpl();
      context.init(getSystemContext().mPackageInfo,null,this);
      Application app=Instrumentation.newApplication(Application.class,context);
      mAllApplications.add(app);
      mInitialApplication=app;
      app.onCreate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.toString(),e);
    }
  }
  ViewRoot.addConfigCallback(new ComponentCallbacks(){
    public void onConfigurationChanged(    Configuration newConfig){
synchronized (mPackages) {
        if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
          mPendingConfiguration=newConfig;
          applyConfigurationToResourcesLocked(newConfig);
        }
      }
      queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
    }
    public void onLowMemory(){
    }
  }
);
}","private final void attach(boolean system){
  sThreadLocal.set(this);
  mSystemThread=system;
  if (!system) {
    ViewRoot.addFirstDrawHandler(new Runnable(){
      public void run(){
        ensureJitEnabled();
      }
    }
);
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    RuntimeInit.setApplicationObject(mAppThread.asBinder());
    IActivityManager mgr=ActivityManagerNative.getDefault();
    try {
      mgr.attachApplication(mAppThread);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    try {
      mInstrumentation=new Instrumentation();
      ContextImpl context=new ContextImpl();
      context.init(getSystemContext().mPackageInfo,null,this);
      Application app=Instrumentation.newApplication(Application.class,context);
      mAllApplications.add(app);
      mInitialApplication=app;
      app.onCreate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.toString(),e);
    }
  }
  ViewRoot.addConfigCallback(new ComponentCallbacks(){
    public void onConfigurationChanged(    Configuration newConfig){
synchronized (mPackages) {
        if (applyConfigurationToResourcesLocked(newConfig)) {
          if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
            mPendingConfiguration=newConfig;
            queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
          }
        }
      }
    }
    public void onLowMemory(){
    }
  }
);
}"
22790,"public void onConfigurationChanged(Configuration newConfig){
synchronized (mPackages) {
    if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
      mPendingConfiguration=newConfig;
      applyConfigurationToResourcesLocked(newConfig);
    }
  }
  queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
}","public void onConfigurationChanged(Configuration newConfig){
synchronized (mPackages) {
    if (applyConfigurationToResourcesLocked(newConfig)) {
      if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
        mPendingConfiguration=newConfig;
        queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
      }
    }
  }
}"
22791,"final void applyConfigurationToResourcesLocked(Configuration config){
  if (mResConfiguration == null) {
    mResConfiguration=new Configuration();
  }
  if (!mResConfiguration.isOtherSeqNewer(config)) {
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + mResConfiguration.seq + ""String_Node_Str""+ config.seq);
    return;
  }
  mResConfiguration.updateFrom(config);
  DisplayMetrics dm=getDisplayMetricsLocked(true);
  if (config.locale != null) {
    Locale.setDefault(config.locale);
  }
  Resources.updateSystemConfiguration(config,dm);
  ContextImpl.ApplicationPackageManager.configurationChanged();
  Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
  while (it.hasNext()) {
    WeakReference<Resources> v=it.next();
    Resources r=v.get();
    if (r != null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ config);
      r.updateConfiguration(config,dm);
    }
 else {
      it.remove();
    }
  }
}","final boolean applyConfigurationToResourcesLocked(Configuration config){
  if (mResConfiguration == null) {
    mResConfiguration=new Configuration();
  }
  if (!mResConfiguration.isOtherSeqNewer(config)) {
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + mResConfiguration.seq + ""String_Node_Str""+ config.seq);
    return false;
  }
  int changes=mResConfiguration.updateFrom(config);
  DisplayMetrics dm=getDisplayMetricsLocked(true);
  if (config.locale != null) {
    Locale.setDefault(config.locale);
  }
  Resources.updateSystemConfiguration(config,dm);
  ContextImpl.ApplicationPackageManager.configurationChanged();
  Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
  while (it.hasNext()) {
    WeakReference<Resources> v=it.next();
    Resources r=v.get();
    if (r != null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ config);
      r.updateConfiguration(config,dm);
    }
 else {
      it.remove();
    }
  }
  return changes != 0;
}"
22792,"private final void attach(boolean system){
  sThreadLocal.set(this);
  mSystemThread=system;
  if (!system) {
    ViewRoot.addFirstDrawHandler(new Runnable(){
      public void run(){
        ensureJitEnabled();
      }
    }
);
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    RuntimeInit.setApplicationObject(mAppThread.asBinder());
    IActivityManager mgr=ActivityManagerNative.getDefault();
    try {
      mgr.attachApplication(mAppThread);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    try {
      mInstrumentation=new Instrumentation();
      ContextImpl context=new ContextImpl();
      context.init(getSystemContext().mPackageInfo,null,this);
      Application app=Instrumentation.newApplication(Application.class,context);
      mAllApplications.add(app);
      mInitialApplication=app;
      app.onCreate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.toString(),e);
    }
  }
  ViewRoot.addConfigCallback(new ComponentCallbacks(){
    public void onConfigurationChanged(    Configuration newConfig){
synchronized (mPackages) {
        if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
          mPendingConfiguration=newConfig;
          applyConfigurationToResourcesLocked(newConfig);
        }
      }
      queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
    }
    public void onLowMemory(){
    }
  }
);
}","private final void attach(boolean system){
  sThreadLocal.set(this);
  mSystemThread=system;
  if (!system) {
    ViewRoot.addFirstDrawHandler(new Runnable(){
      public void run(){
        ensureJitEnabled();
      }
    }
);
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    RuntimeInit.setApplicationObject(mAppThread.asBinder());
    IActivityManager mgr=ActivityManagerNative.getDefault();
    try {
      mgr.attachApplication(mAppThread);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    try {
      mInstrumentation=new Instrumentation();
      ContextImpl context=new ContextImpl();
      context.init(getSystemContext().mPackageInfo,null,this);
      Application app=Instrumentation.newApplication(Application.class,context);
      mAllApplications.add(app);
      mInitialApplication=app;
      app.onCreate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.toString(),e);
    }
  }
  ViewRoot.addConfigCallback(new ComponentCallbacks(){
    public void onConfigurationChanged(    Configuration newConfig){
synchronized (mPackages) {
        if (applyConfigurationToResourcesLocked(newConfig)) {
          if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
            mPendingConfiguration=newConfig;
            queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
          }
        }
      }
    }
    public void onLowMemory(){
    }
  }
);
}"
22793,"public void onConfigurationChanged(Configuration newConfig){
synchronized (mPackages) {
    if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
      mPendingConfiguration=newConfig;
      applyConfigurationToResourcesLocked(newConfig);
    }
  }
  queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
}","public void onConfigurationChanged(Configuration newConfig){
synchronized (mPackages) {
    if (applyConfigurationToResourcesLocked(newConfig)) {
      if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
        mPendingConfiguration=newConfig;
        queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
      }
    }
  }
}"
22794,"final void applyConfigurationToResourcesLocked(Configuration config){
  if (mResConfiguration == null) {
    mResConfiguration=new Configuration();
  }
  if (!mResConfiguration.isOtherSeqNewer(config)) {
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + mResConfiguration.seq + ""String_Node_Str""+ config.seq);
    return;
  }
  mResConfiguration.updateFrom(config);
  DisplayMetrics dm=getDisplayMetricsLocked(true);
  if (config.locale != null) {
    Locale.setDefault(config.locale);
  }
  Resources.updateSystemConfiguration(config,dm);
  ContextImpl.ApplicationPackageManager.configurationChanged();
  Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
  while (it.hasNext()) {
    WeakReference<Resources> v=it.next();
    Resources r=v.get();
    if (r != null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ config);
      r.updateConfiguration(config,dm);
    }
 else {
      it.remove();
    }
  }
}","final boolean applyConfigurationToResourcesLocked(Configuration config){
  if (mResConfiguration == null) {
    mResConfiguration=new Configuration();
  }
  if (!mResConfiguration.isOtherSeqNewer(config)) {
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + mResConfiguration.seq + ""String_Node_Str""+ config.seq);
    return false;
  }
  int changes=mResConfiguration.updateFrom(config);
  DisplayMetrics dm=getDisplayMetricsLocked(true);
  if (config.locale != null) {
    Locale.setDefault(config.locale);
  }
  Resources.updateSystemConfiguration(config,dm);
  ContextImpl.ApplicationPackageManager.configurationChanged();
  Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
  while (it.hasNext()) {
    WeakReference<Resources> v=it.next();
    Resources r=v.get();
    if (r != null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ config);
      r.updateConfiguration(config,dm);
    }
 else {
      it.remove();
    }
  }
  return changes != 0;
}"
22795,"private final void attach(boolean system){
  sThreadLocal.set(this);
  mSystemThread=system;
  if (!system) {
    ViewRoot.addFirstDrawHandler(new Runnable(){
      public void run(){
        ensureJitEnabled();
      }
    }
);
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    RuntimeInit.setApplicationObject(mAppThread.asBinder());
    IActivityManager mgr=ActivityManagerNative.getDefault();
    try {
      mgr.attachApplication(mAppThread);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    try {
      mInstrumentation=new Instrumentation();
      ContextImpl context=new ContextImpl();
      context.init(getSystemContext().mPackageInfo,null,this);
      Application app=Instrumentation.newApplication(Application.class,context);
      mAllApplications.add(app);
      mInitialApplication=app;
      app.onCreate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.toString(),e);
    }
  }
  ViewRoot.addConfigCallback(new ComponentCallbacks(){
    public void onConfigurationChanged(    Configuration newConfig){
synchronized (mPackages) {
        if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
          mPendingConfiguration=newConfig;
          applyConfigurationToResourcesLocked(newConfig);
        }
      }
      queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
    }
    public void onLowMemory(){
    }
  }
);
}","private final void attach(boolean system){
  sThreadLocal.set(this);
  mSystemThread=system;
  if (!system) {
    ViewRoot.addFirstDrawHandler(new Runnable(){
      public void run(){
        ensureJitEnabled();
      }
    }
);
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    RuntimeInit.setApplicationObject(mAppThread.asBinder());
    IActivityManager mgr=ActivityManagerNative.getDefault();
    try {
      mgr.attachApplication(mAppThread);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    try {
      mInstrumentation=new Instrumentation();
      ContextImpl context=new ContextImpl();
      context.init(getSystemContext().mPackageInfo,null,this);
      Application app=Instrumentation.newApplication(Application.class,context);
      mAllApplications.add(app);
      mInitialApplication=app;
      app.onCreate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.toString(),e);
    }
  }
  ViewRoot.addConfigCallback(new ComponentCallbacks(){
    public void onConfigurationChanged(    Configuration newConfig){
synchronized (mPackages) {
        if (applyConfigurationToResourcesLocked(newConfig)) {
          if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
            mPendingConfiguration=newConfig;
            queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
          }
        }
      }
    }
    public void onLowMemory(){
    }
  }
);
}"
22796,"public void onConfigurationChanged(Configuration newConfig){
synchronized (mPackages) {
    if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
      mPendingConfiguration=newConfig;
      applyConfigurationToResourcesLocked(newConfig);
    }
  }
  queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
}","public void onConfigurationChanged(Configuration newConfig){
synchronized (mPackages) {
    if (applyConfigurationToResourcesLocked(newConfig)) {
      if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
        mPendingConfiguration=newConfig;
        queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
      }
    }
  }
}"
22797,"final void applyConfigurationToResourcesLocked(Configuration config){
  if (mResConfiguration == null) {
    mResConfiguration=new Configuration();
  }
  if (!mResConfiguration.isOtherSeqNewer(config)) {
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + mResConfiguration.seq + ""String_Node_Str""+ config.seq);
    return;
  }
  mResConfiguration.updateFrom(config);
  DisplayMetrics dm=getDisplayMetricsLocked(true);
  if (config.locale != null) {
    Locale.setDefault(config.locale);
  }
  Resources.updateSystemConfiguration(config,dm);
  ContextImpl.ApplicationPackageManager.configurationChanged();
  Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
  while (it.hasNext()) {
    WeakReference<Resources> v=it.next();
    Resources r=v.get();
    if (r != null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ config);
      r.updateConfiguration(config,dm);
    }
 else {
      it.remove();
    }
  }
}","final boolean applyConfigurationToResourcesLocked(Configuration config){
  if (mResConfiguration == null) {
    mResConfiguration=new Configuration();
  }
  if (!mResConfiguration.isOtherSeqNewer(config)) {
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + mResConfiguration.seq + ""String_Node_Str""+ config.seq);
    return false;
  }
  int changes=mResConfiguration.updateFrom(config);
  DisplayMetrics dm=getDisplayMetricsLocked(true);
  if (config.locale != null) {
    Locale.setDefault(config.locale);
  }
  Resources.updateSystemConfiguration(config,dm);
  ContextImpl.ApplicationPackageManager.configurationChanged();
  Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
  while (it.hasNext()) {
    WeakReference<Resources> v=it.next();
    Resources r=v.get();
    if (r != null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ config);
      r.updateConfiguration(config,dm);
    }
 else {
      it.remove();
    }
  }
  return changes != 0;
}"
22798,"/** 
 * Updates the engine configuration.
 */
public int setConfig(String engineConfig){
  return native_setConfig(engineConfig);
}","/** 
 * Updates the engine configuration.
 */
public int setConfig(String engineConfig){
  return native_setConfig(mJniData,engineConfig);
}"
22799,private native final int native_setConfig(String engineConfig);,"private native final int native_setConfig(int jniData,String engineConfig);"
22800,"/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
setDetailedState(DetailedState.CONNECTING,Phone.REASON_APN_CHANGED,null);
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnTypeToWatchFor);
intent.putExtra(Phone.DATA_APN_KEY,mApnName);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
mEnabled=true;
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}","/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
setDetailedState(DetailedState.CONNECTING,Phone.REASON_APN_CHANGED,null);
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnTypeToWatchFor);
intent.putExtra(Phone.DATA_APN_KEY,mApnName);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
mEnabled=true;
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
if (mApnType != Phone.APN_TYPE_DEFAULT) {
mEnabled=false;
}
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}"
22801,"/** 
 * Perform any final cleanup before an activity is destroyed.  This can happen either because the activity is finishing (someone called  {@link #finish} on it, or because the system is temporarily destroyingthis instance of the activity to save space.  You can distinguish between these two scenarios with the  {@link #isFinishing} method.<p><em>Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either  {@link #onPause} or{@link #onSaveInstanceState}, not here.</em> This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running.  There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. <p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onPause
 * @see #onStop
 * @see #finish
 * @see #isFinishing
 */
protected void onDestroy(){
  mCalled=true;
  if (mManagedDialogs != null) {
    final int numDialogs=mManagedDialogs.size();
    for (int i=0; i < numDialogs; i++) {
      final ManagedDialog md=mManagedDialogs.valueAt(i);
      if (md.mDialog.isShowing()) {
        md.mDialog.dismiss();
      }
    }
    mManagedDialogs=null;
  }
synchronized (mManagedCursors) {
    int numCursors=mManagedCursors.size();
    for (int i=0; i < numCursors; i++) {
      ManagedCursor c=mManagedCursors.get(i);
      if (c != null) {
        c.mCursor.close();
      }
    }
    mManagedCursors.clear();
  }
}","/** 
 * Perform any final cleanup before an activity is destroyed.  This can happen either because the activity is finishing (someone called  {@link #finish} on it, or because the system is temporarily destroyingthis instance of the activity to save space.  You can distinguish between these two scenarios with the  {@link #isFinishing} method.<p><em>Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either  {@link #onPause} or{@link #onSaveInstanceState}, not here.</em> This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running.  There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. <p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onPause
 * @see #onStop
 * @see #finish
 * @see #isFinishing
 */
protected void onDestroy(){
  mCalled=true;
  if (mManagedDialogs != null) {
    final int numDialogs=mManagedDialogs.size();
    for (int i=0; i < numDialogs; i++) {
      final ManagedDialog md=mManagedDialogs.valueAt(i);
      if (md.mDialog.isShowing()) {
        md.mDialog.dismiss();
      }
    }
    mManagedDialogs=null;
  }
synchronized (mManagedCursors) {
    int numCursors=mManagedCursors.size();
    for (int i=0; i < numCursors; i++) {
      ManagedCursor c=mManagedCursors.get(i);
      if (c != null) {
        c.mCursor.close();
      }
    }
    mManagedCursors.clear();
  }
  if (mSearchManager != null) {
    mSearchManager.stopSearch();
  }
}"
22802,"/** 
 * Constructor - fires it up and makes it look like the search UI.
 * @param context Application Context we can use for system acess
 */
public SearchDialog(Context context,SearchManager searchManager){
  super(context,com.android.internal.R.style.Theme_SearchBar);
  mVoiceWebSearchIntent=new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
  mVoiceWebSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mVoiceWebSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);
  mVoiceAppSearchIntent=new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
  mVoiceAppSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mSearchManager=searchManager;
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
  context.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      if (intent.getAction().equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        onConfigurationChanged();
      }
    }
  }
,filter);
}","/** 
 * Constructor - fires it up and makes it look like the search UI.
 * @param context Application Context we can use for system acess
 */
public SearchDialog(Context context,SearchManager searchManager){
  super(context,com.android.internal.R.style.Theme_SearchBar);
  mVoiceWebSearchIntent=new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
  mVoiceWebSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mVoiceWebSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);
  mVoiceAppSearchIntent=new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
  mVoiceAppSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mSearchManager=searchManager;
}"
22803,"/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mUserQuery=null;
}","/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  getContext().unregisterReceiver(mConfChangeListener);
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mUserQuery=null;
}"
22804,"/** 
 * Perform any final cleanup before an activity is destroyed.  This can happen either because the activity is finishing (someone called  {@link #finish} on it, or because the system is temporarily destroyingthis instance of the activity to save space.  You can distinguish between these two scenarios with the  {@link #isFinishing} method.<p><em>Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either  {@link #onPause} or{@link #onSaveInstanceState}, not here.</em> This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running.  There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. <p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onPause
 * @see #onStop
 * @see #finish
 * @see #isFinishing
 */
protected void onDestroy(){
  mCalled=true;
  if (mManagedDialogs != null) {
    final int numDialogs=mManagedDialogs.size();
    for (int i=0; i < numDialogs; i++) {
      final ManagedDialog md=mManagedDialogs.valueAt(i);
      if (md.mDialog.isShowing()) {
        md.mDialog.dismiss();
      }
    }
    mManagedDialogs=null;
  }
synchronized (mManagedCursors) {
    int numCursors=mManagedCursors.size();
    for (int i=0; i < numCursors; i++) {
      ManagedCursor c=mManagedCursors.get(i);
      if (c != null) {
        c.mCursor.close();
      }
    }
    mManagedCursors.clear();
  }
}","/** 
 * Perform any final cleanup before an activity is destroyed.  This can happen either because the activity is finishing (someone called  {@link #finish} on it, or because the system is temporarily destroyingthis instance of the activity to save space.  You can distinguish between these two scenarios with the  {@link #isFinishing} method.<p><em>Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either  {@link #onPause} or{@link #onSaveInstanceState}, not here.</em> This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running.  There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. <p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onPause
 * @see #onStop
 * @see #finish
 * @see #isFinishing
 */
protected void onDestroy(){
  mCalled=true;
  if (mManagedDialogs != null) {
    final int numDialogs=mManagedDialogs.size();
    for (int i=0; i < numDialogs; i++) {
      final ManagedDialog md=mManagedDialogs.valueAt(i);
      if (md.mDialog.isShowing()) {
        md.mDialog.dismiss();
      }
    }
    mManagedDialogs=null;
  }
synchronized (mManagedCursors) {
    int numCursors=mManagedCursors.size();
    for (int i=0; i < numCursors; i++) {
      ManagedCursor c=mManagedCursors.get(i);
      if (c != null) {
        c.mCursor.close();
      }
    }
    mManagedCursors.clear();
  }
  if (mSearchManager != null) {
    mSearchManager.stopSearch();
  }
}"
22805,"/** 
 * Constructor - fires it up and makes it look like the search UI.
 * @param context Application Context we can use for system acess
 */
public SearchDialog(Context context,SearchManager searchManager){
  super(context,com.android.internal.R.style.Theme_SearchBar);
  mVoiceWebSearchIntent=new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
  mVoiceWebSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mVoiceWebSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);
  mVoiceAppSearchIntent=new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
  mVoiceAppSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mSearchManager=searchManager;
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
  context.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      if (intent.getAction().equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        onConfigurationChanged();
      }
    }
  }
,filter);
}","/** 
 * Constructor - fires it up and makes it look like the search UI.
 * @param context Application Context we can use for system acess
 */
public SearchDialog(Context context,SearchManager searchManager){
  super(context,com.android.internal.R.style.Theme_SearchBar);
  mVoiceWebSearchIntent=new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
  mVoiceWebSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mVoiceWebSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);
  mVoiceAppSearchIntent=new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
  mVoiceAppSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mSearchManager=searchManager;
}"
22806,"/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mUserQuery=null;
}","/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  getContext().unregisterReceiver(mConfChangeListener);
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mUserQuery=null;
}"
22807,"/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
setDetailedState(DetailedState.CONNECTING,Phone.REASON_APN_CHANGED,null);
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnTypeToWatchFor);
intent.putExtra(Phone.DATA_APN_KEY,mApnName);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
mEnabled=true;
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}","/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
setDetailedState(DetailedState.CONNECTING,Phone.REASON_APN_CHANGED,null);
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnTypeToWatchFor);
intent.putExtra(Phone.DATA_APN_KEY,mApnName);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
mEnabled=true;
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
if (mApnType != Phone.APN_TYPE_DEFAULT) {
mEnabled=false;
}
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}"
22808,"private void recreateLockScreen(){
  if (mLockScreen.getVisibility() == View.VISIBLE) {
    ((KeyguardScreen)mLockScreen).onPause();
  }
  ((KeyguardScreen)mLockScreen).cleanUp();
  removeViewInLayout(mLockScreen);
  mLockScreen=createLockScreen();
  mLockScreen.setVisibility(View.INVISIBLE);
  addView(mLockScreen);
}","private void recreateLockScreen(){
  if (mLockScreen.getVisibility() == View.VISIBLE) {
    ((KeyguardScreen)mLockScreen).onPause();
  }
  ((KeyguardScreen)mLockScreen).cleanUp();
  removeView(mLockScreen);
  mLockScreen=createLockScreen();
  mLockScreen.setVisibility(View.INVISIBLE);
  addView(mLockScreen);
}"
22809,"private void updateScreen(final Mode mode){
  mMode=mode;
  if (mode == Mode.UnlockScreen && mCurrentUnlockMode != getUnlockMode()) {
    recreateUnlockScreen();
  }
  final View goneScreen=(mode == Mode.LockScreen) ? mUnlockScreen : mLockScreen;
  final View visibleScreen=(mode == Mode.LockScreen) ? mLockScreen : mUnlockScreen;
  mWindowController.setNeedsInput(((KeyguardScreen)visibleScreen).needsInput());
  if (mScreenOn) {
    if (goneScreen.getVisibility() == View.VISIBLE) {
      ((KeyguardScreen)goneScreen).onPause();
    }
    if (visibleScreen.getVisibility() != View.VISIBLE) {
      ((KeyguardScreen)visibleScreen).onResume();
    }
  }
  goneScreen.setVisibility(View.GONE);
  visibleScreen.setVisibility(View.VISIBLE);
  if (!visibleScreen.requestFocus()) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + visibleScreen.getClass().getCanonicalName());
  }
}","private void updateScreen(final Mode mode){
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + mode + ""String_Node_Str""+ mMode,new RuntimeException());
  mMode=mode;
  if (mode == Mode.UnlockScreen && mCurrentUnlockMode != getUnlockMode()) {
    recreateUnlockScreen();
  }
  final View goneScreen=(mode == Mode.LockScreen) ? mUnlockScreen : mLockScreen;
  final View visibleScreen=(mode == Mode.LockScreen) ? mLockScreen : mUnlockScreen;
  mWindowController.setNeedsInput(((KeyguardScreen)visibleScreen).needsInput());
  if (DEBUG_CONFIGURATION) {
    Log.v(TAG,""String_Node_Str"" + goneScreen);
    Log.v(TAG,""String_Node_Str"" + visibleScreen);
  }
  if (mScreenOn) {
    if (goneScreen.getVisibility() == View.VISIBLE) {
      ((KeyguardScreen)goneScreen).onPause();
    }
    if (visibleScreen.getVisibility() != View.VISIBLE) {
      ((KeyguardScreen)visibleScreen).onResume();
    }
  }
  goneScreen.setVisibility(View.GONE);
  visibleScreen.setVisibility(View.VISIBLE);
  requestLayout();
  if (!visibleScreen.requestFocus()) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + visibleScreen.getClass().getCanonicalName());
  }
}"
22810,"private void recreateUnlockScreen(){
  if (mUnlockScreen.getVisibility() == View.VISIBLE) {
    ((KeyguardScreen)mUnlockScreen).onPause();
  }
  ((KeyguardScreen)mUnlockScreen).cleanUp();
  removeViewInLayout(mUnlockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreen.setVisibility(View.INVISIBLE);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
}","private void recreateUnlockScreen(){
  if (mUnlockScreen.getVisibility() == View.VISIBLE) {
    ((KeyguardScreen)mUnlockScreen).onPause();
  }
  ((KeyguardScreen)mUnlockScreen).cleanUp();
  removeView(mUnlockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreen.setVisibility(View.INVISIBLE);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
}"
22811,"/** 
 * @param context Used to setup the view.
 * @param configuration The current configuration. Used to use when selecting layout, etc.
 * @param lockPatternUtils Used to know the state of the lock pattern settings.
 * @param updateMonitor Used to register for updates on various keyguard relatedstate, and query the initial state at setup.
 * @param callback Used to communicate back to the host keyguard view.
 */
LockScreen(Context context,Configuration configuration,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mEnableMenuKeyInLockScreen=shouldEnableMenuKey();
  mCreationOrientation=configuration.orientation;
  mKeyboardHidden=configuration.hardKeyboardHidden;
  final LayoutInflater inflater=LayoutInflater.from(context);
  if (DBG)   Log.v(TAG,""String_Node_Str"" + mCreationOrientation);
  if (mCreationOrientation != Configuration.ORIENTATION_LANDSCAPE) {
    inflater.inflate(R.layout.keyguard_screen_tab_unlock,this,true);
  }
 else {
    inflater.inflate(R.layout.keyguard_screen_tab_unlock_land,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCarrier.setSelected(true);
  mCarrier.setTextColor(0xffffffff);
  mDate=(TextView)findViewById(R.id.date);
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatus2=(TextView)findViewById(R.id.status2);
  mEmergencyCallButton=(Button)findViewById(R.id.emergencyCallButton);
  mEmergencyCallButton.setText(R.string.lockscreen_emergency_call);
  mLockPatternUtils.updateEmergencyCallButtonState(mEmergencyCallButton);
  mScreenLocked=(TextView)findViewById(R.id.screenLocked);
  mSelector=(SlidingTab)findViewById(R.id.tab_selector);
  mSelector.setHoldAfterTrigger(true,false);
  mSelector.setLeftHintText(R.string.lockscreen_unlock_label);
  mEmergencyCallButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
);
  setFocusable(true);
  setFocusableInTouchMode(true);
  setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
  mSilentMode=isSilentMode();
  mSelector.setLeftTabResources(R.drawable.ic_jog_dial_unlock,R.drawable.jog_tab_target_green,R.drawable.jog_tab_bar_left_unlock,R.drawable.jog_tab_left_unlock);
  updateRightTabResources();
  mSelector.setOnTriggerListener(this);
  resetStatusInfo(updateMonitor);
}","/** 
 * @param context Used to setup the view.
 * @param configuration The current configuration. Used to use when selecting layout, etc.
 * @param lockPatternUtils Used to know the state of the lock pattern settings.
 * @param updateMonitor Used to register for updates on various keyguard relatedstate, and query the initial state at setup.
 * @param callback Used to communicate back to the host keyguard view.
 */
LockScreen(Context context,Configuration configuration,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mEnableMenuKeyInLockScreen=shouldEnableMenuKey();
  mCreationOrientation=configuration.orientation;
  mKeyboardHidden=configuration.hardKeyboardHidden;
  if (LockPatternKeyguardView.DEBUG_CONFIGURATION) {
    Log.v(TAG,""String_Node_Str"",new RuntimeException());
    Log.v(TAG,""String_Node_Str"" + mCreationOrientation + ""String_Node_Str""+ context.getResources().getConfiguration().orientation);
  }
  final LayoutInflater inflater=LayoutInflater.from(context);
  if (DBG)   Log.v(TAG,""String_Node_Str"" + mCreationOrientation);
  if (mCreationOrientation != Configuration.ORIENTATION_LANDSCAPE) {
    inflater.inflate(R.layout.keyguard_screen_tab_unlock,this,true);
  }
 else {
    inflater.inflate(R.layout.keyguard_screen_tab_unlock_land,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCarrier.setSelected(true);
  mCarrier.setTextColor(0xffffffff);
  mDate=(TextView)findViewById(R.id.date);
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatus2=(TextView)findViewById(R.id.status2);
  mEmergencyCallButton=(Button)findViewById(R.id.emergencyCallButton);
  mEmergencyCallButton.setText(R.string.lockscreen_emergency_call);
  mLockPatternUtils.updateEmergencyCallButtonState(mEmergencyCallButton);
  mScreenLocked=(TextView)findViewById(R.id.screenLocked);
  mSelector=(SlidingTab)findViewById(R.id.tab_selector);
  mSelector.setHoldAfterTrigger(true,false);
  mSelector.setLeftHintText(R.string.lockscreen_unlock_label);
  mEmergencyCallButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
);
  setFocusable(true);
  setFocusableInTouchMode(true);
  setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
  mSilentMode=isSilentMode();
  mSelector.setLeftTabResources(R.drawable.ic_jog_dial_unlock,R.drawable.jog_tab_target_green,R.drawable.jog_tab_bar_left_unlock,R.drawable.jog_tab_left_unlock);
  updateRightTabResources();
  mSelector.setOnTriggerListener(this);
  resetStatusInfo(updateMonitor);
}"
22812,"/** 
 * {@inheritDoc} 
 */
@Override protected void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  if (DBG) {
    Log.v(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    if (getResources().getConfiguration().orientation != newConfig.orientation) {
      Log.e(TAG,""String_Node_Str"",new Exception(""String_Node_Str""));
    }
  }
  if (newConfig.orientation != mCreationOrientation) {
    mCallback.recreateMe(newConfig);
  }
 else   if (newConfig.hardKeyboardHidden != mKeyboardHidden) {
    mKeyboardHidden=newConfig.hardKeyboardHidden;
    final boolean isKeyboardOpen=mKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO;
    if (mUpdateMonitor.isKeyguardBypassEnabled() && isKeyboardOpen) {
      mCallback.goToUnlockScreen();
    }
  }
}","/** 
 * {@inheritDoc} 
 */
@Override protected void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  if (LockPatternKeyguardView.DEBUG_CONFIGURATION) {
    Log.w(TAG,""String_Node_Str"",new RuntimeException());
    Log.v(TAG,""String_Node_Str"" + mCreationOrientation + ""String_Node_Str""+ newConfig);
  }
  updateConfiguration();
}"
22813,"/** 
 * {@inheritDoc} 
 */
@Override protected void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  if (newConfig.orientation != mCreationOrientation) {
    mCallback.recreateMe(newConfig);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override protected void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  if (LockPatternKeyguardView.DEBUG_CONFIGURATION) {
    Log.v(TAG,""String_Node_Str"");
    Log.v(TAG,""String_Node_Str"" + mCreationOrientation + ""String_Node_Str""+ getResources().getConfiguration());
  }
  if (newConfig.orientation != mCreationOrientation) {
    mCallback.recreateMe(newConfig);
  }
}"
22814,"/** 
 * {@inheritDoc} 
 */
@Override protected void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  if (newConfig.orientation != mCreationOrientation) {
    mCallback.recreateMe(newConfig);
  }
 else   if (newConfig.hardKeyboardHidden != mKeyboardHidden) {
    mKeyboardHidden=newConfig.hardKeyboardHidden;
    final boolean isKeyboardOpen=mKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO;
    if (mUpdateMonitor.isKeyguardBypassEnabled() && isKeyboardOpen) {
      mCallback.goToUnlockScreen();
    }
  }
}","/** 
 * {@inheritDoc} 
 */
@Override protected void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  updateConfiguration();
}"
22815,"@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (isPopupShowing()) {
    if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || (keyCode != KeyEvent.KEYCODE_ENTER && keyCode != KeyEvent.KEYCODE_DPAD_CENTER))) {
      int curIndex=mDropDownList.getSelectedItemPosition();
      boolean consumed;
      final boolean below=!mPopup.isAboveAnchor();
      final ListAdapter adapter=mDropDownList.getAdapter();
      final boolean allEnabled=adapter.areAllItemsEnabled();
      final int firstItem=allEnabled ? 0 : mDropDownList.lookForSelectablePosition(0,true);
      final int lastItem=allEnabled ? adapter.getCount() - 1 : mDropDownList.lookForSelectablePosition(adapter.getCount() - 1,false);
      if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
        clearListSelection();
        mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
        showDropDown();
        return true;
      }
 else {
        mDropDownList.mListSelectionHidden=false;
      }
      consumed=mDropDownList.onKeyDown(keyCode,event);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + keyCode + ""String_Node_Str""+ consumed);
      if (consumed) {
        mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
        mDropDownList.requestFocusFromTouch();
        showDropDown();
switch (keyCode) {
case KeyEvent.KEYCODE_ENTER:
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_DPAD_DOWN:
case KeyEvent.KEYCODE_DPAD_UP:
          return true;
      }
    }
 else {
      if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
        if (curIndex == lastItem) {
          return true;
        }
      }
 else       if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
        return true;
      }
    }
  }
}
 else {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_DOWN:
    performValidation();
}
}
mLastKeyCode=keyCode;
boolean handled=super.onKeyDown(keyCode,event);
mLastKeyCode=KeyEvent.KEYCODE_UNKNOWN;
if (handled && isPopupShowing() && mDropDownList != null) {
clearListSelection();
}
return handled;
}","@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (isPopupShowing()) {
    if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || (keyCode != KeyEvent.KEYCODE_ENTER && keyCode != KeyEvent.KEYCODE_DPAD_CENTER))) {
      int curIndex=mDropDownList.getSelectedItemPosition();
      boolean consumed;
      final boolean below=!mPopup.isAboveAnchor();
      final ListAdapter adapter=mAdapter;
      boolean allEnabled;
      int firstItem=Integer.MAX_VALUE;
      int lastItem=Integer.MIN_VALUE;
      if (adapter != null) {
        allEnabled=adapter.areAllItemsEnabled();
        firstItem=allEnabled ? 0 : mDropDownList.lookForSelectablePosition(0,true);
        lastItem=allEnabled ? adapter.getCount() - 1 : mDropDownList.lookForSelectablePosition(adapter.getCount() - 1,false);
      }
      if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
        clearListSelection();
        mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
        showDropDown();
        return true;
      }
 else {
        mDropDownList.mListSelectionHidden=false;
      }
      consumed=mDropDownList.onKeyDown(keyCode,event);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + keyCode + ""String_Node_Str""+ consumed);
      if (consumed) {
        mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
        mDropDownList.requestFocusFromTouch();
        showDropDown();
switch (keyCode) {
case KeyEvent.KEYCODE_ENTER:
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_DPAD_DOWN:
case KeyEvent.KEYCODE_DPAD_UP:
          return true;
      }
    }
 else {
      if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
        if (curIndex == lastItem) {
          return true;
        }
      }
 else       if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
        return true;
      }
    }
  }
}
 else {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_DOWN:
    performValidation();
}
}
mLastKeyCode=keyCode;
boolean handled=super.onKeyDown(keyCode,event);
mLastKeyCode=KeyEvent.KEYCODE_UNKNOWN;
if (handled && isPopupShowing() && mDropDownList != null) {
clearListSelection();
}
return handled;
}"
22816,"void showInputMethodMenu(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  hideInputMethodMenu();
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + lastInputMethodId);
  final List<InputMethodInfo> immis=getEnabledInputMethodList();
  if (immis == null) {
    return;
  }
  int N=immis.size();
  mItems=new CharSequence[N];
  mIms=new InputMethodInfo[N];
  for (int i=0; i < N; ++i) {
    InputMethodInfo property=immis.get(i);
    if (property == null) {
      i--;
      N--;
      continue;
    }
    mItems[i]=property.loadLabel(pm);
    mIms[i]=property;
  }
  int checkedItem=0;
  for (int i=0; i < N; ++i) {
    if (mIms[i].getId().equals(lastInputMethodId)) {
      checkedItem=i;
      break;
    }
  }
  AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      hideInputMethodMenu();
    }
  }
;
  TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
  mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
    public void onCancel(    DialogInterface dialog){
      hideInputMethodMenu();
    }
  }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
  a.recycle();
  mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
synchronized (mMethodMap) {
        if (mIms == null || mIms.length <= which) {
          return;
        }
        InputMethodInfo im=mIms[which];
        hideInputMethodMenu();
        if (im != null) {
          setInputMethodLocked(im.getId());
        }
      }
    }
  }
);
synchronized (mMethodMap) {
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.show();
  }
}","void showInputMethodMenu(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + lastInputMethodId);
  final List<InputMethodInfo> immis=getEnabledInputMethodList();
  if (immis == null) {
    return;
  }
synchronized (mMethodMap) {
    hideInputMethodMenuLocked();
    int N=immis.size();
    mItems=new CharSequence[N];
    mIms=new InputMethodInfo[N];
    int j=0;
    for (int i=0; i < N; ++i) {
      InputMethodInfo property=immis.get(i);
      if (property == null) {
        continue;
      }
      mItems[j]=property.loadLabel(pm);
      mIms[j]=property;
      j++;
    }
    int checkedItem=0;
    for (int i=0; i < N; ++i) {
      if (mIms[i].getId().equals(lastInputMethodId)) {
        checkedItem=i;
        break;
      }
    }
    AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        hideInputMethodMenu();
      }
    }
;
    TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
    mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
      public void onCancel(      DialogInterface dialog){
        hideInputMethodMenu();
      }
    }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
    a.recycle();
    mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
synchronized (mMethodMap) {
          if (mIms == null || mIms.length <= which) {
            return;
          }
          InputMethodInfo im=mIms[which];
          hideInputMethodMenu();
          if (im != null) {
            setInputMethodLocked(im.getId());
          }
        }
      }
    }
);
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.show();
  }
}"
22817,"/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
  if (l == null) {
    return;
  }
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}","/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}"
22818,"private String getIdForAudioFocusListener(OnAudioFocusChangeListener l){
  if (l == null) {
    return new String();
  }
 else {
    return new String(this.toString() + l.toString());
  }
}","private String getIdForAudioFocusListener(OnAudioFocusChangeListener l){
  if (l == null) {
    return new String(this.toString());
  }
 else {
    return new String(this.toString() + l.toString());
  }
}"
22819,"/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
  if (l == null) {
    return;
  }
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}","/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}"
22820,"private String getIdForAudioFocusListener(OnAudioFocusChangeListener l){
  if (l == null) {
    return new String();
  }
 else {
    return new String(this.toString() + l.toString());
  }
}","private String getIdForAudioFocusListener(OnAudioFocusChangeListener l){
  if (l == null) {
    return new String(this.toString());
  }
 else {
    return new String(this.toString() + l.toString());
  }
}"
22821,"void showInputMethodMenu(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  hideInputMethodMenu();
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + lastInputMethodId);
  final List<InputMethodInfo> immis=getEnabledInputMethodList();
  if (immis == null) {
    return;
  }
  int N=immis.size();
  mItems=new CharSequence[N];
  mIms=new InputMethodInfo[N];
  for (int i=0; i < N; ++i) {
    InputMethodInfo property=immis.get(i);
    if (property == null) {
      i--;
      N--;
      continue;
    }
    mItems[i]=property.loadLabel(pm);
    mIms[i]=property;
  }
  int checkedItem=0;
  for (int i=0; i < N; ++i) {
    if (mIms[i].getId().equals(lastInputMethodId)) {
      checkedItem=i;
      break;
    }
  }
  AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      hideInputMethodMenu();
    }
  }
;
  TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
  mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
    public void onCancel(    DialogInterface dialog){
      hideInputMethodMenu();
    }
  }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
  a.recycle();
  mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
synchronized (mMethodMap) {
        if (mIms == null || mIms.length <= which) {
          return;
        }
        InputMethodInfo im=mIms[which];
        hideInputMethodMenu();
        if (im != null) {
          setInputMethodLocked(im.getId());
        }
      }
    }
  }
);
synchronized (mMethodMap) {
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.show();
  }
}","void showInputMethodMenu(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + lastInputMethodId);
  final List<InputMethodInfo> immis=getEnabledInputMethodList();
  if (immis == null) {
    return;
  }
synchronized (mMethodMap) {
    hideInputMethodMenuLocked();
    int N=immis.size();
    mItems=new CharSequence[N];
    mIms=new InputMethodInfo[N];
    int j=0;
    for (int i=0; i < N; ++i) {
      InputMethodInfo property=immis.get(i);
      if (property == null) {
        continue;
      }
      mItems[j]=property.loadLabel(pm);
      mIms[j]=property;
      j++;
    }
    int checkedItem=0;
    for (int i=0; i < N; ++i) {
      if (mIms[i].getId().equals(lastInputMethodId)) {
        checkedItem=i;
        break;
      }
    }
    AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        hideInputMethodMenu();
      }
    }
;
    TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
    mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
      public void onCancel(      DialogInterface dialog){
        hideInputMethodMenu();
      }
    }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
    a.recycle();
    mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
synchronized (mMethodMap) {
          if (mIms == null || mIms.length <= which) {
            return;
          }
          InputMethodInfo im=mIms[which];
          hideInputMethodMenu();
          if (im != null) {
            setInputMethodLocked(im.getId());
          }
        }
      }
    }
);
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.show();
  }
}"
22822,"/** 
 * AccountUnlockScreen constructor.
 */
public AccountUnlockScreen(Context context,KeyguardScreenCallback callback,LockPatternUtils lockPatternUtils){
  super(context);
  mCallback=callback;
  mLockPatternUtils=lockPatternUtils;
  LayoutInflater.from(context).inflate(R.layout.keyguard_screen_glogin_unlock,this,true);
  mTopHeader=(TextView)findViewById(R.id.topHeader);
  mTopHeader.setText(mLockPatternUtils.isPermanentlyLocked() ? R.string.lockscreen_glogin_too_many_attempts : R.string.lockscreen_glogin_forgot_pattern);
  mInstructions=(TextView)findViewById(R.id.instructions);
  mLogin=(EditText)findViewById(R.id.login);
  mLogin.setFilters(new InputFilter[]{new LoginFilter.UsernameFilterGeneric()});
  mLogin.addTextChangedListener(this);
  mPassword=(EditText)findViewById(R.id.password);
  mPassword.addTextChangedListener(this);
  mOk=(Button)findViewById(R.id.ok);
  mOk.setOnClickListener(this);
  mEmergencyCall=(Button)findViewById(R.id.emergencyCall);
  mEmergencyCall.setOnClickListener(this);
  mLockPatternUtils.updateEmergencyCallButtonState(mEmergencyCall);
}","/** 
 * AccountUnlockScreen constructor.
 * @param configuration
 */
public AccountUnlockScreen(Context context,Configuration configuration,KeyguardScreenCallback callback,LockPatternUtils lockPatternUtils){
  super(context);
  mCallback=callback;
  mLockPatternUtils=lockPatternUtils;
  LayoutInflater.from(context).inflate(R.layout.keyguard_screen_glogin_unlock,this,true);
  mTopHeader=(TextView)findViewById(R.id.topHeader);
  mTopHeader.setText(mLockPatternUtils.isPermanentlyLocked() ? R.string.lockscreen_glogin_too_many_attempts : R.string.lockscreen_glogin_forgot_pattern);
  mInstructions=(TextView)findViewById(R.id.instructions);
  mLogin=(EditText)findViewById(R.id.login);
  mLogin.setFilters(new InputFilter[]{new LoginFilter.UsernameFilterGeneric()});
  mLogin.addTextChangedListener(this);
  mPassword=(EditText)findViewById(R.id.password);
  mPassword.addTextChangedListener(this);
  mOk=(Button)findViewById(R.id.ok);
  mOk.setOnClickListener(this);
  mEmergencyCall=(Button)findViewById(R.id.emergencyCall);
  mEmergencyCall.setOnClickListener(this);
  mLockPatternUtils.updateEmergencyCallButtonState(mEmergencyCall);
}"
22823,"/** 
 * Stay on me, but recreate me (so I can use a different layout).
 */
void recreateMe();","/** 
 * Stay on me, but recreate me (so I can use a different layout).
 */
void recreateMe(Configuration config);"
22824,"/** 
 * Remove the given observer from being registered from any of the kinds of callbacks.
 * @param observer The observer to remove (an instance of {@link ConfigurationChangeCallback},  {@link InfoCallback} or {@link SimStateCallback}
 */
public void removeCallback(Object observer){
  mConfigurationChangeCallbacks.remove(observer);
  mInfoCallbacks.remove(observer);
  mSimStateCallbacks.remove(observer);
}","/** 
 * Remove the given observer from being registered from any of the kinds of callbacks.
 * @param observer The observer to remove (an instance of {@link ConfigurationChangeCallback},  {@link InfoCallback} or {@link SimStateCallback}
 */
public void removeCallback(Object observer){
  mInfoCallbacks.remove(observer);
  mSimStateCallbacks.remove(observer);
}"
22825,"public KeyguardUpdateMonitor(Context context){
  mContext=context;
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CONFIGURATION_CHANGED:
        handleConfigurationChange();
      break;
case MSG_TIME_UPDATE:
    handleTimeUpdate();
  break;
case MSG_BATTERY_UPDATE:
handleBatteryUpdate(msg.arg1,msg.arg2);
break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}
}
;
mKeyguardBypassEnabled=context.getResources().getBoolean(com.android.internal.R.bool.config_bypass_keyguard_if_slider_open);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (!mDeviceProvisioned) {
mContentObserver=new ContentObserver(mHandler){
@Override public void onChange(boolean selfChange){
super.onChange(selfChange);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (mDeviceProvisioned && mContentObserver != null) {
mContext.getContentResolver().unregisterContentObserver(mContentObserver);
mContentObserver=null;
}
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mDeviceProvisioned);
}
}
;
mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEVICE_PROVISIONED),false,mContentObserver);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
}
mInPortrait=queryInPortrait();
mKeyboardOpen=queryKeyboardOpen();
mSimState=IccCard.State.READY;
mDevicePluggedIn=true;
mBatteryLevel=100;
mTelephonyPlmn=getDefaultPlmn();
final IntentFilter filter=new IntentFilter();
filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
filter.addAction(Intent.ACTION_TIME_TICK);
filter.addAction(Intent.ACTION_TIME_CHANGED);
filter.addAction(Intent.ACTION_BATTERY_CHANGED);
filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
filter.addAction(SPN_STRINGS_UPDATED_ACTION);
filter.addAction(AudioManager.RINGER_MODE_CHANGED_ACTION);
context.registerReceiver(new BroadcastReceiver(){
public void onReceive(Context context,Intent intent){
final String action=intent.getAction();
if (DEBUG) Log.d(TAG,""String_Node_Str"" + action);
if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_CONFIGURATION_CHANGED));
}
 else if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
}
 else if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
mTelephonyPlmn=getTelephonyPlmnFrom(intent);
mTelephonySpn=getTelephonySpnFrom(intent);
mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
}
 else if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
mHandler.sendMessage(msg);
}
 else if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
}
 else if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
}
 else if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
}
}
}
,filter);
}","public KeyguardUpdateMonitor(Context context){
  mContext=context;
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_TIME_UPDATE:
        handleTimeUpdate();
      break;
case MSG_BATTERY_UPDATE:
    handleBatteryUpdate(msg.arg1,msg.arg2);
  break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}
}
;
mKeyguardBypassEnabled=context.getResources().getBoolean(com.android.internal.R.bool.config_bypass_keyguard_if_slider_open);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (!mDeviceProvisioned) {
mContentObserver=new ContentObserver(mHandler){
@Override public void onChange(boolean selfChange){
super.onChange(selfChange);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (mDeviceProvisioned && mContentObserver != null) {
mContext.getContentResolver().unregisterContentObserver(mContentObserver);
mContentObserver=null;
}
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mDeviceProvisioned);
}
}
;
mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEVICE_PROVISIONED),false,mContentObserver);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
}
mSimState=IccCard.State.READY;
mDevicePluggedIn=true;
mBatteryLevel=100;
mTelephonyPlmn=getDefaultPlmn();
final IntentFilter filter=new IntentFilter();
filter.addAction(Intent.ACTION_TIME_TICK);
filter.addAction(Intent.ACTION_TIME_CHANGED);
filter.addAction(Intent.ACTION_BATTERY_CHANGED);
filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
filter.addAction(SPN_STRINGS_UPDATED_ACTION);
filter.addAction(AudioManager.RINGER_MODE_CHANGED_ACTION);
context.registerReceiver(new BroadcastReceiver(){
public void onReceive(Context context,Intent intent){
final String action=intent.getAction();
if (DEBUG) Log.d(TAG,""String_Node_Str"" + action);
if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
}
 else if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
mTelephonyPlmn=getTelephonyPlmnFrom(intent);
mTelephonySpn=getTelephonySpnFrom(intent);
mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
}
 else if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
mHandler.sendMessage(msg);
}
 else if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
}
 else if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
}
 else if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
}
}
}
,filter);
}"
22826,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_CONFIGURATION_CHANGED:
    handleConfigurationChange();
  break;
case MSG_TIME_UPDATE:
handleTimeUpdate();
break;
case MSG_BATTERY_UPDATE:
handleBatteryUpdate(msg.arg1,msg.arg2);
break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_TIME_UPDATE:
    handleTimeUpdate();
  break;
case MSG_BATTERY_UPDATE:
handleBatteryUpdate(msg.arg1,msg.arg2);
break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}"
22827,"public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + action);
  if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_CONFIGURATION_CHANGED));
  }
 else   if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
  }
 else   if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
    mTelephonyPlmn=getTelephonyPlmnFrom(intent);
    mTelephonySpn=getTelephonySpnFrom(intent);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
  }
 else   if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
    final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
    int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
    final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
    mHandler.sendMessage(msg);
  }
 else   if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
  }
 else   if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
  }
 else   if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
    String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
  }
}","public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + action);
  if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
  }
 else   if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
    mTelephonyPlmn=getTelephonyPlmnFrom(intent);
    mTelephonySpn=getTelephonySpnFrom(intent);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
  }
 else   if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
    final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
    int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
    final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
    mHandler.sendMessage(msg);
  }
 else   if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
  }
 else   if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
  }
 else   if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
    String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
  }
}"
22828,"View createLockScreen(){
  return new LockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
}","View createLockScreen(){
  return new LockScreen(mContext,mConfiguration,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
}"
22829,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      pokeWakelock(EMERGENCY_CALL_TIMEOUT);
      if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
      }
 else {
        Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivity(intent);
      }
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedUnlockAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
      mLockPatternUtils.reportFailedPasswordAttempt();
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
    public void reportSuccessfulUnlockAttempt(){
      mLockPatternUtils.reportSuccessfulPasswordAttempt();
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mConfiguration=context.getResources().getConfiguration();
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(    Configuration config){
      mConfiguration=config;
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      pokeWakelock(EMERGENCY_CALL_TIMEOUT);
      if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
      }
 else {
        Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivity(intent);
      }
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedUnlockAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
      mLockPatternUtils.reportFailedPasswordAttempt();
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
    public void reportSuccessfulUnlockAttempt(){
      mLockPatternUtils.reportSuccessfulPasswordAttempt();
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}"
22830,"View createUnlockScreenFor(UnlockMode unlockMode){
  mIsPortrait=getResources().getBoolean(R.bool.lockscreen_isPortrait);
  View unlockView=null;
  if (unlockMode == UnlockMode.Pattern) {
    PatternUnlockScreen view=new PatternUnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + unlockMode + ""String_Node_Str""+ mEnableFallback);
    view.setEnableFallback(mEnableFallback);
    unlockView=view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    unlockView=new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback,mLockPatternUtils);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      unlockView=new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      unlockView=createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else   if (unlockMode == UnlockMode.Password) {
    unlockView=new PasswordUnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
  mCurrentUnlockMode=unlockMode;
  return unlockView;
}","View createUnlockScreenFor(UnlockMode unlockMode){
  View unlockView=null;
  if (unlockMode == UnlockMode.Pattern) {
    PatternUnlockScreen view=new PatternUnlockScreen(mContext,mConfiguration,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + unlockMode + ""String_Node_Str""+ mEnableFallback);
    view.setEnableFallback(mEnableFallback);
    unlockView=view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    unlockView=new SimUnlockScreen(mContext,mConfiguration,mUpdateMonitor,mKeyguardScreenCallback,mLockPatternUtils);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      unlockView=new AccountUnlockScreen(mContext,mConfiguration,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      unlockView=createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else   if (unlockMode == UnlockMode.Password) {
    unlockView=new PasswordUnlockScreen(mContext,mConfiguration,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
  mCurrentUnlockMode=unlockMode;
  return unlockView;
}"
22831,"@Override protected void dispatchDraw(Canvas canvas){
  final int orientation=getResources().getConfiguration().orientation;
  if (mIsPortrait && Configuration.ORIENTATION_PORTRAIT != orientation || getResources().getBoolean(R.bool.lockscreen_isPortrait) != mIsPortrait) {
    postInvalidate();
    ViewGroup view=(ViewGroup)(mMode == Mode.LockScreen ? mLockScreen : mUnlockScreen);
    if (view != null && view.getChildAt(0) != null) {
      Drawable background=view.getChildAt(0).getBackground();
      if (background != null) {
        background.draw(canvas);
      }
    }
    return;
  }
  super.dispatchDraw(canvas);
}","@Override protected void dispatchDraw(Canvas canvas){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
  super.dispatchDraw(canvas);
}"
22832,"public void recreateMe(){
  recreateScreens();
}","public void recreateMe(Configuration config){
  mConfiguration=config;
  recreateScreens();
}"
22833,"public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
      }
      if (mScrollY != 0) {
        mScrollY=0;
        invalidate();
      }
    }
  }
  mLastTouchMode=isInTouchMode ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
}","public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
      }
      if (mScrollY != 0) {
        mScrollY=0;
        invalidate();
      }
    }
  }
}"
22834,"public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
      }
      if (mScrollY != 0) {
        mScrollY=0;
        invalidate();
      }
    }
  }
  mLastTouchMode=isInTouchMode ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
}","public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
      }
      if (mScrollY != 0) {
        mScrollY=0;
        invalidate();
      }
    }
  }
}"
22835,"/** 
 * @param contentResolver Used to look up and save settings.
 */
public LockPatternUtils(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  mDevicePolicyManager=getDevicePolicyManager();
  if (sLockPatternFilename == null) {
    sLockPatternFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PATTERN_FILE;
    sLockPasswordFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PASSWORD_FILE;
  }
}","/** 
 * @param contentResolver Used to look up and save settings.
 */
public LockPatternUtils(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  if (sLockPatternFilename == null) {
    sLockPatternFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PATTERN_FILE;
    sLockPasswordFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PASSWORD_FILE;
  }
}"
22836,"public void testScreenRequestsRecreation(){
  mLPKV.wakeWhenReadyTq(0);
  mLPKV.onScreenTurnedOn();
  assertEquals(1,mLPKV.getInjectedLockScreens().size());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().size());
  MockKeyguardScreen lockScreen=mLPKV.getInjectedLockScreens().get(0);
  assertEquals(0,lockScreen.getOnPauseCount());
  assertEquals(1,lockScreen.getOnResumeCount());
  mLPKV.mKeyguardScreenCallback.recreateMe();
  assertEquals(2,mLPKV.getInjectedLockScreens().size());
  assertEquals(2,mLPKV.getInjectedUnlockScreens().size());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getOnPauseCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(0).getOnPauseCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(1).getOnResumeCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(1).getOnResumeCount());
}","public void testScreenRequestsRecreation(){
  mLPKV.wakeWhenReadyTq(0);
  mLPKV.onScreenTurnedOn();
  assertEquals(1,mLPKV.getInjectedLockScreens().size());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().size());
  MockKeyguardScreen lockScreen=mLPKV.getInjectedLockScreens().get(0);
  assertEquals(0,lockScreen.getOnPauseCount());
  assertEquals(1,lockScreen.getOnResumeCount());
  mLPKV.mKeyguardScreenCallback.recreateMe(new Configuration());
  assertEquals(2,mLPKV.getInjectedLockScreens().size());
  assertEquals(2,mLPKV.getInjectedUnlockScreens().size());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getOnPauseCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(0).getOnPauseCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(1).getOnResumeCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(1).getOnResumeCount());
}"
22837,"/** 
 * Figures out the layout for the menu items.
 * @param width The available width for the icon menu.
 */
private void layoutItems(int width){
  int numItems=getChildCount();
  int curNumRows=Math.min((int)Math.ceil(numItems / (float)mMaxItemsPerRow),mMaxRows);
  for (; curNumRows <= mMaxRows; curNumRows++) {
    layoutItemsUsingGravity(curNumRows,numItems);
    if (curNumRows >= numItems) {
      break;
    }
    if (doItemsFit()) {
      break;
    }
  }
}","/** 
 * Figures out the layout for the menu items.
 * @param width The available width for the icon menu.
 */
private void layoutItems(int width){
  int numItems=getChildCount();
  if (numItems == 0) {
    mLayoutNumRows=0;
    return;
  }
  int curNumRows=Math.min((int)Math.ceil(numItems / (float)mMaxItemsPerRow),mMaxRows);
  for (; curNumRows <= mMaxRows; curNumRows++) {
    layoutItemsUsingGravity(curNumRows,numItems);
    if (curNumRows >= numItems) {
      break;
    }
    if (doItemsFit()) {
      break;
    }
  }
}"
22838,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mHasStaleChildren) {
    mHasStaleChildren=false;
    updateChildren(false);
  }
  int measuredWidth=resolveSize(Integer.MAX_VALUE,widthMeasureSpec);
  calculateItemFittingMetadata(measuredWidth);
  layoutItems(measuredWidth);
  final int desiredHeight=(mRowHeight + mHorizontalDividerHeight) * mLayoutNumRows - mHorizontalDividerHeight;
  setMeasuredDimension(measuredWidth,resolveSize(desiredHeight,heightMeasureSpec));
  positionChildren(mMeasuredWidth,mMeasuredHeight);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mHasStaleChildren) {
    mHasStaleChildren=false;
    updateChildren(false);
  }
  int measuredWidth=resolveSize(Integer.MAX_VALUE,widthMeasureSpec);
  calculateItemFittingMetadata(measuredWidth);
  layoutItems(measuredWidth);
  final int layoutNumRows=mLayoutNumRows;
  final int desiredHeight=(mRowHeight + mHorizontalDividerHeight) * layoutNumRows - mHorizontalDividerHeight;
  setMeasuredDimension(measuredWidth,resolveSize(desiredHeight,heightMeasureSpec));
  if (layoutNumRows > 0) {
    positionChildren(mMeasuredWidth,mMeasuredHeight);
  }
}"
22839,"/** 
 * Figures out the layout for the menu items.
 * @param width The available width for the icon menu.
 */
private void layoutItems(int width){
  int numItems=getChildCount();
  int curNumRows=Math.min((int)Math.ceil(numItems / (float)mMaxItemsPerRow),mMaxRows);
  for (; curNumRows <= mMaxRows; curNumRows++) {
    layoutItemsUsingGravity(curNumRows,numItems);
    if (curNumRows >= numItems) {
      break;
    }
    if (doItemsFit()) {
      break;
    }
  }
}","/** 
 * Figures out the layout for the menu items.
 * @param width The available width for the icon menu.
 */
private void layoutItems(int width){
  int numItems=getChildCount();
  if (numItems == 0) {
    mLayoutNumRows=0;
    return;
  }
  int curNumRows=Math.min((int)Math.ceil(numItems / (float)mMaxItemsPerRow),mMaxRows);
  for (; curNumRows <= mMaxRows; curNumRows++) {
    layoutItemsUsingGravity(curNumRows,numItems);
    if (curNumRows >= numItems) {
      break;
    }
    if (doItemsFit()) {
      break;
    }
  }
}"
22840,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mHasStaleChildren) {
    mHasStaleChildren=false;
    updateChildren(false);
  }
  int measuredWidth=resolveSize(Integer.MAX_VALUE,widthMeasureSpec);
  calculateItemFittingMetadata(measuredWidth);
  layoutItems(measuredWidth);
  final int desiredHeight=(mRowHeight + mHorizontalDividerHeight) * mLayoutNumRows - mHorizontalDividerHeight;
  setMeasuredDimension(measuredWidth,resolveSize(desiredHeight,heightMeasureSpec));
  positionChildren(mMeasuredWidth,mMeasuredHeight);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mHasStaleChildren) {
    mHasStaleChildren=false;
    updateChildren(false);
  }
  int measuredWidth=resolveSize(Integer.MAX_VALUE,widthMeasureSpec);
  calculateItemFittingMetadata(measuredWidth);
  layoutItems(measuredWidth);
  final int layoutNumRows=mLayoutNumRows;
  final int desiredHeight=(mRowHeight + mHorizontalDividerHeight) * layoutNumRows - mHorizontalDividerHeight;
  setMeasuredDimension(measuredWidth,resolveSize(desiredHeight,heightMeasureSpec));
  if (layoutNumRows > 0) {
    positionChildren(mMeasuredWidth,mMeasuredHeight);
  }
}"
22841,"/** 
 * See if the key event means we should leave touch mode (and leave touch mode if so).
 * @param event The key event.
 * @return Whether this key event should be consumed (meaning the act ofleaving touch mode alone is considered the event).
 */
private boolean checkForLeavingTouchModeAndConsume(KeyEvent event){
  if (event.getAction() != KeyEvent.ACTION_DOWN) {
    return false;
  }
  if ((event.getFlags() & KeyEvent.FLAG_KEEP_TOUCH_MODE) != 0) {
    return false;
  }
  if (!mAttachInfo.mInTouchMode) {
    return false;
  }
  if (isKeyboardKey(event) && mView != null && mView.hasFocus()) {
    mFocusedView=mView.findFocus();
    if ((mFocusedView instanceof ViewGroup) && ((ViewGroup)mFocusedView).getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS) {
      return false;
    }
    if (ensureTouchMode(false)) {
      throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
    return false;
  }
  if (isDirectional(event.getKeyCode())) {
    return ensureTouchMode(false);
  }
  return false;
}","/** 
 * See if the key event means we should leave touch mode (and leave touch mode if so).
 * @param event The key event.
 * @return Whether this key event should be consumed (meaning the act ofleaving touch mode alone is considered the event).
 */
private boolean checkForLeavingTouchModeAndConsume(KeyEvent event){
  final int action=event.getAction();
  if (action != KeyEvent.ACTION_DOWN && action != KeyEvent.ACTION_MULTIPLE) {
    return false;
  }
  if ((event.getFlags() & KeyEvent.FLAG_KEEP_TOUCH_MODE) != 0) {
    return false;
  }
  if (!mAttachInfo.mInTouchMode) {
    return false;
  }
  if (isKeyboardKey(event) && mView != null && mView.hasFocus()) {
    mFocusedView=mView.findFocus();
    if ((mFocusedView instanceof ViewGroup) && ((ViewGroup)mFocusedView).getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS) {
      return false;
    }
    if (ensureTouchMode(false)) {
      throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
    return false;
  }
  if (isDirectional(event.getKeyCode())) {
    return ensureTouchMode(false);
  }
  return false;
}"
22842,"public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
        if (mScrollY != 0) {
          mScrollY=0;
          invalidate();
        }
      }
    }
  }
  mLastTouchMode=isInTouchMode ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
}","public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
      }
      if (mScrollY != 0) {
        mScrollY=0;
        invalidate();
      }
    }
  }
  mLastTouchMode=isInTouchMode ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
}"
22843,"final void updateLocked(){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
      }
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    updateConfigurationLocked();
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","final void updateLocked(){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    updateConfigurationLocked();
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
22844,"final void updateLocked(){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
      }
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    updateConfigurationLocked();
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","final void updateLocked(){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    updateConfigurationLocked();
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
22845,"/** 
 * See if the key event means we should leave touch mode (and leave touch mode if so).
 * @param event The key event.
 * @return Whether this key event should be consumed (meaning the act ofleaving touch mode alone is considered the event).
 */
private boolean checkForLeavingTouchModeAndConsume(KeyEvent event){
  if (event.getAction() != KeyEvent.ACTION_DOWN) {
    return false;
  }
  if ((event.getFlags() & KeyEvent.FLAG_KEEP_TOUCH_MODE) != 0) {
    return false;
  }
  if (!mAttachInfo.mInTouchMode) {
    return false;
  }
  if (isKeyboardKey(event) && mView != null && mView.hasFocus()) {
    mFocusedView=mView.findFocus();
    if ((mFocusedView instanceof ViewGroup) && ((ViewGroup)mFocusedView).getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS) {
      return false;
    }
    if (ensureTouchMode(false)) {
      throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
    return false;
  }
  if (isDirectional(event.getKeyCode())) {
    return ensureTouchMode(false);
  }
  return false;
}","/** 
 * See if the key event means we should leave touch mode (and leave touch mode if so).
 * @param event The key event.
 * @return Whether this key event should be consumed (meaning the act ofleaving touch mode alone is considered the event).
 */
private boolean checkForLeavingTouchModeAndConsume(KeyEvent event){
  final int action=event.getAction();
  if (action != KeyEvent.ACTION_DOWN && action != KeyEvent.ACTION_MULTIPLE) {
    return false;
  }
  if ((event.getFlags() & KeyEvent.FLAG_KEEP_TOUCH_MODE) != 0) {
    return false;
  }
  if (!mAttachInfo.mInTouchMode) {
    return false;
  }
  if (isKeyboardKey(event) && mView != null && mView.hasFocus()) {
    mFocusedView=mView.findFocus();
    if ((mFocusedView instanceof ViewGroup) && ((ViewGroup)mFocusedView).getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS) {
      return false;
    }
    if (ensureTouchMode(false)) {
      throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
    return false;
  }
  if (isDirectional(event.getKeyCode())) {
    return ensureTouchMode(false);
  }
  return false;
}"
22846,"public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
        if (mScrollY != 0) {
          mScrollY=0;
          invalidate();
        }
      }
    }
  }
  mLastTouchMode=isInTouchMode ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
}","public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
      }
      if (mScrollY != 0) {
        mScrollY=0;
        invalidate();
      }
    }
  }
  mLastTouchMode=isInTouchMode ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
}"
22847,"/** 
 * @param contentResolver Used to look up and save settings.
 */
public LockPatternUtils(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  mDevicePolicyManager=getDevicePolicyManager();
  if (sLockPatternFilename == null) {
    sLockPatternFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PATTERN_FILE;
    sLockPasswordFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PASSWORD_FILE;
  }
}","/** 
 * @param contentResolver Used to look up and save settings.
 */
public LockPatternUtils(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  if (sLockPatternFilename == null) {
    sLockPatternFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PATTERN_FILE;
    sLockPasswordFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PASSWORD_FILE;
  }
}"
22848,"public void testScreenRequestsRecreation(){
  mLPKV.wakeWhenReadyTq(0);
  mLPKV.onScreenTurnedOn();
  assertEquals(1,mLPKV.getInjectedLockScreens().size());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().size());
  MockKeyguardScreen lockScreen=mLPKV.getInjectedLockScreens().get(0);
  assertEquals(0,lockScreen.getOnPauseCount());
  assertEquals(1,lockScreen.getOnResumeCount());
  mLPKV.mKeyguardScreenCallback.recreateMe();
  assertEquals(2,mLPKV.getInjectedLockScreens().size());
  assertEquals(2,mLPKV.getInjectedUnlockScreens().size());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getOnPauseCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(0).getOnPauseCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(1).getOnResumeCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(1).getOnResumeCount());
}","public void testScreenRequestsRecreation(){
  mLPKV.wakeWhenReadyTq(0);
  mLPKV.onScreenTurnedOn();
  assertEquals(1,mLPKV.getInjectedLockScreens().size());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().size());
  MockKeyguardScreen lockScreen=mLPKV.getInjectedLockScreens().get(0);
  assertEquals(0,lockScreen.getOnPauseCount());
  assertEquals(1,lockScreen.getOnResumeCount());
  mLPKV.mKeyguardScreenCallback.recreateMe(new Configuration());
  assertEquals(2,mLPKV.getInjectedLockScreens().size());
  assertEquals(2,mLPKV.getInjectedUnlockScreens().size());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getOnPauseCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(0).getOnPauseCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(1).getOnResumeCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(1).getOnResumeCount());
}"
22849,"/** 
 * AccountUnlockScreen constructor.
 */
public AccountUnlockScreen(Context context,KeyguardScreenCallback callback,LockPatternUtils lockPatternUtils){
  super(context);
  mCallback=callback;
  mLockPatternUtils=lockPatternUtils;
  LayoutInflater.from(context).inflate(R.layout.keyguard_screen_glogin_unlock,this,true);
  mTopHeader=(TextView)findViewById(R.id.topHeader);
  mTopHeader.setText(mLockPatternUtils.isPermanentlyLocked() ? R.string.lockscreen_glogin_too_many_attempts : R.string.lockscreen_glogin_forgot_pattern);
  mInstructions=(TextView)findViewById(R.id.instructions);
  mLogin=(EditText)findViewById(R.id.login);
  mLogin.setFilters(new InputFilter[]{new LoginFilter.UsernameFilterGeneric()});
  mLogin.addTextChangedListener(this);
  mPassword=(EditText)findViewById(R.id.password);
  mPassword.addTextChangedListener(this);
  mOk=(Button)findViewById(R.id.ok);
  mOk.setOnClickListener(this);
  mEmergencyCall=(Button)findViewById(R.id.emergencyCall);
  mEmergencyCall.setOnClickListener(this);
  mLockPatternUtils.updateEmergencyCallButtonState(mEmergencyCall);
}","/** 
 * AccountUnlockScreen constructor.
 * @param configuration
 */
public AccountUnlockScreen(Context context,Configuration configuration,KeyguardScreenCallback callback,LockPatternUtils lockPatternUtils){
  super(context);
  mCallback=callback;
  mLockPatternUtils=lockPatternUtils;
  LayoutInflater.from(context).inflate(R.layout.keyguard_screen_glogin_unlock,this,true);
  mTopHeader=(TextView)findViewById(R.id.topHeader);
  mTopHeader.setText(mLockPatternUtils.isPermanentlyLocked() ? R.string.lockscreen_glogin_too_many_attempts : R.string.lockscreen_glogin_forgot_pattern);
  mInstructions=(TextView)findViewById(R.id.instructions);
  mLogin=(EditText)findViewById(R.id.login);
  mLogin.setFilters(new InputFilter[]{new LoginFilter.UsernameFilterGeneric()});
  mLogin.addTextChangedListener(this);
  mPassword=(EditText)findViewById(R.id.password);
  mPassword.addTextChangedListener(this);
  mOk=(Button)findViewById(R.id.ok);
  mOk.setOnClickListener(this);
  mEmergencyCall=(Button)findViewById(R.id.emergencyCall);
  mEmergencyCall.setOnClickListener(this);
  mLockPatternUtils.updateEmergencyCallButtonState(mEmergencyCall);
}"
22850,"/** 
 * Stay on me, but recreate me (so I can use a different layout).
 */
void recreateMe();","/** 
 * Stay on me, but recreate me (so I can use a different layout).
 */
void recreateMe(Configuration config);"
22851,"/** 
 * Remove the given observer from being registered from any of the kinds of callbacks.
 * @param observer The observer to remove (an instance of {@link ConfigurationChangeCallback},  {@link InfoCallback} or {@link SimStateCallback}
 */
public void removeCallback(Object observer){
  mConfigurationChangeCallbacks.remove(observer);
  mInfoCallbacks.remove(observer);
  mSimStateCallbacks.remove(observer);
}","/** 
 * Remove the given observer from being registered from any of the kinds of callbacks.
 * @param observer The observer to remove (an instance of {@link ConfigurationChangeCallback},  {@link InfoCallback} or {@link SimStateCallback}
 */
public void removeCallback(Object observer){
  mInfoCallbacks.remove(observer);
  mSimStateCallbacks.remove(observer);
}"
22852,"public KeyguardUpdateMonitor(Context context){
  mContext=context;
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CONFIGURATION_CHANGED:
        handleConfigurationChange();
      break;
case MSG_TIME_UPDATE:
    handleTimeUpdate();
  break;
case MSG_BATTERY_UPDATE:
handleBatteryUpdate(msg.arg1,msg.arg2);
break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}
}
;
mKeyguardBypassEnabled=context.getResources().getBoolean(com.android.internal.R.bool.config_bypass_keyguard_if_slider_open);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (!mDeviceProvisioned) {
mContentObserver=new ContentObserver(mHandler){
@Override public void onChange(boolean selfChange){
super.onChange(selfChange);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (mDeviceProvisioned && mContentObserver != null) {
mContext.getContentResolver().unregisterContentObserver(mContentObserver);
mContentObserver=null;
}
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mDeviceProvisioned);
}
}
;
mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEVICE_PROVISIONED),false,mContentObserver);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
}
mInPortrait=queryInPortrait();
mKeyboardOpen=queryKeyboardOpen();
mSimState=IccCard.State.READY;
mDevicePluggedIn=true;
mBatteryLevel=100;
mTelephonyPlmn=getDefaultPlmn();
final IntentFilter filter=new IntentFilter();
filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
filter.addAction(Intent.ACTION_TIME_TICK);
filter.addAction(Intent.ACTION_TIME_CHANGED);
filter.addAction(Intent.ACTION_BATTERY_CHANGED);
filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
filter.addAction(SPN_STRINGS_UPDATED_ACTION);
filter.addAction(AudioManager.RINGER_MODE_CHANGED_ACTION);
context.registerReceiver(new BroadcastReceiver(){
public void onReceive(Context context,Intent intent){
final String action=intent.getAction();
if (DEBUG) Log.d(TAG,""String_Node_Str"" + action);
if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_CONFIGURATION_CHANGED));
}
 else if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
}
 else if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
mTelephonyPlmn=getTelephonyPlmnFrom(intent);
mTelephonySpn=getTelephonySpnFrom(intent);
mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
}
 else if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
mHandler.sendMessage(msg);
}
 else if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
}
 else if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
}
 else if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
}
}
}
,filter);
}","public KeyguardUpdateMonitor(Context context){
  mContext=context;
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_TIME_UPDATE:
        handleTimeUpdate();
      break;
case MSG_BATTERY_UPDATE:
    handleBatteryUpdate(msg.arg1,msg.arg2);
  break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}
}
;
mKeyguardBypassEnabled=context.getResources().getBoolean(com.android.internal.R.bool.config_bypass_keyguard_if_slider_open);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (!mDeviceProvisioned) {
mContentObserver=new ContentObserver(mHandler){
@Override public void onChange(boolean selfChange){
super.onChange(selfChange);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (mDeviceProvisioned && mContentObserver != null) {
mContext.getContentResolver().unregisterContentObserver(mContentObserver);
mContentObserver=null;
}
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mDeviceProvisioned);
}
}
;
mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEVICE_PROVISIONED),false,mContentObserver);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
}
mSimState=IccCard.State.READY;
mDevicePluggedIn=true;
mBatteryLevel=100;
mTelephonyPlmn=getDefaultPlmn();
final IntentFilter filter=new IntentFilter();
filter.addAction(Intent.ACTION_TIME_TICK);
filter.addAction(Intent.ACTION_TIME_CHANGED);
filter.addAction(Intent.ACTION_BATTERY_CHANGED);
filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
filter.addAction(SPN_STRINGS_UPDATED_ACTION);
filter.addAction(AudioManager.RINGER_MODE_CHANGED_ACTION);
context.registerReceiver(new BroadcastReceiver(){
public void onReceive(Context context,Intent intent){
final String action=intent.getAction();
if (DEBUG) Log.d(TAG,""String_Node_Str"" + action);
if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
}
 else if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
mTelephonyPlmn=getTelephonyPlmnFrom(intent);
mTelephonySpn=getTelephonySpnFrom(intent);
mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
}
 else if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
mHandler.sendMessage(msg);
}
 else if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
}
 else if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
}
 else if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
}
}
}
,filter);
}"
22853,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_CONFIGURATION_CHANGED:
    handleConfigurationChange();
  break;
case MSG_TIME_UPDATE:
handleTimeUpdate();
break;
case MSG_BATTERY_UPDATE:
handleBatteryUpdate(msg.arg1,msg.arg2);
break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_TIME_UPDATE:
    handleTimeUpdate();
  break;
case MSG_BATTERY_UPDATE:
handleBatteryUpdate(msg.arg1,msg.arg2);
break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}"
22854,"public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + action);
  if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_CONFIGURATION_CHANGED));
  }
 else   if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
  }
 else   if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
    mTelephonyPlmn=getTelephonyPlmnFrom(intent);
    mTelephonySpn=getTelephonySpnFrom(intent);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
  }
 else   if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
    final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
    int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
    final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
    mHandler.sendMessage(msg);
  }
 else   if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
  }
 else   if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
  }
 else   if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
    String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
  }
}","public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + action);
  if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
  }
 else   if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
    mTelephonyPlmn=getTelephonyPlmnFrom(intent);
    mTelephonySpn=getTelephonySpnFrom(intent);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
  }
 else   if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
    final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
    int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
    final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
    mHandler.sendMessage(msg);
  }
 else   if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
  }
 else   if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
  }
 else   if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
    String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
  }
}"
22855,"View createLockScreen(){
  return new LockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
}","View createLockScreen(){
  return new LockScreen(mContext,mConfiguration,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
}"
22856,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      pokeWakelock(EMERGENCY_CALL_TIMEOUT);
      if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
      }
 else {
        Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivity(intent);
      }
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedUnlockAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
      mLockPatternUtils.reportFailedPasswordAttempt();
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
    public void reportSuccessfulUnlockAttempt(){
      mLockPatternUtils.reportSuccessfulPasswordAttempt();
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mConfiguration=context.getResources().getConfiguration();
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(    Configuration config){
      mConfiguration=config;
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      pokeWakelock(EMERGENCY_CALL_TIMEOUT);
      if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
      }
 else {
        Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivity(intent);
      }
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedUnlockAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
      mLockPatternUtils.reportFailedPasswordAttempt();
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
    public void reportSuccessfulUnlockAttempt(){
      mLockPatternUtils.reportSuccessfulPasswordAttempt();
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}"
22857,"View createUnlockScreenFor(UnlockMode unlockMode){
  mIsPortrait=getResources().getBoolean(R.bool.lockscreen_isPortrait);
  View unlockView=null;
  if (unlockMode == UnlockMode.Pattern) {
    PatternUnlockScreen view=new PatternUnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + unlockMode + ""String_Node_Str""+ mEnableFallback);
    view.setEnableFallback(mEnableFallback);
    unlockView=view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    unlockView=new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback,mLockPatternUtils);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      unlockView=new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      unlockView=createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else   if (unlockMode == UnlockMode.Password) {
    unlockView=new PasswordUnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
  mCurrentUnlockMode=unlockMode;
  return unlockView;
}","View createUnlockScreenFor(UnlockMode unlockMode){
  View unlockView=null;
  if (unlockMode == UnlockMode.Pattern) {
    PatternUnlockScreen view=new PatternUnlockScreen(mContext,mConfiguration,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + unlockMode + ""String_Node_Str""+ mEnableFallback);
    view.setEnableFallback(mEnableFallback);
    unlockView=view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    unlockView=new SimUnlockScreen(mContext,mConfiguration,mUpdateMonitor,mKeyguardScreenCallback,mLockPatternUtils);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      unlockView=new AccountUnlockScreen(mContext,mConfiguration,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      unlockView=createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else   if (unlockMode == UnlockMode.Password) {
    unlockView=new PasswordUnlockScreen(mContext,mConfiguration,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
  mCurrentUnlockMode=unlockMode;
  return unlockView;
}"
22858,"@Override protected void dispatchDraw(Canvas canvas){
  final int orientation=getResources().getConfiguration().orientation;
  if (mIsPortrait && Configuration.ORIENTATION_PORTRAIT != orientation || getResources().getBoolean(R.bool.lockscreen_isPortrait) != mIsPortrait) {
    postInvalidate();
    ViewGroup view=(ViewGroup)(mMode == Mode.LockScreen ? mLockScreen : mUnlockScreen);
    if (view != null && view.getChildAt(0) != null) {
      Drawable background=view.getChildAt(0).getBackground();
      if (background != null) {
        background.draw(canvas);
      }
    }
    return;
  }
  super.dispatchDraw(canvas);
}","@Override protected void dispatchDraw(Canvas canvas){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
  super.dispatchDraw(canvas);
}"
22859,"public void recreateMe(){
  recreateScreens();
}","public void recreateMe(Configuration config){
  mConfiguration=config;
  recreateScreens();
}"
22860,"/** 
 * Send ar.userObj if its a message, which is should be back to originator.
 * @param dp is the DisconnectParams.
 */
private void notifyDisconnectCompleted(DisconnectParams dp){
  if (DBG)   log(""String_Node_Str"");
  Message msg=dp.onCompletedMsg;
  log(String.format(""String_Node_Str"",msg.what,((msg.obj instanceof String) ? (String)msg.obj : ""String_Node_Str"")));
  AsyncResult.forMessage(msg);
  msg.sendToTarget();
  clearSettings();
}","/** 
 * Send ar.userObj if its a message, which is should be back to originator.
 * @param dp is the DisconnectParams.
 */
private void notifyDisconnectCompleted(DisconnectParams dp){
  if (DBG)   log(""String_Node_Str"");
  if (dp.onCompletedMsg != null) {
    Message msg=dp.onCompletedMsg;
    log(String.format(""String_Node_Str"",msg.what,((msg.obj instanceof String) ? (String)msg.obj : ""String_Node_Str"")));
    AsyncResult.forMessage(msg);
    msg.sendToTarget();
  }
  if (dp.lockObj != null) {
synchronized (dp.lockObj) {
      dp.lockObj.notify();
    }
  }
  clearSettings();
}"
22861,"public DisconnectParams(Message onCompletedMsg){
  this.onCompletedMsg=onCompletedMsg;
}","public DisconnectParams(ResetSynchronouslyLock lockObj){
  this.lockObj=lockObj;
}"
22862,"/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying DataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : dataConnectionList) {
    if (conn != null) {
      if (tearDown) {
        if (DBG)         log(""String_Node_Str"");
        conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
      }
 else {
        if (DBG)         log(""String_Node_Str"");
        conn.reset(obtainMessage(EVENT_RESET_DONE,reason));
      }
      notificationDeferred=true;
    }
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}","/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying DataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : dataConnectionList) {
    if (conn != null) {
      if (tearDown) {
        if (DBG)         log(""String_Node_Str"");
        conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
        notificationDeferred=true;
      }
 else {
        if (DBG)         log(""String_Node_Str"");
        conn.resetSynchronously();
        notificationDeferred=false;
      }
    }
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}"
22863,"/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying GsmDataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : pdpList) {
    if (tearDown) {
      if (DBG)       log(""String_Node_Str"");
      conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
    }
 else {
      if (DBG)       log(""String_Node_Str"");
      conn.reset(obtainMessage(EVENT_RESET_DONE,reason));
    }
    notificationDeferred=true;
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}","/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying GsmDataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : pdpList) {
    if (tearDown) {
      if (DBG)       log(""String_Node_Str"");
      conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
      notificationDeferred=true;
    }
 else {
      if (DBG)       log(""String_Node_Str"");
      conn.resetSynchronously();
      notificationDeferred=false;
    }
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}"
22864,"public boolean validateMemoryResult(int startPid,int startMemory,Writer output,int limit) throws Exception {
  Thread.sleep(10000);
  mEndPid=getMediaserverPid();
  int memDiff=mEndMemory - startMemory;
  if (memDiff < 0)   memDiff=0;
 else   output.write(""String_Node_Str"" + memDiff);
  output.write(""String_Node_Str"");
  if (startPid != mEndPid) {
    output.write(""String_Node_Str"");
    return false;
  }
  if (memDiff > limit)   return false;
  return true;
}","public boolean validateMemoryResult(int startPid,int startMemory,Writer output,int limit) throws Exception {
  Thread.sleep(10000);
  mEndPid=getMediaserverPid();
  int memDiff=mEndMemory - startMemory;
  if (memDiff < 0) {
    memDiff=0;
  }
  output.write(""String_Node_Str"" + memDiff);
  output.write(""String_Node_Str"");
  if (startPid != mEndPid) {
    output.write(""String_Node_Str"");
    return false;
  }
  if (memDiff > limit)   return false;
  return true;
}"
22865,"/** 
 * Send ar.userObj if its a message, which is should be back to originator.
 * @param dp is the DisconnectParams.
 */
private void notifyDisconnectCompleted(DisconnectParams dp){
  if (DBG)   log(""String_Node_Str"");
  Message msg=dp.onCompletedMsg;
  log(String.format(""String_Node_Str"",msg.what,((msg.obj instanceof String) ? (String)msg.obj : ""String_Node_Str"")));
  AsyncResult.forMessage(msg);
  msg.sendToTarget();
  clearSettings();
}","/** 
 * Send ar.userObj if its a message, which is should be back to originator.
 * @param dp is the DisconnectParams.
 */
private void notifyDisconnectCompleted(DisconnectParams dp){
  if (DBG)   log(""String_Node_Str"");
  if (dp.onCompletedMsg != null) {
    Message msg=dp.onCompletedMsg;
    log(String.format(""String_Node_Str"",msg.what,((msg.obj instanceof String) ? (String)msg.obj : ""String_Node_Str"")));
    AsyncResult.forMessage(msg);
    msg.sendToTarget();
  }
  if (dp.lockObj != null) {
synchronized (dp.lockObj) {
      dp.lockObj.notify();
    }
  }
  clearSettings();
}"
22866,"public DisconnectParams(Message onCompletedMsg){
  this.onCompletedMsg=onCompletedMsg;
}","public DisconnectParams(ResetSynchronouslyLock lockObj){
  this.lockObj=lockObj;
}"
22867,"/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying DataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : dataConnectionList) {
    if (conn != null) {
      if (tearDown) {
        if (DBG)         log(""String_Node_Str"");
        conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
      }
 else {
        if (DBG)         log(""String_Node_Str"");
        conn.reset(obtainMessage(EVENT_RESET_DONE,reason));
      }
      notificationDeferred=true;
    }
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}","/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying DataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : dataConnectionList) {
    if (conn != null) {
      if (tearDown) {
        if (DBG)         log(""String_Node_Str"");
        conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
        notificationDeferred=true;
      }
 else {
        if (DBG)         log(""String_Node_Str"");
        conn.resetSynchronously();
        notificationDeferred=false;
      }
    }
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}"
22868,"/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying GsmDataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : pdpList) {
    if (tearDown) {
      if (DBG)       log(""String_Node_Str"");
      conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
    }
 else {
      if (DBG)       log(""String_Node_Str"");
      conn.reset(obtainMessage(EVENT_RESET_DONE,reason));
    }
    notificationDeferred=true;
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}","/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying GsmDataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : pdpList) {
    if (tearDown) {
      if (DBG)       log(""String_Node_Str"");
      conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
      notificationDeferred=true;
    }
 else {
      if (DBG)       log(""String_Node_Str"");
      conn.resetSynchronously();
      notificationDeferred=false;
    }
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}"
22869,"public int compareTo(Configuration that){
  int n;
  float a=this.fontScale;
  float b=that.fontScale;
  if (a < b)   return -1;
  if (a > b)   return 1;
  n=this.mcc - that.mcc;
  if (n != 0)   return n;
  n=this.mnc - that.mnc;
  if (n != 0)   return n;
  n=this.locale.getLanguage().compareTo(that.locale.getLanguage());
  if (n != 0)   return n;
  n=this.locale.getCountry().compareTo(that.locale.getCountry());
  if (n != 0)   return n;
  n=this.locale.getVariant().compareTo(that.locale.getVariant());
  if (n != 0)   return n;
  n=this.touchscreen - that.touchscreen;
  if (n != 0)   return n;
  n=this.keyboard - that.keyboard;
  if (n != 0)   return n;
  n=this.keyboardHidden - that.keyboardHidden;
  if (n != 0)   return n;
  n=this.hardKeyboardHidden - that.hardKeyboardHidden;
  if (n != 0)   return n;
  n=this.navigation - that.navigation;
  if (n != 0)   return n;
  n=this.navigationHidden - that.navigationHidden;
  if (n != 0)   return n;
  n=this.orientation - that.orientation;
  if (n != 0)   return n;
  n=this.screenLayout - that.screenLayout;
  if (n != 0)   return n;
  n=this.uiMode - that.uiMode;
  return n;
}","public int compareTo(Configuration that){
  int n;
  float a=this.fontScale;
  float b=that.fontScale;
  if (a < b)   return -1;
  if (a > b)   return 1;
  n=this.mcc - that.mcc;
  if (n != 0)   return n;
  n=this.mnc - that.mnc;
  if (n != 0)   return n;
  if (this.locale == null) {
    if (that.locale != null)     return 1;
  }
 else   if (that.locale == null) {
    return -1;
  }
 else {
    n=this.locale.getLanguage().compareTo(that.locale.getLanguage());
    if (n != 0)     return n;
    n=this.locale.getCountry().compareTo(that.locale.getCountry());
    if (n != 0)     return n;
    n=this.locale.getVariant().compareTo(that.locale.getVariant());
    if (n != 0)     return n;
  }
  n=this.touchscreen - that.touchscreen;
  if (n != 0)   return n;
  n=this.keyboard - that.keyboard;
  if (n != 0)   return n;
  n=this.keyboardHidden - that.keyboardHidden;
  if (n != 0)   return n;
  n=this.hardKeyboardHidden - that.hardKeyboardHidden;
  if (n != 0)   return n;
  n=this.navigation - that.navigation;
  if (n != 0)   return n;
  n=this.navigationHidden - that.navigationHidden;
  if (n != 0)   return n;
  n=this.orientation - that.orientation;
  if (n != 0)   return n;
  n=this.screenLayout - that.screenLayout;
  if (n != 0)   return n;
  n=this.uiMode - that.uiMode;
  return n;
}"
22870,"public int hashCode(){
  return ((int)this.fontScale) + this.mcc + this.mnc+ this.locale.hashCode()+ this.touchscreen+ this.keyboard+ this.keyboardHidden+ this.hardKeyboardHidden+ this.navigation+ this.navigationHidden+ this.orientation+ this.screenLayout+ this.uiMode;
}","public int hashCode(){
  return ((int)this.fontScale) + this.mcc + this.mnc+ (this.locale != null ? this.locale.hashCode() : 0)+ this.touchscreen+ this.keyboard+ this.keyboardHidden+ this.hardKeyboardHidden+ this.navigation+ this.navigationHidden+ this.orientation+ this.screenLayout+ this.uiMode;
}"
22871,"public boolean validateMemoryResult(int startPid,int startMemory,Writer output,int limit) throws Exception {
  Thread.sleep(10000);
  mEndPid=getMediaserverPid();
  int memDiff=mEndMemory - startMemory;
  if (memDiff < 0)   memDiff=0;
 else   output.write(""String_Node_Str"" + memDiff);
  output.write(""String_Node_Str"");
  if (startPid != mEndPid) {
    output.write(""String_Node_Str"");
    return false;
  }
  if (memDiff > limit)   return false;
  return true;
}","public boolean validateMemoryResult(int startPid,int startMemory,Writer output,int limit) throws Exception {
  Thread.sleep(10000);
  mEndPid=getMediaserverPid();
  int memDiff=mEndMemory - startMemory;
  if (memDiff < 0) {
    memDiff=0;
  }
  output.write(""String_Node_Str"" + memDiff);
  output.write(""String_Node_Str"");
  if (startPid != mEndPid) {
    output.write(""String_Node_Str"");
    return false;
  }
  if (memDiff > limit)   return false;
  return true;
}"
22872,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
    int grantedMode=data.readInt();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    boolean onlyIfNeeded=data.readInt() != 0;
    boolean debug=data.readInt() != 0;
    WaitResult result=startActivityAndWait(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
    reply.writeNoException();
    result.writeToParcel(reply,0);
    return true;
  }
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
  Intent fillInIntent=null;
  if (data.readInt() != 0) {
    fillInIntent=Intent.CREATOR.createFromParcel(data);
  }
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int flagsMask=data.readInt();
  int flagsValues=data.readInt();
  int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean result=startNextMatchingActivity(callingActivity,intent);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=finishActivity(token,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
if (token != null) {
activityIdle(token,config);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
boolean removeNotification=data.readInt() != 0;
setServiceForeground(className,token,id,notification,removeNotification);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
killBackgroundProcesses(packageName);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
forceStopPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeInt(isUserAMonkey() ? 1 : 0);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
    int grantedMode=data.readInt();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    boolean onlyIfNeeded=data.readInt() != 0;
    boolean debug=data.readInt() != 0;
    WaitResult result=startActivityAndWait(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
    reply.writeNoException();
    result.writeToParcel(reply,0);
    return true;
  }
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
  Intent fillInIntent=null;
  if (data.readInt() != 0) {
    fillInIntent=Intent.CREATOR.createFromParcel(data);
  }
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int flagsMask=data.readInt();
  int flagsValues=data.readInt();
  int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean result=startNextMatchingActivity(callingActivity,intent);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=finishActivity(token,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
if (token != null) {
activityIdle(token,config);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
boolean removeNotification=data.readInt() != 0;
setServiceForeground(className,token,id,notification,removeNotification);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
killBackgroundProcesses(packageName);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
forceStopPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeInt(isUserAMonkey() ? 1 : 0);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}"
22873,"final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward){
  unscheduleGcIdler();
  ActivityRecord r=performResumeActivity(token,clearHide);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    if (r.window == null && !a.mFinished && !a.mStartedActivity) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (a.mVisibleFromClient) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (a.mStartedActivity) {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    if (!r.activity.mFinished && !a.mStartedActivity && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ r.newConfig);
        performConfigurationChanged(r.activity,r.newConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        if (r.activity.mVisibleFromClient) {
          ViewManager wm=a.getWindowManager();
          View decor=r.window.getDecorView();
          wm.updateViewLayout(decor,l);
        }
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    r.nextIdle=mNewActivities;
    mNewActivities=r;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    Looper.myQueue().addIdleHandler(new Idler());
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}","final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward){
  unscheduleGcIdler();
  ActivityRecord r=performResumeActivity(token,clearHide);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    boolean willBeVisible=!a.mStartedActivity;
    if (!willBeVisible) {
      try {
        willBeVisible=ActivityManagerNative.getDefault().willActivityBeVisible(a.getActivityToken());
      }
 catch (      RemoteException e) {
      }
    }
    if (r.window == null && !a.mFinished && willBeVisible) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (a.mVisibleFromClient) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (!willBeVisible) {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    if (!r.activity.mFinished && willBeVisible && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ r.newConfig);
        performConfigurationChanged(r.activity,r.newConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        if (r.activity.mVisibleFromClient) {
          ViewManager wm=a.getWindowManager();
          View decor=r.window.getDecorView();
          wm.updateViewLayout(decor,l);
        }
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    r.nextIdle=mNewActivities;
    mNewActivities=r;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    Looper.myQueue().addIdleHandler(new Idler());
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}"
22874,"public final ActivityRecord performResumeActivity(IBinder token,boolean clearHide){
  ActivityRecord r=mActivities.get(token);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.activity.mFinished);
  if (r != null && !r.activity.mFinished) {
    if (clearHide) {
      r.hideForNow=false;
      r.activity.mStartedActivity=false;
    }
    try {
      if (r.pendingIntents != null) {
        deliverNewIntents(r,r.pendingIntents);
        r.pendingIntents=null;
      }
      if (r.pendingResults != null) {
        deliverResults(r,r.pendingResults);
        r.pendingResults=null;
      }
      r.activity.performResume();
      EventLog.writeEvent(LOG_ON_RESUME_CALLED,r.activity.getComponentName().getClassName());
      r.paused=false;
      r.stopped=false;
      if (r.activity.mStartedActivity) {
        r.hideForNow=true;
      }
      r.state=null;
    }
 catch (    Exception e) {
      if (!mInstrumentation.onException(r.activity,e)) {
        throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
      }
    }
  }
  return r;
}","public final ActivityRecord performResumeActivity(IBinder token,boolean clearHide){
  ActivityRecord r=mActivities.get(token);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.activity.mFinished);
  if (r != null && !r.activity.mFinished) {
    if (clearHide) {
      r.hideForNow=false;
      r.activity.mStartedActivity=false;
    }
    try {
      if (r.pendingIntents != null) {
        deliverNewIntents(r,r.pendingIntents);
        r.pendingIntents=null;
      }
      if (r.pendingResults != null) {
        deliverResults(r,r.pendingResults);
        r.pendingResults=null;
      }
      r.activity.performResume();
      EventLog.writeEvent(LOG_ON_RESUME_CALLED,r.activity.getComponentName().getClassName());
      r.paused=false;
      r.stopped=false;
      r.state=null;
    }
 catch (    Exception e) {
      if (!mInstrumentation.onException(r.activity,e)) {
        throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
      }
    }
  }
  return r;
}"
22875,"final void handleProfilerControl(boolean start,ProfilerControlData pcd){
  if (start) {
    try {
      Debug.startMethodTracing(pcd.path,pcd.fd.getFileDescriptor(),8 * 1024 * 1024,0);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + pcd.path + ""String_Node_Str"");
    }
 finally {
      try {
        pcd.fd.close();
      }
 catch (      IOException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
 else {
    Debug.stopMethodTracing();
  }
}","final void handleProfilerControl(boolean start,ProfilerControlData pcd){
  if (start) {
    try {
      Debug.startMethodTracing(pcd.path,pcd.fd.getFileDescriptor(),8 * 1024 * 1024,0);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + pcd.path + ""String_Node_Str"");
    }
 finally {
      try {
        pcd.fd.close();
      }
 catch (      IOException e) {
        Slog.w(TAG,""String_Node_Str"",e);
      }
    }
  }
 else {
    Debug.stopMethodTracing();
  }
}"
22876,"public void setSchedulingGroup(int group){
  try {
    Process.setProcessGroup(Process.myPid(),group);
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"" + group,e);
  }
}","public void setSchedulingGroup(int group){
  try {
    Process.setProcessGroup(Process.myPid(),group);
  }
 catch (  Exception e) {
    Slog.w(TAG,""String_Node_Str"" + group,e);
  }
}"
22877,"public void removeContextRegistrations(Context context,String who,String what){
  HashMap<BroadcastReceiver,ReceiverDispatcher> rmap=mReceivers.remove(context);
  if (rmap != null) {
    Iterator<ReceiverDispatcher> it=rmap.values().iterator();
    while (it.hasNext()) {
      ReceiverDispatcher rd=it.next();
      IntentReceiverLeaked leak=new IntentReceiverLeaked(what + ""String_Node_Str"" + who+ ""String_Node_Str""+ rd.getIntentReceiver()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      leak.setStackTrace(rd.getLocation().getStackTrace());
      Log.e(TAG,leak.getMessage(),leak);
      try {
        ActivityManagerNative.getDefault().unregisterReceiver(rd.getIIntentReceiver());
      }
 catch (      RemoteException e) {
      }
    }
  }
  mUnregisteredReceivers.remove(context);
  HashMap<ServiceConnection,ServiceDispatcher> smap=mServices.remove(context);
  if (smap != null) {
    Iterator<ServiceDispatcher> it=smap.values().iterator();
    while (it.hasNext()) {
      ServiceDispatcher sd=it.next();
      ServiceConnectionLeaked leak=new ServiceConnectionLeaked(what + ""String_Node_Str"" + who+ ""String_Node_Str""+ sd.getServiceConnection()+ ""String_Node_Str"");
      leak.setStackTrace(sd.getLocation().getStackTrace());
      Log.e(TAG,leak.getMessage(),leak);
      try {
        ActivityManagerNative.getDefault().unbindService(sd.getIServiceConnection());
      }
 catch (      RemoteException e) {
      }
      sd.doForget();
    }
  }
  mUnboundServices.remove(context);
}","public void removeContextRegistrations(Context context,String who,String what){
  HashMap<BroadcastReceiver,ReceiverDispatcher> rmap=mReceivers.remove(context);
  if (rmap != null) {
    Iterator<ReceiverDispatcher> it=rmap.values().iterator();
    while (it.hasNext()) {
      ReceiverDispatcher rd=it.next();
      IntentReceiverLeaked leak=new IntentReceiverLeaked(what + ""String_Node_Str"" + who+ ""String_Node_Str""+ rd.getIntentReceiver()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      leak.setStackTrace(rd.getLocation().getStackTrace());
      Slog.e(TAG,leak.getMessage(),leak);
      try {
        ActivityManagerNative.getDefault().unregisterReceiver(rd.getIIntentReceiver());
      }
 catch (      RemoteException e) {
      }
    }
  }
  mUnregisteredReceivers.remove(context);
  HashMap<ServiceConnection,ServiceDispatcher> smap=mServices.remove(context);
  if (smap != null) {
    Iterator<ServiceDispatcher> it=smap.values().iterator();
    while (it.hasNext()) {
      ServiceDispatcher sd=it.next();
      ServiceConnectionLeaked leak=new ServiceConnectionLeaked(what + ""String_Node_Str"" + who+ ""String_Node_Str""+ sd.getServiceConnection()+ ""String_Node_Str"");
      leak.setStackTrace(sd.getLocation().getStackTrace());
      Slog.e(TAG,leak.getMessage(),leak);
      try {
        ActivityManagerNative.getDefault().unbindService(sd.getIServiceConnection());
      }
 catch (      RemoteException e) {
      }
      sd.doForget();
    }
  }
  mUnboundServices.remove(context);
}"
22878,"private final void handleCreateBackupAgent(CreateBackupAgentData data){
  if (DEBUG_BACKUP)   Log.v(TAG,""String_Node_Str"" + data);
  unscheduleGcIdler();
  PackageInfo packageInfo=getPackageInfoNoCheck(data.appInfo);
  String packageName=packageInfo.mPackageName;
  if (mBackupAgents.get(packageName) != null) {
    Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + packageName + ""String_Node_Str"");
    return;
  }
  BackupAgent agent=null;
  String classname=data.appInfo.backupAgentName;
  if (classname == null) {
    if (data.backupMode == IApplicationThread.BACKUP_MODE_INCREMENTAL) {
      Log.e(TAG,""String_Node_Str"" + packageName);
      return;
    }
    classname=""String_Node_Str"";
  }
  try {
    IBinder binder=null;
    try {
      java.lang.ClassLoader cl=packageInfo.getClassLoader();
      agent=(BackupAgent)cl.loadClass(data.appInfo.backupAgentName).newInstance();
      if (DEBUG_BACKUP)       Log.v(TAG,""String_Node_Str"" + data.appInfo.backupAgentName);
      ContextImpl context=new ContextImpl();
      context.init(packageInfo,null,this);
      context.setOuterContext(agent);
      agent.attach(context);
      agent.onCreate();
      binder=agent.onBind();
      mBackupAgents.put(packageName,agent);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"" + e);
      if (data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE) {
        throw e;
      }
    }
    try {
      ActivityManagerNative.getDefault().backupAgentCreated(packageName,binder);
    }
 catch (    RemoteException e) {
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + data.appInfo.backupAgentName + ""String_Node_Str""+ e.toString(),e);
  }
}","private final void handleCreateBackupAgent(CreateBackupAgentData data){
  if (DEBUG_BACKUP)   Log.v(TAG,""String_Node_Str"" + data);
  unscheduleGcIdler();
  PackageInfo packageInfo=getPackageInfoNoCheck(data.appInfo);
  String packageName=packageInfo.mPackageName;
  if (mBackupAgents.get(packageName) != null) {
    Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + packageName + ""String_Node_Str"");
    return;
  }
  BackupAgent agent=null;
  String classname=data.appInfo.backupAgentName;
  if (classname == null) {
    if (data.backupMode == IApplicationThread.BACKUP_MODE_INCREMENTAL) {
      Slog.e(TAG,""String_Node_Str"" + packageName);
      return;
    }
    classname=""String_Node_Str"";
  }
  try {
    IBinder binder=null;
    try {
      java.lang.ClassLoader cl=packageInfo.getClassLoader();
      agent=(BackupAgent)cl.loadClass(data.appInfo.backupAgentName).newInstance();
      if (DEBUG_BACKUP)       Log.v(TAG,""String_Node_Str"" + data.appInfo.backupAgentName);
      ContextImpl context=new ContextImpl();
      context.init(packageInfo,null,this);
      context.setOuterContext(agent);
      agent.attach(context);
      agent.onCreate();
      binder=agent.onBind();
      mBackupAgents.put(packageName,agent);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"" + e);
      if (data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE) {
        throw e;
      }
    }
    try {
      ActivityManagerNative.getDefault().backupAgentCreated(packageName,binder);
    }
 catch (    RemoteException e) {
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + data.appInfo.backupAgentName + ""String_Node_Str""+ e.toString(),e);
  }
}"
22879,"private final IContentProvider installProvider(Context context,IContentProvider provider,ProviderInfo info,boolean noisy){
  ContentProvider localProvider=null;
  if (provider == null) {
    if (noisy) {
      Log.d(TAG,""String_Node_Str"" + info.authority + ""String_Node_Str""+ info.name);
    }
    Context c=null;
    ApplicationInfo ai=info.applicationInfo;
    if (context.getPackageName().equals(ai.packageName)) {
      c=context;
    }
 else     if (mInitialApplication != null && mInitialApplication.getPackageName().equals(ai.packageName)) {
      c=mInitialApplication;
    }
 else {
      try {
        c=context.createPackageContext(ai.packageName,Context.CONTEXT_INCLUDE_CODE);
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    if (c == null) {
      Log.w(TAG,""String_Node_Str"" + ai.packageName + ""String_Node_Str""+ info.name);
      return null;
    }
    try {
      final java.lang.ClassLoader cl=c.getClassLoader();
      localProvider=(ContentProvider)cl.loadClass(info.name).newInstance();
      provider=localProvider.getIContentProvider();
      if (provider == null) {
        Log.e(TAG,""String_Node_Str"" + info.name + ""String_Node_Str""+ info.applicationInfo.sourceDir);
        return null;
      }
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + info.name);
      localProvider.attachInfo(c,info);
    }
 catch (    java.lang.Exception e) {
      if (!mInstrumentation.onException(null,e)) {
        throw new RuntimeException(""String_Node_Str"" + info.name + ""String_Node_Str""+ e.toString(),e);
      }
      return null;
    }
  }
 else   if (localLOGV) {
    Log.v(TAG,""String_Node_Str"" + info.authority + ""String_Node_Str""+ info.name);
  }
synchronized (mProviderMap) {
    String names[]=PATTERN_SEMICOLON.split(info.authority);
    for (int i=0; i < names.length; i++) {
      ProviderRecord pr=new ProviderRecord(names[i],provider,localProvider);
      try {
        provider.asBinder().linkToDeath(pr,0);
        mProviderMap.put(names[i],pr);
      }
 catch (      RemoteException e) {
        return null;
      }
    }
    if (localProvider != null) {
      mLocalProviders.put(provider.asBinder(),new ProviderRecord(null,provider,localProvider));
    }
  }
  return provider;
}","private final IContentProvider installProvider(Context context,IContentProvider provider,ProviderInfo info,boolean noisy){
  ContentProvider localProvider=null;
  if (provider == null) {
    if (noisy) {
      Log.d(TAG,""String_Node_Str"" + info.authority + ""String_Node_Str""+ info.name);
    }
    Context c=null;
    ApplicationInfo ai=info.applicationInfo;
    if (context.getPackageName().equals(ai.packageName)) {
      c=context;
    }
 else     if (mInitialApplication != null && mInitialApplication.getPackageName().equals(ai.packageName)) {
      c=mInitialApplication;
    }
 else {
      try {
        c=context.createPackageContext(ai.packageName,Context.CONTEXT_INCLUDE_CODE);
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    if (c == null) {
      Slog.w(TAG,""String_Node_Str"" + ai.packageName + ""String_Node_Str""+ info.name);
      return null;
    }
    try {
      final java.lang.ClassLoader cl=c.getClassLoader();
      localProvider=(ContentProvider)cl.loadClass(info.name).newInstance();
      provider=localProvider.getIContentProvider();
      if (provider == null) {
        Slog.e(TAG,""String_Node_Str"" + info.name + ""String_Node_Str""+ info.applicationInfo.sourceDir);
        return null;
      }
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + info.name);
      localProvider.attachInfo(c,info);
    }
 catch (    java.lang.Exception e) {
      if (!mInstrumentation.onException(null,e)) {
        throw new RuntimeException(""String_Node_Str"" + info.name + ""String_Node_Str""+ e.toString(),e);
      }
      return null;
    }
  }
 else   if (localLOGV) {
    Log.v(TAG,""String_Node_Str"" + info.authority + ""String_Node_Str""+ info.name);
  }
synchronized (mProviderMap) {
    String names[]=PATTERN_SEMICOLON.split(info.authority);
    for (int i=0; i < names.length; i++) {
      ProviderRecord pr=new ProviderRecord(names[i],provider,localProvider);
      try {
        provider.asBinder().linkToDeath(pr,0);
        mProviderMap.put(names[i],pr);
      }
 catch (      RemoteException e) {
        return null;
      }
    }
    if (localProvider != null) {
      mLocalProviders.put(provider.asBinder(),new ProviderRecord(null,provider,localProvider));
    }
  }
  return provider;
}"
22880,"private final void handleDestroyBackupAgent(CreateBackupAgentData data){
  if (DEBUG_BACKUP)   Log.v(TAG,""String_Node_Str"" + data);
  PackageInfo packageInfo=getPackageInfoNoCheck(data.appInfo);
  String packageName=packageInfo.mPackageName;
  BackupAgent agent=mBackupAgents.get(packageName);
  if (agent != null) {
    try {
      agent.onDestroy();
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + data.appInfo);
      e.printStackTrace();
    }
    mBackupAgents.remove(packageName);
  }
 else {
    Log.w(TAG,""String_Node_Str"" + data);
  }
}","private final void handleDestroyBackupAgent(CreateBackupAgentData data){
  if (DEBUG_BACKUP)   Log.v(TAG,""String_Node_Str"" + data);
  PackageInfo packageInfo=getPackageInfoNoCheck(data.appInfo);
  String packageName=packageInfo.mPackageName;
  BackupAgent agent=mBackupAgents.get(packageName);
  if (agent != null) {
    try {
      agent.onDestroy();
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + data.appInfo);
      e.printStackTrace();
    }
    mBackupAgents.remove(packageName);
  }
 else {
    Slog.w(TAG,""String_Node_Str"" + data);
  }
}"
22881,"private final IContentProvider getProvider(Context context,String name){
synchronized (mProviderMap) {
    final ProviderRecord pr=mProviderMap.get(name);
    if (pr != null) {
      return pr.mProvider;
    }
  }
  IActivityManager.ContentProviderHolder holder=null;
  try {
    holder=ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(),name);
  }
 catch (  RemoteException ex) {
  }
  if (holder == null) {
    Log.e(TAG,""String_Node_Str"" + name);
    return null;
  }
  if (holder.permissionFailure != null) {
    throw new SecurityException(""String_Node_Str"" + holder.permissionFailure + ""String_Node_Str""+ name);
  }
  IContentProvider prov=installProvider(context,holder.provider,holder.info,true);
  if (holder.noReleaseNeeded || holder.provider == null) {
synchronized (mProviderMap) {
      mProviderRefCountMap.put(prov.asBinder(),new ProviderRefCount(10000));
    }
  }
  return prov;
}","private final IContentProvider getProvider(Context context,String name){
synchronized (mProviderMap) {
    final ProviderRecord pr=mProviderMap.get(name);
    if (pr != null) {
      return pr.mProvider;
    }
  }
  IActivityManager.ContentProviderHolder holder=null;
  try {
    holder=ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(),name);
  }
 catch (  RemoteException ex) {
  }
  if (holder == null) {
    Slog.e(TAG,""String_Node_Str"" + name);
    return null;
  }
  if (holder.permissionFailure != null) {
    throw new SecurityException(""String_Node_Str"" + holder.permissionFailure + ""String_Node_Str""+ name);
  }
  IContentProvider prov=installProvider(context,holder.provider,holder.info,true);
  if (holder.noReleaseNeeded || holder.provider == null) {
synchronized (mProviderMap) {
      mProviderRefCountMap.put(prov.asBinder(),new ProviderRefCount(10000));
    }
  }
  return prov;
}"
22882,"private final void performStopActivityInner(ActivityRecord r,StopInfo info,boolean keepShown){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  if (r != null) {
    if (!keepShown && r.stopped) {
      if (r.activity.mFinished) {
        return;
      }
      RuntimeException e=new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString());
      Log.e(TAG,e.getMessage(),e);
    }
    if (info != null) {
      try {
        info.description=r.activity.onCreateDescription();
      }
 catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
    }
    if (!keepShown) {
      try {
        r.activity.performStop();
      }
 catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.stopped=true;
    }
    r.paused=true;
  }
}","private final void performStopActivityInner(ActivityRecord r,StopInfo info,boolean keepShown){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  if (r != null) {
    if (!keepShown && r.stopped) {
      if (r.activity.mFinished) {
        return;
      }
      RuntimeException e=new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString());
      Slog.e(TAG,e.getMessage(),e);
    }
    if (info != null) {
      try {
        info.description=r.activity.onCreateDescription();
      }
 catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
    }
    if (!keepShown) {
      try {
        r.activity.performStop();
      }
 catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.stopped=true;
    }
    r.paused=true;
  }
}"
22883,"private void warn(String methodName){
  if (warned) {
    return;
  }
  warned=true;
  Thread.currentThread().setContextClassLoader(getParent());
  Log.w(TAG,""String_Node_Str"" + methodName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","private void warn(String methodName){
  if (warned) {
    return;
  }
  warned=true;
  Thread.currentThread().setContextClassLoader(getParent());
  Slog.w(TAG,""String_Node_Str"" + methodName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
22884,"final Bundle performPauseActivity(ActivityRecord r,boolean finished,boolean saveState){
  if (r.paused) {
    if (r.activity.mFinished) {
      return null;
    }
    RuntimeException e=new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString());
    Log.e(TAG,e.getMessage(),e);
  }
  Bundle state=null;
  if (finished) {
    r.activity.mFinished=true;
  }
  try {
    if (!r.activity.mFinished && saveState) {
      state=new Bundle();
      mInstrumentation.callActivityOnSaveInstanceState(r.activity,state);
      r.state=state;
    }
    r.activity.mCalled=false;
    mInstrumentation.callActivityOnPause(r.activity);
    EventLog.writeEvent(LOG_ON_PAUSE_CALLED,r.activity.getComponentName().getClassName());
    if (!r.activity.mCalled) {
      throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
    }
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(r.activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
    }
  }
  r.paused=true;
  return state;
}","final Bundle performPauseActivity(ActivityRecord r,boolean finished,boolean saveState){
  if (r.paused) {
    if (r.activity.mFinished) {
      return null;
    }
    RuntimeException e=new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString());
    Slog.e(TAG,e.getMessage(),e);
  }
  Bundle state=null;
  if (finished) {
    r.activity.mFinished=true;
  }
  try {
    if (!r.activity.mFinished && saveState) {
      state=new Bundle();
      mInstrumentation.callActivityOnSaveInstanceState(r.activity,state);
      r.state=state;
    }
    r.activity.mCalled=false;
    mInstrumentation.callActivityOnPause(r.activity);
    EventLog.writeEvent(LOG_ON_PAUSE_CALLED,r.activity.getComponentName().getClassName());
    if (!r.activity.mCalled) {
      throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
    }
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(r.activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
    }
  }
  r.paused=true;
  return state;
}"
22885,"/** 
 * The main function called when started through the zygote process. This could be unified with main(), if the native code in finishInit() were rationalized with Zygote startup.<p> Current recognized args: <ul> <li> --nice-name=<i>nice name to appear in ps</i> <li> <code> [--] &lt;start class name&gt;  &lt;args&gt; </ul>
 * @param argv arg strings
 */
public static final void zygoteInit(String[] argv) throws ZygoteInit.MethodAndArgsCaller {
  System.setOut(new AndroidPrintStream(Log.INFO,""String_Node_Str""));
  System.setErr(new AndroidPrintStream(Log.WARN,""String_Node_Str""));
  commonInit();
  zygoteInitNative();
  int curArg=0;
  for (; curArg < argv.length; curArg++) {
    String arg=argv[curArg];
    if (arg.equals(""String_Node_Str"")) {
      curArg++;
      break;
    }
 else     if (!arg.startsWith(""String_Node_Str"")) {
      break;
    }
 else     if (arg.startsWith(""String_Node_Str"")) {
      String niceName=arg.substring(arg.indexOf('=') + 1);
      Process.setArgV0(niceName);
    }
  }
  if (curArg == argv.length) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  String startClass=argv[curArg++];
  String[] startArgs=new String[argv.length - curArg];
  System.arraycopy(argv,curArg,startArgs,0,startArgs.length);
  invokeStaticMain(startClass,startArgs);
}","/** 
 * The main function called when started through the zygote process. This could be unified with main(), if the native code in finishInit() were rationalized with Zygote startup.<p> Current recognized args: <ul> <li> --nice-name=<i>nice name to appear in ps</i> <li> <code> [--] &lt;start class name&gt;  &lt;args&gt; </ul>
 * @param argv arg strings
 */
public static final void zygoteInit(String[] argv) throws ZygoteInit.MethodAndArgsCaller {
  System.setOut(new AndroidPrintStream(Log.INFO,""String_Node_Str""));
  System.setErr(new AndroidPrintStream(Log.WARN,""String_Node_Str""));
  commonInit();
  zygoteInitNative();
  int curArg=0;
  for (; curArg < argv.length; curArg++) {
    String arg=argv[curArg];
    if (arg.equals(""String_Node_Str"")) {
      curArg++;
      break;
    }
 else     if (!arg.startsWith(""String_Node_Str"")) {
      break;
    }
 else     if (arg.startsWith(""String_Node_Str"")) {
      String niceName=arg.substring(arg.indexOf('=') + 1);
      Process.setArgV0(niceName);
    }
  }
  if (curArg == argv.length) {
    Slog.e(TAG,""String_Node_Str"");
    return;
  }
  String startClass=argv[curArg++];
  String[] startArgs=new String[argv.length - curArg];
  System.arraycopy(argv,curArg,startArgs,0,startArgs.length);
  invokeStaticMain(startClass,startArgs);
}"
22886,"/** 
 * Report a serious error in the current process.  May or may not cause the process to terminate (depends on system settings).
 * @param tag to record with the error
 * @param t exception describing the error site and conditions
 */
public static void wtf(String tag,Throwable t){
  try {
    if (ActivityManagerNative.getDefault().handleApplicationWtf(mApplicationObject,tag,new ApplicationErrorReport.CrashInfo(t))) {
      Process.killProcess(Process.myPid());
      System.exit(10);
    }
  }
 catch (  Throwable t2) {
    Log.e(TAG,""String_Node_Str"",t2);
  }
}","/** 
 * Report a serious error in the current process.  May or may not cause the process to terminate (depends on system settings).
 * @param tag to record with the error
 * @param t exception describing the error site and conditions
 */
public static void wtf(String tag,Throwable t){
  try {
    if (ActivityManagerNative.getDefault().handleApplicationWtf(mApplicationObject,tag,new ApplicationErrorReport.CrashInfo(t))) {
      Process.killProcess(Process.myPid());
      System.exit(10);
    }
  }
 catch (  Throwable t2) {
    Slog.e(TAG,""String_Node_Str"",t2);
  }
}"
22887,"public static final void main(String[] argv){
  commonInit();
  finishInit();
  if (Config.LOGV)   Log.d(TAG,""String_Node_Str"");
}","public static final void main(String[] argv){
  commonInit();
  finishInit();
  if (Config.LOGV)   Slog.d(TAG,""String_Node_Str"");
}"
22888,"private static final void commonInit(){
  if (Config.LOGV)   Log.d(TAG,""String_Node_Str"");
  Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());
  int hasQwerty=getQwertyKeyboard();
  if (Config.LOGV)   Log.d(TAG,""String_Node_Str"" + hasQwerty);
  if (hasQwerty == 1) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  TimezoneGetter.setInstance(new TimezoneGetter(){
    @Override public String getId(){
      return SystemProperties.get(""String_Node_Str"");
    }
  }
);
  TimeZone.setDefault(null);
  LogManager.getLogManager().reset();
  new AndroidConfig();
  String userAgent=getDefaultUserAgent();
  System.setProperty(""String_Node_Str"",userAgent);
  String trace=SystemProperties.get(""String_Node_Str"");
  if (trace.equals(""String_Node_Str"")) {
    Log.i(TAG,""String_Node_Str"");
    Debug.enableEmulatorTraceOutput();
  }
  initialized=true;
}","private static final void commonInit(){
  if (Config.LOGV)   Slog.d(TAG,""String_Node_Str"");
  Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());
  int hasQwerty=getQwertyKeyboard();
  if (Config.LOGV)   Slog.d(TAG,""String_Node_Str"" + hasQwerty);
  if (hasQwerty == 1) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  TimezoneGetter.setInstance(new TimezoneGetter(){
    @Override public String getId(){
      return SystemProperties.get(""String_Node_Str"");
    }
  }
);
  TimeZone.setDefault(null);
  LogManager.getLogManager().reset();
  new AndroidConfig();
  String userAgent=getDefaultUserAgent();
  System.setProperty(""String_Node_Str"",userAgent);
  String trace=SystemProperties.get(""String_Node_Str"");
  if (trace.equals(""String_Node_Str"")) {
    Slog.i(TAG,""String_Node_Str"");
    Debug.enableEmulatorTraceOutput();
  }
  initialized=true;
}"
22889,"public void uncaughtException(Thread t,Throwable e){
  try {
    if (mCrashing)     return;
    mCrashing=true;
    if (mApplicationObject == null) {
      Log.e(TAG,""String_Node_Str"" + t.getName(),e);
    }
 else {
      Log.e(TAG,""String_Node_Str"" + t.getName(),e);
    }
    ActivityManagerNative.getDefault().handleApplicationCrash(mApplicationObject,new ApplicationErrorReport.CrashInfo(e));
  }
 catch (  Throwable t2) {
    try {
      Log.e(TAG,""String_Node_Str"",t2);
    }
 catch (    Throwable t3) {
    }
  }
 finally {
    Process.killProcess(Process.myPid());
    System.exit(10);
  }
}","public void uncaughtException(Thread t,Throwable e){
  try {
    if (mCrashing)     return;
    mCrashing=true;
    if (mApplicationObject == null) {
      Slog.e(TAG,""String_Node_Str"" + t.getName(),e);
    }
 else {
      Slog.e(TAG,""String_Node_Str"" + t.getName(),e);
    }
    ActivityManagerNative.getDefault().handleApplicationCrash(mApplicationObject,new ApplicationErrorReport.CrashInfo(e));
  }
 catch (  Throwable t2) {
    try {
      Slog.e(TAG,""String_Node_Str"",t2);
    }
 catch (    Throwable t3) {
    }
  }
 finally {
    Process.killProcess(Process.myPid());
    System.exit(10);
  }
}"
22890,"public void clearWallpaperLocked(){
  File f=WALLPAPER_FILE;
  if (f.exists()) {
    f.delete();
  }
  final long ident=Binder.clearCallingIdentity();
  try {
    bindWallpaperComponentLocked(null);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void clearWallpaperLocked(){
  File f=WALLPAPER_FILE;
  if (f.exists()) {
    f.delete();
  }
  final long ident=Binder.clearCallingIdentity();
  try {
    bindWallpaperComponentLocked(null);
  }
 catch (  IllegalArgumentException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
22891,"/** 
 * Reboot the device immediately, passing 'reason' (may be null) to the underlying __reboot system call.  Should not return.
 */
public void reboot(String reason){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT,null);
  if (mHandler == null || !ActivityManagerNative.isSystemReady()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final String finalReason=reason;
  Runnable runnable=new Runnable(){
    public void run(){
synchronized (this) {
        ShutdownThread.reboot(mContext,finalReason,false);
        notify();
      }
    }
  }
;
  mHandler.post(runnable);
synchronized (runnable) {
    try {
      runnable.wait();
    }
 catch (    InterruptedException e) {
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * Reboot the device immediately, passing 'reason' (may be null) to the underlying __reboot system call.  Should not return.
 */
public void reboot(String reason){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT,null);
  if (mHandler == null || !ActivityManagerNative.isSystemReady()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final String finalReason=reason;
  Runnable runnable=new Runnable(){
    public void run(){
synchronized (this) {
        ShutdownThread.reboot(mContext,finalReason,false);
      }
    }
  }
;
  mHandler.post(runnable);
synchronized (runnable) {
    while (true) {
      try {
        runnable.wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
}"
22892,"final void appNotRespondingLocked(ProcessRecord app,HistoryRecord activity,HistoryRecord parent,final String annotation){
  if (app.notResponding || app.crashing) {
    return;
  }
  EventLog.writeEvent(EventLogTags.AM_ANR,app.pid,app.processName,app.info.flags,annotation);
  ArrayList<Integer> pids=new ArrayList<Integer>(20);
  pids.add(app.pid);
  int parentPid=app.pid;
  if (parent != null && parent.app != null && parent.app.pid > 0)   parentPid=parent.app.pid;
  if (parentPid != app.pid)   pids.add(parentPid);
  if (MY_PID != app.pid && MY_PID != parentPid)   pids.add(MY_PID);
  for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
    ProcessRecord r=mLruProcesses.get(i);
    if (r != null && r.thread != null) {
      int pid=r.pid;
      if (pid > 0 && pid != app.pid && pid != parentPid && pid != MY_PID)       pids.add(pid);
    }
  }
  File tracesFile=dumpStackTraces(pids);
  StringBuilder info=mStringBuilder;
  info.setLength(0);
  info.append(""String_Node_Str"").append(app.processName);
  if (activity != null && activity.shortComponentName != null) {
    info.append(""String_Node_Str"").append(activity.shortComponentName).append(""String_Node_Str"");
  }
  info.append(""String_Node_Str"");
  if (annotation != null) {
    info.append(""String_Node_Str"").append(annotation).append(""String_Node_Str"");
  }
  if (parent != null && parent != activity) {
    info.append(""String_Node_Str"").append(parent.shortComponentName).append(""String_Node_Str"");
  }
  String cpuInfo=null;
  if (MONITOR_CPU_USAGE) {
    updateCpuStatsNow();
synchronized (mProcessStatsThread) {
      cpuInfo=mProcessStats.printCurrentState();
    }
    info.append(cpuInfo);
  }
  Slog.e(TAG,info.toString());
  if (tracesFile == null) {
    Process.sendSignal(app.pid,Process.SIGNAL_QUIT);
  }
  addErrorToDropBox(""String_Node_Str"",app,activity,parent,annotation,cpuInfo,tracesFile,null);
  if (mController != null) {
    try {
      int res=mController.appNotResponding(app.processName,app.pid,info.toString());
      if (res != 0) {
        if (res < 0 && app.pid != MY_PID)         Process.killProcess(app.pid);
        return;
      }
    }
 catch (    RemoteException e) {
      mController=null;
    }
  }
  boolean showBackground=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ANR_SHOW_BACKGROUND,0) != 0;
  if (!showBackground && !app.isInterestingToUserLocked() && app.pid != MY_PID) {
    Process.killProcess(app.pid);
    return;
  }
  makeAppNotRespondingLocked(app,activity != null ? activity.shortComponentName : null,annotation != null ? ""String_Node_Str"" + annotation : ""String_Node_Str"",info.toString());
  Message msg=Message.obtain();
  HashMap map=new HashMap();
  msg.what=SHOW_NOT_RESPONDING_MSG;
  msg.obj=map;
  map.put(""String_Node_Str"",app);
  if (activity != null) {
    map.put(""String_Node_Str"",activity);
  }
  mHandler.sendMessage(msg);
  return;
}","final void appNotRespondingLocked(ProcessRecord app,HistoryRecord activity,HistoryRecord parent,final String annotation){
  if (mShuttingDown || app.notResponding || app.crashing) {
    return;
  }
  EventLog.writeEvent(EventLogTags.AM_ANR,app.pid,app.processName,app.info.flags,annotation);
  ArrayList<Integer> pids=new ArrayList<Integer>(20);
  pids.add(app.pid);
  int parentPid=app.pid;
  if (parent != null && parent.app != null && parent.app.pid > 0)   parentPid=parent.app.pid;
  if (parentPid != app.pid)   pids.add(parentPid);
  if (MY_PID != app.pid && MY_PID != parentPid)   pids.add(MY_PID);
  for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
    ProcessRecord r=mLruProcesses.get(i);
    if (r != null && r.thread != null) {
      int pid=r.pid;
      if (pid > 0 && pid != app.pid && pid != parentPid && pid != MY_PID)       pids.add(pid);
    }
  }
  File tracesFile=dumpStackTraces(pids);
  StringBuilder info=mStringBuilder;
  info.setLength(0);
  info.append(""String_Node_Str"").append(app.processName);
  if (activity != null && activity.shortComponentName != null) {
    info.append(""String_Node_Str"").append(activity.shortComponentName).append(""String_Node_Str"");
  }
  info.append(""String_Node_Str"");
  if (annotation != null) {
    info.append(""String_Node_Str"").append(annotation).append(""String_Node_Str"");
  }
  if (parent != null && parent != activity) {
    info.append(""String_Node_Str"").append(parent.shortComponentName).append(""String_Node_Str"");
  }
  String cpuInfo=null;
  if (MONITOR_CPU_USAGE) {
    updateCpuStatsNow();
synchronized (mProcessStatsThread) {
      cpuInfo=mProcessStats.printCurrentState();
    }
    info.append(cpuInfo);
  }
  Slog.e(TAG,info.toString());
  if (tracesFile == null) {
    Process.sendSignal(app.pid,Process.SIGNAL_QUIT);
  }
  addErrorToDropBox(""String_Node_Str"",app,activity,parent,annotation,cpuInfo,tracesFile,null);
  if (mController != null) {
    try {
      int res=mController.appNotResponding(app.processName,app.pid,info.toString());
      if (res != 0) {
        if (res < 0 && app.pid != MY_PID)         Process.killProcess(app.pid);
        return;
      }
    }
 catch (    RemoteException e) {
      mController=null;
    }
  }
  boolean showBackground=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ANR_SHOW_BACKGROUND,0) != 0;
  if (!showBackground && !app.isInterestingToUserLocked() && app.pid != MY_PID) {
    Process.killProcess(app.pid);
    return;
  }
  makeAppNotRespondingLocked(app,activity != null ? activity.shortComponentName : null,annotation != null ? ""String_Node_Str"" + annotation : ""String_Node_Str"",info.toString());
  Message msg=Message.obtain();
  HashMap map=new HashMap();
  msg.what=SHOW_NOT_RESPONDING_MSG;
  msg.obj=map;
  map.put(""String_Node_Str"",app);
  if (activity != null) {
    map.put(""String_Node_Str"",activity);
  }
  mHandler.sendMessage(msg);
  return;
}"
22893,"/** 
 * Reboot the device immediately, passing 'reason' (may be null) to the underlying __reboot system call.  Should not return.
 */
public void reboot(String reason){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT,null);
  if (mHandler == null || !ActivityManagerNative.isSystemReady()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final String finalReason=reason;
  Runnable runnable=new Runnable(){
    public void run(){
synchronized (this) {
        ShutdownThread.reboot(mContext,finalReason,false);
        notify();
      }
    }
  }
;
  mHandler.post(runnable);
synchronized (runnable) {
    try {
      runnable.wait();
    }
 catch (    InterruptedException e) {
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * Reboot the device immediately, passing 'reason' (may be null) to the underlying __reboot system call.  Should not return.
 */
public void reboot(String reason){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT,null);
  if (mHandler == null || !ActivityManagerNative.isSystemReady()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final String finalReason=reason;
  Runnable runnable=new Runnable(){
    public void run(){
synchronized (this) {
        ShutdownThread.reboot(mContext,finalReason,false);
      }
    }
  }
;
  mHandler.post(runnable);
synchronized (runnable) {
    while (true) {
      try {
        runnable.wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
}"
22894,"final void appNotRespondingLocked(ProcessRecord app,HistoryRecord activity,HistoryRecord parent,final String annotation){
  if (app.notResponding || app.crashing) {
    return;
  }
  EventLog.writeEvent(EventLogTags.AM_ANR,app.pid,app.processName,app.info.flags,annotation);
  ArrayList<Integer> pids=new ArrayList<Integer>(20);
  pids.add(app.pid);
  int parentPid=app.pid;
  if (parent != null && parent.app != null && parent.app.pid > 0)   parentPid=parent.app.pid;
  if (parentPid != app.pid)   pids.add(parentPid);
  if (MY_PID != app.pid && MY_PID != parentPid)   pids.add(MY_PID);
  for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
    ProcessRecord r=mLruProcesses.get(i);
    if (r != null && r.thread != null) {
      int pid=r.pid;
      if (pid > 0 && pid != app.pid && pid != parentPid && pid != MY_PID)       pids.add(pid);
    }
  }
  File tracesFile=dumpStackTraces(pids);
  StringBuilder info=mStringBuilder;
  info.setLength(0);
  info.append(""String_Node_Str"").append(app.processName);
  if (activity != null && activity.shortComponentName != null) {
    info.append(""String_Node_Str"").append(activity.shortComponentName).append(""String_Node_Str"");
  }
  info.append(""String_Node_Str"");
  if (annotation != null) {
    info.append(""String_Node_Str"").append(annotation).append(""String_Node_Str"");
  }
  if (parent != null && parent != activity) {
    info.append(""String_Node_Str"").append(parent.shortComponentName).append(""String_Node_Str"");
  }
  String cpuInfo=null;
  if (MONITOR_CPU_USAGE) {
    updateCpuStatsNow();
synchronized (mProcessStatsThread) {
      cpuInfo=mProcessStats.printCurrentState();
    }
    info.append(cpuInfo);
  }
  Slog.e(TAG,info.toString());
  if (tracesFile == null) {
    Process.sendSignal(app.pid,Process.SIGNAL_QUIT);
  }
  addErrorToDropBox(""String_Node_Str"",app,activity,parent,annotation,cpuInfo,tracesFile,null);
  if (mController != null) {
    try {
      int res=mController.appNotResponding(app.processName,app.pid,info.toString());
      if (res != 0) {
        if (res < 0 && app.pid != MY_PID)         Process.killProcess(app.pid);
        return;
      }
    }
 catch (    RemoteException e) {
      mController=null;
    }
  }
  boolean showBackground=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ANR_SHOW_BACKGROUND,0) != 0;
  if (!showBackground && !app.isInterestingToUserLocked() && app.pid != MY_PID) {
    Process.killProcess(app.pid);
    return;
  }
  makeAppNotRespondingLocked(app,activity != null ? activity.shortComponentName : null,annotation != null ? ""String_Node_Str"" + annotation : ""String_Node_Str"",info.toString());
  Message msg=Message.obtain();
  HashMap map=new HashMap();
  msg.what=SHOW_NOT_RESPONDING_MSG;
  msg.obj=map;
  map.put(""String_Node_Str"",app);
  if (activity != null) {
    map.put(""String_Node_Str"",activity);
  }
  mHandler.sendMessage(msg);
  return;
}","final void appNotRespondingLocked(ProcessRecord app,HistoryRecord activity,HistoryRecord parent,final String annotation){
  if (mShuttingDown || app.notResponding || app.crashing) {
    return;
  }
  EventLog.writeEvent(EventLogTags.AM_ANR,app.pid,app.processName,app.info.flags,annotation);
  ArrayList<Integer> pids=new ArrayList<Integer>(20);
  pids.add(app.pid);
  int parentPid=app.pid;
  if (parent != null && parent.app != null && parent.app.pid > 0)   parentPid=parent.app.pid;
  if (parentPid != app.pid)   pids.add(parentPid);
  if (MY_PID != app.pid && MY_PID != parentPid)   pids.add(MY_PID);
  for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
    ProcessRecord r=mLruProcesses.get(i);
    if (r != null && r.thread != null) {
      int pid=r.pid;
      if (pid > 0 && pid != app.pid && pid != parentPid && pid != MY_PID)       pids.add(pid);
    }
  }
  File tracesFile=dumpStackTraces(pids);
  StringBuilder info=mStringBuilder;
  info.setLength(0);
  info.append(""String_Node_Str"").append(app.processName);
  if (activity != null && activity.shortComponentName != null) {
    info.append(""String_Node_Str"").append(activity.shortComponentName).append(""String_Node_Str"");
  }
  info.append(""String_Node_Str"");
  if (annotation != null) {
    info.append(""String_Node_Str"").append(annotation).append(""String_Node_Str"");
  }
  if (parent != null && parent != activity) {
    info.append(""String_Node_Str"").append(parent.shortComponentName).append(""String_Node_Str"");
  }
  String cpuInfo=null;
  if (MONITOR_CPU_USAGE) {
    updateCpuStatsNow();
synchronized (mProcessStatsThread) {
      cpuInfo=mProcessStats.printCurrentState();
    }
    info.append(cpuInfo);
  }
  Slog.e(TAG,info.toString());
  if (tracesFile == null) {
    Process.sendSignal(app.pid,Process.SIGNAL_QUIT);
  }
  addErrorToDropBox(""String_Node_Str"",app,activity,parent,annotation,cpuInfo,tracesFile,null);
  if (mController != null) {
    try {
      int res=mController.appNotResponding(app.processName,app.pid,info.toString());
      if (res != 0) {
        if (res < 0 && app.pid != MY_PID)         Process.killProcess(app.pid);
        return;
      }
    }
 catch (    RemoteException e) {
      mController=null;
    }
  }
  boolean showBackground=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ANR_SHOW_BACKGROUND,0) != 0;
  if (!showBackground && !app.isInterestingToUserLocked() && app.pid != MY_PID) {
    Process.killProcess(app.pid);
    return;
  }
  makeAppNotRespondingLocked(app,activity != null ? activity.shortComponentName : null,annotation != null ? ""String_Node_Str"" + annotation : ""String_Node_Str"",info.toString());
  Message msg=Message.obtain();
  HashMap map=new HashMap();
  msg.what=SHOW_NOT_RESPONDING_MSG;
  msg.obj=map;
  map.put(""String_Node_Str"",app);
  if (activity != null) {
    map.put(""String_Node_Str"",activity);
  }
  mHandler.sendMessage(msg);
  return;
}"
22895,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if (DEBUG_ORIENTATION && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if ((DEBUG_RESIZE || DEBUG_ORIENTATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}"
22896,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if (DEBUG_ORIENTATION && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if ((DEBUG_RESIZE || DEBUG_ORIENTATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}"
22897,"/** 
 * Searches for an entry in the CalendarAlerts table that matches the given event id, begin time and alarm time.  If one is found then this alarm already exists and this method returns true.
 * @param cr the ContentResolver
 * @param eventId the event id to match
 * @param begin the start time of the event in UTC millis
 * @param alarmTime the alarm time of the event in UTC millis
 * @return true if there is already an alarm for the given eventwith the same start time and alarm time.
 */
public static final boolean alarmExists(ContentResolver cr,long eventId,long begin,long alarmTime){
  String selection=CalendarAlerts.EVENT_ID + ""String_Node_Str"" + eventId+ ""String_Node_Str""+ CalendarAlerts.BEGIN+ ""String_Node_Str""+ begin+ ""String_Node_Str""+ CalendarAlerts.ALARM_TIME+ ""String_Node_Str""+ alarmTime;
  String[] projection=new String[]{CalendarAlerts.ALARM_TIME};
  Cursor cursor=query(cr,projection,selection,null,null);
  boolean found=false;
  try {
    if (cursor != null && cursor.getCount() > 0) {
      found=true;
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return found;
}","/** 
 * Searches for an entry in the CalendarAlerts table that matches the given event id, begin time and alarm time.  If one is found then this alarm already exists and this method returns true.
 * @param cr the ContentResolver
 * @param eventId the event id to match
 * @param begin the start time of the event in UTC millis
 * @param alarmTime the alarm time of the event in UTC millis
 * @return true if there is already an alarm for the given eventwith the same start time and alarm time.
 */
public static final boolean alarmExists(ContentResolver cr,long eventId,long begin,long alarmTime){
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=query(cr,projection,WHERE_ALARM_EXISTS,new String[]{Long.toString(eventId),Long.toString(begin),Long.toString(alarmTime)},null);
  boolean found=false;
  try {
    if (cursor != null && cursor.getCount() > 0) {
      found=true;
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return found;
}"
22898,"@Override public Entity getEntityAndIncrementCursor(Cursor cursor) throws RemoteException {
  final long eventId=cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
  ContentValues cv=new ContentValues();
  cv.put(Events._ID,eventId);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,CALENDAR_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HTML_URI);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,TITLE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DESCRIPTION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_LOCATION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,STATUS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,SELF_ATTENDEE_STATUS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,COMMENTS_URI);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTSTART);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTEND);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DURATION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_TIMEZONE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ALL_DAY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,VISIBILITY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,TRANSPARENCY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_ALARM);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_EXTENDED_PROPERTIES);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORIGINAL_EVENT);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,ORIGINAL_INSTANCE_TIME);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,ORIGINAL_ALL_DAY);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,LAST_DATE);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,HAS_ATTENDEE_DATA);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_INVITE_OTHERS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_MODIFY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_SEE_GUESTS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORGANIZER);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_DATA);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,_SYNC_DIRTY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_VERSION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,DELETED);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,Calendars.URL);
  Entity entity=new Entity(cv);
  Cursor subCursor;
  if (mResolver != null) {
    subCursor=mResolver.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
 else {
    subCursor=mProvider.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues reminderValues=new ContentValues();
      reminderValues.put(Reminders.MINUTES,subCursor.getInt(COLUMN_MINUTES));
      reminderValues.put(Reminders.METHOD,subCursor.getInt(COLUMN_METHOD));
      entity.addSubValue(Reminders.CONTENT_URI,reminderValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
 else {
    subCursor=mProvider.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues attendeeValues=new ContentValues();
      attendeeValues.put(Attendees.ATTENDEE_NAME,subCursor.getString(COLUMN_ATTENDEE_NAME));
      attendeeValues.put(Attendees.ATTENDEE_EMAIL,subCursor.getString(COLUMN_ATTENDEE_EMAIL));
      attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP,subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
      attendeeValues.put(Attendees.ATTENDEE_TYPE,subCursor.getInt(COLUMN_ATTENDEE_TYPE));
      attendeeValues.put(Attendees.ATTENDEE_STATUS,subCursor.getInt(COLUMN_ATTENDEE_STATUS));
      entity.addSubValue(Attendees.CONTENT_URI,attendeeValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
 else {
    subCursor=mProvider.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues extendedValues=new ContentValues();
      extendedValues.put(ExtendedProperties.NAME,subCursor.getString(COLUMN_NAME));
      extendedValues.put(ExtendedProperties.VALUE,subCursor.getString(COLUMN_VALUE));
      entity.addSubValue(ExtendedProperties.CONTENT_URI,extendedValues);
    }
  }
  finally {
    subCursor.close();
  }
  cursor.moveToNext();
  return entity;
}","@Override public Entity getEntityAndIncrementCursor(Cursor cursor) throws RemoteException {
  final long eventId=cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
  ContentValues cv=new ContentValues();
  cv.put(Events._ID,eventId);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,CALENDAR_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HTML_URI);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,TITLE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DESCRIPTION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_LOCATION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,STATUS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,SELF_ATTENDEE_STATUS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,COMMENTS_URI);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTSTART);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTEND);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DURATION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_TIMEZONE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ALL_DAY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,VISIBILITY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,TRANSPARENCY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_ALARM);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_EXTENDED_PROPERTIES);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORIGINAL_EVENT);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,ORIGINAL_INSTANCE_TIME);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,ORIGINAL_ALL_DAY);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,LAST_DATE);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,HAS_ATTENDEE_DATA);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_INVITE_OTHERS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_MODIFY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_SEE_GUESTS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORGANIZER);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_DATA);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,_SYNC_DIRTY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_VERSION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,DELETED);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,Calendars.URL);
  Entity entity=new Entity(cv);
  Cursor subCursor;
  if (mResolver != null) {
    subCursor=mResolver.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
 else {
    subCursor=mProvider.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues reminderValues=new ContentValues();
      reminderValues.put(Reminders.MINUTES,subCursor.getInt(COLUMN_MINUTES));
      reminderValues.put(Reminders.METHOD,subCursor.getInt(COLUMN_METHOD));
      entity.addSubValue(Reminders.CONTENT_URI,reminderValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
 else {
    subCursor=mProvider.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues attendeeValues=new ContentValues();
      attendeeValues.put(Attendees.ATTENDEE_NAME,subCursor.getString(COLUMN_ATTENDEE_NAME));
      attendeeValues.put(Attendees.ATTENDEE_EMAIL,subCursor.getString(COLUMN_ATTENDEE_EMAIL));
      attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP,subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
      attendeeValues.put(Attendees.ATTENDEE_TYPE,subCursor.getInt(COLUMN_ATTENDEE_TYPE));
      attendeeValues.put(Attendees.ATTENDEE_STATUS,subCursor.getInt(COLUMN_ATTENDEE_STATUS));
      entity.addSubValue(Attendees.CONTENT_URI,attendeeValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
 else {
    subCursor=mProvider.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues extendedValues=new ContentValues();
      extendedValues.put(ExtendedProperties.NAME,subCursor.getString(COLUMN_NAME));
      extendedValues.put(ExtendedProperties.VALUE,subCursor.getString(COLUMN_VALUE));
      entity.addSubValue(ExtendedProperties.CONTENT_URI,extendedValues);
    }
  }
  finally {
    subCursor.close();
  }
  cursor.moveToNext();
  return entity;
}"
22899,"/** 
 * Finds the next alarm after (or equal to) the given time and returns the time of that alarm or -1 if no such alarm exists.
 * @param cr the ContentResolver
 * @param millis the time in UTC milliseconds
 * @return the next alarm time greater than or equal to ""millis"", or -1if no such alarm exists.
 */
public static final long findNextAlarmTime(ContentResolver cr,long millis){
  String selection=ALARM_TIME + ""String_Node_Str"" + millis;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=query(cr,projection,selection,null,ALARM_TIME + ""String_Node_Str"");
  long alarmTime=-1;
  try {
    if (cursor != null && cursor.moveToFirst()) {
      alarmTime=cursor.getLong(0);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return alarmTime;
}","/** 
 * Finds the next alarm after (or equal to) the given time and returns the time of that alarm or -1 if no such alarm exists.
 * @param cr the ContentResolver
 * @param millis the time in UTC milliseconds
 * @return the next alarm time greater than or equal to ""millis"", or -1if no such alarm exists.
 */
public static final long findNextAlarmTime(ContentResolver cr,long millis){
  String selection=ALARM_TIME + ""String_Node_Str"" + millis;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=query(cr,projection,WHERE_FINDNEXTALARMTIME,new String[]{Long.toString(millis)},SORT_ORDER_ALARMTIME_ASC);
  long alarmTime=-1;
  try {
    if (cursor != null && cursor.moveToFirst()) {
      alarmTime=cursor.getLong(0);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return alarmTime;
}"
22900,"public static void scheduleAlarm(Context context,AlarmManager manager,long alarmTime){
  if (DEBUG) {
    Time time=new Time();
    time.set(alarmTime);
    String schedTime=time.format(""String_Node_Str"");
    Log.d(TAG,""String_Node_Str"" + alarmTime + ""String_Node_Str""+ schedTime);
  }
  if (manager == null) {
    manager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  }
  Intent intent=new Intent(android.provider.Calendar.EVENT_REMINDER_ACTION);
  intent.putExtra(android.provider.Calendar.CalendarAlerts.ALARM_TIME,alarmTime);
  PendingIntent pi=PendingIntent.getBroadcast(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  manager.set(AlarmManager.RTC_WAKEUP,alarmTime,pi);
}","public static void scheduleAlarm(Context context,AlarmManager manager,long alarmTime){
  if (DEBUG) {
    Time time=new Time();
    time.set(alarmTime);
    String schedTime=time.format(""String_Node_Str"");
    Log.d(TAG,""String_Node_Str"" + alarmTime + ""String_Node_Str""+ schedTime);
  }
  if (manager == null) {
    manager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  }
  Intent intent=new Intent(EVENT_REMINDER_ACTION);
  intent.putExtra(ALARM_TIME,alarmTime);
  PendingIntent pi=PendingIntent.getBroadcast(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  manager.set(AlarmManager.RTC_WAKEUP,alarmTime,pi);
}"
22901,"/** 
 * Convenience method to delete all calendars that match the account.
 * @param cr the ContentResolver
 * @param account the account whose rows should be deleted
 * @return the count of rows that were deleted
 */
public static int deleteCalendarsForAccount(ContentResolver cr,Account account){
  return Calendar.Calendars.delete(cr,Calendar.Calendars._SYNC_ACCOUNT + ""String_Node_Str"" + Calendar.Calendars._SYNC_ACCOUNT_TYPE+ ""String_Node_Str"",new String[]{account.name,account.type});
}","/** 
 * Convenience method to delete all calendars that match the account.
 * @param cr the ContentResolver
 * @param account the account whose rows should be deleted
 * @return the count of rows that were deleted
 */
public static int deleteCalendarsForAccount(ContentResolver cr,Account account){
  return Calendar.Calendars.delete(cr,WHERE_DELETE_FOR_ACCOUNT,new String[]{account.name,account.type});
}"
22902,"/** 
 * Searches the CalendarAlerts table for alarms that should have fired but have not and then reschedules them.  This method can be called at boot time to restore alarms that may have been lost due to a phone reboot.
 * @param cr the ContentResolver
 * @param context the Context
 * @param manager the AlarmManager
 */
public static final void rescheduleMissedAlarms(ContentResolver cr,Context context,AlarmManager manager){
  long now=System.currentTimeMillis();
  long ancient=now - DateUtils.DAY_IN_MILLIS;
  String selection=CalendarAlerts.STATE + ""String_Node_Str"" + CalendarAlerts.SCHEDULED+ ""String_Node_Str""+ CalendarAlerts.ALARM_TIME+ ""String_Node_Str""+ now+ ""String_Node_Str""+ CalendarAlerts.ALARM_TIME+ ""String_Node_Str""+ ancient+ ""String_Node_Str""+ CalendarAlerts.END+ ""String_Node_Str""+ now;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=CalendarAlerts.query(cr,projection,selection,null,""String_Node_Str"");
  if (cursor == null) {
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + cursor.getCount());
  }
  try {
    long alarmTime=-1;
    while (cursor.moveToNext()) {
      long newAlarmTime=cursor.getLong(0);
      if (alarmTime != newAlarmTime) {
        if (DEBUG) {
          Log.w(TAG,""String_Node_Str"" + newAlarmTime);
        }
        scheduleAlarm(context,manager,newAlarmTime);
        alarmTime=newAlarmTime;
      }
    }
  }
  finally {
    cursor.close();
  }
}","/** 
 * Searches the CalendarAlerts table for alarms that should have fired but have not and then reschedules them.  This method can be called at boot time to restore alarms that may have been lost due to a phone reboot.
 * @param cr the ContentResolver
 * @param context the Context
 * @param manager the AlarmManager
 */
public static final void rescheduleMissedAlarms(ContentResolver cr,Context context,AlarmManager manager){
  long now=System.currentTimeMillis();
  long ancient=now - DateUtils.DAY_IN_MILLIS;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=CalendarAlerts.query(cr,projection,WHERE_RESCHEDULE_MISSED_ALARMS,new String[]{Long.toString(now),Long.toString(ancient),Long.toString(now)},SORT_ORDER_ALARMTIME_ASC);
  if (cursor == null) {
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + cursor.getCount());
  }
  try {
    long alarmTime=-1;
    while (cursor.moveToNext()) {
      long newAlarmTime=cursor.getLong(0);
      if (alarmTime != newAlarmTime) {
        if (DEBUG) {
          Log.w(TAG,""String_Node_Str"" + newAlarmTime);
        }
        scheduleAlarm(context,manager,newAlarmTime);
        alarmTime=newAlarmTime;
      }
    }
  }
  finally {
    cursor.close();
  }
}"
22903,"/** 
 * Searches for an entry in the CalendarAlerts table that matches the given event id, begin time and alarm time.  If one is found then this alarm already exists and this method returns true.
 * @param cr the ContentResolver
 * @param eventId the event id to match
 * @param begin the start time of the event in UTC millis
 * @param alarmTime the alarm time of the event in UTC millis
 * @return true if there is already an alarm for the given eventwith the same start time and alarm time.
 */
public static final boolean alarmExists(ContentResolver cr,long eventId,long begin,long alarmTime){
  String selection=CalendarAlerts.EVENT_ID + ""String_Node_Str"" + eventId+ ""String_Node_Str""+ CalendarAlerts.BEGIN+ ""String_Node_Str""+ begin+ ""String_Node_Str""+ CalendarAlerts.ALARM_TIME+ ""String_Node_Str""+ alarmTime;
  String[] projection=new String[]{CalendarAlerts.ALARM_TIME};
  Cursor cursor=query(cr,projection,selection,null,null);
  boolean found=false;
  try {
    if (cursor != null && cursor.getCount() > 0) {
      found=true;
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return found;
}","/** 
 * Searches for an entry in the CalendarAlerts table that matches the given event id, begin time and alarm time.  If one is found then this alarm already exists and this method returns true.
 * @param cr the ContentResolver
 * @param eventId the event id to match
 * @param begin the start time of the event in UTC millis
 * @param alarmTime the alarm time of the event in UTC millis
 * @return true if there is already an alarm for the given eventwith the same start time and alarm time.
 */
public static final boolean alarmExists(ContentResolver cr,long eventId,long begin,long alarmTime){
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=query(cr,projection,WHERE_ALARM_EXISTS,new String[]{Long.toString(eventId),Long.toString(begin),Long.toString(alarmTime)},null);
  boolean found=false;
  try {
    if (cursor != null && cursor.getCount() > 0) {
      found=true;
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return found;
}"
22904,"@Override public Entity getEntityAndIncrementCursor(Cursor cursor) throws RemoteException {
  final long eventId=cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
  ContentValues cv=new ContentValues();
  cv.put(Events._ID,eventId);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,CALENDAR_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HTML_URI);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,TITLE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DESCRIPTION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_LOCATION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,STATUS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,SELF_ATTENDEE_STATUS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,COMMENTS_URI);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTSTART);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTEND);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DURATION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_TIMEZONE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ALL_DAY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,VISIBILITY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,TRANSPARENCY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_ALARM);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_EXTENDED_PROPERTIES);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORIGINAL_EVENT);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,ORIGINAL_INSTANCE_TIME);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,ORIGINAL_ALL_DAY);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,LAST_DATE);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,HAS_ATTENDEE_DATA);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_INVITE_OTHERS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_MODIFY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_SEE_GUESTS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORGANIZER);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_DATA);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,_SYNC_DIRTY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_VERSION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,DELETED);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,Calendars.URL);
  Entity entity=new Entity(cv);
  Cursor subCursor;
  if (mResolver != null) {
    subCursor=mResolver.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
 else {
    subCursor=mProvider.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues reminderValues=new ContentValues();
      reminderValues.put(Reminders.MINUTES,subCursor.getInt(COLUMN_MINUTES));
      reminderValues.put(Reminders.METHOD,subCursor.getInt(COLUMN_METHOD));
      entity.addSubValue(Reminders.CONTENT_URI,reminderValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
 else {
    subCursor=mProvider.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues attendeeValues=new ContentValues();
      attendeeValues.put(Attendees.ATTENDEE_NAME,subCursor.getString(COLUMN_ATTENDEE_NAME));
      attendeeValues.put(Attendees.ATTENDEE_EMAIL,subCursor.getString(COLUMN_ATTENDEE_EMAIL));
      attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP,subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
      attendeeValues.put(Attendees.ATTENDEE_TYPE,subCursor.getInt(COLUMN_ATTENDEE_TYPE));
      attendeeValues.put(Attendees.ATTENDEE_STATUS,subCursor.getInt(COLUMN_ATTENDEE_STATUS));
      entity.addSubValue(Attendees.CONTENT_URI,attendeeValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
 else {
    subCursor=mProvider.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues extendedValues=new ContentValues();
      extendedValues.put(ExtendedProperties.NAME,subCursor.getString(COLUMN_NAME));
      extendedValues.put(ExtendedProperties.VALUE,subCursor.getString(COLUMN_VALUE));
      entity.addSubValue(ExtendedProperties.CONTENT_URI,extendedValues);
    }
  }
  finally {
    subCursor.close();
  }
  cursor.moveToNext();
  return entity;
}","@Override public Entity getEntityAndIncrementCursor(Cursor cursor) throws RemoteException {
  final long eventId=cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
  ContentValues cv=new ContentValues();
  cv.put(Events._ID,eventId);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,CALENDAR_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HTML_URI);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,TITLE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DESCRIPTION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_LOCATION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,STATUS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,SELF_ATTENDEE_STATUS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,COMMENTS_URI);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTSTART);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTEND);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DURATION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_TIMEZONE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ALL_DAY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,VISIBILITY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,TRANSPARENCY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_ALARM);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_EXTENDED_PROPERTIES);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORIGINAL_EVENT);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,ORIGINAL_INSTANCE_TIME);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,ORIGINAL_ALL_DAY);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,LAST_DATE);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,HAS_ATTENDEE_DATA);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_INVITE_OTHERS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_MODIFY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_SEE_GUESTS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORGANIZER);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_DATA);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,_SYNC_DIRTY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_VERSION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,DELETED);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,Calendars.URL);
  Entity entity=new Entity(cv);
  Cursor subCursor;
  if (mResolver != null) {
    subCursor=mResolver.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
 else {
    subCursor=mProvider.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues reminderValues=new ContentValues();
      reminderValues.put(Reminders.MINUTES,subCursor.getInt(COLUMN_MINUTES));
      reminderValues.put(Reminders.METHOD,subCursor.getInt(COLUMN_METHOD));
      entity.addSubValue(Reminders.CONTENT_URI,reminderValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
 else {
    subCursor=mProvider.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues attendeeValues=new ContentValues();
      attendeeValues.put(Attendees.ATTENDEE_NAME,subCursor.getString(COLUMN_ATTENDEE_NAME));
      attendeeValues.put(Attendees.ATTENDEE_EMAIL,subCursor.getString(COLUMN_ATTENDEE_EMAIL));
      attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP,subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
      attendeeValues.put(Attendees.ATTENDEE_TYPE,subCursor.getInt(COLUMN_ATTENDEE_TYPE));
      attendeeValues.put(Attendees.ATTENDEE_STATUS,subCursor.getInt(COLUMN_ATTENDEE_STATUS));
      entity.addSubValue(Attendees.CONTENT_URI,attendeeValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
 else {
    subCursor=mProvider.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues extendedValues=new ContentValues();
      extendedValues.put(ExtendedProperties.NAME,subCursor.getString(COLUMN_NAME));
      extendedValues.put(ExtendedProperties.VALUE,subCursor.getString(COLUMN_VALUE));
      entity.addSubValue(ExtendedProperties.CONTENT_URI,extendedValues);
    }
  }
  finally {
    subCursor.close();
  }
  cursor.moveToNext();
  return entity;
}"
22905,"/** 
 * Finds the next alarm after (or equal to) the given time and returns the time of that alarm or -1 if no such alarm exists.
 * @param cr the ContentResolver
 * @param millis the time in UTC milliseconds
 * @return the next alarm time greater than or equal to ""millis"", or -1if no such alarm exists.
 */
public static final long findNextAlarmTime(ContentResolver cr,long millis){
  String selection=ALARM_TIME + ""String_Node_Str"" + millis;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=query(cr,projection,selection,null,ALARM_TIME + ""String_Node_Str"");
  long alarmTime=-1;
  try {
    if (cursor != null && cursor.moveToFirst()) {
      alarmTime=cursor.getLong(0);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return alarmTime;
}","/** 
 * Finds the next alarm after (or equal to) the given time and returns the time of that alarm or -1 if no such alarm exists.
 * @param cr the ContentResolver
 * @param millis the time in UTC milliseconds
 * @return the next alarm time greater than or equal to ""millis"", or -1if no such alarm exists.
 */
public static final long findNextAlarmTime(ContentResolver cr,long millis){
  String selection=ALARM_TIME + ""String_Node_Str"" + millis;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=query(cr,projection,WHERE_FINDNEXTALARMTIME,new String[]{Long.toString(millis)},SORT_ORDER_ALARMTIME_ASC);
  long alarmTime=-1;
  try {
    if (cursor != null && cursor.moveToFirst()) {
      alarmTime=cursor.getLong(0);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return alarmTime;
}"
22906,"public static void scheduleAlarm(Context context,AlarmManager manager,long alarmTime){
  if (DEBUG) {
    Time time=new Time();
    time.set(alarmTime);
    String schedTime=time.format(""String_Node_Str"");
    Log.d(TAG,""String_Node_Str"" + alarmTime + ""String_Node_Str""+ schedTime);
  }
  if (manager == null) {
    manager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  }
  Intent intent=new Intent(android.provider.Calendar.EVENT_REMINDER_ACTION);
  intent.putExtra(android.provider.Calendar.CalendarAlerts.ALARM_TIME,alarmTime);
  PendingIntent pi=PendingIntent.getBroadcast(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  manager.set(AlarmManager.RTC_WAKEUP,alarmTime,pi);
}","public static void scheduleAlarm(Context context,AlarmManager manager,long alarmTime){
  if (DEBUG) {
    Time time=new Time();
    time.set(alarmTime);
    String schedTime=time.format(""String_Node_Str"");
    Log.d(TAG,""String_Node_Str"" + alarmTime + ""String_Node_Str""+ schedTime);
  }
  if (manager == null) {
    manager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  }
  Intent intent=new Intent(EVENT_REMINDER_ACTION);
  intent.putExtra(ALARM_TIME,alarmTime);
  PendingIntent pi=PendingIntent.getBroadcast(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  manager.set(AlarmManager.RTC_WAKEUP,alarmTime,pi);
}"
22907,"/** 
 * Convenience method to delete all calendars that match the account.
 * @param cr the ContentResolver
 * @param account the account whose rows should be deleted
 * @return the count of rows that were deleted
 */
public static int deleteCalendarsForAccount(ContentResolver cr,Account account){
  return Calendar.Calendars.delete(cr,Calendar.Calendars._SYNC_ACCOUNT + ""String_Node_Str"" + Calendar.Calendars._SYNC_ACCOUNT_TYPE+ ""String_Node_Str"",new String[]{account.name,account.type});
}","/** 
 * Convenience method to delete all calendars that match the account.
 * @param cr the ContentResolver
 * @param account the account whose rows should be deleted
 * @return the count of rows that were deleted
 */
public static int deleteCalendarsForAccount(ContentResolver cr,Account account){
  return Calendar.Calendars.delete(cr,WHERE_DELETE_FOR_ACCOUNT,new String[]{account.name,account.type});
}"
22908,"/** 
 * Searches the CalendarAlerts table for alarms that should have fired but have not and then reschedules them.  This method can be called at boot time to restore alarms that may have been lost due to a phone reboot.
 * @param cr the ContentResolver
 * @param context the Context
 * @param manager the AlarmManager
 */
public static final void rescheduleMissedAlarms(ContentResolver cr,Context context,AlarmManager manager){
  long now=System.currentTimeMillis();
  long ancient=now - DateUtils.DAY_IN_MILLIS;
  String selection=CalendarAlerts.STATE + ""String_Node_Str"" + CalendarAlerts.SCHEDULED+ ""String_Node_Str""+ CalendarAlerts.ALARM_TIME+ ""String_Node_Str""+ now+ ""String_Node_Str""+ CalendarAlerts.ALARM_TIME+ ""String_Node_Str""+ ancient+ ""String_Node_Str""+ CalendarAlerts.END+ ""String_Node_Str""+ now;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=CalendarAlerts.query(cr,projection,selection,null,""String_Node_Str"");
  if (cursor == null) {
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + cursor.getCount());
  }
  try {
    long alarmTime=-1;
    while (cursor.moveToNext()) {
      long newAlarmTime=cursor.getLong(0);
      if (alarmTime != newAlarmTime) {
        if (DEBUG) {
          Log.w(TAG,""String_Node_Str"" + newAlarmTime);
        }
        scheduleAlarm(context,manager,newAlarmTime);
        alarmTime=newAlarmTime;
      }
    }
  }
  finally {
    cursor.close();
  }
}","/** 
 * Searches the CalendarAlerts table for alarms that should have fired but have not and then reschedules them.  This method can be called at boot time to restore alarms that may have been lost due to a phone reboot.
 * @param cr the ContentResolver
 * @param context the Context
 * @param manager the AlarmManager
 */
public static final void rescheduleMissedAlarms(ContentResolver cr,Context context,AlarmManager manager){
  long now=System.currentTimeMillis();
  long ancient=now - DateUtils.DAY_IN_MILLIS;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=CalendarAlerts.query(cr,projection,WHERE_RESCHEDULE_MISSED_ALARMS,new String[]{Long.toString(now),Long.toString(ancient),Long.toString(now)},SORT_ORDER_ALARMTIME_ASC);
  if (cursor == null) {
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + cursor.getCount());
  }
  try {
    long alarmTime=-1;
    while (cursor.moveToNext()) {
      long newAlarmTime=cursor.getLong(0);
      if (alarmTime != newAlarmTime) {
        if (DEBUG) {
          Log.w(TAG,""String_Node_Str"" + newAlarmTime);
        }
        scheduleAlarm(context,manager,newAlarmTime);
        alarmTime=newAlarmTime;
      }
    }
  }
  finally {
    cursor.close();
  }
}"
22909,"@Override public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event){
  final boolean isPassword=isPasswordInputType(mInputType);
  if (!isPassword) {
    CharSequence text=getText();
    if (TextUtils.isEmpty(text)) {
      text=getHint();
    }
    if (!TextUtils.isEmpty(text)) {
      if (text.length() > AccessibilityEvent.MAX_TEXT_LENGTH) {
        text=text.subSequence(0,AccessibilityEvent.MAX_TEXT_LENGTH + 1);
      }
      event.getText().add(text);
    }
  }
 else {
    event.setPassword(isPassword);
  }
  return false;
}","@Override public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event){
  if (!isShown()) {
    return false;
  }
  final boolean isPassword=isPasswordInputType(mInputType);
  if (!isPassword) {
    CharSequence text=getText();
    if (TextUtils.isEmpty(text)) {
      text=getHint();
    }
    if (!TextUtils.isEmpty(text)) {
      if (text.length() > AccessibilityEvent.MAX_TEXT_LENGTH) {
        text=text.subSequence(0,AccessibilityEvent.MAX_TEXT_LENGTH + 1);
      }
      event.getText().add(text);
    }
  }
 else {
    event.setPassword(isPassword);
  }
  return false;
}"
22910,"@Override public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event){
  final boolean isPassword=isPasswordInputType(mInputType);
  if (!isPassword) {
    CharSequence text=getText();
    if (TextUtils.isEmpty(text)) {
      text=getHint();
    }
    if (!TextUtils.isEmpty(text)) {
      if (text.length() > AccessibilityEvent.MAX_TEXT_LENGTH) {
        text=text.subSequence(0,AccessibilityEvent.MAX_TEXT_LENGTH + 1);
      }
      event.getText().add(text);
    }
  }
 else {
    event.setPassword(isPassword);
  }
  return false;
}","@Override public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event){
  if (!isShown()) {
    return false;
  }
  final boolean isPassword=isPasswordInputType(mInputType);
  if (!isPassword) {
    CharSequence text=getText();
    if (TextUtils.isEmpty(text)) {
      text=getHint();
    }
    if (!TextUtils.isEmpty(text)) {
      if (text.length() > AccessibilityEvent.MAX_TEXT_LENGTH) {
        text=text.subSequence(0,AccessibilityEvent.MAX_TEXT_LENGTH + 1);
      }
      event.getText().add(text);
    }
  }
 else {
    event.setPassword(isPassword);
  }
  return false;
}"
22911,"/** 
 * Synthesizes the given text to a file using the specified parameters.
 * @param text The String of text that should be synthesized
 * @param params The list of parameters to be used. Can be null if no parameters are given. They are specified using a (key, value) pair, where the key can be {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * @param filename The string that gives the full output filename; it should be something like ""/sdcard/myappsounds/mysound.wav"".
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
public int synthesizeToFile(String text,HashMap<String,String> params,String filename){
synchronized (mStartLock) {
    int result=ERROR;
    if (!mStarted) {
      return result;
    }
    try {
      if ((params != null) && (!params.isEmpty())) {
        String extra=params.get(Engine.KEY_PARAM_UTTERANCE_ID);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=extra;
        }
        extra=params.get(Engine.KEY_PARAM_ENGINE);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=extra;
        }
      }
      if (mITts.synthesizeToFile(mPackageName,text,mCachedParams,filename)) {
        result=SUCCESS;
      }
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
 finally {
      resetCachedParams();
      return result;
    }
  }
}","/** 
 * Synthesizes the given text to a file using the specified parameters.
 * @param text The String of text that should be synthesized
 * @param params The list of parameters to be used. Can be null if no parameters are given. They are specified using a (key, value) pair, where the key can be {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * @param filename The string that gives the full output filename; it should be something like ""/sdcard/myappsounds/mysound.wav"".
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
public int synthesizeToFile(String text,HashMap<String,String> params,String filename){
synchronized (mStartLock) {
    int result=ERROR;
    if (!mStarted) {
      return result;
    }
    try {
      if ((params != null) && (!params.isEmpty())) {
        String extra=params.get(Engine.KEY_PARAM_UTTERANCE_ID);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=extra;
        }
        extra=params.get(Engine.KEY_PARAM_ENGINE);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=extra;
        }
      }
      result=mITts.synthesizeToFile(mPackageName,text,mCachedParams,filename) ? SUCCESS : ERROR;
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
 finally {
      resetCachedParams();
      return result;
    }
  }
}"
22912,"void start(int position,int boundPosition){
  if (boundPosition == INVALID_POSITION) {
    start(position);
    return;
  }
  final int firstPos=mFirstPosition;
  final int lastPos=firstPos + getChildCount() - 1;
  int viewTravelCount=0;
  if (position < firstPos) {
    final int boundPosFromLast=lastPos - boundPosition;
    if (boundPosFromLast < 1) {
      return;
    }
    final int posTravel=firstPos - position + 1;
    final int boundTravel=boundPosFromLast - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_UP_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_UP_POS;
    }
  }
 else   if (position > lastPos) {
    final int boundPosFromFirst=boundPosition - firstPos;
    if (boundPosFromFirst < 1) {
      return;
    }
    final int posTravel=position - lastPos + 1;
    final int boundTravel=boundPosFromFirst - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_DOWN_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_DOWN_POS;
    }
  }
 else {
    return;
  }
  if (viewTravelCount > 0) {
    mScrollDuration=SCROLL_DURATION / viewTravelCount;
  }
 else {
    mScrollDuration=SCROLL_DURATION;
  }
  mTargetPos=position;
  mBoundPos=boundPosition;
  mLastSeenPos=INVALID_POSITION;
  post(this);
}","void start(int position,int boundPosition){
  if (boundPosition == INVALID_POSITION) {
    start(position);
    return;
  }
  final int firstPos=mFirstPosition;
  final int lastPos=firstPos + getChildCount() - 1;
  int viewTravelCount=0;
  if (position <= firstPos) {
    final int boundPosFromLast=lastPos - boundPosition;
    if (boundPosFromLast < 1) {
      return;
    }
    final int posTravel=firstPos - position + 1;
    final int boundTravel=boundPosFromLast - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_UP_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_UP_POS;
    }
  }
 else   if (position >= lastPos) {
    final int boundPosFromFirst=boundPosition - firstPos;
    if (boundPosFromFirst < 1) {
      return;
    }
    final int posTravel=position - lastPos + 1;
    final int boundTravel=boundPosFromFirst - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_DOWN_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_DOWN_POS;
    }
  }
 else {
    return;
  }
  if (viewTravelCount > 0) {
    mScrollDuration=SCROLL_DURATION / viewTravelCount;
  }
 else {
    mScrollDuration=SCROLL_DURATION;
  }
  mTargetPos=position;
  mBoundPos=boundPosition;
  mLastSeenPos=INVALID_POSITION;
  post(this);
}"
22913,"void start(int position,int boundPosition){
  if (boundPosition == INVALID_POSITION) {
    start(position);
    return;
  }
  final int firstPos=mFirstPosition;
  final int lastPos=firstPos + getChildCount() - 1;
  int viewTravelCount=0;
  if (position < firstPos) {
    final int boundPosFromLast=lastPos - boundPosition;
    if (boundPosFromLast < 1) {
      return;
    }
    final int posTravel=firstPos - position + 1;
    final int boundTravel=boundPosFromLast - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_UP_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_UP_POS;
    }
  }
 else   if (position > lastPos) {
    final int boundPosFromFirst=boundPosition - firstPos;
    if (boundPosFromFirst < 1) {
      return;
    }
    final int posTravel=position - lastPos + 1;
    final int boundTravel=boundPosFromFirst - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_DOWN_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_DOWN_POS;
    }
  }
 else {
    return;
  }
  if (viewTravelCount > 0) {
    mScrollDuration=SCROLL_DURATION / viewTravelCount;
  }
 else {
    mScrollDuration=SCROLL_DURATION;
  }
  mTargetPos=position;
  mBoundPos=boundPosition;
  mLastSeenPos=INVALID_POSITION;
  post(this);
}","void start(int position,int boundPosition){
  if (boundPosition == INVALID_POSITION) {
    start(position);
    return;
  }
  final int firstPos=mFirstPosition;
  final int lastPos=firstPos + getChildCount() - 1;
  int viewTravelCount=0;
  if (position <= firstPos) {
    final int boundPosFromLast=lastPos - boundPosition;
    if (boundPosFromLast < 1) {
      return;
    }
    final int posTravel=firstPos - position + 1;
    final int boundTravel=boundPosFromLast - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_UP_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_UP_POS;
    }
  }
 else   if (position >= lastPos) {
    final int boundPosFromFirst=boundPosition - firstPos;
    if (boundPosFromFirst < 1) {
      return;
    }
    final int posTravel=position - lastPos + 1;
    final int boundTravel=boundPosFromFirst - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_DOWN_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_DOWN_POS;
    }
  }
 else {
    return;
  }
  if (viewTravelCount > 0) {
    mScrollDuration=SCROLL_DURATION / viewTravelCount;
  }
 else {
    mScrollDuration=SCROLL_DURATION;
  }
  mTargetPos=position;
  mBoundPos=boundPosition;
  mLastSeenPos=INVALID_POSITION;
  post(this);
}"
22914,"@Override protected boolean setFrame(int l,int t,int r,int b){
  boolean result=super.setFrame(l,t,r,b);
  if (mPopup.isShowing()) {
    mPopup.update(this,r - l,-1);
  }
  return result;
}","@Override protected boolean setFrame(final int l,int t,final int r,int b){
  boolean result=super.setFrame(l,t,r,b);
  if (mPopup.isShowing()) {
    showDropDown();
  }
  return result;
}"
22915,"/** 
 * <p>Display the content view in a popup window anchored to the bottom-left corner of the anchor view offset by the specified x and y coordinates. If there is not enough room on screen to show the popup in its entirety, this method tries to find a parent scroll view to scroll. If no parent scroll view can be scrolled, the bottom-left corner of the popup is pinned at the top left corner of the anchor view.</p> <p>If the view later scrolls to move <code>anchor</code> to a different location, the popup will be moved correspondingly.</p>
 * @param anchor the view on which to pin the popup window
 * @see #dismiss()
 */
public void showAsDropDown(View anchor,int xoff,int yoff){
  if (isShowing() || mContentView == null) {
    return;
  }
  registerForScrollChanged(anchor,xoff,yoff);
  mIsShowing=true;
  mIsDropdown=true;
  WindowManager.LayoutParams p=createPopupLayout(anchor.getWindowToken());
  preparePopup(p);
  mAboveAnchor=findDropDownPosition(anchor,p,xoff,yoff);
  if (mBackground != null) {
    if (mAboveAnchorBackgroundDrawable != null) {
      if (mAboveAnchor) {
        mPopupView.setBackgroundDrawable(mAboveAnchorBackgroundDrawable);
      }
 else {
        mPopupView.setBackgroundDrawable(mBelowAnchorBackgroundDrawable);
      }
    }
 else {
      mPopupView.refreshDrawableState();
    }
  }
  if (mHeightMode < 0)   p.height=mLastHeight=mHeightMode;
  if (mWidthMode < 0)   p.width=mLastWidth=mWidthMode;
  p.windowAnimations=computeAnimationResource();
  invokePopup(p);
}","/** 
 * <p>Display the content view in a popup window anchored to the bottom-left corner of the anchor view offset by the specified x and y coordinates. If there is not enough room on screen to show the popup in its entirety, this method tries to find a parent scroll view to scroll. If no parent scroll view can be scrolled, the bottom-left corner of the popup is pinned at the top left corner of the anchor view.</p> <p>If the view later scrolls to move <code>anchor</code> to a different location, the popup will be moved correspondingly.</p>
 * @param anchor the view on which to pin the popup window
 * @see #dismiss()
 */
public void showAsDropDown(View anchor,int xoff,int yoff){
  if (isShowing() || mContentView == null) {
    return;
  }
  registerForScrollChanged(anchor,xoff,yoff);
  mIsShowing=true;
  mIsDropdown=true;
  WindowManager.LayoutParams p=createPopupLayout(anchor.getWindowToken());
  preparePopup(p);
  updateAboveAnchor(findDropDownPosition(anchor,p,xoff,yoff));
  if (mHeightMode < 0)   p.height=mLastHeight=mHeightMode;
  if (mWidthMode < 0)   p.width=mLastWidth=mWidthMode;
  p.windowAnimations=computeAnimationResource();
  invokePopup(p);
}"
22916,"private void update(View anchor,boolean updateLocation,int xoff,int yoff,boolean updateDimension,int width,int height){
  if (!isShowing() || mContentView == null) {
    return;
  }
  WeakReference<View> oldAnchor=mAnchor;
  if (oldAnchor == null || oldAnchor.get() != anchor || (updateLocation && (mAnchorXoff != xoff || mAnchorYoff != yoff))) {
    registerForScrollChanged(anchor,xoff,yoff);
  }
  WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
  if (updateDimension) {
    if (width == -1) {
      width=mPopupWidth;
    }
 else {
      mPopupWidth=width;
    }
    if (height == -1) {
      height=mPopupHeight;
    }
 else {
      mPopupHeight=height;
    }
  }
  if (updateLocation) {
    mAboveAnchor=findDropDownPosition(anchor,p,xoff,yoff);
  }
 else {
    mAboveAnchor=findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff);
  }
  update(p.x,p.y,width,height);
}","private void update(View anchor,boolean updateLocation,int xoff,int yoff,boolean updateDimension,int width,int height){
  if (!isShowing() || mContentView == null) {
    return;
  }
  WeakReference<View> oldAnchor=mAnchor;
  if (oldAnchor == null || oldAnchor.get() != anchor || (updateLocation && (mAnchorXoff != xoff || mAnchorYoff != yoff))) {
    registerForScrollChanged(anchor,xoff,yoff);
  }
  WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
  if (updateDimension) {
    if (width == -1) {
      width=mPopupWidth;
    }
 else {
      mPopupWidth=width;
    }
    if (height == -1) {
      height=mPopupHeight;
    }
 else {
      mPopupHeight=height;
    }
  }
  int x=p.x;
  int y=p.y;
  if (updateLocation) {
    updateAboveAnchor(findDropDownPosition(anchor,p,xoff,yoff));
  }
 else {
    updateAboveAnchor(findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff));
  }
  update(p.x,p.y,width,height,x != p.x || y != p.y);
}"
22917,"public void onScrollChanged(){
  View anchor=mAnchor.get();
  if (anchor != null && mPopupView != null) {
    WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
    mAboveAnchor=findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff);
    update(p.x,p.y,-1,-1,true);
  }
}","public void onScrollChanged(){
  View anchor=mAnchor.get();
  if (anchor != null && mPopupView != null) {
    WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
    updateAboveAnchor(findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff));
    update(p.x,p.y,-1,-1,true);
  }
}"
22918,"/** 
 * <p>Positions the popup window on screen. When the popup window is too tall to fit under the anchor, a parent scroll view is seeked and scrolled up to reclaim space. If scrolling is not possible or not enough, the popup window gets moved on top of the anchor.</p> <p>The height must have been set on the layout parameters prior to calling this method.</p>
 * @param anchor the view on which the popup window must be anchored
 * @param p the layout parameters used to display the drop down
 * @return true if the popup is translated upwards to fit on screen
 */
private boolean findDropDownPosition(View anchor,WindowManager.LayoutParams p,int xoff,int yoff){
  anchor.getLocationInWindow(mDrawingLocation);
  p.x=mDrawingLocation[0] + xoff;
  p.y=mDrawingLocation[1] + anchor.getMeasuredHeight() + yoff;
  boolean onTop=false;
  p.gravity=Gravity.LEFT | Gravity.TOP;
  anchor.getLocationOnScreen(mScreenLocation);
  final Rect displayFrame=new Rect();
  anchor.getWindowVisibleDisplayFrame(displayFrame);
  final View root=anchor.getRootView();
  if (p.y + mPopupHeight > displayFrame.bottom || p.x + mPopupWidth - root.getWidth() > 0) {
    int scrollX=anchor.getScrollX();
    int scrollY=anchor.getScrollY();
    Rect r=new Rect(scrollX,scrollY,scrollX + mPopupWidth,scrollY + mPopupHeight + anchor.getMeasuredHeight());
    anchor.requestRectangleOnScreen(r,true);
    anchor.getLocationInWindow(mDrawingLocation);
    p.x=mDrawingLocation[0] + xoff;
    p.y=mDrawingLocation[1] + anchor.getMeasuredHeight() + yoff;
    anchor.getLocationOnScreen(mScreenLocation);
    onTop=(displayFrame.bottom - mScreenLocation[1] - anchor.getMeasuredHeight()- yoff) < (mScreenLocation[1] - yoff - displayFrame.top);
    if (onTop) {
      p.gravity=Gravity.LEFT | Gravity.BOTTOM;
      p.y=root.getHeight() - mDrawingLocation[1] + yoff;
    }
 else {
      p.y=mDrawingLocation[1] + anchor.getMeasuredHeight() + yoff;
    }
  }
  p.gravity|=Gravity.DISPLAY_CLIP_VERTICAL;
  return onTop;
}","/** 
 * <p>Positions the popup window on screen. When the popup window is too tall to fit under the anchor, a parent scroll view is seeked and scrolled up to reclaim space. If scrolling is not possible or not enough, the popup window gets moved on top of the anchor.</p> <p>The height must have been set on the layout parameters prior to calling this method.</p>
 * @param anchor the view on which the popup window must be anchored
 * @param p the layout parameters used to display the drop down
 * @return true if the popup is translated upwards to fit on screen
 */
private boolean findDropDownPosition(View anchor,WindowManager.LayoutParams p,int xoff,int yoff){
  anchor.getLocationInWindow(mDrawingLocation);
  p.x=mDrawingLocation[0] + xoff;
  p.y=mDrawingLocation[1] + anchor.getHeight() + yoff;
  boolean onTop=false;
  p.gravity=Gravity.LEFT | Gravity.TOP;
  anchor.getLocationOnScreen(mScreenLocation);
  final Rect displayFrame=new Rect();
  anchor.getWindowVisibleDisplayFrame(displayFrame);
  final View root=anchor.getRootView();
  if (p.y + mPopupHeight > displayFrame.bottom || p.x + mPopupWidth - root.getWidth() > 0) {
    int scrollX=anchor.getScrollX();
    int scrollY=anchor.getScrollY();
    Rect r=new Rect(scrollX,scrollY,scrollX + mPopupWidth + xoff,scrollY + mPopupHeight + anchor.getHeight()+ yoff);
    anchor.requestRectangleOnScreen(r,true);
    anchor.getLocationInWindow(mDrawingLocation);
    p.x=mDrawingLocation[0] + xoff;
    p.y=mDrawingLocation[1] + anchor.getHeight() + yoff;
    anchor.getLocationOnScreen(mScreenLocation);
    onTop=(displayFrame.bottom - mScreenLocation[1] - anchor.getHeight()- yoff) < (mScreenLocation[1] - yoff - displayFrame.top);
    if (onTop) {
      p.gravity=Gravity.LEFT | Gravity.BOTTOM;
      p.y=root.getHeight() - mDrawingLocation[1] + yoff;
    }
 else {
      p.y=mDrawingLocation[1] + anchor.getHeight() + yoff;
    }
  }
  p.gravity|=Gravity.DISPLAY_CLIP_VERTICAL;
  return onTop;
}"
22919,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  hideSelector();
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    positionSelector(getChildAt(mSelectedPosition - mFirstPosition));
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}"
22920,"@Override protected boolean setFrame(int l,int t,int r,int b){
  boolean result=super.setFrame(l,t,r,b);
  if (mPopup.isShowing()) {
    mPopup.update(this,r - l,-1);
  }
  return result;
}","@Override protected boolean setFrame(final int l,int t,final int r,int b){
  boolean result=super.setFrame(l,t,r,b);
  if (mPopup.isShowing()) {
    showDropDown();
  }
  return result;
}"
22921,"/** 
 * <p>Display the content view in a popup window anchored to the bottom-left corner of the anchor view offset by the specified x and y coordinates. If there is not enough room on screen to show the popup in its entirety, this method tries to find a parent scroll view to scroll. If no parent scroll view can be scrolled, the bottom-left corner of the popup is pinned at the top left corner of the anchor view.</p> <p>If the view later scrolls to move <code>anchor</code> to a different location, the popup will be moved correspondingly.</p>
 * @param anchor the view on which to pin the popup window
 * @see #dismiss()
 */
public void showAsDropDown(View anchor,int xoff,int yoff){
  if (isShowing() || mContentView == null) {
    return;
  }
  registerForScrollChanged(anchor,xoff,yoff);
  mIsShowing=true;
  mIsDropdown=true;
  WindowManager.LayoutParams p=createPopupLayout(anchor.getWindowToken());
  preparePopup(p);
  mAboveAnchor=findDropDownPosition(anchor,p,xoff,yoff);
  if (mBackground != null) {
    if (mAboveAnchorBackgroundDrawable != null) {
      if (mAboveAnchor) {
        mPopupView.setBackgroundDrawable(mAboveAnchorBackgroundDrawable);
      }
 else {
        mPopupView.setBackgroundDrawable(mBelowAnchorBackgroundDrawable);
      }
    }
 else {
      mPopupView.refreshDrawableState();
    }
  }
  if (mHeightMode < 0)   p.height=mLastHeight=mHeightMode;
  if (mWidthMode < 0)   p.width=mLastWidth=mWidthMode;
  p.windowAnimations=computeAnimationResource();
  invokePopup(p);
}","/** 
 * <p>Display the content view in a popup window anchored to the bottom-left corner of the anchor view offset by the specified x and y coordinates. If there is not enough room on screen to show the popup in its entirety, this method tries to find a parent scroll view to scroll. If no parent scroll view can be scrolled, the bottom-left corner of the popup is pinned at the top left corner of the anchor view.</p> <p>If the view later scrolls to move <code>anchor</code> to a different location, the popup will be moved correspondingly.</p>
 * @param anchor the view on which to pin the popup window
 * @see #dismiss()
 */
public void showAsDropDown(View anchor,int xoff,int yoff){
  if (isShowing() || mContentView == null) {
    return;
  }
  registerForScrollChanged(anchor,xoff,yoff);
  mIsShowing=true;
  mIsDropdown=true;
  WindowManager.LayoutParams p=createPopupLayout(anchor.getWindowToken());
  preparePopup(p);
  updateAboveAnchor(findDropDownPosition(anchor,p,xoff,yoff));
  if (mHeightMode < 0)   p.height=mLastHeight=mHeightMode;
  if (mWidthMode < 0)   p.width=mLastWidth=mWidthMode;
  p.windowAnimations=computeAnimationResource();
  invokePopup(p);
}"
22922,"private void update(View anchor,boolean updateLocation,int xoff,int yoff,boolean updateDimension,int width,int height){
  if (!isShowing() || mContentView == null) {
    return;
  }
  WeakReference<View> oldAnchor=mAnchor;
  if (oldAnchor == null || oldAnchor.get() != anchor || (updateLocation && (mAnchorXoff != xoff || mAnchorYoff != yoff))) {
    registerForScrollChanged(anchor,xoff,yoff);
  }
  WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
  if (updateDimension) {
    if (width == -1) {
      width=mPopupWidth;
    }
 else {
      mPopupWidth=width;
    }
    if (height == -1) {
      height=mPopupHeight;
    }
 else {
      mPopupHeight=height;
    }
  }
  if (updateLocation) {
    mAboveAnchor=findDropDownPosition(anchor,p,xoff,yoff);
  }
 else {
    mAboveAnchor=findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff);
  }
  update(p.x,p.y,width,height);
}","private void update(View anchor,boolean updateLocation,int xoff,int yoff,boolean updateDimension,int width,int height){
  if (!isShowing() || mContentView == null) {
    return;
  }
  WeakReference<View> oldAnchor=mAnchor;
  if (oldAnchor == null || oldAnchor.get() != anchor || (updateLocation && (mAnchorXoff != xoff || mAnchorYoff != yoff))) {
    registerForScrollChanged(anchor,xoff,yoff);
  }
  WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
  if (updateDimension) {
    if (width == -1) {
      width=mPopupWidth;
    }
 else {
      mPopupWidth=width;
    }
    if (height == -1) {
      height=mPopupHeight;
    }
 else {
      mPopupHeight=height;
    }
  }
  int x=p.x;
  int y=p.y;
  if (updateLocation) {
    updateAboveAnchor(findDropDownPosition(anchor,p,xoff,yoff));
  }
 else {
    updateAboveAnchor(findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff));
  }
  update(p.x,p.y,width,height,x != p.x || y != p.y);
}"
22923,"public void onScrollChanged(){
  View anchor=mAnchor.get();
  if (anchor != null && mPopupView != null) {
    WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
    mAboveAnchor=findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff);
    update(p.x,p.y,-1,-1,true);
  }
}","public void onScrollChanged(){
  View anchor=mAnchor.get();
  if (anchor != null && mPopupView != null) {
    WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
    updateAboveAnchor(findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff));
    update(p.x,p.y,-1,-1,true);
  }
}"
22924,"/** 
 * <p>Positions the popup window on screen. When the popup window is too tall to fit under the anchor, a parent scroll view is seeked and scrolled up to reclaim space. If scrolling is not possible or not enough, the popup window gets moved on top of the anchor.</p> <p>The height must have been set on the layout parameters prior to calling this method.</p>
 * @param anchor the view on which the popup window must be anchored
 * @param p the layout parameters used to display the drop down
 * @return true if the popup is translated upwards to fit on screen
 */
private boolean findDropDownPosition(View anchor,WindowManager.LayoutParams p,int xoff,int yoff){
  anchor.getLocationInWindow(mDrawingLocation);
  p.x=mDrawingLocation[0] + xoff;
  p.y=mDrawingLocation[1] + anchor.getMeasuredHeight() + yoff;
  boolean onTop=false;
  p.gravity=Gravity.LEFT | Gravity.TOP;
  anchor.getLocationOnScreen(mScreenLocation);
  final Rect displayFrame=new Rect();
  anchor.getWindowVisibleDisplayFrame(displayFrame);
  final View root=anchor.getRootView();
  if (p.y + mPopupHeight > displayFrame.bottom || p.x + mPopupWidth - root.getWidth() > 0) {
    int scrollX=anchor.getScrollX();
    int scrollY=anchor.getScrollY();
    Rect r=new Rect(scrollX,scrollY,scrollX + mPopupWidth,scrollY + mPopupHeight + anchor.getMeasuredHeight());
    anchor.requestRectangleOnScreen(r,true);
    anchor.getLocationInWindow(mDrawingLocation);
    p.x=mDrawingLocation[0] + xoff;
    p.y=mDrawingLocation[1] + anchor.getMeasuredHeight() + yoff;
    anchor.getLocationOnScreen(mScreenLocation);
    onTop=(displayFrame.bottom - mScreenLocation[1] - anchor.getMeasuredHeight()- yoff) < (mScreenLocation[1] - yoff - displayFrame.top);
    if (onTop) {
      p.gravity=Gravity.LEFT | Gravity.BOTTOM;
      p.y=root.getHeight() - mDrawingLocation[1] + yoff;
    }
 else {
      p.y=mDrawingLocation[1] + anchor.getMeasuredHeight() + yoff;
    }
  }
  p.gravity|=Gravity.DISPLAY_CLIP_VERTICAL;
  return onTop;
}","/** 
 * <p>Positions the popup window on screen. When the popup window is too tall to fit under the anchor, a parent scroll view is seeked and scrolled up to reclaim space. If scrolling is not possible or not enough, the popup window gets moved on top of the anchor.</p> <p>The height must have been set on the layout parameters prior to calling this method.</p>
 * @param anchor the view on which the popup window must be anchored
 * @param p the layout parameters used to display the drop down
 * @return true if the popup is translated upwards to fit on screen
 */
private boolean findDropDownPosition(View anchor,WindowManager.LayoutParams p,int xoff,int yoff){
  anchor.getLocationInWindow(mDrawingLocation);
  p.x=mDrawingLocation[0] + xoff;
  p.y=mDrawingLocation[1] + anchor.getHeight() + yoff;
  boolean onTop=false;
  p.gravity=Gravity.LEFT | Gravity.TOP;
  anchor.getLocationOnScreen(mScreenLocation);
  final Rect displayFrame=new Rect();
  anchor.getWindowVisibleDisplayFrame(displayFrame);
  final View root=anchor.getRootView();
  if (p.y + mPopupHeight > displayFrame.bottom || p.x + mPopupWidth - root.getWidth() > 0) {
    int scrollX=anchor.getScrollX();
    int scrollY=anchor.getScrollY();
    Rect r=new Rect(scrollX,scrollY,scrollX + mPopupWidth + xoff,scrollY + mPopupHeight + anchor.getHeight()+ yoff);
    anchor.requestRectangleOnScreen(r,true);
    anchor.getLocationInWindow(mDrawingLocation);
    p.x=mDrawingLocation[0] + xoff;
    p.y=mDrawingLocation[1] + anchor.getHeight() + yoff;
    anchor.getLocationOnScreen(mScreenLocation);
    onTop=(displayFrame.bottom - mScreenLocation[1] - anchor.getHeight()- yoff) < (mScreenLocation[1] - yoff - displayFrame.top);
    if (onTop) {
      p.gravity=Gravity.LEFT | Gravity.BOTTOM;
      p.y=root.getHeight() - mDrawingLocation[1] + yoff;
    }
 else {
      p.y=mDrawingLocation[1] + anchor.getHeight() + yoff;
    }
  }
  p.gravity|=Gravity.DISPLAY_CLIP_VERTICAL;
  return onTop;
}"
22925,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  hideSelector();
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    positionSelector(getChildAt(mSelectedPosition - mFirstPosition));
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}"
22926,"/** 
 * Synthesizes the given text to a file using the specified parameters.
 * @param text The String of text that should be synthesized
 * @param params The list of parameters to be used. Can be null if no parameters are given. They are specified using a (key, value) pair, where the key can be {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * @param filename The string that gives the full output filename; it should be something like ""/sdcard/myappsounds/mysound.wav"".
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
public int synthesizeToFile(String text,HashMap<String,String> params,String filename){
synchronized (mStartLock) {
    int result=ERROR;
    if (!mStarted) {
      return result;
    }
    try {
      if ((params != null) && (!params.isEmpty())) {
        String extra=params.get(Engine.KEY_PARAM_UTTERANCE_ID);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=extra;
        }
        extra=params.get(Engine.KEY_PARAM_ENGINE);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=extra;
        }
      }
      if (mITts.synthesizeToFile(mPackageName,text,mCachedParams,filename)) {
        result=SUCCESS;
      }
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
 finally {
      resetCachedParams();
      return result;
    }
  }
}","/** 
 * Synthesizes the given text to a file using the specified parameters.
 * @param text The String of text that should be synthesized
 * @param params The list of parameters to be used. Can be null if no parameters are given. They are specified using a (key, value) pair, where the key can be {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * @param filename The string that gives the full output filename; it should be something like ""/sdcard/myappsounds/mysound.wav"".
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
public int synthesizeToFile(String text,HashMap<String,String> params,String filename){
synchronized (mStartLock) {
    int result=ERROR;
    if (!mStarted) {
      return result;
    }
    try {
      if ((params != null) && (!params.isEmpty())) {
        String extra=params.get(Engine.KEY_PARAM_UTTERANCE_ID);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=extra;
        }
        extra=params.get(Engine.KEY_PARAM_ENGINE);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=extra;
        }
      }
      result=mITts.synthesizeToFile(mPackageName,text,mCachedParams,filename) ? SUCCESS : ERROR;
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
 finally {
      resetCachedParams();
      return result;
    }
  }
}"
22927,"public AuthenticatorDescription parseServiceAttributes(String packageName,AttributeSet attrs){
  TypedArray sa=mContext.getResources().obtainAttributes(attrs,com.android.internal.R.styleable.AccountAuthenticator);
  try {
    final String accountType=sa.getString(com.android.internal.R.styleable.AccountAuthenticator_accountType);
    final int labelId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_label,0);
    final int iconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_icon,0);
    final int smallIconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_smallIcon,0);
    final int prefId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_accountPreferences,0);
    if (TextUtils.isEmpty(accountType)) {
      return null;
    }
    return new AuthenticatorDescription(accountType,packageName,labelId,iconId,smallIconId,prefId);
  }
  finally {
    sa.recycle();
  }
}","public AuthenticatorDescription parseServiceAttributes(Resources res,String packageName,AttributeSet attrs){
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AccountAuthenticator);
  try {
    final String accountType=sa.getString(com.android.internal.R.styleable.AccountAuthenticator_accountType);
    final int labelId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_label,0);
    final int iconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_icon,0);
    final int smallIconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_smallIcon,0);
    final int prefId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_accountPreferences,0);
    if (TextUtils.isEmpty(accountType)) {
      return null;
    }
    return new AuthenticatorDescription(accountType,packageName,labelId,iconId,smallIconId,prefId);
  }
  finally {
    sa.recycle();
  }
}"
22928,"public SyncAdapterType parseServiceAttributes(String packageName,AttributeSet attrs){
  TypedArray sa=mContext.getResources().obtainAttributes(attrs,com.android.internal.R.styleable.SyncAdapter);
  try {
    final String authority=sa.getString(com.android.internal.R.styleable.SyncAdapter_contentAuthority);
    final String accountType=sa.getString(com.android.internal.R.styleable.SyncAdapter_accountType);
    if (authority == null || accountType == null) {
      return null;
    }
    final boolean userVisible=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_userVisible,true);
    final boolean supportsUploading=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_supportsUploading,true);
    return new SyncAdapterType(authority,accountType,userVisible,supportsUploading);
  }
  finally {
    sa.recycle();
  }
}","public SyncAdapterType parseServiceAttributes(Resources res,String packageName,AttributeSet attrs){
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.SyncAdapter);
  try {
    final String authority=sa.getString(com.android.internal.R.styleable.SyncAdapter_contentAuthority);
    final String accountType=sa.getString(com.android.internal.R.styleable.SyncAdapter_accountType);
    if (authority == null || accountType == null) {
      return null;
    }
    final boolean userVisible=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_userVisible,true);
    final boolean supportsUploading=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_supportsUploading,true);
    return new SyncAdapterType(authority,accountType,userVisible,supportsUploading);
  }
  finally {
    sa.recycle();
  }
}"
22929,"public abstract V parseServiceAttributes(String packageName,AttributeSet attrs);","public abstract V parseServiceAttributes(Resources res,String packageName,AttributeSet attrs);"
22930,"private ServiceInfo<V> parseServiceInfo(ResolveInfo service) throws XmlPullParserException, IOException {
  android.content.pm.ServiceInfo si=service.serviceInfo;
  ComponentName componentName=new ComponentName(si.packageName,si.name);
  PackageManager pm=mContext.getPackageManager();
  XmlResourceParser parser=null;
  try {
    parser=si.loadXmlMetaData(pm,mMetaDataName);
    if (parser == null) {
      throw new XmlPullParserException(""String_Node_Str"" + mMetaDataName + ""String_Node_Str"");
    }
    AttributeSet attrs=Xml.asAttributeSet(parser);
    int type;
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
    }
    String nodeName=parser.getName();
    if (!mAttributesName.equals(nodeName)) {
      throw new XmlPullParserException(""String_Node_Str"" + mAttributesName + ""String_Node_Str"");
    }
    V v=parseServiceAttributes(si.packageName,attrs);
    if (v == null) {
      return null;
    }
    final android.content.pm.ServiceInfo serviceInfo=service.serviceInfo;
    final ApplicationInfo applicationInfo=serviceInfo.applicationInfo;
    final int uid=applicationInfo.uid;
    return new ServiceInfo<V>(v,componentName,uid);
  }
  finally {
    if (parser != null)     parser.close();
  }
}","private ServiceInfo<V> parseServiceInfo(ResolveInfo service) throws XmlPullParserException, IOException {
  android.content.pm.ServiceInfo si=service.serviceInfo;
  ComponentName componentName=new ComponentName(si.packageName,si.name);
  PackageManager pm=mContext.getPackageManager();
  XmlResourceParser parser=null;
  try {
    parser=si.loadXmlMetaData(pm,mMetaDataName);
    if (parser == null) {
      throw new XmlPullParserException(""String_Node_Str"" + mMetaDataName + ""String_Node_Str"");
    }
    AttributeSet attrs=Xml.asAttributeSet(parser);
    int type;
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
    }
    String nodeName=parser.getName();
    if (!mAttributesName.equals(nodeName)) {
      throw new XmlPullParserException(""String_Node_Str"" + mAttributesName + ""String_Node_Str"");
    }
    V v=parseServiceAttributes(pm.getResourcesForApplication(si.applicationInfo),si.packageName,attrs);
    if (v == null) {
      return null;
    }
    final android.content.pm.ServiceInfo serviceInfo=service.serviceInfo;
    final ApplicationInfo applicationInfo=serviceInfo.applicationInfo;
    final int uid=applicationInfo.uid;
    return new ServiceInfo<V>(v,componentName,uid);
  }
 catch (  NameNotFoundException e) {
    throw new XmlPullParserException(""String_Node_Str"" + si.packageName);
  }
 finally {
    if (parser != null)     parser.close();
  }
}"
22931,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      pokeWakelock(EMERGENCY_CALL_TIMEOUT);
      if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
      }
 else {
        Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivity(intent);
      }
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
    public void reportFailedUnlockAttempt(){
      mLockPatternUtils.reportFailedPasswordAttempt();
    }
    public void reportSuccessfulUnlockAttempt(){
      mLockPatternUtils.reportSuccessfulPasswordAttempt();
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      pokeWakelock(EMERGENCY_CALL_TIMEOUT);
      if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
      }
 else {
        Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivity(intent);
      }
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedUnlockAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
      mLockPatternUtils.reportFailedPasswordAttempt();
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
    public void reportSuccessfulUnlockAttempt(){
      mLockPatternUtils.reportSuccessfulPasswordAttempt();
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}"
22932,"public void reportFailedUnlockAttempt(){
  mLockPatternUtils.reportFailedPasswordAttempt();
}","public void reportFailedUnlockAttempt(){
  mUpdateMonitor.reportFailedAttempt();
  final int failedAttempts=mUpdateMonitor.getFailedAttempts();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
  if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    showAlmostAtAccountLoginDialog();
  }
 else   if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
    mLockPatternUtils.setPermanentlyLocked(true);
    updateScreen(mMode);
  }
 else   if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
    showTimeoutDialog();
  }
  mLockPatternUtils.reportFailedPasswordAttempt();
}"
22933,"/** 
 * Given the current state of things, what should the unlock screen be?
 */
private UnlockMode getUnlockMode(){
  final IccCard.State simState=mUpdateMonitor.getSimState();
  UnlockMode currentMode;
  if (simState == IccCard.State.PIN_REQUIRED || simState == IccCard.State.PUK_REQUIRED) {
    currentMode=UnlockMode.SimPin;
  }
 else {
    final int mode=mLockPatternUtils.getPasswordMode();
switch (mode) {
case LockPatternUtils.MODE_PIN:
case LockPatternUtils.MODE_PASSWORD:
      currentMode=UnlockMode.Password;
    break;
case LockPatternUtils.MODE_PATTERN:
  if (mForgotPattern && mLockPatternUtils.isPermanentlyLocked()) {
    currentMode=UnlockMode.Account;
  }
 else {
    currentMode=UnlockMode.Pattern;
  }
break;
default :
throw new IllegalStateException(""String_Node_Str"" + mode);
}
}
return currentMode;
}","/** 
 * Given the current state of things, what should the unlock screen be?
 */
private UnlockMode getUnlockMode(){
  final IccCard.State simState=mUpdateMonitor.getSimState();
  UnlockMode currentMode;
  if (simState == IccCard.State.PIN_REQUIRED || simState == IccCard.State.PUK_REQUIRED) {
    currentMode=UnlockMode.SimPin;
  }
 else {
    final int mode=mLockPatternUtils.getPasswordMode();
switch (mode) {
case LockPatternUtils.MODE_PIN:
case LockPatternUtils.MODE_PASSWORD:
      currentMode=UnlockMode.Password;
    break;
case LockPatternUtils.MODE_PATTERN:
  if (mForgotPattern || mLockPatternUtils.isPermanentlyLocked()) {
    currentMode=UnlockMode.Account;
  }
 else {
    currentMode=UnlockMode.Pattern;
  }
break;
default :
throw new IllegalStateException(""String_Node_Str"" + mode);
}
}
return currentMode;
}"
22934,"public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mInstructions=""String_Node_Str"";
    updateStatusLines();
    mCallback.keyguardDone(true);
    mCallback.reportSuccessfulUnlockAttempt();
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.pokeWakelock(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    if (pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL) {
      mTotalFailedPatternAttempts++;
      mFailedPatternAttemptsSinceLastTimeout++;
    }
    if (mFailedPatternAttemptsSinceLastTimeout >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mInstructions=getContext().getString(R.string.lockscreen_pattern_wrong);
      updateStatusLines();
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
    if (pattern.size() > MIN_PATTERN_BEFORE_REPORT) {
      mCallback.reportFailedUnlockAttempt();
    }
  }
}","public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mInstructions=""String_Node_Str"";
    updateStatusLines();
    mCallback.keyguardDone(true);
    mCallback.reportSuccessfulUnlockAttempt();
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.pokeWakelock(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    if (pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL) {
      mTotalFailedPatternAttempts++;
      mFailedPatternAttemptsSinceLastTimeout++;
      mCallback.reportFailedUnlockAttempt();
    }
    if (mFailedPatternAttemptsSinceLastTimeout >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mInstructions=getContext().getString(R.string.lockscreen_pattern_wrong);
      updateStatusLines();
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}"
22935,"public AuthenticatorDescription parseServiceAttributes(String packageName,AttributeSet attrs){
  TypedArray sa=mContext.getResources().obtainAttributes(attrs,com.android.internal.R.styleable.AccountAuthenticator);
  try {
    final String accountType=sa.getString(com.android.internal.R.styleable.AccountAuthenticator_accountType);
    final int labelId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_label,0);
    final int iconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_icon,0);
    final int smallIconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_smallIcon,0);
    final int prefId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_accountPreferences,0);
    if (TextUtils.isEmpty(accountType)) {
      return null;
    }
    return new AuthenticatorDescription(accountType,packageName,labelId,iconId,smallIconId,prefId);
  }
  finally {
    sa.recycle();
  }
}","public AuthenticatorDescription parseServiceAttributes(Resources res,String packageName,AttributeSet attrs){
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AccountAuthenticator);
  try {
    final String accountType=sa.getString(com.android.internal.R.styleable.AccountAuthenticator_accountType);
    final int labelId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_label,0);
    final int iconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_icon,0);
    final int smallIconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_smallIcon,0);
    final int prefId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_accountPreferences,0);
    if (TextUtils.isEmpty(accountType)) {
      return null;
    }
    return new AuthenticatorDescription(accountType,packageName,labelId,iconId,smallIconId,prefId);
  }
  finally {
    sa.recycle();
  }
}"
22936,"public SyncAdapterType parseServiceAttributes(String packageName,AttributeSet attrs){
  TypedArray sa=mContext.getResources().obtainAttributes(attrs,com.android.internal.R.styleable.SyncAdapter);
  try {
    final String authority=sa.getString(com.android.internal.R.styleable.SyncAdapter_contentAuthority);
    final String accountType=sa.getString(com.android.internal.R.styleable.SyncAdapter_accountType);
    if (authority == null || accountType == null) {
      return null;
    }
    final boolean userVisible=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_userVisible,true);
    final boolean supportsUploading=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_supportsUploading,true);
    return new SyncAdapterType(authority,accountType,userVisible,supportsUploading);
  }
  finally {
    sa.recycle();
  }
}","public SyncAdapterType parseServiceAttributes(Resources res,String packageName,AttributeSet attrs){
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.SyncAdapter);
  try {
    final String authority=sa.getString(com.android.internal.R.styleable.SyncAdapter_contentAuthority);
    final String accountType=sa.getString(com.android.internal.R.styleable.SyncAdapter_accountType);
    if (authority == null || accountType == null) {
      return null;
    }
    final boolean userVisible=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_userVisible,true);
    final boolean supportsUploading=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_supportsUploading,true);
    return new SyncAdapterType(authority,accountType,userVisible,supportsUploading);
  }
  finally {
    sa.recycle();
  }
}"
22937,"public abstract V parseServiceAttributes(String packageName,AttributeSet attrs);","public abstract V parseServiceAttributes(Resources res,String packageName,AttributeSet attrs);"
22938,"private ServiceInfo<V> parseServiceInfo(ResolveInfo service) throws XmlPullParserException, IOException {
  android.content.pm.ServiceInfo si=service.serviceInfo;
  ComponentName componentName=new ComponentName(si.packageName,si.name);
  PackageManager pm=mContext.getPackageManager();
  XmlResourceParser parser=null;
  try {
    parser=si.loadXmlMetaData(pm,mMetaDataName);
    if (parser == null) {
      throw new XmlPullParserException(""String_Node_Str"" + mMetaDataName + ""String_Node_Str"");
    }
    AttributeSet attrs=Xml.asAttributeSet(parser);
    int type;
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
    }
    String nodeName=parser.getName();
    if (!mAttributesName.equals(nodeName)) {
      throw new XmlPullParserException(""String_Node_Str"" + mAttributesName + ""String_Node_Str"");
    }
    V v=parseServiceAttributes(si.packageName,attrs);
    if (v == null) {
      return null;
    }
    final android.content.pm.ServiceInfo serviceInfo=service.serviceInfo;
    final ApplicationInfo applicationInfo=serviceInfo.applicationInfo;
    final int uid=applicationInfo.uid;
    return new ServiceInfo<V>(v,componentName,uid);
  }
  finally {
    if (parser != null)     parser.close();
  }
}","private ServiceInfo<V> parseServiceInfo(ResolveInfo service) throws XmlPullParserException, IOException {
  android.content.pm.ServiceInfo si=service.serviceInfo;
  ComponentName componentName=new ComponentName(si.packageName,si.name);
  PackageManager pm=mContext.getPackageManager();
  XmlResourceParser parser=null;
  try {
    parser=si.loadXmlMetaData(pm,mMetaDataName);
    if (parser == null) {
      throw new XmlPullParserException(""String_Node_Str"" + mMetaDataName + ""String_Node_Str"");
    }
    AttributeSet attrs=Xml.asAttributeSet(parser);
    int type;
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
    }
    String nodeName=parser.getName();
    if (!mAttributesName.equals(nodeName)) {
      throw new XmlPullParserException(""String_Node_Str"" + mAttributesName + ""String_Node_Str"");
    }
    V v=parseServiceAttributes(pm.getResourcesForApplication(si.applicationInfo),si.packageName,attrs);
    if (v == null) {
      return null;
    }
    final android.content.pm.ServiceInfo serviceInfo=service.serviceInfo;
    final ApplicationInfo applicationInfo=serviceInfo.applicationInfo;
    final int uid=applicationInfo.uid;
    return new ServiceInfo<V>(v,componentName,uid);
  }
 catch (  NameNotFoundException e) {
    throw new XmlPullParserException(""String_Node_Str"" + si.packageName);
  }
 finally {
    if (parser != null)     parser.close();
  }
}"
22939,"public boolean isUsbRNDISStarted() throws IllegalStateException {
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_NETWORK_STATE,""String_Node_Str"");
  ArrayList<String> rsp=mConnector.doCommand(""String_Node_Str"");
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == NetdResponseCode.UsbRNDISStatusResult) {
      if (tok[2].equals(""String_Node_Str""))       return true;
      return false;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","public boolean isUsbRNDISStarted() throws IllegalStateException {
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_NETWORK_STATE,""String_Node_Str"");
  ArrayList<String> rsp=mConnector.doCommand(""String_Node_Str"");
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == NetdResponseCode.UsbRNDISStatusResult) {
      if (tok[3].equals(""String_Node_Str""))       return true;
      return false;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}"
22940,"private void setSystemVolume(VolumeStreamState streamState){
  setStreamVolumeIndex(streamState.mStreamType,streamState.mIndex);
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
    if (streamType != streamState.mStreamType && STREAM_VOLUME_ALIAS[streamType] == streamState.mStreamType) {
      setStreamVolumeIndex(streamType,mStreamStates[streamType].mIndex);
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamState.mStreamType,SENDMSG_REPLACE,0,0,streamState,PERSIST_DELAY);
}","private void setSystemVolume(VolumeStreamState streamState){
  setStreamVolumeIndex(streamState.mStreamType,streamState.mIndex);
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
    if (streamType != streamState.mStreamType && STREAM_VOLUME_ALIAS[streamType] == streamState.mStreamType) {
      setStreamVolumeIndex(streamType,mStreamStates[streamType].mIndex);
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamState.mStreamType,SENDMSG_REPLACE,1,1,streamState,PERSIST_DELAY);
}"
22941,"@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
synchronized (mSettingsLock) {
    int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
      mRingerModeAffectedStreams=ringerModeAffectedStreams;
      setRingerModeInt(getRingerMode(),false);
    }
    int notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1);
    if (notificationsUseRingVolume != mNotificationsUseRingVolume) {
      mNotificationsUseRingVolume=notificationsUseRingVolume;
      if (mNotificationsUseRingVolume == 1) {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_RING;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_RING]);
      }
 else {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_NOTIFICATION;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_NOTIFICATION]);
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,AudioSystem.STREAM_NOTIFICATION,SENDMSG_REPLACE,0,0,mStreamStates[AudioSystem.STREAM_NOTIFICATION],0);
      }
    }
  }
}","@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
synchronized (mSettingsLock) {
    int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
      mRingerModeAffectedStreams=ringerModeAffectedStreams;
      setRingerModeInt(getRingerMode(),false);
    }
    int notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1);
    if (notificationsUseRingVolume != mNotificationsUseRingVolume) {
      mNotificationsUseRingVolume=notificationsUseRingVolume;
      if (mNotificationsUseRingVolume == 1) {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_RING;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_RING]);
      }
 else {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_NOTIFICATION;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_NOTIFICATION]);
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,AudioSystem.STREAM_NOTIFICATION,SENDMSG_REPLACE,1,1,mStreamStates[AudioSystem.STREAM_NOTIFICATION],0);
      }
    }
  }
}"
22942,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0 && (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0)) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
 else {
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
}"
22943,"private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}","private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}"
22944,"private void persistVolume(VolumeStreamState streamState){
  System.putInt(mContentResolver,streamState.mVolumeIndexSettingName,(streamState.mIndex + 5) / 10);
  System.putInt(mContentResolver,streamState.mLastAudibleVolumeIndexSettingName,(streamState.mLastAudibleIndex + 5) / 10);
}","private void persistVolume(VolumeStreamState streamState,boolean current,boolean lastAudible){
  if (current) {
    System.putInt(mContentResolver,streamState.mVolumeIndexSettingName,(streamState.mIndex + 5) / 10);
  }
  if (lastAudible) {
    System.putInt(mContentResolver,streamState.mLastAudibleVolumeIndexSettingName,(streamState.mLastAudibleIndex + 5) / 10);
  }
}"
22945,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}"
22946,"void showInputMethodMenu(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  hideInputMethodMenu();
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + lastInputMethodId);
  final List<InputMethodInfo> immis=getEnabledInputMethodList();
  int N=(immis == null ? 0 : immis.size());
  mItems=new CharSequence[N];
  mIms=new InputMethodInfo[N];
  for (int i=0; i < N; ++i) {
    InputMethodInfo property=immis.get(i);
    mItems[i]=property.loadLabel(pm);
    mIms[i]=property;
  }
  int checkedItem=0;
  for (int i=0; i < N; ++i) {
    if (mIms[i].getId().equals(lastInputMethodId)) {
      checkedItem=i;
      break;
    }
  }
  AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      hideInputMethodMenu();
    }
  }
;
  TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
  mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
    public void onCancel(    DialogInterface dialog){
      hideInputMethodMenu();
    }
  }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
  a.recycle();
  mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
synchronized (mMethodMap) {
        InputMethodInfo im=mIms[which];
        hideInputMethodMenu();
        setInputMethodLocked(im.getId());
      }
    }
  }
);
synchronized (mMethodMap) {
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.show();
  }
}","void showInputMethodMenu(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  hideInputMethodMenu();
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + lastInputMethodId);
  final List<InputMethodInfo> immis=getEnabledInputMethodList();
  if (immis == null) {
    return;
  }
  int N=immis.size();
  mItems=new CharSequence[N];
  mIms=new InputMethodInfo[N];
  for (int i=0; i < N; ++i) {
    InputMethodInfo property=immis.get(i);
    if (property == null) {
      i--;
      N--;
      continue;
    }
    mItems[i]=property.loadLabel(pm);
    mIms[i]=property;
  }
  int checkedItem=0;
  for (int i=0; i < N; ++i) {
    if (mIms[i].getId().equals(lastInputMethodId)) {
      checkedItem=i;
      break;
    }
  }
  AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      hideInputMethodMenu();
    }
  }
;
  TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
  mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
    public void onCancel(    DialogInterface dialog){
      hideInputMethodMenu();
    }
  }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
  a.recycle();
  mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
synchronized (mMethodMap) {
        InputMethodInfo im=mIms[which];
        hideInputMethodMenu();
        setInputMethodLocked(im.getId());
      }
    }
  }
);
synchronized (mMethodMap) {
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.show();
  }
}"
22947,"/** 
 * Sets the final position (Y) for this scroller.
 * @param newY The new Y offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalX(int)
 */
public void setFinalY(int newY){
  if (mScrollMode == MODE_DEFAULT) {
    mDefaultScroller.setFinalY(newY);
  }
}","/** 
 * Sets the final position (Y) for this scroller.
 * @param newY The new Y offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalX(int)
 */
public void setFinalY(int newY){
  if (mScrollMode == MODE_DEFAULT) {
    if (newY < mMinimumY) {
      mMinimumY=newY;
    }
    if (newY > mMaximumY) {
      mMaximumY=newY;
    }
    mDefaultScroller.setFinalY(newY);
  }
}"
22948,"/** 
 * Sets the final position (X) for this scroller.
 * @param newX The new X offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalY(int)
 */
public void setFinalX(int newX){
  if (mScrollMode == MODE_DEFAULT) {
    mDefaultScroller.setFinalX(newX);
  }
}","/** 
 * Sets the final position (X) for this scroller.
 * @param newX The new X offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalY(int)
 */
public void setFinalX(int newX){
  if (mScrollMode == MODE_DEFAULT) {
    if (newX < mMinimumX) {
      mMinimumX=newX;
    }
    if (newX > mMaximumX) {
      mMaximumX=newX;
    }
    mDefaultScroller.setFinalX(newX);
  }
}"
22949,"/** 
 * A key was pressed down and not handled by anything else in the window.
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
protected boolean onKeyDown(int featureId,int keyCode,KeyEvent event){
  final KeyEvent.DispatcherState dispatcher=mDecor != null ? mDecor.getKeyDispatcherState() : null;
switch (keyCode) {
case KeyEvent.KEYCODE_VOLUME_UP:
case KeyEvent.KEYCODE_VOLUME_DOWN:
{
      AudioManager audioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
      if (audioManager != null) {
        audioManager.adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER,mVolumeControlStreamType,AudioManager.FLAG_SHOW_UI | AudioManager.FLAG_VIBRATE);
      }
      return true;
    }
case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
  if (mTelephonyManager == null) {
    mTelephonyManager=(TelephonyManager)getContext().getSystemService(Context.TELEPHONY_SERVICE);
  }
if (mTelephonyManager != null && mTelephonyManager.getCallState() != TelephonyManager.CALL_STATE_IDLE) {
  return true;
}
case KeyEvent.KEYCODE_MUTE:
case KeyEvent.KEYCODE_HEADSETHOOK:
case KeyEvent.KEYCODE_MEDIA_STOP:
case KeyEvent.KEYCODE_MEDIA_NEXT:
case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
case KeyEvent.KEYCODE_MEDIA_REWIND:
case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
{
Intent intent=new Intent(Intent.ACTION_MEDIA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,event);
getContext().sendOrderedBroadcast(intent,null);
return true;
}
case KeyEvent.KEYCODE_CAMERA:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || dispatcher == null) {
break;
}
if (event.getRepeatCount() == 0) {
dispatcher.startTracking(event,this);
}
 else if (event.isLongPress() && dispatcher.isTracking(event)) {
dispatcher.performedLongPress(event);
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
sendCloseSystemWindows();
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,event);
getContext().sendOrderedBroadcast(intent,null);
}
return true;
}
case KeyEvent.KEYCODE_MENU:
{
onKeyDownPanel((featureId < 0) ? FEATURE_OPTIONS_PANEL : featureId,event);
return true;
}
case KeyEvent.KEYCODE_BACK:
{
if (event.getRepeatCount() > 0) break;
if (featureId < 0) break;
dispatcher.startTracking(event,this);
return true;
}
case KeyEvent.KEYCODE_CALL:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || dispatcher == null) {
break;
}
if (event.getRepeatCount() == 0) {
dispatcher.startTracking(event,this);
}
 else if (event.isLongPress() && dispatcher.isTracking(event)) {
dispatcher.performedLongPress(event);
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
return true;
}
case KeyEvent.KEYCODE_SEARCH:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || dispatcher == null) {
break;
}
if (event.getRepeatCount() == 0) {
dispatcher.startTracking(event,this);
}
 else if (event.isLongPress() && dispatcher.isTracking(event)) {
Configuration config=getContext().getResources().getConfiguration();
if (config.keyboard == Configuration.KEYBOARD_NOKEYS || config.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
dispatcher.performedLongPress(event);
}
 catch (ActivityNotFoundException e) {
}
}
}
break;
}
}
return false;
}","/** 
 * A key was pressed down and not handled by anything else in the window.
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
protected boolean onKeyDown(int featureId,int keyCode,KeyEvent event){
  final KeyEvent.DispatcherState dispatcher=mDecor != null ? mDecor.getKeyDispatcherState() : null;
switch (keyCode) {
case KeyEvent.KEYCODE_VOLUME_UP:
case KeyEvent.KEYCODE_VOLUME_DOWN:
{
      AudioManager audioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
      if (audioManager != null) {
        audioManager.adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER,mVolumeControlStreamType,AudioManager.FLAG_SHOW_UI | AudioManager.FLAG_VIBRATE);
      }
      return true;
    }
case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
  if (mTelephonyManager == null) {
    mTelephonyManager=(TelephonyManager)getContext().getSystemService(Context.TELEPHONY_SERVICE);
  }
if (mTelephonyManager != null && mTelephonyManager.getCallState() != TelephonyManager.CALL_STATE_IDLE) {
  return true;
}
case KeyEvent.KEYCODE_MUTE:
case KeyEvent.KEYCODE_HEADSETHOOK:
case KeyEvent.KEYCODE_MEDIA_STOP:
case KeyEvent.KEYCODE_MEDIA_NEXT:
case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
case KeyEvent.KEYCODE_MEDIA_REWIND:
case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
{
Intent intent=new Intent(Intent.ACTION_MEDIA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,event);
getContext().sendOrderedBroadcast(intent,null);
return true;
}
case KeyEvent.KEYCODE_CAMERA:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || dispatcher == null) {
break;
}
if (event.getRepeatCount() == 0) {
dispatcher.startTracking(event,this);
}
 else if (event.isLongPress() && dispatcher.isTracking(event)) {
dispatcher.performedLongPress(event);
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
sendCloseSystemWindows();
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,event);
getContext().sendOrderedBroadcast(intent,null);
}
return true;
}
case KeyEvent.KEYCODE_MENU:
{
onKeyDownPanel((featureId < 0) ? FEATURE_OPTIONS_PANEL : featureId,event);
return true;
}
case KeyEvent.KEYCODE_BACK:
{
if (event.getRepeatCount() > 0) break;
if (featureId < 0) break;
dispatcher.startTracking(event,this);
return true;
}
case KeyEvent.KEYCODE_CALL:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || dispatcher == null) {
break;
}
if (event.getRepeatCount() == 0) {
dispatcher.startTracking(event,this);
}
 else if (event.isLongPress() && dispatcher.isTracking(event)) {
dispatcher.performedLongPress(event);
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
return true;
}
case KeyEvent.KEYCODE_SEARCH:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || dispatcher == null) {
break;
}
if (event.getRepeatCount() == 0) {
dispatcher.startTracking(event,this);
}
 else if (event.isLongPress() && dispatcher.isTracking(event)) {
Configuration config=getContext().getResources().getConfiguration();
if (config.keyboard == Configuration.KEYBOARD_NOKEYS || config.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
dispatcher.performedLongPress(event);
return true;
}
 catch (ActivityNotFoundException e) {
}
}
}
break;
}
}
return false;
}"
22950,"private void setSystemVolume(VolumeStreamState streamState){
  setStreamVolumeIndex(streamState.mStreamType,streamState.mIndex);
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
    if (streamType != streamState.mStreamType && STREAM_VOLUME_ALIAS[streamType] == streamState.mStreamType) {
      setStreamVolumeIndex(streamType,mStreamStates[streamType].mIndex);
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamState.mStreamType,SENDMSG_REPLACE,0,0,streamState,PERSIST_DELAY);
}","private void setSystemVolume(VolumeStreamState streamState){
  setStreamVolumeIndex(streamState.mStreamType,streamState.mIndex);
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
    if (streamType != streamState.mStreamType && STREAM_VOLUME_ALIAS[streamType] == streamState.mStreamType) {
      setStreamVolumeIndex(streamType,mStreamStates[streamType].mIndex);
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamState.mStreamType,SENDMSG_REPLACE,1,1,streamState,PERSIST_DELAY);
}"
22951,"@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
synchronized (mSettingsLock) {
    int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
      mRingerModeAffectedStreams=ringerModeAffectedStreams;
      setRingerModeInt(getRingerMode(),false);
    }
    int notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1);
    if (notificationsUseRingVolume != mNotificationsUseRingVolume) {
      mNotificationsUseRingVolume=notificationsUseRingVolume;
      if (mNotificationsUseRingVolume == 1) {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_RING;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_RING]);
      }
 else {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_NOTIFICATION;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_NOTIFICATION]);
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,AudioSystem.STREAM_NOTIFICATION,SENDMSG_REPLACE,0,0,mStreamStates[AudioSystem.STREAM_NOTIFICATION],0);
      }
    }
  }
}","@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
synchronized (mSettingsLock) {
    int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
      mRingerModeAffectedStreams=ringerModeAffectedStreams;
      setRingerModeInt(getRingerMode(),false);
    }
    int notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1);
    if (notificationsUseRingVolume != mNotificationsUseRingVolume) {
      mNotificationsUseRingVolume=notificationsUseRingVolume;
      if (mNotificationsUseRingVolume == 1) {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_RING;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_RING]);
      }
 else {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_NOTIFICATION;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_NOTIFICATION]);
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,AudioSystem.STREAM_NOTIFICATION,SENDMSG_REPLACE,1,1,mStreamStates[AudioSystem.STREAM_NOTIFICATION],0);
      }
    }
  }
}"
22952,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0 && (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0)) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
 else {
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
}"
22953,"private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}","private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}"
22954,"private void persistVolume(VolumeStreamState streamState){
  System.putInt(mContentResolver,streamState.mVolumeIndexSettingName,(streamState.mIndex + 5) / 10);
  System.putInt(mContentResolver,streamState.mLastAudibleVolumeIndexSettingName,(streamState.mLastAudibleIndex + 5) / 10);
}","private void persistVolume(VolumeStreamState streamState,boolean current,boolean lastAudible){
  if (current) {
    System.putInt(mContentResolver,streamState.mVolumeIndexSettingName,(streamState.mIndex + 5) / 10);
  }
  if (lastAudible) {
    System.putInt(mContentResolver,streamState.mLastAudibleVolumeIndexSettingName,(streamState.mLastAudibleIndex + 5) / 10);
  }
}"
22955,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}"
22956,"/** 
 * Sets the final position (Y) for this scroller.
 * @param newY The new Y offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalX(int)
 */
public void setFinalY(int newY){
  if (mScrollMode == MODE_DEFAULT) {
    mDefaultScroller.setFinalY(newY);
  }
}","/** 
 * Sets the final position (Y) for this scroller.
 * @param newY The new Y offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalX(int)
 */
public void setFinalY(int newY){
  if (mScrollMode == MODE_DEFAULT) {
    if (newY < mMinimumY) {
      mMinimumY=newY;
    }
    if (newY > mMaximumY) {
      mMaximumY=newY;
    }
    mDefaultScroller.setFinalY(newY);
  }
}"
22957,"/** 
 * Sets the final position (X) for this scroller.
 * @param newX The new X offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalY(int)
 */
public void setFinalX(int newX){
  if (mScrollMode == MODE_DEFAULT) {
    mDefaultScroller.setFinalX(newX);
  }
}","/** 
 * Sets the final position (X) for this scroller.
 * @param newX The new X offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalY(int)
 */
public void setFinalX(int newX){
  if (mScrollMode == MODE_DEFAULT) {
    if (newX < mMinimumX) {
      mMinimumX=newX;
    }
    if (newX > mMaximumX) {
      mMaximumX=newX;
    }
    mDefaultScroller.setFinalX(newX);
  }
}"
22958,"public boolean isUsbRNDISStarted() throws IllegalStateException {
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_NETWORK_STATE,""String_Node_Str"");
  ArrayList<String> rsp=mConnector.doCommand(""String_Node_Str"");
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == NetdResponseCode.UsbRNDISStatusResult) {
      if (tok[2].equals(""String_Node_Str""))       return true;
      return false;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","public boolean isUsbRNDISStarted() throws IllegalStateException {
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_NETWORK_STATE,""String_Node_Str"");
  ArrayList<String> rsp=mConnector.doCommand(""String_Node_Str"");
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == NetdResponseCode.UsbRNDISStatusResult) {
      if (tok[3].equals(""String_Node_Str""))       return true;
      return false;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}"
22959,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  boolean configChanged;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client,false);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (DEBUG_LAYOUT)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mAttrs);
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
 else {
      win.mHScale=win.mVScale=1;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen && mPolicy.isScreenOn()) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Slog.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
      if (win.mAttrs.type == TYPE_BASE_APPLICATION && win.mAppToken != null && win.mAppToken.startingWindow != null) {
        final int mask=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON;
        WindowManager.LayoutParams sa=win.mAppToken.startingWindow.mAttrs;
        sa.flags=(sa.flags & ~mask) | (win.mAttrs.flags & mask);
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    configChanged=updateOrientationFromAppTokensLocked();
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (configChanged) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  boolean configChanged;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client,false);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (DEBUG_LAYOUT)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mAttrs);
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
 else {
      win.mHScale=win.mVScale=1;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen && mPolicy.isScreenOn()) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Slog.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
      if (win.mAttrs.type == TYPE_BASE_APPLICATION && win.mAppToken != null && win.mAppToken.startingWindow != null) {
        final int mask=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON;
        WindowManager.LayoutParams sa=win.mAppToken.startingWindow.mAttrs;
        sa.flags=(sa.flags & ~mask) | (win.mAttrs.flags & mask);
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    configChanged=updateOrientationFromAppTokensLocked();
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (configChanged) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}"
22960,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    boolean wallpaperForceHidingChanged=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
focusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && !restart && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    restart=true;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + restart);
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if (DEBUG_ORIENTATION && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    boolean wallpaperForceHidingChanged=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
                mFocusMayChange=true;
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && !restart && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    restart=true;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + restart);
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if (DEBUG_ORIENTATION && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}"
22961,"/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}","/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}"
22962,"public void prepareAppTransition(int transit){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit + ""String_Node_Str""+ mNextAppTransition);
    if (!mDisplayFrozen) {
      if (mNextAppTransition == WindowManagerPolicy.TRANSIT_UNSET || mNextAppTransition == WindowManagerPolicy.TRANSIT_NONE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_TASK_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_TASK_CLOSE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE) {
        mNextAppTransition=transit;
      }
      mAppTransitionReady=false;
      mAppTransitionTimeout=false;
      mStartingIconInTransition=false;
      mSkipAppTransitionAnimation=false;
      mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
      mH.sendMessageDelayed(mH.obtainMessage(H.APP_TRANSITION_TIMEOUT),5000);
    }
  }
}","public void prepareAppTransition(int transit){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit + ""String_Node_Str""+ mNextAppTransition);
    if (!mDisplayFrozen && mPolicy.isScreenOn()) {
      if (mNextAppTransition == WindowManagerPolicy.TRANSIT_UNSET || mNextAppTransition == WindowManagerPolicy.TRANSIT_NONE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_TASK_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_TASK_CLOSE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE) {
        mNextAppTransition=transit;
      }
      mAppTransitionReady=false;
      mAppTransitionTimeout=false;
      mStartingIconInTransition=false;
      mSkipAppTransitionAnimation=false;
      mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
      mH.sendMessageDelayed(mH.obtainMessage(H.APP_TRANSITION_TIMEOUT),5000);
    }
  }
}"
22963,"public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
      RuntimeException e=new RuntimeException();
      if (!HIDE_STACK_CRAWLS)       e.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mNextAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested,e);
    }
    if (!mDisplayFrozen && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
      if (wtoken.hiddenRequested != visible) {
        return;
      }
      wtoken.hiddenRequested=!visible;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      wtoken.setDummyAnimation();
      mOpeningApps.remove(wtoken);
      mClosingApps.remove(wtoken);
      wtoken.waitingToShow=wtoken.waitingToHide=false;
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.startingDisplayed=false;
        wtoken.startingMoved=false;
        if (wtoken.hidden) {
          wtoken.allDrawn=false;
          wtoken.waitingToShow=true;
          if (wtoken.clientHidden) {
            wtoken.clientHidden=false;
            wtoken.sendAppVisibilityToClients();
          }
        }
      }
 else {
        mClosingApps.add(wtoken);
        if (!wtoken.hidden) {
          wtoken.waitingToHide=true;
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    setTokenVisibilityLocked(wtoken,null,visible,WindowManagerPolicy.TRANSIT_UNSET,true);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}","public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
      RuntimeException e=new RuntimeException();
      if (!HIDE_STACK_CRAWLS)       e.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mNextAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested,e);
    }
    if (!mDisplayFrozen && mPolicy.isScreenOn() && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
      if (wtoken.hiddenRequested != visible) {
        return;
      }
      wtoken.hiddenRequested=!visible;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      wtoken.setDummyAnimation();
      mOpeningApps.remove(wtoken);
      mClosingApps.remove(wtoken);
      wtoken.waitingToShow=wtoken.waitingToHide=false;
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.startingDisplayed=false;
        wtoken.startingMoved=false;
        if (wtoken.hidden) {
          wtoken.allDrawn=false;
          wtoken.waitingToShow=true;
          if (wtoken.clientHidden) {
            wtoken.clientHidden=false;
            wtoken.sendAppVisibilityToClients();
          }
        }
      }
 else {
        mClosingApps.add(wtoken);
        if (!wtoken.hidden) {
          wtoken.waitingToHide=true;
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    setTokenVisibilityLocked(wtoken,null,visible,WindowManagerPolicy.TRANSIT_UNSET,true);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}"
22964,"boolean hideLw(boolean doAnimation,boolean requestAnim){
  boolean current=doAnimation ? mPolicyVisibilityAfterAnim : mPolicyVisibility;
  if (!current) {
    return false;
  }
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_EXIT,false);
    if (mAnimation == null) {
      doAnimation=false;
    }
  }
  if (doAnimation) {
    mPolicyVisibilityAfterAnim=false;
  }
 else {
    mPolicyVisibilityAfterAnim=false;
    mPolicyVisibility=false;
    enableScreenIfNeededLocked();
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}","boolean hideLw(boolean doAnimation,boolean requestAnim){
  boolean current=doAnimation ? mPolicyVisibilityAfterAnim : mPolicyVisibility;
  if (!current) {
    return false;
  }
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_EXIT,false);
    if (mAnimation == null) {
      doAnimation=false;
    }
  }
  if (doAnimation) {
    mPolicyVisibilityAfterAnim=false;
  }
 else {
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this);
    mPolicyVisibilityAfterAnim=false;
    mPolicyVisibility=false;
    enableScreenIfNeededLocked();
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}"
22965,"boolean showLw(boolean doAnimation,boolean requestAnim){
  if (mPolicyVisibility && mPolicyVisibilityAfterAnim) {
    return false;
  }
  mPolicyVisibility=true;
  mPolicyVisibilityAfterAnim=true;
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_ENTER,true);
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}","boolean showLw(boolean doAnimation,boolean requestAnim){
  if (mPolicyVisibility && mPolicyVisibilityAfterAnim) {
    return false;
  }
  if (DEBUG_VISIBILITY)   Slog.v(TAG,""String_Node_Str"" + this);
  mPolicyVisibility=true;
  mPolicyVisibilityAfterAnim=true;
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_ENTER,true);
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}"
22966,"public void startAppFreezingScreen(IBinder token,int configChanges){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (configChanges == 0 && !mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + token);
      return;
    }
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null || wtoken.appToken == null) {
      Slog.w(TAG,""String_Node_Str"" + wtoken);
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    startAppFreezingScreenLocked(wtoken,configChanges);
    Binder.restoreCallingIdentity(origId);
  }
}","public void startAppFreezingScreen(IBinder token,int configChanges){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (configChanges == 0 && !mDisplayFrozen && mPolicy.isScreenOn()) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + token);
      return;
    }
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null || wtoken.appToken == null) {
      Slog.w(TAG,""String_Node_Str"" + wtoken);
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    startAppFreezingScreenLocked(wtoken,configChanges);
    Binder.restoreCallingIdentity(origId);
  }
}"
22967,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  boolean configChanged;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client,false);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (DEBUG_LAYOUT)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mAttrs);
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
 else {
      win.mHScale=win.mVScale=1;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen && mPolicy.isScreenOn()) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Slog.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
      if (win.mAttrs.type == TYPE_BASE_APPLICATION && win.mAppToken != null && win.mAppToken.startingWindow != null) {
        final int mask=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON;
        WindowManager.LayoutParams sa=win.mAppToken.startingWindow.mAttrs;
        sa.flags=(sa.flags & ~mask) | (win.mAttrs.flags & mask);
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    configChanged=updateOrientationFromAppTokensLocked();
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (configChanged) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  boolean configChanged;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client,false);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (DEBUG_LAYOUT)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mAttrs);
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
 else {
      win.mHScale=win.mVScale=1;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen && mPolicy.isScreenOn()) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Slog.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
      if (win.mAttrs.type == TYPE_BASE_APPLICATION && win.mAppToken != null && win.mAppToken.startingWindow != null) {
        final int mask=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON;
        WindowManager.LayoutParams sa=win.mAppToken.startingWindow.mAttrs;
        sa.flags=(sa.flags & ~mask) | (win.mAttrs.flags & mask);
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    configChanged=updateOrientationFromAppTokensLocked();
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (configChanged) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}"
22968,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    boolean wallpaperForceHidingChanged=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
focusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && !restart && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    restart=true;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + restart);
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if (DEBUG_ORIENTATION && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    boolean wallpaperForceHidingChanged=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
                mFocusMayChange=true;
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && !restart && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    restart=true;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + restart);
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if (DEBUG_ORIENTATION && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}"
22969,"/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}","/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}"
22970,"public void prepareAppTransition(int transit){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit + ""String_Node_Str""+ mNextAppTransition);
    if (!mDisplayFrozen) {
      if (mNextAppTransition == WindowManagerPolicy.TRANSIT_UNSET || mNextAppTransition == WindowManagerPolicy.TRANSIT_NONE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_TASK_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_TASK_CLOSE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE) {
        mNextAppTransition=transit;
      }
      mAppTransitionReady=false;
      mAppTransitionTimeout=false;
      mStartingIconInTransition=false;
      mSkipAppTransitionAnimation=false;
      mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
      mH.sendMessageDelayed(mH.obtainMessage(H.APP_TRANSITION_TIMEOUT),5000);
    }
  }
}","public void prepareAppTransition(int transit){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit + ""String_Node_Str""+ mNextAppTransition);
    if (!mDisplayFrozen && mPolicy.isScreenOn()) {
      if (mNextAppTransition == WindowManagerPolicy.TRANSIT_UNSET || mNextAppTransition == WindowManagerPolicy.TRANSIT_NONE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_TASK_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_TASK_CLOSE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE) {
        mNextAppTransition=transit;
      }
      mAppTransitionReady=false;
      mAppTransitionTimeout=false;
      mStartingIconInTransition=false;
      mSkipAppTransitionAnimation=false;
      mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
      mH.sendMessageDelayed(mH.obtainMessage(H.APP_TRANSITION_TIMEOUT),5000);
    }
  }
}"
22971,"public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
      RuntimeException e=new RuntimeException();
      if (!HIDE_STACK_CRAWLS)       e.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mNextAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested,e);
    }
    if (!mDisplayFrozen && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
      if (wtoken.hiddenRequested != visible) {
        return;
      }
      wtoken.hiddenRequested=!visible;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      wtoken.setDummyAnimation();
      mOpeningApps.remove(wtoken);
      mClosingApps.remove(wtoken);
      wtoken.waitingToShow=wtoken.waitingToHide=false;
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.startingDisplayed=false;
        wtoken.startingMoved=false;
        if (wtoken.hidden) {
          wtoken.allDrawn=false;
          wtoken.waitingToShow=true;
          if (wtoken.clientHidden) {
            wtoken.clientHidden=false;
            wtoken.sendAppVisibilityToClients();
          }
        }
      }
 else {
        mClosingApps.add(wtoken);
        if (!wtoken.hidden) {
          wtoken.waitingToHide=true;
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    setTokenVisibilityLocked(wtoken,null,visible,WindowManagerPolicy.TRANSIT_UNSET,true);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}","public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
      RuntimeException e=new RuntimeException();
      if (!HIDE_STACK_CRAWLS)       e.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mNextAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested,e);
    }
    if (!mDisplayFrozen && mPolicy.isScreenOn() && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
      if (wtoken.hiddenRequested != visible) {
        return;
      }
      wtoken.hiddenRequested=!visible;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      wtoken.setDummyAnimation();
      mOpeningApps.remove(wtoken);
      mClosingApps.remove(wtoken);
      wtoken.waitingToShow=wtoken.waitingToHide=false;
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.startingDisplayed=false;
        wtoken.startingMoved=false;
        if (wtoken.hidden) {
          wtoken.allDrawn=false;
          wtoken.waitingToShow=true;
          if (wtoken.clientHidden) {
            wtoken.clientHidden=false;
            wtoken.sendAppVisibilityToClients();
          }
        }
      }
 else {
        mClosingApps.add(wtoken);
        if (!wtoken.hidden) {
          wtoken.waitingToHide=true;
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    setTokenVisibilityLocked(wtoken,null,visible,WindowManagerPolicy.TRANSIT_UNSET,true);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}"
22972,"boolean hideLw(boolean doAnimation,boolean requestAnim){
  boolean current=doAnimation ? mPolicyVisibilityAfterAnim : mPolicyVisibility;
  if (!current) {
    return false;
  }
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_EXIT,false);
    if (mAnimation == null) {
      doAnimation=false;
    }
  }
  if (doAnimation) {
    mPolicyVisibilityAfterAnim=false;
  }
 else {
    mPolicyVisibilityAfterAnim=false;
    mPolicyVisibility=false;
    enableScreenIfNeededLocked();
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}","boolean hideLw(boolean doAnimation,boolean requestAnim){
  boolean current=doAnimation ? mPolicyVisibilityAfterAnim : mPolicyVisibility;
  if (!current) {
    return false;
  }
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_EXIT,false);
    if (mAnimation == null) {
      doAnimation=false;
    }
  }
  if (doAnimation) {
    mPolicyVisibilityAfterAnim=false;
  }
 else {
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this);
    mPolicyVisibilityAfterAnim=false;
    mPolicyVisibility=false;
    enableScreenIfNeededLocked();
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}"
22973,"boolean showLw(boolean doAnimation,boolean requestAnim){
  if (mPolicyVisibility && mPolicyVisibilityAfterAnim) {
    return false;
  }
  mPolicyVisibility=true;
  mPolicyVisibilityAfterAnim=true;
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_ENTER,true);
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}","boolean showLw(boolean doAnimation,boolean requestAnim){
  if (mPolicyVisibility && mPolicyVisibilityAfterAnim) {
    return false;
  }
  if (DEBUG_VISIBILITY)   Slog.v(TAG,""String_Node_Str"" + this);
  mPolicyVisibility=true;
  mPolicyVisibilityAfterAnim=true;
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_ENTER,true);
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}"
22974,"public void startAppFreezingScreen(IBinder token,int configChanges){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (configChanges == 0 && !mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + token);
      return;
    }
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null || wtoken.appToken == null) {
      Slog.w(TAG,""String_Node_Str"" + wtoken);
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    startAppFreezingScreenLocked(wtoken,configChanges);
    Binder.restoreCallingIdentity(origId);
  }
}","public void startAppFreezingScreen(IBinder token,int configChanges){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (configChanges == 0 && !mDisplayFrozen && mPolicy.isScreenOn()) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + token);
      return;
    }
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null || wtoken.appToken == null) {
      Slog.w(TAG,""String_Node_Str"" + wtoken);
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    startAppFreezingScreenLocked(wtoken,configChanges);
    Binder.restoreCallingIdentity(origId);
  }
}"
22975,"private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}","private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  if (mAuthHeader != null)   return;
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}"
22976,"/** 
 * The constructor for the TextToSpeech class. This will also initialize the associated TextToSpeech engine if it isn't already running.
 * @param context The context this instance is running in.
 * @param listener The  {@link TextToSpeech.OnInitListener} that will be called when theTextToSpeech engine has initialized.
 */
public TextToSpeech(Context context,OnInitListener listener){
  mContext=context;
  mPackageName=mContext.getPackageName();
  mInitListener=listener;
  mCachedParams=new String[2 * Engine.NB_CACHED_PARAMS];
  mCachedParams[Engine.PARAM_POSITION_RATE]=Engine.KEY_PARAM_RATE;
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE]=Engine.KEY_PARAM_LANGUAGE;
  mCachedParams[Engine.PARAM_POSITION_COUNTRY]=Engine.KEY_PARAM_COUNTRY;
  mCachedParams[Engine.PARAM_POSITION_VARIANT]=Engine.KEY_PARAM_VARIANT;
  mCachedParams[Engine.PARAM_POSITION_STREAM]=Engine.KEY_PARAM_STREAM;
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID]=Engine.KEY_PARAM_UTTERANCE_ID;
  mCachedParams[Engine.PARAM_POSITION_ENGINE]=Engine.KEY_PARAM_ENGINE;
  mCachedParams[Engine.PARAM_POSITION_RATE + 1]=String.valueOf(Engine.DEFAULT_RATE);
  Locale defaultLoc=Locale.getDefault();
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1]=defaultLoc.getISO3Language();
  mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1]=defaultLoc.getISO3Country();
  mCachedParams[Engine.PARAM_POSITION_VARIANT + 1]=defaultLoc.getVariant();
  mCachedParams[Engine.PARAM_POSITION_STREAM + 1]=String.valueOf(Engine.DEFAULT_STREAM);
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=Engine.DEFAULT_SYNTH;
  initTts();
}","/** 
 * The constructor for the TextToSpeech class. This will also initialize the associated TextToSpeech engine if it isn't already running.
 * @param context The context this instance is running in.
 * @param listener The  {@link TextToSpeech.OnInitListener} that will be called when theTextToSpeech engine has initialized.
 */
public TextToSpeech(Context context,OnInitListener listener){
  mContext=context;
  mPackageName=mContext.getPackageName();
  mInitListener=listener;
  mCachedParams=new String[2 * Engine.NB_CACHED_PARAMS];
  mCachedParams[Engine.PARAM_POSITION_RATE]=Engine.KEY_PARAM_RATE;
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE]=Engine.KEY_PARAM_LANGUAGE;
  mCachedParams[Engine.PARAM_POSITION_COUNTRY]=Engine.KEY_PARAM_COUNTRY;
  mCachedParams[Engine.PARAM_POSITION_VARIANT]=Engine.KEY_PARAM_VARIANT;
  mCachedParams[Engine.PARAM_POSITION_STREAM]=Engine.KEY_PARAM_STREAM;
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID]=Engine.KEY_PARAM_UTTERANCE_ID;
  mCachedParams[Engine.PARAM_POSITION_ENGINE]=Engine.KEY_PARAM_ENGINE;
  mCachedParams[Engine.PARAM_POSITION_RATE + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_VARIANT + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_STREAM + 1]=String.valueOf(Engine.DEFAULT_STREAM);
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=""String_Node_Str"";
  initTts();
}"
22977,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
synchronized (this) {
        mSynthBusy=true;
      }
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
synchronized (this) {
        mSynthBusy=false;
      }
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
      processSpeechQueue();
    }
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
synchronized (this) {
        mSynthBusy=true;
      }
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
synchronized (this) {
        mSynthBusy=false;
      }
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
 else {
        setEngine(getDefaultEngine());
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
 else {
        setLanguage(""String_Node_Str"",getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
 else {
        setSpeechRate(""String_Node_Str"",getDefaultRate());
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
      processSpeechQueue();
    }
  }
}"
22978,"private int setEngine(String enginePackageName){
  String soFilename=""String_Node_Str"";
  if (enginePackageName.equals(""String_Node_Str"")) {
    soFilename=""String_Node_Str"";
  }
 else {
    Intent intent=new Intent(""String_Node_Str"");
    intent.setPackage(enginePackageName);
    ResolveInfo[] enginesArray=new ResolveInfo[0];
    PackageManager pm=getPackageManager();
    List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
    if ((resolveInfos == null) || resolveInfos.isEmpty()) {
      Log.e(SERVICE_TAG,""String_Node_Str"" + enginePackageName);
      return TextToSpeech.ERROR;
    }
    enginesArray=resolveInfos.toArray(enginesArray);
    ActivityInfo aInfo=enginesArray[0].activityInfo;
    soFilename=aInfo.name.replace(aInfo.packageName + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
    soFilename=soFilename.toLowerCase();
    soFilename=""String_Node_Str"" + aInfo.packageName + ""String_Node_Str""+ soFilename;
  }
  if (currentSpeechEngineSOFile.equals(soFilename)) {
    return TextToSpeech.SUCCESS;
  }
  File f=new File(soFilename);
  if (!f.exists()) {
    Log.e(SERVICE_TAG,""String_Node_Str"" + soFilename);
    return TextToSpeech.ERROR;
  }
  if (sNativeSynth != null) {
    sNativeSynth.stopSync();
    sNativeSynth.shutdown();
    sNativeSynth=null;
  }
  sNativeSynth=new SynthProxy(soFilename);
  currentSpeechEngineSOFile=soFilename;
  return TextToSpeech.SUCCESS;
}","private int setEngine(String enginePackageName){
  String soFilename=""String_Node_Str"";
  if (isDefaultEnforced()) {
    enginePackageName=getDefaultEngine();
  }
  if (enginePackageName.equals(""String_Node_Str"")) {
    soFilename=""String_Node_Str"";
  }
 else {
    Intent intent=new Intent(""String_Node_Str"");
    intent.setPackage(enginePackageName);
    ResolveInfo[] enginesArray=new ResolveInfo[0];
    PackageManager pm=getPackageManager();
    List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
    if ((resolveInfos == null) || resolveInfos.isEmpty()) {
      Log.e(SERVICE_TAG,""String_Node_Str"" + enginePackageName);
      return TextToSpeech.ERROR;
    }
    enginesArray=resolveInfos.toArray(enginesArray);
    ActivityInfo aInfo=enginesArray[0].activityInfo;
    soFilename=aInfo.name.replace(aInfo.packageName + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
    soFilename=soFilename.toLowerCase();
    soFilename=""String_Node_Str"" + aInfo.packageName + ""String_Node_Str""+ soFilename;
  }
  if (currentSpeechEngineSOFile.equals(soFilename)) {
    return TextToSpeech.SUCCESS;
  }
  File f=new File(soFilename);
  if (!f.exists()) {
    Log.e(SERVICE_TAG,""String_Node_Str"" + soFilename);
    return TextToSpeech.ERROR;
  }
  if (sNativeSynth != null) {
    sNativeSynth.stopSync();
    sNativeSynth.shutdown();
    sNativeSynth=null;
  }
  sNativeSynth=new SynthProxy(soFilename);
  currentSpeechEngineSOFile=soFilename;
  return TextToSpeech.SUCCESS;
}"
22979,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
synchronized (this) {
            mSynthBusy=true;
          }
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
synchronized (this) {
            mSynthBusy=false;
          }
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
synchronized (this) {
            mSynthBusy=true;
          }
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
synchronized (this) {
            mSynthBusy=false;
          }
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
 else {
            setEngine(getDefaultEngine());
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
 else {
            setLanguage(""String_Node_Str"",getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
 else {
            setSpeechRate(""String_Node_Str"",getDefaultRate());
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}"
22980,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          mSynthBusy=true;
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          mSynthBusy=false;
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          mSynthBusy=true;
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          mSynthBusy=false;
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
 else {
            setEngine(getDefaultEngine());
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
 else {
            setLanguage(""String_Node_Str"",getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
 else {
            setSpeechRate(""String_Node_Str"",getDefaultRate());
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}"
22981,"private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}","private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  if (mAuthHeader != null)   return;
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}"
22982,"private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}","private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  if (mAuthHeader != null)   return;
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}"
22983,"/** 
 * The constructor for the TextToSpeech class. This will also initialize the associated TextToSpeech engine if it isn't already running.
 * @param context The context this instance is running in.
 * @param listener The  {@link TextToSpeech.OnInitListener} that will be called when theTextToSpeech engine has initialized.
 */
public TextToSpeech(Context context,OnInitListener listener){
  mContext=context;
  mPackageName=mContext.getPackageName();
  mInitListener=listener;
  mCachedParams=new String[2 * Engine.NB_CACHED_PARAMS];
  mCachedParams[Engine.PARAM_POSITION_RATE]=Engine.KEY_PARAM_RATE;
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE]=Engine.KEY_PARAM_LANGUAGE;
  mCachedParams[Engine.PARAM_POSITION_COUNTRY]=Engine.KEY_PARAM_COUNTRY;
  mCachedParams[Engine.PARAM_POSITION_VARIANT]=Engine.KEY_PARAM_VARIANT;
  mCachedParams[Engine.PARAM_POSITION_STREAM]=Engine.KEY_PARAM_STREAM;
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID]=Engine.KEY_PARAM_UTTERANCE_ID;
  mCachedParams[Engine.PARAM_POSITION_ENGINE]=Engine.KEY_PARAM_ENGINE;
  mCachedParams[Engine.PARAM_POSITION_RATE + 1]=String.valueOf(Engine.DEFAULT_RATE);
  Locale defaultLoc=Locale.getDefault();
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1]=defaultLoc.getISO3Language();
  mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1]=defaultLoc.getISO3Country();
  mCachedParams[Engine.PARAM_POSITION_VARIANT + 1]=defaultLoc.getVariant();
  mCachedParams[Engine.PARAM_POSITION_STREAM + 1]=String.valueOf(Engine.DEFAULT_STREAM);
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=Engine.DEFAULT_SYNTH;
  initTts();
}","/** 
 * The constructor for the TextToSpeech class. This will also initialize the associated TextToSpeech engine if it isn't already running.
 * @param context The context this instance is running in.
 * @param listener The  {@link TextToSpeech.OnInitListener} that will be called when theTextToSpeech engine has initialized.
 */
public TextToSpeech(Context context,OnInitListener listener){
  mContext=context;
  mPackageName=mContext.getPackageName();
  mInitListener=listener;
  mCachedParams=new String[2 * Engine.NB_CACHED_PARAMS];
  mCachedParams[Engine.PARAM_POSITION_RATE]=Engine.KEY_PARAM_RATE;
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE]=Engine.KEY_PARAM_LANGUAGE;
  mCachedParams[Engine.PARAM_POSITION_COUNTRY]=Engine.KEY_PARAM_COUNTRY;
  mCachedParams[Engine.PARAM_POSITION_VARIANT]=Engine.KEY_PARAM_VARIANT;
  mCachedParams[Engine.PARAM_POSITION_STREAM]=Engine.KEY_PARAM_STREAM;
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID]=Engine.KEY_PARAM_UTTERANCE_ID;
  mCachedParams[Engine.PARAM_POSITION_ENGINE]=Engine.KEY_PARAM_ENGINE;
  mCachedParams[Engine.PARAM_POSITION_RATE + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_VARIANT + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_STREAM + 1]=String.valueOf(Engine.DEFAULT_STREAM);
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=""String_Node_Str"";
  initTts();
}"
22984,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
synchronized (this) {
        mSynthBusy=true;
      }
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
synchronized (this) {
        mSynthBusy=false;
      }
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
      processSpeechQueue();
    }
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
synchronized (this) {
        mSynthBusy=true;
      }
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
synchronized (this) {
        mSynthBusy=false;
      }
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
 else {
        setEngine(getDefaultEngine());
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
 else {
        setLanguage(""String_Node_Str"",getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
 else {
        setSpeechRate(""String_Node_Str"",getDefaultRate());
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
      processSpeechQueue();
    }
  }
}"
22985,"private int setEngine(String enginePackageName){
  String soFilename=""String_Node_Str"";
  if (enginePackageName.equals(""String_Node_Str"")) {
    soFilename=""String_Node_Str"";
  }
 else {
    Intent intent=new Intent(""String_Node_Str"");
    intent.setPackage(enginePackageName);
    ResolveInfo[] enginesArray=new ResolveInfo[0];
    PackageManager pm=getPackageManager();
    List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
    if ((resolveInfos == null) || resolveInfos.isEmpty()) {
      Log.e(SERVICE_TAG,""String_Node_Str"" + enginePackageName);
      return TextToSpeech.ERROR;
    }
    enginesArray=resolveInfos.toArray(enginesArray);
    ActivityInfo aInfo=enginesArray[0].activityInfo;
    soFilename=aInfo.name.replace(aInfo.packageName + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
    soFilename=soFilename.toLowerCase();
    soFilename=""String_Node_Str"" + aInfo.packageName + ""String_Node_Str""+ soFilename;
  }
  if (currentSpeechEngineSOFile.equals(soFilename)) {
    return TextToSpeech.SUCCESS;
  }
  File f=new File(soFilename);
  if (!f.exists()) {
    Log.e(SERVICE_TAG,""String_Node_Str"" + soFilename);
    return TextToSpeech.ERROR;
  }
  if (sNativeSynth != null) {
    sNativeSynth.stopSync();
    sNativeSynth.shutdown();
    sNativeSynth=null;
  }
  sNativeSynth=new SynthProxy(soFilename);
  currentSpeechEngineSOFile=soFilename;
  return TextToSpeech.SUCCESS;
}","private int setEngine(String enginePackageName){
  String soFilename=""String_Node_Str"";
  if (isDefaultEnforced()) {
    enginePackageName=getDefaultEngine();
  }
  if (enginePackageName.equals(""String_Node_Str"")) {
    soFilename=""String_Node_Str"";
  }
 else {
    Intent intent=new Intent(""String_Node_Str"");
    intent.setPackage(enginePackageName);
    ResolveInfo[] enginesArray=new ResolveInfo[0];
    PackageManager pm=getPackageManager();
    List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
    if ((resolveInfos == null) || resolveInfos.isEmpty()) {
      Log.e(SERVICE_TAG,""String_Node_Str"" + enginePackageName);
      return TextToSpeech.ERROR;
    }
    enginesArray=resolveInfos.toArray(enginesArray);
    ActivityInfo aInfo=enginesArray[0].activityInfo;
    soFilename=aInfo.name.replace(aInfo.packageName + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
    soFilename=soFilename.toLowerCase();
    soFilename=""String_Node_Str"" + aInfo.packageName + ""String_Node_Str""+ soFilename;
  }
  if (currentSpeechEngineSOFile.equals(soFilename)) {
    return TextToSpeech.SUCCESS;
  }
  File f=new File(soFilename);
  if (!f.exists()) {
    Log.e(SERVICE_TAG,""String_Node_Str"" + soFilename);
    return TextToSpeech.ERROR;
  }
  if (sNativeSynth != null) {
    sNativeSynth.stopSync();
    sNativeSynth.shutdown();
    sNativeSynth=null;
  }
  sNativeSynth=new SynthProxy(soFilename);
  currentSpeechEngineSOFile=soFilename;
  return TextToSpeech.SUCCESS;
}"
22986,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
synchronized (this) {
            mSynthBusy=true;
          }
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
synchronized (this) {
            mSynthBusy=false;
          }
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
synchronized (this) {
            mSynthBusy=true;
          }
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
synchronized (this) {
            mSynthBusy=false;
          }
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
 else {
            setEngine(getDefaultEngine());
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
 else {
            setLanguage(""String_Node_Str"",getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
 else {
            setSpeechRate(""String_Node_Str"",getDefaultRate());
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}"
22987,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          mSynthBusy=true;
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          mSynthBusy=false;
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          mSynthBusy=true;
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          mSynthBusy=false;
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
 else {
            setEngine(getDefaultEngine());
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
 else {
            setLanguage(""String_Node_Str"",getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
 else {
            setSpeechRate(""String_Node_Str"",getDefaultRate());
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}"
22988,"private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}","private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  if (mAuthHeader != null)   return;
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}"
22989,"Listener(IBinder token){
  mToken=token;
}","Listener(IBinder token,int uid){
  mToken=token;
  mUid=uid;
}"
22990,"public boolean enableSensor(IBinder binder,String name,int sensor,int enable) throws RemoteException {
  if (localLOGV)   Slog.d(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ sensor+ ""String_Node_Str""+ enable);
  int uid=Binder.getCallingUid();
  long identity=Binder.clearCallingIdentity();
  if (enable == SENSOR_DISABLE) {
    mBatteryStats.noteStopSensor(uid,sensor);
  }
 else {
    mBatteryStats.noteStartSensor(uid,sensor);
  }
  Binder.restoreCallingIdentity(identity);
  if (binder == null) {
    Slog.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ sensor+ ""String_Node_Str"");
    return false;
  }
synchronized (mListeners) {
    if (enable != SENSOR_DISABLE && !_sensors_control_activate(sensor,true)) {
      Slog.w(TAG,""String_Node_Str"" + sensor);
      return false;
    }
    Listener l=null;
    int minDelay=enable;
    for (    Listener listener : mListeners) {
      if (binder == listener.mToken) {
        l=listener;
      }
      if (minDelay > listener.mDelay)       minDelay=listener.mDelay;
    }
    if (l == null && enable != SENSOR_DISABLE) {
      l=new Listener(binder);
      binder.linkToDeath(l,0);
      mListeners.add(l);
      mListeners.notify();
    }
    if (l == null) {
      Slog.w(TAG,""String_Node_Str"" + binder + ""String_Node_Str""+ name+ ""String_Node_Str""+ sensor+ ""String_Node_Str"");
      return false;
    }
    if (minDelay >= 0) {
      _sensors_control_set_delay(minDelay);
    }
    if (enable != SENSOR_DISABLE) {
      l.addSensor(sensor,enable);
    }
 else {
      l.removeSensor(sensor);
      deactivateIfUnusedLocked(sensor);
      if (l.mSensors == 0) {
        mListeners.remove(l);
        binder.unlinkToDeath(l,0);
        mListeners.notify();
      }
    }
    if (mListeners.size() == 0) {
      _sensors_control_wake();
      _sensors_control_close();
    }
  }
  return true;
}","public boolean enableSensor(IBinder binder,String name,int sensor,int enable) throws RemoteException {
  if (localLOGV)   Slog.d(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ sensor+ ""String_Node_Str""+ enable);
  if (binder == null) {
    Slog.e(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ sensor+ ""String_Node_Str"");
    return false;
  }
  if (enable < 0 && (enable != SENSOR_DISABLE)) {
    Slog.e(TAG,""String_Node_Str"" + enable + ""String_Node_Str""+ name+ ""String_Node_Str""+ sensor+ ""String_Node_Str"");
    return false;
  }
  boolean res;
  int uid=Binder.getCallingUid();
synchronized (mListeners) {
    res=enableSensorInternalLocked(binder,uid,name,sensor,enable);
    if (res == true) {
      long identity=Binder.clearCallingIdentity();
      if (enable == SENSOR_DISABLE) {
        mBatteryStats.noteStopSensor(uid,sensor);
      }
 else {
        mBatteryStats.noteStartSensor(uid,sensor);
      }
      Binder.restoreCallingIdentity(identity);
    }
  }
  return res;
}"
22991,"void addSensor(int sensor,int delay){
  mSensors|=(1 << sensor);
  if (mDelay > delay)   mDelay=delay;
}","void addSensor(int sensor,int delay){
  mSensors|=(1 << sensor);
  if (delay < mDelay)   mDelay=delay;
}"
22992,"private void deactivateIfUnusedLocked(int sensor) throws RemoteException {
  int size=mListeners.size();
  for (int i=0; i < size; i++) {
    if (mListeners.get(i).hasSensor(sensor))     return;
  }
  _sensors_control_activate(sensor,false);
}","private void deactivateIfUnusedLocked(int sensor){
  int size=mListeners.size();
  for (int i=0; i < size; i++) {
    if (mListeners.get(i).hasSensor(sensor)) {
      return;
    }
  }
  if (_sensors_control_activate(sensor,false) == false) {
    Slog.w(TAG,""String_Node_Str"" + sensor);
  }
}"
22993,"public void binderDied(){
  if (localLOGV)   Slog.d(TAG,""String_Node_Str"");
synchronized (mListeners) {
    mListeners.remove(this);
    mToken.unlinkToDeath(this,0);
    for (int sensor=0; sensor < 32 && mSensors != 0; sensor++) {
      if (hasSensor(sensor)) {
        removeSensor(sensor);
        try {
          deactivateIfUnusedLocked(sensor);
        }
 catch (        RemoteException e) {
          Slog.w(TAG,""String_Node_Str"");
        }
      }
    }
    if (mListeners.size() == 0) {
      _sensors_control_wake();
      _sensors_control_close();
    }
    mListeners.notify();
  }
}","public void binderDied(){
  if (localLOGV)   Slog.d(TAG,""String_Node_Str"");
synchronized (mListeners) {
    mListeners.remove(this);
    mToken.unlinkToDeath(this,0);
    for (int sensor=0; sensor < 32 && mSensors != 0; sensor++) {
      if (hasSensor(sensor)) {
        removeSensor(sensor);
        deactivateIfUnusedLocked(sensor);
        try {
          mBatteryStats.noteStopSensor(mUid,sensor);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (mListeners.size() == 0) {
      _sensors_control_wake();
      _sensors_control_close();
    }
 else {
    }
    mListeners.notify();
  }
}"
22994,"void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  operation=new SyncOperation(operation);
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false)) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.tooManyRetries) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(new SyncOperation(operation.account,operation.syncSource,operation.authority,operation.extras,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS));
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}","void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  operation=new SyncOperation(operation);
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false)) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.tooManyRetries) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(new SyncOperation(operation.account,operation.syncSource,operation.authority,operation.extras,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS * 1000));
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}"
22995,"void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  operation=new SyncOperation(operation);
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false)) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.tooManyRetries) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(new SyncOperation(operation.account,operation.syncSource,operation.authority,operation.extras,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS));
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}","void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  operation=new SyncOperation(operation);
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false)) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.tooManyRetries) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(new SyncOperation(operation.account,operation.syncSource,operation.authority,operation.extras,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS * 1000));
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}"
22996,"private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.curSchedGroup=app.setSchedGroup=Process.THREAD_GROUP_DEFAULT;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  boolean normalMode=mSystemReady || isAllowedWhileBooting(app.info);
  List providers=normalMode ? generateApplicationProvidersLocked(app) : null;
  if (!normalMode) {
    Log.i(TAG,""String_Node_Str"" + app);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    boolean isRestrictedBackupMode=false;
    if (mBackupTarget != null && mBackupAppName.equals(processName)) {
      isRestrictedBackupMode=(mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
    }
    ensurePackageDexOpt(app.instrumentationInfo != null ? app.instrumentationInfo.packageName : app.info.packageName);
    if (app.instrumentationClass != null) {
      ensurePackageDexOpt(app.instrumentationClass.getPackageName());
    }
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + processName + ""String_Node_Str""+ mConfiguration);
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,isRestrictedBackupMode || !normalMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=app.lastLowMemory=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.info.uid) {
    if (DEBUG_BACKUP)     Log.v(TAG,""String_Node_Str"" + app);
    ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
    try {
      thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,mBackupTarget.backupMode);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"");
      e.printStackTrace();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}","private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.curSchedGroup=app.setSchedGroup=Process.THREAD_GROUP_DEFAULT;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  boolean normalMode=mSystemReady || isAllowedWhileBooting(app.info);
  List providers=normalMode ? generateApplicationProvidersLocked(app) : null;
  if (!normalMode) {
    Log.i(TAG,""String_Node_Str"" + app);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    boolean isRestrictedBackupMode=false;
    if (mBackupTarget != null && mBackupAppName.equals(processName)) {
      isRestrictedBackupMode=(mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
    }
    ensurePackageDexOpt(app.instrumentationInfo != null ? app.instrumentationInfo.packageName : app.info.packageName);
    if (app.instrumentationClass != null) {
      ensurePackageDexOpt(app.instrumentationClass.getPackageName());
    }
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + processName + ""String_Node_Str""+ mConfiguration);
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,isRestrictedBackupMode || !normalMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=app.lastLowMemory=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
      br.state=BroadcastRecord.IDLE;
    }
  }
  if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.info.uid) {
    if (DEBUG_BACKUP)     Log.v(TAG,""String_Node_Str"" + app);
    ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
    try {
      thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,mBackupTarget.backupMode);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"");
      e.printStackTrace();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}"
22997,"private final void appDiedLocked(ProcessRecord app,int pid,IApplicationThread thread){
  mProcDeaths[0]++;
  if (app.thread != null && app.thread.asBinder() == thread.asBinder()) {
    Log.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ pid+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_PROCESS_DIED,app.pid,app.processName);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ pid+ ""String_Node_Str""+ thread.asBinder());
    boolean doLowMem=app.instrumentationClass == null;
    handleAppDiedLocked(app,false);
    if (doLowMem) {
      boolean haveBg=false;
      int count=mLRUProcesses.size();
      int i;
      for (i=0; i < count; i++) {
        ProcessRecord rec=mLRUProcesses.get(i);
        if (rec.thread != null && rec.setAdj >= HIDDEN_APP_MIN_ADJ) {
          haveBg=true;
          break;
        }
      }
      if (!haveBg) {
        Log.i(TAG,""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_LOW_MEMORY,mLRUProcesses.size());
        long now=SystemClock.uptimeMillis();
        for (i=0; i < count; i++) {
          ProcessRecord rec=mLRUProcesses.get(i);
          if (rec != app && rec.thread != null && (rec.lastLowMemory + GC_MIN_INTERVAL) <= now) {
            if (rec.setAdj <= VISIBLE_APP_ADJ) {
              rec.lastRequestedGc=0;
            }
 else {
              rec.lastRequestedGc=rec.lastLowMemory;
            }
            rec.reportLowMemory=true;
            rec.lastLowMemory=now;
            mProcessesToGc.remove(rec);
            addProcessToGcListLocked(rec);
          }
        }
        scheduleAppGcsLocked();
      }
    }
  }
 else   if (Config.LOGD) {
    Log.d(TAG,""String_Node_Str"" + thread.asBinder());
  }
}","private final void appDiedLocked(ProcessRecord app,int pid,IApplicationThread thread){
  mProcDeaths[0]++;
  if (app.pid == pid && app.thread != null && app.thread.asBinder() == thread.asBinder()) {
    Log.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ pid+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_PROCESS_DIED,app.pid,app.processName);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ pid+ ""String_Node_Str""+ thread.asBinder());
    boolean doLowMem=app.instrumentationClass == null;
    handleAppDiedLocked(app,false);
    if (doLowMem) {
      boolean haveBg=false;
      int count=mLRUProcesses.size();
      int i;
      for (i=0; i < count; i++) {
        ProcessRecord rec=mLRUProcesses.get(i);
        if (rec.thread != null && rec.setAdj >= HIDDEN_APP_MIN_ADJ) {
          haveBg=true;
          break;
        }
      }
      if (!haveBg) {
        Log.i(TAG,""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_LOW_MEMORY,mLRUProcesses.size());
        long now=SystemClock.uptimeMillis();
        for (i=0; i < count; i++) {
          ProcessRecord rec=mLRUProcesses.get(i);
          if (rec != app && rec.thread != null && (rec.lastLowMemory + GC_MIN_INTERVAL) <= now) {
            if (rec.setAdj <= VISIBLE_APP_ADJ) {
              rec.lastRequestedGc=0;
            }
 else {
              rec.lastRequestedGc=rec.lastLowMemory;
            }
            rec.reportLowMemory=true;
            rec.lastLowMemory=now;
            mProcessesToGc.remove(rec);
            addProcessToGcListLocked(rec);
          }
        }
        scheduleAppGcsLocked();
      }
    }
  }
 else   if (app.pid != pid) {
    Log.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ pid+ ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_PROCESS_DIED,pid,app.processName);
  }
 else   if (Config.LOGD) {
    Log.d(TAG,""String_Node_Str"" + thread.asBinder());
  }
}"
22998,"public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  SearchableInfo searchable=mSearchable;
  cancel();
  try {
    if (searchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (searchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent,searchable);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
}","public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  SearchableInfo searchable=mSearchable;
  try {
    if (searchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (searchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent,searchable);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
  dismiss();
}"
22999,"/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mActivityContext=null;
  mUserQuery=null;
}","/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mUserQuery=null;
}"
23000,"/** 
 * Update the UI according to the info in the current value of   {@link #mSearchable}.
 */
private void updateUI(){
  if (mSearchable != null) {
    mDecor.setVisibility(View.VISIBLE);
    updateSearchAutoComplete();
    updateSearchButton();
    updateSearchAppIcon();
    updateSearchBadge();
    updateQueryHint();
    updateVoiceButton();
    int inputType=mSearchable.getInputType();
    if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
      inputType&=~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      if (mSearchable.getSuggestAuthority() != null) {
        inputType|=InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      }
    }
    mSearchAutoComplete.setInputType(inputType);
    mSearchAutoCompleteImeOptions=mSearchable.getImeOptions();
    mSearchAutoComplete.setImeOptions(mSearchAutoCompleteImeOptions);
    if (mSearchable.getVoiceSearchEnabled()) {
      mSearchAutoComplete.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
    }
 else {
      mSearchAutoComplete.setPrivateImeOptions(null);
    }
  }
}","/** 
 * Update the UI according to the info in the current value of   {@link #mSearchable}.
 */
private void updateUI(){
  if (mSearchable != null) {
    mDecor.setVisibility(View.VISIBLE);
    updateSearchAutoComplete();
    updateSearchButton();
    updateSearchAppIcon();
    updateSearchBadge();
    updateQueryHint();
    updateVoiceButton(TextUtils.isEmpty(mUserQuery));
    int inputType=mSearchable.getInputType();
    if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
      inputType&=~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      if (mSearchable.getSuggestAuthority() != null) {
        inputType|=InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      }
    }
    mSearchAutoComplete.setInputType(inputType);
    mSearchAutoCompleteImeOptions=mSearchable.getImeOptions();
    mSearchAutoComplete.setImeOptions(mSearchAutoCompleteImeOptions);
    if (mSearchable.getVoiceSearchEnabled()) {
      mSearchAutoComplete.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
    }
 else {
      mSearchAutoComplete.setPrivateImeOptions(null);
    }
  }
}"
